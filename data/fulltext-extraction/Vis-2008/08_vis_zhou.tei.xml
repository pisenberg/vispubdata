<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visibility-driven Mesh Analysis and Visualization through Graph Cuts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaichi</forename><surname>Zhou</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiří</forename><surname>Bittner</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Wonka</surname></persName>
						</author>
						<title level="a" type="main">Visibility-driven Mesh Analysis and Visualization through Graph Cuts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Interior/Exterior Classification</term>
					<term>Normal Orientation</term>
					<term>Layer Classification</term>
					<term>Inside Removal</term>
					<term>Graph Cut</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper we present an algorithm that operates on a triangular mesh and classifies each face of a triangle as either inside or outside. We present three example applications of this core algorithm: normal orientation, inside removal, and layer-based visualization. The distinguishing feature of our algorithm is its robustness even if a difficult input model that includes holes, coplanar triangles, intersecting triangles, and lost connectivity is given. Our algorithm works with the original triangles of the input model and uses sampling to construct a visibility graph that is then segmented using graph cut.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>We address the following problem: given a model as a potentially unstructured set of triangles t i ∈ T where each triangle t i consists of two faces t i,1 and t i,2 . As output we want to compute a classification of all triangle faces t i, j into either inside or outside. Such an approach has several applications and we will demonstrate three in this paper: the inside removal of architectural and mechanical models for faster visualization, normal orientation and layer-based visualization of multiple layers of geometry using transparency.</p><p>We believe that previous work does not use visibility to its full potential so that classification errors are likely in more difficult models. There are two existing approaches to using visibility for inside outside classification. 1) Rays are sampled from an outside bounding volume to classify geometry as outside (e.g. <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16]</ref>, see <ref type="figure" target="#fig_0">Fig. 1 left)</ref>. This approach has difficulties with cracks and with the fact that parts of the outside surface might not be visible from an enclosing bounding volume. 2) Rays are sampled from the outside to stab the whole model. The inside-outside classification changes with each intersection (e.g. <ref type="bibr" target="#b15">[16]</ref>, see <ref type="figure" target="#fig_0">Fig. 1 middle)</ref>. This approach has also some difficulties with cracks, double sided triangles, self intersecting triangles, and coplanar triangles. In contrast, we observe that any ray path can be used to propagate inside-outside classifications, see <ref type="figure" target="#fig_0">Fig. 1</ref> right.</p><p>Our solution is to use visibility analysis to establish connections between entities that we call half-space nodes. A half-space node can correspond to a single half-space point or a (possibly infinite) set of half-space points. A half-space point is an oriented sample on a triangle and consists of a point p i in R 3 and hemisphere centered at p i . The orientation of the hemisphere is decided by the normal of a triangle face at p i . Visibility relationships between half space points are established through sampling using ray casting. The details of our algorithm include a solution on how and where to create half space nodes and how to sample rays to establish visibility relations. The second part of our approach is a classification using iterative graph cut. The main contributions of our work are the following:</p><p>• We propose a model preprocessing algorithm that can classify triangle faces into inside or outside even if the input contains coplanar polygons, self-intersections, two-sided triangles and cracks.</p><p>• We are the first to propose semi-automatic extensions to inside outside classification to increase robustness in case the automatic method is unspecified or the errors in the model are above a user defined tolerance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Challenges</head><p>There are several geometric configurations that we want to consider in this paper as explained in the following: One sided and two sided triangles: A one sided triangle has one side on the inside and one side on the outside while a two sided triangle has both faces on the outside (or inside). The main difficulty is to ensure that the algorithm can detect holes and does not classify triangle faces as outside that are only visible through an unwanted crack or hole in the model (see <ref type="figure" target="#fig_1">Fig. 2</ref> for an example illustration).</p><p>Intersections and coplanar triangles: The algorithm should be robust in the presence of self intersections and coplanar triangles (see <ref type="figure">Fig. 3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>left and right).</head><p>User input: It is unlikely that all models can be handled without some user input. In many cases, such as with terrains the question of what is inside and what is outside is actually a modeling problem that requires user input (see <ref type="figure">Fig. 3 right)</ref>. We want to make use of minimal user input to clarify ambiguous configurations and to improve robustness in difficult cases.</p><p>Inside-outside definitions: There are two fundamentally different definitions of an inside-outside classification: view-based and objectbased. The view-based definition considers all triangle faces as outside that are seen along a straight line from a bounding region, e.g. sphere, around the object. The object-based definition considers all triangle faces as outside that can be seen along a poly-line from the bounding region. The line or poly-line cannot intersect other triangles or pass through cracks in the model. Please note that only the objectbased definition establishes an inherent property of the object, while the view-based definition produces different results for different viewing regions. In this paper we focus on the object-based definition. The view-based definition is a from-region visibility problem that could be addressed with our previous work <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b19">20]</ref> as a starting point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>Surface based model repair: Surface based model repair algorithms operate directly on the input mesh and fix model errors by local modifications to the mesh. A large class of methods fixes the model errors by either stitching the boundaries of the patches together or filling the holes by inserting additional geometry <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">12]</ref>. Murali and Funkhouser <ref type="bibr" target="#b14">[15]</ref> construct a BSP tree using the input triangles and then use linear programming in order to classify the cells of the BSP either inside or outside, remove cracks and fill holes. However due  Middle: a cup where each triangle has two outside faces. Right: this is a tricky example that could have multiple interpretations. We show the interpretation as one sided object with a hole.</p><p>to the BSP and linear programming the application of this approach to large models is costly and memory demanding. Our algorithm is closely related and partially inspired by the paper of Borodin et al. <ref type="bibr" target="#b3">[4]</ref>. This paper also proposes to use visibility sampling for mesh analysis, but there are three issues that we want to improve upon: 1) The algorithm is not able to cope with coplanar polygons and intersections. 2) the algorithm computes neither a view-based nor an object-based inside-outside classification, but some mixed form.</p><p>3) The algorithm does not have a mechanism to correct sampling errors due to the ray tracer. This includes the omission of cosine-based sampling suggested by Zhang and Turk <ref type="bibr" target="#b20">[21]</ref>.</p><p>Volumetric model repair: In recent years a significant attention has been paid to techniques which repair a polygonal model by using an intermediate volumetric representation <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b1">2]</ref>. Nooruddin <ref type="figure">Fig. 3</ref>. Left: intersecting lines segments (triangles). Middle: a simple object showing three coplanar line segments (triangles). Right: A terrain has no inherent orientation. The user can specify the classification of two points in space to define inside and outside. Outside points are shown in blue and inside points in red. The algorithm suggested in this paper can correctly classify the triangles that are non-intersecting and non-coplanar. On the intersecting and coplanar triangles there would be a number of seed points (depending on the setting) that are classified as inside or outside.</p><p>and Turk <ref type="bibr" target="#b15">[16]</ref> convert the model into a volumetric grid. They perform inside outside classification of the cells of the grid by using ray casting. The grid is processed using morphological operations. Finally, the model is converted back to a polygonal representation. Ju <ref type="bibr" target="#b9">[10]</ref> extends this approach by using an octree instead of a regular grid. This method uses a more efficient local approach for the inside outside classification of the cells of the octree. For the conversion to the polygonal model he suggests to use dual contouring which is able to better preserve sharp features of the model. Bischoff et al. <ref type="bibr" target="#b1">[2]</ref> proposed a method which is able to robustly handle interpenetrating geometry or dangling triangles. This method also uses octree based voxelization, which is followed by hole filling using morphological operations and an extension of the dual contouring <ref type="bibr" target="#b10">[11]</ref>. The common problem of volumetric methods is that they perform low pass filtering of the input geometry. Therefore they have problems with preserving sharp features and thin structures of the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Overview</head><p>The pipeline of our algorithm consists of four stages (see below):</p><p>Preprocessing: In the preprocessing step we load a model as triangle soup. In the basic version of the algorithm we mainly use three preprocessing steps. We build a kd-tree, we mark triangles that intersect other triangles, and we mark triangles that are coplanar with other triangles. Alternatively, we also use three more sophisticated preprocessing techniques that are optional. We can make use of connectivity and geometry information to construct clusters of triangles, we can compute exact triangle intersections, and we can remove coplanar triangles. The latter two computations are fairly difficult and not as robust as the other parts of the pipeline. For example, triangle intersections can often lead to many small additional triangles that are a disadvantage for many applications. See section 2 for details.</p><p>Sampling: In the sampling stage we create half-space nodes on triangle surfaces and shoot rays to sample visibility connections to other half space nodes. The methodology combines ideas from visibility, geometry, and global illumination to obtain a robust sampling strategy for the creation of half space nodes and the generation of rays. See section 3 for details.</p><p>Classification: The classification step analyzes the graph using a max-flow, min-cut algorithm to classify half space nodes as either inside or outside. Additionally, we provide a user input to set some global parameters of the classification, or to locally refine the computation in case of difficult geometric configurations. See section 4 for details.</p><p>Application and Results: The algorithm can be used for normal orientation, inside removal, or layer classification. We present a few more details on how to fine tune the pipeline for these applications in section 5 including a variety of results on selected example models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PREPROCESSING</head><p>The input to our algorithm is a set of n 0 triangles t i , with 1 ≤ i ≤ n 0 . In this section we explain six preprocessing steps: 1) kd-tree construction, 2) intersection testing, 3) coplanar testing, 4) intersection retriangulation, 5) coplanar triangle removal, and 6) patch clustering. The first three steps are required for all models and the second three are optional.</p><p>Our main philosophy is to establish a conservative and robust model processing algorithm. We found that the two optional preprocessing steps intersection retriangulation and coplanar triangle removal give undesirable results in many cases. The main focus of this paper is therefore to establish robustness despite geometric errors and inaccuracies rather then to fix these problems. A general problem with intersection retriangulation is the long implementation time for a correct algorithm and the many (often very thin) triangles that can be generated in the process (see <ref type="figure" target="#fig_2">Fig. 4</ref> for an example intersection retriangulation). Coplanar triangle removal shares the same problems of intersection retriangulation. Additionally, it is unclear how coplanar triangles can be removed in textured models, because there are multiple textures or texture coordinates to choose from. As default we will assume that only the required steps are performed and will note additional optional preprocessing steps for each model.</p><p>Kd-tree construction: All triangles in the model are sorted into a kd-tree to accelerate ray casting. The kd-tree construction and the ray tracer are an improved version of multi-level ray tracing <ref type="bibr" target="#b16">[17]</ref>. The kdtree construction takes under two minutes for the largest model in the paper.</p><p>Intersection Test: The intersection test is performed for each triangle t i ∈ T and outputs a flag inters i ∈ {true, f alse} that is true if the triangle intersects another triangle and is f alse if the triangle does not intersect another triangle. The algorithm has to be conservative, i.e. two non-intersecting triangles can be incorrectly classify as intersecting but not the other way around. The reason for this conservative strategy is that the subsequent sampling and classification steps more carefully analyze intersecting triangles. Therefore, the first type of misclassification does not lead to any problems. We proceed as follows. We first use the kd-tree to select a list of intersection candidate triangles. We can find a set of candidate triangles CSet i by computing the bounding box B i of triangle t i and then taking all triangles that are stored with the leaf nodes of the kd-tree that intersect the bounding box B i . For each triangle t j ∈ CSet i we compute an intersection using the algorithm proposed by Moeller <ref type="bibr" target="#b12">[13]</ref>. Alternate intersection routines are described in <ref type="bibr" target="#b13">[14]</ref> chapter 13. We choose the first algorithm, because we found it easier to modify to make it conservative. The main idea of the conservative intersection tests is to introduce ε thresholds. We omit a very detailed description because it would be very lengthy due to many special cases and the ε intersection algorithm is not a contribution of our paper. Some of the special cases arise due to degenerate intersections and overcoming floating point limitations. Please note that we do not consider triangles sharing a vertex or an edge as intersecting. These cases are explicitly excluded in the implementation.</p><p>Coplanarity Test: The conservative coplanarity test for triangles is performed for each triangle t i and outputs a flag cpl i ∈ {true, f alse} that is true if the triangle is coplanar to another triangle and is f alse otherwise. The test is conservative because we use ε thresholds as in the intersection computation. The algorithm proceeds as follows. We reuse the candidate set CSet i to test each triangle t j ∈ CSet i . We compute the angle α between the plane containing t i and the plane containing t j with a normal vector dot product. If α indicates parallel plane orientation we proceed to test the distance d i j between the two closets points on t i and t j . If the distance is within an ε threshold we finally project t i into the plane of t j and use a two-dimensional version of the triangle intersection test <ref type="bibr" target="#b12">[13]</ref>. If the triangles intersect they are both marked as coplanar.</p><p>Triangle Clustering: The idea of this stage is to cluster triangles that can be classified together. The clustering algorithm assumes that all connected triangles are part of orientable surface patches. The clustering algorithm is a simple greedy algorithm that needs two main parts: the clustering algorithm itself and a preprocessing algorithm that marks each triangle edge with a flag ∈ true, f alse that indicates if triangles that share this edge can be clustered. In the following we first explain how to compute the edge flag and then give the algorithm outline. The edge flag is set to true by default and then we set the flag to f alse in the following cases: 1) the edge belongs to a triangle with inters i = true or 2) cpl i = true; 3) the edge is non-manifold, i.e. it is shared by more then two triangles, and 4) the edge belongs to a triangle that is too close to another non-adjacent triangle.</p><p>The clustering algorithm marks all triangles of the model as not visited using a boolean flag per triangle. Iteratively, the first not visited triangle is selected to start a new cluster. The cluster is expanded by adding other triangles that share edges marked true using breath first search. If there is only one triangle in a cluster we assign the cluster id cluster i = −1 and otherwise we set the cluster id of all triangles in the cluster using a counter to ensure unique cluster ids.</p><p>Intersection Re-triangulation: The idea of intersection retriangulation is to re-triangulate triangles so that no triangle is intersected by another one. While the output of this algorithm is a very helpful simplification of a general input, we believe that the actual use of the algorithm is controversial, because it can create many additional triangles and it is difficult to implement correctly. The triangle intersection algorithm for a triangle t i proceeds similar to the intersection test and first computes intersection candidates and then triangle intersections. For each triangle intersection we store the intersection lines l j in a set LineS i . After all intersection lines are computed we retriangulate t i using constrained Delauney triangulation <ref type="bibr" target="#b17">[18]</ref>. More robust triangulations can be computed with the CGAL library <ref type="bibr" target="#b5">[6]</ref>. See <ref type="figure" target="#fig_2">Fig. 4</ref> for an examples. Coplanar Removal: The coplanar triangle removal uses the result of the coplanarity test. Coplanar triangles are projected into one plane and the resulting polygon is retriangulated.</p><p>Output of Preprocessing: At the end of preprocessing we obtain a set of n triangles t i , with 1 ≤ i ≤ n. If steps four and five are not performed n = n 0 . Additionally, each triangle i has a flag cpl i ∈ {true, f alse} to denote if the triangle has other coplanar triangles and a flag inters i ∈ {true, f alse} to denote if the triangle is intersecting other triangles. If triangle clustering is used we store a cluster identifier cluster i with each triangle. The goal of the sampling stage is to generate a visibility graph G(V, E) consisting of half-space nodes hsn i ∈ V , virtual nodes ∈ V , and edges ∈ E that encode visibility connections between the nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SAMPLING</head><p>We divide the process into two steps: geometry sampling for node generation and visibility sampling. In principal the nodes in the graph correspond to geometry. We want to classify the nodes into inside and outside and then later transfer the node classification back to the geometry. These are then our two fundamental ideas on how to design such a graph:</p><p>1. The goal for the node design is to create nodes that correspond to geometry that can receive a consistent classification. This will result in a solution where more nodes are placed in difficult parts and fewer nodes are placed in easy parts of the model. For example, intersecting and coplanar triangles are difficult, because the visibility classification is expected to change within a triangle and we cannot assume that we can classify the faces of such a triangle consistently. On the other extreme, triangles within a triangle cluster will have two sets of faces so that the classification within each of the two sets is consistent.</p><p>2. The goal for edge design is to generate edge weights that measure how strong the visibility between two nodes is. Therefore, we propose to use a measure in ray space that corresponds to how many visible rays exist between two nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Geometry Sampling</head><p>We define a half-space point as a point in R 3 and a set of viewing directions on a hemisphere Ω. Typically, the half-space point is a sample on a triangle and the hemisphere is defined by the normal vector of one of the two triangle faces.</p><p>A half-space node corresponds to either a single half-space point or a set of half-space points (see <ref type="figure" target="#fig_3">Fig. 5</ref>). We use different methods to generate half-space nodes for triangle clusters and the coplanar and intersected triangles:</p><p>Triangle Clusters: All the triangles belonging to a triangle cluster give rise to two sets of triangle faces f s 1 and f s 2 that will have the same inside-outside classification. Only two half space nodes are generated for a triangle cluster. One for all half space points on triangle faces in f s 1 and one for all half-space points on triangle faces in f s 2 . Note that a single triangle is just a special case of triangle cluster.</p><p>Intersected and Coplanar Triangles: A predefined number of sample points are distributed over each intersected triangle. Each point contributes two half space nodes in the graph. We propose three sampling schemes to distribute the points: 1) Uniformly sample the triangle. 2) Uniformly sample the polygonal face, plus sample along the polygon's edges. 3) Compute all the intersection edges on the face (for coplanar faces, first project all the coplanars onto the interested face's plane), triangulate the face and uniformly sample the sub-faces.</p><p>The sampling quality increases from the first method to the third, but the time complexity also increases. In our experiments, we found that the second scheme generates good results for most of the models. To avoid potential numerical issues of ray casting, we need to detect whether the selected sample point is within an epsilon proximity of other triangles. For each of the other triangles intersected or coplanar with the current triangle, the distance from the point to its plane is computed and also the point is projected onto its plane to see if the point really falls inside the triangle. The half space point is offset along the normal of the furthest triangle that satisfies the proximity test above. <ref type="figure" target="#fig_4">Fig. 6</ref> illustrates the adjustment. Virtual Nodes: The graph always contains at least two virtual nodes, one of which represents the outside and the other represents the inside. Later, we will compute a cut in the graph to compute two disjunct sets of nodes. The set of nodes that contains the outside node (inside node) will be classified as outside (inside).</p><p>The sampling stage first creates the half-space nodes and then stochastically samples visibility between half-space nodes using ray casting. During this process a number of half-space points is generated for each half-space node. The details will be described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Visibility Sampling</head><p>The constructed graph of halfspace nodes contains edges with weights. The weight of an edge connecting two halfspace nodes should reflect the amount of visibility between the corresponding patches. In the next section we derive the weight assignment and then we describe how the weights are established using ray casting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Weight Assignment</head><p>We desire that the weight of connection of two patches in the scene reflects the amount of their mutual visibility. Mutual visibility of two patches has been studied intensively in the context of radiosity methods which aim to simulate illumination of diffuse environments. In radiosity methods the visibility between patches drives the amount of power exchanged between them.</p><p>Inspired by these methods, we define the weight of an edge connecting two patches (half-space nodes) as the average amount of power transferred between these patches. The power transfer from patch i to patch j is:</p><formula xml:id="formula_0">P i j = A i B i F i j (1)</formula><p>where A i is the area of patch i and F i j is the form factor between patches i and j. Assuming all patches have unit radiosity (B i = 1) we get P i j = A i F i j . The form factor F i j is given by the following equations <ref type="bibr" target="#b6">[7]</ref>:</p><formula xml:id="formula_1">F i j = 1 A i A i A j F(x, y)dA j dA i<label>(2)</label></formula><p>where x and y are points on patches A i and A j respectively, dA i and dA j are differential surface areas, and F(x, y) is the point-to-point form factor defined as:</p><formula xml:id="formula_2">F(x, y) = (Θ xy N x )(−Θ xy N y ) πr 2 xy V (x, y)<label>(3)</label></formula><p>where Θ xy is a unit direction vector from x to y, N x (N y ) is the patch normal vector at x(y), r xy is the distance between x and y, and is the inner product. V (x, y) is the visibility function given as:</p><formula xml:id="formula_3">V (x, y) =</formula><p>1 if a ray from point x hits point y 0 otherwise</p><p>From the definition of the form factor, we can see that A i F i j = A j F ji and thus P i j = P ji .</p><p>The form factors can be computed using ray casting as follows: If we originate a ray from a uniformly chosen location on patch i and shoot into a cosine-biased direction (i.e. the probability of the direction depends on the cosine between the direction and the patch normal), the probability of such a ray lands on patch j is equal to the form factor F i j <ref type="bibr" target="#b6">[7]</ref>. Thus we can estimate for sufficiently large number of rays: F i j ≈ F i j = n i j /n i where n i j is the number of rays shot from patch i and landed on patch j and n i is the total number of rays shot from patch i. From F i j and F ji we can compute estimates of power exchange P i j and P ji . The weight of the link between patches i and j is then defined as the average of the two power exchange estimates:</p><formula xml:id="formula_5">w(i, j) = 1 2 ( P i j + P ji ) = 1 2 (A i n i j n i + A j n ji n j )<label>(5)</label></formula><p>The weight w(i, j) can also be interpreted as the measure of rays which connect the two patches. In order to support this intuition we provide the following substitution: Assuming uniformly distributed rays we know that</p><formula xml:id="formula_6">n i ≈ n A i A , n j ≈ n A j</formula><p>A , where n is the total number of rays cast and A is the total area of patches. By substitution we can rewrite Eq.5 as:</p><formula xml:id="formula_7">w(i, j) ≈ A 2 n i j + n ji n<label>(6)</label></formula><p>Thus the defined weight corresponds to the ratio of the number of rays connecting the two patches with respect to all rays cast with a constant scale factor A 2 . Note that the area of a patch is the sum of the areas of all the triangles belonging to the patch. If a half space node represents a single half space point on a triangle the patch corresponds to a voronoi region on the triangle (the details will be discussed in section 3.2.2). Since the samples are mostly uniformly distributed on the triangles, it is reasonable to assume that each such voronoi region has the same area, which is the triangle's area divided by the number of samples on the triangle.</p><p>The rays hitting void from a half space node i contribute to the connection between node i and the outside node. The geometrical meaning of the outside node is the bounding sphere of the scene. The weight is defined as:</p><formula xml:id="formula_8">w o (i) = A i (1 − ∑ j n i j n i )<label>(7)</label></formula><p>Note that this weight is not reciprocal, since we do not shoot rays from the bounding sphere. Based on geometrical probability, the form factor computation stays valid if we shoot rays from the bounding sphere and count the number of hits landed on each node. Nevertheless, it is inefficient and unnecessary. To embody the inside node in a geometric sense is problematic. One of the workarounds is that the user assigns a region on the surface or a volume in space as inside. Then we can shoot rays from such regions to build the connection between half space nodes and the inside node. Without users' guidance, we contribute one half space node's outside weight to its opposite half space node's inside weight: w i (opp(i)) = w o (i) where opp() is an operator to find out node i's opposite half space node. Due to the imperfection of the geometry, the sampling may incorporate some amount of errors (see <ref type="figure" target="#fig_5">Fig. 7</ref>). Thus we apply a cos filter to dampen the error fraction. For each node i,</p><formula xml:id="formula_9">w max (i) = max{w(i, j), w o (i), w i (i)}, ∀ j<label>(8)</label></formula><p>Our directed filter function is defined as:</p><formula xml:id="formula_10">f ilter(w(i, j)) = 1 2 (1 + cos(π − π w(i, j) w max (i) ))w(i, j)<label>(9)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Ray Casting</head><p>The start locations of the sampling rays are generated uniformly in the region each half space node possesses. Specifically, for a cluster half space node, one triangle of the cluster is selected according to its area and the location is uniformly distributed on the triangle. The directions are sampled on the corresponding hemisphere with a cosine-distributed probability. If a sampling ray shot by node i hits a triangle belonging to a cluster, then a connection is built between the corresponding cluster node and node i. If the hit triangle is either an intersected one or a coplanar one, we aim at estimating visibility in such a manner that a single half space point represents a voronoi region on the triangle instead of a single point (see <ref type="figure" target="#fig_6">Fig. 8</ref>). As we want to avoid complex computations we only try to compute a fast estimate that results in robust visibility classifications. We therefore snap the ray to a half space node j on the triangle closest to the hit point. Since we only originate rays from one location of such node, which is the center of its voronoi region, the form factor integral is biased. Due to the fact that P i j = A i F i j = A j F ji = P ji , we reduce the variance by using P ji only as the weight between node i and node j instead of</p><formula xml:id="formula_11">P i j +P ji 2</formula><p>, if node j is not a single half space point. Another important special case with snapping occurs when visibility changes between the ray hit and the snapped half space point. In order to discover this case we test reverse visibility by shooting a reverse ray from the node snapped on to the sampling ray's origin. The right of <ref type="figure" target="#fig_6">Fig. 8</ref> shows a case where visibility changes in a voronoi region. Node B's sampling ray hits a triangle and the hit is snapped onto Node A, but a reverse ray from Node A to Node B is blocked by other geometry in between. Therefore the ray hit from Node B to A is discarded. Please note that while visibility is symmetric in general, in this case visibility is not symmetric. This is because the starting point of the reverse ray is not the end point of the original ray. <ref type="figure">Fig. 9</ref>. The visibility graph built from the input geometry on the left.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CLASSIFICATION</head><p>This section describes how the visibility graph can be processed to obtain an inside and outside classification of each node in the graph. The algorithm is basically a graph clustering or segmentation algorithm. There are several older but powerful algorithms, such as k-means, single-link, agglomerative, or Ward's algorithm that could be transferred to our problem. See Tan et al.'s book <ref type="bibr" target="#b18">[19]</ref> for a review of these techniques. While these algorithms can be fast, they are not guaranteed to produce optimal results. In contrast, many new techniques rely on spectral matrix decompositions.</p><p>Our problem is given as follows. The sampling stage generates a visibility graph G = V, E (see <ref type="figure">Fig. 9</ref>). An inside-outside classification of N half space nodes can be denoted by a binary vector X = <ref type="figure" target="#fig_0">(x 1 , x 2 ,...,x N )</ref>, where x i = 1 if node i is outside, otherwise x i = 0. We define an energy function for the classification proportional to the visibility connections that have to be cut:</p><formula xml:id="formula_12">E(X) = ∑ (i, j)∈E w i j δ i j<label>(10)</label></formula><p>where w i j is the weight between node i and j, and</p><formula xml:id="formula_13">δ i j = 1 if x i = x j 0 if x i = x j<label>(11)</label></formula><p>The minimization of this energy function defines an inside-outside classification with minimal visibility errors. The optimal solution can be computed by the algorithm of Boykov and Jolly <ref type="bibr" target="#b4">[5]</ref>. This algorithm was proposed in the context of image processing and it was designed to work with graphs where each node has only a few incident edges. Our experiments show that the algorithm still performs well for graphs with denser (visibility) connections. This is partially due to the fact that we do not shoot a very large numbers of rays to estimate visibility. <ref type="figure" target="#fig_0">Fig. 10</ref> shows a visualization of an example graph. In complex situations the algorithm does slow down and can take several minutes. This classification algorithm can be computed once or iteratively depending on the application. In the next section we will show several example applications that we implemented and explain how they setup the classification. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPLICATIONS</head><p>Inside Removal: Inside removal of models can be computed by one iteration of the sampling and classification step. All triangles that are associated with an outside half space node are considered to be in layer one. All other triangles can be removed. See <ref type="figure" target="#fig_0">Fig. 11</ref> and 22 for an example.</p><p>Normal Orientation: Normal orientation of a model is computed by one iteration of the sampling and classification step. The user can decide the front face vertex order, i.e. if triangles should be oriented in clockwise or counterclockwise order. All triangle faces associated with exactly one outside half-space node, or triangles with multiple agreeing half space nodes are oriented according to the user setting. Triangles associated with multiple half space nodes that indicate a conflicting inside-outside classification are typically duplicated and two triangles with the two possible orientations are created. We found that to be the most intuitive output of normal orientation for general models (see <ref type="figure" target="#fig_0">Fig. 13</ref>). If the application requires one triangle face to be outside <ref type="figure" target="#fig_0">Fig. 11</ref>. Left: The outside of the house model. The model was created by stacking boxes, so that almost all triangle-edges are non-manifold, and most faces are coplanar. Right: The interior geometry that was removed. <ref type="figure" target="#fig_0">Fig. 12</ref>. Left: the outer layer of the blgd2 model. Right: the inside polygons that were removed. and one triangle be face to be inside, i.e. one normal per triangle, we can pick the orientation where the sum of edge weights to the outside is bigger. Layer Computation and Visualization: Layer computation can help to gain insight into the internal structure of a model. Layers can be computed by multiple iterations of the classification step and an edge reweighing step. The first iteration computes the first layer. After the first iteration the edges connected to inside nodes associated with triangles in the first layer are connected to the source (the outside). Then the classification step is repeated. The layer computation can be used to assign different transparency values to different layers. See <ref type="figure" target="#fig_0">Fig. 14 and Fig. 16</ref> for examples where we render transparency based on an Nvidia whitepaper <ref type="bibr" target="#b7">[8]</ref>. While this application has been suggested by previous authors our contribution is the improved definition and computation of inside and outside layers. See <ref type="figure" target="#fig_0">Fig. 15</ref> for the separate layers.</p><p>Interactive Editing and Mesh Analysis: The framework also includes the ability to interact with the visibility graph. A user can define additional nodes on the model or in free space and manually set weights of edges and classifications of nodes. We do not use interac-  tive editing for the results in this paper, because that would skew the comparison with other approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>We present the running times of our algorithm on a small set of models. The models were selected to include some variety of how difficult the models are and how many sharp features they possess. For each model we run one inside-outside classification for inside removal. We list the number of polygons of the input model, the number of polygons of the output, as well as the complete running time (See <ref type="table" target="#tab_1">Table 1</ref>). We also include an informal comparison with Ju's PolyMender software <ref type="bibr" target="#b9">[10]</ref> available at his web page <ref type="bibr" target="#b0">1</ref> . PolyMender needs to scan the input models into a hierarchical grid. One parameter maxd allows the user to control the maximal depth of the octree. In our experiments, we tune the parameters for PolyMender to capture the details of different models. Polymender generates an order of magnitude more triangles for the models house, building 2, and mechanic 1. A main reason is that coplanar faces seem to force a very detailed voxelization. Most of the models are well reconstructed with maxd = 9. The bird skeleton contains many detailed structures and requires maxd = 10. For simpler models such as the Turbine and Skull we set maxd = 8. We use the version dc-clean for all models except for the bird which uses dc. While our algorithm cannot compete with Polymender's hole filling functionality, we believe that the results underline that our proposed system can complement volumetric methods well. We also list a breakdown of our running times for the three major steps clustering, sampling, and graph cut in <ref type="table" target="#tab_3">Table 2</ref>. In the same table we list statistics about the graph and memory consumption. The main parameters of our algorithm are the number of random samples, the number of border samples, the number of rays per node, the threshold for the intersection computation and the threshold for the coplanarity computation. For these tests we made a binary correct or not correct decision based on visual inspection. See <ref type="table">Table 3</ref> and <ref type="table">Table 4</ref> for the results. We measured the influence of clustering on three models (see <ref type="table">Table 5</ref>). Even though we do not perform clustering in the second column, we still have to run the intersection <ref type="bibr" target="#b0">1</ref> http://www.cse.wustl.edu/ taoju/code/polymender.htm and coplanarity tests <ref type="figure">(I[s]</ref>). Note that the skull is an extreme case that benefits a lot from clustering, as it has very large connected components; the others are just normal cases where both connected mesh and intersected triangles both exist. The third column simulates a triangle soup case by randomly messing up selected triangles. The clustering algorithm typically improves the overall running time because it reduces the number of nodes and edges in the visibility graph processed by the graph cut algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alg.</head><p>Tri </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>In this section we want to compare to previous work, identify contributions and open problems that are of interest for future research. Mesh Repair: Our algorithm performs several steps of a mesh repair framework, but we do not currently address hole filling, a major challenge that is implemented in some previous mesh repair systems, e.g. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10]</ref>. However, the problem of hole filling is not solved by previous work and it remains an inherently difficult topic. Many cases require user input to be resolved. Our major avenue for future work is to determine how the visibility graph can be used to let a user specify hints for hole filling.</p><p>Inside Outside Classification: We believe that our algorithm significantly improves the state of the art, because we make better use of visibility information. Previous work, especially Borodin et al. <ref type="bibr">[</ref>   <ref type="table">Table 3</ref>. We evaluate the parameters number of random samples (RS), number of border samples (BS), and the number of rays per node (RperN) on two selected models. We always keep two parameters the same and vary the other one. As result we report the running time. The lowest running time that produces a correct result is highlighted in red.</p><p>and Murali et al. <ref type="bibr" target="#b14">[15]</ref> make many assumptions about the model and are therefore not robust to intersecting and coplanar triangles. On the other hand volumetric methods <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10]</ref> can deal with a larger number of inputs, but they are not able to classify the original geometry. As a result a significant increase in triangles is likely for all models that do not have a nice uniform triangulation. Furthermore, our experience with the Polymender software <ref type="bibr" target="#b9">[10]</ref> shows that there are some robustness issues that would have to be resolved. We therefore argue that our algorithm is the best available choice for inside-outside classification and related applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We presented a robust visibility based geometry analysis algorithm that takes a triangular model as input and computes an inside and outside classification of oriented triangle faces. We show how to use this classification for three example applications: inside removal, normal orientation, layer-based visualization. The core idea of out framework is to propagate visibility using ray casting and to compute a classification using graph cut. We believe that our algorithm is a significant  <ref type="table">Table 4</ref>. We list the setting for three models for the threshold parameters that produce correct results: threshold for the intersection detection (I-thresh) and threshold for the coplanar detection (C-thresh). The parameter range was determined by running a large number of tests with different thresholds and subsequent visual inspection of the results.  <ref type="table">Table 5</ref>. Running times for clustering(C), sampling(S), intersection(I), and graph cut(G) technical improvement over previous techniques.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Triangles (line segments) are shown in black, vertices as grey spheres, an outside classification is shown in blue and an inside classification is shown in red. Left: Classification of outside geometry by sampling visibility from a bounding sphere around the scene. Middle: stabbing the object along straight lines and alternating outside inside classification. Right: propagating inside and outside classification along an arbitrary path.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Triangles (line segments) are shown in black, vertices as grey spheres, an outside classification is shown in blue and an inside classification is shown in red. Left: a typical example of a one sided object.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>The images on the left show the bird model before triangle splitting. The images on the right show the bird model after splitting. All triangles considered for splitting are shown in red. Please note the high number of thin polygons in the closeup view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Three cases of half-space nodes. Left: a single half-space point. Middle: the set of half-space points on one triangle face. Right: all half-space points on a cluster of triangle faces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Coplanar and intersected samples are adjusted to the surface of the furthest triangle that satisfies the proximity test.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>A 2D illustration of visibility filtering for a cave model. Thicker line segments represent triangle faces in 3D. Thinner blue lines represent outside normals of the faces and red ones represent inside normals. Left: An undesirable classification occurs because rays pass through small cracks between faces. These rays are shown as dotted line. The visibility propagated through the small cracks outweighs the visibility propagated through the main entrance of the cave (shown as straight line). Right: The weights are filtered so that the algorithm gives less weight to smaller cracks resulting in the desired classification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Left: Voronoi regions formed by single half space nodes in a triangle. Right: A ray hit from Node B is snapped onto Node A, which is not visible from Node B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10 .</head><label>10</label><figDesc>Left: An example visibility graph. Nodes are shown in green and red and graph-edges in black. Right: All graph-edges connected to a selected node are highlighted in pink.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13 .</head><label>13</label><figDesc>Left: the bird model with front facing (outside) triangles in blue and back facing (inside) triangles in red. Middle: reoriented normals. Right: The model is difficult to process due to the thin (coplanar) structures shown in yellow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 14 .</head><label>14</label><figDesc>Left: The skull model with the first layer in blue and the second layer in red. Right: layer visualization in the motor model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 15 .</head><label>15</label><figDesc>Three layers of the top of the motor model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 16 .</head><label>16</label><figDesc>Left: The turb model with the first layer in blue and second layer in red. This model is an illustration of the difference of the viewbased and object-based inside-outside classification. Please note that the interior pipe structure is correctly classified as outside because it is reachable through several smaller pipes. Right: a closeup.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>− 6 −</head><label>6</label><figDesc>10 −2 10 −5 − 10 −2 mech1 26 25 30 10 −6 − 10 −3 10 −5 − 10 −2 motor 5 21 20 10 −6 − 10 −2 10 −5 − 10 −2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>•</head><label></label><figDesc>Kaichi Zhou graduated from Arizona State University and is now with NVIDIA, E-mail: kaichi.zhou@gmail.com. • Eugene Zhang is with Oregon State University, E-mail: zhange@eecs.oregonstate.edu • Jiří Bittner is with Czech Technical University in Prague, E-mail: bittner@fel.cvut.cz • Peter Wonka is with Arizona State University: E-mail: pwonka@gmail.</figDesc><table /><note>com Manuscript received 31 March 2008; accepted 1 August 2008; posted online 19 October 2008; mailed on 13 October 2008. For information on obtaining reprints of this article, please send e-mailto:tvcg@computer.org.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>The table lists the number of input triangles (Tri.In) and output triangles (Tri.Out) and total computation time in seconds. We compare our results (VGC: Visibility Graph Cut) against Ju's PolyMender (version 1.7).</figDesc><table><row><cell></cell><cell></cell><cell cols="3">.In# Tri.Out# Time [s]</cell></row><row><cell>house</cell><cell>VGC JU</cell><cell>24K 24K</cell><cell>11K 1.9M</cell><cell>89.1s 14.97s</cell></row><row><cell>bird</cell><cell>VGC JU</cell><cell>111K 111K</cell><cell>92K 1.1M</cell><cell>17.6s 8.37s</cell></row><row><cell>bldg1</cell><cell>VGC JU</cell><cell>93K 93K</cell><cell>85K 791K</cell><cell>43.9s 17.812s</cell></row><row><cell>bldg2</cell><cell>VGC JU</cell><cell>33K 33K</cell><cell>22K 897K</cell><cell>22.7s 6.687s</cell></row><row><cell>mech1</cell><cell cols="2">VGC 1.04K JU 1.04K</cell><cell>1.03K 861K</cell><cell>5.52s 3.062s</cell></row><row><cell>mech2</cell><cell>VGC JU</cell><cell>25K 25K</cell><cell>23K 742K</cell><cell>3.75s 2.34s</cell></row><row><cell>turb</cell><cell cols="2">VGC 1.76M JU 1.76M</cell><cell>1.76M 843K</cell><cell>66.5s 46.18s</cell></row><row><cell>skull</cell><cell cols="2">VGC 1.16M JU 1.16M</cell><cell>1.16M 1.61M</cell><cell>47.89s 44.31s</cell></row><row><cell>motor</cell><cell>VGS JU</cell><cell>140k 140k</cell><cell>44k 1.5M</cell><cell>74.14s 17.016s</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>The break-down of computation times for each model and running times in seconds for clustering (C) , sampling (S), and graph cut (G). Further we list the number of rays used in the sampling stage (Rays), the number of nodes (Node) and edges (Edge) of the visibility graph, and the memory consumption (Mem).</figDesc><table><row><cell>RS = 5, BS = 30, RperN =</cell><cell>8</cell><cell>16</cell><cell>32</cell><cell>48</cell><cell>64</cell></row><row><cell>house, time=</cell><cell cols="5">49s 89s 206s 327s 382s</cell></row><row><cell>RS = 5, RperN = 16, BS =</cell><cell>6</cell><cell>15</cell><cell>24</cell><cell>30</cell><cell>36</cell></row><row><cell>house, time=</cell><cell cols="2">23s 44s</cell><cell>68s</cell><cell>89s</cell><cell>121s</cell></row><row><cell>BS = 30, RperN = 16, RS =</cell><cell>0</cell><cell>5</cell><cell>10</cell><cell>15</cell><cell>20</cell></row><row><cell>house, time=</cell><cell cols="5">75s 89s 102s 121s 143s</cell></row><row><cell>RS = 10, BS = 0, RperN =</cell><cell>8</cell><cell>16</cell><cell>32</cell><cell>48</cell><cell>64</cell></row><row><cell>bird, time=</cell><cell>7s</cell><cell>17s</cell><cell>22s</cell><cell>32s</cell><cell>42s</cell></row><row><cell>RS = 10, RperN = 16, BS =</cell><cell>0</cell><cell>6</cell><cell>15</cell><cell>24</cell><cell>30</cell></row><row><cell>bird, time=</cell><cell cols="2">17s 35s</cell><cell>59s</cell><cell cols="2">108s 146s</cell></row><row><cell>BS = 0, RperN = 16, RS =</cell><cell>5</cell><cell>10</cell><cell>15</cell><cell>20</cell><cell>25</cell></row><row><cell>bird, time=</cell><cell>8s</cell><cell>17s</cell><cell>33s</cell><cell>52s</cell><cell>79s</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>/1.4/0.06) 194 (21.4/145/28) 161 (135.2/25.9) motor 25 (3.5/20/1.5) 48 (2.3/43.2/2.5) 11 (10.1/0.5)</figDesc><table><row><cell></cell><cell>Clustering</cell><cell>No Clustering</cell><cell>Triangle Soup</cell></row><row><cell></cell><cell>(C[s]/S[s]/G[s])</cell><cell>(I[s]/S[s]/G[s])</cell><cell>(S[s]/G[s])</cell></row><row><cell>bird</cell><cell>18 (7.3/9.1/1.2)</cell><cell>25 (3.5/18.7/3)</cell><cell>11 (10.1/1.1)</cell></row><row><cell>skull</cell><cell>47 (46</cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors acknowledge the contribution of all the reviewers and financial support from NSF IIS-0612269, NSF CCF-0643822, NSF CCF-0546881, and grant LC-06008 from the Czech Ministry of Education, Youth and Sports. We thank Will Schroeder, Ken Martin, Bill Lorensen, Bruce Teeter, Terry Yoo, Mark Levoy and the Stanford Graphics Group for the 3D models in this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Filling gaps in the boundary of a polyhedron</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barequet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sharir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="207" to="229" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatic restoration of polygon models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bischoff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pavic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1332" to="1352" />
			<date type="published" when="2005-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A topology-based approach for sell-closure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Bøhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wozny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Geometric Modeling for Product Realization</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="297" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Consistent normal orientation for polygonal meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Zachmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics International</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="18" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive graph cuts for optimal boundary and region segmentation of objects in n-d images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Boykov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-P</forename><surname>Jolly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="105" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Computational geometry algorithms library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cgal</surname></persName>
		</author>
		<ptr target="www.cgal.org" />
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Advanced Global Illumination</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Dutre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bekaert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>AK Peters</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Interactive order-independent transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Everitt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Cutting and stitching: Converting sets of polygons to manifold surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="136" to="151" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Robust repair of polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="888" to="895" />
			<date type="published" when="2004-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dual contouring of hermite data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Losasso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="339" to="346" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Filling holes in meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liepa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Geometry Processing</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="200" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A fast triangle-triangle intersection test</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Möler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graphics Tools</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="25" to="30" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Real-Time Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Haines</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">1568811829</biblScope>
		</imprint>
	</monogr>
	<note>Second Edition. A. K. Peters Limited</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Consistent solid and boundary representations from arbitrary polygonal data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Murali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1997 Symposium on Interactive 3D Graphics</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Simplification and repair of polygonal models using volumetric techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">S</forename><surname>Nooruddin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="191" to="205" />
			<date type="published" when="2003-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Multi-level ray tracing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Reshetov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Soupikov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hurley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1176" to="1185" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Triangle: Engineering a 2D quality mesh generator and delaunay triangulator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shewchuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WACG: 1st Workshop on Applied Computational Geometry: Towards Geometric Engineering</title>
		<imprint>
			<publisher>WACG</publisher>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Introduction to Data Mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-N</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Steinbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Addiso Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Guided visibility sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wonka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Maierhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hesina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Reshetov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="494" to="502" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Visibility-guided simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
