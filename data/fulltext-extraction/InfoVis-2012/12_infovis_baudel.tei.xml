<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Capturing the Design Space of Sequential Space-Filling Layouts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Baudel</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertjan</forename><surname>Broeksema</surname></persName>
						</author>
						<title level="a" type="main">Capturing the Design Space of Sequential Space-Filling Layouts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:03+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Order: data Size: data</term>
					<term>Population Chunking: BestMinAspectRatio Recurse: #items &gt; 2 Phrase: ZigZag Order: data</term>
					<term>Population Size: data</term>
					<term>Population Chunking: BestMinAspectRatio Recurse: never Phrase: Spiral Order: data Size: data</term>
					<term>Population Chunking: PivotBySize Recurse: #items &gt; 2 Phrase: WorstDiscontinuous Order: data Size: constant Chunking: HalfItemCount Recurse: #items % 4 == 0 Phrase: Hilbert</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. various space-filling layout examples: (a) strip (with recursion), (b) spiral, (c) pivot by middle. (d) hilbert phrasing, Chunks are separated by black lines, individual items by red lines.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Treemaps are now over twenty years old <ref type="bibr" target="#b13">[14]</ref>. This visualization technique has generated much enthusiasm in the information visualization community and has become a small research area of its own <ref type="bibr" target="#b20">[21]</ref>. In the general public, treemaps have had their moments of fame with the map of the market <ref type="bibr" target="#b22">[23]</ref>, and are slowly making their way as a standard device in the toolkit of graphic designers <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b23">24]</ref>.</p><p>Yet, for a technology about as old as the World Wide Web, which keeps a high level of interest in the research community, we could hope for more salient success: treemaps and related rectangular spacefilling approaches are still not a common visualization device of everyday use. Success stories for treemaps are the result of talented graphic design work, where the visualization designer has crafted the layout and visualization parameters to match a specific context and narrative.</p><p>We attribute the need for careful crafting to the lack of a good understanding of their design space. Choosing the right layout parame- ters to suit a particular dataset and features to be highlighted requires a solid experience and a dedicated presentation effort. In analysis contexts, this presentation effort is a distraction from the research task and therefore often sub-optimal layouts are used. This lack of presentation automation, or easier customizability, creates a barrier to more widespread adoption in the contexts where rectangular space-filling layouts, such as treemaps, could really bring insight. Our goal here is to define more precisely the design space of a particular class of layout algorithms that lie at the root of the treemap concept: rectangular space-filling layouts, i.e. the layouts that tile a unit square with rectangles in a space-filling manner. We describe how input data is transformed into a set of rectangles that tile the unit square through a process that is constrained by the dimensions that span this design space. In addition we contribute a universal algorithm for some class of rectangular space-filling layouts. This universal algorithm is parametrized by functors that represent the described dimensions. We present the algorithm with various examples of useful values for these dimensions, which allow creating well known as well as novel rectangular, space-filling layouts. We believe that a solid understanding of this design space can serve as a basis to develop methods and heuristics that determine the most appropriate layout given a particular data set. Finally, it has been suggested that the design-space of space-filling rectangular layouts is very large and that the generic problem of creating such layouts fall in the category of NP-hard problems <ref type="bibr" target="#b7">[8]</ref>. To the contrary, we show here that:</p><p>They have an average complexity of O(n) or O(nlogn), with worst case at O(n 2 ). 2. Only five dimensions suffice to characterize the task of sequentially laying out a data set in space-filling rectangles: order, size, chunk, recurse and phrase (the chunk and phrase dimensions echo Buxton's perspective on the structure of input <ref type="bibr" target="#b8">[9]</ref>). 3. Functional representations (functors) of these five dimensions are the parameters of a universal algorithm for the class of sequential, rectangular, space-filling layouts.</p><p>To support those assertions, we first state the problem more formally by specifying the class of problems we address and place our work in context. Next we describe the five dimensions of the design space spanning the introduced problem class. This is followed by the construction of an universal algorithm which covers this space. Next, we show how these dimensions serve as parameters of the algorithm and demonstrate how various values for each dimension result in different well-known or new layouts. Finally, we extend the algorithm to allow handling hierarchical data structures for the realization of a generalized treemap layout framework. This lets us conclude on the potential of our algorithm to help mastering better the design space of treemaps and rectangular space-filling layouts, as well as address more general visualization techniques with similar algorithmic space characterizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PROBLEM STATEMENT</head><p>There are various ways to define the concept of rectangular spacefilling layouts which underlie the design space of treemaps. We choose to state the problem in a more general, yet simple to formalize way. The problem we address can be stated formally as follows. A rectangular space filling layout is an algorithm which The sides of these rectangles are only allowed to be aligned with the sides of the unit square, i.e. no rotation is allowed. Colloquially, we call these "orthogonal" or "manhattan" rectangles; • while maximizing a given objective function;</p><p>The objective function will define, for a large part, the algorithm to apply. This function is generally a weighted sum of objectives <ref type="bibr" target="#b15">[16]</ref> involving criteria such as:</p><p>1. Aspect ratio of rectangles should be close to 1 or some chosen value. 2. Preservation of the input order. 3. Stability to resizing or adding or removing a small number of items.</p><p>Other criteria could be interesting to investigate, such as including the input surfaces as part of the objective function instead of posing them as hard constraints.</p><p>While the layout phase is the center of our attention, treemaps are often perceived as a method to visualize hierarchies. To address this perception, our generalized approach applies the solution for the above layout problem to each level of the hierarchy.</p><p>This definition discards some interesting work from our focus: Ellimaps <ref type="bibr" target="#b18">[19]</ref> or Voronoi Treemaps <ref type="bibr" target="#b0">[1]</ref> for instance, are moved out of our scope. Still, it covers most of the central area of treemap research: slice and dice, squarified, pivot layouts. We stress, however, that our approach is not limited to treemaps but also covers related rectangular space-filling visualizations such as mosaic displays, icicle plots and 100% stacked bar charts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Generic Algorithm</head><p>We propose a generic algorithm, whose parameters allow specifying points (i.e. concrete rectangular, space-filling layouts) in a specific portion of the problem space described above. For convenience, in the remainder of the paper we will use the following conventions. Our algorithm takes as input a collection of N tuples <ref type="bibr" target="#b12">[13]</ref>, which we will denote T . We refer to a single element in T as t i ∈ T with 0 &lt;= i &lt; N. Each tuple t i has a finite number of attributes, which we denote a j for the jth attribute.</p><p>The output of our algorithm is a representation of the input data presented as a list of graphic instructions in the form</p><formula xml:id="formula_0">drawRectangle(t i , x i , y i , w i , h i ) for each i.</formula><p>This list is constrained: output rectangles do not overlap and together they fill the unit square. In our algorithm description, we consider that the output is produced through a succession of calls to a rendering function: render : T × Rectangle → Graphical Out put. Hence, our algorithm can be characterized as a function that takes a collection of tuples T and a renderer R: draw : T × R → Graphical Out put.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Sequential methods</head><p>Considering that our target problem is defined as a combinatorial optimization problem, it would seem, at first sight, that reaching optimal solutions is a hard problem. Some have assumed that the disjunctive nature of the problem makes it NP-hard <ref type="bibr" target="#b7">[8]</ref>. We do not adhere to this view. We will show that the constraints for tiling the full surface impose some severe restrictions on the allowed choices, and that dynamic-programming-based solutions work satisfactorily.</p><p>However, it remains clear that describing the full algorithmic design space of rectangular space-filling layouts, of unbounded complexity, is a challenging task. Rather, we decide to focus on a class of greedy methods, which we call sequential layouts. These methods are not allowed to use backtracking techniques of unbounded depth. They can perform a fixed number of passes on the input set and partition the input set to apply to each partition element a further layout method (divide and conquer/dynamic programming approach). This class of algorithms corresponds to the class of input-linear visualizations <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, augmented with partial recursion capability. As defined in <ref type="bibr" target="#b1">[2]</ref>, algorithms are input-linear (or data-linear) when there is a constant K such that, for any input set T of length N, for all i &lt; N, t i is accessed at most K times. Augmented with local recursion, the algorithms we consider are contained in the class that we call quasi − input − linear algorithms, defined by the proposition that t i is accessed log(N) * K times on average and N * K at most, which gives algorithms in this class a worst-case complexity of O(N 2 ).</p><p>There are several reasons to restrict oneself to exploring this class:</p><p>• All widely known algorithms that tile rectangles belong to this class. • If further improvements are needed, local optimization techniques provide a range of simple techniques to move down to local minima. • A design space of this class of algorithms can be fully characterized very simply.</p><p>Algorithms in this class, are conveniently written as a sequence of ordered passes (sequences) over the dataset, which is why we call this class "sequential algorithms" (or methods').</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK</head><p>In the previous section, we have restricted our ambitions to provide for a simpler model. Still the space-filling model we describe covers a large number of commonplace views which are used in various contexts.</p><p>Tables, grids (figure 1d), file browsers, but also simple hierarchical trees are representable in our model. For the later case, it suffice to replace the rectangle renderer with a link renderer to obtain commonplace trees out of a space filling layout algorithm.</p><p>Rectangular space-filling layouts also cover a large portion of common statistical graphics. Equal height and 100% Stacked bar charts are two of the simplest space-filing layout to implement. More interestingly, treemaps are predated by Mosaic plots <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>, which are hierarchical, space-filling layouts too. Dimensional stacking <ref type="bibr" target="#b16">[17]</ref> and pixel bar charts <ref type="bibr" target="#b14">[15]</ref> are also covered by our design space.</p><p>Starting from the seminal paper of Johnson and Shneiderman <ref type="bibr" target="#b13">[14]</ref>, treemaps have been a widely explored area. The issue of the poor aspect ratios produced by the slice and dice technique have been addressed quite rapidly after: M. Hascoet-Zizi proposed, as soon as 1992, the squarified layout algorithm <ref type="bibr" target="#b28">[29]</ref>. Bruls et al. <ref type="bibr" target="#b7">[8]</ref> rediscovered this technique and popularized it. Around the same time, M. Wattenberg proposed a variety of pivot based layouts, while B. Bederson introduced strip and quantum layouts <ref type="bibr" target="#b4">[5]</ref>. A recent technique worthy of discussion is spatially ordered treemaps <ref type="bibr" target="#b27">[28]</ref>. We refer to Shneiderman <ref type="bibr" target="#b20">[21]</ref> for a more exhaustive listing. All the techniques presented above are particular instances of our generalized layout technique.</p><p>Of interest to our work are some recent efforts to model the treemap design space more formally. Onak et al. introduced "Fat Polygonal Partitions" <ref type="bibr" target="#b5">[6]</ref> and "Circular partitions" <ref type="bibr" target="#b17">[18]</ref> which are interesting variants of the problem we address, splitting the unit square with quadrilaterals instead of rectangles. The extra degree of freedom gained lets them improve the optimization results, and in particular provide better overall aspect ratios. Interestingly enough, both techniques can be recreated with a generalization of our universal layout algorithm wherein the output is changed to general quadrilaterals. Schulz et al. <ref type="bibr" target="#b19">[20]</ref> survey the design space of implicit hierarchical visualization. They define layout as one of the axis of this space. However, they only distinguish between subdivision and packing, which leaves layout still as an ill-defined black box. We show that layout can be defined more precisely and covers a design space on its own. Vliegen et. al. <ref type="bibr" target="#b24">[25]</ref> discuss several of the dimensions we consider for our space (direction, size, nesting as a equivalent to our partitioning operator, but not our recurse functor), as well as other dimensions (transformation, uniform density), but those dimensions are treated as parameters of finite range (or black-box parameters) and the algorithm features that are the foundation of the problem space are not discussed.</p><p>Our work inscribes itself in a variety of foundational work on describing the structure of graphical representations. Our approach is inspired by some seminal work in formalizing the design space of information visualization such as Chi et al. <ref type="bibr" target="#b9">[10]</ref>. Bertin's seminal Semiology of Graphics <ref type="bibr" target="#b6">[7]</ref> provides numerous insights, including a treemap layout (p. 270). Wilkinson's Grammar of Graphics <ref type="bibr" target="#b26">[27]</ref> went much further by including data projection and statistical concerns in his framework. This work was extended by Wickham and Hofmann <ref type="bibr" target="#b25">[26]</ref> who propose 1d and 2d primitives for map data to various space-filling and non-space-filling plots. But we are not aware of related work regarding decomposing and rationalizing the layout problem. We propose to characterize layout classes as a space whose dimensions are characterized by elementary decision functions. We open such a possibility by restraining our taxonomy to a useful subset of algorithmic classes, that happens to be easy to study and categorize: input-linear and quasi-input-linear algorithms. Slingsby et al. <ref type="bibr" target="#b21">[22]</ref> proposed a general technique to configuring hierarchical spacefilling layouts. Our design space is structured quite similarly, but has been inspired by our Discovery earlier work <ref type="bibr" target="#b2">[3]</ref>. Our contribution over the work of Slingsby et al. is that, instead of providing a preset number of layout functions, we request the specification of five independent parameters: order, size, chunk, recurse and phrase. All are functional expressions determining the behavior of the sequential layout algorithm. These expressions allow covering the full design space of sequential space-filling layouts. In short, our model does not rely on a preset number of "black boxes" predefined layouts. All possible layouts in the class we consider are described through parameter settings only. Order and Size are similar to Slingsby et al. sSize and sOrder operator.s Slingsby's model can probably replace its oLayout operator with oChunk, oRecurse and oPhrase operators and make all those operators functional to reach the full expressiveness of our model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DESIGN SPACE</head><p>The design space for sequential, rectangular space-filling layouts is determined by five independent dimensions: order, size, chunk, recurse and phrase. Those dimensions are functional: they are functors that define choice points to be taken based either on the input data or on the current state of the layout process. For example, a particular instance of the chunk functor can make the decision to start a new chunk every tenth item. All functors are stateful, meaning that their actual signature is X × State → Y × State A brief overview of those functors is given in table 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Order</head><p>As the data is handled sequentially, the first dimension that determines the layout is the order in which to process input. The functor that defines this dimension takes as input the original data items to be laid out and return the items in a particular order. Basic ordering functions include sorting data items ascending or descending based on a particular input attribute a i . More elaborate ordering functions can be used: for instance, returning all items at even indices followed by items at odd indices. Functionally this dimension is represented as:</p><formula xml:id="formula_1">order : T → T</formula><p>We must take in account an important restriction: because we cover only the class of sequential algorithms, only ordering functions that are sequential can be used in our model. This includes linear time sort algorithms such as bucket sort and divide and conquer sort algorithms such as quicksort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Size</head><p>We have defined the layout problem as the tiling of a unit square, given a list of sizes. The size determines the relative space a given data item will take in the final layout. Retrieving these sizes from the original data can be expressed as a function on the input data. The most trivial functions return either a fixed size or use a particular numeric data attribute. Other possibilities include calculations on attributes of the data items or transforming categorical data attributes to a numeric value that serves as size based. Functionally this dimension is represented as:</p><formula xml:id="formula_2">size : T → R</formula><p>Where, size(T [i]) returns the size of the ith tuple (i.e. L[i], from the initial problem statement).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Chunk</head><p>A chunk is a rectangle in the unit square that fully contains one or more of the output items. In the remainder, C denotes the list of chunks that pave unit square and c i the ith chunk, with 0 &lt; i &lt;= N. When i ≡ N, all items are laid out in separate chunks.</p><p>A consequence of the limitation that the algorithm must be sequential is that items must be placed sequentially in successive chunks.</p><p>How big these chunks are, i.e. how many items are laid out at once, can be determined in various ways. Therefore, Chunking defines yet another dimension of our design space. The decision of adding an item to the current chunk or to the next can be based on various variables such as the number of items in a block with respect to the total number of items to layout or the aspect ratio of items in a chunk. Functionally this dimension is represented as:</p><formula xml:id="formula_3">chunk : C × R → B Where, chunk(c[ j], L[i]) returns false when L[i]</formula><p>should be added to the jth chunk and true when a new chunk should be formed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Recurse</head><p>The recurse dimension indicates whether, after having isolated a chunk, the algorithm should recurse into the chunk, reapplying itself to further improve the aspect ratio or other optimization goals. This is a partial recursion and it is bounded by the number of data items to be laid out. This functor therefore causes the algorithm's worst case complexity to grow into O(N 2 ), just under the same kind of scenario as the quicksort algorithm: the worst case occurs when N − 1 items are laid out in a chunk and in the recursion proceeds N − 2 times, until finally no items are left to process. This results in N(N + 1)/2 = O(N 2 ) steps.</p><p>This dimension allows implementing the various types of pivot layouts. Recursion can be used for instance to improve the aspect ratio of small items in a strip treemap without compromising the ordering (1a). Functionally this dimension is represented as:</p><formula xml:id="formula_4">recurse : C → B</formula><p>Where, recurse(C[ j]) returns true when the algorithm must recurse into the jth chunk and apply itself recursively to the items in this chunk and false otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Phrase</head><p>When a chunk is finished it must be laid out in the available space. Once a chunk is laid out, no changes to the aspect ratio or to the location of the chunk can be made (because of fixed depth backtracking). Consequently, the way a chunk can be located in the available space rectangle is strongly constrained, as explained in figure 5: if a chunk was allowed to be placed anywhere in the available space, using any aspect ratio, it would be easy to create input sequences that defeat the space filling constraint and therefore the sequential constraint. Hence, there are only four possible locations for a new chunk: the four sides of the containing rectangle. Besides newly created chunks must take either full height (resp. width) and grow horizontally (resp. vertically) as items are added. Finally, items can be stacked in various directions inside a chunk. In horizontal chunks they can be either stacked from left to right or vice versa. In vertical chunks they can be stacked from top to bottom or vice versa. This brings the total number of possible block configurations to eight. For completeness we note that items could be stacked vertical in horizontal chunks and stacked horizontal in vertical chunks, doubling the number of configurations. Functionally this dimension is thus represented as:</p><formula xml:id="formula_5">phrase : C → (Side, Direction)</formula><p>With Side in {North, South, East,West} and Direction in {U p, Down, Le f t, Right}. Here, phrase(C[ j]) returns the layout configuration for the jth chunk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ALGORITHM</head><p>Now that we have specified the dimensions that span the design space of rectangular, sequential space-filling layouts, we can stitch them together in order to construct a universal algorithm that creates rectangular space-filling layouts in a sequential manner. <ref type="figure">Figure 2</ref> summarizes the steps required for creating rectangular space-filling layouts. It gives an functional view of the algorithm and shows the various functors that transform data into rectangles. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Chunks</head><p>Our algorithm stacks items in a chunk as shown in <ref type="figure" target="#fig_14">figure 3</ref>. The chunk is placed on the left side of the unit square, and three out of six equally sized items are added to the chunk. Items are stacked from bottom to top. The order of stacking is depicted by color, going from black for the first to light gray for the last item. In figure 3a, no item is added, hence the chunk height is equal to the available space plane and its width is zero. Next, in figure 3b one item is added and the chunk now has a width proportional to the size of the item that was added previously over the total size to be laid out. In figure 3c a second item is added. The width of the chunk again grows proportionally, but the items' height are reduced as they are stacked in the chunk. Finally, <ref type="figure" target="#fig_14">figure 3d</ref> shows the result of adding yet another item to the chunk. A chunk has six properties: side, direction, fromX, toX, fromY and toY. These are initialized using an initial chunk configuration (combination of side and direction), and the available space rectangle, but with a flat rectangle along the progress direction. Once no more items are to be added to a chunk, it can reduce the available space rectangle by moving one of its corresponding borders proportionally to the chunk's surface. Assuming that figure 3d shows the final state of the chunk, the available space would be reduced to [x : 0.5, y : 0, w : 0.5, h : 1]. This progressive reduction of the available space is materialized by the reduce function in our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Chunking</head><p>Chunking is the process of deciding whether t i gets added to c j or c j+1 . This decision is based on a simple scoring function which takes a chunk c j , the size of tuple t i and returns a score s. Or more formally:</p><formula xml:id="formula_6">score : C × R → R</formula><p>with score(c j , t i ) &gt;= score(c j , t i+1 ) when adding item t i+1 is considered to be an improvement of the layout. Like the main functors of our algorithm, score is stateful as well. The function describes an optimization function whose successive local maxima are used as chunk delimiters as the algorithm progresses through the input. This chunking process is described as pseudo code in listing 1.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Phrasing</head><p>When a new chunk is started, it must be decided how the chunk will be laid out in the available space. Recall that a chunk must be placed along one of the four sides of the available space, and that a stack direction must be given as well. Those two characteristics, taken together, form a chunk configuration. Phrasing is the process of picking a configuration for each successive chunk. Phrase is a functor that takes the previous chunk c i−1 and returns the chunk configuration for chunk c i . That is, phrase : chunk j → (side, direction). The first chunk is phrased according to the initial configuration set given to the algorithm, which is one of the above mentioned 16 possibilities. Depending on the strategy, the next configuration can be determined in a number of ways. There are four simple and useful strategies, which we call data independent. An overview of these strategies is shown in figure 4. Color depicts order of placement from first (dark) to last (light) and the arrow depicts the direction in which the items are placed in the chunk. These strategies work as follows:</p><p>• Strip ( <ref type="figure" target="#fig_4">fig. 4a</ref>) -Using this strategy, each chunk is put the same way in the available space. This results in each first item of c i being placed next to the first item of c i−1 for i &gt; 0, i.e. a discontinuous placement of items.</p><p>• Zigzag (more accurately, Boustrophedon) ( <ref type="figure" target="#fig_4">fig. 4b</ref>) -Is similar to strip except that the stack order of the items is reversed for every new chunk. Each first item of c i is placed next to the last item of c i−1 for i &gt; 0, i.e a continuous placement of items.</p><p>• Spiral <ref type="figure" target="#fig_4">(fig. 4c</ref>) -In this strategy, chunks are laid out against the next border of the available space based on the border and layout direction of the previous chunk. Each first item of c i is placed next to the last item of c i−1 for i &gt; 0, i.e a continuous placement of items.</p><p>• Spikes ( <ref type="figure" target="#fig_4">fig. 4d</ref>) -Chunks are laid out perpendicularly to the previous chunk so that the first item of c i is close to the first item of c i−1 for i &gt; 0, i.e. a discontinuous placement of items.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Layout</head><p>All the basic components of our layout algorithm have now been introduced. The actual layout algorithm can be described by extending the earlier presented chunk function as follows. The first chunk is given an initial configuration. Next we start chunking as detailed before. However, before a new chunk is started, we first test if recursive layout is required and apply the algorithm recursively if so. Next, the phrase functor is used to determine the configuration for the new chunk. The resulting pseudo code is listed in listing 2.</p><p>1 function layout(Array T, int from, int to) { 2 // order, size, score recurse and phrase 3 // are global function pointers. 4 Rect availableSpace = new Rect(0,0,1,1); 5 // phrase(null) returns a default configuration 6 Chunk currentChunk = new Chunk(phrase(null), availableSpace ); 7 int currentFrom = from; 8 Chunk result[] = [currentChunk ]; 9 T = order(T, from, to); 10 float prevScore = -inf; 11 12 for (i = from; i &lt; to; ++i) { 13     Finally, we can implement the draw function mentioned in the input and output section as listed in 3. The chunk.rectangle method simply assigns iteratively a rectangle to each item in the chunk based on the chunk's rectangle and its direction attribute and increments a local counter to assign the border of the next item to be drawn.  This fully describes our universal algorithm to solves the problem stated in section 2 in with sequential methods. Note that some parts of the algorithm are optimized in practice. For example, the ordering and sum functors are memoized, instead of being recalculated for each recursive iteration. These kind of optimizations are left out for clarity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Completeness</head><p>As we have mentioned in the introduction, the dimensions we describe are independent, and each cover a functional, recursively enumerable, domain. We can show in a nonconstructive way that our generic algorithm allows the depiction of any sequential, rectangular, space-filling layout as defined in 2.2: the order functor is instantiated with a general function that can perform any calculation and store its result in the state variable. The chunk, phrase and recurse functors are then free to reuse those results as they see fit. Hence it is always possible to "pack" a knowingly sequential algorithm into the order functor, which has the adequate signature, and leave the other functors just retrieve precomputed values to perform the layout. Finally, as long as the order function stays sequential in the sense of 2.2 and the other functions stay in constant time, all possible parametrizations of our generic algorithm stay sequential.</p><p>While this sketched proof somewhat downplays the use of separate phrase and chunk functors, these two dimensions greatly simplify the expression of a large variety of rectangular space-filling layouts, because they allow expressing in a terse way the base ingredients of a divide and conquer approach to layout, which is a most sensible technique to encompass efficiently the various objective functions of the problem stated in 2.</p><p>Indeed, the combination of chunk and phrase functors capture the fact that the chunking process needs to proceed by growing chunks along the borders of the area to fill. If a sequential layout algorithm decided to attribute to a chunk a rectangle that is not on the border of the available area, and does not extend to the full height or width of this area, then it suffice to input the algorithm two (or more) additional items which cannot be made to fit the remaining space: the algorithm fails to find a proper tiling. <ref type="figure">Figure 5</ref> illustrates this fact. In other words, an algorithm that wishes to chunk some items together into a distinctive block to further layout this block independently must proceed by placing the distinctive block along one of the edges of the area to layout, or be allowed to perform backtracks of arbitrary depth to decide how to organize those blocks together in the alloted space. These backtracks of arbitrary depth push the complexity of the method beyond the realm of input-linear and quasi-input-linear methods.</p><p>These considerations let us claim that our algorithm is universal for the class of algorithms considered, i.e. sequential methods for tiling the unit square with rectangles of varying surfaces. Still, we acknowledge a detailed proof is desirable. Such a proof goes beyond the scope of this paper as it would require further formalization and introduction to the class of input-linear algorithms. Instead, we now show how in practice those five dimensions can be combined to provide a wide variety of layouts. <ref type="figure">Fig. 5</ref>. When it is decided to place chunk A of size 1 in this square of surface 4; and if there are only two items left to fit in the square which sizes are 0.5 (B) and 2.5 (C), then there is no way to produce a rectangular space-filling tiling of the square.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">LAYOUT PARAMETERS</head><p>This section presents various examples of functions for each of the considered dimension and demonstrates how different configurations of the algorithm creates instances of well known or new layouts.</p><p>First, we briefly discuss the order and size functions as these are rather trivial. Next, we illustrate how the score and phrase functions interplay with each other to allow producing a variety of known or novel layouts. Finally, we discuss the recursion functor which adds the ability to reenter the layout algorithm inside chunks.</p><p>In the following we use a dataset containing US cities, the states they belong to and measures for various properties such as population, climate, education and health care. Individual items are colored by item index from light (low index) to dark (high index) and separated by red lines. Chunks are separated by black lines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Order and Size</head><p>The order functor orders (a subset of) the original input data set. When this functor is not specified the original order of the data is kept. A trivial example of an ordering function is one which sorts the tuples based on a particular attribute of the data set, e.g. by population. However, we explicitly named this dimension order as more complex ordering, which falls outside the range of sorting are allowed. For example, we chose to access first the tuples that have an even index, followed by the tuples that have an odd index.</p><p>The size functor lets one specify which attribute or function to use to compute the size of each tuple. There are only a limited number of useful size functions:</p><p>• An function that returns a tuple attribute ( <ref type="figure" target="#fig_12">fig. 6a</ref>) which should be a ratio attribute for best result. For nodes in a hierarchy, the value of this function is the sum of all values of the tuples it contains. An efficient implementation will of course cache this sum for each node to avoid recomputing it needlessly. • The result of a computation on tuple attributes ( <ref type="figure" target="#fig_12">fig. 6b</ref>). This is merely a special case of the former where a value is calculated based on one or more fields of the available data. <ref type="figure" target="#fig_12">• Constant (fig. 6c</ref>). One for tuples and nodes alike. This is useful for similar usages in grid layouts. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Chunk scoring</head><p>The Chunk scoring function is the most powerful and complex parameter. The score functor evaluates a score for a chunk composed of a current chunk and one extra item. So, this score functor is evaluated be f ore adding an item to the chunk. In the remainder of this section we assume a global variable state is available for bookkeeping, which is updated by the algorithm as required.</p><p>The simplest instances of this functor are Slice and Dice, which return the maximal score when the chunk has only one item, resp. when its cardinality is the full node. When these methods are alternatively applied at each level of a hierarchical data structure, this produces the regular slice and dice layout. Equally simple is the Grid function. This function returns its maximum when the number of items is equal to the closest approximation of the square root of the number of children in the node. This results (approximately) in a number of chunks with equal cardinality (To produce perfect grid, the size functor needs to be adjusted to return the smallest square integer above the cardinal of the input size). As its name indicate, this chunking method produces grids ( <ref type="figure" target="#fig_12">fig. 6c</ref>) if the size attribute is set to constant, or some variant of a strip layout if not.</p><p>1 function Slice(Chunk c, double itemSize, State state) { 2 return c.itemCount == state.itemCount ? 1 : 0; 3 } 4 function Dice(Chunk c, double itemSize, State state) { 5 return 1 -c.itemCount; 6 } 7 function Grid(Chunk c, double itemSize, State state) { 8 return square(c.itemCount) &lt;= state.itemCount ? 1 : 0; 9 }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Listing 4. Elementary chunking functions</head><p>More interesting, yet complex, chunking functions can be used, allowing for instance to implement a variety of squarified and strip layouts. The bestAverageAspectRatio (lst. 5, <ref type="figure">fig. 7a</ref>) and bestMinAspectRatio (list. 6, <ref type="figure">fig. 7b</ref>) functions return as a score respectively the average aspect ratio of all the items in the chunk and the aspect ratio of the smallest item in the chunk. The closer this value is to one, the more "fit" the current chunk is to be laid out. To compute these values, the width (resp. height) of the chunk has to be computed by evaluating the ratio of the sum of the current chunk over the total sum of the square to be laid out. The height (resp. width) is equal to that of the enclosing space. Having computed the width and height of the chunk makes computing the average and minimal aspect ratios of its content elementary.</p><p>1 function BestAverageAspectRatio (Chunk c, double itemSize, State state) { 2 Rect rect = state.availableSpace ; 3 float expandingDim = c.isVertical ? rect.height : rect.width; 4 float fixedDim = c.isVertical ? rect.width : rect.height; 5 int newChunkSize = c.sum() + itemSize; 6 float aspectRatio = expandingDim / (c.itemCount + 1) 7 / (fixedDim * newChunkSize / state.overallSize); 1 function BestMinAspectRatio (Chunk c, double itemSize, State state) { 2 Rect rect = state.availableSpace ; 3 float expandingDim = c.isVertical ? rect.height : rect.width; 4 float fixedDim = c.isVertical ? rect.width : rect.height; 5 int newChunkSize = c.sum() + itemSize; 6 int minItemSize = c.minItemSize() &lt; itemSize 7</p><p>? c.minItemSize () : itemSize;</p><p>8 float aspectRatio = expandingDim * (minItemSize / newChunkSize) 9 / (fixedDim * newChunkSize / state.overallSum);</p><p>10 return aspectRatio &gt; 1 ? 1 / aspectRatio : aspectRatio; 11 } Listing 6. Calculating score based on aspect ratio of smallest item Finally, to implement Pivot layout, other score functions can be used that split the input data in two approximately equal parts. Pivot by middle has its maximum around the middle of the item count, Pivot by size has its maximum at the index of the biggest item, and Pivot by split size has its maximum where the sum of the sizes are closest to half the total sum. 8 } 9 function PivotBySize(Chunk c, double itemSize, State state) { 10 return state.currentIndex == state.indexOfBiggestItem ? 1 : 0; 11 } Listing 7. Pivot layout functions: The first two are parabolas which have their maxima at the desired item index <ref type="figure">(Fig. 1c)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Phrase</head><p>In section 5.3 we introduced four simple, data independent phrasing strategies. The implementation of these strategies is done by means of functions which basically consist of a switch statement over the current chunk phrase configuration to pick the next one. A novel layout is shown in figure 1b, where we apply spiral phrasing to our US population dataset. More complex phrasing functions, combined with recursion, can use some state variables and a stack to produce sophisticated layouts such as the Peano-Hilbert curve of figure 1d.  <ref type="figure">fig. 1d</ref>). direction, sequence and depth are state variables maintained at the scope of each chunk.</p><p>In addition, phrasing can be made dependent on the input data, to produce data dependent strategies. Those can echo the data independent strategies described earlier. The data dependent alternative of Strip phrasing is called Worst Discontinuous phrasing. In this strategy, each chunk is placed so as to degrade the aspect ratio of the available space. Items in new chunks are stacked in the same direction, resulting in a discontinuity at each chunking step. The data dependent variant of zigzag is the Worst Continuous strategy which places the next chunk so as to degrade the aspect ratio and reverse the stack direction. The data dependent variant of Spiral is Best Continuous. In this strategy the chunk is placed so as to improve the aspect ratio of the available space and orders the items so that the first item of the next chunk is next to the last item of the previous chunk. Finally, the data dependent variant of Spikes ( <ref type="figure" target="#fig_16">fig. 8a</ref>) is called Best Discontinuous ( <ref type="figure" target="#fig_16">fig. 8b</ref>). It places each chunk so as to improve the aspect ratio of the available space and so that the first item of the new chunk is next to the first item of the previous chunk. This layout is a novel and interesting improvement over the regular squarified layout as it results in significantly squarer items, as shown in figure 8b. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Recurse</head><p>As with the other dimensions, recurse is a functor in our algorithm that returns a boolean. When true is returned the layout algorithm is applied to the items of the current chunk. If the recursion results in one or more chunks, the current chunk is removed from the result and replaced by the chunks that resulted from the recursion step. Obviously, there must be a stop criterion for the recursion. Therefore, the simplest value of the recurse functor should not just be a function that returns true but limit itself based on the number of remaining items. In our implementation it stops when only two or less items are left to be laid out. One reason to use recursion is that it might improve aspect ratio of small items. <ref type="figure" target="#fig_17">Figure 9</ref> shows that after recursion many of the small items got a better aspect ratio. Another reason for recursion is to implement various variants of the well known pivot layouts. <ref type="figure" target="#fig_18">Figure 10</ref> shows how recursion complements the pivot by middle scoring function. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">STRUCTURING</head><p>So far, we have focused purely on the layout aspect of space-filling visualizations. However, as stated before, treemaps are a central concern, and those are most often perceived as a method to visualize hierarchies. To accommodate this perception, we extend the presented algorithm by introducing a structuring phase. This phase consist of partitioning and ordering which reflect the sHier and sOrder states from Slingby et al. <ref type="bibr" target="#b21">[22]</ref>. First we define a new structure Node, used for representing hierarchies. This allows the algorithm to take as input either a tabular input data set and turn it into an ordered hierarchy according to some set criteria, or a preexisting hierarchy of ordered nodes. Each node has a unique identifier and keeps a list of children. The children can be tuples, nodes or a mix of both.</p><p>We adapt the previously introduced layout and draw functions to take this new context into account. First, the layout function now takes a node n as input and additionally does not assume the unit square as available space any longer but takes a bounding rectangle BR. Furthermore, the children of a node can be a mix of tuples and nodes. Hence, the size function must be adapted to return the appropriate size for the ith child of n. The required changes for the layout function are listed in 9.</p><p>1 layout(Node n, Rect BR, int from, int to) 2 Rect availableSpace = BR; 3 // Same as in listing 2 4 int N = n.childCount(); 5 int S = sum(n, from, to). 6 order(n, from, to); 7 float prevScore = -inf 8 for (int i = from; i &lt; to; ++i) 9</p><p>int itemSize = size(n.children  Like the layout function, the draw function now takes a node n and a bounding rectangle BR instead of assuming unit square. The items in b are now elements e, which are either tuples or nodes. In the former case, we call draw on the Renderer as before. In the latter case, we recursively call draw, but now we set the bounding rectangle to the rectangle that was laid out for this node. All children of the node will therefore be laid out not in the unit square but in the input bounding rectangle. The adapted version of the draw function is listed in 10.   At this stage our space-filling layout algorithm is able to deal with both flat and hierarchical data. In both cases the initial step is to convert input T into a root node containing T as children. Now an additional structuring function is added before calling draw, which converts the flat root node into an ordered hierarchy. The structure function executes in two phases, partitioning and ordering. These two phases are detailed now.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Partition</head><p>Partitioning aggregates tuples in nodes according to a user provided expression. This expression is expected to return a unique sub node identifier for each tuple, or null if the tuple is to remain at the current level. Calling this functor on each child tuple results in creating one additional level to the hierarchy. Listing 11 shows how a partitioner can be used to create a hierarchical structure out of flat data. Using this partition expression, data can be partitioned as listed in 11.    This partitioner allows, for instance, to group a set of US cities by states. Likewise, date and numeric partitioners can be defined to split according to values and fields held in a date or numeric attribute. A hierarchical partitioner can be defined as a list of single column partitioners, resulting in mosaic plot layouts. Hierarchical partitioners need to keep track of the depth of the current node, to invoke the proper level of partitioning. Finally, a path partitioner takes an attribute column that describes a path (directory + file name, or URL, or date in the form y/M/d h:m:s, for instance). At each depth level n, this partitioner will return the corresponding nth substring in the attribute value. This partitioner is used for instance to display a file hierarchy in a treemap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Order</head><p>Once partitioning is done, the resulting list can be ordered. Because the children can be either nodes or tuples, the function used to determine order needs to take into account the possibility of having to compare a node against a tuple. Past this hurdle, defining a comparator is fairly simple. The most common comparator, like the Enumeration partitioner, uses a column as its sort criteria. To handle nodes, this comparator defines an aggregation value for nodes, which can be, for instance, the sum of all the tuple values, or their average, maximum or minimum. Alternatively, the comparator can decide to place all nodes before or after all tuples, and sort them according to their node id, their immediate child count or the number of tuples they contain. Each of those possibilities will determine different placement of the nodes at a given level, but will not affect the layout algorithm per se. Finally, when ordering is done at the structuring phase, it should be obvious that ordering can be removed from the layout phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have defined the design space of sequential, rectangular, spacefilling layouts. This space is covered by five independent, functional, dimensions, namely: order, size, chunk, recurse and phrase. In addition we presented a universal algorithm for sequential, rectangular, space-filling layout. Our method leverages the observation that optimization techniques for sequential layout methods are essentially of the divide and conquer type, requiring chunking the input into blocks that are further laid out separately. The sequential nature of the process imposes the chunking process to proceed from a full side of the available space to fill, and then proceed along one of four possible sides, along one of four possible directions. Giving the user the ability to specify the value of each of those dimensions at each step of the algorithm results in a universal method to describe this class of algorithm. Additionally we discussed an extension of the algorithm in order to make it suitable for hierarchical data as well.</p><p>Our Discovery <ref type="bibr" target="#b2">[3]</ref> framework implements the majority of the presented algorithms and techniques, even though it was not formalized at the time. To provide broader access, we have implemented the generalized space-filling layout algorithm as a small, independent component. This component consists of only a few hundreds of lines of JavaScript code and follows closely the presented algorithms.</p><p>A future research direction is to extend the presented algorithms to other layout problems involving only data-linear or quasi-data-linear visualizations. We have mentioned the possibility of describing circular partitions <ref type="bibr" target="#b17">[18]</ref> and <ref type="bibr" target="#b5">[6]</ref> with the same techniques. Many tree and graph drawing algorithms that do not require global heuristics (where the position of a node depends possibly on all the other node positions) are also representable with our technique, simply replacing the drawing of rectangles with drawing of arcs joining the centers of the rectangles.</p><p>Yet, returning to the original motivation of our work. We have already shown (figure 8b and 1a) that subtle changes to the configuration of the algorithm result in improved layouts. Relying on the designer to think about those possible changes is unrealistic. Hence, our goal in defining this layout design space is to provide a more solid grounding to support analysts in their use of space-filling displays. We envision using this design space to develop a systematic method and a set of heuristics to (semi-) automatically choose a proper layout given some data sets, appropriate meta-data and contextual information.</p><p>Finally, our work presents some aspects that seem to be new in the area of computational geometry. As said before, we are not aware of related work regarding decomposing and rationalizing layout design spaces relying on algorithmic properties of the problem specification. Similar under-specified problems (whose objective function is a weighted sum of objectives, the weights being personal decisions) are abundant in the literature. By leveraging the cases where these problems are satisfactorily addressed by algorithms of low complexity (sequential, dynamic-programming...), we have found a way to characterize such algorithmic design spaces elegantly, through a limited set of functors that represent elementary decision functions that are to be made by the algorithm: in our context, "how to group items together? (chunk)", "in what order to fill the plane? (phrase)", "do we refine the groups? (recurse)". The study of input-linear and quasi-input linear algorithms in such contexts could bring new insights to these classes of problems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>taking as input an ordered list of N positive integers: {a, b, c, ...}, whose sum is equal to S, • outputs a tiling of the unit square [0, 1] × [0, 1] with N nonoverlapping, rectangles of surfaces {a/S, b/S, c/S, ...}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .Fig. 3 .</head><label>23</label><figDesc>Functional view of the algorithm, showing dependencies among components. Stacking items in a chunk.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1</head><label></label><figDesc>function chunk(Array T) { 2 // size and score are global function pointers 3 Chunk currentChunk = new Chunk(); 4 Chunk chunks[] = [currentChunk ]; 5 float prevScore = -inf; 6 for (var i = 0; i &lt; N; ++i) { 7 float curScore = score(currentChunk , size(T[i])) 8 if (curScore &lt; prevScore) { 9 currentChunk = new Chunk();</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>10chunks.append(currentChunk ); 11 prevScore = score(currentChunk , size(T[i]));</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Four data independent phrasing strategies to create a space filling layout: (a) Strip; (b) Zigzag; (c) Spiral; and (d) Spikes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>20</head><label></label><figDesc>Chunk recursiveChunks [] = layout(T, currentFrom, to); 21 if (!recursiveChunks .isEmpty())</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>22 result.pop(); // replace last chunk with 23 // subdivision result.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>if (currentFrom != from &amp;&amp; recurse(currentChunk )) { 37 Chunk recursiveChunks [] = layout(T, currentFrom , to); 38 if (!recursiveChunks .isEmpty()) 39 result.pop(); // replace last chunk with subdivision result.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>1</head><label></label><figDesc>function draw(T, R) { 2 Chunk chunks[] = layout(T, 0, T.length()); 3 foreach (chunk : chunks) { 4 R.drawRect(chunk.rectangle()); 5 foreach (t : chunk) { // item in chunk</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>6 R 7 } 8 } 9 } 3 .</head><label>67893</label><figDesc>.drawRect(t, chunk.rectangle(t));Listing Draw function implementation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 6 .</head><label>6</label><figDesc>Various settings for the size functor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>8 9 }Fig. 7 .</head><label>97</label><figDesc>return aspectRatio &gt; 1 ? 1 / aspectRatio : aspectRatio; Listing 5. Calculating score based on average aspect ratio (a) Best Average (b) Best Minimum Two scoring functions based on aspect ratio of items: (a) best average aspect ratio. (b) best aspect ratio for smallest item. The order function is not specified, resulting in a (intentional) poor squarification of the layout.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>1 3 -</head><label>3</label><figDesc>function PivotByMiddle (Chunk c, double itemSize, State state) { 2 return -square(c.itemCount + 1 (state.to -state.from) / 2); 4 } 5 function PivotBySplitSize (Chunk c, double itemSize, State state) { 6 return -square(state.currentChunk.size() + itemSize 7 -state.remainingSum / 2);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>1 6 // direction of the 2nd chunk 7 if 14 } 15 } 18 } 20 } 21 } 8 .</head><label>6714151820218</label><figDesc>function hilbertPhrasing (state) { 2 state.sequence += 1; 3 var direction = state.parentConfig ; 4 if (state.depth % 2 === 0) { 5 // at even depth, we split in 2 blocks of 2 and reverse (state.sequence % 2 === 0) { return direction; } 8 else { return direction.reverse(); } 9 } else { 10 // at odd depths we toggle the orientation of each quarter 11 if (state.parentSequence % 2 === 0) { // 1st half 12 if (state.sequence % 2 === 0) { 13 return direction.alternate(); } // q1 else { return direction; } // q2 else { // 2nd half 16 if (state.sequence % 2 === 0) { 17 return direction.alternate(); } // q3 else { return direction.alternate().reverse(); } // q4 19 } Listing Hilbert phrasing (see</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 8 .</head><label>8</label><figDesc>Data independent and dependent spike phrasing strategies. Notice the two vertical chunks at the left in (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 9 .</head><label>9</label><figDesc>Strip layout with recursion to improve small item visibility.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 10 .</head><label>10</label><figDesc>(a) Without recursion (b) With recursion Recursion to implement pivot by middle: (a) size by population, Strip, no recurse (b) size by population, Strip, recurse #item &gt; 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>2 Listing 9 .</head><label>29</label><figDesc>15 currentChunk .add(n.children[i])16 // Same as in listing Layout function for hierarchical structures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>1</head><label></label><figDesc>draw(Node n, Renderer R, Rect BR) 2 Chunk chunks[] = layout(n, BR, 0, n.childCount()); 3 foreach(chunk : chunks) 4 foreach(element : chunk) 5if (e instanceof Tuple)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>6 R 7 else // e is a Node 8 /</head><label>678</label><figDesc>.drawRect(e, b.rectangle(e)) / Recursively draw the next level in the tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>9</head><label></label><figDesc>draw(n, R, chunk.rectangle(e)) Listing 10. Recursive draw function for hierarchical structures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>1</head><label></label><figDesc>structuring(Node n, int depth) 2 Array result = []; 3 Map partitionMap = {}; 4 foreach (e : n.children) 5 Object id = partitionExpression (e, node, depth) 6 if(id != null) 7 child = partitions.get(id); 8 if(child == null); 9 child = new Node(id); 10 structure(child, depth + 1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>11partitions.put(id, child)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>13 child.add(e) // Add element to node 14 else 15 result.add(e) // Add element as leaf 16 order(result); 17 n.children = result returnget(t, myPartitioningColumn).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Overview of the five dimensions that span the design space of sequential, rectangular space filling layouts. All functors are stateful, meaning their actual signature is X × state → Y × state. Direction) how chunks are assembled in the available space.</figDesc><table><row><cell>Dimension Signature</cell><cell>Description</cell></row><row><cell>Order T → T</cell><cell>order in which the data items are laid out.</cell></row><row><cell>Size T → R</cell><cell>how individual data items are sized.</cell></row><row><cell>Chunk C × R → B</cell><cell>how data items are chunked together.</cell></row><row><cell>Recurse C → B</cell><cell>how a chunk lays out its content.</cell></row><row><cell>Phrase C → (Side,</cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors would like to thank the following persons for their reviews and thoughtful comments: Alex Telea from University of Groningen, Guy Melançon from INRIA, Bordeaux, and our colleagues from IBM, Frank van Ham and Christophe Jolif.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Voronoi treemaps for the visualization of software metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Deussen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lewerentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM symposium on Software visualization -SoftVis &apos;05</title>
		<meeting>the 2005 ACM symposium on Software visualization -SoftVis &apos;05<address><addrLine>New York, New York, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="165" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Visualisations compactes: une approche declarative pour la visualisation d&apos;information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Baudel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th French-speaking conference on Human-computer interaction (Conference Francophone sur l&apos;Interaction Homme-Machine), IHM &apos;02</title>
		<meeting>the 14th French-speaking conference on Human-computer interaction (Conference Francophone sur l&apos;Interaction Homme-Machine), IHM &apos;02<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="161" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Browsing through an information visualization design space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Baudel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI &apos;04 extended abstracts on Human factors in computing systems, CHI EA &apos;04</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="765" to="766" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bbc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Superpower</surname></persName>
		</author>
		<ptr target="http://news.bbc.co.uk/2/hi/technology/8562801.stm" />
		<title level="m">Visualising the internet</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ordered and quantum treemaps: Making effective use of 2D space to display hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="833" to="854" />
			<date type="published" when="2002-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fat Polygonal Partitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Onak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sidiropoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">773</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Sémiologie graphique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bertin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1967" />
			<publisher>Mouton</publisher>
			<pubPlace>Paris</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Squarified treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bruls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Huizing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the joint Eurographics and IEEE TCVG Symposium on Visualization</title>
		<meeting>the joint Eurographics and IEEE TCVG Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Chunking and Phrasing and the Design of Human-Computer Dialogues</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFIP World Computer Congress</title>
		<meeting>the IFIP World Computer Congress</meeting>
		<imprint>
			<publisher>North Holland Publishers</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="475" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An operator interaction framework for visualization systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">H</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Riedl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 IEEE Symposium on Information Visualization</title>
		<meeting>the 1998 IEEE Symposium on Information Visualization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Extending Mosaic Displays : Marginal , Partial , and Conditional Views of Categorical Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Friendly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational and Graphical Statistics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="373" to="395" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Brief History of the Mosaic Display</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Friendly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational and Graphical Statistics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="107" />
			<date type="published" when="2002-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Software design patterns for information visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="853" to="860" />
			<date type="published" when="2006-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Treemaps: a space-filling approach to the visualization of hierarchical information structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd conference on Visualization &apos;91</title>
		<meeting>the 2nd conference on Visualization &apos;91<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Hierarchical pixel bar charts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="255" to="269" />
			<date type="published" when="2002-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Perceptual guidelines for creating rectangular treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>IEEE Information Visualization</publisher>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Exploring N-dimensional databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wittels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st conference on Visualization &apos;90</title>
		<meeting>the 1st conference on Visualization &apos;90<address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="230" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Circular partitions with applications to visualization and embeddings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Onak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sidiropoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twenty-fourth annual symposium on Computational geometry -SCG &apos;08</title>
		<meeting>the twenty-fourth annual symposium on Computational geometry -SCG &apos;08</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="28" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">CGD -A New Algorithm to Optimize Space Occupation in Ellimaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Otjacques</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cornil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Monique</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Feltz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">; T</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gulliksen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kotzé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Oestreicher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Palanque</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">O</forename><surname>Prates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Winckler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th IFIP TC 13 International Conference on Human-Computer Interaction: Part II</title>
		<meeting>the 12th IFIP TC 13 International Conference on Human-Computer Interaction: Part II<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">5727</biblScope>
			<biblScope unit="page" from="805" to="818" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The design space of implicit hierarchy visualization: A survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-J</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hadlak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="393" to="411" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Treemaps for space-constrained visualization of hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<ptr target="http://www.cs.umd.edu/hcil/treemap-history/" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Configuring hierarchical layouts to address research questions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Slingsby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dykes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on visualization and computer graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="977" to="84" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Map of the market</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smartmoney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Com</surname></persName>
		</author>
		<ptr target="http://smartmoney.com/marketmap" />
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The New York Times. Health of the car, van, suv, and truck markets</title>
		<ptr target="http://www.nytimes.com/imagepages/2007/02/25/business/20070225CHRYSLERGRAPHIC.html" />
		<imprint>
			<date type="published" when="2007-02-25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Visualizing business data with generalized treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vliegen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E.-J</forename><surname>Van Der Linden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="789" to="796" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Product plots</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wickham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2223" to="2230" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The grammar of graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wilkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistics and computing</title>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Spatially ordered treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dykes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on visualization and computer graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1348" to="55" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Accessing hyperdocuments through interactive dynamic maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zizi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Beaudouin-Lafon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 ACM European conference on Hypermedia technology -ECHT &apos;94</title>
		<meeting>the 1994 ACM European conference on Hypermedia technology -ECHT &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="126" to="135" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
