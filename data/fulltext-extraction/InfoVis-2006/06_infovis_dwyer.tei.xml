<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">IPSEP-COLA: An Incremental Procedure for Separation Constraint Layout of Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Dwyer</surname></persName>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Yehuda</forename><surname>Koren</surname></persName>
							<email>yehuda@research.att.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename><surname>Marriott</surname></persName>
						</author>
						<title level="a" type="main">IPSEP-COLA: An Incremental Procedure for Separation Constraint Layout of Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph drawing</term>
					<term>constraints</term>
					<term>stress majorization</term>
					<term>force directed algorithms</term>
					<term>multidimensional scaling</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We extend the popular force-directed approach to network (or graph) layout to allow separation constraints, which enforce a minimum horizontal or vertical separation between selected pairs of nodes. This simple class of linear constraints is expressive enough to satisfy a wide variety of application-specific layout requirements, including: layout of directed graphs to better show flow; layout with non-overlapping node labels; and layout of graphs with grouped nodes (called clusters). In the stress majorization force-directed layout process, separation constraints can be treated as a quadratic programming problem. We give an incremental algorithm based on gradient projection for efficiently solving this problem. The algorithm is considerably faster than using generic constraint optimization techniques and is comparable in speed to unconstrained stress majorization. We demonstrate the utility of our technique with sample data from a number of practical applications including gene-activation networks, terrorist networks and visualization of high-dimensional data.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>✦</head><p>Many fields of science, technology and industry require visualization of networks. For example, biologists study gene-activation networks and metabolic pathways, police study networks of associations between suspects to uncover organized crime or terrorist cells, and software and process engineers need to understand the complex networks of relationships between system components.</p><p>A wide variety of graph layout algorithms have been developed to aid such visualization. However, many of these algorithms are designed to draw simple, idealized mathematical graphs. This significantly limits their usefulness since, in many applications, the networks have much more complex structure and, consequently, more constraints on their layout. Such constraints include, for instance, requiring directed connections to be represented by arrows that point downward, grouping of selected nodes into clusters, large labels on nodes and edges, alignment of selected nodes, and an ordering on nodes perhaps reflecting an underlying physical ordering.</p><p>Current techniques for handling these application specific layout requirements are complex and are brittle in the sense that each technique can only handle a particular kind of layout constraint. Here we present IPSEP-COLA, an Incremental Procedure for Separation Constraint Layout of graphs. This is a new approach to network layout that provides a generic, robust framework that handles the constraints arising in a wide variety of applications. Our approach is relatively simple and is efficient enough to handle large networks with thousands of nodes.</p><p>The key idea behind IPSEP-COLA is to extend force-directed placement approaches for graph layout to allow so-called separation constraints. Force-directed placement algorithms are among the most successful approaches to the layout of simple graphs. They find an embedding of the graph in 2-D (or 3-D) space that minimizes some continuous goal function. A popular algorithm in this family has been that of Kamada and Kawai <ref type="bibr" target="#b15">[16]</ref> which attempts to minimize the sum of squared differences between ideal spacing for pairs of nodes and their Euclidean distance in the embedding. These approaches are rel-atively easy to implement, they can -with appropriate hierarchical data structures -scale up to large graphs, and they give reasonable layout for most input graphs. They are the most commonly used technique for drawing unstructured networks. The starting point for our approach is Gansner et al. <ref type="bibr" target="#b10">[11]</ref> who recently revisited force-directed placement and suggested using functional or stress majorizationan optimization technique from the field of multidimensional scaling. Compared to Kamada and Kawai, stress majorization has been shown to be faster and exhibit more robust convergence behavior.</p><p>We extend stress majorization to allow so-called separation constraints in each dimension. These have the form u + d ≤ v where u and v are variables representing horizontal or vertical position and d is a constant giving the minimum separation required between u and v. <ref type="bibr" target="#b0">1</ref> Although seemingly a very restricted kind of linear constraint, separation constraints are expressive enough to handle a wide variety of application-specific layout constraints. These include:</p><p>Directed edges We can ensure that node v is placed above (or, to the left of) node u if there is a directed edge from v to u. Alignment or distribution E.g. placing selected nodes on different horizontal layers. Bands By adding dummy variables we can ensure that nodes are placed in vertical or horizontal bands, as defined in <ref type="bibr" target="#b2">[3]</ref>. Fixed position A node's position can be fixed in any axis. Containment We can ensure that selected nodes lie in a rectangular region, for instance within the boundaries of page, window or a cluster dynamically sized to fit its contents. Orthogonal ordering between nodes We can ensure that nodes are to the left/right or above/below other nodes. Non-overlap of nodes and/or clusters By dynamically generating separation constraints we can ensure that nodes do not overlap each other and, in combination with containment constraints, that clusters do not overlap.</p><p>Our approach also handles dynamic layout. When a graph is modified in an interactive context usually we wish to find a new layout which is similar to the old layout, so as to preserve the viewer's "mental map" of the graph <ref type="bibr" target="#b16">[17]</ref>. It is straightforward to add separation constraints to preserve the orthogonal ordering of the nodes in the layout. Extending stress majorization to handle separation constraints has broader application in data visualization than just network layout since it allows this widely used multi-dimensional scaling technique to take into account layout constraints from the underlying structure. For instance placing data points in clusters or preserving some underlying ordering. This paper has two main contributions. The first is identifying the usefulness of separation constraints for modeling a wide variety of application specific network layout requirements. The second is an efficient algorithm for solving the force-directed placement problem in the presence of separation constraints. Stress majorization iteratively improves the drawing by minimizing a sequence of quadratic goal functions. We modify the method to minimize each quadratic goal function while satisfying the separation constraints. We solve the resulting Quadratic Program (QP) using an iterative gradient-projection algorithm that relies on a novel, incremental algorithm for projecting a point on to a set of separation constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Related Work</head><p>The work presented in this paper significantly extends our recent research on handling band constraints <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref> in stress majorization. As part of this we introduced the DIG-COLA drawing style for directed graphs in which the nodes are partitioned into an ordered sequence of bands. We also demonstrated the usefulness of band constraints for drawing networks such as rail-networks where the placement of nodes should reflect the underlying geography. Band constraints are a very restricted kind of separation constraints: for instance they cannot model containment, non-overlap or arbitrary vertical separation. Thus, generalizing to separation constraints greatly increases the usefulness of constraint-based stress majorization and opens a number of new applications for constraint-based force-directed layout. In order to handle this greater generality the algorithm we give for projecting on to separation constraints is quite different to that proposed for band constraints <ref type="bibr" target="#b4">[5]</ref>.</p><p>Augmenting force-directed layout with true constraints was first explored by He and Marriott <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>, where a Kamada-Kawai-based method was extended with an active-set constraint solving technique to provide separation constraints. However, only small examples of fewer than 20 nodes were tested and the scalability and potential applications of the technique were not examined.</p><p>Many researchers have suggested changes to classical forcedirected methods to provide some of the functionality of constraints. For example, Ryall et al. <ref type="bibr" target="#b19">[20]</ref> added stiff springs to a standard forcedirected model to keep user-selected parts of the diagram roughly spaced as desired; various works <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22]</ref> modified the goal function to discourage node overlaps; while Wang and Miyamoto <ref type="bibr" target="#b21">[22]</ref> and Huang and Eades <ref type="bibr" target="#b14">[15]</ref> augmenting force-directed models to draw clustered graphs. However, these approaches do not impose strict constraints on the layout, but rather change the force model so as to avoid overlaps or emphasize the partition to clusters etc. Thus there is no guarantee that the constraints are enforced and convergence is often problematic, requiring complex cooling strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Applications 2.1 Directed graph layout</head><p>Separation constraints can be applied to the problem of arranging a directed graph, where we want to convey hierarchy by orienting all edges ("arrows") in the same direction. If the digraph is acyclic, we can simply define a separation constraint for each edge (u, v) to require that u be positioned above v. If the digraph contains directed cycles we avoid cyclic constraints by omitting constraints for a -preferably minimal -number of edges. Many heuristics are available for solving this largest acyclic subgraph problem <ref type="bibr" target="#b8">[9]</ref>.</p><p>This approach results in at most one constraint per edge. This is very different from the band-constraints that we used in the previous DIG-COLA algorithm <ref type="bibr" target="#b2">[3]</ref>. The more restrictive band constraints typically mean that the constrained optimization problem can be solved more quickly, while per-edge constraints can achieve lower stress as defined in Eq. <ref type="bibr" target="#b0">(1)</ref>. As a measure of variation from desired edge length stress gives an indication of layout quality. <ref type="figure" target="#fig_0">Figure 1</ref> compares unconstrained layout for a reasonably large graph with layout subject to peredge separation constraints, DiG-CoLa band constraints and layout by the traditional Sugiyama method <ref type="bibr" target="#b20">[21]</ref> for arranging directed graphs. Note that, of the layouts enforcing uniform edge direction DiG-CoLa keeps edge-length relatively consistent but is unable to "unfold" the  graph. The Sugiyama strategy is a slight improvement in terms of number of edge crossings but there are a large number of very long edges (in some cases spanning nearly the entire width of the graph) making it difficult to see weakly connected components. Arguably, per-edge separation constraints offer the best available strategy for arranging large and mixed 2 directed graphs, e.g. in <ref type="figure" target="#fig_0">Figure 1</ref>(b) low stress is coupled with a clear display of the connectivity of the graph and the fewest edge crossings of any of the directed graph drawing methods. It should be noted that the popular Sugiyama framework is currently significantly faster when applied to large graphs, especially given recent advances <ref type="bibr" target="#b9">[10]</ref>. We would argue, however, that run-time scalability is not so useful if the output, when applied to large graphs, gives no insight into the graph structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graphs with labelled nodes</head><p>The nodes in graphs modelling real-world relational data usually correspond to some concept or information that needs to be indicated through a textual or graphical label. Separation constraints between the rectangular bounding boxes of labelled nodes give us a way to ensure that these labels do not overlap and hence, remain readable. Previously, overlaps between nodes in graphs arranged by force-directed layout could only be avoided by one of two methods. The first is the so called "layout adjustment" approach which involves a post-processing step that may significantly degrade the quality of the original layout. The second known approach is to add extra repulsive forces between node boundaries. This generally requires complex cooling schedules to achieve a convergent layout and secondly cannot guarantee no overlaps in all cases. By contrast using separation constraints to avoid overlaps avoids modifying the goal function, so that the final layout will still have been optimized subject to the aesthetic criteria of spacing nodes according to the graph path length between them, and guarantees that overlaps can never occur. All the labelled graph examples in this paper are arranged using non-overlap separation constraints.</p><p>The layout process is simple. A layout allowing overlaps is first (a) Original layout reproduced with permission from <ref type="bibr" target="#b1">[2]</ref> (b) IPSEP-COLA layout using cluster containment constraints and nonoverlap constraints obtained. Stress-majorization layout then continues subject to nonoverlap separation constraints generated prior to processing each dimension. Thus, nodes can "slide" past or around each other, but can never overlap. The constraints are generated using a fast scanline algorithm <ref type="bibr" target="#b5">[6]</ref> which produces at most 2n constraints for a graph with n nodes, e.g. see <ref type="figure" target="#fig_2">Figure 3</ref>. Note that after removing overlaps the stress-majorization process continues to monotonically decrease stress, meaning that convergence is guaranteed.</p><p>Non-overlap constraints can be combined with directed-edge constraints. For example <ref type="figure" target="#fig_1">Figure 2</ref> shows a gene activation network where non-overlap constraints and directed edge constraints are combined to produce a compact layout with near uniform edge length, where the precedence of gene activation is clearly shown and individual genes can easily be identified by their labels. A version without non-overlap constraints is also shown for contrast. Note that the gap required by the non-overlap constraints is set slightly larger than the actual node size. This leaves some space through which edges can be routed.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Clustered graphs</head><p>Separation constraints can also be used to require containment within some boundary. One possible application of such constraints is to require layout within the fixed width and height bounds of a page or arbitrarily sized window. Another example is layout where arbitrary groups of nodes -or clusters -are required to be placed within certain bounds. Combining these containment constraints with nonoverlap constraints (as illustrated in <ref type="figure" target="#fig_2">Figure 3</ref>) we are able to produce high-quality drawings of clustered graphs. Specifying constraints between nodes and cluster boundaries requires the use of dummy variables for each of left, right, top and bottom positions. We have also found that it is useful to specify a small attraction between the left and right, top and bottom pairs of dummy variables by trivial modification of the A matrix of Eq. (2). This helps to keep clusters compact relative to the rest of the graph. <ref type="figure" target="#fig_3">Figures 4 and 5</ref> show a possible application of this type of clustered graph layout. The data is a terrorist communication network studied in detail in Brams et al. <ref type="bibr" target="#b1">[2]</ref>. The figures appearing in the original paper were arranged using unconstrained force-directed layout. The authors identified subgraphs within which two-way communication (mutual influence) was observed between the terrorist suspects. Two of the original figures of Brams et al. are shown in <ref type="figure" target="#fig_3">Figures 4(a)</ref> and 5(a). Note that the mutual influence subgraphs, highlighted presumably manually, fall within non-convex boundaries that can overlap other parts of the graph. We would argue that in our rendering of the same networks <ref type="figure" target="#fig_3">(Figures 4(b)</ref> and 5(b)) the mutual influence cells are more easily identifiable. Notice also that in <ref type="figure" target="#fig_3">Figure 4</ref>(b) separation constraints have been used to force directed edges to point downwards while within the mutual influence networks, where the edges are bidirectional, no such constraints are applied. This helps to show the hierarchy within the terrorist organization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Directed and Clustered Multi-dimensional Scaling</head><p>Previously we introduced Directed Multidimensional Scaling (DMDS) as a way of displaying an ordered classification of high-dimensional data over a multidimensional-scaling plot <ref type="bibr" target="#b2">[3]</ref>. <ref type="figure" target="#fig_6">Figure 6</ref> shows a DMDS plot for breakfast cereal data, with separation constraints used to en-force a total order-based on a dietician's health rating-over the cereals. Note that for n data points n − 1 constraints are required to enforce a total ordering. Also new in this figure is the use of separation constraints to prevent overlapping labels. In our original figure <ref type="bibr" target="#b2">[3]</ref> overlaps had to be removed by hand to make the labels readable.</p><p>The non-overlap and containment constraints used above to draw clustered graphs give us yet another possibility for enriching an MDS data plot. In <ref type="figure" target="#fig_7">Figure 7</ref> we use such constraints to group the cereals by manufacturer in addition to the directional constraints highlighting health rating. This Clustered MDS (CMDS) plot allows us to easily see if manufacturers specialize in certain types of products. For example we might conclude that Nabisco generally produces healthier cereals than Post while Kelloggs appears to produce a wide variety of cereals.</p><p>Clearly the more constraints that are imposed on an MDS plot the more difficult it is to achieve a low stress value. The final stress value for a DMDS or CMDS plot can be used as a quality measure for the fit of the constraints to the data. Thus, we suggest that constraints can be imposed on an MDS plot to test a theory about the structure of the data and the final stress value could be considered a measure of the accuracy of the theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Algorithm 3.1 Problem formulation</head><p>The general goal or stress function that we seek to minimize is:</p><formula xml:id="formula_0">stress(X) = ∑ i&lt; j w i j (||X i − X j || − d i j ) 2<label>(1)</label></formula><p>where for each pair of nodes i and j, d i j gives an ideal separation between i and j (usually their graph-theoretical distance),</p><formula xml:id="formula_1">w i j = d −2 i j</formula><p>is used as a normalization constant and X is a n × d matrix of positions for all nodes, where d is the dimensionality of the drawing and n is the number of nodes. Majorization minimizes this stress function by iteratively minimizing quadratic forms that approximate and bound it from above.</p><p>At each iteration we determine the coordinates x of the nodes in each dimension by minimizing f (x) = 1 2 x T Ax − x T b where there are n  nodes A ∈ R n × R n is positive semi-definite matrix and x, b ∈ R n . The vector x is a column of X such that x i is the coordinate of node i. The reader is referred to <ref type="bibr" target="#b10">[11]</ref> for the definition of A and b.</p><p>In this paper we consider the case where we have additional separation constraints. A separation constraint c is of form u + a ≤ v where u, v are variables and a is the minimum gap between them. We use the notation le f t(c), right(c) and gap(c) to refer to u, v and a respectively. We require that constraints are axis separable in the sense that they always constrain variables in the same dimension.</p><p>We can treat a set of separation constraints C over variables V as a weighted directed graph with a node for each v ∈ V and an edge for each c ∈ C from le f t(c) to right(c) with weight gap(c). We call this the constraint graph. We define out(v) = {c ∈ C | le f t(c) = v} and in(v) = {c ∈ C | right(c) = v}. Note that edges in this graph are not the edges in the original graph.</p><p>We restrict attention to problems in which the constraint graph is acyclic, and for which there is at most one edge between any pair of variables. It is possible to transform any satisfiable set of separation constraints into an equivalent problem of this form as long as the gaps are non-negative. Thus, at each iteration step and for each dimension in the drawing we solve:</p><formula xml:id="formula_2">min x 1 2</formula><p>x T Ax − x T b subject to: C</p><p>We call this the Quadratic Programming with Separation Constraints (QPSC) problem.</p><p>Since A is positive semi-definite, the problem has only global minima. Such a QP problem can be solved in polynomial time <ref type="bibr" target="#b18">[19]</ref>. However, our experiments detailed in Section 3.3 show that generic QP solvers are quite slow at solving this problem. To accelerate computation we utilize two special characteristics of the problem: 1. During the majorization process, we iteratively solve closely related QPs: The matrix A is not changed between iterations, only the vector b is changed, while the constraints either remain unchanged or are slightly modified. We ensure that changes to the constraints maintain feasibility of the current solution. Therefore, the solution of the previous iteration is still a feasible solution for current iteration. Moreover, this previous solution is probably very close to the new optimal solution (e.g., consider that in most iterations the coordinates are only slightly changed). However, such "warm-start" initialization is fundamentally not trivial for the barrier (or interior-point) methods used by most commercial solvers. 2. Standard QP solvers allow general linear constraints. Separation constraints are very simple as each of them involve only two variables. Importantly, we can develop a method for solving (2) which takes advantage of this restricted form of constraint. Consequently, in the next section we describe a specialized algorithm for solving the QPSC problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Gradient Projection Algorithm</head><p>We give an iterative gradient-projection algorithm [19, pp. 476-481] for finding a solution to a QPSC Problem. The algorithm, solve QPSC, is shown in <ref type="figure" target="#fig_8">Figure 8</ref>. It first decreases f (x), by moving</p><p>x in the direction of steepest descent, i.e. the opposite of the gradient ∇ f (x) = Ax + b. For the moment ignore the call to the procedure split blocks. While we are guaranteed that -with appropriate selection of step-size s -the energy is decreased by this first step, the new positions may violate the constraints. We correct this by calling project, which returns the closest pointx to x which satisfies the separation constraints, i.e. it projects x on to the feasible region. Finally, we calculate a vector d from our initial positionx tox and we ensure monotonic decrease in stress when moving in this direction by computing a second stepsize α = arg min α∈ <ref type="bibr">[0,</ref><ref type="bibr" target="#b0">1]</ref> f (x + αd) which minimizes stress in this interval.</p><p>procedure <ref type="figure">solve QPSC(A, b, C)</ref> repeat While the algorithm given in <ref type="figure" target="#fig_8">Figure 8</ref> describes a fairly standard gradient-projection approach, the procedures project and split blocks are the part of the algorithm specific to our particular QP. The main difficulty in implementing gradient-projection methods is the need to efficiently project on to the feasible region.</p><formula xml:id="formula_4">g ← Ax + b s ← g T g g T Aĝ x ← x x ←x − sg nosplit ← split blocks(x) x ←project(C) d ←x −x α ← max( g T d d T Ad , 1) x ←x + αd until x − x sufficiently small and nosplit return x</formula><p>The projection operation essentially requires solving a QP of the form min x ∑ n i=1 (x i − p i ) 2 subject to the separation constraints C where p =x − sg is defined in the gradient-projection step. The project procedure ( <ref type="figure">Figure 9</ref>) iteratively changes the variable's positions till all constraints are satisfied. The algorithm works by merging variables into larger and larger "blocks" of contiguous variables connected by a spanning tree of active constraints, where a separation constraint u + a ≤ v is active if for the current position for u and v, u + a = v.</p><p>We represent a block B i using a record with the following fields: vars, the set of variables in the block; nvars, the number of variables in the block; active, the set of constraints between variables in the block which form the spanning tree of active constraints; posn, the position of the block's "reference point".</p><p>The algorithm also uses two arrays blocks and offset indexed by variables where block i gives the block of variable i and offset i gives the distance from i to its block's reference point. We have that the current position of variable i, posn(i), is given by the expression B block i .posn+ offset i .</p><p>On each call to solve QPSC we start from the blocks computed in the previous call to solve QPSC for that dimension and from the previously computed value for x. At the very start of the process we put each variable i in its own block and place it at x i .</p><p>The project procedure starts with the current set of blocks and moves them to their new optimal position. An invariant of the algorithm is that the reference point B.posn for each block B is at its optimal position which is simply the average of the variables in the block's desired positions appropriately translated to the same reference frame:</p><formula xml:id="formula_5">∑ i∈B.vars x i − offset i B.</formula><p>nvars . <ref type="figure" target="#fig_0">Fig. 10</ref>. An example of the use of expand block. Here, we are drawing a directed graph horizontally with the separation constraint that u + 1 ≤ v if there is an edge from u to v. <ref type="figure">Initially, the nodes A, B,C, D, E, F, G, H, I</ref> form a block connected by the active tree of constraints shown as black and red arrows. Now the edge from A to B is discovered to be violated. This is shown in blue in the top diagram. Since A and B are in the same block expand block is called. The core function of expand block is to determine where to split the current active tree of constraints to allow the edge (A, B) to be inserted. Edges which are valid split points shown in red dashes. Assuming that the valid split point with the smallest Lagrange multiplier is the edge (F, E), this edge will be removed from the active constraints being replaced by <ref type="figure">(A, B)</ref> to give the layout shown in the bottom.  <ref type="figure" target="#fig_0">Figure 10</ref>. It deals with a case where a previously constructed block now causes a constraint c between two variables in the block to be violated. To fix this we must identify where to split the current block and then rejoin the subblocks usingc. This "expands" the block to remove the violation, by spanning it using a different spanning tree of active constraints. More, precisely, we first compute the best constraint sc in the active set on which to split. To do this we compute the Lagrange multiplier lm c for each active constraint c in the block using the procedure comp dfdv introduced in <ref type="bibr" target="#b5">[6]</ref>. Lagrange multipliers are a fundamental notion in constrained optimization, but describing their properties is beyond the scope of this paper; the interested reader is referred to <ref type="bibr" target="#b18">[19]</ref>. Here, it suffices to understand that the value of lm c gives the rate of increase of the goal function as a function of right(c) − le f t(c). Thus the smaller the value of lm c the better it is to split the block at that constraint. However, not all constraints in the active set are valid points for splitting. Clearly we must choose a constraint that is on the path between the variables le f t(c) and right(c). The call to function comp path returns the list of variables [v 1 , ..., v k ] on the path from le f t(c) to right(c) along the constraints in the active set of constraints AC. Furthermore, to be a valid split point the constraint c must be oriented in the same direction asc, i.e. for some j, le f t(c) = v j and right(c) = v j+1 . The split constraint sc is simply the valid split constraint with the least Lagrange multiplier. The remainder of expand block splits the block by removing sc from the active set AC and then moves each variable in the right block, i.e. those connected to right(c), to the right by the amount required to fix the violation ofc. The constraintc is added to the active set for the block to rejoin the two sub-blocks and the block is placed at its optimal location.</p><p>As we have alluded, the call project(C) is not guaranteed to perform an exact projection of x onto C. It will always return a solution satisfying C but this may not be the closest feasible point to x. The problem is that project(C) can perform a merge which is later made unnecessary, but project never splits blocks even if this leads to a better solution.</p><p>In practice it is relatively rare for this to happen. We fix this problem lazily using the procedure split blocks. This takes the blocks from the previous iteration and places them at their new position. It then identifies which previous merges need to be undone by computing the Lagrange multiplier lm c for all active constraints c. If all of these are non-negative then no block needs to be split. Otherwise, for each block B i with a negative Lagrange multiplier we choose the constraint sc with the most negative lm c and remove this from the active set AC for the block. The variables connected to right(sc) are removed from B i and placed in a new block B right <ref type="bibr">(sc)</ref> . The other fields are appropriately updated. This ensures that on termination a locally optimal solution is found.</p><p>We have previously defined the problem of adjusting a graph layout so that all overlaps between nodes are removed as the solution to a QP with separation constraints <ref type="bibr" target="#b5">[6]</ref>. In fact that QP was the same type of sum-of-least-squares problem that is required in the projection step of a constrained majorization algorithm involving separation constraints. That is, the problem involved finding a solution that minimized the sum of squared displacements of all nodes -in the same way that in the projection step of gradient projection we need to displace each variable by as little as possible in order to satisfy the constraints. However our previous algorithm was non-incremental, slow if an exact projection was required, and complicated to implement (a number of special cases must be handled for correct behavior <ref type="bibr" target="#b6">[7]</ref>). The algorithm given above is quite different, incremental, reasonably fast and asymptotically exact.</p><p>It is worth pointing out that the worst case complexity of solve QPSC is O((n + m) 2 ) where n is the number of variables and m the number of constraints. Typically the number of constraints is linear in the number of variables in which case the algorithm is quadratic in the number of variables. This is the same as the complexity in the unconstrained case and the complexity of our dedicated solver used for solving band constraints <ref type="bibr" target="#b4">[5]</ref>.</p><p>The complexity is computed as follows. Since A is an n × n matrix, the complexity of computing g, s and α is O(n 2 ). The complexity of split blocks is O(n) since the total number of active constraints is O(n) as they form a spanning forest for the variables. The complexity of project is O(m × (n + m) + n). The main while loop can only be called O(m) times since once a constraint is made active it can never become violated again. This is because if it is active then it cannot be violated because of the way blocks are constructed. It can only be made inactive by a subsequent call to expand block in which case it will be implied by the other active constraints and so cannot become violated since these cannot be violated. At each iteration of the main while loop the most violated constraint must be determined. Currently we scan through all non-active constraints which has cost O(m). We plan to investigate more efficient data structures in the future. Both merge block and expand block are O(n) in the number of variables in the blocks being merged or expanded. Clearly the last for loop has O(n) complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Algorithm Performance</head><p>To test the efficiency of the solve QPSC algorithm we used it to arrange a set of graphs using directed edge constraints. Our test data is a set of 52 graphs from the Matrix Market <ref type="bibr" target="#b0">[1]</ref>, the AT&amp;T Graphs collection <ref type="bibr" target="#b2">3</ref> and other sources <ref type="bibr" target="#b3">4</ref> . The graphs were chosen to be representative of different application domains (software design diagrams, gene activation networks, citation networks, etc.) and different types of graph structure including both dense and sparse graphs, regular meshes and scale-free networks.</p><p>We compared running time for constrained layout using the solve QPSC algorithm and the commercial Mosek quadratic program solver <ref type="bibr" target="#b17">[18]</ref>. We also compare against unconstrained layout using the conventional conjugate gradient method to solve the quadratic subproblems. The results are shown graphically in <ref type="figure" target="#fig_0">Figure 11</ref>. The independent variable is edge count for each sample graph, which corresponds to the number of constraints required and should therefore vary proportionally to running time and stress.</p><p>From the chart it is easy to see that the purpose designed solve QPSC solver is faster than Mosek in all cases, usually by at least <ref type="figure" target="#fig_0">Fig. 11</ref>. Running time for unconstrained layout and layout with directed edge constraints using either solve QPSC or the Mosek solver to solve the quadratic program. a factor of 10 (note the log scale). Generally solve QPSC is somewhat slower than unconstrained layout. The exceptions occur when a constrained local minimum is reached in relatively few iterations. The trade-off is that the constrained solution has higher stress and may therefore be less readable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>An obvious limitation of the IPSEP-COLA method is that separation constraints must be linear and orthogonal to the axes. This is a problem when nodes have non-rectangular boundaries. Also, clustered graphs could be arranged more compactly if clusters could be fitted with nonoverlapping convex hulls rather than simple rectangles. It is possiblethough somewhat complicated and computationally expensive-to approximate arbitrary linear constraints with separation constraints by modifying the goal function slightly. Non-linear constraints can be approximated by a sequence of line-segments. We have recently explored such a process with application to edge routing <ref type="bibr" target="#b7">[8]</ref>.</p><p>Another limitation, as described in Section 2.1, is that constraints must be satisfiable, for example, care may need to be taken to avoid generating cyclic constraints. We are working on a modified solver that can detect cycles and relax the constraints involved until they can be satisfied. Also, the more constraints that are placed on layout the greater the problem of local minima. Generally, for highly constrained graphs we would suggest a preprocessing step such as unconstrained layout or a method for quickly finding a feasible arrangement.</p><p>The greatest advantage of IPSEP-COLA over other graph drawing algorithms is its flexibility. The mapping of drawing conventions to constraints is potentially simple enough that users of network visualization and diagramming tools can define constraints interactively. Such interactivity is further facilitated by the incremental nature of the method. That is, the constrained stress majorization process can begin from any input arrangement and the layout process animated to preserve the mental map. Finally, IPSEP-COLA provides a single generic technique for arranging real-world networks using the most common drawing conventions. This contrasts strongly with the current state of affairs in which different drawing conventions and layout constraints require very different algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>(a) Unconstrained layout -no uniform edge direction, 1,142 edge crossings, stress=39,954 (b) Drawn as a DAG using a separation constraint for every directed edge -all edges point downwards, 3,617 edge crossings,stress=49,035 (c) Drawn as a DAG using DIG-COLA style level constraints -all edges point downwards and nodes are globally ordered according to hierarchical levels, 7,600 edge crossings, stress=74,894 (d) Drawn as a DAG using Sugiyama style layout, nodes arranged into levels such that all edges point downwards, 6,148 edge crossings, stress=N/A Drawings of the bus1138 graph [1] using different sets of constraints. Stress is computed using Eq. (1) with a desired edge length of 1. Long edges are highlighted in red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Directed-edge constraints and non-overlap constraints A gene-activation network arranged with directed edge constraints and non-overlap constraints.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Illustration of possible separation constraints required to avoid overlap between nodes and to keep nodes within their cluster boundaries. Constraints are shown as arrows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Mutual influence sets in a terrorist network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>(a) Conventional force-directed layout (reproduced with the authors' permission from [2]) (b) IPSEP-COLA layout using cluster containment constraints and non-overlap constraints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Mutual influence sets in a larger terrorist network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Various cereal brands arranged using Directed Multi-Dimensional Scaling, i.e. separation of the cereals is based on the similarity of their nutritional data while directed edge constraints have been used to require that the healthier cereals (as determined by a dietitian's ranking) must be higher than less healthy cereals. Red coloring indicates high sugar content.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Various cereal brands arranged using Clustered Multi-Dimensional Scaling, clustered by manufacturer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Algorithm to find an optimal solution to a QPSC problem with variables x 1 ,...,x n , symmetric positive-semidefinite matrix A, vector b and separation constraints C over the variables.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>violation(c) = posn(left(c)) + gap(c) − posn(right(c)). If c connects two different blocks B L and B R then we merge the two blocks connected by c using the function merge block(L, R, c). This function adds block B R to B L with c as the active connecting constraint. It appropriately computes the new position for the block in terms of the positions of B R and B L . If c connects two variables in the same block B b , then we use expand block(b, c) which pushes the variables in the block apart by making c active. We repeat this until no constraint is violated in which case we have (almost) projected on to the constraints. The procedure expand block(b,c) is the most complex part of the algorithm. An example of its use is shown in</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">In addition we can also handle equalities of the form u+ d = v.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">For graphs with mixed directed and undirected edges no separation constraint needs to be assigned to undirected edges and hence, these can lie horizontally -other layout methods such as Sugiyama force undirected edges to span layers.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">ftp://ftp.research.att.com/dist/drawdag/dg.gz<ref type="bibr" target="#b3">4</ref> Our test data is available from www.csse.monash.edu.au/∼tdwyer</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Acknowledgements</head><p>We have implemented IPSEP-COLA in the Neato layout tool distributed with the Graphviz package from AT&amp;T. Thanks to Emden Gansner for incorporating our changes into the Graphviz code repository. We wish to thank Stephen J. Brams for permission to use the terrorist networks shown in <ref type="figure">Figures 4 and 5.</ref> </p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Of course moving the blocks may mean that some constraints are now violated. We repeatedly find the most violated constraint c where    <ref type="figure">Fig. 9</ref>. Algorithm to project variables to the closest feasible position.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Matrix Market: A web resource for test matrix collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Boisvert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pozo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Remington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dongarra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quality of Numerical Software</title>
		<imprint>
			<publisher>Chapman Hall</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="125" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Influence in Terrorist Networks: From Undirected To Directed Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Brams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">L</forename><surname>Ramirez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Studies in Conflict and Terrorism</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">7</biblScope>
			<publisher>Taylor and Francis</publisher>
		</imprint>
	</monogr>
	<note>to appear 2006</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">DIG-COLA: Directed Graph Layout through Constrained Energy Minimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Information Visualization (Infovis&apos;05)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="65" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Drawing Directed Graphs Using Quadratic Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="536" to="548" />
			<date type="published" when="2006" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Stress Majorization with Orthogonal Ordering Constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int. Symp. Graph Drawing (GD&apos;05)</title>
		<meeting>13th Int. Symp. Graph Drawing (GD&apos;05)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">3843</biblScope>
			<biblScope unit="page" from="141" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fast Node Overlap Removal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int. Symp. Graph Drawing (GD&apos;05)</title>
		<meeting>13th Int. Symp. Graph Drawing (GD&apos;05)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">3842</biblScope>
			<biblScope unit="page" from="153" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Fast Node Overlap Removal -Addendum</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<ptr target="http://www.csse.monash.edu.au/∼tdwyer/FNORAddendum.pdf" />
		<imprint/>
		<respStmt>
			<orgName>Monash University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Integrating Edge Routing into Force-Directed Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wybrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int. Symp. Graph Drawing (GD&apos;06)</title>
		<meeting>14th Int. Symp. Graph Drawing (GD&apos;06)</meeting>
		<imprint>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>to appear 2007</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A New Heuristic for the Feedback Arc Set Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Australian Journal of Combinatorics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="15" to="26" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An Efficient Implementation of Sugiyama&apos;s Algorithm for Layered Graph Drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eiglsperger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Siebenhaller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="305" to="325" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Graph Drawing by Stress Majorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int. Symp. Graph Drawing (GD&apos;04)</title>
		<meeting>12th Int. Symp. Graph Drawing (GD&apos;04)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">3383</biblScope>
			<biblScope unit="page" from="239" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Drawing Graphs with Non-uniform Vertices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Working Conference on Advanced Visual Interfaces (AVI&apos;02)</title>
		<meeting>Working Conference on Advanced Visual Interfaces (AVI&apos;02)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Constrained Graph Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Symp. Graph Drawing (GD&apos;96)</title>
		<meeting>3rd Int. Symp. Graph Drawing (GD&apos;96)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">1190</biblScope>
			<biblScope unit="page" from="217" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Constrained Graph Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Constraints</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="289" to="314" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Fully Animated Interactive System for Clustering and Navigating Huge Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5rd Int. Symp. Graph Drawing (GD&apos;98)</title>
		<meeting>5rd Int. Symp. Graph Drawing (GD&apos;98)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1547</biblScope>
			<biblScope unit="page" from="374" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Algorithm for Drawing General Undirected Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kawai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="7" to="15" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Layout Adjustment and the Mental Map</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Misue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="183" to="210" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Mosek Optimization Toolkit V3.2 www.mosek</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Numerical Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nocedal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wright</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Interactive Constraint-Based System for Drawing Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ryall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Shieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on User Interface Software and Technology</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="97" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Methods for Visual Understanding of Hierarchical Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="109" to="125" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Generating Customized Layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miyamoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Int. Symp. Graph Drawing (GD&apos;95)</title>
		<meeting>2nd Int. Symp. Graph Drawing (GD&apos;95)</meeting>
		<imprint>
			<biblScope unit="volume">1027</biblScope>
			<biblScope unit="page" from="504" to="515" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
