<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ASK-GraphView : A Large Scale Graph Visualization System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">James</forename><surname>Abello</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Van Ham</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neeraj</forename><surname>Krishnan</surname></persName>
						</author>
						<title level="a" type="main">ASK-GraphView : A Large Scale Graph Visualization System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Information Visualization</term>
					<term>Graph Visualization</term>
					<term>Graph Clustering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We describe ASK-GraphView, a node-link-based graph visualization system that allows clustering and interactive navigation of large graphs, ranging in size up to 16 million edges. The system uses a scalable architecture and a series of increasingly sophisticated clustering algorithms to construct a hierarchy on an arbitrary, weighted undirected input graph. By lowering the interactivity requirements we can scale to substantially bigger graphs. The user is allowed to navigate this hierarchy in a top down manner by interactively expanding individual clusters. ASK-GraphView also provides facilities for filtering and coloring, annotation and cluster labeling.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Over the past years two of the authors have spent significant time and effort designing, deploying and reviewing visualizations of large graphs. Most current systems are focused on nicely visualizing relatively small graphs <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b23">24]</ref> while most of the recent academic techniques in large scale visualization and graph drawing are focused on providing static drawings of relatively large graphs. Often these techniques are only applicable to graphs with specific structural properties. For example, <ref type="bibr" target="#b18">[19]</ref> is only truly effective for very sparse or tree-like graphs. Layout techniques such as <ref type="bibr" target="#b17">[18]</ref> offer increased scalability but are only really effective on grid-like graphs, such as those resulting from finite element methods.</p><p>Some of the interaction techniques and systems that have been proposed to navigate graphs (such as <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>) use the clustered graph navigation paradigm, which allows the user to navigate a potentially large graph by iteratively expanding or collapsing aggregate (cluster) nodes. However, these proposals assume a hierarchy is given for the input graph, which is rarely the case in practice. Their implementations are also limited in scale, with samples given for graphs of a few hundred nodes.</p><p>Other techniques, such as <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> also use the clustered graph paradigm. They create a hierarchy by using a fast algorithm and then display this hierarchy in an adjacency matrix representation. Because these systems construct a single huge hierarchy for a very large graph, the clustering algorithm used cannot be too sophisticated and often results in suboptimal hierarchies.</p><p>A second practical problem is that some users find it hard to understand the abstract matrix representations <ref type="bibr" target="#b15">[16]</ref> of graphs that are used in these systems. We think that if a desktop node-link graph visualization is to be successfully applied as a practical tool for analysis of large amounts of data it needs to provide at least the following functionality:</p><p>1. A scalable architecture that is able to deal with hierarchical graphs even if they do not fit the RAM of the desktop machine and does not depend on the precise characteristics (such as density or link structure) of the graph (Section 4);</p><p>2. The ability to automatically cluster large graphs, even if there is no additional hierarchical information available. Note that an often overlooked issue is the fan-out and depth of the hierarchy, which need to be controlled if one wants to navigate a graph interactively (Section 5);</p><p>3. Interactive techniques that allow the user to filter and explore this hierarchy without losing context (Section 6).</p><p>We present ASK-GraphView: a system that addresses all of these issues and is currently being used for the analysis of graphs with up to 200,000 nodes. Among the practical use cases of the system are manual inspection and updating of search content, assessment of new clustering approaches and infrastructure maintenance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>ASK-GraphView combines two major ideas from existing graph visualization systems. For user interaction and navigation it uses a node link layout of a clustered graph, which allows users to arbitrarily expand and collapse clusters to show the subgraph below. This basic idea is described in <ref type="bibr" target="#b11">[12]</ref> and a number of experimental implementations based on it have been presented <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b19">20]</ref>. However, all of these implementations assume that the actual cluster hierarchy is either provided in the data or manually supplied by the user. Manually creating a hierarchy for a huge graph with unknown structure is difficult and tedious, and automatically creating a suitable hierarchy for a very large graph in limited time is by no means an easy task either. A second problem with these approaches is that users often tend to lose context when navigating clustered graphs with deeper hierarchies (in our opinion, more than 4 or 5 levels deep).</p><p>In terms of architecture ASK-GraphView borrows the concepts of memory and disk resident antichains from previous work on large graph navigation <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref> and expands on these by incorporating time constraints. In previous approaches we used matrix oriented views of the antichains, but users often found these views too abstract <ref type="bibr" target="#b15">[16]</ref>. Also, these views did not allow inspection of fine graph details and their relationships to the rest of the graph. Our system is probably closest to Tulip <ref type="bibr" target="#b6">[7]</ref> which also provides automatic rendering and clustering. The main difference is that Tulip has been set up as a flexible test bed for graph visualizations, allowing (expert) users to compose different layouts and clustering approaches. We instead aimed for a system that can automatically provide a useful visualization of a graph upon loading and is easily accessible to domain experts with no visualization experience. Other related interaction techniques for large graphs include fisheye views of large clustered networks <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17]</ref>. These create an abstraction of the graph based on the positions of one or more foci such that nodes nearer to the focus are displayed in greater detail. The major practical disadvantage of these types of views is that it is very hard to relate two visualizations of the same graph with different foci, even when providing visual cues such as animation or coloring.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PRELIMINARY DEFINITIONS</head><p>We consider weighted undirected graphs G = (V, E, w) where V and E denote the set of vertices and edges respectively. w is a function that assigns to each edge in E a non-negative real weight. |V| and |E| denote the cardinalities of V and E. A subgraph of G is said to be induced by a subset U of V, if it consists of the nodes in U and those edges in E that have both endpoints in U. We denote an induced subgraph by G(U). A hierarchy tree TG for a graph G is a tree rooted at r whose set of leaves is in one to one correspondence with V. That is, leaves(r) = V, if we denote the set of descendant leaves of a node u in the tree by leaves <ref type="bibr">(u)</ref>. The set of children of a node u is denoted by children <ref type="bibr">(u)</ref>. Similarly, the unique parent of u is denoted by parent(u).</p><p>A (maximal) antichain A in TG is a (maximal) set of nodes in TG such that no two distinct nodes in A are ancestors of one another. An antichain A 1 is said to be above another antichain A 2 if each node in A 1 is an ancestor (not necessary proper) of a node in A 2 .</p><p>A maximal antichain A formalizes the notion of abstract views <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, slices <ref type="bibr" target="#b1">[2]</ref> or abridgements <ref type="bibr" target="#b11">[12]</ref> and it defines a partitioning of the nodes of G. On this partitioning we can define a macro edge set E'={e ab : a A b A : ( e xy E: x leaves(a) y leaves(b))} with weights w(e ab ) = w(e xy ): e xy E: x leaves(a) y leaves(b). The weighted graph (A, E') is a macro view of G. To make the defining antichain A explicit we refer to it as an A-view of G (see also <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>). In other words, the A-view of a graph is a macro graph consisting of the nodes in A and the macro edges connecting them. In the rest of this paper we assume that the visualization client has random access to every macro edge of a view, that is, we have a data structure available that stores both a hierarchy TG and the entire macro edge set on that hierarchy in RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ARCHITECTURE</head><p>ASK-GraphView is a client server system that builds a data structure (i.e. a hierarchy tree) that treats the available screen (S), random access memory (R) and disk as three buffers of increasing size and with different access characteristics. Although we have previously considered only size constraints [1,2,3], we cannot offer interactive navigation if we do not also consider the temporal dimension. That is, we have to ensure that we are able to process any data that is transferred from disk to RAM (clustering) and from RAM to screen (layout) in reasonable time.</p><p>To address the first issue, we construct a stack of progressively finer disk resident macro views of our graph, such that the increase in number of edges in successive macroviews is limited (see also <ref type="figure">Fig. 1</ref>). We deal with the second issue by customizing a structural clustering algorithm such that we can guarantee that the fan out of the hierarchy generated by that algorithm is bounded.</p><p>The rest of this section discusses the system's time/space parameterized data structure and the direct relation between macroviews and antichains in hierarchy trees. In Section 6.2 we present a notion of graph context that allows the user to explore the graph without exceeding S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Constrained Resources</head><p>In interactive graph navigation our two main bottlenecks are space and time. Space refers both to the maximum size of the graph R which we can still store in RAM and the maximum size S of the graph that we can interactively show on screen (see also <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref>). However, if we want to offer interactive navigation of large graphs we also need to consider the time dimension.</p><p>The two main bottlenecks here are the time needed for computation of a clustering and the time needed for computation of a layout. IL (Interactive Layout) and IH (Interactive Hierarchy) are interactivity parameters that encode sizes of (sub)graphs for which a drawing and a hierarchical clustering can be computed in desired response times t L and t H (in our case a few seconds). We express IL in terms of the number of nodes and IH in the number of edges in the (sub)graph. Suitable values for IL and IH are obtained experimentally and clearly depend on the sophistication of the desired layout or hierarchy tree computation and the level of required interactivity for both. Given the current state of algorithmic knowledge and typical hardware configurations, it is reasonable to assume that IL &lt; S IH &lt; R.</p><p>The parameter IL effectively controls the maximum fan out of nodes in the hierarchy we are using to interactively navigate the graph. A hierarchy that has a maximum fan out of 10,000 is clearly not suitable to use for the interactive navigation of a graph, since it would take us too long to compute a satisfactory layout for a subgraph this big. Apart from this time constraint, IL is also limited by the user's ability to visually 'digest' the new subgraph presented. We determined empirically that IL = 64 provides a reasonable tradeoff between scale and readability.</p><p>Similarly, IH represents the maximum amount of edges for which we can compute a hierarchy in a few seconds, regardless of the density of the graph. Using the procedures described in Section 5, we are able to hierarchically cluster around 100,000 edges at an interactive rate. Both of these navigation parameters are used to tune system performance in order to offer truly interactive graph navigation. In the following sections we assume that 2 &lt; IL 2 &lt; IH and d*IL &lt; S where d is a small non zero integer.</p><p>Trying to navigate dense graphs with node link diagrams is not really useful and other representations (such as adjacency matrices) might be more suited here. However, theoretically our infrastructure is also able to deal with denser graphs by replacing the clustering and hierarchy tree computation procedures by a simpler version that groups nodes together such that the fan out in the hierarchy tree is at most IH. A more efficient alternative on weighted input graphs is pruning the graph by weight such that at most |V| |V| edges remain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. A hierarchy on an arbitrary input graph G = (V, E). AC R</head><p>indicates the part of the graph that is processed in RAM. AC IH indicates the part of the hierarchy that is sent to a visualization client for further processing and visualization. For each node in AC IH we ensure that there are no more than IH edges in the subgraph induced by its descendants on AC R below.</p><formula xml:id="formula_0">r AC IH AC R Leaves(r) = V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IH edges</head><p>The main idea behind the architecture is that by reusing the parameter IH when navigating a macro view of a graph with IH edges, we can expand any node in that macroview to a new subgraph, again with at most IH edges ( <ref type="figure">Fig. 1)</ref>. Given that the maximum density is |V| |V|, a subgraph of IH edges consists of at least IH 2/3 nodes. For each of these nodes we can then nest a new subgraph of IH 2/3 nodes, resulting in a total of IH 4/3 nodes below, having at most IH 2 edges (given density |V| |V|). In practice however we cannot possibly create a hierarchy tree for a graph this big because our RAM size R can fit only a limited number of edges, so usually R &lt; IH <ref type="bibr" target="#b1">2</ref> . If we use 32 bytes per edge, a server with 2GB of RAM available for edge storage will allow us to store in the order of 16 million edges.</p><p>This means that undirected graphs with up to 16 million edges are navigable with our software infrastructure (depending on available RAM) and this in turn offers a solution to the interactive navigation of graphs with up to 4,000 vertices with no qualifications. This number might seem disappointing since these graphs are not really that large. However, the real gains of our approach become noticeable by considering graph density, i.e. if |E| &lt; |V| |V|, |V| lies between 64,000 and 300,000 vertexes. Similarly, if |E| &lt; |V|log(|V|), |V| lies between 300,000 and 16,000,000 vertices.</p><p>To our knowledge these results represent a substantial improvement over previous work dealing with the navigation of graphs represented by node-link diagrams, without posing qualifications on the actual structure of the graph. In summary, the lower the density of the input graph the larger graph scalability we obtain and improvements in clustering algorithms (i.e. higher IH) will automatically make navigation of larger graphs possible subject to RAM availability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2</head><p>Data Structure The fundamental data structure at the server level is a hierarchy tree TG that is parameterized by IH and R. The central idea is to find an antichain AC R whose associated AC R -view can be processed on the available RAM of size R and an antichain AC IH above AC R that can be processed in an interactive fashion. The antichain AC IH is then processed on the client side to create a hierarchy. Should the user require parts of the hierarchy that are below AC IH , the client sends a request to the server for more data which is subsequently processed in a similar manner. We assume throughout that IL &lt; S &lt;= IH &lt; R, where |V| &lt; R &lt; |V|+|E| (i.e. G is a semi-external graph as in <ref type="bibr" target="#b1">[2]</ref>).</p><p>Definition: A good (IH, R)-parameterized hierarchy tree TG for a graph G = (V, E) has the following properties:</p><p>1. It has a maximal antichain AC IH above a maximal antichain AC R such that the AC IH and AC R -views of G are of sizes not more than |IH| and R, respectively. This requirement allows us to process the hierarchy in the first place. 2. Each of the subtrees rooted at nodes in AC IH have at most |IH| edges among their descendants in AC R . This ensures that the server will return a reasonable amount of edges for each data request.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The subgraph induced by leaves(u) of each node u in AC IH</head><p>is connected. This is a minimal requirement to ensure that the subgraphs returned by the server reflect some of the graph's structure. Ideally, we would like each node u to reflect a dense cluster in the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The depth of TG is log(|E|).</head><p>To ensure within-group connectivity and incorporate subgraph density and edge weights during the process, we use an ordered external memory version of Boruvka's contraction algorithm <ref type="bibr" target="#b0">[1]</ref> that produces a binary hierarchy tree in O(log(|V|/R)) passes over the input data. It also produces an antichain on it with no more than the desired number of elements R. The obtained R-view then, is a memory resident macro view of the original semi-external input graph G. Since AC R fits in RAM we can use now an internal memory version of the same described algorithm with AC R as input to obtain a second antichain AC IH .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Reducing the Depth of the Hierarchy</head><p>Running the procedure mentioned above may provide suboptimal results because the binary hierarchy might be very unbalanced. As an extreme case, consider a binary hierarchy where each node has one leaf and one non-leaf (except for the bottommost node). We refer to such a (part of a) hierarchy as a comb. Any antichain of size n in a comb, will have exactly n-1 leafnodes and one cluster. Clearly this is not a balanced abstraction of a graph. To address this problem we create a more balanced hierarchy by reducing the depth of the given binary hierarchy as much as possible without compromising the structural information that is contained in the hierarchy. We do this by aggregating a select set of nodes in the binary hierarchy under a common parent.</p><p>To guarantee that we can always find an antichain AC IH above AC R such that for any node in AC IH the number of edges among their descendants on AC R is no more than IH (see requirement 2 in 4.2), we have to limit the number of nodes we can aggregate. As an example consider a set of 500 nodes in AC R that are aggregated under a single parent. Worst case, we might be dealing with a locally complete subgraph with 500 2 = 25,000 edges, which we cannot process due to the limited IH and which we cannot split anymore because all nodes are aggregated under a single parent.</p><p>To avoid these problems we define an internal degree parameter ID that indicates the maximum allowed fan out in our hierarchy tree. From our above discussion it should be clear that ID 2 IH. Prime candidates for aggregation are the combs we described previously and we therefore aggregate all nodes in the comb under the rootnode of this comb. If this aggregation step leads to a fan out higher than ID, we recursively split this cluster into subclusters of a most ID nodes. <ref type="figure" target="#fig_0">Fig. 2</ref> shows a sample of comb reduction using an ID of 4. After depth reduction we find a suitable antichain AC IH by aggregating upward from our memory resident antichain AC R . The resulting AC IH -view is then passed to the visualization client for clustering. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CLUSTERING</head><p>In the previous section we used a specialized hierarchy tree to create graph abstractions AC IH and AC R that allow us to break down the entire graph into more manageable pieces of size at most IH edges.</p><p>In this section we present a sequence of structural clustering operations that we apply to each of these pieces on demand. The hierarchy resulting from this clustering is then used to drive the visual navigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.1</head><p>Preprocessing From a graph drawing perspective, it does not make much sense to employ expensive algorithms such as force directed algorithms to compute a layout for tree-like parts of the graph. We use a special case of a linear time process known as peeling <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b20">21]</ref> to identify peripheral tree-like sections and group them together. If the user decides to expand such a tree group, we can employ much more efficient tree specific algorithms to provide a layout.</p><p>We find subtrees in the graph by iteratively identifying nodes with degree one and subsequently decreasing the degree of its neighbor by one. We call the set of trees induced by these nodes the peripheral forest of the graph. Since the peeling process can be implemented in time linear on the number of edges <ref type="bibr" target="#b8">[9]</ref> we can identify the peripheral forest of G efficiently. If G is connected and not a tree, then each subtree t in the peripheral forest of G is incident to a vertex rt in the complement of the peripheral forest. We then group together all subtrees in the peripheral forest that are incident to rt along with rt itself. Applying peel grouping reduces the amount of vertices that need to be analyzed significantly, and is also meaningful at a structural level.</p><p>Biconnected components (BCC's) provide another high level view of the structure of a graph. A BCC is a connected subgraph that cannot be broken into multiple components by removing a single node or edge. The BCC's of a graph form a partition of E and can be computed efficiently in O(|V|+|E|) <ref type="bibr" target="#b22">[23]</ref>. Those vertices or edges whose removal disconnects the graph are called articulation points and bridges respectively.</p><p>A large number of induced subtrees in a graph corresponds to a large number of BCC's (more precisely one for each vertex in the subtree). However, by first applying tree grouping as outlined above and then applying a biconnected component decompostition to the resulting graph we obtain a substantially smaller number of BCC's without losing essential biconnectivity information, as was proposed in <ref type="bibr" target="#b3">[4]</ref> and independently in <ref type="bibr" target="#b5">[6]</ref>. However, biconnected components form a partition on the edge set of the graph, where we need a partition of the vertex set. We address this problem in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.2</head><p>Biconnected component vertex decomposition The next step is to obtain a vertex partition from the edge partition provided by the biconnectivity decomposition. Simply creating a partition based on biconnected decomposition by assigning each articulation point to a separate cluster might provide undesirable results since this can create a single biconnected component cluster consisting of multiple disconnected components.</p><p>The trick is to replace each articulation vertex a that is shared among k biconnected components B 1 , B 2 ,â€¦, B k by a star centered at a new vertex a' with k spokes, where the i th spoke connects a' to a new 'cloned' vertex named a i and where the neighborhood of a i is a' {v : v B i (a, v) E}. We refer to the a i 's as clones of a and to a' as the central clone of a (see <ref type="figure" target="#fig_1">Fig. 3</ref>).</p><p>Notice that by introducing clones for each articulation point we obtain an enlarged graph G' with more vertices than the original one, but with disjoint BCC's. Deleting the central clones and identifying their associated clone vertices gives us back the original graph. The biconnected decomposition tree of this enlarged graph contains essentially the same biconnected information as the original graph with some redundancy added by the incorporation of the clone vertices.</p><p>We can then use G' to represent a clustering of the original graph G by the obtained BCC vertex decomposition. We create one cluster for each BCC and any cloned articulation points in that BCC and one cluster for the central clone of an articulation point. This BCC clustered graph then serves as a top level view from which we can explore the rest of the graph. However, it might very well be possible that the number of nodes in a particular biconnected component B is too large for us to layout or comprehend, that is |B| &gt; IL. In that case we have to resort to an off-the-shelf algorithm to compute a clustering, and we apply it recursively to further break down the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.3</head><p>Recursive Clustering To enforce that our hierarchy has a maximal fan out of IL we recursively break clusters c for which |children(c)| &gt; IL by applying a clustering algorithm of choice (in our case a tuned version of MCL <ref type="bibr" target="#b9">[10]</ref>) using the children(c)-view as input. When this clustering algorithm returns we have to deal with either one of three cases, depending on the clusters C that were returned: The whole clustering pipeline (Peeling -BCC -MCL -contraction) outlined above completes in a matter of seconds since we can guarantee that the size of the input subgraph will never be more than IH. The resulting hierarchy on AC IH is then used to drive the visualization.</p><formula xml:id="formula_1">IL &lt; |C|&lt;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">VISUALIZATION</head><p>Although some of our previous visualizations for large graphs have mainly focused on matrix oriented representations, we found that in practice these often seemed too abstract and confusing to the novice user. Matrices have the disadvantage that two links that share the same node need not be close together in the adjacency matrix. This makes it particularly hard to identify interesting graph structures, such as subtrees or barrel-like structures, from a matrix representation. In the GraphView system we opted for a node-link visualization of a clustered graph, similar to the approach described in <ref type="bibr" target="#b11">[12]</ref>. The user is allowed to 'open up' clusters of interest, after which the system will embed a more detailed version of that cluster in the current layout.</p><p>However, simply allowing the user to successively click open multiple levels quickly leads to disorientation and context loss. The ASK-GraphView system incorporates a number of options to address this problem. Firstly, instead of rendering only the subgraph induced by the clicked cluster <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, we keep the entire contextual view of the graph visible at all times. The user is allowed to smoothly zoom in and out of context using the scrollwheel. Secondly, we provide a traditional textual indented treeview to the side of the main window that lists the labels of the nodes in the hierarchy. To avoid the user having to scroll through the entire list looking for a specific node, we also provide a search box above it. The treeview and searchbox are useful if the user is looking for a specific item in the data, but doesn't know where that item is located in the hierarchy. Thirdly, we provide a sketch of the entire hierarchy at the top of the main window in the form of an outlined and fisheyed treeview. This representation indicates both the current position of the item the user is currently viewing in the hierarchy, as well as single attribute information on a cluster. We usually display density but other possibilities include the number of times this cluster was browsed or the number of nodes in this cluster matching a particular filter. The treeview also allows random access to any cluster in the hierarchy and the system automatically computes a smooth transition from the current cluster to the selected cluster. These three representations are linked, meaning that operations such as cluster selection, cluster expansion and cluster collapsing can be performed from any of these representations and the others will automatically adapt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.1</head><p>Interaction As mentioned previously, the user navigates the clustered graph by iteratively clicking open a cluster C that he or she wants to see in more detail. Or, more formally, at any time during navigation the system is displaying the graph induced by a display antichain, which we call AC S . In this case expanding a cluster C amounts to replacing AC S with AC S children(C) -{C} and collapsing a cluster replaces AC S with AC S -children(parent(C)) {parent(C)} (see also <ref type="bibr" target="#b2">[3]</ref>). To avoid a large number of new links suddenly popping up in the display we animate the expansion by interpolating node positions.</p><p>The coordinates of the subgraph induced by the children of C are computed by a force directed layout algorithm. These are then linearly transformed to fit within an area that is dependent on |leaves(C)|. In our case we used an optimized <ref type="bibr" target="#b7">[8]</ref> force directed layout algorithm for its ability to compute a decent layout of any subgraph with at most IL vertices in reasonable time regardless of the subgraph's structure. It is however very easy to add more algorithms and have the system select the most appropriate one, depending on the graph structure.</p><p>To save users from the tedious task of having to successively click open a large number of potentially uninteresting subgraphs we added the option to expand any cluster for which |leaves(C)| &lt; x to its corresponding leaves. The parameter x depends on the desired level of interactivity and the speed of the layout algorithms used, and in our case is set to 150 nodes. Another option lets the user recursively expand subgraphs of a selected node by dragging a slider down to a particular level in the graph. Missing coordinates for subgraphs are then computed on the fly. Since the number of subgraphs that need to be laid out increases exponentially with depth, this feature is only really useful if the user wishes to expand ahead a limited number of levels in the graph. Another feature is the ability to filter nodes and edges by a parameter. If attribute data is specified with the input data we can filter nodes and edges by setting upper and lower bounds for that attribute either by using a slider directly from the interface or by selecting a range in a window showing the distributions of this attribute. The system then automatically adjusts all of the displays to reflect only the data that falls within this range. Passing all these parameters with the input data instead of computing them internally, allows us great flexibility in assessing the usefulness of different types of computed metrics.</p><p>Because node-link visualizations often suffer from on screen edge congestion, we also implemented two solutions to alleviate this problem. The first one makes edges which have both nodes off screen more transparent. Since both of the end nodes from these edges cannot be seen these edges do not add to the display. The other option allows the user to elide all edges from view, except for the ones adjacent to a user specified set of nodes. Since the node layout reflects the clustering of the graph, one can usually deduce the approximate structure from the node density alone (see <ref type="figure">Fig. 6</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.2</head><p>Context definition Any usable interactive system dealing with a potentially large number of items on screen will have to provide a mechanism to guarantee interactive performance. Even when using fast hardware accelerated graphics cards, applications often become slow and unwieldy when animating and/or navigating tens of thousands of nodes on screen. Other systems that have been designed for the visualization of large graphs and trees <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b24">25]</ref> include cut-off mechanisms and intelligent pixel level algorithms to keep rendering overhead to acceptable levels. In section 4 we have parameterized the number of nodes that can be rendered at an interactive rate as S. This means that at any time during navigation our display antichain AC S can have at most S nodes.</p><p>If we assume a reasonably balanced hierarchy on a graph of size |V| the average depth of the hierarchy is limited to d log(|V|) and in practice we can safely say that d &lt; 20, especially given the fact that we are aiming for a maximum fan out of IL.</p><p>Define the set context(u) of a node u in the hierarchy recursively as children <ref type="bibr">(u)</ref> context(parent(u)) -{u}. Note that context(u) defines the minimum maximal antichain that includes the children of u. Each time the expansion of a node x should lead to a number of on-screen nodes that is bigger than S, we replace S with context(x). Since the size of context(x) is at most d * IL and provided S &gt; d * IL (see section 4.1) we can never have more than S nodes on screen at once. A more intelligent alternative, which also keeps the direct neighbours of a cluster visible, amounts to greedily collapsing nodes in AC S based on edge weight: Define the union of two antichains A and B as the largest subset of A B which is still an antichain. The set neighbours(x) in AC S is defined as {y AC S : e xy S-view of G}.</p><p>We start out with a set of proposed neighbours P = neighbours(x). While the union of context(x) and the contexts of all nodes in P is bigger than S we replace the node y in P having minimum w(e xy ) with parent(y) and compute a new context. Termination of this loop is guaranteed, since at one point all nodes in the proposed neighbour set will be above context(x) and the size of context(x) &lt; S. This computation can be performed in RAM in time O(S log(S)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.3</head><p>Labeling Another important aspect regarding the usability of the visualization is its ability to automatically assign labels to higher level clusters. Without these labels users are forced to manually inspect the labels of the set of leaf nodes of a cluster every single time to get a rough idea of the data that is contained in that cluster. A straightforward solution could include a weighted tf-idf based algorithm, coupled with stemming and a frequency cut-off to avoid misspellings and obscure terms. Here, we incorporated a proprietary algorithm that for a cluster x automatically extracts the log(|leaves(x)|) most important labels from this potentially large keyword set, based on both node importance and graph structure. These are then displayed in order of computed importance (see <ref type="figure" target="#fig_2">Fig. 4</ref>).</p><p>Note that the general problem of defining a sensible labeling for a cluster is not always easy to solve. For the wordnet <ref type="bibr" target="#b12">[13]</ref> graph for example, we would like to label a cluster that contains only plantnames (see <ref type="figure" target="#fig_3">Fig. 5a</ref>) with the label "plants", but integrating this semantic knowledge into a system is an open problem.</p><p>Since displaying a label for every single visible node quickly fills the screen with overlapping (and hence unreadable) labels, we also implemented a level-of-detail algorithm based on the amount of zoom. We recurse through the entire hierarchy tree starting at the root and stop the recursion as soon as the screen size of a cluster falls below a certain pixel threshold. Since the screen size of a cluster depends on the amount of zoom the user has applied this has the effect of incrementally showing more labels as the user zooms in.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS AND FURTHER WORK</head><p>We described ASK-GraphView, a fully implemented system for interactive navigation of large graphs. Its main contribution is an extension of previous work on resource parameterization <ref type="bibr" target="#b2">[3]</ref> by also including processing time in the model where previously only memory and screen space were considered. This allows us to visualize external memory graphs with millions of edges at interactive rates. Other contributions include a structural clustering algorithm that improves on <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr" target="#b5">[6]</ref> by guaranteeing a bound on the number of subclusters and the ability to break dense clusters if needed, as well as a notion of navigation context that keeps the number of nodes visible on screen below a predetermined constant. 7.1 Scalability Using our system we have been able to interactively navigate graphs with a few million edges with relative ease. More importantly, we do not pose any restrictions on the input graph in terms of structure and density. We even managed to get visualizations of a few graphs with over 2 billion edges by reusing the architecture. When we hit the point where the client ran out of RAM we created a number of separate files for deeper subgraphs below, and have the system automatically load the subsection the user wished to drill into. In terms of scale ASK-GraphView is a substantial improvement over existing systems, which either do not scale to this amount or rely on special structural properties of the graph in question to do so.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.2</head><p>Flexibility ASK-GraphView was not designed to answer a particular visualization question. Although its main current use is the analysis of relations between search terms, we have also applied it to internet topologies, lexical databases and other types of graphs. Rather than being a highly customized application, it serves as a framework visualization that can answer multiple types of graph-related questions, depending on the attribute parameters that are supplied with the nodes. For example, coloring by an attribute 'density' might be useful if the user is looking for dense subgraphs within the structure. Coloring by an attribute 'number of visits' might entice users to explore areas that are often visited. Although we are currently creating a hierarchy based on the density of subgraphs below (i.e. the system tries not to break dense clusters), we can easily plug in different clustering procedures that allow us to cluster by node attributes or any other graph clustering algorithm for that matter. The system still performs at interactive levels as long as we update our IL and IH parameters appropriately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.3</head><p>Usability Although we have not evaluated our system formally yet, it has been in continuous use by a small number of data analysts over the past six months. During this period interesting requests came up, which we hadn't considered in the initial design and which we think do not surface often in graph visualization applications:</p><p>Firstly, the users complained about not being able to annotate certain areas of the graph that they found interesting (for example because of a dense cluster they found or because there were unexpected connections). They would use the system to explore the dataset on one day, only to come back the next day to find that they could not remember where they had spotted interesting features. In response to this we included the possibility of assigning persistent markers with custom labels to a node (see <ref type="figure">Fig. 6</ref>).</p><p>A related request concerned the exploration of a large unknown dataset. Users would be able to navigate around just fine, but had no idea where they should start to look for interesting features. As a result they sometimes stumbled upon something interesting, but spent most of their time randomly browsing the data. We decided to re-use the marker feature and mark the m most interesting nodes, where the amount of interest was based on a pre-computed node attribute. Another feature that helped alleviate this problem was the ability to type a random keyword into an edit box and have the system mark all leaf nodes that had that keyword in their label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.4</head><p>Future work Future work in the area of large graph navigation should focus on is the automatic computation of a meaningful label for a given cluster. We have used a keyword based method, but meaningful keywords might not always be available.</p><p>In terms of architecture, we cannot handle large graphs that come to us in the form of streams, since the architecture that we have presented here requires us to pre-process the entire dataset before being able to visualize it. <ref type="figure">Fig. 6</ref>. Low level view of a graph defined on health related terms with 86,000 nodes and 2,000,000 edges. The system has marked the term tranquilizers. Other clusters found near this cluster are related to specific drugs and have their labels automatically abstracted for readability. Edges are hidden.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Compacting binary hierarchies (a) Binary hierarchy with a comb; (b) All nodes in the comb were contracted with their rootnode and intermediate nodes were deleted; (c) Since this might increase the fan-out of the rootnode we recursively bin these nodes under two new nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Effect of separating articulation points: (a) input graph with 4 biconnected components and 2 articulation points; (b) cloned version, articulation points are split over their respective BCC's. The resulting partitioning is then used as a clustering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Screenshot of the ASK-Graphview interface showing small graph (489 nodes) representing information items on Netherlands. The treelist is visible on the left, the treeview is at the top of the screen. The grey area in the treeview represents the currently selected node. A matrix representation of the entire graph is visible in top left. The single cluster labeled 'Tiny' represents all smaller connected components. A slider near the bottom of the screen allows quick filtering on a user specified attribute, while the slider at the right edge of the screen allows quick expansion of individual nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Screen shots from a visualization of the wordnet database<ref type="bibr" target="#b12">[13]</ref> totaling approximately 100K vertices: (a) Dense high-level cluster showing plants. Note that the user has not (yet) requested detail level data for these nodes, as there are no subtrees below the grey selected node in the treeview at the top;(b) Detailed cluster showing dogs and horses, both are connected through the term racer; (c) closeup of the highlighted area in (b) showing only horses. Notice how more labels have become visible.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors wish to thank Apostolos Gerasoulis and Tomasz Imielinski at Ask.com for their continued support throughout this project.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Hierarchical Graph Maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer and Graphics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mgv: a System for Visualizing Massive Multidigraphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Korn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="38" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Matrix Zoom: A Visual Interface to Semi-External Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Van Ham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization</title>
		<meeting>IEEE Symp. Information Visualization</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="183" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Interactive Navigation of Power Law Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Van Ham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DIMACS TR# 2005-43</title>
		<imprint>
			<date type="published" when="2005-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<ptr target="http://www.aisee.com/" />
	</analytic>
	<monogr>
		<title level="j">AiSee Graph Visualization Software</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Topolayout</forename></persName>
		</author>
		<title level="m">Graph Layout by Topological features, Poster Track of the IEEE Symposium on Information Visualization (InfoVis&apos;05)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="3" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
		<title level="m">Tulip : A Huge Graph Visualisation Framework, Graph Drawing Software, Mathematics and Visualization</title>
		<editor>P. Mutzel and M. JÃ¼nger</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="105" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A hierarchical O(N log N) force calculation algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">324</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="44" to="449" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Pajek -Analysis and Visualization of Large Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Batagelj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mrvar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing Software</title>
		<editor>M. JÃ¼nger, P. Mutzel</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="77" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Van Dongen</surname></persName>
		</author>
		<title level="m">Graph Clustering by Flow Simulation</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
		<respStmt>
			<orgName>Universiteit Utrecht</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multilevel Visualization of Clustered Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">W</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Intl. Symp. On Graph Drawing</title>
		<meeting>the 4th Intl. Symp. On Graph Drawing</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">1190</biblScope>
			<biblScope unit="page" from="101" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Navigating Clustered Graphs using Force-Directed Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="157" to="181" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fellbaum</surname></persName>
		</author>
		<title level="m">Wordnet: An Electronical Lexical Database</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Demonstration of the interactive Graph Visualization System daVinci</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Frohlich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of the DIMACS Workshop on Graph Drawing</title>
		<meeting>of the DIMACS Workshop on Graph Drawing</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">894</biblScope>
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Topological Fisheye Views for Visualizing Large Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="468" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the readability of graphs using node-link and matrix-based representations: a controlled experiment and statistical analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ghoniem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Castagliola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Visualization</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="114" to="135" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive Visualization of Small World Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Van Ham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization</title>
		<meeting>IEEE Symp. Information Visualization</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="199" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Drawing Huge Graphs by Algebraic Multigrid Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiscale Modeling and Simulation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="645" to="673" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">H3: Laying Out Large Directed Graphs in 3D Hyperbolic Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization</title>
		<meeting>IEEE Symp. Information Visualization</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Navigating hierarchically clustered networks through fisheye and full-zoom methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schaffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="162" to="188" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Seidman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Network Structure and Minimum Degree, Social Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="269" to="287" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">PRISAD : A Partitioned Rendering Infrastructure for Scalable Accordion Drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Slack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hildebrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization</title>
		<meeting>IEEE Symp. Information Visualization</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Depth first search and linear graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="160" />
			<date type="published" when="1972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Saywer Software</surname></persName>
		</author>
		<ptr target="http://www/tomsawyer.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Nicheworks -Interactive Visualization of Large Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Wills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational and Graphical Statistics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="190" to="213" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
