<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Smashing Peacocks Further: Drawing Quasi-Trees from Biconnected Components</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Archambault</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Tamara</forename><surname>Munzner</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Auber</surname></persName>
						</author>
						<title level="a" type="main">Smashing Peacocks Further: Drawing Quasi-Trees from Biconnected Components</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Quasi-trees, namely graphs with tree-like structure, appear in many application domains, including bioinformatics and computer networks. Our new SPF approach exploits the structure of these graphs with a two-level approach to drawing, where the graph is decomposed into a tree of biconnected components. The low-level biconnected components are drawn with a force-directed approach that uses a spanning tree skeleton as a starting point for the layout. The higher-level structure of the graph is a true tree with meta-nodes of variable size that contain each biconnected component. That tree is drawn with a new area-aware variant of a tree drawing algorithm that handles high-degree nodes gracefully, at the cost of allowing edge-node overlaps. SPF performs an order of magnitude faster than the best previous approaches, while producing drawings of commensurate or improved quality.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Several approaches to graph drawing have used a spanning tree to accelerate or improve the visual quality of general graph layout, in applications such as: bioinformatics <ref type="bibr" target="#b0">[1]</ref>; computer networking <ref type="bibr" target="#b7">[8]</ref>; web site design and software engineering <ref type="bibr" target="#b16">[17]</ref>; and co-citation analysis <ref type="bibr" target="#b5">[6]</ref>. These methods succeed when the graph is a quasi-tree; that is, a graph with tree-like structure. Intuitively, for these types of data, using a spanning tree skeleton for layout is useful, even when the graph is much more densely connected than a strict hierarchy. Many definitions for quasi-tree have been proposed, for example a graph with a limit on the number or graph-theoretic length of non-tree edges. Here, we define quasi-trees as graphs where the number of biconnected components is a constant multiple of the number of vertices. A biconnected component is a maximal subgraph where the removal of any node or edge from that subgraph does not disconnect it into two or more components. More formally, for a graph G(V, E) with a set of V nodes and E edges, we consider it a quasi-tree if it has O(|V |) biconnected components. The biconnected component tree of a graph is a tree of meta-nodes, representing biconnected components, which conveys important structural information.</p><p>In the telecommunications network domain, the biconnected components of a quasi-tree can highlight semantic information in the network such as subnetwork structure. A decomposition of the quasi-tree into biconnected components highlights strengths and weaknesses in network design <ref type="bibr" target="#b19">[20]</ref>. In Internet tomography, seeing the subnetwork structure in the context of the global structure of the Internet is important in several user scenarios, including: visualizing infrastructure attacks on a corporation, discovering prolonged outages due to natural disasters or war, and tracing anonymous packets from an attack on a network back to their source <ref type="bibr" target="#b7">[8]</ref>.</p><p>In bioinformatics, graphs with quasi-tree structure appear in gene function, protein-protein interaction, and biochemical pathway data <ref type="bibr" target="#b0">[1]</ref>. With the LGL system <ref type="bibr" target="#b0">[1]</ref>, the authors exploit quasi-tree structure to produce impressive drawings of protein homology maps. In these networks, nodes are proteins and there exists an edge between a pair of nodes if their aligned amino acid sequences have a high similarity score. When drawn in a certain way, homology maps cluster proteins of similar function together, allowing biologists to predict the function of unknown proteins. To make these predictions, we need to see localized protein families in the context of the homology map.</p><p>In these applications, both the low-level structure within each biconnected component, and the high-level of the how those components interconnect in a tree, are important in understanding the graph. Many of the important low-level features in protein homology maps involve the biconnected components in the graph. For example, fusion proteins that connect two functionally related families of proteins often appear as a node separating two biconnected components <ref type="bibr" target="#b0">[1]</ref>. For Internet tomography, we believe that biconnected components are also of interest because they distinguish between peering relationships and downstream clients.</p><p>Some previous approaches to drawing quasi-trees are fast and explicitly exploit quasi-tree structure, but show only a subset of the full graph, relying on extensive interactive exploration to eventually reveal the complete structure <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b5">6]</ref>. Other general approaches to graph drawing are fast and show the full graph, but produce drawings of limited visual quality <ref type="bibr" target="#b11">[12]</ref>. The recent LGL system exploits quasitree structure to produce high-quality drawings of the full graph in the bioinformatics domain <ref type="bibr" target="#b0">[1]</ref>. While faster than previous work in the networking domain <ref type="bibr" target="#b7">[8]</ref>, layout of large datasets still takes hours to compute.</p><p>The SPF system exploits the quasi-tree structure of the graph by using a two-level approach to drawing: one algorithm to draw the biconnected component of each meta-node, and a second to draw the higher-level structure of the tree of these meta-nodes. The primary contribution of this paper is to draw the full graph structure of quasitrees much faster than previous work, and to provide equivalent or better visual quality with drawings that accurately portray the structural information of interest in application domains. We also improve the visual quality results of the LGL algorithm while keeping the algorithm running time within the same order of magnitude as the original version of LGL. Finally, we introduce an area-aware version of the RINGS tree drawing algorithm <ref type="bibr" target="#b21">[22]</ref> to draw our biconnected component tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DEFINITIONS</head><p>A spanning tree is a subset of edges in a connected graph that is a tree incident to all nodes. A minimum spanning tree is a spanning tree of minimum cost on a graph of weighted edges. For unweighted graphs, the weights of all edges can be set to one.</p><p>A biconnected component decomposition divides a graph into biconnected components. After a biconnected component decomposition, by definition, the biconnected components are linked by edges and nodes whose removal would disconnect the graph into two or more components. We define bridge nodes and bridge edges as the nodes and edges which can be removed to disconnect the graph into two or more components. Bridge nodes are also called articulation or cut vertices elsewhere in the literature. Bridge edges correspond to edges incident to two bridge nodes. If we replace each biconnected component with a single meta-node, we create a new higher-level graph with meta-nodes linked by only the bridge nodes and edges. The topology of this graph is always a tree, and we refer to it as the biconnected component tree. We use this more evocative name here, rather than the synonymous term block-cut point tree found in other areas of the literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK</head><p>Related work for quasi-trees is divided into three categories: multilevel graph drawing algorithms, spanning tree visualization, and domain-specific graph visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Multi-Level Graph Drawing</head><p>Multi-level schemes for graph drawing have been studied extensively to improve the running time and visual quality of large graph layouts. In multi-level algorithms, a coarsening operator is recursively applied to an input graph, forming a hierarchy of coarse graphs which are similar in structure, but cheaper to lay out. The coarsest graph of the hierarchy is laid out first and the locations of its nodes are used as an estimate for the next finest level. Coarsening operators suggested in the literature include: estimates of maximal matching <ref type="bibr" target="#b22">[23]</ref>, graph filtration based on shortest path distance in GRIP <ref type="bibr" target="#b9">[10]</ref>, eigenvector computation on coarse approximations of the Laplacian matrix in ACE <ref type="bibr" target="#b14">[15]</ref>, and solar system models based on local graph connectivity in FM 3 <ref type="bibr" target="#b11">[12]</ref>. These algorithms produce layouts of high visual quality for several types of undirected graphs, but none of them take into account the topological features that are integral to quasi-trees.</p><p>TopoLayout <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref> was the first multi-level algorithm to take topological features into account. Previous algorithms have exploited topological features <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b19">20]</ref>, but never in a multi-level context. The coarsening operator of TopoLayout recursively detects topological features such as trees, biconnected components, and highly connected clusters in the graph and draws them with appropriate algorithms. In the quasi-tree problem, we are only interested in specific types of topology, mainly trees and biconnected components. SPF is built inside the TopoLayout framework, but is directed specifically to the quasi-tree problem. SPF is similar to the work of Six and Tollis <ref type="bibr" target="#b19">[20]</ref>, but it uses a more sophisticated approach to drawing biconnected components than their method, which uses circular layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Spanning Tree Visualization</head><p>Spanning tree methods have appeared previously in the graph drawing and information visualization literature, but they only draw a subset of the graph edges and depend heavily on user interaction for understanding graph structure. In contrast, SPF attempts to convey the full complexity of the underlying graph at all times.</p><p>The H3 system <ref type="bibr" target="#b16">[17]</ref> uses domain-specific knowledge to determine a spanning tree for the graph. Node positions depend only on the chosen spanning tree, and the drawing of non-tree edges is toggled based on user selection.</p><p>Boutin and Hascoët <ref type="bibr" target="#b5">[6]</ref> characterize tree-like graphs as having nontree links only below a threshold graph-theoretic distance. They support filtering a potentially dense general graph to create a tree-like graph by eliminating graph edges that do not fit their constraint. An interactively chosen focus node is used as the spanning tree root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Domain-Specific Graph Visualization</head><p>Two key domain-specific papers are the primary inspiration for this work. Cheswick et al. <ref type="bibr" target="#b7">[8]</ref> presented drawings of substantial portions of the Internet. They mapped the hardware structure of the Internet using traceroute packets from a source machine. Outgoing paths were tracked to determine the connectivity between servers. In order to visualize the collected data, the authors employ a force-directed approach. The first optimization eliminates sufficiently distant nodes from the repulsive force calculations. The second optimization is the use of a spanning tree as a skeleton for the force-directed layout. The nodes of the test servers are laid out in the centre of the drawing. Iterations of force-directed layout are applied until this graph reaches equilibrium. Nodes are added to the layout in breadth-first order using a spanning tree centred at the traceroute packet source. The edges that connect these nodes to previously placed nodes are added. The result has been described as a "smashed peacock on a windshield" by Dave Presotto <ref type="bibr" target="#b7">[8]</ref>. Our biconnected component decomposition divides this dataset into smaller components, inspiring the title of this paper. We could not directly compare our results with this system because the code is proprietary.</p><p>In bioinformatics, Adai et al. <ref type="bibr" target="#b0">[1]</ref> implemented the approach of Cheswick et al. <ref type="bibr" target="#b7">[8]</ref> to draw protein homology maps. In their system, LGL, the spanning tree used as a skeleton is computed on a graph with edges weighted by BLAST e-values. The root vertex of this graph is chosen arbitrarily, is user specified, or is chosen based on graph centrality. As in Cheswick et al., by embedding the graph in a grid, repulsive forces between sufficiently distant nodes are culled. Two nodes share a repulsive force if they are present in the same or adjacent cells.</p><p>LGL was tested on several protein homology maps and the layouts grouped proteins into families of related function. In this work, we improve some aspects of the LGL drawing algorithm and integrate the improved algorithm into SPF. Drawings produced by SPF are an order of magnitude faster than those produced by LGL. They retain much of the high-level graph structure and better illustrate the low-level graph structure in the quasi-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ALGORITHM</head><p>The inputs to SPF are a graph and an unrooted, minimum spanning tree. For weighted graphs we use Kruskal's algorithm <ref type="bibr" target="#b20">[21]</ref> to compute the spanning tree, and for unweighted graphs we use breadth first search <ref type="bibr" target="#b4">[5]</ref>. For unweighted graphs, all spanning trees are of equal cost. Spanning trees computed from a breadth-first search are a logical choice to use as they tend to be representative of the underlying distance structure in the graph <ref type="bibr" target="#b20">[21]</ref>. We root the input spanning tree at its tree centre.</p><p>The drawing algorithm runs in three phases:</p><p>1. Decompose the graph into biconnected components.</p><p>2. Draw each component using an improved version of LGL.</p><p>3. Draw the biconnected component tree using an area-aware version of the RINGS <ref type="bibr" target="#b21">[22]</ref> algorithm.</p><p>Our first phase decomposes the input graph into biconnected components. In the second phase, the algorithm draws each biconnected component with our improved version of LGL. The sizes of the nodes in the biconnected component tree are set to the size of the biconnected component drawings. The third phase draws the biconnected component tree using an area-aware version of the RINGS <ref type="bibr" target="#b21">[22]</ref> algorithm that we have developed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Decomposition into Biconnected Components</head><p>In SPF, the graph is decomposed into biconnected components using a standard algorithm from the literature <ref type="bibr" target="#b4">[5]</ref>. It works by performing a depth-first search through the graph. Edges that point back to higher levels of the depth-first search are called back edges. When a subtree s of the depth-first search tree has no back edges to any ancestor of s, it is a separate biconnected component. The algorithm has a running time of O(|V | + |E|).</p><p>The biconnected component tree is constructed as shown in Figures 1(a) and 1(b). Bridge edges, such as the edge between components C 3 and C 4 , are edges in this tree. Bridge nodes appear as nodes in the tree. If a bridge node shares two or more edges with a component, the bridge node is duplicated and placed into those adjacent components as shown with C 1 and C 2 . This duplication keeps nodes directly adjacent to the bridge node together when during layout of the biconnected component, but the duplicated bridge nodes are not actually drawn. The decomposition phase does not take into account the prespecified spanning tree. Our choice of spanning tree could only be limited by the biconnected component decomposition if the chosen spanning tree did not contain all of the bridge nodes and bridge edges of the biconnected component tree; the remaining edges in the biconnected components can be present or absent from the spanning tree as needed.</p><formula xml:id="formula_0">C 1 C 2 C 3 C 4 (a) C 1 C 2 C 3 C 4 (b) C 1 C 2 C 3 C 4 (c)</formula><p>All bridge edges need to be present in the spanning tree. The bridge edge is the only edge connecting two biconnected components in the graph, and, if it were not present, the tree would be disconnected. Bridge nodes must be present by the definition of a spanning tree, and the edges between them and their duplicate nodes must be present as they are bridge edges. Therefore, a biconnected component decomposition does not limit our choice of spanning tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Biconnected Component Drawing with Optimized LGL</head><p>Once the graph is divided into biconnected components, we use our improved version of LGL, optimized LGL, to draw each biconnected component. The roots are computed from the spanning tree as shown in Figures 1(b) and 1(c). If the root of the input spanning tree is present in a biconnected component, it is chosen as the root of the biconnected component. Otherwise, the node from which the spanning tree entered this biconnected component on a depth-first search from the root of the spanning tree is used. The input spanning tree continues through the biconnected component as specified.</p><p>The first optimization to LGL improves running time in some cases and leaves visual quality unchanged. Recall that LGL uses a grid to cull repulsive forces of sufficiently distant nodes. To compute the repulsive forces, LGL marches through each cell of the grid. Computing repulsive forces in this manner can be costly in the early stages of the algorithm when many cells are empty. Instead, we keep a list of nodes already placed by the spanning tree, determine the position of the node in the grid, and compute the repulsive forces directly. We then mark the cell to ensure that the repulsive forces between nodes in a cell are computed only once. The drawing remains unchanged, because exactly the same set of repulsive forces are computed as when marching through the grid. The second optimization improves the visual quality of the final drawing of the graph, as shown in <ref type="figure">Figure 2</ref>. This optimization consists of two parts that influence initial placement of the nodes in the layout. In LGL, nodes are placed into the layout using the input spanning tree as a skeleton according to S:</p><formula xml:id="formula_1">S = c(M +P) + x parent (1)</formula><p>where c is a constant proportional to the number of nodes in the graph, M is the centre of mass, andP is the vector between the parent and the grandparent of the placed node in the input spanning tree. BothM and P are normalized. The value of x parent is the position of the parent in the spanning tree. The first part improves placement by reducing the constant c to the sum of the size of the parent node, the size of child node, and the average size of the nodes in the graph. Reducing c yields more compact drawings. In <ref type="figure">Figure 2</ref>(a) the nodes are spread far apart and can hardly be seen while in <ref type="figure">Figure 2</ref>(b) they are easily visible along with the topology. The second part places nodes on small directed fans in the direction of the vector S as shown in <ref type="figure" target="#fig_2">Figure 3</ref>(b) instead of circles as shown in <ref type="figure" target="#fig_2">Figure 3(a)</ref>. Placing the nodes on fans inhibits them from being directed back inwards, preserving low-level structure. We can see the problem near the root node of the tree in <ref type="figure">Figure 2(a)</ref>. In contrast, the problem is less prevalent in optimized LGL as demonstrated by <ref type="figure">Figure 2</ref>(b).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Biconnected Component Tree Drawing with Area-Aware RINGS</head><p>Once each biconnected component has been laid out, we know the screen-space extents required by each of these meta-nodes. In order to draw the biconnected component tree, we need a tree drawing algorithm that is area-aware; that is, that can correctly handle nodes of variable rather than uniform size. To begin this section, we first motivate the need for area-aware RINGS. Next, we describe the original RINGS algorithm as presented by Teoh and Ma <ref type="bibr" target="#b21">[22]</ref>. Then, we describe our area-aware adaptation of RINGS and discuss how to use it to draw our biconnected component trees.</p><p>For large quasi-trees, the degree of nodes inside the biconnected component tree can be very high. As we can see in <ref type="figure" target="#fig_3">Figure 4</ref>, the few previously existing tree layout algorithms that are area-aware perform poorly in this case. The area-aware version of the Walker <ref type="bibr" target="#b6">[7]</ref> layout, shown in <ref type="figure" target="#fig_3">Figure 4(a)</ref>, lays out the children of the high-degree node on a horizontal line, and the details of their structure are too small to be seen without zooming. Similarly, <ref type="figure" target="#fig_3">Figure 4</ref>(b) shows that Bubble Tree <ref type="bibr" target="#b10">[11]</ref> lays out the high-degree node in the centre of a circle so large that the children are too small to be seen individually on the circumference. In contrast, the RINGS algorithm <ref type="bibr" target="#b21">[22]</ref> provides a much more compact drawing at the price of introducing node-edge overlaps and edge crossings. By adapting it to be area-aware, we achieve the result shown in <ref type="figure" target="#fig_3">Figure 4(c)</ref>.</p><p>In RINGS <ref type="bibr" target="#b21">[22]</ref>, each child of a root is placed in a circle enclosing its entire subtree as shown in <ref type="figure" target="#fig_4">Figure 5(a)</ref>. The dark blue node at the centre of the drawing is the root while the dark grey circles are the children of the root and their subtrees. The root is placed at the centre of the drawing, and we sort its children by their number of children; that is, by their number of grandchildren with respect to the root. The subtrees are placed onto concentric rings inward towards the root in order from the child with the most to least children. Each of the subtrees on a ring is given an equal-sized enclosing circle of radius r. The radii R 1 and R 2 are as shown in <ref type="figure" target="#fig_4">Figure 5(a)</ref>. Let N GrandPlaced be the number of grandchildren placed in the current ring. Let N GrandTotal be the total number of grandchildren to place with respect to the root. A new ring is started on the inner, yellow circle when:</p><formula xml:id="formula_2">N GrandPlaced N GrandTotal &gt; R 2 2 R 1 2 = (1 − sin( π n )) 2 (1 + sin( π n )) 2<label>(2)</label></formula><p>Given n children and their subtrees, the right hand side of Equation (2) is the ratio of the circle areas with radii R 1 and R 2 respectively. This ratio does not depend on r and only requires that</p><formula xml:id="formula_3">R 1 = 2r + R 2 .</formula><p>The process is repeated for the remaining subtrees.</p><p>From the left hand side of Equation (2), we notice that the size of the nodes in the tree is not considered, only the number of children. Therefore, RINGS assumes a uniform node size. Moreover, the node size should be much smaller than r to ensure that the entire subtree is fully contained by the enclosing circle, since only grandchildren, and not the entire subtree, are considered in this ratio. In our work, this subtree could contain a large number of nodes of substantial size. Therefore, we cannot choose such an r.</p><p>In our area-aware variant of RINGS, instead of counting the number of grandchildren, we determine the area needed to lay out each subtree by drawing the tree bottom-up. At a leaf node, we use the bounding circle of the node. At an interior node, we use the bounding circle of the subtree of which it is the root. The subtrees are placed into concentric rings outward from the root in order from the subtree which requires the least area, to the subtree which requires the most area, as shown in <ref type="figure" target="#fig_4">Figure 5(b)</ref>. We keep track of the largest enclosing circle radius in r max . The radii R 1 and R 2 are as shown in <ref type="figure" target="#fig_4">Figure 5</ref>(b) with R 1 = 2r max + R 2 . A new ring is started on the outer, yellow circle when:</p><formula xml:id="formula_4">A R 2 A R 1 &lt; R 2 2 R 1 2 = (1 − sin( π n )) 2 (1 + sin( π n )) 2<label>(3)</label></formula><p>where A R 1 and A R 2 are the areas of the circles with radii R 1 and R 2 .</p><p>Since we have drawn the tree from the bottom up, we know the actual areas of these circles and can compute the ratio directly. Where Equation (2) compares ratios of grandchildren, Equation <ref type="formula" target="#formula_4">3</ref>compares ratios of the areas needed to draw the nodes and subtrees. We further optimize area-aware RINGS when the number of subtrees to be placed on a ring is two or fewer as shown in <ref type="figure">Figure 6</ref>. The root node of a subtree is usually placed at the centre of its bounding circle, which leads to wasted space as shown in <ref type="figure">Figure 6</ref>(a) and 6(c). In the case of a root node with a single child subtree, we place the root and its child subtree tangent to each other as shown in <ref type="figure">Figure 6(b)</ref>. In the two-child subtree case, we place the root and its two subtrees tangent to each other in a triangle as shown in <ref type="figure">Figure 6(d)</ref>. When the triangle connecting the three centres is acute, the smallest bounding circle is the outer circle tangent to all three enclosing circles. This circle is known as the outer Soddy circle <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14]</ref>. When the triangle is obtuse, the bounding circle is the circle enclosing two largest circles as shown in <ref type="figure">Figure 6</ref>(e).</p><p>We also improve how area-aware RINGS handles chains. A chain is defined as a linear sequence of nodes each having exactly one child. Without this improvement, each node of the chain is the case shown in <ref type="figure">Figure 6</ref>(b), resulting in the long lines of nodes as seen <ref type="figure">Figure 7(a)</ref>. In our optimization, we treat each node of the chain as though it was a direct child of the node which began the chain. The chain spirals around the node that began it, drawing it compactly, as shown in <ref type="figure">Figure 7</ref>(b). Unlike other cases in area-aware RINGS, the nodes of a chain are not sorted by size.</p><p>We use a subtle three-dimensional depth effect to create perceptual layering when drawing edges. Edges are placed below the nodes, with edges to the outer rings placed more deeply than edges to the inner ones. When browsing the layout in Tulip <ref type="bibr" target="#b3">[4]</ref>, edges can be raised if a path between two nodes needs to be visible. Edge colour for edges between biconnected components is lightened.</p><p>We also choose an ordering for the biconnected components in a ring to reduce edge occlusion, since all biconnected components in the same ring have an enclosing circle of at most r max . The chosen ordering of the biconnected components in a ring is based on the positions of the nodes inside the biconnected component at the root. The vector between every node inside the root that attaches the biconnected component on the ring and the centre of the drawing at the root is computed. The average vector is taken as the vector of ideal placement. Biconnected components in a ring are sorted based on the direction of their ideal placement vector. The biconnected component with the most edges to the root is placed in its ideal location on the ring. All other biconnected components are placed in their sorted order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EMPIRICAL TESTING AND RESULTS</head><p>We implemented SPF in the Tulip <ref type="bibr" target="#b3">[4]</ref> framework and now compare it to three other algorithms in terms of performance, qualitative visual results, and quantitative statistics. We do so using two large datasets. Protein, the graph shown in <ref type="figure" target="#fig_6">Figure 8</ref> with 30,727 nodes and 1,206,654 edges, is the unweighted version of the protein homology graph presented in the LGL paper <ref type="bibr" target="#b0">[1]</ref>. Net05, the graph shown in <ref type="figure" target="#fig_7">Figure 9</ref> with 190,384 nodes and 228,354 edges, is an Internet tomography dataset similar to those presented in Cheswick et al. <ref type="bibr" target="#b7">[8]</ref>, but generated in 2005 by Cheswick's Internet Mapping Project 1 . All benchmarks were run on a 3.0GHz Pentium IV with 3.0GB of memory running SuSE Linux with a 2.6.5-7.252 kernel. The accompanying video 2 shows interactive exploration of these graphs at multiple levels of zooming.</p><p>Space constraints preclude showing all competing algorithms, so we compare SPF to its most competitive. FM <ref type="bibr" target="#b2">3</ref>  <ref type="bibr" target="#b11">[12]</ref> is a state of the art multi-level graph drawing algorithm. Other algorithms, including ACE <ref type="bibr" target="#b14">[15]</ref>, GRIP <ref type="bibr" target="#b9">[10]</ref>, and HDE <ref type="bibr" target="#b15">[16]</ref>, were shown to be less competitive than FM 3 in previous work <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b2">3]</ref>.</p><p>LGL is an algorithm developed in the bioinformatics domain for visualizing quasi-trees and optimized LGL is our modified form of LGL. TopoLayout <ref type="bibr" target="#b2">[3]</ref> took too long to cluster Protein, because it used a clustering algorithm whose performance deteriorates as the number of edges becomes large. The TopoLayout drawing of Net05 was not compact, because it drew most of the biconnected component tree using Bubble Tree. Its drawing is similar to <ref type="figure" target="#fig_3">Figure 4(b)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance</head><p>The FM 3 algorithm was the fastest algorithm on both datasets. On Protein, it was an order of magnitude faster than all the drawing algorithms. FM 3 was the same order of magnitude as SPF on Net05, but three times faster. LGL and optimized LGL were the slowest algorithms on both datasets. They are two times slower than SPF on Protein. On Net05, LGL and optimized LGL are an order of magnitude slower than all algorithms. SPF is twice as fast as LGL and optimized LGL on Protein and an order of magnitude faster than LGL and optimized LGL on Net05.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Qualitative Drawing Comparison</head><p>FM 3 has difficulty depicting both the high-level and low-level structure in both datasets, as shown in <ref type="figure" target="#fig_6">Figures 8(a) and 9(a)</ref>. The high-level, tree-like structure is unclear in Protein. On Net05, the high-level tree structure is somewhat visible, but details of it are difficult to see, because it draws the branches along thin lines. It is nearly impossible to see low-level structure in either dataset.</p><p>With the slower LGL and optimized LGL, the drawings are improved. The high-level, tree-like structure is apparent in Protein throughout the dataset as shown in <ref type="figure" target="#fig_6">Figures 8(b)</ref> and 8(c). We can clearly see high-level branches without zooming in, as well as more of the tree structure in the insets. However, the drawing of Net05, shown in Figures 9(b) and 9(c), only displays the high-level tree structure well at the periphery. Most of the drawing is a featureless core where the tree-like structure is hidden. In terms of low-level structure, we are able to see protein families and fusion proteins between families in Protein. In Net05, the subnetwork structure is only clear when the nodes lie on the fringes of the drawing, as we see in the insets of Figures 9(b) and 9(c). SPF improves upon the running time of LGL and optimized LGL and retains or improves much of the high-level and low-level structure. Much of the high-level tree structure is retained with SPF. The spanning tree skeleton is made visually apparent with area-aware RINGS, but at a cost of spatial locality and edge crossings in the drawings.</p><p>The principal advantage of SPF over previous work is the improved visualization of low-level structure in the graph, because it is not as occluded by the higher-level components. In Protein, we see protein families and the fusion proteins between them as shown in the insets of <ref type="figure" target="#fig_6">Figure 8(d)</ref>. The core of Protein is thinned, revealing more internal structure than with previous algorithms. Protein families and fusion proteins are clearly seen in the rings of the drawing. The core of Net05 is far smaller than with LGL; however, it still contains about 37,000 nodes and suffers from a great deal of node and edge occlusion. Nevertheless, we can resolve many local network features in the context of the entire Internet. We clearly resolve subnetwork structure around servers at the University of British Columbia and the City of Baltimore as shown in the insets of <ref type="figure" target="#fig_7">Figure 9</ref>(d).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Statistical Analysis</head><p>In addition to the qualitative analysis of the drawings, we provide quantitative statistics for each of the four layouts. We compute nodenode overlaps and uniformity of edge lengths, both for the low-level structure of individual nodes and edges, and for the high-level structure of the biconnected components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Node-Node Overlaps</head><p>A node-node overlap is simply the intersection of two nodes in a drawing. For the biconnected components, a node-node overlap occurs when the two convex hulls of the biconnected components intersect. A smaller number of node-node overlaps in the biconnected components more clearly displays high-level structure and better represents the low-level structure as the biconnected components do not occlude each other.</p><p>We present the node-node overlap statistics in the top of <ref type="figure">Figure 10</ref>. We show the total number of overlaps, and the number of major overlaps where more than half the the area of the smallest node is covered. Major overlaps are more interesting than total overlaps as they effect the readability of the drawing more severely.</p><p>We see that FM <ref type="bibr" target="#b2">3</ref> has few node-node overlaps on either dataset. However, in this approach, the nodes are spread very far from each other with respect to the standard node size. LGL and optimized LGL incur more overlaps, but have the benefit of a more compact drawing. Optimized LGL incurs many more total node-node overlaps as we have reduced the magnitude of the repulsive force constant. However, only a small percentage of them are major. With SPF, although Protein has a large total number of overlaps, the number of major overlaps is less than that for optimized LGL. We see a significant reduction in the number of node-node overlaps on Net05. of area-aware RINGS to draw the very large number of biconnected components reduces the possibility of low-level node-node overlaps.</p><p>In the bottom of <ref type="figure">Figure 10</ref>, we present the overlap figures for the higher-level biconnected components. FM 3 , LGL, and optimized LGL have thousands of major overlaps. These major overlaps make it difficult to see the low-level structure of the biconnected components in their higher level context. In these drawings, many but not all, of the large overlaps of biconnected components are with the large, biconnected core which is spread through the drawing. It is important to note that optimized LGL is better able to separate the biconnected components than the original LGL. This result supports our optimization of placing nodes on directed fans and reducing the repulsive force constant, which keeps nodes in biconnected components closer together. In contrast to these three methods, SPF succeeds in making these biconnected components more evident. It incurs no overlaps at all for the smaller Protein dataset, and only one major overlap for the larger Net05.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Uniformity of Edge Lengths</head><p>Uniform edge lengths keep all elements of the graph drawing at a similar scale. For each drawing, we compute the standard deviation of the edge lengths for each drawing. The raw edge length values are normalized by the average edge length on each dataset. This normalization sets the mean edge length in each drawing to one, so that the standard deviations can be directly compared. Standard deviations are all positive and numbers closer to zero correspond to more uniform edge lengths. When we consider the graph as a whole, SPF has highly nonuniform edge lengths. However, considering the uniformity with a particular level of structure shows its benefits.</p><p>The results are presented in <ref type="figure">Figure 11</ref>. The overall standard deviation is presented the left hand column. FM <ref type="bibr" target="#b2">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, LGL, and optimized</head><p>LGL perform well on this metric where SPF does not. From visual inspection of the SPF drawings, we can see that this additional variance is probably due to the long edges introduced by the area-aware RINGS algorithm. However, uniform edge lengths across the entire drawing may not be appropriate for displaying the biconnected structure of quasi-trees. In the drawings produced by LGL and optimized LGL, we see this property as the drawings have a uniform but featureless core. Noack <ref type="bibr" target="#b18">[19]</ref> stated that long edges may be required to display cluster structures. We propose that a more suitable metric for quasitrees is to consider uniformity within a meaningful group; that is, the edges within a particular biconnected component, and the edges of the quasi-tree that connect between biconnected components. <ref type="figure">Figure 11</ref> shows these separate standard deviations in the centre and right columns. We see that optimized LGL is commensurate with LGL on nearly all numbers. SPF is commensurate with all algorithms in terms of the average standard deviation of edge lengths within biconnected components on both datasets. SPF has a slight improvement for the between edges in Protein, but a very high standard deviation for Net05. This situation follows directly from the size of their biconnected component trees: small for the former, and large for the latter. The many concentric rings used by area-aware RINGS for large biconnected component trees contribute to this increased variance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION AND FUTURE WORK</head><p>We have presented SPF, a new drawing algorithm for quasi-trees. The principal advantage of SPF over previous work is the improved visualization of low-level structure within the biconnected components of the graph. These components are not as occluded by the higher-level structure of the tree formed by the interconnections between them. FM 3 is fast, but its visual quality is poor. The slower LGL approach dramatically improves the visual quality of the protein homology network dataset that it was designed for, but fails to visually distinguish the high-level structure of the Internet Mapping dataset. SPF does succeed at showing more structure for both of these datasets, as we argue both qualitatively in our discussion of the drawings and quantitatively with the very low number of biconnected component overlaps. Moreover, SPF is much closer to the speed of FM 3 , ranging from twice as fast to an order of magnitude faster than LGL. Our optimizations to LGL were designed to improve SPF itself, since it is used as one of our layout algorithms. However, considering optimized LGL as a standalone layout approach is also interesting. Although it is similar to LGL from visual inspection of the drawings, and has variable performance depending on the dataset tested, the biconnected component overlap statistic suggests that it does help distinguish more structure.</p><p>We adapted the RINGS algorithm to handle nodes of variable size, and optimized its behavior when handling small subtrees. Such an area-aware tree layout is useful not only within SPF, but also within other multi-level frameworks.</p><p>Reducing occlusion continues to be the driving problem for largescale graph drawing, and many improvements remain for future work. The common approach of reducing edge-edge crossings would better show low-level structure, but we would also like to better show high-level structure by reducing the crossings between edges and the meta-nodes that constitute biconnected components, for example by improving the biconnected component tree drawing algorithm.</p><p>In this work we focus on the problem of exploiting quasi-tree structure to make better drawings of graphs that we assert are quasi-trees using our intuitive definition. A future challenge would be to build a quasi-tree detector that automatically determines whether a graph is a quasi-tree, allowing us to include quasi-trees as a topological feature type in the TopoLayout framework. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Daniel Archambault and Tamara Munzner are with the University of British Columbia, E-mail: {archam, tmm}@cs.ubc.ca. • David Auber is with the Université de Bordeaux, E-mail: auber@labri.fr Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Decomposition of the graph into biconnected components preserves the input spanning tree. Spanning tree edges are shown with directed red edges, and the roots are shown in white. (a) Identify the bridge nodes and edges, shown in blue, in the decomposition phase. (b) If a bridge node shares two or more edges with a component, the bridge node is duplicated and placed into those adjacent components. (c) Break spanning tree up into individual biconnected components, and find the root for each new component. (a) LGL (b) optimized LGL Comparison of the final layout of a ten-ary tree of depth three between (a) LGL and (b) optimized LGL. Repulsive forces are diminished in optimized LGL to roughly the size of a node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Comparison of the initial placement of nodes between (a) LGL and (b) optimized LGL, on a ten-ary graph of depth tree. Fan placement also places nodes closer to each other at the beginning.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Layouts of the Cheswick 2005 dataset biconnected component tree using: (a) area-aware Walker's algorithm<ref type="bibr" target="#b6">[7]</ref>, (b) bubble tree<ref type="bibr" target="#b10">[11]</ref>, and (c) our adaptation of area-aware RINGS. With area-aware RINGS, we gain a significantly more compact drawing at the price of introducing edge-node overlaps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Comparison of subtree placement between (a) the RINGS algorithm and (b) Area-Aware RINGS. The blue node is the root of the current subtree. The grey circles are subtrees that have filled the white ring. The yellow circle indicates where the next ring is started.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .Fig. 7 .</head><label>67</label><figDesc>Comparison of special cases for small subtree layout. (a) One subtree in RINGS. (b) One subtree in area-aware RINGS. (c) Two subtrees in RINGS. (d) Two subtrees in area-aware RINGS. When the triangle connecting the three centres of the root and subtrees is obtuse, the centre of the bounding circle is placed at the centre of the sum of the two largest diameters as shown in (e). Demonstration of the chain optimization, with nodes set to random sizes between one and ten unite. (a) Node drawn in linear chains. (b) More compact drawing of chain nodes in a spiral.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Drawing of Protein, a protein homology map obtained from the LGL project. Graph contains 30,727 nodes and 1,206,654 edges. Drawings produced by (a) FM 3 , (b) LGL, (c) optimized LGL, and (d) SPF, with drawing times indicated underneath.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 .</head><label>9</label><figDesc>Drawing of Net05, obtained from the Internet Mapping project. Graph contains 190,384 nodes and 228,354 edges. Drawings produced by (a) FM 3 , (b) LGL, (c) optimized LGL, and (d) SPF, with drawing times indicated underneath.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Fig. 10. Node-node overlaps. We first give the total number of nodenode overlaps, then only the number of major overlaps; that is, those where the overlap covers more than half of the node area.</figDesc><table><row><cell>Algorithm</cell><cell>Total</cell><cell>Major</cell><cell>Total</cell><cell>Major</cell></row><row><cell></cell><cell cols="2">Protein</cell><cell cols="2">Net05</cell></row><row><cell></cell><cell></cell><cell cols="2">Nodes</cell><cell></cell></row><row><cell>FM 3</cell><cell>95</cell><cell>95</cell><cell>381</cell><cell>381</cell></row><row><cell>LGL</cell><cell>920</cell><cell>809</cell><cell>6,761</cell><cell>5,746</cell></row><row><cell>LGL Opt.</cell><cell cols="2">54,255 13,021</cell><cell>60,218</cell><cell>1,204</cell></row><row><cell>SPF</cell><cell cols="2">71,574 12,167</cell><cell>4,185</cell><cell>42</cell></row><row><cell></cell><cell></cell><cell cols="2">Biconnected Components</cell><cell></cell></row><row><cell>FM 3</cell><cell>2,400</cell><cell cols="3">2,376 162,620 160,993</cell></row><row><cell>LGL</cell><cell>2,657</cell><cell cols="2">2,603 170,073</cell><cell>3,401</cell></row><row><cell>LGL Opt.</cell><cell>2,955</cell><cell>2,629</cell><cell>93,570</cell><cell>1,871</cell></row><row><cell>SPF</cell><cell>0</cell><cell>0</cell><cell>8</cell><cell>1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Protein has</cell></row><row><cell cols="5">30,727 nodes and 2,427 biconnected components. Net05 has 190,384</cell></row><row><cell cols="4">nodes and 167,460 biconnected components.</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Fig. 11. Standard deviation of normalized edge lengths, where lower numbers mean more uniformity. Overall is the standard deviation over all edges. Within is the average standard deviation of the edges within each biconnected component, and Between is the standard deviation of edges that connect the components in the biconnected component tree.</figDesc><table><row><cell cols="4">Algorithm Overall Within Between</cell></row><row><cell></cell><cell></cell><cell>Protein</cell><cell></cell></row><row><cell>FM 3</cell><cell>1.02</cell><cell>0.61</cell><cell>0.94</cell></row><row><cell>LGL</cell><cell>0.57</cell><cell>0.32</cell><cell>0.88</cell></row><row><cell>LGL Opt.</cell><cell>0.72</cell><cell>0.33</cell><cell>0.78</cell></row><row><cell>SPF</cell><cell>2.74</cell><cell>0.32</cell><cell>0.74</cell></row><row><cell></cell><cell></cell><cell>Net05</cell><cell></cell></row><row><cell>FM 3</cell><cell>0.62</cell><cell>0.17</cell><cell>0.48</cell></row><row><cell>LGL</cell><cell>1.21</cell><cell>0.19</cell><cell>0.93</cell></row><row><cell>LGL Opt.</cell><cell>1.26</cell><cell>0.18</cell><cell>0.98</cell></row><row><cell>SPF</cell><cell>1.96</cell><cell>0.24</cell><cell>5.03</cell></row><row><cell>The use</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">research.lumeta.com/ches/map 2 www.cs.ubc.ca/labs/imager/video/2006/spf</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank Ciarán Llachlan Leavitt for help in editing this paper. We would also like to thank Heidi Lam, Peter McLachlan, James Slack, and Melanie Tory for providing comments on previous drafts.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">LGL: Creating a map of protein function with an algorithm for visualizing very large biological networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">T</forename><surname>Adai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">V</forename><surname>Date</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wieland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Marcotte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Molecular Biology</title>
		<imprint>
			<biblScope unit="volume">340</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="179" to="190" />
			<date type="published" when="2004-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">TopoLayout: Graph layout by topological features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Information Visualization Posters Compendium (InfoVis&apos;05)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="3" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">TopoLayout: Graph layout by topological features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tulip : A huge graph visualization framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing Software, Mathematics and Visualization</title>
		<editor>P. Mutzel and M. Jünger</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="105" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Computer Algorithms: Introduction to Design and Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Baase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Gelder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Focus-based filtering + clustering technique for power-law networks with small world phenomenon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Boutin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thièvre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hascoët</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Conference on Visualization and Data Analysis (VDA &apos;06)</title>
		<meeting>of the Conference on Visualization and Data Analysis (VDA &apos;06)</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improving Walker&apos;s algorithm to run in linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Buchheim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Leipert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD&apos;02)</title>
		<meeting>Graph Drawing (GD&apos;02)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="344" to="353" />
		</imprint>
	</monogr>
	<note>volume 2528 of LNCS</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mapping and visualizing the Internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cheswick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Branigan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX</title>
		<meeting>USENIX</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Introduction to Geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S M</forename><surname>Coxeter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969" />
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">GRIP: Graph drawing with intelligent placement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gajer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Kobourov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="203" to="224" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bubble tree drawing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grivet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Domenger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Melancon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Vision and Graphics</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="633" to="641" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Drawing large graphs with a potential-fieldbased multilevel algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hachul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int. Symp. on Graph Drawing</title>
		<meeting>12th Int. Symp. on Graph Drawing</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">3383</biblScope>
			<biblScope unit="page" from="285" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An experimental comparison of fast algorithms for drawing general large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hachul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int. Symp. on Graph Drawing</title>
		<meeting>13th Int. Symp. on Graph Drawing</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Central points and central lines in the plane of a triangle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kimberling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics Magazine</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="163" to="187" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Drawing huge graphs by algebraic multigrid optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiscale Modeling and Simulation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="645" to="673" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Graph drawing by high-dimensional embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD&apos;02)</title>
		<meeting>Graph Drawing (GD&apos;02)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">2528</biblScope>
			<biblScope unit="page" from="207" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">H3: Laying out large directed graphs in 3D hyperbolic space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Information Visualization (Info-Vis&apos;97)</title>
		<meeting>IEEE Symposium on Information Visualization (Info-Vis&apos;97)</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="2" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A meta heuristic for graph drawing. learning the optimal graph-drawing method for clustered graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Niggemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AVI 2000: Proc. of the Working Conference on Advanced Visual Interfaces</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="286" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An energy model for visual graph clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Noack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int. Symp. on Graph Drawing</title>
		<meeting>11th Int. Symp. on Graph Drawing</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003" />
			<biblScope unit="volume">2912</biblScope>
			<biblScope unit="page" from="425" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A framework for circular drawings of networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Six</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD&apos;99)</title>
		<meeting>Graph Drawing (GD&apos;99)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
	<note>volume 1731 of LNCS</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The Algorithm Design Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Skiena</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">RINGS: A technique for visualizing large hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>Teoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD&apos;02)</title>
		<meeting>Graph Drawing (GD&apos;02)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">2528</biblScope>
			<biblScope unit="page" from="268" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A multilevel algorithm for force-directed graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Walshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="253" to="285" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
