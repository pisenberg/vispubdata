<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Nanocubes for Real-Time Exploration of Spatiotemporal Datasets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lauro</forename><surname>Lins</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>00,11 01, 11 10, 11 11, 11 00, 10 01, 10 10, 10 11, 10 00, 01 10, 00 01, 00 10, 00 11</addrLine>
									<postCode>01 01, 01 11, 01 00, 00</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>00,11 01, 11 10, 11 11, 11 00, 10 01, 10 10, 10 11, 10 00, 01 10, 00 01, 00 10, 00 11</addrLine>
									<postCode>01 01, 01 11, 01 00, 00</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Scheidegger</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>00,11 01, 11 10, 11 11, 11 00, 10 01, 10 10, 10 11, 10 00, 01 10, 00 01, 00 10, 00 11</addrLine>
									<postCode>01 01, 01 11, 01 00, 00</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Nanocubes for Real-Time Exploration of Spatiotemporal Datasets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Data cube</term>
					<term>Data structures</term>
					<term>Interactive exploration</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Example visualizations of 210 million public geolocated Twitter posts over the course of a year. The data structure we propose enables real-time (these images above were rendered faster than the typical screen refresh rate) visual exploration of large, spatiotemporal, multidimensional datasets. The visual encodings built using nanocubes are within a controllable difference to ones rendered by a traditional linear scan over the dataset. They naturally support linked navigation and brushing, and include choropleth maps, time series over arbitrary regions and scales of space and time, parallel sets, histograms, and binned scatterplots. The color scale of the choropleth map is a diverging scale in which blue corresponds to iPhones being relatively more popular, and red corresponds to higher relative popularity of Android devices.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>As datasets get larger, exploratory data visualization becomes more difficult. Consider a dataset with a billion entries. We can compute a small summary of the dataset and visualize the summary instead of the dataset, but as Anscombe's famous quartet shows <ref type="bibr" target="#b2">[3]</ref>, summaries themselves cannot ascertain their own validity. Summaries might help, but in order to understand if that is the case, we will inevitably find</p><p>• Lauro Lins is with AT&amp;T Research. E-mail: llins@research.att.com.</p><p>• Jim Klosowski is with AT&amp;T Research. E-mail: jklosow@research.att.com.</p><p>• Carlos Scheidegger is with AT&amp;T Research. E-mail: cscheid@research.att.com.</p><p>Manuscript received 31 March 2013; accepted 1 August 2013; posted online 13 October 2013; mailed on 4 October 2013. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</p><p>ourselves having to visualize one billion residuals. As far as scale goes, we are back to square one. In other words, data summarization alone will never solve the problem of scale in exploratory visualization. As visualization practitioners, what then can we do? Even drawing the simplest scatterplot is not straightforward. If we decide to produce the visualization by scanning the rows of a table, we will either need non-trivial parallel rendering algorithms or significant time to produce a drawing. Neither of these solutions is attractive or scales well with dataset size. Data cubes are structures that perform aggregations across every possible set of dimensions of a table in a database, to support quick exploration <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b34">31]</ref>. Many visualization systems are built on top of data cubes, concretely or conceptually. Still, only recently have researchers started to examine data cube creation algorithms in the context of information visualization <ref type="bibr" target="#b36">[33,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>Data cubes are often problematic in that they can take prohibitively large amounts of memory as the number of dimensions increases. In Section 4, we show how to construct a data cube that fits in the main memory of a modern laptop computer or workstation, extending the work of Sismanis et al. <ref type="bibr" target="#b34">[31]</ref>. In addition, the query times to build the visual encodings in which we are interested will be at most proportional to the size of the output, which is bounded by the number of screen pixels (within a small factor). This is an important observation: the time complexity of a visualization algorithm should ideally be bounded the number of pixels it touches on the screen. Our technique enables realtime exploratory visualization on datasets that are large, spatiotemporal, and multidimensional. Because the speed of our data cube structure hinges partly on it being small enough to fit in main memory, we call it a nanocube.</p><p>By real-time, we mean query times on average under a millisecond for a single thread running on computers ranging from laptops, to workstations, to server-class computing nodes (Section 6). By large, we mean that the datasets we support have millions to billions of entries.</p><p>By spatiotemporal, we mean that nanocubes support queries typical of spatial databases, such as counting events in a spatial region that can be either a rectangle covering most of the world, or a heatmap of activity in downtown San Francisco (Section 4.3.1). By the same token, nanocubes support temporal queries at multiple scales, such as event counts by hour, day, week, or month over a period of years (Section 4.3.3). Data cubes in general enable the Visual Information-Seeking Mantra <ref type="bibr" target="#b32">[29]</ref> of "Overview first, zoom and filter, then detailson-demand" by providing summaries and letting users drill down by expanding along the wanted dimensions. Nanocubes also provide overviews, filters, zooming, and details-on-demand inside the spatiotemporal dimensions themselves.</p><p>By multidimensional, we mean that besides latitude, longitude, and time, each entry can have additional attributes (see section 6) that can be used in query selections and rollups.</p><p>As we will show, nanocubes lend themselves very well to building visual encodings which are fundamental building blocks of interactive visualization systems, such as scatterplots, histograms, parallel coordinate plots, and choropleth maps. In summary, we contribute:</p><p>• a novel data structure that improves on the current state of the art data cube technology to enable real-time exploratory visualization of multidimensional, spatiotemporal datasets;</p><p>• algorithms to query the nanocube and build linked and brushable visual encodings commonly found in visualization systems; and</p><p>• case studies highlighting the strengths and weaknesses of our technique, together with experiments to measure its utilization of space, time, and network bandwidth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Relational databases are so widespread and fundamental to the practice of computing that they were a natural target for information visualization almost since the field's inception <ref type="bibr" target="#b19">[20]</ref>. Mackinlay's Automatic Presentation Tool is the breakthrough result that critically connected the relational structure of the data with the graphical primitives available for display <ref type="bibr" target="#b26">[23]</ref> and ultimately lead to data cube visualization tools like Polaris <ref type="bibr" target="#b37">[34,</ref><ref type="bibr" target="#b38">35]</ref> and Show Me <ref type="bibr" target="#b27">[24]</ref>. Nanocubes are specifically designed to speed up queries for spatiotemporal data cubes, and could eventually be used as a backend for these types of applications. In contrast, some of the work in large data visualization involves shipping the computation and data to a cluster of processing nodes. While parallelism is an attractive option for increasing throughput, it does not necessarily help achieve low latency, which is essential for fluid interactions with a visualization tool. As a result, sophisticated techniques such as query prediction become necessary <ref type="bibr" target="#b5">[6]</ref>. Leveraging the enormous power of graphics processing units has also become popular <ref type="bibr" target="#b28">[25,</ref><ref type="bibr" target="#b20">21]</ref>, but without algorithmic changes, linear scans through the dataset will still be too slow for fluid interaction, even with GPUs.</p><p>Another popular way to cope with large datasets is through sampling. Statistical sampling can be performed on the database backend <ref type="bibr" target="#b29">[26,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14]</ref>, or on the front-end <ref type="bibr" target="#b10">[11]</ref>. Still, the techniques we introduce with nanocubes can produce results quickly and exactly (to within screen precision) without requiring approximations, which we believe is preferable. In addition, as Liu et al. argue, sampling by itself is not sufficient to prevent overplotting, and might actually mask important data outliers <ref type="bibr" target="#b20">[21]</ref>.</p><p>Fekete and Plaisant have proposed modifications of traditional visual encodings which use the computer screen more efficiently <ref type="bibr" target="#b12">[13]</ref>. These scale better with dataset size, but nevertheless require a traversal of all input data points that renders the proposal less attractive for larger datasets. Carr et al. were among the first to propose techniques replacing a scatterplot with an equivalent density plot <ref type="bibr" target="#b4">[5]</ref>; nanocubes enable these visualizations at a variety of dataset sizes and scales.</p><p>Careful data aggregation <ref type="bibr" target="#b16">[17]</ref>, then, appears to be one of the few scalable solutions for low-latency large data graphics. While Elmqvist and Fekete propose variations of visualization techniques that include aggregation as a first-class citizen <ref type="bibr" target="#b11">[12]</ref>, in this paper we show how to issue queries such that, at the screen resolution in which the application is operating, the result is indistinguishable (or close to) from a complete return nano cube 8: end function</p><formula xml:id="formula_0">1: function TRAILPROPERPATH(root, [v 1 , . . . , v k ]) 2: stack ← STACK( ) New Empty Stack 3:</formula><p>PUSH(stack, root)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>node ← root 5:</p><formula xml:id="formula_1">for i = 1 to k do 6: child ← CHILD(node, v i ) 7:</formula><p>if child = null then 8:</p><formula xml:id="formula_2">child ← NEWPROPERCHILD(node, v i , NODE( )) 9:</formula><p>else if ISSHAREDCHILD(node,child) then SETSHAREDCONTENT(node sc, CONTENT(node)) <ref type="bibr" target="#b3">4</ref>:</p><formula xml:id="formula_3">for v in CHILDRENLABELS(node) do 5: NEWSHAREDCHILD(node sc, v, CHILD(node, v)) 6: end for 7:</formula><p>return node sc 8: end function 1: procedure ADD(root, o, d, S, time , updated nodes) 2:</p><formula xml:id="formula_4">[ 1 , . . . , k ] ← CHAIN(S, d) 3: stack ← TRAILPROPERPATH(root, [ 1 (o), . . . , k (o)]) 4: child ← null 5:</formula><p>while stack is not empty do if update then 20:</p><p>if d= dim(S) then  scan through the dataset. We note that over-aggressive aggregation itself introduces potential discrepancies between the visualization and the dataset, and there are proposals to understand this <ref type="bibr" target="#b8">[9]</ref>.</p><p>We are interested in bounding the difference between our visual encoding and a visual encoding that would traverse the entirety of the data by the size of the screen, i.e. the number of pixels in it. Related to this, pixel-oriented techniques <ref type="bibr" target="#b18">[19]</ref> have been investigated. However, these tend to focus on the development of new visual encodings, while in this paper we show how to create the already well-known and established encodings with low error, high performance and interactivity.</p><p>Our technique is most closely related to the work of Sismanis et al. <ref type="bibr" target="#b33">[30,</ref><ref type="bibr" target="#b34">31,</ref><ref type="bibr" target="#b35">32]</ref>. Nanocubes improve upon their work in two fundamental directions. First, we develop a model for spatiotemporal data cubes that exploits unique characteristics of space and time to get a good compromise between space usage and efficiency of queries (Sections 4.2.1 and 6). Second, we show how these structures enable the visualizations which are common in interactive tools (Section 4.3).</p><p>There have been recent efforts to build data cube structures specifically suited for visualization. Crossfilter <ref type="bibr" target="#b36">[33]</ref> is based on the clever observation that many queries in interactive visualization are incremental: assuming that previous results are available, the results needed for the next query can be quickly computed. Unfortunately, we do not see how this would work for the multiscale queries necessary in a spatiotemporal setting. Just as recently, <ref type="bibr">Kandel et al.</ref> proposed Datavore, a column-oriented database that supports fast data cube queries <ref type="bibr" target="#b17">[18]</ref>, and Liu et al. leverage graphics hardware in imMens, achieving extremely fast queries over large data <ref type="bibr" target="#b20">[21]</ref>. We provide a detailed, direct comparison of nanocubes to Datavore and imMens in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DATA CUBES</head><p>Following common practice, we will call the table in <ref type="figure" target="#fig_8">Figure 4</ref> a relation, its columns attributes, its lines records, and its entries values. An aggregation represents the idea of selecting a certain group of records from a relation and summarizing this group using an aggregation function (e.g. count, sum, max, min). For example, a possible aggregation for the relation A could be to select all its records and summarize those using count, yielding five as the aggregation result. If we allow a special value All to be a valid attribute value, we could represent this aggregation as relation B in <ref type="figure" target="#fig_8">Figure 4</ref>. A record that contains the special value All is an aggregation record. Using this notation, it is easy to understand some conventional ways of describing aggregations for a given relation: GROUP BY, CUBE, and ROLL UP.</p><p>A GROUP BY operation is one in which a relation is derived from a base relation given a list of attributes and an aggregation function. For example, GROUP BY on attributes Device and Language with the count aggregation function results in the relation C in <ref type="figure" target="#fig_8">Figure 4</ref>. Note that for every different combination of values present in the attributes of a base relation, an aggregation record is added to the resulting relation. In our running example, these combinations are (Android, en), (iPhone, en), and (iPhone, ru).</p><p>The CUBE operation is the result of collecting all possible GROUP BY aggregations into a single relation for a given list of attributes (i.e. 2 n GROUP BYs for n input attributes). In our running example, the CUBE for count on Device and Language is the union of four GROUP BYs: on <ref type="bibr" target="#b0">(1)</ref>   guage, but does not include the GROUP BY on Language only. As the results of GROUP BYs, CUBEs and ROLL UPs can be seen as relations, we can naturally compose such operators (e.g. a ROLL UP CUBE).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NANOCUBE: A COMPACT, SPATIOTEMPORAL DATA CUBE</head><p>Data visualizations in a computer are necessarily bounded by display size, and so we would like to be able to quickly collect subsets of the dataset that would end up in the same pixel on the screen. However, spatiotemporal navigation is inherently multiscale. The same data structure should support quick indexing for a visualization over multiple years of time series and for drilling down into one particular hour or day. Similarly, the data cube should support aggregation queries over vast spatial regions covering entire continents, as well as very narrow queries covering only a few city blocks. The database notion of ROLL UP, in a sense, aligns nicely with the notion of Level of Detail. For example, if the records of a table (relation) contain a location attribute, one can design a ROLL UP query whose resulting relation encodes the same information as the one encoded in a level of detail data structure. More concretely, suppose 1 , . . . , k are attributes computed from the original location attribute and yield "quadtree addresses" of increasingly higher levels of detail (from 1 to k). A ROLL UP query on these (computed) attributes results in, essentially, the same information as the one contained in a quadtree (given that we are keeping the same summary in both, e.g. count).</p><p>The second important notion in the design of nanocubes is the idea that we want to combine aggregations of independent dimensions at independent levels of detail. For example we might want to know for a whole country, what is the spatial distribution of tweets generated by an iPhone: coarse on the spatial dimension, but specific on the device dimension. Conversely, we might want to know the distribution of tweets (coarse on device) in a small city block (fine in space). In relational database terminology, this model has a name: it is a CUBE of ROLL UP, or a ROLL UP CUBE. With the terminology set, we can state: a nanocube is a data structure to efficiently store and query spatiotemporal ROLL UP CUBE. Besides implementation tricks, the main difference between nanocubes and previously published sparse coalesced data cubes such as Dwarf cubes <ref type="bibr" target="#b33">[30]</ref> is in the design of aggregations across spatiotemporal dimensions (see Sections 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">and 4.3.3).</head><p>Next, we present a formal description of the components that make up our nanocube index, pseudo-code for building nanocubes, an illustrated example, and how queries are made against our index. Using this notation, it is easy to understand some conventional ways of describing aggregations for a given relation: group by, cube, and rollup. A group by operation is one in which a relation is derived from a base relation given a list of attributes and an aggregate function. For example, group by on attributes Device and Language with the count aggregate function results in the relation C in <ref type="figure" target="#fig_5">Figure 5</ref>. Note that for every different combination of values present in the attributes of a base relation an aggregation record is added to the resulting relation. In our running example ( <ref type="figure" target="#fig_5">Figure 5</ref>) these combinations are (Android, en), (iPhone, en), and (iPhone, ru n aggregation represents the idea of selecting a certain group of rds from a relation and summarizing this group using an aggregafunction (e.g.count, sum, max, min). For example, a possible regation for the relation above could be to select all its records and marize those using count. In this case, five would be the final regation result. If we allow entries in the record to have a special e All, we could represent this aggreation as the following relation:</p><formula xml:id="formula_5">Country Device Language Count All All All 5</formula><p>refer to records in a relation that contain the special value All as agation records. Using this notation, it is easy to understand the contional ways of describing aggregations for a given relation: group cube, and rollup. A group by operation is one in which a relation is ved from a base relation given a list of attributes and an aggregate tion. For example, group by on attributes Device and Language the count aggregate function results in the relation: n aggregation represents the idea of selecting a certain group of rds from a relation and summarizing this group using an aggregafunction (e.g.count, sum, max, min). For example, a possible regation for the relation above could be to select all its records and marize those using count. In this case, five would be the final regation result. If we allow entries in the record to have a special e All, we could represent this aggreation as the following relation: refer to records in a relation that contain the special value All as agation records. Using this notation, it is easy to understand the contional ways of describing aggregations for a given relation: group cube, and rollup. A group by operation is one in which a relation is ved from a base relation given a list of attributes and an aggregate tion. For example, group by on attributes Device and Language the count aggregate function results in the relation: . A simplified set of queries supported by the nanocube data structure. The column s represents space; t, time; c, category. R means "rollup", D means "drilldown". The value next to R or D contains the subset of that dimension's domain being selected. We use U to represent the entire domain ("universe"). Omitted here, but supported by our structure, are: the extra parameter for number of steps throughout the time region in a time-based drilldown; multiple categories with separate rollups and drilldowns; tiles of variable resolution.</p><p>sulting relation. In our running example these combinations are (Android, en), (iPhone, en), and (iPhone, ru). The cube operation is the result of collecting all possible group by aggregations into a single relation for a given list of attributes. In our running example, the cube for count on Device and Language would be the same as the union of four group by's: on <ref type="bibr" target="#b0">(1)</ref>  Finally, a roll up is a constrained version of the cube operation where the order of the input attributes is important. So a roll up on Device and Language (in this order) means the union of group by's on: (1) no attributes; (2) Device; and (3) Device and Language. Note that the group by on Language only is not part of the roll up. As the results of group by's, cubes and roll ups can be seen as relations, we can naturally compose such operations. As we will describe nanocubes is a specialized data structure to store and query cubes of roll ups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NANOCUBES:</head><p>A COMPACT, SPATIOTEMPORAL ROLL-UP CUBE Data visualizations in a computer are necessarily bounded by display independent levels of detail. For example we might want to know for a whole country, what is the spatial distribution of tweets gererated by an iPhone: coarse on the spatial dimension, but specific on the device dimension; conversely we might want to know the distribution of tweets (coarse on device) in a small block of a city (fine in space). In relational database terminology, this model has a name: it is a cube of roll-ups, or a roll-up cube. Now with the language set up, we can state: A nanocube is a data structure to efficiently store and query spatio-temporal roll-up cubes. Besides implmentation tricks (e.g. tagged pointers, carefully design of the bit layout of the structures, specifically designed to live in main memory), there is, to the best of our knowledge, a qualitative difference in nanocubes to other data structures like <ref type="bibr" target="#b32">[29]</ref>. The difference is in what nanocubes store for each aggregation which is deeply related to spatio-temporal datasets: it stores time series in a sparse summed table format. This element of nanocubes is explained in Section 4.3 and, cannot be cannot be efficiently simulated (memory-wise) by previous datastructures.</p><p>In the remainder of this section, we present a formal description of the components that make up our nanocube index, pseudo-code for building nanocubes together with an illustrated example, and how queries are made against our index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definitions</head><p>Let O be a set of objects. A labeling function`: O ! L associates a label value to the objects of O. We can think of`as an attribute in a relational database. In connection with the level of detail discussion above, if`1 and`2 are two labeling functions for O, we say`1 is coarser than`2 or that`2 is finer than`1 if for any two objects o, o 0 2 O the implication`2(o) =`2(o 0 ) )`1(o) =`1(o 0 ) holds. We denote this fact by`1 &lt;`2.  while stack is not empty do Using this notation, it is easy to understand some conventional ways of describing aggregations for a given relation: group by, cube, and rollup. A group by operation is one in which a relation is derived from a base relation given a list of attributes and an aggregate function. For example, group by on attributes Device and Language with the count aggregate function results in the relation C in <ref type="figure" target="#fig_5">Figure 5</ref>. Note that for every different combination of values present in the attributes of a base relation an aggregation record is added to the resulting relation. In our running example ( <ref type="figure" target="#fig_5">Figure 5</ref>) these combinations are (Android, en), (iPhone, en), and (iPhone, ru aggregation represents the idea of selecting a certain group of s from a relation and summarizing this group using an aggreganction (e.g.count, sum, max, min). For example, a possible ation for the relation above could be to select all its records and arize those using count. In this case, five would be the final ation result. If we allow entries in the record to have a special ll, we could represent this aggreation as the following relation:</p><formula xml:id="formula_6">Country Device Language Count All All All 5</formula><p>er to records in a relation that contain the special value All as agion records. Using this notation, it is easy to understand the connal ways of describing aggregations for a given relation: group e, and rollup. A group by operation is one in which a relation is d from a base relation given a list of attributes and an aggregate n. n aggregation represents the idea of selecting a certain group of rds from a relation and summarizing this group using an aggregafunction (e.g.count, sum, max, min). For example, a possible regation for the relation above could be to select all its records and marize those using count. In this case, five would be the final regation result. If we allow entries in the record to have a special e All, we could represent this aggreation as the following relation: refer to records in a relation that contain the special value All as agation records. Using this notation, it is easy to understand the contional ways of describing aggregations for a given relation: group cube, and rollup. A group by operation is one in which a relation is ved from a base relation given a list of attributes and an aggregate ction. n aggregation represents the idea of selecting a certain group of rds from a relation and summarizing this group using an aggregafunction (e.g.count, sum, max, min). For example, a possible regation for the relation above could be to select all its records and marize those using count. In this case, five would be the final regation result. If we allow entries in the record to have a special e All, we could represent this aggreation as the following relation: refer to records in a relation that contain the special value All as agation records. Using this notation, it is easy to understand the contional ways of describing aggregations for a given relation: group cube, and rollup. A group by operation is one in which a relation is ved from a base relation given a list of attributes and an aggregate tion. For example, group by on attributes Device and Language the count aggregate function results in the relation: sulting relation. In our running example these combinations are (Android, en), (iPhone, en), and (iPhone, ru). The cube operation is the result of collecting all possible group by aggregations into a single relation for a given list of attributes. In our running example, the cube for count on Device and Language would be the same as the union of four group by's: on <ref type="bibr" target="#b0">(1)</ref>  Finally, a roll up is a constrained version of the cube operation where the order of the input attributes is important. So a roll up on Device and Language (in this order) means the union of group by's on: (1) no attributes; (2) Device; and (3) Device and Language. Note that the group by on Language only is not part of the roll up. As the results of group by's, cubes and roll ups can be seen as relations, we can naturally compose such operations. As we will describe nanocubes is a specialized data structure to store and query cubes of roll ups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NANOCUBES:</head><p>A COMPACT, SPATIOTEMPORAL ROLL-UP CUBE Data visualizations in a computer are necessarily bounded by display size, and so we would like to be able to quickly collect subspaces of the dataset that would end up in the same pixel on the screen. However, spatiotemporal navigation is inherently multiscale. The same independent levels of detail. For example we might want to know for a whole country, what is the spatial distribution of tweets gererated by an iPhone: coarse on the spatial dimension, but specific on the device dimension; conversely we might want to know the distribution of tweets (coarse on device) in a small block of a city (fine in space). In relational database terminology, this model has a name: it is a cube of roll-ups, or a roll-up cube. Now with the language set up, we can state: A nanocube is a data structure to efficiently store and query spatio-temporal roll-up cubes. Besides implmentation tricks (e.g. tagged pointers, carefully design of the bit layout of the structures, specifically designed to live in main memory), there is, to the best of our knowledge, a qualitative difference in nanocubes to other data structures like <ref type="bibr" target="#b32">[29]</ref>. The difference is in what nanocubes store for each aggregation which is deeply related to spatio-temporal datasets: it stores time series in a sparse summed table format. This element of nanocubes is explained in Section 4.3 and, cannot be cannot be efficiently simulated (memory-wise) by previous datastructures.</p><p>In the remainder of this section, we present a formal description of the components that make up our nanocube index, pseudo-code for building nanocubes together with an illustrated example, and how queries are made against our index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definitions</head><p>Let O be a set of objects. A labeling function`: O ! L associates a label value to the objects of O. We can think of`as an attribute in a relational database. In connection with the level of detail discussion above, if`1 and`2 are two labeling functions for O, we say`1 is coarser than`2 or that`2 is finer than`1 if for any two objects o, o 0 2 O the implication`2(o) =`2(o 0 ) )`1(o) =`1(o 0 ) holds. We denote this fact by`1 &lt;`2.</p><p>A sequence of labeling functions c = [`1,`, ...,`k] for objects O is a chain for O if every labeling function is coarser than the next labeling function in the sequence:`i &lt;`i +1 . Note how chains are  while stack is not empty do Using this notation, it is easy to understand some conventional ways of describing aggregations for a given relation: group by, cube, and rollup. A group by operation is one in which a relation is derived from a base relation given a list of attributes and an aggregate function. For example, group by on attributes Device and Language with the count aggregate function results in the relation C in <ref type="figure" target="#fig_5">Figure 5</ref>. Note that for every different combination of values present in the attributes of a base relation an aggregation record is added to the resulting relation. In our running example ( <ref type="figure" target="#fig_5">Figure 5</ref>) these combinations are (Android, en), (iPhone, en), and (iPhone, ru aggregation represents the idea of selecting a certain group of ds from a relation and summarizing this group using an aggregaunction (e.g.count, sum, max, min). For example, a possible gation for the relation above could be to select all its records and arize those using count. In this case, five would be the final gation result. If we allow entries in the record to have a special All, we could represent this aggreation as the following relation: fer to records in a relation that contain the special value All as agtion records. Using this notation, it is easy to understand the cononal ways of describing aggregations for a given relation: group be, and rollup. A group by operation is one in which a relation is ed from a base relation given a list of attributes and an aggregate ion. An aggregation represents the idea of selecting a certain group of ords from a relation and summarizing this group using an aggregan function (e.g.count, sum, max, min). For example, a possible gregation for the relation above could be to select all its records and mmarize those using count. In this case, five would be the final gregation result. If we allow entries in the record to have a special lue All, we could represent this aggreation as the following relation: An aggregation represents the idea of selecting a certain group of ords from a relation and summarizing this group using an aggregan function (e.g.count, sum, max, min). For example, a possible gregation for the relation above could be to select all its records and mmarize those using count. In this case, five would be the final gregation result. If we allow entries in the record to have a special lue All, we could represent this aggreation as the following relation:</p><formula xml:id="formula_7">Country Device Language Count All All All 5</formula><p>refer to records in a relation that contain the special value All as aggation records. Using this notation, it is easy to understand the conntional ways of describing aggregations for a given relation: group , cube, and rollup. A group by operation is one in which a relation is rived from a base relation given a list of attributes and an aggregate ction. For example, group by on attributes Device and Language th the count aggregate function results in the relation: sulting relation. In our running example these combinations are (Android, en), (iPhone, en), and (iPhone, ru). The cube operation is the result of collecting all possible group by aggregations into a single relation for a given list of attributes. In our running example, the cube for count on Device and Language would be the same as the union of four group by's: on <ref type="bibr" target="#b0">(1)</ref>  As the results of group by's, cubes and roll ups can be seen as relations, we can naturally compose such operations. As we will describe nanocubes is a specialized data structure to store and query cubes of roll ups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NANOCUBES: A COMPACT, SPATIOTEMPORAL ROLL-UP CUBE</head><p>Data visualizations in a computer are necessarily bounded by display size, and so we would like to be able to quickly collect subspaces of the dataset that would end up in the same pixel on the screen. However, spatiotemporal navigation is inherently multiscale. The same data structure should support quick indexing for a visualization over multiple years of time series and for drilling down into one particu-independent levels of detail. For example we might want to know for a whole country, what is the spatial distribution of tweets gererated by an iPhone: coarse on the spatial dimension, but specific on the device dimension; conversely we might want to know the distribution of tweets (coarse on device) in a small block of a city (fine in space). In relational database terminology, this model has a name: it is a cube of roll-ups, or a roll-up cube. Now with the language set up, we can state: A nanocube is a data structure to efficiently store and query spatio-temporal roll-up cubes. Besides implmentation tricks (e.g. tagged pointers, carefully design of the bit layout of the structures, specifically designed to live in main memory), there is, to the best of our knowledge, a qualitative difference in nanocubes to other data structures like <ref type="bibr" target="#b32">[29]</ref>. The difference is in what nanocubes store for each aggregation which is deeply related to spatio-temporal datasets: it stores time series in a sparse summed table format. This element of nanocubes is explained in Section 4.3 and, cannot be cannot be efficiently simulated (memory-wise) by previous datastructures.</p><p>In the remainder of this section, we present a formal description of the components that make up our nanocube index, pseudo-code for building nanocubes together with an illustrated example, and how queries are made against our index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definitions</head><p>Let O be a set of objects. A labeling function`: O ! L associates a label value to the objects of O. We can think of`as an attribute in a relational database. In connection with the level of detail discussion above, if`1 and`2 are two labeling functions for O, we say`1 is coarser than`2 or that`2 is finer than`1 if for any two objects o, o 0 2 O the implication`2(o) =`2(o 0 ) )`1(o) =`1(o 0 ) holds. We denote this fact by`1 &lt;`2.</p><p>A sequence of labeling functions c = [`1,`, ...,`k] for objects O is a chain for O if every labeling function is coarser than the next labeling function in the sequence:`i &lt;`i +1 . Note how chains are related to roll ups, we avoid the same name to not overload more the term roll up. The number of levels of a chain is defined by levels(c) =  A key in a nanocube is any pair (a,t) where a ∈ addr(S) and corresponds to a full assignment (see definition above) and t ∈ T is a possible time label. If we remove the requirement of a being a full assignment, we say that pair (a,t) is an aggregate key. Note that every key is also an aggregate key. The set of all possible keys and the set of all possible aggregate keys of a nanocube are respectively referred to as its key space, or K , and its aggregate key space, or K a . The size of the key space, |K |, is referred to as its cardinality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Building the Index</head><p>To ease the remaining exposition, we assume that a nanocube maps an aggregate key to a count. Nevertheless, nanocubes support any kind of summary that is an algebra with weighted sums and subtractions. Notably, this includes linear combinations of moment statistics, with which we can compute means, variances and covariances.</p><p>The pseudo-code for building a nanocube is presented in <ref type="figure" target="#fig_3">Figure 3</ref>. The main idea of the algorithm is for every object o i to first find the finest address of the schema S hit by this object, update the time series associated with this address and from there on update in a deepest first fashion, all coarser addresses also hit by o i . Note that the content of the last dimension of schema S is always a time series and that is why, in line 21 of ADD, we insert the time label of the current object. The important trick used is to, when possible, allow for shared links  <ref type="table">Table Sparse Representation for Counts   query/tseries/1/3/4</ref> start at bin 1, use buckets of 3 bins each, and collect 4 of these buckets solve using... across dimensions (dashed blue lines in <ref type="figure" target="#fig_0">Figure 2</ref>) and in the same dimension (dashed black connections). In real use cases this sharing is responsible for significant memory savings and enables exploring even larger datasets on small laptops.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Nanocube Example</head><p>Consider the scenario where an analyst is interested in understanding the spatiotemporal distribution of Twitter data (i.e. tweets), including which devices (e.g. iPhone, Android) people are using. Natural questions to ask include: Which device is more popular for tweeting? Is one device more popular in certain areas than in others? How has this popularity changed over time? We illustrate the construction of a nanocube built using Twitter data in The labeling device assigns a device to each tweet and spatial1 and spatial2 assign a spatial label to each tweet. The tweet labels given by spatial1 and spatial2 are essentially addresses in a quadtree partition of a square. Note that spatial1 is coarser than spatial2 . The right part of <ref type="figure" target="#fig_0">Figure 2</ref> presents intermediate nanocubes generated by NANOCUBE ( <ref type="figure" target="#fig_3">Figure 3</ref>) after each tweet is inserted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Querying the Cube</head><p>Nanocubes support three distinct dimension types, which are always traversed in a fixed order: spatial, categorical, and finally temporal. Before describing queries for each of these specific dimension types, we first illustrate how simple queries are conducted on nanocubes using an example. Recall that the end result of the query will be to return precomputed aggregates across one or more dimensions.</p><p>In <ref type="figure" target="#fig_0">Figure 2</ref>(5), assume we are interested in the count of all tweets that occurred in the northwest quadrant of the world, regardless of the device type and time. The aggregate key k a = ((p 1 , p 2 ),t) for this query consists of: (1) the partial assignment for the northwest quadrant in the spatial dimension: p 1 = [0, 1]; (2) the empty partial path for the device dimension p 2 = [ ] indicating any device; and (3) a time label t indicating any time. Finding the precomputed aggregate for a given aggregate key is called a simple query. In this example, we start at the top-most node and traverse all black parent-child links described in the partial assignment p 1 : in this case only the black [0,1] link. We next cross the dimension boundary line by traversing the (blue) content link of the current node. The traversal process is repeated for the device dimension using the partial assignment p 2 . In this specific case, no restrictions are made on the device, and we can jump to the next dimension by traversing the content link. At this point, we reach a <ref type="figure">Fig. 7</ref>. Which device is more popular for tweeting: iPhone (blue) or Android (orange)? This choropleth map highlights areas in which devices are more popular based on a sample of 210M tweets. When we zoom in to Chicago we can observe something not seen from the overview display: south and west of the city, Android is more popular than iPhone.</p><p>leaf node containing {o 1 , o 2 }. Since no time constraint is imposed, the count of elements inside the leaf (2) is the answer for the query.</p><p>Note that, for each dimension, a simple query only traverses a single path of its tree before jumping to the root node of a tree in the next dimension (or to a leaf node which encodes time and is treated differently). In general, higher level queries might traverse multiple paths of a single tree, and may also report single aggregates, multiple aggregates, or even combine aggregates from multiple branches. To abstract and classify how a general nanocube query processes a dimension, we use the terminology of rollups and drilldowns (the ROLL UP relational operation is related but has a different meaning than the one we intend here). The dimension that is the basis of a rollup should report a single aggregate value as a result. This aggregate might be a single existing aggregate in the nanocube or a combination of multiple aggregates from different branches of that dimension. A drilldown reports aggregate values for multiple branches in that dimension. In a single nanocube query, each dimension is independently set to be used as the basis for either a rollup or a drilldown. In <ref type="figure" target="#fig_5">Figure 5</ref>, we provide a set of example queries and their mapping to the server query URL (see Section 5).</p><p>It is worth noting that the order of the d dimensions does not impact the worst-case query run-time. For example, a marginal barchart of a categorical dimension (with k bars), requires O(kd) time, regardless of the category chosen or the ordering of the dimensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Spatial Queries</head><p>In our current implementation, the first dimension to be traversed in a nanocube is always the spatial dimension. It is helpful to think of this dimension as being represented by a traditional quadtree <ref type="bibr" target="#b31">[28]</ref>, where each quadtree node is enriched by an extra pointer (content pointer) that jumps to the next dimension of the nanocube. If a query matches exactly the region represented by a quadtree node, then the content pointer of that node is the gateway for all aggregates that refers precisely to that region. If the query includes categorical restrictions (or drilldowns), then these can be found by traversing down the following categorical dimensions, as described below. However, spatial regions will very rarely match exactly one node in the quadtree; therefore, we use the traditional region quadtree intersecting algorithms to compute the minimal disjoint set of quadtree nodes that exactly cover the query region <ref type="bibr" target="#b31">[28]</ref>, and sum the resulting rollups across the nodes.</p><p>Arbitrarily shaped regions are not currently supported for spatial queries because of the additional complexity that is introduced, but there is no intrinsic barrier in the framework which prevents them from working. For spatial rollups, we support arbitrary rectangular regions. For drilldowns, we currently support regions defined by the tiling scheme of most mapping services on the WWW. For example, the widest tile in the world in OpenStreetMap <ref type="bibr" target="#b15">[16]</ref> has coordinates (0, 0, 0), while a tile for block-level maps of downtown Los Angeles might have coordinates (22485, 52342, 17). The first two coordinates are integer addresses, and the third coordinate corresponds to the zoom level: going down a zoom level doubles the resolution in both x and y. Our spatial drilldowns are then specified by a tile (x, y, z) address and an additional integer resolution, which denotes how many levels to break down space inside the tile. Traditionally, tiles from mapping services are squares with 256 pixels on the side, which corresponds in our case to a resolution of 8. Since our spatial drilldowns return an array of counts broken down by latitude and longitude, they are the basis for spatial density plots and choropleth maps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Categorical Queries</head><p>Categorical dimensions in a nanocube are represented by flat trees, which always contain a root node with potentially as many children as there are different values in that category. To restrict the domain to a certain value of the category, the query engine simply follows the path down the child of the corresponding value. Categorical rollups are performed by simply returning the count corresponding to either the top-level node (in case of no restriction) or the child node (in case of a restriction). Categorical drilldowns are also similarly simple: they are a sparse array of all children with non-zero counts.</p><p>We note that since categorical dimensions appear under spatial dimensions, answering spatial region rollups with either categorical restrictions or drilldowns requires combining the categorical rollups across all quadtree nodes that are reached by the region. An analogous phenomenon happens for nested drilldowns across multiple categories. For example, the binned scatterplot in <ref type="figure" target="#fig_1">Figure 11</ref> can be built directly from the result of drilling down in both day of week and hour of day. The recombinable parallel set visualization of <ref type="figure" target="#fig_1">Figure 1</ref> requires a triple breakdown of language, device and application. Single category drilldowns also trivially enable histogram plots.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Temporal Queries</head><p>To represent the temporal dimension, we use a sparse variant of summed-area tables <ref type="bibr" target="#b7">[8]</ref>  <ref type="figure">(Figure 6</ref>). Each time series in a node is stored as a dense, sorted array of cumulative counts, tagged by timestamp. With this data structure, we can compute a temporal rollup of event counts along any contiguous period, using only two binary searches: one to find the array element with the least upper bound of the period's beginning, and another to find the greatest lower bound of the period's end. The difference between these numbers is the total number of events in the period. A temporal drilldown happens similarly, and we can compute a time series with t entries by performing t + 1 binary searches. Each determines the breaking points in the cumulative array, and the final value is computed by stepwise differences.</p><p>This scheme for storing time entries is attractive for several reasons. First, it ensures that we can store time series of any granularity without requiring a nested tree structure like our spatial indexing scheme. Second, the running time is essentially optimal (up to a log n factor), and the algorithm is extremely fast in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION</head><p>We use a client-server architecture for the current implementation of nanocubes. The server reads the multidimensional data, builds a nanocube, and then processes queries on the nanocube from client applications. The server is a C++11 template-based implementation which makes it easy to plug in different data structures for each dimension of the nanocube. For example, for the Twitter data, we use a 2d quadtree for the spatial dimensions (latitude and longitude), and flat trees for each categorical dimension (e.g. language, device, application), and our summed-area table variant for the time dimension.</p><p>The nanocube construction algorithm has not been optimized for speed (results are included in section 6) but there are several possible improvements that we could make: using multiple threads, or using memory pools to avoid the overhead of repeated memory allocations and deallocations. Due to the scale of the input data, most of our effort has been spent on optimizing memory usage, including optimized libraries for memory allocation (libtcmalloc) and tagged pointers, which allow us to use the 16 most significant bits in a 64-bit pointer to quickly identify different types of nodes in our data structure.</p><p>The nanocube server exposes its API for queries via HTTP. More specifically, it provides a web service through which queries can be issued <ref type="bibr" target="#b30">[27]</ref>. After the data cube is built, the data structures are no longer mutated, and so the server is easily parallelizable (it also means that nanocubes are add-only: they cannot be updated if a record is removed from the base relation). Our implementation uses the Mongoose library for handling multiple HTTP requests in separate threads concurrently <ref type="bibr">[22]</ref>. We have built two front-end visualization clients to query the nanocube server. One client is written in C++ and uses OpenGL for efficient rendering. The other client is browser-based and is written in Javascript, HTML5, SVG, WebGL, and D3 <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>To study the behavior of nanocubes, we collected six datasets that ranged in size from four million records up to over one billion records. Each dataset includes geospatial, temporal, and domain-specific categorical dimensions with up to 30 distinct values. For all but the <ref type="figure" target="#fig_1">Fig. 10</ref>. Highlights of a visual analysis session of the CDR dataset, with 1, 043, 884, 027 records. We noticed the different patterns in call volume by interacting with the dataset and trying different regions and category selections. Notice the patterns occur at different spatial and temporal scales.</p><p>synthetic dataset experiments, we included the geospatial time-series dimensions, and varied the other dimensions based on the datasets.</p><p>In the following sections, we provide a brief overview of each of the datasets, followed by an overall summary of our experimental results in section 6.8. For each of the experiments, we paid particular attention to how much memory was required to build and store the nanocube index, as well as the overall complexity of the dataset itself, which varied greatly from one to the next. Once the nanocubes were constructed, we queried them using one or both of our front-end clients to highlight the ease with which analysts could explore the data.</p><p>The query times and bandwidth usage across all experiments are consistent, so we report them in aggregate here. The mean query time was 800µs (less than 1 millisecond) with a maximum of 12 milliseconds. The output size per query averaged 5KB, with a maximum size of 50KB (geographical tiles dominated bandwidth usage). Our server currently uses no compression, although we plan to support transparent gzip stream encoding. The mean number of queries for the C++ client was 100 requests per second. The HTML5 client is much quieter, at around 1 query per second, since linked views are only updated when a brush is released. The C++ client was designed for LANs, and its bandwidth usage is around 5Mbps, well within current capacities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Twitter</head><p>Between November 2011 and June 2012, we collected about 210 million tweets that originated in the United States using Twitter's public feed which provides a representative sampling of all tweets. The rate of tweets obtained averaged about one million per day. The data was streamed in the form of JSON objects, from which we extracted the following attributes: latitude and longitude of the device, the time the tweet occurred, the client application used, the type of device, and the language of the tweet. The categorical dimensions in our data (application, device, language) had respectively 4, 5, and 15 distinct values. With a nanocube built using this data, we could quickly explore the data to better understand the areas in which one device is more popular than another, where each of the languages is most prevalent, and how that information changes over time (see <ref type="figure">Figure 7</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Airline Commercial Flights History</head><p>This publicly available dataset contains data for every commercial flight in the United States over a <ref type="bibr">20 year period (1987-2008)</ref>  <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b39">36]</ref>. For over 120 million flights, the records include the scheduled departure and arrival times, the actual departure and arrival times, the origin and destination airports, the airline, and other fields. For this experiment, we built our index using the origin airport (for latitude and longitude), scheduled departure time, the departure delay, and the airline. This allows us to answer queries related to overall departure delays for any airports, airlines, time of day, or combinations thereof. In <ref type="figure">Figure 8</ref> we present an overview on the weekly percentages of total commercial flights in the U.S. for a 20 year period of Delta and American Airlines. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Call Detail Records</head><p>For each cellular phone call, telecommunications companies collect information about the call including time, duration, and the sequence of cell towers that carried the call. This information is organized into what are known as Call Detail Records (CDRs). A large U.S. service provider (privately) shared with us over one billion CDRs generated from a one month period in July 2010. Due to the sensitivity of CDR data, our data has been completely anonymized. No personally identifiable information was gathered or used in conducting this study. To the extent that any data was used, it was anonymous and aggregated data. The nanocube was built using the geospatial temporal data (of first cell tower), as well as the duration (transformed to a catagorical dimension) of each call (see <ref type="figure" target="#fig_1">Figure 10</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Location-Based Social Networks</head><p>The next dataset is also publicly available, and consists of locationbased checkins in the Brightkite social network collected by Cho et al. <ref type="bibr" target="#b6">[7]</ref>. The dataset comprises all data checkins from the (now-defunct) website between April 2008 and October 2010. In addition to latitude, longitude, and the time of each checkin, we redundantly encoded hour of day and day of week as extra categorical dimensions, since we expected there to be interesting periodic day-to-day and weekday vs. weekend patterns (see <ref type="figure" target="#fig_0">Figures 11 and 12</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Customer tickets</head><p>This dataset contains a record of about 8 million records of customer interactions of a large U.S. service provider over a period of 2.5 years. The dataset contains latitude, longitude, time and report type (one of eight categories). The same measures taken to anonymize CDR data in Section 6.3 were used here. In <ref type="figure" target="#fig_24">Figure 9</ref>, we highlight the use of nanocubes to detect relative changes in category in the time series plot, and how choropleth maps restricted to different time regions show the change in geographical distribution of the report types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">SPLOM</head><p>This is a collection of synthetic datasets (each with five dimensions) designed by Kandel et al. <ref type="bibr" target="#b17">[18]</ref> to exercise data cube technology (SPLOM stands for ScatterPLOt Matrix, the visual encoding used to explore the dataset in that work), also used by Liu et al. <ref type="bibr" target="#b20">[21]</ref>. To compare resource usage to that of these other proposals, we built nanocubes using five different bin sizes per dimension, from 10 to 50.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7">Memory Usage</head><p>To understand the memory requirements to build a nanocube, it is important to remember that objects are not inserted directly into the <ref type="figure" target="#fig_0">Fig. 12</ref>. By supporting multiscale time series queries, we can explore the Brightkite checkin frequency to investigate global trends as well as short-lived events. The iOS client for Brightkite was released exactly when the upward spike happened. The downward spike was caused by a global outage that lasted a few days.</p><p>nanocube, but rather through their corresponding keys (see <ref type="figure" target="#fig_3">Figure 3</ref>). An object's key identifies the most specific bin in the nanocube that contains that object. Thus, depending upon the resolutions defined for the dimensions of a nanocube, two different objects may or may not be distinguishable. For example, if the time resolution of a nanocube is one hour, two objects with timestamps at 20h10m and 20h50m will both have have keys with the same time label rounded to 20h. As a result, new occurrences of keys that were already inserted into a nanocube do not require additional storage space. <ref type="figure" target="#fig_1">Figure 14(A)</ref> shows the memory usage growth for the SPLOM dataset as we insert from zero to one billion objects into the five nanocubes of increasing bin size. In all cases there is an initial rapid growth that quickly flattens out. In the case of SPLOM 50, the index grew from 0 to 300MB with the first 200 million object insertions, but grew less than 100MB larger as a result of the next 800 million object insertions. The explanation for this behavior is that, by a characteristic of the synthetic object generator (samples from a normal distribution for each dimension) a key set of high probability was quickly generated making it harder and harder for a new object with an unseen key to be generated. Thus, later in the process, most inserted objects will not require more memory since their keys were already inserted into the nanocube. We refer to this phenomena as key saturation.</p><p>In <ref type="figure" target="#fig_1">Figure 14</ref>(B), we present curves for memory usage and number of keys for the CDR dataset, both relative to the final nanocube numbers. To test for a key saturation effect, we excluded the time dimension present in the original data. Once again, we observe an initial rapid growth on memory usage explained by the large number of combinations of cell locations and call durations not yet inserted. Once the bulk of the keys corresponding to these combinations are inserted, a relatively small but steady rate of new keys are inserted reflecting a small but steady growth in the cell tower infrastructure. Similarly defined curves for the Flights dataset are shown in <ref type="figure" target="#fig_1">Figure 14</ref>(C). The first part of this experiment follows the same trend as before: rapid initial growth, followed by a saturation of keys and a steady but much slower growth reflecting the small rate of new airport locations and carriers. At about 80M inserted flights (circa 1995), we again observe a regime of rapid growth, which corresponds to a burst of new carriers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.8">Performance Summary</head><p>In <ref type="figure" target="#fig_1">Figure 13</ref>, we summarize the relevant information for building our nanocubes on the previously described datasets. The number of input objects N, the memory requirements, and the build times are reported in the first three columns, while the exact schema used for each dataset  <ref type="bibr" target="#b28">(25)</ref>, lon <ref type="bibr" target="#b28">(25)</ref>, time <ref type="bibr" target="#b15">(16)</ref>, duration(3) <ref type="figure" target="#fig_1">Fig. 13</ref>. Summary of resource usage for our reported experimental results (K=10 3 , M=10 6 , B=10 <ref type="bibr" target="#b8">9</ref> ). The numbers in parentheses on the schema column denote the number of bits necessary to refer to a value of that dimension, and their sum is the exponent of 2 in the |K | column.</p><p>is included in the last column. Column "size" indicates the number of nodes in our data structure (in the nanocube of <ref type="figure" target="#fig_0">Figure 2</ref>(5) this number would be 41: 22 circles + 19 entries in the leaves). The "sharing" column indicates how much larger the nanocube would be without the sharing mechanism (dashed lines in <ref type="figure" target="#fig_0">Figure 2</ref>). For example, the twitter dataset nanocube would use at least 4 × 46.4GB = 185.6GB without sharing. Column "keys" is the number of distinct keys induced by the N objects (note here that the time dimension is included). Finally, column |K | reports the cardinality of the key space of each nanocube. All but two of the datasets fit in 4GB of RAM, and only one of them would not fit in 16GB, the amount of memory in a high-end laptop.</p><p>The multiscale nature of spatiotemporal datasets make the cardinality of the key space impractically large for any dense storage scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>As a sparse scheme to store aggregates, nanocubes suffer from the same drawbacks of any sparse data structure. Namely, when the occupancy (i.e. key space covered by the inserted objects) is large, the extra logic and memory needed to handle pointers is wasteful. A dense mechanism using implicit addressing on arrays has simpler logic, faster access, and uses less memory. When considering multidimensional datasets, however, the memory requirements of a dense mechanism quickly become impractical (see cardinality of <ref type="figure" target="#fig_1">Figure 13</ref>). Except for the SPLOM experiments, every other dataset would require at least 2 53 memory locations to represent the finest bin summaries (e.g. counts), without even considering the memory needed to represent aggregates. This requirement is simply overwhelming. A sparse scheme like a nanocube's can handle those datasets with present day technology. Nanocubes will not avoid the combinatorial explosion that happens when an arbitrary Nanocube memory usage growth with number of elements, using the SPLOM benchmark by Kandel et al <ref type="bibr" target="#b17">[18]</ref>. Notice the plateauing in memory usage due to key saturation. On the right, the growth of memory usage and number of keys when inserting objects into nanocubes for the Call Detail Records (B) and Flights (C) datasets.</p><p>number of dimensions is considered, but they still push the boundary of interactive visualizations as far as scale is concerned. It is enlightening to compare nanocubes to recent data cube visualization proposals: Datavore <ref type="bibr" target="#b17">[18]</ref> and imMens <ref type="bibr" target="#b20">[21]</ref> (see <ref type="figure" target="#fig_1">Figure 15</ref>). For this discussion, we assume input objects inducing keys K and aggregate keys K a . Datavore's algorithms behave well in the sparse regime, but cannot handle very large datasets, because its querying time appears to be proportional to |K|. imMens, on the other hand, has extremely fast query times (below 1ms per query, and apparently O(1)), but is designed for the dense regime, and uses memory proportional to the cardinality of its key space, O(|K |). This limits the size of the key space and we observe that although imMens reports experiments varying N from 10 6 to 10 9 , the value of |K | in all experiments were within a factor of 5 of one another <ref type="bibr" target="#b20">[21]</ref>. The hierarchical nature of a nanocube's spatiotemporal index provides advantages in the fidelity of resulting visualizations for a much larger set of scales than imMens (Datavore supports exact visual encodings across any dimensions, but cannot cope with large-scale datasets). This same hierarchical nature provides nanocubes with natural offscreen culling: the region visible onscreen can be interpreted as a spatiotemporal selection, reducing the total processing necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">LIMITATIONS AND FUTURE WORK</head><p>Nanocubes offer efficient storage and querying of large, multidimensional, spatiotemporal datasets, but are not without limits. Nanocubes do not allow queries down to any individual record, like a traditional database. Our index was designed specifically to answer queries from interactive visualization systems that explore massive datasets Our current server API encourages much chattier communication than is necessary, peaking at hundreds of HTTP requests a second. This happens when brushes are being moved in the C++ client, but could be avoided by techniques like query queueing and prediction <ref type="bibr" target="#b5">[6]</ref>.</p><p>The current nanocube implementation allows for only one spatial dimension and one temporal dimension. It would be clearly useful to allow schemata that included multiple spatial dimensions so that one could visualize, for example, the distribution of geographical locations of flights leaving a certain different geographical area. Similarly, phone calls have two natural geographical dimensions.</p><p>Nanocubes still take more memory than we would like. One of our examples clearly demonstrates this: when indexing all six dimensions, the 210 million points from Twitter take around 45GB of memory. This is enough memory for a present-day server, but above that of typical laptops and workstations. We envision dynamic control over the cardinality of dimensions, but leave that for future work. We would also like to explore hybrid solutions that utilize both on-disk and in-memory data structures to enable more complex nanocubes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>SFig. 2 .</head><label>2</label><figDesc>= [ [`s patial1 ,`s patial2 ], [`d evice ] ] An illustration of how to build a nanocube for five points [o 1 , . . . , o 5 ] under schema S. The complete process is described in Section 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1 :</head><label>1</label><figDesc>function NANOCUBE([o 1 , o 2 , . . . , o n ], S, time ) cube, o i , 1, S, time , updated nodes)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(node), o, d+1, updated nodes)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Pseudo-code of an algorithm to build nanocubes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>no attributes; on (2) Device only; on (3) Language only; and (4) on Device and Language, shown in relation D in Figure 4. Finally, a ROLL UP is a constrained version of the CUBE operation where the order of the input attributes is important. A ROLL UP on Device and Language (in this order) means the union of GROUP BYs on: (1) no attributes; (2) Device; and (3) Device and Lan-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>count of all Delta flights in the Midwest R Midwest R { Delta } R U /region/Midwest/where/carrier=Delta count of all flights in 2010 R U D R 2010 /field/carrier/when/2010 time-series of all United flights in 2009 R U R { United } D 2009 /tseries/when/2009/where/carrier=United heatmap of Delta flights in 2010D tile0 R { Delta } R 2010 /tile/tile0/when/2010/where/carrier=Delta A simplified set of queries supported by nanocubes. The column s represents space; t, time; c, category. R means "rollup", D means "drilldown". The value next to R or D contains the subset of that dimension's domain being selected. U represents the entire domain ("universe").</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>:</head><label></label><figDesc>every different combination of values present in the at-ID: 276 : procedure ADD(root, o, d, S,`t ime , updated nodes) : [`1,...,`k] CHAIN(S, d) : stack TRAILPROPERPATH(root, [`1(o),...,`k(o)]) if node has a single child then : SETSHAREDCONTENT(node, CONTENT(child)) : else if CONTENT(node) is null then : SETPROPERCONTENT(node, ( d= dim(S) ? SUMMEDTABLETIMESERIES( ) : NODE( ) ) : update true : else if CONTENTISSHARED(node) and CONTENT(node) not in updated nodes then :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 4</head><label>4</label><figDesc>every different combination of values present in the attes of the base relation an aggregation record is added to the re-count of all Delta flights in the Midwest R (Midwest) R { Delta } R U /region/(Midwest)/where/carrier=Delta count of early flights in 2010 R U D R (2010) /field/carrier/when/(2010) time-series of all United flights in 2009 R U R U D (2009) /tseries/when/2009/where/carrier=United heatmap of Delta flights in 2010 D (tile) R { Delta } R (2010) /tile/(tile)/where/carrier=Delta</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 5 .</head><label>5</label><figDesc>on Device, Language Cube on Device, Language Equivalent to Group By on all possible subsets of {Device, A sample relation and its associated aggregation operators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>1 :</head><label>1</label><figDesc>procedure ADD(root, o, d, S,`t ime , updated nodes) 2: [`1,...,`k] CHAIN(S, d) 3: stack TRAILPROPERPATH(root, [`1(o),...,`k(o)])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>e</head><label></label><figDesc>that for every different combination of values present in the attes of the base relation an aggregation record is added to the re-count of all Delta flights in the Midwest R (Midwest) R { Delta } R U /region/(Midwest)/where/carrier=Delta count of early flights in 2010 R U D R (2010) /field/carrier/when/(2010) time-series of all United flights in 2009 R U R U D (2009) /tseries/when/2009/where/carrier=United heatmap of Delta flights in 2010 D (tile) R { Delta } R (2010) /tile/(tile)/where/carrier=Delta Fig.4. A simplified set of queries supported by the nanocube data structure. The column s represents space; t, time; c, category. R means "rollup", D means "drilldown". The value next to R or D contains the subset of that dimension's domain being selected. We use U to represent the entire domain ("universe"). Omitted here, but supported by our structure, are: the extra parameter for number of steps throughout the time region in a time-based drilldown; multiple categories with separate rollups and drilldowns; tiles of variable resolution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 5 .</head><label>5</label><figDesc>on Device, Language Cube on Device, Language Equivalent to Group By on all possible subsets of {Device, A sample relation and its associated aggregation operators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>1 :</head><label>1</label><figDesc>procedure ADD(root, o, d, S,`t ime , updated nodes) 2: [`1,...,`k] CHAIN(S, d) 3: stack TRAILPROPERPATH(root, [`1(o),...,`k(o)])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 4 .</head><label>4</label><figDesc>that for every different combination of values present in the atbutes of the base relation an aggregation record is added to the re-count of all Delta flights in the Midwest R (Midwest) R { Delta } R U /region/(Midwest)/where/carrier=Delta count of early flights in 2010 R U D R (2010) /field/carrier/when/(2010) time-series of all United flights in 2009 R U R U D (2009) /tseries/when/2009/where/carrier=United heatmap of Delta flights in 2010 D (tile) R { Delta } R (2010) /tile/(tile)/where/carrier=Delta A simplified set of queries supported by the nanocube data structure. The column s represents space; t, time; c, category. R means "rollup", D means "drilldown". The value next to R or D contains the subset of that dimension's domain being selected. We use U to represent the entire domain ("universe"). Omitted here, but supported by our structure, are: the extra parameter for number of steps throughout the time region in a time-based drilldown; multiple categories with separate rollups and drilldowns; tiles of variable resolution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 5 .Fig. 4 .</head><label>54</label><figDesc>Device, Language Cube on Device, Language Equivalent to Group By on all possible subsets of {Device, A sample relation and its associated aggregation operators. A sample relation and its associated aggregation operators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>4. 1</head><label>1</label><figDesc>DefinitionsLet O be a set of objects. A labeling function : O → L associates a label value to the objects of O. We can think of as an attribute in a relational database. In connection with the level of detail discussion above, if 1 and 2 are two labeling functions for O, we say 1 is coarser than 2 or that 2 is finer than 1 if for any two objects o, o ∈ O the implication 2 (o) = 2 (o ) ⇒ 1 (o) = 1 (o ) holds. We denote this fact by1 2 . A sequence of labeling functions c = [ 1 , , . . . , k ] for objects O is a chain for O if every labeling function is coarser than the next labeling function in the sequence: i i+1 . The number of levels of a chain is defined by levels(c) = |c| + 1. An indexing schema for objects O consists of a sequence of chains S = [c 1 , c 2 , . . . , c n ]. The dimension of an indexing schema S is the length of its sequence of chains and is denoted by dim(S). The multiplicity of a schema S is the product of its chains' number of levels: µ(S) = ∏ n i=1 levels(c i ). A full assignment for a sequence of labeling functions[ 1 , 2 , . . . , k ] is a sequence of label values [v 1 , v 2 , . . . , v k ] where vi is a label value under i . Any prefix of a full assignment for a sequence of labeling functions, including the empty one, is referred to as a partial assignment. Note that a full assignment is also a partial assignment since a sequence is also a prefix of itself. An address on a schema is a sequence of partial assignments for its chains, more formally, if S = [c 1 , c 2 , . . . , c n ] is an indexing schema, then a = [p 1 , p 2 , . . . , p n ] is an address of S if p i is a partial assignment for chain c i . The set of possible addresses of S is denoted by addr(S). The addresses of an object o under indexing schema S, denoted by addr(o, S) are all the addresses in addr(S) whose partial assignments are consistent with the label values associated to o and it is easy to see that the size of addr(o, S) is always µ(S). Besides a schema S, the definition of a nanocube requires a separate labeling function, time : O → T , which we refer to as the time labeling function since we use it to encode the temporal aspect of our datasets. Thus, a nanocube for objects o 1 , . . . , o n is denoted by: NANOCUBE([o 1 , . . . , o n ], S, time )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>13 Fig. 6 .</head><label>136</label><figDesc>An illustration of the summed-area table variant we use for our time series indexing scheme. Every node inFigure 2stores an array of timestamped counts like the one in thisfigure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 2 .</head><label>2</label><figDesc>For clarity, this example contains only five tweets o 1 , . . . , o 5 , all ordered in time. As shown on the top-left map of Figure 2, the first two tweets (o 1 and o 2 ) were sent from the east coast of the United States; the third tweet (o 3 ), from South Africa; the fourth tweet (o 4 ) was sent from Asia, and the fifth tweet (o 5 ) from Australia. Tweets o 1 and o 4 were sent from an Android device while o 2 , o 3 , and o 5 were sent from an iPhone device. The labeling functions device , spatial1 , and spatial2 as well as the schema of this nanocube, S, are all defined on the left part of this figure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>A 9 / 11 Fig. 8 .</head><label>9118</label><figDesc>A history of American Airlines and Delta. The time series show the weekly percentage of the number of commercial flights in the United States. After 9/11 Delta (orange) saw a positive spike where American (blue) saw a negative one. The big bump on American was the merger with TWA. The heatmap shows the spatial hotspots of the two companies counting all flights after 9/11 (the time bar A can be dragged and resized to change the considered time window for the heatmap).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 9 .</head><label>9</label><figDesc>Two kinds of Customer Tickets: Type 1 (Red) and Type 2 (Blue). The heatmap on the left map corresponds to time bar A, and the one on the right to time bar B: both encode the difference between number of reports of Type 2 and Type 1 in each point of the map. Reports of Type 1 exceed reports of Type 2, but not everywhere: notice that the region of Denver is still blue. Zooming into Denver we see that the number of Type 1 reports has increased over time, but Type 2 still dominates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 11 .</head><label>11</label><figDesc>Selecting different geographical regions highlights how different populations interacted with the Brightkite social network. While in the US and UK there is no substantial difference between weekday and weekend traffic, in Japan weekday usage is markedly lower.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Fig. 14 .</head><label>14</label><figDesc>(A)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>procedure ADD(root, o, d, S,`t ime , updated nodes)</figDesc><table><row><cell cols="2">bmission ID: 276</cell></row><row><cell>0 de ck</cell><cell>1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: end procedure [`1,...,`k] stack TRAILPROPERPATH(root, [`1(o),...,`k(o)]) CHAIN(S, d) child null while stack is not empty do node POP(stack) update false if node has a single child then SETSHAREDCONTENT(node, CONTENT(child)) else if CONTENT(node) is null then SETPROPERCONTENT(node, ( d= dim(S) ? SUMMEDTABLETIMESERIES( ) : NODE( ) ) update true else if CONTENTISSHARED(node) and CONTENT(node) not in updated nodes then SETPROPERCONTENT(node, SHALLOWCOPY(CONTENT(node))) update true else if CONTENTISPROPER(node) then update true end if if update then if d= dim(S) then INSERT(CONTENT(node),`t ime (o)) else ADD(CONTENT(node), o, d+1, updated nodes) end if INSERT(updated nodes, CONTENT(node)) end if child node end while</cell></row><row><cell>m-.2.1 iza-</cell><cell></cell></row><row><cell>cif-age al-ble, for-ale del fast iM-we bes eve ata iM-</cell><cell></cell></row><row><cell>la-An rds nc-ga-rize al-ent</cell><cell></cell></row><row><cell>rd.</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>). The cube operation</figDesc><table><row><cell>ID: 276</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">: 276 rocedure ADD(root, o, d, S,`t ime , updated nodes) [`1,...,`k] CHAIN(S, d) stack TRAILPROPERPATH(root, [`1(o),...,`k(o)]) child null while stack is not empty do node POP(stack) update false if node has a single child then SETSHAREDCONTENT(node, CONTENT(child)) else if CONTENT(node) is null then SETPROPERCONTENT(node, ( d= dim(S) ? SUMMEDTABLETIMESERIES( ) : NODE( ) ) update true else if CONTENTISSHARED(node) and CONTENT(node) not in updated nodes then SETPROPERCONTENT(node, SHALLOWCOPY(CONTENT(node))) update true else if CONTENTISPROPER(node) then update true end if if update then if d= dim(S) then INSERT(CONTENT(node),`t ime (o)) else : procedure ADD(root, o, d, S,`t ime , updated nodes) : [`1,...,`k] CHAIN(S, d) : stack TRAILPROPERPATH(root, [`1(o),...,`k(o)]) : child null : while stack is not empty do : node POP(stack) : update false : if node has a single child then : SETSHAREDCONTENT(node, CONTENT(child)) : else if CONTENT(node) is null then : SETPROPERCONTENT(node, ( d= dim(S) ? SUMMEDTABLETIMESERIES( ) : NODE( ) ) : update true : else if CONTENTISSHARED(node) and CONTENT(node) not in updated nodes then : SETPROPERCONTENT(node, SHALLOWCOPY(CONTENT(node))) : update true : else if CONTENTISPROPER(node) then : update true : end if : if update then : if d= dim(S) then : INSERT(CONTENT(node),`t ime (o)) : else : ADD(CONTENT(node), o, d+1, updated nodes) : end if : INSERT(updated nodes, CONTENT(node)) : end if : child node : end while : end procedure ADD(CONTENT(node), o, d+1, updated nodes) end if INSERT(updated nodes, CONTENT(node)) end if child node end while Country Device Language nd procedure US Android en</cell></row><row><cell cols="2">US</cell><cell>iPhone</cell><cell></cell><cell>ru</cell></row><row><cell cols="2">South Africa</cell><cell>iPhone</cell><cell></cell><cell>en</cell></row><row><cell cols="2">India</cell><cell>Android</cell><cell></cell><cell>en</cell></row><row><cell cols="2">Australia</cell><cell>iPhone</cell><cell></cell><cell>en</cell></row><row><cell cols="2">Country</cell><cell>Device</cell><cell cols="2">Language</cell></row><row><cell>US</cell><cell cols="2">Android</cell><cell></cell><cell>en</cell></row><row><cell>US</cell><cell></cell><cell>iPhone</cell><cell></cell><cell>ru</cell></row><row><cell cols="2">South Africa</cell><cell>iPhone</cell><cell></cell><cell>en</cell></row><row><cell>India</cell><cell cols="2">Android</cell><cell></cell><cell>en</cell></row><row><cell cols="2">Australia</cell><cell>iPhone</cell><cell></cell><cell>en</cell></row><row><cell cols="5">aggregation represents the idea of selecting a certain group of s from a relation and summarizing this group using an aggrega-nction (e.g.count, sum, max, min). For example, a possible ation for the relation above could be to select all its records and rize those using count. In this case, five would be the final ation result. If we allow entries in the record to have a special ll, we could represent this aggreation as the following relation:</cell></row><row><cell>Country</cell><cell>Device</cell><cell cols="2">Language</cell><cell>Count</cell></row><row><cell>All</cell><cell>All</cell><cell>All</cell><cell></cell><cell>5</cell></row></table><note>er to records in a relation that contain the special value All as ag- ion records. Using this notation, it is easy to understand the con- nal ways of describing aggregations for a given relation: group e, and rollup. A group by operation is one in which a relation is from a base relation given a list of attributes and an aggregate</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>). The cube operation</figDesc><table><row><cell>: 276</cell><cell></cell><cell></cell></row><row><cell cols="3">rocedure ADD(root, o, d, S,`t ime , updated nodes) [`1,...,`k] CHAIN(S, d) stack TRAILPROPERPATH(root, [`1(o),...,`k(o)]) child null while stack is not empty do node POP(stack) update false if node has a single child then SETSHAREDCONTENT(node, CONTENT(child)) else if CONTENT(node) is null then SETPROPERCONTENT(node, ( d= dim(S) ? SUMMEDTABLETIMESERIES( ) : NODE( ) ) update true else if CONTENTISSHARED(node) and CONTENT(node) not in updated nodes then SETPROPERCONTENT(node, SHALLOWCOPY(CONTENT(node))) update true else if CONTENTISPROPER(node) then update true end if if update then if d= dim(S) then INSERT(CONTENT(node),`t ime (o)) else ADD(CONTENT(node), o, d+1, updated nodes) end if INSERT(updated nodes, CONTENT(node)) end if child node end while nd procedure</cell></row><row><cell>Country</cell><cell>Device</cell><cell>Language</cell></row><row><cell>US</cell><cell>Android</cell><cell>en</cell></row><row><cell>US</cell><cell>iPhone</cell><cell>ru</cell></row><row><cell>South Africa</cell><cell>iPhone</cell><cell>en</cell></row><row><cell>India</cell><cell>Android</cell><cell>en</cell></row><row><cell>Australia</cell><cell>iPhone</cell><cell>en</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>procedure ADD(root, o, d, S,`t ime , updated nodes)</figDesc><table><row><cell></cell><cell>ID: 276</cell><cell></cell><cell></cell></row><row><cell>: :</cell><cell cols="4">[`1,...,`k] stack TRAILPROPERPATH(root, [`1(o),...,`k(o)]) CHAIN(S, d)</cell></row><row><cell>: : : : : : : : :</cell><cell cols="4">node update if node has a single child then POP(stack) false SETSHAREDCONTENT(node, CONTENT(child)) else if CONTENT(node) is null then SETPROPERCONTENT(node, ( d= dim(S) ? SUMMEDTABLETIMESERIES( ) : NODE( ) ) update true else if CONTENTISSHARED(node) and CONTENT(node) not in updated nodes then SETPROPERCONTENT(node, SHALLOWCOPY(CONTENT(node)))</cell></row><row><cell></cell><cell cols="2">Country</cell><cell>Device</cell><cell>Language</cell></row><row><cell></cell><cell>US</cell><cell cols="2">Android</cell><cell>en</cell></row><row><cell></cell><cell>US</cell><cell></cell><cell>iPhone</cell><cell>ru</cell></row><row><cell></cell><cell cols="2">South Africa</cell><cell>iPhone</cell><cell>en</cell></row><row><cell></cell><cell>India</cell><cell cols="2">Android</cell><cell>en</cell></row><row><cell></cell><cell cols="2">Australia</cell><cell>iPhone</cell><cell>en</cell></row><row><cell></cell><cell>Country</cell><cell>Device</cell><cell cols="2">Language</cell><cell>Count</cell></row><row><cell></cell><cell>All</cell><cell cols="2">Android</cell><cell>en</cell><cell>2</cell></row><row><cell></cell><cell>All</cell><cell>iPhone</cell><cell></cell><cell>en</cell><cell>2</cell></row><row><cell></cell><cell>All</cell><cell>iPhone</cell><cell></cell><cell>ru</cell><cell>1</cell></row></table><note>For example, group by on attributes Device and Language the count aggregate function results in the relation:e that for every different combination of values present in the at- utes of the base relation an aggregation record is added to the re-:: child null: while stack is not empty do: update true: else if CONTENTISPROPER(node) then: update true: end if: if update then: if d= dim(S) then: INSERT(CONTENT(node),`t ime (o)): else: ADD(CONTENT(node), o, d+1, updated nodes): end if: INSERT(updated nodes, CONTENT(node)): end if: child node: end while: end procedure</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>no attributes; on (2) Device only; on (3) Language only; and (4) on Device and Language (2 n group bys where n is the number of input attributes):Finally, a roll up is a constrained version of the cube operation where the order of the input attributes is important. So a roll up on Device</figDesc><table><row><cell>Country</cell><cell>Device</cell><cell>Language</cell><cell>Count</cell></row><row><cell>All</cell><cell>All</cell><cell>All</cell><cell>5</cell></row><row><cell>All</cell><cell>Android</cell><cell>All</cell><cell>2</cell></row><row><cell>All</cell><cell>iPhone</cell><cell>All</cell><cell>3</cell></row><row><cell>All</cell><cell>All</cell><cell>eu</cell><cell>4</cell></row><row><cell>All</cell><cell>All</cell><cell>ru</cell><cell>1</cell></row><row><cell>All</cell><cell>iPhone</cell><cell>ru</cell><cell>1</cell></row><row><cell>All</cell><cell>Android</cell><cell>en</cell><cell>2</cell></row><row><cell>All</cell><cell>iPhone</cell><cell>en</cell><cell>2</cell></row><row><cell>All</cell><cell>iPhone</cell><cell>ru</cell><cell>1</cell></row></table><note>and Language (in this order) means the union of group by's on: (1) no attributes; (2) Device; and (3) Device and Language. Note that the group by on Language only is not part of the roll up.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank Stephen North, Luciano Barbosa, Divesh Srivastava and Jeffrey Heer for their gracious support and input, as well as the anonymous reviewers.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Blinkdb: Queries with bounded errors and bounded response times on very large data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroSys</title>
		<meeting>EuroSys</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>to appear.</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">American Statistical Association Data Expo</title>
		<ptr target="http://stat-computing.org/dataexpo/2009" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note type="report_type">Flights dataset</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Graphs in statistic analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Anscombe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The American Statistician</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="21" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">D3: Data-driven documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ogievetskey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactoins on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Scatterplot matrix techniques for large n</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Littlefield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">L</forename><surname>Nicholson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Littlefield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">398</biblScope>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Maintaining interactivity while exploring massive time series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-M</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gerth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Visual Analytics Science and Technology</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="59" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Friendship and mobility: User movement in location-based social networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGKDD</title>
		<meeting>SIGKDD</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Summed-area tables for texture mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">C</forename><surname>Crow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="207" to="212" />
			<date type="published" when="1984-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Measuring data abstraction quality in multiresolution visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Rundensteiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="709" to="716" />
			<date type="published" when="2006-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient spatial sampling of large geographical tables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">Das</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Madhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;12</title>
		<meeting>the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="193" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">by chance: enhancing interaction with large data sets through statistical sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Working Conference on Advanced Visual Interfaces, AVI &apos;02</title>
		<meeting>the Working Conference on Advanced Visual Interfaces, AVI &apos;02<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="167" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hierarchical aggregation for information visualization: Overview, techniques, and design guidelines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="439" to="454" />
			<date type="published" when="2010-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Interactive information visualization of a million items</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualization (InfoVis&apos;02), INFOVIS &apos;02</title>
		<meeting>the IEEE Symposium on Information Visualization (InfoVis&apos;02), INFOVIS &apos;02<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page">117</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Trust me, i&apos;m partially right: incremental visualization lets analysts explore large datasets faster</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Popov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Drucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI Conference on Human Factors in Computing Systems, CHI &apos;12</title>
		<meeting>the SIGCHI Conference on Human Factors in Computing Systems, CHI &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1673" to="1682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Data cube: A relational aggregation operator generalizing group-by, cross-tab, and sub-totals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bosworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Layman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reichart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Venkatrao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pellow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="53" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Openstreetmap: User-generated street maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Haklay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pervasive Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="12" to="18" />
			<date type="published" when="2008" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Online aggregation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="182" />
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Profiler: Integrated statistical analysis and visualization for data quality assessment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kandel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Parikh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Paepcke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Visual Interfaces</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Designing pixel-oriented visualization techniques: Theory and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="78" />
			<date type="published" when="2000-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Exploring n-dimensional databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wittels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st conference on Visualization &apos;90, VIS &apos;90</title>
		<meeting>the 1st conference on Visualization &apos;90, VIS &apos;90<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="230" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">imMens: Real-time visual querying of big data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroVis)</title>
		<meeting>EuroVis)</meeting>
		<imprint/>
	</monogr>
	<note>to appear, 2013. Space Query Time Constraints Datavore [18] O(|K| log 2 |K |</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O(|k|) |k| ≤ Main</forename><surname>Mem</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O(|k |) O ; |k | ≤ Gpu</forename><surname>Mem</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O(|</forename><surname>Nanocubes</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">O(1) | f (K a )| ≤ Main Mem</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Set K corresponds to the input keys and set K a to the aggregate keys induced by K. Key space, K , is a set that grows quickly with resolution and number of dimensions. Function f reflects nanocube&apos;s sharing mechanism and has an important compression effect on the already sparse set K a (see sharing col</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lyubka</surname></persName>
		</author>
		<ptr target="https://github.com/valenok/mongoose/" />
	</analytic>
	<monogr>
		<title level="m">Comparison of observed asymptotic resource usage of recent methods</title>
		<imprint/>
	</monogr>
	<note>Figure 13): | f (K a )| ≤ |K a |</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automating the design of graphical presentations of relational information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="110" to="141" />
			<date type="published" when="1986-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Show me: Automatic presentation for visual analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1137" to="1144" />
			<date type="published" when="2007-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Towards utilizing gpus in information visualization: A model and implementation of image-space operations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mcdonnel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1105" to="1112" />
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Simple random sampling from relational databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Olken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rotem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Very Large Data Bases, VLDB &apos;86</title>
		<meeting>the 12th International Conference on Very Large Data Bases, VLDB &apos;86<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="160" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ruby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RESTful Web Services. O&apos;Reilly Media</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Foundations of Multidimensional and Metric Data Structures (The Morgan Kaufmann Series in Computer Graphics and Geometric Modeling)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The eyes have it: A task by data type taxonomy for information visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 IEEE Symposium on Visual Languages, VL &apos;96</title>
		<meeting>the 1996 IEEE Symposium on Visual Languages, VL &apos;96<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page">336</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Hierarchical dwarfs for the rollup cube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sismanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Deligiannakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th ACM International Workshop on Data Warehousing and OLAP</title>
		<meeting>the 6th ACM International Workshop on Data Warehousing and OLAP</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Dwarf: Shrinking the petacube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sismanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Deligiannakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM International Conference on Management of Data (SIGMOD)</title>
		<meeting>ACM International Conference on Management of Data (SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="464" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The polynomial complexity of fully materialized coalesced cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sismanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth international conference on Very large data bases</title>
		<meeting>the Thirtieth international conference on Very large data bases</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="540" to="551" />
		</imprint>
		<respStmt>
			<orgName>VLDB Endowment</orgName>
		</respStmt>
	</monogr>
	<note>VLDB &apos;04</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Crossfilter: Fast multidimensional filtering for coordinated views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Square</surname></persName>
		</author>
		<ptr target="http://github.com/square/crossfilter" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Query, analysis, and visualization of hierarchically structured data using polaris</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>the 8th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="112" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Multiscale visualization using data cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="176" to="187" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">ASA 2009 data expo. Computational and Graphical Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wickham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="281" to="283" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
