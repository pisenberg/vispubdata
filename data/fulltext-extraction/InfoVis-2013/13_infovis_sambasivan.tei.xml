<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visualizing Request-Flow Comparison to Aid Performance Diagnosis in Distributed Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raja</forename><forename type="middle">R</forename><surname>Sambasivan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilari</forename><surname>Shafer</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michelle</forename><forename type="middle">L</forename><surname>Mazurek</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
						</author>
						<title level="a" type="main">Visualizing Request-Flow Comparison to Aid Performance Diagnosis in Distributed Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Distributed systems</term>
					<term>human factors</term>
					<term>problem diagnosis</term>
					<term>visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Comparing request-flow graphs: This side-by-side visualization, one of three interfaces we evaluate, illustrates the output of a diagnosis technique that compares graphs. It shows these two graphs juxtaposed horizontally, with dashed lines between matching nodes in both. The rightmost series of nodes in the screenshot do not exist in the graph on the left, causing the yellow nodes to shift downward in the graph on the right.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A distributed system is a set of software components running on multiple networked computers that collectively provide some service or result. Examples now pervade all walks of life, as society uses distributed services to communicate (e.g., Google's Gmail), shop (e.g., Amazon), provide entertainment (e.g., YouTube), and so forth. Though such distributed systems often have simple interfaces and usually respond quickly, great complexity is involved in developing them and maintaining their performance levels over time. Unexpected performance degradations arise frequently, and substantial human effort is involved in addressing them.</p><p>When a performance degradation arises, the crucial first step in addressing it is figuring out what is causing it. The root cause might be any of the system's software components, unexpected interactions between them, or slowdowns in the network connecting them. Exploring the possibilities and identifying the most likely root causes has traditionally been an ad-hoc manual process, informed primarily by raw performance data collected from individual components. As distributed systems have grown in scale and complexity, such ad-hoc processes have grown less and less tenable.</p><p>To help, recent research has proposed many techniques for automatically localizing the many possible sources of a new problem to just a few potential culprits <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b30">32]</ref>. These techniques do not identify the root cause directly, but rather help developers build intuition about the problem and focus their diagnosis efforts. Though complete automation would be ideal, the complexity of modern systems and the problems that arise in them ensure this human-in-the-loop model will be dominant for the foreseeable future. As such, many researchers recognize the need for diagnosis tools to present their results as clearly as possible <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b27">28]</ref>. But, apart from a few select instances <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24]</ref>, far too little research has been conducted on what types of presentations are most useful for distributed systems developers.</p><p>As a step toward addressing this need, this paper presents a 26-person user study that compares three promising approaches for visualizing the results of an implementation of one powerful, proven automated localization technique called request-flow comparison <ref type="bibr" target="#b30">[32]</ref>. The approaches we consider are well-known in the visualization community, and we make no claims as to their novelty. Rather, our contribution lies in identifying which of these approaches work best for diagnosing different types of distributed systems problems and for different developer usage modes. Our user study uses real problems observed in Ursa Minor <ref type="bibr" target="#b0">[1]</ref>, a real distributed storage system. It includes 13 professionals (i.e., developers of Ursa Minor and software engineers from Google) and 13 graduate students taking distributed systems classes.</p><p>Request-flow comparison contrasts how a distributed system services requests (e.g., "read this e-mail message" or "find books by this author") during two periods of operation: one where performance was fine ("before") and the new one in which performance has degraded ("after"). Each serviced request has a corresponding workflow within the system, representing the order and timing of components involved; for example, a request to read e-mail might start at a frontend web server that parses the request, then be forwarded to the e-mail directory server for the specific user, then be forwarded to the storage server that holds the desired message, and then return to the web server so it can respond to the requester. <ref type="figure">Figure 2</ref> shows a similar example for a generic distributed storage system. Each such request flow can be represented as a directed acyclic graph, and comparing before and after graphs can provide significant insight into performance degradations. Many organizations are interested in algorithms and visualizations for comparing request flows, including Google <ref type="bibr" target="#b33">[35]</ref>, Microsoft, and Twitter <ref type="bibr" target="#b35">[37]</ref>.</p><p>The initial version of our request-flow-comparison implementation, Spectroscope <ref type="bibr" target="#b30">[32]</ref>, used an inadequate Graphviz-based interface that required graphs to be manually and painstakingly compared with each other. The approaches we compare in this paper were chosen based on the recommendations of developers who used this initial version to diagnose real problems in Ursa Minor and certain Google services <ref type="bibr" target="#b30">[32]</ref>. They occupy three corners in the space of approaches to visualizing differences, as identified by a taxonomy of comparison approaches <ref type="bibr" target="#b16">[17]</ref>. The side-by-side approach is nearly a "juxtaposition," which presents independent layouts. Diff is an "explicit encoding," which highlights the differences between the two graphs. Animation is closest to a "superposition" design that guides attention to changes that "blink."</p><p>Despite the large body of work on comparing graphs <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b12">13]</ref>, we found no existing implementations of side-by-side, diff, and animation that are suitable for request-flow comparison's domain-specific needs. For example, differences must be found in directed acyclic graph structure and edge weights. Also, matching nodes in before-and-after graphs are not known a priori and must be identified algorithmically. Therefore, we built our own interfaces.</p><p>Our user study results show that side-by-side is the best approach for helping developers obtain an overall understanding of a problem. Diff is best for helping diagnose problems caused by non-structural differences. Animation is best for helping diagnose problems that are caused by structural differences alone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">REQUEST-FLOW COMPARISON</head><p>Request-flow comparison <ref type="bibr" target="#b30">[32]</ref> is a technique for automatically localizing the root causes of performance degradations in distributed systems, such as Ursa Minor and Bigtable <ref type="bibr" target="#b8">[9]</ref>. Such degradations often manifest as changes in the workflow of individual requests as they are serviced by the system. Exposing such changes and showing how they differ from previous behavior localizes the problem's source and significantly guides developer effort.</p><p>Request-flow comparison aims to identify changes between requestflow graphs observed during two periods: one obtained before the degradation and one obtained after the degradation. Nodes of requestflow graphs (which are directed acyclic graphs) show important events or activities observed within different components during request processing, and edges show latencies between these events (see <ref type="figure" target="#fig_1">Figure 3</ref>). Request-flow comparison identifies two important types of changes. Edge latency changes are differences in the time required to execute successive events and represent unforeseen slowdowns in request processing. Structural changes are differences in the number and causal ordering of system events. They represent slowdowns due to extra (or less) concurrent activity or additional (or different) activity within a single sequential thread (i.e., intra-thread event changes).</p><p>Spectroscope <ref type="bibr" target="#b30">[32]</ref>, our current prototype, implements request-flow comparison by grouping identically-structured graphs observed during  <ref type="table" target="#tab_2">Client A 1  1 1  1  2  2 2  2  3  3 3  3  4  4 4  4   5  5 5  5   Client B  Client B  Client B  Client B   1  1 1  1  2  2 2  2</ref> Fig <ref type="figure">. 2</ref>. A distributed storage system. To read a file, clients send a request to the frontend file server. To return the requested data, the file server may need to access other components like the data location server and storage servers. This figure shows two of many possible flows through the system.</p><p>both periods (often numbered in the hundreds or thousands) into the same category. By analyzing per-period statistical properties, Spectroscope identifies categories containing performance-affecting changes.</p><p>As output, Spectroscope presents before-and-after pairs of these categories showing how request processing changed between the two periods. Since categories contain identically structured requests, each is represented by a single constituent request-flow graph. Edge latency changes are automatically identified via hypothesis testing, but such tests may not identify all edges worth investigating, so developers must still examine before-after graph pairs manually to find additional such divergences. Similar tests are used in several automated diagnosis tools <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b30">32]</ref>. Spectroscope will identify categories containing structural changes, but developers must contrast before-after graphs manually to identify where the divergences occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK</head><p>Recent research has explored a number of approaches, including some akin to side-by-side, diff, and animation, to help users identify differences in graphs, but no single one has emerged as the clear winner <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b29">31]</ref>. The choice depends on the domain, the types of graphs being compared, and the differences of interest, thus motivating the need for the study presented in this paper. This section discusses user studies comparing different approaches for comparing graphs, as well as tools designed to identify graph differences. For understanding the evolution of undirected, unweighted graphs (e.g., many social network graphs) over time, Archambault et al. <ref type="bibr" target="#b3">[4]</ref> find that small multiples (akin to our side-by-side approach) yielded faster task completion times, but that accuracy was greater with animation for tasks that involved identifying node or edge additions/deletions.  In contrast, Farrugia et al. <ref type="bibr" target="#b12">[13]</ref> find that small multiples outperform animation with regard to both completion time and accuracy. In a later study, Archambault et al. <ref type="bibr" target="#b4">[5]</ref> evaluate a hybrid approach that uses sideby-side or animation to present diffs of consecutive graph evolutions. Participants preferred the hybrid approach over comparing independent graphs of each evolutionary stage, but, it did not yield lower completion times or increased accuracy for most tasks. Melville et al. <ref type="bibr" target="#b24">[25]</ref> develop a set of general graph-comparison questions and find that for small graphs represented as adjacency matrices, a superimposed (diff) view is superior to a juxtaposed (side-by-side) view. For weighted graphs that are much denser than our request-flow graphs, Alper et al. <ref type="bibr" target="#b1">[2]</ref> find that matrix-based superimposed representations outperform node-link-based ones. Robertson et al. <ref type="bibr" target="#b29">[31]</ref> compare animation's effectiveness to that of small multiples and one other static approach for identifying trends in the evolution of Gapminder Trendalyzer <ref type="bibr" target="#b14">[15]</ref> plots (3-dimensional data plotted on 2-D axes). They find that animation is more effective for presenting trends, while static approaches are more effective for helping users identify them.</p><p>Many tools designed to identify graph differences use domainspecific algorithms or target specific graph structures. For example, TreeJuxtaposer <ref type="bibr" target="#b25">[26]</ref> uses domain knowledge to match similar nodes in trees that show evolutionary relationships among different species. TreeVersity <ref type="bibr" target="#b17">[18]</ref> uses a diff-based technique to identify differences in node attributes and structure for trees with unweighted edges and known matchings. G-PARE <ref type="bibr" target="#b32">[34]</ref> presents overlays to compare predictions made by machine-learning algorithms on graph-based data. Visual Pivot <ref type="bibr" target="#b28">[30]</ref> helps identify relationships between two trees by using a layout that co-locates a selected common node. Beck and Diehl <ref type="bibr" target="#b5">[6]</ref> use a matrix representation to compare software architectures based on code dependencies. Donatien <ref type="bibr" target="#b18">[19]</ref> enables comparison of unweighted graphs by placing individual graphs in independently-configurable overlays, which can be optionally superimposed or viewed side-by-side. Their human-in-the loop model for graph matching could be applied to our interfaces to improve matching accuracy.</p><p>Our work in this paper complements both of the above related-work categories. Specifically, we attempt to identify good graph comparison techniques for the output of a tool used in one important domain: performance diagnosis of distributed systems using request-flow comparison. Our domain is characterized by sparse, directed, acyclic, weighted graphs, with unknown matchings. We also believe our intended audience-those familiar with distributed systems development-will exhibit different preferences than the general population.</p><p>In the systems community, there has been relatively little research conducted on visual methods for diagnosis. Indeed, a recent survey of important directions for log analysis concludes that because humans will remain in the diagnosis loop for the foreseeable feature, visualization research is an important next step <ref type="bibr" target="#b27">[28]</ref>. One project in this vein is NetClinic, which considers diagnosis of network faults <ref type="bibr" target="#b21">[22]</ref>. The authors find that visualization in conjunction with automated analysis <ref type="bibr" target="#b20">[21]</ref> is helpful for diagnosis. As in this study, their tool uses automated processes to direct users' attention, and the authors observe that automation failures inhibit users' understanding. In another system targeting network diagnosis, Mansmann et al. observe that automated tools are limited in utility without effective presentation of results <ref type="bibr" target="#b23">[24]</ref>. <ref type="figure" target="#fig_3">Figure 4</ref> shows our implementations of side-by-side, diff, and animation. All of them were guided by an initial pilot study, which is not described in this paper. These interfaces are implemented in JavaScript, and use modified libraries from the JavaScript InfoVis Toolkit <ref type="bibr" target="#b6">[7]</ref>. This section further describes them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">INTERFACE DESIGN</head><p>Side-by-side: Our side-by-side interface (illustrated with a simplified diagram at right and in <ref type="figure" target="#fig_3">Figure 4a,d</ref>) computes independent layered layouts for the before and after graphs and displays them beside each other. Nodes in the before graph are linked to matching nodes in the after graph by dashed correspondence lines. Using this interface, latency changes can be identified by examining the relative slope of adjacent dashed lines: parallel lines indicate no change in latency, while increasing skew is indicative of longer response time. Structural changes can be identified by the presence of nodes in the before or after graph with no matching node in the other graph.</p><p>Diff: Our diff interface (at right and in <ref type="figure">Figure</ref> 4b,e) shows a single static image of an explicit encoding of the differences between the before and after graphs, which are associated with the colors orange and blue respectively. The layout contains all nodes from both the before and after graphs. Nodes that exist only in the before graph are outlined in orange and annotated with a minus sign; those that exist only in the after graph are outlined in blue and annotated with a plus sign. This structural approach is akin to the output of a contextual diff tool <ref type="bibr" target="#b22">[23]</ref> emphasizing insertions and deletions.</p><p>We use the same orange and blue scheme to show latency changes, with edges that exist in only one graph shown in the appropriate color. Edges existing in both graphs produce a per-edge latency diff: orange and blue lines are inset together with different lengths. The ratio of the lengths is computed from the ratio of the edge latencies in before and after graphs, and the next node is attached at the end of the longer line.</p><p>Animation: Our animation interface (at right and in <ref type="figure" target="#fig_3">Figure 4c</ref>,f) switches automatically between the before and after graphs. Independent layouts are calculated for each graph, but non-matching nodes are not allowed to occupy the same position. To provide a smooth transition, it interpolates the positions of matching nodes. Nodes that exist in only one graph appear only on the appropriate terminal of the animation. They all become more transparent at the same rate, and vanish completely by the other terminal. Both types of transition are linear and happen concurrently.</p><p>Users can start and stop the animation, as well as manually switch between terminal or intermediate points, via the provided slider. Unless it is controlled this way, the animation repeats with a transition period of two seconds and a pause for three seconds at either terminal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Graph matching</head><p>Drawing correspondence lines in the side-by-side interface and merging corresponding nodes in the diff and animation interfaces requires identifying matching nodes in the before and after graphs. This problem is hard (in the formal sense), and there exists a wide body of work investigating algorithms and heuristics for such matching <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14]</ref>. Like many of these approaches, we use heuristics to obtain approximate matches.</p><p>Our approximation technique, which runs in O(N 2 ) time in the number of nodes, makes use of the fact that if a node in the before graph matches a node in the after graph, their node names will be the same. (Note the converse is not necessarily true.) First, we use a lexically-ordered depth-first traversal to transform both graphs into strings. Next, we keep track of the insertions, deletions, and mutations made by a string-edit distance transformation of one string into another. Finally, we map these edits back onto the appropriate interface. Items that were not inserted, deleted, or modified are ones that correspond in both graphs. A given node in the before graph is matched to at most one node in the after graph. Despite the limitations of this approach, we have found it to work well in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Common features</head><p>All three of our interfaces incorporate some common features, tailored specifically for request-flow graphs. As seen above, all graphs are represented with node-link diagrams since request-flow graphs are sparse, directed graphs that have fan-ins and fan-outs. They are drawn with a layered layout based on the technique by Sugiyama et al. <ref type="bibr" target="#b34">[36]</ref>; layouts based on this technique enjoy widespread use <ref type="bibr" target="#b11">[12]</ref>.  To navigate the interface, users can pan the graph view by clicking and dragging or by using a vertical scroll bar. In large graphs, this allows for movement in the neighborhood of the current view or rapid traversal across the entire graph. By using the wheel on a mouse, users can zoom in and out, up to a limit. We employ rubber-banding for both the traversal and zoom features to prevent the interface from moving off the screen or becoming smaller than the viewing window.</p><p>For all of the interfaces, edge lengths are drawn using a sigmoidbased scaling function that allows both large and small edge latencies to be visible on the same graph. Statistically significant edge latency changes are highlighted with a bold red outline. When graphs contain join points, or locations where multiple parallel paths converge at the same node, one path may have to wait for another to complete. Our interfaces illustrate the distinction between actual latency and waiting time by using thinner lines for the latter (see the "write in cache" to "MDSCLIENT lookup call" edge in Figures 4a-c for an example).</p><p>Each interface also has an annotation mechanism that allows users to add marks and comments to a graph comparison. These annotations are saved as an additional layer on the interface and can be restored for later examination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Interface Example</head><p>To better illustrate how these interfaces show differences, the example of diff shown in <ref type="figure" target="#fig_3">Figure 4b</ref> is annotated with the three key differences it is meant to reveal. First, the after graph contains an extra thread of concurrent activity (outlined in blue and marked with a plus sign). Second, there is a statistically significant change in metadata lookup latency (highlighted in red). Third, there is a large latency change between the lookup of metadata and the request's reply. These observations localize the problem to those system components involved in the changes and thus provide starting points for developers' diagnosis efforts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">USER STUDY OVERVIEW &amp; METHODOLOGY</head><p>We compared the three approaches via a between-subjects user study, in which we asked participants to complete five assignments using our interfaces. Each assignment asked participants to find key performanceaffecting differences for a before/after request-flow graph pair obtained from Ursa Minor <ref type="bibr" target="#b0">[1]</ref>. Four of the five assignments used graphs output by Spectroscope for real problems that were either observed in the system or injected into it. These problems are described further in Sambasivan et al. <ref type="bibr" target="#b30">[32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Participants</head><p>Our interfaces' target users are the developers of the distributed system being diagnosed. As our example tasks come from Ursa Minor, we recruited the seven Ursa Minor developers to whom we had access as expert participants. In addition, we recruited six professional distributed-system developers from Google. We refer to the Ursa Minor and Google developers collectively as professionals.</p><p>Many of our professional participants are intimately familiar with more traditional diagnosis techniques, potentially biasing their responses to our user-study questions. For a wider perspective, we recruited additional participants by advertising in undergraduate and graduate classes on distributed systems and posting fliers on and around our campus. Potential participants were required to demonstrate (via a pre-screening questionnaire) knowledge of key undergraduate-level distributed systems concepts. Of the 33 volunteers who completed the questionnaire, 29 were deemed eligible; the first 13 to respond were selected. Because all of the selected participants were graduate students in computer science, electrical and computer engineering, or information networking, we refer to them as student participants.</p><p>During the user study, each participant was assigned, round-robin, to evaluate one of the three approaches. <ref type="table" target="#tab_2">Table 1</ref> lists the participants, their demographic information, and the interface they were assigned. We paid each participant $20 for the approximately 1.5-hour study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Creating before/after graphs</head><p>Each assignment required participants to identify salient differences in a before/after graph pair. To limit the length of the study, we modified the real-problem graph pairs slightly to remove a few differences that were repeated many times. The only synthetic before/after pair was modified from a real request-flow graph observed in the system. <ref type="table">Table 2</ref> describes the various assignments and their properties.</p><p>To make the before/after graphs easier for participants to understand, we changed node labels, which describe events observed during request processing, to more human-readable versions. For example, we changed the label "e10__t3__NFS_CACHE_READ_HIT" to "Read that hit in the NFS server's cache." The original labels were written by Ursa Minor developers and only have meaning to them. Finally, we omitted numbers indicating edge lengths from the graphs to ensure participants used visual properties of our interfaces to find differences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">User study procedure</head><p>The 1.5 hour study consisted of a 10-15 minute training period, followed by three evaluation phases: guided questions, emulation of real diagnoses, and interface comparison. Participants were encouraged to think aloud throughout the study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Training</head><p>In the training phase, participants were shown an Ursa Minor diagram (similar to the one in <ref type="figure">Figure 2</ref>). They were only required to understand that the system consists of four components that can communicate over the network. We also provided a sample request-flow graph and <ref type="table">Table 2</ref>. Before/after graph-pair assignments. Assignments 1-3 were used in the guided questions phase (G); 4 and 5 were used to emulate real diagnoses (E). Four of the five assignments used graphs from the output of Spectroscope for real problems seen in Ursa Minor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Phase Assignment Differences</head><p>Before/after and type graph sizes (nodes) described the meaning of nodes and edges. Finally, we trained each participant on her assigned interface by showing her a sample before/after graph (identical to those shown in <ref type="figure" target="#fig_3">Figures 4(a-c)</ref>) and guiding her through tasks she would have to complete in latter parts of the study. Participants were given ample time to ask questions and told we would be unable to answer further questions after the training portion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Finding differences via guided questions</head><p>In this phase of the study, we guided participants through the process of identifying differences, asking them to complete five focused tasks for each of three assignments. Rows 1-3 of <ref type="table">Table 2</ref> describe the graphs used for this part of the study. TASK 1: Find any edges with statistically significant latency changes. This task required participants to find all of the graph edges highlighted in red (i.e., those automatically identified by Spectroscope as having statistically significant changes in latency distribution).</p><p>TASK 2: Find any other edges with latency changes worth investigating. Spectroscope will not identify all edges worth investigating. For example, edges with large changes in average latency that also exhibit high variance will not be identified. This task required participants to find edges with notable latency changes not highlighted in red. TASK 3: Find any groups of structural changes. Participants were asked to identify added or deleted nodes. To reduce effort, we asked them to identify these changes in contiguous groups, rather than noting each changed node individually.</p><p>TASK 4: Describe in a sentence or two what the changes you identified in the previous tasks represent. This task examines whether the interface enables participants to quickly develop an intuition about the problem in question. For example, many of the edge latency changes presented in assignment 1 indicate a slowdown in network communication between machines. Identifying these themes is a crucial step toward understanding the root cause of the problem.</p><p>TASK 5: Of the changes you identified in the previous tasks, identify which one most impacts request response time. The difference that most affects response time is likely the one that should be investigated first when attempting to find the root cause. This task evaluates whether the interface allows participants to quickly identify this key change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Emulating real diagnoses</head><p>In the next phase, participants completed two additional assignments. These assignments were intended to emulate how the interfaces might be used in the wild, when diagnosing a new problem for the first time. For each assignment, the participant was asked to complete tasks 4 and 5 only (as described above). We selected these two tasks because they most closely align with the questions a developer would ask when diagnosing an unknown problem.</p><p>After this part of the study, participants were asked to agree or disagree with two statements using a five-point Likert scale: "I am confident my answers are correct" and "This interface was useful for solving these problems." We also asked them to comment on features of the interface they liked or disliked and to suggest improvements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.4">Interface comparison</head><p>Finally, to get a more direct sense of what aspects of each approach were useful, we showed participants an alternate interface. To avoid fatiguing participants and training effects, we did not ask them to complete the assignments and tasks again; instead we asked them to briefly consider (using assignments 1 and 3 as examples) whether the tasks would be easier or harder to complete with the second interface, and to explain which features of both approaches they liked or disliked. Because our pilot study suggested animation was most difficult to use, we focused this part of the study on comparing side-by-side and diff.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Scoring criteria</head><p>We evaluated participants' responses by comparing them to an "answer key" created by an Ursa Minor developer who had previously used Spectroscope to diagnose the real problems used in this study. Tasks 1-3, which asked for multiple answers, were scored using precision/recall. Precision measures the fraction of a participant's answers that were also in the key. Recall measures the fraction of all answers in the key identified by the participant. Note that it is possible to have high precision and low recall-for example, by identifying only one change out of ten possible ones. For task 3, participants who marked any part of a correct group were given credit.</p><p>Tasks 4 and 5 were graded as correct or incorrect. For both, we accepted multiple possible answers. For example, for task 4 ("identify what changes represent"), we accepted an answer as correct if it was close to one of several possibilities, corresponding to different levels of background knowledge. In one assignment, several students identified the changes as representing extra cache misses in the after graph, which we accepted. Some participants with more experience explicitly identified that the after graph showed a read-modify write, a well-known bane of distributed storage system performance.</p><p>We also captured completion times for the five quantitative tasks. For completion times as well as precision/recall, we used the Kruskal-Wallis test to establish differences among all three interfaces, then pairwise Wilcoxon Rank Sum tests (chosen a priori) to separately compare the animation interface to each of side-by-side and diff. We recorded and analyzed participants' comments from each phase as a means to better understand the strengths and weaknesses of each approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Limitations</head><p>Our methodology has several limitations. Most importantly, it is difficult to fully evaluate visualization approaches for helping developers diagnose problems without going through the entire process of debugging a real, complex problem. However, such problems are often unwieldy and can take days to diagnose. As a compromise, we designed tasks to test whether our interfaces enable participants to understand the gist of the problem and identify starting points for diagnosis.</p><p>Deficiencies in our interface implementations may skew participants' notions of which approaches work best for various scenarios. We explicitly identify such cases in our evaluation and suggest ways for improving our interfaces so as to avoid them in the future.</p><p>We stopped recruiting participants when their qualitative comments converged, leading us to believe we had enough information to identify the useful aspects of each interface. However, our small sample size may limit the generalizability of our quantitative results.</p><p>Many of our participants were not familiar with statistical significance and, as such, were confused by the wording of some of our tasks (especially tasks 1 and 2). We discuss this in more detail in Section 7.</p><p>Our participants skewed young and male. To some extent this reflects the population of distributed-systems developers and students, but it may limit the generalizability of our results somewhat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">USER STUDY RESULTS</head><p>No single approach was best for all users and types of graph differences. For example, side-by-side was preferred by novices, and diff was preferred by advanced users and experts. Similarly, where side-byside and diff proved most useful for most types of graph differences, animation proved better than side-by-side and diff for two very common types. When one of our participants (PD06) was asked to pick his preferred interface, he said, "If I had to choose between one and the other without being able to flip, I would be sad." When asked to contrast side-by-side with diff, SS01 said, "This is more clear, but also more confusing." Section 6.1 compares the approaches based on participants' quantitative performance on the user study tasks. Sections 6.2 to 6.4 describe our observations and participants' comments about the various interfaces and, based on this data, distill the approaches best suited for specific graph difference types and usage modes. <ref type="figure" target="#fig_4">Figure 5</ref> shows completion times for each of the three interfaces. Results for individual tasks, aggregated over all assignments, are shown (note that assignments, as shown in <ref type="table">Table 2</ref>, may contain one or multiple types of differences). Participants who used animation took longer to complete all tasks compared to those who used side-by-side or diff, corroborating the results of several previous studies <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b29">31]</ref>. Median completion times for side-by-side and diff are similar for most tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Quantitative results</head><p>The observed differences between animation and the other interfaces are statistically significant for task 1 ("identify statistically significant changes") and task 4 ("what changes represent"). <ref type="bibr" target="#b0">1</ref> The observed trends are similar when students and professionals are considered separately, except that the differences between animation and the other interfaces are less pronounced for the latter. <ref type="figure" target="#fig_5">Figure 6a</ref> shows the precision, recall, and accuracy results for each of the three interfaces. Our results are not statistically significant, but do contain artifacts worth describing. Overall, both side-by-side and diff fared well, and their median scores for most tasks are similar for precision, recall, and accuracy. Notable exceptions include recall for task 2 ("find other latency changes") and recall for task 3 ("identify structural changes"), for which diff performed better. Overall, both diff and animation exhibit much higher variation in scores than side-by-side. Though animation's median scores are better than or comparable to the other interfaces for tasks 3, 4, and 5, its scores are worse for precision for task 1 and recall for task 2. <ref type="figure" target="#fig_5">Figures 6b and 6c</ref> show the results broken down by participant type. No single interface yielded consistently higher median scores for either group. Though professionals performed equally well with diff and side-by-side for many tasks, their scores with diff are higher for tasks 2 and 3 and higher with side-by-side for task 4. Students' median scores were higher with side-by-side for task 2 and task 5 and higher for recall with diff for task 1 and task 3. Also, students' diff scores exhibit significantly more variation than side-by-side, perhaps because not all of them were familiar with text-based diff tools, which are often used by professionals for source code-revision control. For professionals, animation's median scores are almost never higher than side-by-side. Students had an easier time with animation. For them, animation's median scores are higher than diff and side-by-side for task 2 (precision), task 4, and task 5. Animation's median score is higher than side-by-side for task 3 (recall). <ref type="figure">Figure 7</ref> shows Likert-scale responses to the questions "I am confident my answers are correct" and "This interface was useful for answering these questions." Diff and side-by-side were tied in the number of participants that strongly agreed or agreed that they were confident in their answers (5 of 9, or 56%). However, where one side-by-side user strongly agreed, no diff users did so. Only one animation user (of eight; 12.5%) was confident in his answers, so it is curious that animation was selected as the most useful interface. We postulate this is because participants found animation more engaging and interactive than the other interfaces, an effect also noted by other studies <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b29">31]</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Side-by-side</head><p>Participants liked the side-by-side interface because it was the most straightforward one. It showed the true response times (i.e., overall latencies) of both graphs, enabling participants to quickly get a sense of how much performance had changed. Correspondence lines clearly showed matching nodes in each graph. Also, this interface allowed independent analyses of both graphs, which our professional participants said was important. Comparing diff to side-by-side, PD08 said "it's [side-by-side] a lot easier to tell what the overall latency is for each operation. . . . [the nodes are] all put together without any gaps in the middle." SD09 said, "With [side-by-side], I can more easily see this is happening here before and after. Without the dashed lines, you can't see which event in the previous trace corresponds to the after trace." These sentiments were echoed by many others (e.g., SD06, SD07, PD07).</p><p>Our side-by-side interface suffers from two key drawbacks. First, it is difficult to identify differences when before/after graphs differ significantly because corresponding nodes become farther apart. PS01 complained that "the points that should be lining up are getting farther and farther away, so it's getting more difficult to compare the two." PD06 complained that it was more difficult to match up large changes since the matching counterpart could be off the screen. Similar complaints were voiced by other participants (e.g., PS02, SS02, PS04). Adding the ability to pin one graph relative to another to our side-by-  <ref type="figure">Fig. 7</ref>. Likert responses, by condition. Each participant was asked to respond to the statements "I am confident my answers are correct" and "The interface was useful for answering these questions." side implementation would limit vertical distance between differences. However, horizontal distance, which increases with the number of concurrent threads in each request, would remain. Second, when nodes are very close to another, correspondence lines became too cluttered and difficult to use. This led to complaints from several participants (e.g., PS03, SS01, SS03, PA13). To cope, SS03 and PS05 gave up trying to identify matching nodes between the graphs and instead identified structural differences by determining if the number of correspondence lines on the screen matched the number of nodes visible in both the before and after graph. Modifying our side-by-side interface to draw correspondence lines only at the start of a contiguous run of matching nodes would help reduce clutter, but would complicate edge latency comparisons.</p><p>Based on participants' comments above and our observations, Table 3 shows the use cases for which we believe side-by-side is the best of the three approaches. As shown in <ref type="table">Table 3</ref>, side-by-side's simple approach works best for aiding comprehension. However, due to potential for horizontal skew and clutter, it is not the best approach for identifying any type of difference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Diff</head><p>Participants' comments about our diff interface were polarized. Professionals and more advanced students preferred diff's compactness, whereas others were less decisive. For example, PS03 claimed diff's compact representation made it easier for him to draw deductions. Indeed, unlike side-by-side, diff always shows differences right next to each other, making it easier to find differences when before and after graphs have diverged significantly. Also, by placing differences right next to each other, diff allows for easier identification of smaller structural and edge latency changes. In contrast, SS04 said, "[Side-by-side] may be more helpful than [diff], because this is not so obvious, especially for structural changes."</p><p>Though participants rarely made explicit comments about finding diff challenging to use, we found that diff encouraged incorrect mental models in student participants. For example, SD08 and SD09 confused structural differences within a single thread of activity with a change in the amount of concurrency. It is easy to see why participants might confuse the two, as both are represented by fan-outs in the graph.</p><p>We postulate that participants' comments about diff vary greatly because its compact representation requires more knowledge about software development and distributed systems than that required by the more straightforward side-by-side interface. Additionally, many of our professionals are familiar with diff tools for text, which would help them understand our graph-based diff technique more easily.</p><p>Since it places differences close together, <ref type="table">Table 3</ref> lists diff as the best approach for showing edge latency changes. However, because it encourages poor mental models for structural differences, it is not the best approach for showing concurrency changes and intra-thread event changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Animation</head><p>Our participants often struggled when using our animation interface. With this interface, all differences between the two graphs appear and disappear at the same time. This combined movement causes two problems. First, it creates a large amount of visual flux when both structural and edge latency differences are present within the same thread of activity. This confused users and prevented them from accurately identifying differences. PA11 complained, "Portions of graphs where calls are not being made in the after trace are fading away while other nodes move on top of it and then above it . . . it is confusing." These sentiments were echoed by many other participants (e.g., SA11, PA12, SA10, PA13).</p><p>Second, the large amount of combined movement that results when multiple difference types are present in the same thread prevented participants from establishing static reference points for gauging the impact of a given difference. SA10 told us: "I want to. . . pick one node and switch it between before and after. [But the same node] in before/after is in a different location completely." SA12 said he did not like our animation interface because of the lack of consistent reference points. "If I want to measure the size of an edge, if it was in the same position as before. . . then it'd be easy to see change in position or length."</p><p>Staged animation techniques <ref type="bibr" target="#b19">[20]</ref>, in which differences are animated in one at a time, could reduce combined movement, lower visual flux, and allow users to establish reference points. However, significant research is needed to understand how to effectively stage animations for graphs that exhibit both structural and edge latency changes. Many graph animation visualizations do not use staging and only recent work has begun to explore where such basic approaches fail <ref type="bibr" target="#b15">[16]</ref>.</p><p>Another negative aspect of animation (staged or not) is that it suggests false intermediate states. As a result, SA13 interpreted our interface's animation sequence as a timeline of changes and listed this as a feature he really liked. PA13 told us we should present a toggle instead of a slider so as to clarify that there are only two states. <ref type="table">Table 3</ref>. Most useful approaches for aiding overall comprehension and helping identify the various types of graph differences contained in the user study assignments. These results are based on our qualitative observations and participants' comments. A indicates the best approach for a particular category, whereas a indicates an approach poorly suited to a particular category. Side-by-side is best for aiding overall comprehension because of its straightforward presentation. Diff is best for showing edge latency changes because it places such changes right next to one another. Animation is best for showing structural differences (i.e., intra-thread event changes and concurrency changes) due to the blinking effect it creates for them. Due to their various drawbacks, no single approach is best for showing multiples types of differences within a single thread of activity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comprehension Difference identification</head><p>Shows overall latency change Supports independent analyses Concurrency change Intra-thread event change Edge latency change Intra-thread mixed</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Side Diff Anim</head><p>Despite the above drawbacks, animation excels at showing graphs with only structural differences, such as changes to events within threads (i.e., intra-thread event changes) and concurrency changes. Participants can easily find reference points for such difference by looking for the beginning and end of the structural change (or a contiguous group of them). Additionally, structural differences by themselves, especially concurrency-related ones, do not create a large amount of visual flux because they tend to affect distinct, segmented portions of the graphs. As such, instead of a cacophony of movement, the effect when structural differences are animated is a pleasing blinking effect in which distinct portions of the graph appear and disappear, allowing users to identify such differences easily. For one such assignment, both PA11 and PA12 told us the structural difference was very clear with animation. Other studies have also noted that animation's effectiveness increases with increasing separation of changed items or decreasing visual flux <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>Due to the blinking effect it creates, <ref type="table">Table 3</ref> lists animation as the best approach for showing structural differences. However, the problems caused by combined movement make it the worst interface for showing both edge latency and structural differences within a single thread of activity (i.e., intra-thread mixed changes).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DESIGN LESSONS &amp; RESEARCH CHALLENGES</head><p>In addition to yielding insights about which visualization approaches are best suited to different scenarios, our user study experiences have helped us identify several important design guidelines for future diagnosis visualizations. This section describes the most important ones, and highlights associated research challenges.</p><p>Provide anchor points to help reduce skew and combined movement: Many users struggled with the increasing skew in the side-byside layout, as well as the inability to quickly trace a correspondence from one graph to another (e.g., PS02, SA10, and PS05). Users also struggled with the animation interface when both edge latency and structural differences were present within the same thread because it animated all of them together. A future interface might anchor the comparison in multiple or user-selectable locations to mitigate this problem. However, there are subtleties involved in choosing and using anchor points.</p><p>One option, as requested by most of our participants (e.g., PA12 and PD08), is to anchor the comparison at a user-selectable location. Another is to re-center the graph as users scroll through it. However, both techniques distort the notion that time flows downward, and neither would reduce horizontal distance or clutter. Approaches that restructure the comparison to minimize the horizontal distance between matched nodes are an interesting research opportunity.</p><p>For the animation technique, anchoring in multiple locations could be achieved by staging changes. Questions of ordering immediately arise: structural changes might be presented before, after, or between latency changes. The choice is non-obvious. For example, it is not clear whether to animate structural and latency changes together when the structural change causes the latency change or even how to algorithmically determine such cases (see <ref type="figure">Figure 1</ref> for an example).</p><p>Selectively reduce diagnosis output complexity: Even when they were navigable, graphs with hundreds of nodes posed an obstacle to understanding the output at a high level. While the straightforward approach to zooming we implemented for this study allows the entire graph to be seen, it does not provide intuition into the graph's meaning when zoomed out. Therefore, users needed to scroll through graphs while zoomed in, a complaint for multiple users (e.g., SD05, SA10).</p><p>Further work is needed to investigate options for a higher-level view of the graph that could be shown instead. Some options for semantic zooming based on such a view include coalescing portions of the comparison that are the same in both graphs, or grouping sequences of similar operations (mentioned by several participants, including SD09, PS02, and PD09). Determining which portions to coalesce and defining "similar" operations are non-trivial problems, and solutions may require user guidance or automated techniques to learn meaningful groupings.</p><p>Include strong annotation mechanisms: Annotation was used in this study to record answers, but has the potential to be a valuable tool for collaborative debugging. Developing and debugging a large system involves multiple components built and maintained by different parties, many without knowledge of the internal workings of components that might contain a problem. Users could make annotations for other developers or for documentation. In fact, several professional participants from Google listed our annotation mechanism as a strength of the interfaces (e.g., PA13, PS04, and PD08). PS04 said "[I] really like the way you added the annotation. . . .So other people who are later looking at it can get the benefit of your analysis." Supporting cooperative diagnosis work with an annotation interface, such as that used in Rietveld <ref type="bibr">[29]</ref> for code reviews, is an interesting avenue of future work.</p><p>Match automation to users' expectations: Like several other diagnosis tools, Spectroscope uses statistical significance as the bar for automatically identifying differences, because it bounds wasted developer effort by limiting the expected number of false positives. However, many of our participants did not have a strong background in statistics and so mistook "statistically significant" to mean "large changes in latency." They did not know that variance affects whether an edge latency change is deemed statistically significant. This generated confusion and accounted for lower than expected scores for some tasks. For example, some participants (usually students) failed to differentiate between task 1 and task 2, and a few refused to mark a change as having the most impact unless it was highlighted in red (as statistically significant). Trying to account for why one particularly large latency change was not highlighted, SA10 said, "I don't know what you mean by statistically significant. Maybe it's significant to me." These concerns were echoed by almost all of our participants, and demonstrate that automation must match users' mental models. Statistics and machine learning techniques can provide powerful automation tools, but to take full advantage of this power-which becomes increasingly important as distributed systems become more complex-developers must have the right expectations about how they work. Both better techniques and more advanced training may be needed to achieve this goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">SUMMARY &amp; NEXT STEPS</head><p>For tools that automate aspects of problem diagnosis to be useful, they must present their results in a manner developers find clear and intuitive. This paper compares the relative merits of three commonly used visualization approaches in the context of presenting the results of one promising automated problem localization technique. Via a 26-participant user study, we found that each approach has unique strengths for different distributed systems problem types, developer usage modes, and users.</p><p>Since each of the approaches provided unique benefits, we believe the next step of our research will involve developing an integrated interface that allows users to dynamically switch between side-by-side, diff, and animation. We suspect that empowering users to view the same output from multiple perspectives will enable insights not possible with any single approach. As part of developing this interface, we believe it is important to explore how to stage animation to reduce combined movement and also to investigate mechanisms for semantic zooming of large, complex graphs.</p><p>Finally, we are also interested exploring whether our insights about the various approaches could help guide visualizations in other domains that use directed acyclic graphs (or similar types of graphs). Examples include comparing software versions <ref type="bibr" target="#b9">[10]</ref>, business-process graphs <ref type="bibr" target="#b2">[3]</ref> and general workflows <ref type="bibr" target="#b31">[33]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Raja R. Sambasivan is with Carnegie Mellon. E-mail: rajas@ece.cmu.edu. • Ilari Shafer is with Carnegie Mellon. E-mail: ishafer@cs.cmu.edu. • Michelle L. Mazurek is with Carnegie Mellon. E-mail: mmazurek@cmu.edu. • Gregory R. Ganger is with Carnegie Mellon. E-mail: ganger@ece.cmu.edu. Manuscript received 31 March 2013; accepted 1 August 2013; posted online 13 October 2013; mailed on 4 October 2013. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Example request-flow graph. This graph shows the flow of a read request through the distributed storage system shown inFigure 2. Node names represent important events observed on the various components while completing the required work. Edges show latencies between these events. Fan-outs represent the start of parallel activity, and synchronization points (i.e., joins) are indicated by fan-ins. Due to space constraints, only the events observed on the frontend file server are shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Side-by-side training (b) Diff training (c) Animation training (d) Side-by-side real problem (e) Diff real problem (f) Animation real problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Three interfaces. This diagram illustrates the three approaches to visualizing differences in request-flow graphs that we compare in this studyFigures a, b, and c show the interfaces applied to a mocked-up problem that was used to train participants (slightly modified for clarity on paper).Figures d, e, and f show the interfaces applied to a portion of one of the real-world problems that was presented to participants.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Completion times for all participants. The boxplots show completion times for individual tasks, aggregated across all assignments. Boxes extend from the first quartile to the third quartile, and whiskers to the range of the data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>(a) Precision, recall, and accuracy scores for all participants (b) Precision, recall, and accuracy scores for professionals (c) Precision, recall, and accuracy scores for students Precision/recall scores. The boxplots show precision, recall, and accuracy scores for individual tasks, aggregated across all assignments. Boxes extend from the first quartile to the third quartile, and whiskers to the range of the data. Colored triangles represent single outliers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Participant demographics. Our 26 participants included 13 professional distributed systems developers and 13 graduate students familiar with distributed systems. The ID encodes the participant group (P=professional, S=student) and the assigned interface (S=side-by-side, D=diff, A=animation). Average ages were 35 (professionals) and 25 (students).</figDesc><table><row><cell>ID</cell><cell>Gender</cell><cell>Age</cell><cell>Interface</cell><cell>ID</cell><cell>Gender</cell><cell>Age</cell><cell>Interface</cell></row><row><cell cols="4">PS01 M 26 S</cell><cell>SS01</cell><cell cols="3">F 23 S</cell></row><row><cell cols="4">PS02 M 33 S</cell><cell cols="4">SS02 M 21 S</cell></row><row><cell cols="4">PS03 M 38 S</cell><cell cols="4">SS03 M 28 S</cell></row><row><cell cols="4">PS04 M 44 S</cell><cell cols="4">SS04 M 29 S</cell></row><row><cell cols="4">PS05 M 30 S</cell><cell cols="4">SD05 M 35 D</cell></row><row><cell cols="4">PD06 M 37 D</cell><cell cols="4">SD06 M 22 D</cell></row><row><cell cols="4">PD07 M 44 D</cell><cell cols="4">SD07 M 23 D</cell></row><row><cell cols="4">PD08 M 37 D</cell><cell cols="4">SD08 M 23 D</cell></row><row><cell cols="4">PD09 M 28 D</cell><cell cols="4">SD09 M 25 D</cell></row><row><cell cols="4">PA10 M 33 A</cell><cell cols="4">SA10 F 26 A</cell></row><row><cell cols="4">PA11 M 26 A</cell><cell cols="4">SA11 M 23 A</cell></row><row><cell cols="4">PA12 M 40 A</cell><cell cols="4">SA12 M 22 A</cell></row><row><cell cols="4">PA13 M 34 A</cell><cell cols="4">SA13 M 23 A</cell></row><row><cell></cell><cell cols="2">(a) Professionals</cell><cell></cell><cell></cell><cell cols="2">(b) Students</cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Task 1: χ 2 =6.7, df=2, p=0.04 (omnibus), W=14, p=0.04 (side-anim), W=12, p=0.02 (diff-anim). Task 4: χ 2 =6.05, df=2, p&lt;0.05 (omnibus), W=14, p=0.04 (side-anim), W=14, p=0.04 (diff-anim).</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers and Brad Myers for their feedback. We also thank the members and companies of the PDL Consortium (including Actifio, APC, EMC, Emulex, Facebook, Fusion-io, Google, Hewlett-Packard Labs, Hitachi, Intel, Microsoft Research, NEC Laboratories, NetApp, Oracle, Panasas, Riverbed, Samsung, Seagate, STEC, Symantec, VMware, and Western Digital) for their interest, insights, feedback, and support. This research was sponsored in part by a Google research award, NSF grant #CNS-1117567, and by Intel via the Intel Science and Technology Center for Cloud Computing (ISTC-CC). Ilari Shafer is supported in part by an NSF Graduate Research Fellowship. Michelle L.</p><p>Mazurek is supported in part by a Facebook Fellowship.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Ursa Minor: versatile cluster-based storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abd-El-Malek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">V</forename><surname>Courtright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cranor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hendricks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Klosterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mesnier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Salmon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Sambasivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sinnamohideen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Strunk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Thereska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wachs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wylie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FAST</title>
		<meeting>FAST</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Cited on pages 2 and 5</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Weighted graph comparison techniques for brain connectivity analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Alper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">H</forename><surname>Riche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Isenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHI</title>
		<meeting>CHI</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>Cited on page 3</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visual graph comparison</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wohlfahrt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wurzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IV</title>
		<meeting>IV</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>Cited on page 9</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Animation, small multiples, and the effect of mental map preservation in dynamic graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Purchase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pinaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="539" to="552" />
			<date type="published" when="2011-04" />
		</imprint>
	</monogr>
	<note>Cited on pages 2, 6, and 9</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Difference map readability for dynamic graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Purchase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pinaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GD</title>
		<meeting>GD</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Visual comparison of software architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Diehl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOFTVIS</title>
		<meeting>SOFTVIS</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>Cited on page 3</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename><surname>Belmonte</surname></persName>
		</author>
		<ptr target="http://www.thejit.org" />
		<title level="m">The Javascript Infovis Toolkit</title>
		<imprint>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Graph matching: theoretical foundations, algorithms, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bunke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VI</title>
		<meeting>VI</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bigtable: a distributed storage system for structured data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Gruber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
	<note>Cited on page 2</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A system for graph-based visualization of the evolution of software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Collberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kobourov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nagra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pitts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wampler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOFTVIS</title>
		<meeting>SOFTVIS</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>Cited on page 9</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Graph matching algorithms for business process model similarity search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dijkman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>García-Bañuelos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. BPM</title>
		<meeting>BPM</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graphviz and Dynagraph -static and dynamic graph drawing tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ellson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Woodhull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing Software, Mathematics and Visualization</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Effective temporal graph layout: a comparative study of animation versus static display methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Farrugia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Quigley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Visualization</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="64" />
			<date type="published" when="2011-01" />
		</imprint>
	</monogr>
	<note>Cited on pages 2, 3, 6, and 7</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A survey of graph edit distance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Analysis and Applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2010-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://www.gapminder.org.Citedonpage3" />
		<title level="m">Gapminder</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Perception of animated node-link diagrams for dynamic graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2012-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Visual comparison for information visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gleicher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Albers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Jusufi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Visualization</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="289" to="309" />
			<date type="published" when="2011-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Interactive visualizations for comparing two trees with structure and node value changes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A G</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Buck-Coleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<idno>HCIL-2012-04</idno>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">3</biblScope>
		</imprint>
		<respStmt>
			<orgName>University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Interactive graph matching and visual comparison of graphs and clustered graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hascoët</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Dragicevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AVI</title>
		<meeting>AVI</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Animated transitions in statistical data graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Robertson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1240" to="1247" />
			<date type="published" when="2007-11" />
		</imprint>
	</monogr>
	<note>Cited on page 8</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Detailed diagnosis in enterprise networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Verkaik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>Cited on pages 1, 2, and 3</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">NetClinic: interactive visualization to enhance automated fault diagnosis in enterprise networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VAST</title>
		<meeting>VAST</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="3" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Comparing and merging files with GNU diff and patch. Network Theory Ltd</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eggert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stallman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Visual support for analyzing network traffic and intrusion detection events using TreeMap and graph representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Mansmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHiMiT</title>
		<meeting>CHiMiT</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="3" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Combined vs. separate views in matrix-based graph analysis and comparison</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Melville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Kennedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IV</title>
		<meeting>IV</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">TreeJuxtaposer: scalable tree comparison using focus+context with guaranteed visibility</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Guimbretière</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tasiran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="453" to="462" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>Cited on page 3</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Structured comparative analysis of systems logs to diagnose performance problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nagaraj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Neville</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Advances and challenges in log analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Oliner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ganapathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="3" />
			<date type="published" when="2012-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Polyarchy visualization: visualizing multiple intersecting hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cameron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Czerwinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Robbins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHI</title>
		<meeting>CHI</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Effectiveness of animation in trend visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1325" to="1332" />
			<date type="published" when="2008-11" />
		</imprint>
	</monogr>
	<note>Cited on pages 2, 3, 6, and 7</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Diagnosing performance changes by comparing request flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Sambasivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Rosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Krevat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Whitman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stroucken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>Cited on pages 1, 2, and 5</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Querying and re-using workflows with VsTrails</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
	<note>Cited on page 9</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">G-PARE: a visual analytic tool for comparative analysis of uncertain graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sharara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sopan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Namata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VAST</title>
		<meeting>VAST</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Dapper, a large-scale distributed systems tracing infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">H</forename><surname>Sigelman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Stephenson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Plakal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jaspan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Shanbhag</surname></persName>
		</author>
		<idno>dapper-2010-1</idno>
		<imprint>
			<date type="published" when="2010-04" />
			<pubPlace>Google</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Cited on page 2</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Methods for visual understanding of hierarchical system structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1981-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Twitter Zipkin</surname></persName>
		</author>
		<ptr target="https://github.com/twitter/zipkin.Citedonpage2" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
