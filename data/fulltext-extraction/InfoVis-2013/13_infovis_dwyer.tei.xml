<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Edge Compression Techniques for Visualization of Dense Directed Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013-10-13">13 October 2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Dwyer</surname></persName>
							<email>tim.dwyer@monash.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathalie</forename><forename type="middle">Henry</forename><surname>Riche</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename><surname>Marriott</surname></persName>
							<email>kim.marriott@monash.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Mears</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Monash University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Edge Compression Techniques for Visualization of Dense Directed Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2013-10-13">13 October 2013</date>
						</imprint>
					</monogr>
					<note type="submission">received 31 March 2013; accepted 1 August 2013; posted online</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(b) Since B and D have exactly the same sets of neighbors they can be grouped leaving 18 edges using a simple Neighbor Matching.</p><p>(c) A Modular Decomposition allows internal structure within modules and nesting. Nine edges remain.</p><p>(d) A Power-Graph Decomposition further relaxes the definition of a module to allow edges to cross module boundaries, allowing the same graph to be drawn with only 7 edges. Abstract-We explore the effectiveness of visualizing dense directed graphs by replacing individual edges with edges connected to "modules"-or groups of nodes-such that the new edges imply aggregate connectivity. We only consider techniques that offer a lossless compression: that is, where the entire graph can still be read from the compressed version. The techniques considered are: a simple grouping of nodes with identical neighbor sets; Modular Decomposition which permits internal structure in modules and allows them to be nested; and Power Graph Analysis which further allows edges to cross module boundaries. These techniques all have the same goal-to compress the set of edges that need to be rendered to fully convey connectivity-but each successive relaxation of the module definition permits fewer edges to be drawn in the rendered graph. Each successive technique also, we hypothesize, requires a higher degree of mental effort to interpret. We test this hypothetical trade-off with two studies involving human participants. For Power Graph Analysis we propose a novel optimal technique based on constraint programming. This enables us to explore the parameter space for the technique more precisely than could be achieved with a heuristic. Although applicable to many domains, we are motivated by-and discuss in particular-the application to software dependency analysis.</p><p>Index Terms-Directed graphs, networks, modular decomposition, power graph analysis</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Tremendous work has been focused on the visualization of graphs, i.e. data structures composed of nodes connected by edges. This work has yielded techniques allowing the display of a large number of elements. However, the usefulness of these representations is doubtful when the graphs are so dense with edge curves as to be unreadable. This problem is made even worse when the directionality of the edges is important. Understanding the direction of dependencies in software-engineering diagrams or the direction of flow in biological reaction networks is essential to those applications and countless others. In such applications, to answer questions about directed connectivity each individual edge path must be traceable and its direction obvious.</p><p>We encountered this specific problem when developing a software dependency visualization feature for the Microsoft Visual Studio Integrated Development Environment. The tool's default behavior is to produce a diagram of the dependencies between the top-level components in a given piece of software using a node-link representation. The idea is to produce a relatively small overview of the system from whence the user can perform a top-down visual exploration into the full dependency graph associated with each component. However, for any but the most trivial systems, this top-level diagram may already be so dense with dependency links as to be difficult to read.</p><p>For example, <ref type="figure">Fig. 2(a)</ref> is the top-level graph produced by the tool for IronPython, an open-source .NET based implementation of the Python language. Part of the problem here is that the "Externals" node has a link from every other node in the graph. This means that every component in the system references a library external to the loaded (a) The top-level component graph produced by the Visual Studio code-dependency analysis tool for the IronPython code base with 39 edges.</p><p>(b) We remove the links from every element to the "Externals" node and replace them with a single link from the group of all nodes. The same information is presented but 12 links have been removed and one aggregate link added.</p><p>(c) A full modular decomposition of the same graph leaves only six aggregate links without any loss of connectivity information for an 85% compression rate. <ref type="bibr">[4]</ref> codebase. The representation in (c) starts to look like the kind of "poster" that makers of complex software frameworks sometimes produce to convey the high-level architecture of the platform, e.g. <ref type="bibr" target="#b11">[13]</ref>. However, such poster views are usually conceptual and abstract. This representation is a precise depiction of the underlying code dependencies and can be generated automatically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. Edge compression techniques applied to the graph of dependencies between libraries in the IronPython</head><p>code-base. Unfortunately, this is a common situation in software engineering since most code depends on other platforms. We cannot remove the "Externals" node since in this interactive system it provides a useful UI affordance: users can expand the node to see exactly which external libraries are referenced. We could instead adopt the convention of placing a box around nodes that are internal to the IronPython source-code. Then, one thick arrow from the box to the "Externals" node, as in <ref type="figure">Fig. 2(b)</ref>, implies that every node inside the box has a link to the "Externals" node. This first transformation is fairly obvious, however, it turns out that by repeatedly applying the same type of grouping we can go significantly further to reduce the clutter, as in <ref type="figure">Fig. 2(c)</ref>.</p><p>The only caveats to such edge-compression techniques are that the convention of links being "rolled-up" between groups needs to be learned and that people may have some difficulty in mentally "unrolling" in order to perform useful analysis. We argue in this paper that the benefits provided by edge-compression techniques outweigh these caveats. Contributions. We examined three types of edge-compression techniques called Matching Neighbors, Modular Decomposition and Power Graph Analysis, extending the latter to handle directed graphs. We experimentally tested whether people with little graph expertise can learn to read such representations depending on the type and degree of edge compression. To our knowledge, we report the first empirical studies involving human participants on the readability of these techniques. Our results reveal their potential and immediate application to the visualizations of directed graphs in a variety of domains. Our first study, comparing flat directed graphs with graphs compressed using matching neighbors or modular decomposition, is presented in ยง4.</p><p>We then move beyond the simple techniques above to a generaliza-tion of edge compression as an optimization problem that we believe is NP-hard. This allows us to test different goal functions controlling the degree of compression. A prior technique Power Graph Analysis <ref type="bibr" target="#b21">[23]</ref> attempted only to remove as many edges as possible. We hypothesize that graphs with such maximal compression may prove too difficult to read and that other objectives should be considered. However, a readability study using a heuristic compression may be significantly compromised by the limitations of the heuristic. We introduce a novel methodology involving the use of Constraint Programming to generate a corpus of optimal solutions to small compression problems with a range of objectives. To summarize, the contributions of this methodology are: a constraint optimization model, ยง5.1; the corpus of graphs and their optimal compressed solutions ready for other researchers to use, ยง6; the first empirical comparison of the power graph heuristic to the optimal, ยง7; and the results of our own controlled experiment on readability, ยง8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>People have sought to provide simpler views of large and complex graphs by automatic grouping for some time. Most commonly this is done with techniques that elide information to provide a more abstract or high-level view. For example, Gansner et al. <ref type="bibr" target="#b10">[12]</ref> use a spatial clustering based on an initial layout of a large graph to provide an extremely abridged overview of the full graph's structure. Abello et al. <ref type="bibr" target="#b3">[5]</ref> compute a hierarchical clustering based on the graph structure that users are then able to navigate interactively. Note that both of these techniques remove both nodes and edges to produce their abridged views. A past evaluation of such a lossy graph compression technique is provided by Archambault et al. <ref type="bibr" target="#b4">[6]</ref>. Their study evaluates interactive navigation of clustered graphs. In this paper we focus on techniques that allow the precise structure of the entire graph to be inferred by the reader without the need for interaction. To the best of our knowledge, the first work that used a grouping over nodes to allow implicit edges to be removed is the Phrase Nets text visualization system by van Ham et al. <ref type="bibr" target="#b22">[24]</ref>. Before displaying the Phrase Nets they would find sets of nodes with identical neighbor sets. In the final drawing such nodes were grouped together in the diagram and the edges entering or leaving this group were understood to imply individual edges to each node in the group. Note that since these groups of nodes had to have identical neighbor sets there could not be any internal structure within the group (apart from cliques with common external neighbors which is an easily detectable special case). As we shall see in Section 3, this significantly limits the degree of edge compression that can be achieved in practice.</p><p>This simple edge compression technique has probably been reinvented many times. For example, Dinkla et al. <ref type="bibr" target="#b7">[9]</ref> used a similar technique for grouping nodes with identical neighbor sets to produce compacted matrix representations of biological graphs.</p><p>The edge compression technique used in <ref type="figure">Fig. 2(c)</ref> is called a Modular Decomposition. A modular decomposition identifies groups or modules of nodes that have identical external connections. This definition of a module places no restrictions on the connectivity structure within the module. Therefore, modules may have internal edges and the decomposition can be applied recursively to obtain nested modules. The modular decomposition of a given graph is unique and it can be found in time linear in the number of nodes and edges <ref type="bibr" target="#b15">[17]</ref>.</p><p>To our knowledge, modular decomposition has not previously been used in graph visualization to avoid drawing the full set of edges. However, it has been used to assist with layout. Papadopoulos and Voglis <ref type="bibr" target="#b19">[21]</ref> used Modular Decomposition as a means of obtaining layout for undirected graphs that considers the module structure. They used a force-directed technique to keep nodes in the same module physically close together. However, their final rendering was a typical node-link drawing with all edges present. An earlier layout method that employed similar ideas for drawing directed graphs was by Mc-Creary et al. <ref type="bibr" target="#b16">[18]</ref>. They looked for an alternative to the most commonly used hierarchical graph drawing technique using a so-called Clan decomposition. Similar to <ref type="bibr" target="#b19">[21]</ref>, they used a decomposition to achieve a more structured layout, but they still drew the full set of edges.</p><p>Modular Decomposition should not be confused with maximal modularity clustering <ref type="bibr" target="#b18">[20]</ref>. The latter can be seen as another lossy compression technique. It attempts to group a graph into communities/groups/clusters/modules with minimal links between them compared to a random graph with similar degree distribution. Modularity maximization is NP-hard <ref type="bibr" target="#b6">[8]</ref> and the optimal partitioning is not necessarily unique.</p><p>Power graphs were recently introduced by Royer et al. <ref type="bibr" target="#b21">[23]</ref> for the simplification of dense undirected biological graphs. We describe in the next section how they can be thought of as a relaxation of the constraint in modular decompositions that the aggregate edges do not cross module boundaries. This relaxation allows for potentially much greater compression of edges. We investigate in this paper-for the first time-whether this comes at the expense of more difficult interpretation. Also, their heuristic was designed purely to minimize the number of edges in the decomposed drawing. In this paper we investigate the effect of optimizing other criteria.</p><p>To our knowledge none of the above techniques have been evaluated with controlled studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DEFINITIONS AND TECHNIQUES</head><p>We consider three different edge compression techniques: matching neighbors as per <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b7">9]</ref>; modular decomposition and Power Graph Analysis. In all cases we apply these techniques to a graph G = (V, E) with node set V and directed edges E. A node </p><formula xml:id="formula_0">v โ V has incoming neighbors N โ (v) = {u | โ(u, v) โ E} and outgoing neighbors N + (v) = {w | โ(v, w) โ E}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Matching Neighbors.</head><p>The simplest definition for a module that provides a useful edge compression is that all nodes in a module must have identical neighbor sets. That is, two nodes u and v are grouped if N</p><formula xml:id="formula_1">+ (u) = N + (v) and N โ (u) = N โ (v)</formula><p>. This allows for grouping of the leaves of stars (e.g. <ref type="figure" target="#fig_1">Fig. 3(a-b)</ref>) or for k-partite components into k modules.</p><p>Further compression is possible by relaxing the definition further to allow cliques with identical external neighbors to also be grouped into modules <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b7">9]</ref>, as in <ref type="figure" target="#fig_1">Fig. 3(c-d)</ref>. That is, in addition to the above module definition they also allow two nodes u and v to be grouped if Simple matching in this way is trivially computed in linear time by hashing. <ref type="figure" target="#fig_0">Fig. 1(b)</ref> gives a non-trivial example of matching neighbors. For a given graph, the neighbor matching is unique.</p><formula xml:id="formula_2">u โ N + (v), v โ N + (u), N + (u) \ {v} = N + (v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Modular Decomposition.</head><p>The rules described above for matching neighbors do not allow for internal structure within modules: the nodes inside each module are either not connected to any other nodes in the module, or they are connected to every other node in the module. Modular decomposition relaxes this definition. Thus, a set of nodes M โ V is a module in a modular decomposition, if for every pair of nodes u,</p><formula xml:id="formula_3">v โ M, N + (u) \ M = N + (v) \ M and N โ (u) \ M = N โ (v) \ M.</formula><p>This definition allows for internal structure within modules, and therefore the possibility that the decomposition can be applied recursively to obtain nested modules. Examples of modular decomposition are given in Figures 1(c) and 2(c). Note that matching neighbor sets are subsumed by modules, so Figures 3(b) and (d) also happen to be modular decompositions.</p><p>The first polynomial-time algorithm for modular decomposition is due to James et al. <ref type="bibr" target="#b14">[16]</ref>. Methods that require linear time in the number of nodes and edges exist for directed graphs <ref type="bibr" target="#b15">[17]</ref> but they are subtle and difficult to implement. The figures in this paper were generated with an O |V | 2 method due to Ehrenfeucht et al. <ref type="bibr" target="#b9">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Power Graph Analysis.</head><p>Note that in all of the above definitions for modules, edges in the decomposition and hence the drawing, never cross module boundaries. <ref type="figure" target="#fig_0">Fig. 1</ref> shows that greater edge compression can be achieved if the definition of a module is relaxed to allow edges to cross module boundaries. However, now there are many possible choices for how to decompose the graph in order to compress edges. Royer et al. <ref type="bibr" target="#b21">[23]</ref> very briefly described a simple greedy heuristic for performing this so called power graph analysis for undirected graphs.</p><p>They begin by computing a similarity coefficient for all pairs of nodes based on their neighbor sets. Then they apply a hierarchical clustering of the nodes based on this similarity. Every cluster in the resulting hierarchy is considered as a candidate module.</p><p>The second part of the heuristic involves calculating, for each candidate module, the number of edges that could be removed were the module to be created. In a greedy fashion, they then create the module that allows the most edges to be removed and repeat until no further improvement is possible.</p><p>We consider Power Graph Analysis in more detail in ยง5. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONTROLLED EXPERIMENT 1</head><p>To assess the readability of diagrams produced by edge compression techniques compared to flat node-link diagrams, we performed a controlled experiment involving 15 human subjects. To evaluate the learnability of these techniques, we recruited participants with extremely low (or nonexistent) knowledge in graph theory. None of these participants were programmers and none used graph diagrams in their daily activities. We performed a within-subject experimental design: 3 Techniques ร 3 Difficulties ร 6 Repeats.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Techniques</head><p>In this initial experiment, we compared flat node-link diagrams (our control condition) to the matching neighbors and modular decomposition techniques described earlier. We did not include the power graph technique in this study to keep it to a reasonable time and limit our participants' fatigue. We conjectured that power graphs would require the most training and possibly feature concepts that a naรฏve audience may not successfully grasp. Therefore, we decided to first evaluate the simplest of our edge-compression techniques. Layout of the graphs used in the study was accomplished by constrained-force directed layout <ref type="bibr" target="#b8">[10]</ref>. We also made some manual fine adjustments to resolve obvious layout issues and maximize readability. It is important that all edges are at least visible and distinguishable from other edges along their entire span and that they do not cross node or module boundaries where it is not necessary to do so. The only edge routing methods that we know of that are capable of doing this are orthogonal routing, such as <ref type="bibr" target="#b23">[25]</ref> and the "ordered bundling" edge routing method proposed by Pupyrev et al. <ref type="bibr" target="#b20">[22]</ref>. Since orthogonal routing introduces right-angled bends which may make them difficult to follow, we use the technique of Pupyrev et al. for all the examples in this paper and for the renderings generated for the study. The DGML graphs used (viewable in Visual Studio 2012 Pro) and the images generated for the study are available from our online repository <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Difficulties</head><p>We generated synthetic graphs to ensure equivalent graph structures. In particular we wanted diagrams where we could control the number of nodes and the number of modules when the various techniques were applied. To achieve this we created the desired number of nodes and from this node set we randomly selected subsets of limited size to be modules. We then randomly picked pairs of modules to be linked by creating edges for the Cartesian product of their members. We applied this process recursively until the desired density or nesting level was achieved. The maximum module size and the probability of linking modules also controlled the density. The properties of each graph used are shown in <ref type="table" target="#tab_0">Table 1</ref>. The graph Easy3 is shown in <ref type="figure" target="#fig_0">Fig. 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Task</head><p>We hypothesized that, since our representation was replacing a set of links by a different shape, a connectivity task in which participants have to count or follow links would be most affected. Thus, we selected a shortest path task, in which participants had to count the smallest number of links to go from a node labeled "Start" to a node labeled "End". Path length varied up to 4 links. In some cases no path existed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Participants and apparatus</head><p>We recruited 15 participants (7 males and 8 females). The age of our participants ranged between 24 and 39 years (mean 31.4). The participant pool excluded programmers and participants with graph theory background. We also screened for participants with normal or corrected-to-normal vision, none being color-blind. The experimenter ran 1.5 hour sessions with two participants at a time. Each participant completed the experiment on an individual PC, using a 19-inch monitor with a resolution of 1280 by 1024.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Procedure</head><p>Training. Since our participants were not familiar with graph theory concepts, we decided to train them before each technique and consider the training successful when they could answer correctly each of the 12 training trials. The experimenter first instructed them on how to read the type of diagram using a printed version and illustrating the diagram "rules" with examples of the shortest-path task. Training both participants at the same time was beneficial as it fostered discussion and encouraged them to ask many questions. After this general training the experimenter demonstrated the experimental interface and asked participants to answer the 12 training trials individually, pausing after each trial. These trials were designed to cover all principles of readability and included task instances considered most error-prone. Overall training for the three techniques lasted up to 20 minutes. The experimenter noted that the modular decomposition technique, if taught first, led to a longer training. The most challenging concept to acquire with this technique concerned the different levels of nesting. Experiment. We counterbalanced the order of visualization techniques across participants. We fixed the order of the datasets from low to high difficulties. For the repetitions within the same difficulty, we created isomorphic questions by either selecting different sets of sources and destinations or using a graph with similar properties. Graphs and tasks were repeated across techniques with scrambled labels. The visual representations obtained were also strikingly different as the different number of edges and the groupings led to very different layout and edge routing configurations.</p><p>The experiment software displayed the task as well as multiple choice answers and recorded accuracy and time taken for each answer. The software first displayed the question without any visualization. Once participants read the text and were ready to answer the question, they clicked a button to view the corresponding visual. Participants pressed space bar once they found the answer. At this point, the visual was removed and the timer stopped. Participants entered their answer and reached the next question. They were instructed to rest if needed between questions and to answer questions as accurately and as fast as they could. To keep the study at a reasonable length, we limited each question to a maximum of 60 seconds. Finally, after the experiment, we collected user preferences and comments using a printed questionnaire. The study lasted approximately 60 minutes including training and post-experimental questionnaire.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Hypotheses</head><p>We formed the following hypotheses: (H1) Since link clutter is a key factor affecting the readability of nodelink diagrams, we hypothesized that modular decomposition would perform best across all difficulties, followed by matching neighbors, followed by node-link diagrams. (H2) Modular decomposition will yield more accurate and faster results than the other two techniques for difficult datasets since these benefit most from the removal of links. (H3) Node-link diagrams will yield more accurate results than the other two techniques in easy datasets since they are familiar to a wide audience. However, they will not yield faster results than the other two techniques for correct trials since they require following many more links than in the other two representations. (H4) Since node-link diagrams are cluttered and modular decomposition requires learning, we hypothesized that the matching neighbors technique will be preferred by participants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Results</head><p>We excluded one participant from our analysis since his mean accuracy (59%) was lower by more than three standard deviations compared to the mean accuracy of the remaining 14 participants (88%). However, this participant did not fail the training and his mean accuracy was much lower with node-link diagrams (39%) than with the edge compression techniques (about 60%). Accuracy. Since accuracy does not follow a normal distribution, we used Friedman's non-parametric test. Friedman's did not reveal any overall significant difference between techniques in terms of accuracy. Participants were about 85% to 90% accurate with all techniques <ref type="figure" target="#fig_3">(Fig. 4)</ref>. When splitting results by difficulty, we were surprised that Friedman's test did not reveal any significant difference between techniques either in difficult (H2) or easy (H3) datasets. Completion time. We analyzed the completion time for correct trials with a Mixed Linear Model (MLM) capable of handling missing values. We excluded about 12% incorrect trials. Since the distribution was skewed, we used the logarithm of the completion time as is common practice. MLM revealed a significant effect of Technique (F 2,26 = 65.10, p &lt; .0001) and Difficulty (F 2,26 = 33.32, p &lt; .0001). Pairwise comparisons revealed that modular decomposition is 17% faster than matching neighbors (p &lt; .0001), 36% faster than nodelink (p &lt; .0001) and matching neighbors is 23% faster than node-link across all difficulties <ref type="figure" target="#fig_3">(Fig. 4)</ref>. These results confirm our hypothesis (H1): for correct trials, modular decomposition performs fastest, followed by matching neighbors, followed by our node-link control condition. When splitting results by difficulty, one can observe the same trend in all difficulties <ref type="figure" target="#fig_3">(Fig. 4)</ref>. Pairwise comparisons revealed that node-link is significantly slower than the two other techniques in all three difficulties (p &lt; .001). However, pairwise comparisons revealed that modular decomposition significantly outperforms matching neighbors for only the medium difficulty (p &lt; .0001). User Preferences. A questionnaire gathered user preferences using 5-point Likert scales. Since these results do not follow a normal distribution, we analyzed user preferences ratings using Friedman's nonparametric test. Friedman's test reveals significant difference for all questions <ref type="figure" target="#fig_3">(Fig. 4)</ref>. As expected (H4), modular decomposition was found to be significantly harder to learn than the other two techniques (p &lt; .05) and, despite their faster completion time, participants reported being less confident about their answers with this technique (p &lt; .01). Node-link was also reported to be significantly more cluttered than the other two techniques (p &lt; .01). Overall, the user ranking of the techniques revealed a significant preference of the matching neighbors technique over the modular decomposition technique (p &lt; .01).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Discussion</head><p>We had hypothesized that while modular decomposition would yield more accurate results for difficult (denser) graphs, the technique might prove less effective than node-link diagrams for easy (sparser) ones. Surprisingly, our experimental results did not show any significant differences between techniques in terms of accuracy for either easy or difficult datasets. However, our results on completion time indicate that edge compression techniques provide significant advantages over  <ref type="table" target="#tab_0">Easy1  7  16  1  12  2  9  1  Easy2  7  19  1  14  2  11  0  Easy3  7  23  1  18  3  9  1  Medium1  10  22  2  13  4  6  0  Medium2  10  40  3  21  5  8  1  Medium3  10  34  2  12  3  7  0  Difficult1  15  44  4  29  5  15  2  Difficult2  15  42  4  34  5  17  1  Difficult3  15  66  2  55  6  12  2</ref> standard node-link representations. In particular, modular decomposition outperforms the other two techniques, increasing the speed of answer by 36% on average compared to the control condition. These results clearly demonstrate the power of edge-compression techniques and suggest a clear benefit of these techniques for the representation of directed graphs. Despite these potential benefits we had strong beliefs that the edge compression techniques (especially the modular decomposition exhibiting multiple levels of nesting) would prove difficult to learn by a naรฏve audience. While the difficulty of learning these techniques was reflected in the user ratings and overall ranking preference, we were extremely surprised that all of our participants with low expertise in graph theory could successfully learn to decode these techniques in a short amount of time (15 to 20 minutes of training overall).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">MORE SOPHISTICATED DECOMPOSITIONS</head><p>Thus, we see that for dense directed graphs people are able to usefully interpret aggregate edges. Furthermore, we see that the greater edge reduction provided by modular decomposition provides significant performance advantages over exact-neighbor matching or flat node-link diagrams. A natural question to ask is whether the pattern continues for power graphs, despite the additional complexity of edges crossing module boundaries. In order to answer this question we need to know how to compute the power-graph decomposition.</p><p>Computing power-graph decompositions is significantly harder than computing the graph's modular decomposition. In fact we conjecture that it is NP-hard since it appears to rely in the worst case on evaluating an exponential number of possible module choices. Unlike the modular decomposition the best power-graph decomposition is not unique. Furthermore, it is not clear what exactly we want to optimize. The obvious quantity to minimize is the number of edges in the power graph, however-as we see in <ref type="figure" target="#fig_8">Fig. 5</ref>-minimizing edges alone may lead to diagrams in which modules are highly nested and edges cross many module boundaries. We might also want to trade-off the number of modules.</p><p>As described in ยง3, Royer et al. <ref type="bibr" target="#b21">[23]</ref> give a greedy heuristic for computing a power-graph decomposition which minimizes the number of edges. However, we do not know how effective this heuristic is or even if this is the correct feature to minimize. In order to answer these questions we used a methodology that to the best of our knowledge has not previously been used in visualization research. Our approach was to use a high-level modelling language to declaratively specify the properties we want in a good layout, including a precisely defined objective function, and then use Constraint Programming (CP) to find a provably optimal solution. The use of a high-level modelling language allowed us to quickly experiment with different aesthetic choices and the use of a provably optimal solving technique meant that differences in layout were a result of the aesthetic criteria not of vagaries of the solving heuristic.</p><p>Note that we are not (yet) advocating these optimal techniques as a practical solution for generating power graphs, especially for interactive systems. Finding the optimum takes too long and we are limited to relatively small graphs. However, it is very useful as a way to explore the parameter space for the goal function. Particularly in combination with controlled studies to evaluate the different optimal solutions, we believe this is a powerful methodology that allows us to separate algorithm engineering from discovering the true requirements for useful visualizations. Once those requirements are understood, our intention is to design practical heuristics that give output that is closer to optimal than that of current heuristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Computing the Optimal Power-Graph Decomposition</head><p>In this section we describe the high-level model we used to compute the optimal power-graph decomposition and how we implemented it in MiniZinc <ref type="bibr" target="#b17">[19]</ref>. MiniZinc is a relatively new language designed to allow high-level solver independent modelling of constrained optimization problems. Like other mathematical modelling languages, a MiniZinc model contains input parameters whose value is given in an input file, decision variables whose values are computed by an underlying constraint solver, high-level constraints and an objective function to be minimized or maximized.</p><p>The input to our problem is the number of vertices nv and a Boolean array edge where edge <ref type="bibr">[u, v]</ref> iff there is an edge from vertex u to v. The main decision variables in the problem are the number of modules anm and the vertices in each module. We model this in our MiniZinc model by an array of Boolean decision variables where module[v, m] will be set to true iff vertex v is in module m. A MiniZinc model does not specify how to compute the value of the decision variables, rather the model places constraints on the values the variables can take and it is the job of the underlying constraint solver to compute the values.</p><p>We require that the modules form a hierarchy: one way of stating this is that for all modules m and n, m โ n โจ n โ m โจ m โฉ n = / 0. Note that the hierarchy requirement means that we can restrict anm โค nv. The MiniZinc code to ensure the modules form a hierarchy is simply: Note that the above constraints make use of the Boolean array mcontains[m, n] which is constrained to hold if module m contains module n.</p><p>For any fixed choice of modules there is a unique best choice of edges in the power graph. To simplify the representation of power graph edges in the model we add a singleton "trivial" module {v} for each vertex v:</p><formula xml:id="formula_4">constraint forall (v in vertices)(module[v,v] /\ forall(u in vertices where u != v)(not module[u,v]));</formula><p>This means that the edges in the power graph are all pairs of modules (m, n).</p><p>We first compute for each pair of nodes m and n if there is a possible edge between them. There is a possible edge between m and n iff: <ref type="bibr" target="#b0">(1)</ref> for all u โ m and for all v โ n, (u, v) โ E, and (2) m = n or m โฉ n = / 0. The first condition ensures the edge is semantically correct while the second condition disallows edges between ancestors or descendants in the hierarchy.</p><p>We now compute the actual edges in the power graph. This is any possible edge (m, n) which is not dominated by some other possible edge (m , n ) where (m , n ) dominates (m, n) if m โ m and n โ n . The intuition is that we choose the edges as high up in the module hierarchy as possible.</p><p>The MiniZinc constraints that encode this computation are as follows.  The final piece of the puzzle is the objective function which we wish to minimize. This is specified in our MiniZinc model by solve minimize numbermodules + edgeweight * numberedges + crossingweight * numbercrossings;</p><p>This states that the objective function is the weighted linear sum of the number of modules, number of power graph edges, and the number of edge/module boundary crossings. The weights are input parameters: by changing these in the input file it is simple to explore the layout tradeoff between these features. It is also simple to add other features that we wish to explore to the objective function.</p><p>We must also add constraints to ensure that the decision variables numberedges, numbermodules and numbercrossings are correctly computed. The following MiniZinc assignment statements do this for edges and modules: The number of edge crossings is a little trickier: to help we compute the array of integer decision variables, mcrossings[m, n], which gives the number of module boundaries that must be crossed to get from module m to module n. This is simply the number of modules p that contain either m or n but not both. Running Time As one might expect this model is quite slow even with the cpx solver (which is one of the fastest solvers supporting MiniZinc). We improved efficiency by adding a number of redundant constraints and constraints to remove symmetric solutions. While the model is still too slow for real-world layout it can compute optimal power-graph decompositions for graphs with 10-15 nodes, allowing us to determine a ground truth corpus for evaluating heuristic techniques and also to generate layouts for exploring the tradeoffs between different layout features. Interestingly, the running time is not necessarily strongly tied to the number of nodes or edges, rather it is related to the number of modules in the optimal solution. Instances with only a couple of modules in the optimal solution are generally solvable in several minutes on a standard 2013 PC 1 while, for example, Difficult3 Non-Modular with 7 modules took over 8 hours. Note also, that often the optimal solution is found relatively quickly (e.g. in the first half of the total running time) but significantly more time is required to prove optimality. By contrast the heuristic described in ยง3.3 is O(|V | 2 log |E|) with efficient set comparison techniques and runs in under a second on all of our test graphs. The decomposition of a graph with |V | = 140 and |E| = 406 shown in <ref type="figure">Fig. 9</ref> took 39 seconds on the same hardware. An optimal compression of such a large graph is not practical with current technology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">COMPRESSED GRAPH CORPUS</head><p>To evaluate the amount of compression gained by the optimal decompositions over the power-graph heuristic we prepared a corpus of 28 dense graphs.</p><p>We prepared eight graphs for our second study, based on the medium and difficult graphs used in the first study. The idea of reusing graphs is to provide continuity between studies. Two of them (Difficult Modular) are unmodified from the first study, and so permit a modular decomposition. The rest have been made more dense-and so more interesting for power graph analysis-by randomly adding edges until a modular decomposition is no longer possible. They have 10 (Medium Non-Modular) or 15 (Difficult Non-Modular) nodes and between 24 and 70 edges.</p><p>In addition we generated a set of twenty random scale-free graphs. These were generated following the model of Bollobรกs et al. <ref type="bibr" target="#b5">[7]</ref> which has been shown to construct organic looking graphs with similar structure to those found in biological systems and complex evolving artifacts like the web. We modified the model to eliminate self-loops and multiple edges by simply discarding any such edges. Also, we limited the size of the generated graph to n nodes by stopping the algorithm immediately before the (n + 1) th node would be added.</p><p>The Bollobรกs et al. model has five parameters. At each discrete time step, the graph grows in one of three ways: (a) a new node with a single outgoing edge is added, (b) a new edge between existing nodes is added, or (c) a new node with a single incoming edge is added. The parameters ฮฑ, ฮฒ and ฮณ are the respective probabilities of each possibility. When choosing a destination for the edge in (a) or (b), the choice is weighted towards nodes that have a high in-degree, and when choosing an origin for the edge in (b) or (c), the choice is weighted towards nodes that have a high out-degree. The weighting is influenced by parameters ฮด in and ฮด out , where higher values of the parameters give less weight to the existing in-and out-degrees.</p><p>To generate our corpus of graphs, we used a node limit of 10. After some experimentation we found that the parameters ฮฑ = ฮณ = 1 42 , ฮฒ = 40 42 , and ฮด in = ฮด out = 1 generated graphs with a good distribution of edge densities, between 26 and 60 edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EFFECTIVENESS OF COMPRESSION</head><p>We then ran our MiniZinc solver on each of these 28 graphs, with three different settings for the crossing-weight parameter in the objective function, to find a total of 84 graph decompositions that are optimal with respect to the given goal function. This graph corpus and their optimal decompositions are available online <ref type="bibr" target="#b2">[3]</ref> and constitute a first benchmark useful for further evaluations by the research community. The crossing weights used were 2000, 500 and 1 while the edge weight was kept fixed at 1000. We obtained 84 more decompositions using the greedy power-graph heuristic to obtain approximate solutions, also varying the crossing-weight used to decide when to create a module in the heuristic's cost function. An example set of results for one graph is given in <ref type="figure" target="#fig_8">Fig. 5</ref>. We found that with crossing weight of 2000 the optimal solution was exactly the modular decomposition on our two modular graphs. On the denser modular graph the heuristic failed to find one of the modules.</p><p>It is interesting to compare the cost as computed by the objective function for the optimal versus approximate solutions. In <ref type="figure" target="#fig_9">Fig. 6</ref> we compare the ratio of optimal cost to heuristic cost against the number of modules in the optimal solution. The heuristic does well with very few modules but deteriorates as this number increases. A ratio of 0.7 means a difference of dozens of edges or crossings depending on the objective function. We see in <ref type="figure" target="#fig_8">Fig. 5</ref> that this makes a significant difference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONTROLLED EXPERIMENT 2</head><p>Our first experiment revealed that participants could successfully learn a complex edge-compression technique involving several levels of nesting and significantly increase their performances for shortest path tasks. Yet, as described in ยง5 we can go further by allowing edges to cross module boundaries. Our next study investigates how different degrees of compression affect readability. This second controlled experiment involved 14 human subjects, again with extremely low or no knowledge in graph theory. None of these participants were involved in the first study and none used graph diagrams in their daily activities. We used a within-subject experimental design: 3 Edge compression levels ร 3 Difficulties ร 6 Repeats.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Degree of edge crossing</head><p>We believe that the number of edges crossing module boundaries is the factor that most impacts the readability of power graphs. Therefore, we selected three conditions with low, medium and high numbers of cross-boundary edges. These correspond to the optimal solutions obtained with crossingweight = 2000, 500, 1 respectively, used in the objective function of our power graph model as described in ยง7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Difficulties and Task</head><p>We chose graphs intended to provide three difficulty levels: Difficult Modular were the unmodified difficult graphs from Study 1; Medium Non-Modular and Difficult Non-Modular were modified from Study 1 as described in ยง6 so that they no longer afford a modular decomposition. That is, it is no longer possible to compress these latter graphs without creating crossings between edges and module boundaries. Medium Non-Modular graphs look similar to <ref type="figure" target="#fig_8">Fig. 5</ref>. We selected the same shortest path task as in study 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Participants and apparatus</head><p>We recruited 14 participants (7 males and 7 females). The age of our participants ranged between 20 and 38 years (mean 29.4). The participant pool excluded participants of the first study, programmers and participants with graph theory background. We also screened for participants with normal or corrected-to-normal vision, none being colorblind. The experimenter ran 1.5 hour sessions with two participants at a time using the same apparatus as experiment 1.</p><p>Layout was as described in the first study although the visuals became more polished, following recommendations for directed edge representations from Holten et al. <ref type="bibr" target="#b12">[14]</ref>. Again all materials are available <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Procedure</head><p>Training. Since our participants used the same technique (with different levels of crossings), we only trained them at the beginning of the experiment. The experimenter followed the same training protocol as in the first study. Overall training for the technique lasted 15 minutes on average. The experimenter noted that the most challenging concepts to acquire were the different levels of nesting and edges crossing boundaries. Experiment. We counterbalanced the order of the degree of crossing across participants. We fixed the order of the datasets from low to high difficulties. For the repetitions within the same difficulty, we created isomorphic questions by either selecting different sets of sources and destinations or using a graph with similar properties. Each level of compression displayed the same exact graphs and tasks. Similar to the first study, the visual representations obtained had very different layouts and edge routing configurations and we randomized labels in all diagrams to avoid memorization.</p><p>We used the same experimental software as in the first study. After the experiment, the experimenter briefly interviewed participants on what they found most difficult or confusing in these diagrams. The study lasted approximately 60 minutes including training and postexperimental interview.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Hypotheses</head><p>We hypothesized (H5) that a medium degree of cross-boundary edges-as a compromise between compression and complexitywould give best performance. We further hypothesized (H6) that the highest degree of cross-boundary edges would prove too complex to read for a naive audience, thus yielding less accurate and slower results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Results</head><p>Accuracy. Since the accuracy does not follow a normal distribution, we used Friedman's non-parametric test. Friedman's test reveals an overall significant difference in accuracy between techniques (p &lt; .0001). Pairwise comparisons using the Wilcoxon's test showed that the high level of cross-boundary edges leads to more errors than the other two conditions (p &lt; .0001), verifying (H6). Participants were only 66% accurate in this condition contrasting with the 84% and 85% mean accuracies for the low and medium crossing levels <ref type="figure" target="#fig_10">(Fig. 7)</ref>. When splitting results by difficulty, Friedman's and Wilcoxon's tests reveal the same trend for Difficult Modular (p &lt; .0001) and Medium Non-Modular (p &lt; .0001) graphs: a high degree of crossings yields more errors than the other two conditions. However, there is no significant difference between crossing degree for the most difficult case. Completion time. We analyzed the completion time for correct trials with a Mixed Linear Model (MLM) capable of handling missing values. We excluded 22% incorrect trials. Since the distribution was skewed, we used the logarithm of the completion time as is common practice. MLM revealed a significant effect of degree of crossing (F 2,26 = 5.77, p &lt; .01) and Difficulty (F 2,26 = 3.61, p &lt; .05). Pairwise comparisons revealed that overall, the medium degree of crossing outperforms the high one (p &lt; .0001) <ref type="figure" target="#fig_10">(Fig. 7)</ref>.</p><p>When splitting by difficulty, one can observe different trends for each type of dataset <ref type="figure" target="#fig_10">(Fig. 7)</ref>. It is interesting to note that in the modular datasets, a low degree of crossing equates to the modular decomposition technique. Our results indicate that participants can handle a moderate number of edges crossing module boundaries (H5) as low and medium level do not yield significantly different times but both prove significantly faster than the high degree of crossing (p &lt; .05). For the non-modular datasets, the medium degree of crossing leads to faster completion time than the other two techniques for the medium graphs (p &lt; .01) but there is no significant difference for the difficult graphs. These results may imply that as the graph gets denser (and thus requires more time for finding a shortest path between two nodes), the degree of crossing does not have a noticeable impact on the completion time anymore. User comments. After the timed trials, the experimenter collected comments about the difficult or confusing aspects of these diagrams. The experimenter did not prompt participants with particular aspects but rather collected spontaneous reactions of the participants. We categorized the difficult aspects described by our participants into two major areas: cross-boundary edges and nesting. Nine out of 14 participants commented that the cross-boundary edges (especially from a node inside a module to a different module) were the most difficult aspect of these diagrams. Five participants explicitly said that these were (b) A compressed version (using the heuristic described in ยง3.3) has 17 modules, reducing the visible edge count to 208. Obviously, at this scale individual edges are difficult to follow, yet the groupings are also interesting since they show the members that are accessed together. <ref type="figure">Fig. 9</ref>. A mapping of the reference graph for five classes (blue nodes) and their members from the Json.NET library <ref type="bibr" target="#b1">[2]</ref>.</p><p>the most likely cause of their errors. Four of our 14 participants identified nesting as causing them problems; three of these did not mention the cross-boundary edges at all. Finally, one participant commented that, at first, the most confusing aspect of these diagrams was the affordance of the visual grouping into modules. He explained that such grouping naturally conveyed to him that nodes within a module are directly connected (clique). While training helped, he struggled against this instinctive decoding of the diagram throughout the trials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">DISCUSSION</head><p>Our first study revealed that edge compression through modules does significantly improve response times in path following tasks once the reader has understood the concept of inferred edges. While this concept is not immediately intuited by most novices, 10-15 minutes of training seems adequate to make most of them proficient. Our second study showed that allowing some cross-module edges (and hence allowing compression of graphs that do not permit a modular decomposition) is still readable though compression methods should apply a penalty to cross-edges. Our medium crossing condition (edgeweight = 1000, crossingweight = 500) seems to offer the best compromise in most graphs.</p><p>To qualify, however, our results regarding cross-edges did vary in different graphs. To demonstrate why certain graphs and path follow-ing tasks can be particularly hard we give a final small example. <ref type="figure" target="#fig_11">Fig. 8</ref> is a task used in training that requires both following cross-module edges and unrolling nested modules. Scope and Limitations. This paper focuses on directed graphs instead of general undirected graphs for several reasons: -There are many applications that interest us where the directionality of edges is very important.</p><p>-As already mentioned, the problem of edge density is potentially much greater for directed graphs.</p><p>-The Power Graph Analysis technique has not previously been considered for directed graphs.</p><p>-Greater care must be taken with the visual representation to ensure edge direction is clearly readable.</p><p>We limit the evaluations in this paper to graphs with relatively few nodes, again for multiple reasons: -In our trial runs for the first study we began by considering larger graphs (up to 30 nodes), however the participants were overwhelmed and the flat graphs were completely unreadable. Even at 13 nodes, <ref type="figure">Fig. 2(a)</ref> is becoming overwhelming.</p><p>-There is no doubt that practical applications require analysis of large graphs, yet small graph visualization is still applicable for detailed examination of a neighborhood or viewing at a high level of abstraction. For example, the graph in <ref type="figure">Fig. 2</ref> is only the top-level semantic grouping of a graph with hundreds of thousands of nodes.</p><p>-For smaller graphs it is possible to determine optimal decompositions which affords precise evaluation as described above.</p><p>-Our feeling after completing the studies, is that the difficulty in performing path following tasks has less to do with the number of nodes but everything to do with the complexity of path in terms of whether it crosses module boundaries or requires the reader to mentally unroll nested modules, ยง8.</p><p>Still, scalability to larger instances is essential future work. In <ref type="figure">Fig. 9</ref> we show heuristic compression of a graph with 140 nodes and 406 edges to demonstrate that-even though individual edges are no longer easily traceable without interaction-compression still results in a significantly less cluttered visualization and there is utility in simply obtaining layout that respects the modules. In this software dependency graph, the modules themselves are also meaningful in that they group class members that are accessed together. Further refinement of the algorithmics, visual design and interaction to such larger examples is interesting, but beyond the scope of this paper. Future Work. There are many directions for future work. We are developing a Visual Studio extension for producing "Poster Views" of code dependencies as in <ref type="figure">Fig. 2(c)</ref>. This extension and the source code for all the techniques described are available <ref type="bibr" target="#b0">[1]</ref>. We make our corpus of test graphs and optimal power-graph solutions available in the same repository as detailed in <ref type="bibr" target="#b2">[3]</ref>. These optimal solutions represent hundreds of hours of processing time and should be a valuable resource for both those interested in performing experiments on different representations and algorithms engineers interested in developing more optimal heuristics. For those interested in experimenting with different goal functions or different input graphs our MiniZinc model is also available.</p><p>We find this methodology of using constraint programming to declaratively model and optimally solve small instances of difficult graph visualization problems compelling, as it avoids the shortcomings of heuristics in the exploration of the design space. We hope to investigate this approach further in different areas such as layout.</p><p>Regarding power graphs generally, there is much work to be done: as demonstrated in ยง7 we need more optimal heuristics; we need stable techniques for dynamic graphs; we need to extend to graphs with multiple edge types and attributed edges. Another popular technique for removing clutter in dense graphs is edge bundling, e.g. <ref type="bibr" target="#b13">[15]</ref>. However, usually groups of edges are bundled based on spatial locality. When the edges in such a bundling run concurrently this is effectively a lossy compression as exact connectivity is no longer discernible. An obvious alternative which would not result in this ambiguity is to bundle edges based on the decompositions described in this paper.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Different edge-compression techniques applied to the same small graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>The simplest Matching Neighbors compression allows for leaves of "star graphs" (a) to be collapsed into a module (b). A simple extended matching allows for cliques as in (c) to also be grouped (d). In (d) the edges in the clique module are removed and implied by a self-loop: an arrow from the module to itself.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>) \ {u} and the same is true for the incoming neighbor sets of u and v.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Experimental results: accuracy, time, time split by dataset difficulty and user ratings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>constraint forall(m in modules,n in modules)(mcontains[m,n]= forall(v in vertices)(module[v,n] -&gt; module[v,m])); constraint forall(m in modules, n in modules where m != n) (mcontains[m,n] \/ mcontains[n,m] \/ forall(v in vertices)(not module[v,n] \/ not module[v,m]));</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>They make use of the arrays of Boolean decision variables: pmvedge[m, v] iff โ a possible edge from module m to vertex v; pvmedge[m, v] iff โ a possible edge from vertex v to module m; ppgedge[m, n] iff โ a possible edge from module m to n; and apgedge[m, n] iff โ an actual edge from module m to n: constraint forall(m in modules, v in vertices)(pmvedge[m,v]= forall(u in vertices)(module[u,m]-&gt;edge[u,v])); constraint forall(v in vertices, m in modules)(pvmedge[v,m]= forall(u in vertices)(module[u,m]-&gt;edge[v,u])); constraint forall(m,n in modules)(ppgedge[m,n] = (forall(v in vertices)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>numbermodules=anm-nv; numberedges=sum(m,n in modules)(bool2int(apgedge[m,n]));</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>constraint forall(m,n in modules)( mcrossings[m,n] = sum(p in modules)( bool2int(mcontains[p,m] xor mcontains[p,n]))); numbercrossings=sum(m,n in modules)( bool2int(apgedge[m,n]) * mcrossings[m,n]);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 .</head><label>5</label><figDesc>A small but dense scale-free graph and the results of optimal and heuristic power-graph decomposition for various crossing-penalties. In all cases the edge-weight was kept fixed at 1000.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 .</head><label>6</label><figDesc>The optimal/heuristic cost ratio broken down by number of modules in the optimal solution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 7 .</head><label>7</label><figDesc>Experimental results: accuracy, time and time split by dataset difficulty.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 .</head><label>8</label><figDesc>A fiendishly tricky task used in training for the second study. The shortest paths are 4 steps: e.g. StartโDโGโIโEnd.(a) Flat graph with 140 nodes and 406 links.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Graphs used in study 1 and their properties for each technique, where: |V | = number of nodes, |E| = number of visible edges, m = number of modules, nl = nesting level.</figDesc><table><row><cell></cell><cell cols="2">Node Link</cell><cell cols="2">Matching Neighbors</cell><cell cols="3">Modular Decomposition</cell></row><row><cell>Graph</cell><cell>|V |</cell><cell>|E|</cell><cell>m</cell><cell>|E|</cell><cell>m</cell><cell>|E|</cell><cell>nl</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1077">-2626/13/$31.00 ยฉ 2013 IEEE Published by the IEEE Computer Society IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 19, NO. 12, DECEMBER 2013</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Intel Ivy Bridge Core i7, up to 2.6GHz</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dgml Posterview</surname></persName>
		</author>
		<ptr target="https://dgmlposterview.codeplex.com" />
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Json</forename></persName>
		</author>
		<ptr target="http://json.codeplex.com" />
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Wiki page with links to our various study materials and optimal compression solution corpus</title>
		<ptr target="https://dgmlposterview.codeplex.com/wikipage?title=Study" />
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Ask-graphview: A large scale graph visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Van Ham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="669" to="676" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The readability of path-preserving clusterings of graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Purchase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pinaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1173" to="1182" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Directed scale-free graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bollobรกs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Borgs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chayes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Riordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fourteenth annual ACM-SIAM symposium on Discrete algorithms, SODA &apos;03</title>
		<meeting>the fourteenth annual ACM-SIAM symposium on Discrete algorithms, SODA &apos;03</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="132" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On finding graph clusterings with maximum modularity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Brandes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Delling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gaertler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gรถrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hoefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Nikoloski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph-Theoretic Concepts in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Compressed adjacency matrices: Untangling gene regulatory networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dinkla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Westenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2457" to="2466" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Layout with circular and other non-linear constraints using procrustes projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Robertson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 18th International Symposium on Graph Drawing (GD&apos;10)</title>
		<meeting>18th International Symposium on Graph Drawing (GD&apos;10)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="volume">5849</biblScope>
			<biblScope unit="page" from="393" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An O n 2 divide-and-conquer algorithm for the prime tree decomposition of two-structures and modular decomposition of graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ehrenfeucht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">N</forename><surname>Gabow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Mcconnell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Sullivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="283" to="294" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Topological fisheye views for visualizing large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="468" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">What&apos;s new in</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heikniemi</surname></persName>
		</author>
		<ptr target="www.heikniemi.net/hardcoded/2011/10/whats-new-in-net-framework-4-5-poster/" />
		<imprint>
			<date type="published" when="2013-03" />
		</imprint>
	</monogr>
	<note>NET framework 4.5? [poster</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An extended evaluation of the readability of tapered, animated, and textured directed-edge representations in node-link graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Holten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Isenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Pacific Visualization Symposium (PacificVis)</title>
		<meeting>the Pacific Visualization Symposium (PacificVis)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="195" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Force-directed edge bundling for graph visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Holten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum</title>
		<imprint>
			<publisher>Wiley Online Library</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="983" to="990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graph decomposition for undirected graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">O</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">G</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Cowan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Southeastern Conference on Combinatorics, Graph Theory, and Computing</title>
		<meeting>the Third Southeastern Conference on Combinatorics, Graph Theory, and Computing</meeting>
		<imprint>
			<date type="published" when="1972" />
			<biblScope unit="page" from="281" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Linear-time modular decomposition of directed graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Mcconnell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>De Montgolfier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">145</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="198" to="209" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using graph parsing for automatic graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Mccreary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">O</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">S</forename><surname>Shieh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transaction son Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="545" to="561" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">MiniZinc: Towards a standard cp modelling language. In Principles and Practice of Constraint Programming-CP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Becket</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Brand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Duck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tack</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="529" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Newman</surname></persName>
		</author>
		<title level="m">Modularity and community structure in networks. Proceedings of the National Academy of Sciences</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">103</biblScope>
			<biblScope unit="page" from="8577" to="8582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Drawing graphs using modular decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Voglis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th international conference on Graph Drawing (GD&apos;05)</title>
		<meeting>the 13th international conference on Graph Drawing (GD&apos;05)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">3843</biblScope>
			<biblScope unit="page" from="343" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Edge routing with ordered bundles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pupyrev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Nachmanson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bereg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Holroyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 19th International Symposium on Graph Drawing (GD&apos;11)</title>
		<meeting>19th International Symposium on Graph Drawing (GD&apos;11)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">7034</biblScope>
			<biblScope unit="page" from="136" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Unraveling protein networks with power graph analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Royer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reimann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Andreopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS computational biology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page">1000108</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Mapping text with phrase nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Van Ham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Viegas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1169" to="1176" />
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Orthogonal connector routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wybrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 17th International Symposium on Graph Drawing (GD&apos;09)</title>
		<meeting>17th International Symposium on Graph Drawing (GD&apos;09)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="volume">5849</biblScope>
			<biblScope unit="page" from="219" to="231" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
