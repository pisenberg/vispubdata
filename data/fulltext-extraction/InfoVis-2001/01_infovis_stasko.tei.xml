<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Technical Note: Visually Encoding Program Test Information to Find Faults in Software</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>October 22 -October 23, 2001</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Eagan</surname></persName>
							<email>eaganj@cc.gatech.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><forename type="middle">Jean</forename><surname>Harrold</surname></persName>
							<email>harrold@cc.gatech.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">A</forename><surname>Jones</surname></persName>
							<email>jjones@cc.gatech.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Stasko</surname></persName>
							<email>stasko@cc.gatech.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">College of Computing / GVU Center</orgName>
								<orgName type="institution">Georgia Institute of Technology Atlanta</orgName>
								<address>
									<postCode>30332-0280</postCode>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">IEEE Symposium on Information Visualization</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Technical Note: Visually Encoding Program Test Information to Find Faults in Software</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published">October 22 -October 23, 2001</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Large test suites are frequently used to evaluate software systems and to locate errors. Unfortunately, this process can generate a huge amount of data that is difficult to interpret manually. We have created a system, TARANTULA , that visually encodes test data to help find program errors. The system uses a principled color mapping to represent how source lines act in passed and failed tests. It also provides a flexible user interface for examining different perspectives that show the behavior of the source code on test sets, ranging from individual tests, to important subsets such as the set of failed tests, to the entire test suite.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Software errors significantly impact software productivity and quality. Attempts to reduce the number of delivered faults are estimated to consume 50% to 80% of the development and maintenance effort <ref type="bibr" target="#b1">[2]</ref>. Debugging is one of the most time-consuming tasks required to reduce the number of delivered faults in a program. Thus, researchers have investigated techniques to assist with debugging (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4]</ref>). However, these techniques often do not scale to large programs or they require extensive manual intervention. This lack of effective techniques hinders the development and maintenance process.</p><p>Studies show that locating the errors <ref type="bibr" target="#b0">1</ref> is the most difficult and time-consuming component of the debugging process (e.g., <ref type="bibr" target="#b4">[5]</ref>). Typically, programmers use debugging tools to manually trace a program, encounter a point of failure, and then backtrack to find related entities and potential causes.</p><p>Although this technique can help programmers locate faults, there are several aspects of the process that can be improved. First, even with source-code debuggers, the man-ual process of identifying the locations of the faults can be very time consuming. A technique that can automate, or partially automate, the process can provide significant savings. Second, because these tools lead developers to focus their attention locally instead of providing a global view of the software, interacting faults are difficult to detect. An approach that provides a developer with a global view of the software, while still giving access to the local view, can provide the developer with more useful information. Third, the tools use results of only one execution of the program instead of using information provided by many executions of the program. A tool that provides information about many executions of the program lets the developer understand more complex relationships in the system. However, with large programs and large test suites, the huge amount of data produced by such an approach, if reported in a textual form, may be difficult to interpret.</p><p>We are using information visualization techniques, together with data from program testing, to help software developers and maintainers locate faults in their code. Our techniques are more global in nature than previous approaches, providing a high-level overview of the software system and how it functions under testing, thus summarizing results and highlighting promising locations in the program for further exploration. This paper presents a system we have developed, TARANTULA, that applies our techniques to depict a program along with the results of testing the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Input Data</head><p>Developers and maintainers of large software systems usually create tests (or test cases) for use in testing the systems. This testing provides evaluation of qualities such as correctness and performance. Each test consists of a set of inputs to the software and a set of expected outputs from the execution of the software with those inputs. A set of tests is called a test suite. It is not unusual for software engineers to develop large test suites consisting of unique tests that number in the hundreds or even in the thousands.</p><p>Given a test suite Ì for a software system Ë and a test Ø in Ì , we gather two types of information about the execution of Ë with Ø: pass/fail results and code coverage. Test Ø passes if the actual output for an execution of Ë with Ø is the same as the expected output for Ø; otherwise, Ø fails. The code coverage for Ø consists of the source-code lines that are executed when Ë is run with Ø.</p><p>The input to our visualization consists of three components: the source code for Ë; the pass/fail results for executing Ë with each Ø in Ì ; and the code coverage of executing Ë with each Ø in Ì . Each Ø in Ì (1) is marked as "passed" or "failed," and (2) contains the code coverage for the execution of Ë with Ø. A sample input to our visualization system is shown below. On each line, the first field is the test number, the second field is the pass/fail (P or F) information about the test, and the trailing integers are the code coverage for that test.</p><p>1 P 1 2 3 12 13 14 15 ... 2 P 1 2 23 24 25 26 27 ... 3 F 1 2 3 4 5 123 124 125 ... Our challenge is to use this data to help software engineers find faults or at least identify suspicious regions in code where faults may lie. For large software systems with large test suites, this resulting data is huge, and is extremely tedious to examine in textual form. A visualization can summarize the data, letting software engineers quickly browse the test result representation to find likely problem regions of the code that may be contributing to failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">TARANTULA</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Design Considerations</head><p>In developing TARANTULA, we had several key objectives. One was to provide a high-level, global overview of the source code upon which the results of the testing could be presented. We considered a number of alternatives and decided to use the "line of pixels"-style code view introduced by the SeeSoft system <ref type="bibr" target="#b2">[3]</ref>. Each line of code in the program is represented by a horizontal line of pixels. The length of the line of pixels corresponds to the length of the line of code in characters, thus providing a far-away, birdseye view of the code. Other objectives were to let viewers examine both individual tests and entire test suites, to provide data about individual source-code lines, and to support flexible, interactive perspectives on the system's execution.</p><p>Our design's primary focus is on illustrating the involvement of each program line in the execution of the different tests. We decided to use color to represent which and how many of the different tests caused execution through each line. As we explored this idea further, the difficulty of selecting a good visual mapping became evident.</p><p>Suppose that a test suite contains 100 failed tests and 100 passed tests. Particular lines in the program might be executed by none of the tests, only by failed tests, only by passed tests, or by some mixture of passed and failed tests. Our first approach was to represent each type of line by a different color (hue). Two different colors could represent passed and failed tests, and a third color that is a combination of those two could represent mixed execution.</p><p>More flexibility was necessary, however. Consider two lines in the program that are executed only by failed tests. Suppose that one line is executed by two tests and the other is executed by 50 tests. In some sense, the second line has more negative "weight" and could be represented with the same hue but with its code line darker, brighter, or more saturated than the first to indicate this attribute to the viewer.</p><p>This straightforward idea was sufficient for the pass-only or fail-only tests, but was insufficient to represent lines executed by both passed and failed tests. One approach was to vary the hue of the line, mixing combinations of the two extreme colors, to indicate how many tests of each type executed the line. For example, suppose that a program line was executed by 10 failed and by 20 passed tests. We could make its color closer to the color representing passed tests since it was involved in twice as many of those tests.</p><p>Unfortunately, this relatively simple scheme is not sufficient. Suppose that the entire test suite for the example above contains 15 failed and 200 passed tests. Even though the line was executed by only half as many failed tests (10 to 20), a much higher relative percentage of the failed tests encountered the line (10/15 = 67% to 20/200 = 10%), perhaps indicating more "confidence" in that fact. Representing these ratios seemed to be more important than presenting the total quantities of tests executing a line. Thus, the hue of a line should represent the relative ratios of failed and passed tests encountered, and the color of this line would be more strongly the color indicating a failed test.</p><p>This notion helped, but further issues arose. Consider two different source lines. The first is executed by 1 of 100 failed and 1 of 100 passed tests. The two ratios are the same, thus the line's hue is a perfect blend of the two. Suppose that a second line is executed by 95 of 100 failed and 95 of 100 passed tests. The second line is the same hue as the first, due to the equal ratios, but it seems desirable to render it differently because of its greater execution by the entire test suite. We needed to use a different attribute than hue to encode that fact.</p><p>TARANTULA's visual interface makes concrete the heuristics hinted at above. We first experimented with a variety of background and line category colors by running a series of informal user tests. These studies helped us to select a color scheme using a black background with green representing passed tests, red representing failed tests, and yellow representing an even balance of passed and failed tests. In the most advanced display mode, we decided to use hue to encode the ratio of the percentage (not quantity) of passed to failed tests through a line, and to use brightness to represent the larger of the two percentages. <ref type="figure" target="#fig_0">Figure 1</ref> shows TARANTULA's interface acting on an example data set. The middle area is the code-display area using the code-line representation pioneered in the SeeSoft system. The top area contains a number of interface controls for modifying the perspective in the program code display area. The bottom area shows a detailed textual view of a selected source-code region, statistics of the selected region, and a color-space map. One of the goals of TARANTULA is interactivity and flexibility, and different attributes of the data can be highlighted through different display modes and by mousing over or selecting different source-code lines. We next describe the systems's functionality in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">System Capabilities</head><p>The top area of the display contains a series of buttons, which are mutually exclusive controls for the display mode. The first mode, Default, simply shows the lines of code in gray in the code display area and does not illustrate any testing data. The darkness or lightness of the gray is controlled through the upper-right slider, which is discussed later.</p><p>The second mode, Discrete, presents a general summary of all testing information in a straightforward manner. We call it "Discrete" because three discrete colors, red, yellow, and green, are used to color program statements to indicate how they were executed by the test suite. If no test executed a line or the line is a comment, header, etc., the line is gray. If a line was executed only in passed tests, the line is green. If a line was executed only in failed tests, it is red. Finally, if a line was executed in both passed and failed tests, then it is yellow.</p><p>The third mode, Continuous (shown in <ref type="figure" target="#fig_0">Figure 1</ref>), is the most informative and complex mapping. Unlike the Discrete mode, it renders all executed statements on a spectrum from red to green and with varying brightnesses. In particular, the hue of a line is determined by the percentage of the number of failed tests executing statement × to the total number of failed tests in the test suite Ì and the percentage of the number passed tests executing × to the number of passed tests in Ì . The brightness is determined by the greater of the two percentages, assuming brightness is measured on a 0 to 100 scale. Specifically, the color of the line for a statement × that is executed by at least one test is determined by the following equations. For example, for a test suite of 100 tests, a statement × that is executed by 15 of 20 failed tests and 40 of 80 passed tests, and a hue range of 0 (red) to 100 (green), the hue and brightness are 40 and 75, respectively. The last three display modes (Passes, Fails, and Mixed) simply focus on showing all the lines in one of the three components of the Continuous mode. The same coloration and brightness mapping as in the Continuous case is used, but only lines that meet one of the three criteria are colored. For example, in Fails mode, lines executed only in failed tests are red and all others are gray. This effectively lets the viewer spotlight only those lines and focus more clearly on them. In each of these modes, the brightness for each line is the percentage of tests that execute the respective statement of the tests for that mode. Lines executed by all failed tests are bright red, for example, and lines executed only in a small percentage of the failed tests are dark red.</p><p>The long, thin rectangular region located above and to the right of the code-view area visually encodes the pass/fail attribute of each test in the suite. A small rectangle is drawn for each test from left-to-right and is color-coded to its outcome-green for pass and red for fail. This lets the viewer, at a glance, see the overall pass/fail trend within the test suite. Furthermore, the viewer can use the mouse to select any rectangle in order to display only that particular test's code coverage in the code view below. Also, the textentry box in the upper left (labeled "Test:") lets the viewer enter the numbers of particular tests and see the code coverage of only those tests reflected in the code-display area.</p><p>As mentioned earlier, the slider above the test suite display controls the brightness of the unexecuted statements shown in gray. This feature lets the viewer gain familiarity with the code by making comments and other unexecuted code more visible (brighter gray), and then focus only on the executed code by making the unexecuted code black.</p><p>The bottom area of the display contains a color-space map and detailed information about selected source code. The rectangle in the lower right, when in Continuous mode, is a map of the color space. Statements are represented as black dots at the position corresponding to their color in the current color mapping. The viewer is then able to see the distribution throughout the color space of all statements in the view. The user also can select particular statements by "rubber banding" their dots in the map, thus forming a type of dynamic query that causes the code view to be redisplayed, coloring only appropriate lines. For example, the viewer may wish to select all statements that are within 10% of pure red, or all statements that are executed by more than 90% of the test suite. Finally, moving the cursor over a code line in the code-display area makes it the focus: the source code near that line is shown in the bottom left of the interface, and the line number and test coverage statistics for that line are shown in the lower center.</p><p>To find faults in a system, a software engineer loads the input data about a system (described in Section 2) and can then examine the source code under a variety of perspectives. Presently, we are using TARANTULA to examine large programs under test to gain a better understanding of how program faults correlate to colored regions in the display. We need to determine whether faults usually fall in bright red regions of the display that indicate lines executed only in failed tests and in high percentages of those tests, or whether faults often lie in yellow regions executed both by passed and failed tests. Furthermore, we need to determine whether faults sometimes lie "upstream" or "downstream" of these colored regions. If so, we need to include other program visualization views or supplement TARAN-TULA's view with information to visually encode other program attributes such as control flow and calling relations. Along those lines, Ball and Eick created a visualization system that uses the SeeSoft representation to encode program slices <ref type="bibr" target="#b0">[1]</ref>. We will explore the addition of program analysis information such as slices, into TARANTULA in the future. We are also investigating possible visualizations for higherlevel abstractions of programs and other techniques to aid in the scalability of our technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Conclusion</head><p>This article presented an overview of TARANTULA, its user interface, and its visual encoding methodology for representing program test information. The research makes three main contributions. First, it introduces the idea of using a visual encoding of the potentially massive amount of program test result information to help software engineers locate faults in software systems. Second, it identifies a visual mapping using color and brightness to reflect each source line's influence on the test executions. Finally, it creates an informative and flexible user interface for presenting a variety of perspectives on the testing information.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>A screen snapshot of the TARANTULA system in Continuous mode.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">In our discussion, we use errors, bugs, and faults interchangeably.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Software visualization in the large</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="33" to="43" />
			<date type="published" when="1996-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Evaluating the effectiveness of reliability-assurance techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Collofello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">N</forename><surname>Woodfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="191" to="195" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Seesoft-A tool for visualizing line oriented software statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">E</forename><surname>Sumner</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="957" to="968" />
			<date type="published" when="1992-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://xsuds.argreenhouse.com/html-man/coverpage.html" />
		<title level="m">Telcordia Technologies, Inc. xATAC: A tool for improving testing effectiveness</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Expertise in debugging computer programs. International Journal of Man-Machine Studies: A process analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Vessey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="459" to="494" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
