<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>October 22 -October 23, 2001</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Abello</surname></persName>
							<email>abello@research.att.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Irene</forename><surname>Finocchi</surname></persName>
							<email>finocchi@dsi.uniroma1.it</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Jeffrey Korn Information Visualization Research Shannon Laboratories</orgName>
								<orgName type="institution">AT&amp;T Labs-Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Rome &quot;</orgName>
								<address>
									<addrLine>La Sapienza&quot;</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">IEEE Symposium on Information Visualization</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date type="published">October 22 -October 23, 2001</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>visualization</term>
					<term>massive data sets</term>
					<term>graphs</term>
					<term>hierarchies</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We introduce the notion of Graph Sketches. They can be thought of as visual indices that guide the navigation of a multi-graph too large to fit on the available display. We adhere to the Visual Information-Seeking Mantra: Overview first, zoom and filter, then details on demand. Graph Sketches are incorporated into MGV, an integrated visualization and exploration system for massive multi-digraph navigation. We highlight the main algorithmic and visualization tasks behind the computation of Graph Sketches and illustrate several application scenarios. Graph Sketches will be used to guide the navigation of multi-digraphs defined on vertex sets with sizes ranging from 100 to 250 million vertices.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>One of the great visualization challenges today is the representation and fluid navigation of complex systems. We concentrate on very large multi-digraphs of sparse density and low diameter. Geographic information systems, telecommunications traffic <ref type="bibr" target="#b0">[1]</ref>, World-Wide Web <ref type="bibr" target="#b4">[5]</ref> and Internet data <ref type="bibr" target="#b7">[8]</ref> are prime examples of the type of graphs whose navigation can be guided by our Graph Sketches approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The bottlenecks</head><p>When visualizing massive data, two of the most fundamental issues are those associated with the I/O and screen bottlenecks. The I/O bottleneck is caused by the substantial difference between CPU speeds and external memories <ref type="bibr" target="#b3">[4]</ref>. The screen bottleneck <ref type="bibr" target="#b0">[1]</ref> is caused by the simple fact that the amount of information that can be displayed at once is ultimately limited by the number of available pixels and the speed at which the information is digested by a user. Even though a large number of pixels diminishes the screen bottleneck, it does not help the user's visual processing abstraction unless the display metaphor incorporates some global data set semantics. We propose mechanisms to alleviate the screen bottleneck.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Approach</head><p>Our approach is based on the hierarchical surfaces metaphor presented in <ref type="bibr" target="#b2">[3]</ref>. Its effectiveness on very large graphs depends on a good recursive clustering that can be mapped to a partition of the screen space. Each such mapping is what we call a Graph Sketch. Graph Sketches should offer simple overviews of a very large graph macro-structure ( <ref type="figure" target="#fig_4">Figure 3</ref>). These views are zoom-able and are parameterized by user specified subgraph thresholds. When the obtained subgraph is small enough to fit on the available screen, the graph representation and its processing can be varied.</p><p>The concentration of this paper is on large graphs. With this in mind, we consider a multi-digraph large if its number of vertices is greater than</p><formula xml:id="formula_0">¤ ¦ ¥ § © ¤</formula><p>where ¤ is the number of available display pixels.</p><p>Graph Sketches provide a unified view of computation and visualization of very large graphs. Namely, visualizations become the product of graph decompositions that are tailored to a particular very large graph problem of interest. Different graph representations may be necessary for different goal driven navigations. We suggest searching for graph representations that encapsulate the essential features of either a clustering algorithm or a typical subspace that contains a feasible answer.</p><p>This paper presents techniques that are particularly helpful in guiding the navigation of very large graphs in order for a user to drive the computation towards a set of feasible answers.</p><p>It is worth mentioning that the approach advocated here allows the use of a commercial relational database to query a multi-digraph hierarchy with very little extra effort. Graph Sketches are amenable to distributed visual exploration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Related Work</head><p>Multi-level graph views offer the possibility of drawing large graphs at different levels of abstraction. The higher the level of abstraction, the coarser the provided graph view. Compound and clustered graphs have been considered in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13]</ref>. In <ref type="bibr" target="#b8">[9]</ref>, some of the limitations of force-directed based methods for drawing large graphs are addressed. A central idea is to produce graph embeddings on Euclidean spaces of high dimensions and then projecting them into a two or three dimensional subspace. The method is based on a maximal independent set filtration of the vertexes of the graph and it is not apparent how to obtain such a filtration in the case of external memory graphs.</p><p>The primary difficulty with the surfaces approached described in <ref type="bibr" target="#b2">[3]</ref> is that 2D surfaces are not easy to refine locally. We concentrate here on methods of computing, from the input graph, hierarchy trees that can be turned into efficient Graph Sketches. Graph Sketches can be viewed as a formulation that provides a uniform overall view of massive graph data together with scalable, efficient and flexible visual navigation tools.</p><p>The layout of the paper is as follows: In Section 2, we introduce graph sketches; the main elements of the computational engine, and its fundamental operations and I/O performance are covered in Section 3. In the same section we briefly review the main components of the C-Java visualizer ( " ! ) <ref type="bibr" target="#b0">[1]</ref> that manipulates Graph Sketches. Section 4 points out some future research directions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Graph Sketches</head><p>A Graph Sketch is a screen zoom-able macro-view of a very large graph. The goal is to use the sketch to guide the search for "interesting" subgraphs. The sketch should be tailored to the task at hand. For example, if the goal is to find dense subgraphs, the sketch needs to incorporate some notion of distance. This, in turn, affects the type of recursive clustering that must be used to define the sketch. In general, a good deal of ingenuity will be necessary to design sketches that become effective visual navigation aids. With this framework in mind, designing a good navigation sketch for a particular problem becomes the central algorithmic question that needs to be resolved before a useful interactive visualization can be proposed. In this context, visualization is no longer just a presentation aid; it becomes part of the computational process.</p><p>A sketch for a graph is a multi-digraph defined on a partition</p><formula xml:id="formula_1">! $ # , ! &amp; % , ' ( ' ) ' 0 ! 2 1 of ! 3 4 "</formula><p>that is embedable on the available pixel array. A multi-edge from . The multiplicity is just the number of such edges. We refer to this multi-graph as a </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9</head><p>. This is the case for certain graph problems when the . This means that a detailed view of an sketch multi-edge can be obtained by zooming into it. In other words, from an initial planar embedding of the sketch, one can zoom in locally into any of the edges. This locality provided by the planar clustering allows the user to explore the multi-digraph edge hierarchy in a fluid manner. Of course, all of this is possible only if the detailed view of a macro-edge can be computed efficiently.  . It is important to notice that all these invocations are independent of each other and that by the end of the computation of the ¤ -sketch, the only references that are kept are those from each obtained multi-edge to the actual input data that it represents. Only the subgraph to be expanded needs to reside in memory. Care needs to be taken to carry with each call a mapping from the current vertex names to the local ones. The depth of the recursion is controlled by the number of available pixels ¤ , a time or space budget, and problem defined parameters. When the recursion is finished a data structure representing the obtained hierarchy tree and a mapping from the tree leaves to the partition of ! 3</p><p>4 " that they represent is produced. This data structure may reside in memory or on disk depending on the amount of available RAM. Notice that the complexity of constructing a s t 8 B v u x w y 4</p><p>x @ P depends strictly on the complexity of the procedure Construct-View and on the quality of the obtained partition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Sample Sketches</head><p>The main task to design a good sketch for a problem 9 is to devise a partitioning scheme for the input graph that guarantees that the space of solutions for 9 can be obtained by a suitable combination of solutions of 9 restricted to the subgraphs induced by each set in the partition. Of course, this may not be the case for all problems and we know of no easily computable criteria to classify a problem as partitionable (in the sense described here). Nevertheless, we provide concrete examples of sketches for some NP-Hard problems.</p><p>The most direct example of a sketch comes from graphs whose vertices have associated a geographic location. A classical example is the graph whose vertices are telephone numbers and the edges consists of phone calls among them. In this case, the hierarchy @ on the vertex set is pre-established and consists of the subdivision of the earth in continents, countries, states, counties, towns, etc. An embedding of the hierarchy is provided by a cartographic map. A so called star map drawing was proposed in <ref type="bibr" target="#b0">[1]</ref> to place the underlying graph on top of the map embedding. An alternative view can now be provided by using a matrix based sketch. The rows and columns of the matrix are ordered according to a Peano-Hilbert ordering determined by the geographic position of the vertices (see defined by distances from the BFS root. The corresponding multi-graph is planar (in fact, ignoring directions, it is simply a path) and the number of sets in the partition is just the depth of the BFS tree. So the only condition that could fail for this multi-graph to be considered a sketch is that the depth of the BFS tree is larger than</p><formula xml:id="formula_2">G 0 u v ¤ where ¤</formula><p>is the number of available pixels. In this case, successive folding of the path can be done until it fits on the available screen. More generally, any planar 8 view can be transformed into a related planar ¤ -view where ¤ 8</p><p>. For the maximum clique problem, the assertion that a BFS based partition of</p><formula xml:id="formula_3">! 3 4 "</formula><p>is a "good" ¤ -sketch follows from the observation that cliques of are by definition induced subgraphs where all the vertices are at distance exactly 1. Therefore, cliques can span at most two consecutive levels of any ¦ s tree. A screen embedding is obtained by mapping each vertex of the hierarchy to a box placed diagonally inside its parent's box with the side lengths of the two boxes being in the same proportion as the ratio of the cardinalities of their corresponding sets of descendant leaves. Because the sketch is based on a BFS view of , the subgraph consisting of the edges between consecutive levels gets naturally assigned to the only adjacent boxes that are determined by consecutive boxes on the diagonal. Each box is painted according to a density based color map. When zooming on a box, its interior is partitioned according to its children and the color map is recomputed according to its children densities. The diagonal boxes corresponding to the leaves of the hierarchy tree can be though of as a coordinatization of the visual space (see <ref type="figure" target="#fig_3">Figure 2</ref>). If more detailed connectivity is desired, a conventional drawing representation can be invoked. An overview representation is always maintained on an auxiliary window with an indication of the hierarchy tree level at which the exploration is taking place. In call detail graphs, we have been able to detect experimentally that the largest cliques also have logarithmic size.</p><p>A more economical sketch can be obtained by mapping each node of the hierarchy tree to a colored bar where the length is proportional to the size of its set of descendants leaves and where the color again encodes a map density. The collection of bars representing the set of children of a pair of bars are placed parallel to each other and in the order of their BFS levels. In the case of zooming into the children of just one bar its children are placed inside a zoomed version of the bar in a direction orthogonal to that of the parent bar. Initially, the root bar gets assigned a fixed but arbitrary direction. We refer to this BFS sketch embedding as the orthogonal bars</p><formula xml:id="formula_4">G 0 8 B v u x w v y</formula><p>, (see <ref type="figure" target="#fig_4">Figure 3)</ref>.</p><p>Consider now the problem of computing an edge minimum 8 -view of an arbitrary graph with the added restriction that every set in the partition must be smaller than an input value</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G</head><p>. This problem is also NP-complete. However a Depth First Search spanning forest of that satisfies the property that if a vertex E belongs to a short cycle, then contains a path that goes around some short cycle that contains E , can be used to obtain a sketch of . In the case that several short cycles contain E , priority is given to the unique cycle that is determined by the most recently added edge to the spanning tree. This is a two pass algorithm. In the first pass, the spanning tree is constructed. In the second pass, a bottom up procedure that contracts pendant leaves and interior vertices with exactly two leaves as children produces a partition of the vertex set. It is not hard to show that this procedure computes a with a distance parameter § such that each color class is partitioned into an arbitrary number of disjoint clusters, the shortest path distance between any pair of nodes in a cluster is at most § and clusters of the same color are at least distance 2 apart. The goal is to find such a decomposition of a network where both the number of color classes and the distance parameter § are both e § © g</p><p>where g is the number of vertices in .</p><p>Despite the apparent similarity between this problem and the previous two, such decompositions can be found in optimal time Q R X h i g by a simple greedy construction. This decomposition can be used as a base for a sketch but it is not clear for what class of graph problems this is a "good" sketch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Implementation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sketch maintenance</head><p>In order to effectively use</p><formula xml:id="formula_5">G 0 8 B 0 u j w v y $ B G</formula><p>, the following pre-processing steps are necessary.</p><p>Compute an external memory BFS. This can be done in</p><formula xml:id="formula_6">! k X h l Q R m n ¥ P § © ! k m n C h o G v © u Q R</formula><p>I/O's by using a modification of a data structure originally proposed by <ref type="bibr" target="#b10">[11]</ref>.</p><p>is the size of the disk block.</p><p>Build an in-core index to a disk resident data structure that contains for each level of the BFS its induced subgraph and for each pair of adjacent levels the subgraph consisting of all the edges going from one level to the other in both directions. The in-core index will only keep a reference to the disk location, the associated density function value and a few book keeping items. With this information, the corresponding screen embedding is computed as depicted in <ref type="figure" target="#fig_3">Figure 2</ref> or <ref type="figure" target="#fig_4">Figure 3</ref>. The corresponding portion of the current hierarchy tree @ is also stored in memory. Now, for those vertices of the hierarchy tree whose associated induced subgraph fits in main memory the corresponding full hierarchy subtree is computed, using an internal memory implementation. Notice that all these computations can be made independently. For those vertices of the hierarchy tree whose vertex set fits in main memory but not its edge set, a semi-external version of BFS is invoked <ref type="bibr" target="#b1">[2]</ref>. Those vertices of @ whose associated vertex set does not fit in memory are processed again by a fully external BFS algorithm. Notice that all these computations are amenable to parallelization since they are independent. At the end of these steps, we have a disk resident representation of the hierarchy tree @ and a mapping from its leaves to the actual vertices that they represent in the input graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Navigation</head><p>From any given layer the user can move to any of the adjacent layers by partial aggregation or by refinement of some sets in the corresponding partition. Namely, from any given multi-edge B in a current sketch the user can zoom into B ' s corresponding detailed view or he/she can also zoom out into the subgraph that generated It consists of a C-computational engine (server) and a Java-3D visualizer (client), which may reside on separate machines. In fact, the visualizer can run on multiple desktops allowing different users to navigate a massive data set independently.</p><p>It provides a drill-down zoom-able interface together with a collection of multi-linked views.</p><p>Context is maintained by using multiple cameras. One provides an overview and the others trail each other depending of a user specified zooming interval. A persistent history of previous navigations of the hierarchy is maintained.</p><p>Users can plug-in alternative Sketch visualizations, and can apply their own filters to the subgraphs accessible from the sketch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adding a new sketch to</head><p>" ! requires implementing a small set of functions that handle rendering, zooming, labeling and linking. The sample sketches described in this paper were each on the order of between 500 and 1000 lines of Java.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions</head><p>Graph Sketches offer a unified view of computation and visualization on very large graphs. Very large graph visualizations need to be aware of the intrinsic algorithmic question that needs to be solved in order to provide interactive navigation that can guide a user towards the discovery of interesting graph sub-structures. Tailoring a graph decomposition to an exploration task appears to be an interesting angle that deserves further study. Devising useful 3D sketches is a tantalizing area of research. A question that comes to mind is: Are there any other interesting graph problems for which the BFS based sketches introduced here are beneficial?</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Location-based Graph Sketch of call detail traffic among US states.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>in principle one can use divide and conquer to search for a solution to</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>BFS Sketch. Each diagonal box represents a level of BFS. The remaining boxes represent the subgraphs induced by adjacent levels. Their edge density is color mapped.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :,</head><label>3</label><figDesc>Orthogonal Construct-View is invoked for each r on the subgraph induced by ! 2 5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 1 )</head><label>1</label><figDesc>. The edge density of the corresponding subgraphs is represented by a suitable color map. Consider the problem of finding a largest cardinality clique in an arbitrary connected graph . A Breadth First Search tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>edges in the next Sketch layer that run from the children of p to the children of E f s . The user can customize provided color maps to refine the search at different levels of granularity. An assorted set of multi-linked views and labels are at his/her disposition to identify the actual values being represented by the color maps. Graph Sketches are incorporated into " ! [1] (a Massive Graph Visualizer ) whose more salient features are: It handles hierarchical views of massive multi-digraphs.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Visualizing Massive Multi-Digraphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Korn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Proc. Information Visualization</title>
		<meeting><address><addrLine>Salk Lake City</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="39" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A functional approach to external memory graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Buchsbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Westbrook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Algorithms</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1461</biblScope>
			<biblScope unit="page" from="332" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Navigating Graph Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation and Complexity in Numerical Optimization: Continuous and Discrete Problems</title>
		<editor>P. Pardalos</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">AMS-DIMACS Series on Discrete Mathematics and Theoretical Computer Science</title>
		<editor>J. Abello, J. Vitter.</editor>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Graph Structure in the Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Broder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Networks</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="309" to="320" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A linear time algorithm for network decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cowen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dimacs TR series</title>
		<imprint>
			<biblScope unit="page" from="94" to="56" />
			<date type="published" when="1994-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Straight-line drawing algorithms for hierarchical and clustered graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">W</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Symp. on Graph Drawing</title>
		<meeting>4th Symp. on Graph Drawing</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="113" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On power-law relationships of the internet topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Faloutos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Comp</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="251" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A multidimensional approach to force directed layouts of large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gajer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kobourov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Graph Drawing</title>
		<meeting>of Graph Drawing</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Parallel Algorithm Graph Reduction. TR No. CS88-120</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Karabeg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988-03" />
			<pubPlace>San Diego</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Improved algorithms and data structures for solving graph problems in external memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th IEEE SPDP</title>
		<meeting>8th IEEE SPDP</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="169" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Information Visualization: Dynamic queries, starfield displays, and LifeLines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
	<note>In www.cs.umd.edu</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Visualization of structural information: Automatic drawing of compound digraphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Misue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Systems, Man and Cybernetics</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="876" to="892" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
