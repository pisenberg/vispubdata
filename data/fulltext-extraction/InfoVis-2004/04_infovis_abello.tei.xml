<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Matrix Zoom: A Visual Interface to Semi-external Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Abello</surname></persName>
							<email>abello@dimacs.rutgers.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Van Ham</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">DIMACS</orgName>
								<orgName type="institution">Rutgers University Piscataway</orgName>
								<address>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Mathematics and Computer Science Technische</orgName>
								<orgName type="institution">Universiteit</orgName>
								<address>
									<settlement>Eindhoven</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Matrix Zoom: A Visual Interface to Semi-external Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.5.2 [Information Interfaces and Presentation]: User Interfaces-Graphical User Interfaces; H.2.8 [Database Management]: Database Applications-Data Mining I.5.5 [Pattern Recognition]: Clustering-Algorithms Graph Visualization</term>
					<term>Hierarchy Trees</term>
					<term>Clustering</term>
					<term>External Memory Algorithms</term>
					<term>Cancer Data</term>
					<term>Phone Traffic</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In web data, telecommunications traffic and in epidemiological studies, dense subgraphs correspond to subsets of subjects (i.e. users, patients) that share a collection of attributes values (i.e. accessed web pages, email-calling patterns or disease diagnostic profiles). Visual and computational identification of these &quot;clusters&quot; becomes useful when domain experts desire to determine those factors of major influence in the formation of access and communication clusters or in the detection and contention of disease spread. With the current increases in graphic hardware capabilities and RAM sizes, it is more useful to relate graph sizes to the available screen real estate S and the amount of available RAM M, instead of the number of edges or nodes in the graph. We offer a visual interface that is parameterized by M and S and is particularly suited for navigation tasks that require the identification of subgraphs whose edge density is above certain threshold. This is achieved by providing a zoomable matrix view of the underlying data. This view is strongly coupled to a hierarchical view of the essential information elements present in the data domain. We illustrate the applicability of this work to the visual navigation of cancer incidence data and to an aggregated sample of phone call traffic.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A variety of data sets can be interpreted as a relation A between a set of subjects K (i.e. users, patients, entities, etc) and a set of attribute values L (i.e. web pages accessed, diagnosis characteristics, entities compounds, etc). A can then be viewed as a |K| by |L| matrix where A[x, y] = 1 if and only if subject x has attribute value y, i.e. A becomes the adjacency matrix of a graph G with vertex set V (G) = K ∪ L. In many applications, the set of subjects and the set of attributes are disjoint (i.e. the graph is bipartite), however this is not a restriction since any graph has a unique adjacency matrix representation (modulo columns and row permutations). This matrix view of a graph opened the very successful use of spectral methods to elucidate inherent graph clustering structure of several sorts <ref type="bibr" target="#b12">[13]</ref>. This line of research has been used to produce aesthetically pleasing node-link graph layouts <ref type="bibr" target="#b10">[11]</ref>. A natural way to proceed would then be to obtain a hierarchical clustering on the layout and choose from it a coarse enough level that can be then embedded on the screen. This begs the question of how then one can zoom into the current node-link layout to obtain the next node-link level of granularity. Zooming into a vertex offers no major problem since this amounts to allocating enough screen space around the vertex to locally embed the lower level subgraph that it represents <ref type="bibr" target="#b2">[3]</ref>.</p><p>However, zooming into an aggregated edge leaves us with the unpleasant task of embedding locally the collection of edges it represents with the added constraint that their endpoints already have predetermined positions. The problem becomes aggravated when the collection of edges at a lower level is so large that their local embedding clutters the available screen space. This is in our view one of the major difficulties in using node-link diagrams to visually navigate large graphs even if a hierarchical clustering has been computed. On the other hand, if a clustered graph is visually embedded as an adjacency matrix there is no difference between zooming into edges or vertices since in both cases there is a well defined local area of the screen into which we can zoom in. This is the main justification to use matrix-based representations of large clustered graphs if the user task at hand requires navigation at different levels of granularity.</p><p>Another reason is that, very often, higher levels of clustering tend to produce very dense graphs and in this case nodelink diagrams are again not very well suited. In summary, in this work we concentrate on the problem of navigating hierarchically clustered graphs and we assume that such a clustering is provided to us as a hierarchy tree on the vertex set of an input graph (semi-external). We illustrate the use of the proposed interface to navigate data provided by the SEER program of the US National Cancer Institute and we also use our interface to navigate a hierarchical view of a phone traffic data set for which not even the vertex set fits in RAM (i.e. a fully external memory graph). In the next section we discuss related work and present an overview of our ideas. Section 3 describes the framework that can be used to efficiently navigate semi-external graphs. Section 4 gives an overview of the visual interface and its main features. Section 5 illustrates navigation results on cancer incidence data and on aggregated sample of phone traffic. Finally, we present conclusions and further work in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK AND PAPER OVERVIEW</head><p>The incidence matrix of a graph allows to some extent visualization of a clustering. This amounts to relabelling the nodes of the graph such that nodes in the same cluster have consecutive labels. If there are enough edges within a cluster (i.e. if its density is high) and few edges going out of it then the resulting permuted matrix exhibits a diagonal block structure with the remaining "few" entries scattered in the remaining portions of the matrix. Different reordering algorithms <ref type="bibr" target="#b5">[6]</ref> produce then potentially different clusters, however standardized comparison of cluster methods is virtually non-existent. Usually, the solutions quality is measured in terms of a cost function on the produced clusters, but devising such cost functions is non-trivial <ref type="bibr" target="#b4">[5]</ref>.</p><p>Having a clustering, each of the clusters gets collapsed into a macro vertex and the edges between clusters are aggregated into macro edges providing a coarse view of the input graph. Iteration of this process is what is referred in the literature as hierarchical graph October 10-12, Austin, Texas, USA 0-7803-8779-1/04/$20.00 ©2004 IEEE</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Symposium on Information Visualization 2004</head><p>clustering <ref type="bibr" target="#b9">[10]</ref>. The required data structure to maintain the obtained clusters is a Hierarchy Tree. It is simply a rooted tree T whose set of leaves is in one to one correspondence with the vertices of the input graph. Each internal tree node represents a cluster obtained by collapsing its set of descendant leaves (see <ref type="figure" target="#fig_0">figure 1)</ref>. A view of the input graph consists then of a careful selection of a set of nodes in the hierarchy tree that corresponds to a partition of the graph vertex set and its induced macro view. Navigation from one macro view to another corresponds to refinement or aggregation of selected subsets in the partition. We tune this navigation by using memory, screen, time and graph size parameters as upper bounds on the available resources.</p><p>Navigation tuning becomes essential especially when the input graph is too large to fit on the available RAM (the I/O bottleneck). Even if the graph fits in RAM it is necessary to control the screen space usage since the number of pixels available is often scarce (the screen bottleneck) compared to usual graph sizes. In order to offer predefined levels of interactivity it is necessary to provide efficient access mechanisms to the raw graph data and fast layout algorithms for selected subgraph slices. We address all these issues in a unified manner by building on the work of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b13">14]</ref>, paying special attention to improving the interface. We offer quite reasonable levels of user interactivity by a combination of fast data access, selective use of both matrix and node link diagrams, and fast semantic and geometric zooming. Needless to say that the fundamental data structure behind the scenes is an enhanced hierarchy tree. More succinctly, our contributions are:</p><p>• a. A matrix driven interface to browse hierarchically clustered graphs whose vertex set fits in RAM but whose edge set does not. It is worth to point out that the use of a matrix representation does not preclude the use of node link representations at lower levels of granularity. In fact, the navigation interface is equipped with parameterized controls that allow the use of both representations at the user's discretion.</p><p>• b. The incorporation of screen, graph and RAM parameters into each node of the hierarchy tree to empower the navigation algorithm to make decisions about the type of graph representation that is most suitable at each level of the hierarchy (section 3.3)</p><p>• c. The use of a variation of a kd-index to access subgraph slices when the input graph is too large to fit on the available RAM (section 3.2)</p><p>• d. A strong visual coupling of the hierarchy tree with the canvas display ( <ref type="figure" target="#fig_3">Figure 3</ref>). This provides in effect a uniform and permanent hierarchical view of the entire input graph. Navigation from one macro view to another is explicitly presented.</p><p>• e. Mechanisms to provide a smooth transition from graph matrix views into node link representations. At this stage, vertices are visually ranked according to a local peeling decomposition.</p><p>• f. Illustration of the applicability of the methods to the fluid navigation of US SEER Cancer data <ref type="bibr" target="#b7">[8]</ref> when viewed as a bipartite graph with about 6 million edges and a high level view of a fully external graph with about 250 million vertices (section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MEMORY AND SCREEN BOUNDED GRAPH MACRO-VIEWS</head><p>We assume all through out that |M| is the size (in words) of random access memory and that |S| is the size of the available screen. We reserve the term nodes to refer to vertices of a tree.  • Antichain. For a rooted tree T, and a node p in T let T p denote the subtree of T rooted at p and let Leaves(T ) denote the set of leaves of T . Nodes p and q of T are called incomparable in T if neither p nor q is an ancestor of the other. A set of pairwise incomparable nodes in T is called an antichain. Any maximal antichain in a tree T corresponds to a partition of Leaves(T ). Leaves(T ), Root(T ) and any maximal set of tree nodes at the same distance from the root are the most simple examples of antichains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definitions</head><formula xml:id="formula_0">• A multi-digraph is a triplet G = (V, E, m) where V</formula><p>• Hierarchy Tree. A rooted tree T is called a hierarchy tree for a graph G if Leaves(T) = V (G). We assume that from each leaf of T we have random access to the in-degree and out-degree of its corresponding vertex in V (G). This is a reasonable assumption since this information can be obtained in one pass over E(G) provided that the vertex set fits in RAM (i.e. G is semi-external).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Hierarchical Coordinates for the Adjacency Matrix of G</head><p>Starting from the root, a depth first search (dfs) traversal of the hierarchy tree T , for a multi-digraph G, provides a hierarchical set of coordinates for G's adjacency matrix A(G) as follows. Associate with every node p in T , the interval of dfs numbers going from d f s(p) to the maximum dfs number in the subtree T p ; call such an interval I(p). This collection of intervals provides a hierarchical view of A(G) by mapping the entire matrix to the square with coordinates [0,0], [0, maxdfs of T], [maxdfs of T, 0] and [maxdfs of T, maxdfs of T]. This process is iterated recursively. We obtain in this fashion a hierarchical subdivision of space where each incomparable ordered pair of nodes (p, q) in T is associated with the submatrix cell I(p) × I(q).</p><p>• The cell I(p) × I(q) corresponds to a subgraph of G that we call details(p, q) whose vertex set and edge set are defined as follows:</p><formula xml:id="formula_1">V (details(p, q)) = Leaves(T p ) ∪ Leaves(T q ) and E(details(p, q)) = {(u, v) ∈ E(G) such that u ∈ Leaves(T p ) and v ∈ Leaves(T q )}.</formula><p>The number of non-zero entries in the submatrix cell</p><formula xml:id="formula_2">I(p) × I(q) is precisely |E(details(p, q))| and the density of this subgraph is |E(details(p, q))|÷|I(p) × I(q)|.</formula><p>We are interested in detecting subgraphs details(p, q) with density above certain threshold. Since the central statistic that is carried all trough out in a hierarchical manner is precisely |E(details(p, q))| we record its definition for future reference.</p><p>• The multiplicity of an ordered pair of nodes p and q in a hierarchy tree T is</p><formula xml:id="formula_3">m(p, q) = ∑ (u,v)∈E(G) m(u, v) where u ∈ Leaves(T p ) and v ∈ Leaves (T q )</formula><p>The ordered pair (p, q) is called a virtual multi-edge if m(p, q) is non zero. Notice that in general a virtual multi-edge (p, p) represents the subgraph of G induced by Leaves(T p ) and m(p, p) is its aggregate multiplicity. These types of multi-edges correspond to local interactions. Aggregate interactions at the same level of the hierarchy correspond to multi-edges that are at the same distance from the root (horizontal edges). In the case of phone call traffic, they represent traffic between regions, states, counties, towns, etc.</p><p>• For a virtual multi-edge (p, q), expansion(p, q) is the multidigraph with vertex set equal to children(p) ∪ children(q) and all the multi-edges running between children(p) and children(q).</p><p>A good mental picture is that each virtual multi-edge (p, q) has its own hierarchy of edge slices where each level represents an aggregation of previous levels and where the bottom most level is the subgraph of G that we call details(p, q) consisting of the directed edges running from Leaves(T p ) to Leaves(T q ). In order to have fast disk I/O access to these subgraphs we use a greedy variation of a kd tree index called the gkd index as proposed in <ref type="bibr" target="#b3">[4]</ref>. During data loading, besides constructing the gkd tree we also build a redundant R*-tree that indexes the leaf pages of the gkd tree. In this way, fast construction and balanced lookups are possible because the redundant R* tree can be built without scanning the gkd leaves themselves. The details of how this is achieved can be found in <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Screen Bounded Hierarchy Trees</head><p>Since the number of screen pixels available is the ultimate constraint for a visualization we introduce now a process called hierarchy tree regularization. Its purpose is to embed a given hierarchy tree T into a possible larger hierarchy tree RT such that the number of children of each node is not more than a specified integer value |S| which corresponds to the available screen space. Notice that RT must have the same set of leaves as T . Starting at the root (in breadth first search order), if the number of children of a node p is more than |S|, they get grouped into groups of at most |S| nodes each. Each group of nodes is assigned to a common parent and these artificial parent nodes become the new children of p. To make the subdivisions as meaningful as possible without exceeding our computation time budget, we first check wether there are any childnodes that have no incident edges. This can be done efficiently since we have random access to the degree for each node. Next, we check if there are any leafnodes mixed in with non-leafnodes and aggregate both in a separate group. If both of these tests fail we aggregate nodes into S groups by the order in which they are processed. Note that, time and memory space permitted, we can use any kind of clustering criteria at this point. We could even compute an explicit clustering on the child nodes and the edges among them, but this would take in general an excessive amount of time.The artificial nodes introduced by this process are colored lightly in the interface to indicate that they were introduced for the purposes of visual navigation only, i.e. they do not necessarily convey application domain semantics (see <ref type="figure" target="#fig_3">Figure 3</ref>).</p><p>function RegularizeTree (Tree T , Screensize S)</p><p>• Input: An enhanced hierarchy tree T for a multi digraph G and a parameter |S| corresponding to the number of available screen pixels. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">RAM bounded Macro Views of a Semi External Graph</head><p>In this section we show how we can use the concepts of antichains and the regularized hierarchy tree of the previous section to generate a RAM resident macro view of any graph.</p><p>• For a multi-digraph G with an enhanced hierarchy tree T as above, a maximal antichain in T is called a T-cover of G. Notice that Leaves(T) is a T-cover of G and that substituting in a T-cover C a set of nodes by their common parent produces another T-cover C'. In this case we say that C' is smaller than C. T-covers provide layered views that facilitate localized navigation of the data. Their cardinality can be as small as 1 (i.e. the root of the tree) or as large as the number of leaves in T.</p><p>• A T-view of G is the multi digraph with vertex set the nodes of a T-cover and all the virtual multi-edges running among them.</p><p>Since G is assumed not to fit in RAM (which we assume to be larger than the available screen S) we need to compute a T-view whose number of edges fits in memory(M). We show next how to obtain such RAM bounded T-views for an external memory graph (see the pseudo code for the function Cover). The idea is to descend from the root in the hierarchy tree by expanding (see definition in section 3.2) only those nodes in the current antichain with the greatest degree provided that their substitution by their children still fits in RAM (i.e. the obtained antichain size is less than |M| ).</p><p>Function Cover (Size |M|, Tree RT )</p><p>• Input: An upper bound |M|, an enhanced and regularized hierarchy tree RT for a multidigraph G.</p><p>• Output: A greedy RT-Cover C with no more than |M| elements such that Maximum outdegree(C), indegree(C) is minimum. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Antichain Driven Navigation</head><p>Using the combination of hierarchy tree regularization, memory bounded T-covers and a fast index to retrieve graph slices one can process in principle any secondary storage multi-digraph defined on millions of vertices provided that an explicit enhanced hierarchy tree T is provided. In order to provide reasonable levels of interactivity we focus next on tuning the navigation process . This is achieved by allowing the interface to jump directly from a virtual multi-edge (p, q) to a view T p,q whose number of multi-edges is not more than |S| . Such view is obtained by invoking the function Cover twice with input T p and T q and screen parameter |S| and taking the bottom up aggregation of details(p, q) determined by the two obtained local antichains (i.e. local tree covers, see figure 2). We call the obtained view T p,q the local cross product view of the multi-edge (p, q). Its number of multi-edges is certainly not more than |S| (the specified screen budget). Using this process we can quickly navigate the entire tree without having to click through each individual level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Overall Computational Flow</head><p>We present next the overall view of the main computations involved in preparing a data set for interface navigation. II.Enhance the hierarchy tree RT Traverse RT in dfs (depth first search) order from the root assigning to every node p ∈ RT , the min and max dfs values in the set Leaves(RT p ). The interval of dfs numbers between these two values is a subset of the interval I(p) defined in section. We refer to this subinterval as LI(p).</p><p>Store with node p, the values in(p) and out(p), of the sum of all the indegrees and outdegrees of its descendant leaves( i.e. the nodes in Leaves(RT p )).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Build a gkd index to access E(G) according to RT [4]</head><p>IV. Compute a T M view of G using the subintervals LI(p) defined above Compute C M = Cover ( |M|, RT ) and use the mapping that associates with every p in C M the interval of dfs numbers LI(p) to externally sort E(G) and aggregate the results according to the cover C M . The obtained multi digraph is a T M view of G. Based on edge density greedily select a subset of virtual multi-edges in T M and use the gkd index to cache their corresponding subgraphs. In order to guarantee that the cover T S is smaller than T M we perform an upward aggregation of nodes in T M . Let Temp denote the subtree of RT consisting of its root and all the paths from it to the elements of C M , i.e. Leaves(Temp) = C M . Consider C M to be the antichain consisting of all the parent nodes of elements in C M . A node p in C M can be added to C M and its children can be deleted from C M if the sum of the degrees of p's children is minimum. The process is iterated until one antichain is found whose cardinality is not more than |S|. Call this antichain C S . Aggregation of T M according to C S provides a view T S of T M (which in turn is a view of G) that can be embedded on the available screen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Compute from T M a bottom up T S view</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Prepare for antichains driven navigation</head><p>For every node p in C S compute Cover( |S| ,RT p ). For specially selected virtual multi-edges (p, q) where p and q are in C S , compute in memory all the multi-edges between Cover( |S| ,RT p ) and Cover(|S|, RT q ). This is done by aggregating the in memory resident T M view of G. Those multi-edges for which this T p , q view is not precomputed are computed on demand from the interface.</p><p>The I/O complexity of the overall computation is dominated by the gkd index construction and by the number of virtual edges (p, q) that we want to cache. This is necessary in order to offer a reasonable level of interactivity (Steps III and IV above). The internal computation is dominated by the time taken to aggregate the in memory resident T M view of G.</p><p>In the next section we discuss how these notions translate into visual navigation of a semi-external memory graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MATRIX ZOOM: A MATRIX DRIVEN INTERFACE</head><p>Providing visual access to detailed information within a global context is certainly one of the fundamental problems in Information Visualization. We provide views of semi-external memory graphs at different levels of abstraction by using the graph's adjacency matrix as a unifying mechanism when visually navigating "large" hierarchical clusterings(see <ref type="figure" target="#fig_3">Figure 3</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Detail and Context</head><p>The interface <ref type="figure" target="#fig_3">(Figure 3</ref>) is designed around a canvas that displays a visual representation of an aggregate matrix view of the data. The labels, appearing on the bottom row and rightmost column, index the attributes being considered. The color of the rectangles corresponds to the proportion of data records that share the corresponding attributes. The color scale is tuned depending on data characteristics. For cancer data and phone traffic we found that a logarithmic color map performs better because of the wide range of the density parameter, ranging from 1 to 10 −6 .</p><p>Using the terminology of the previous section, the canvas displays a color mapped representation of a T (p,q) view of a data sub-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Whole subgraph</head><p>Nodes with peel &gt; 1 Nodes with peel &gt; 2 Nodes with peel &gt; 3 graph. The subtrees involved (i.e. T p and T q ) are color marked in two special screen regions (next to the "axes") reserved for a sketch representation of the hierarchy tree. The cross product of Leaves(T p ) and Leaves(T q ) corresponds to the canvas region. The relative position of this region within the entire data set is indicated in the global overview which resides at the North-West corner of the interface. The explicit and fixed representation of the hierarchy tree next to the canvas region is a feature that to our knowledge had not been addressed properly in the past. This is a very effective way to keep a uniform and global view of the data without cluttering the display. It is flexible in the sense that its representation can be altered to suit specific data domains. For example, if a subtree of the hierarchy tree represents a collection of geographical attributes the representation can be changed to that of a physical map with the corresponding subdivisions. In case of communications traffic on a geographical space the canvas corresponds to the "cross product" of the two geographical maps. In the case of cancer incidence data, the data can be viewed as a subset of the cross product of two hierarchies. One being the geography where the patients population resides and the other being a cancer specific hierarchy that incorporates oncological information. Another way to provide context when navigating the matrix is by rendering the parent matrix T parent(p),parent(q) , along with an indication of the area the user is currently browsing in a fixed section of the interface (visible in the top left of <ref type="figure" target="#fig_3">figure 3)</ref>. This helps the user to mentally maintain the navigation history, reducing the chance that he or she loses the global context when browsing the matrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Switching to node link diagrams</head><p>As discussed in the introduction node link diagrams are not well suited if one needs to navigate hierarchical graph views at different levels of granularity. However, if a sparse graph fits on the screen it makes sense to draw its corresponding node link diagram. This corresponds simply to switching the canvas display to a node link diagram if the corresponding subgraph is at the lowest desired level of granularity, if its number of edges is not more than |S| and if its density is below certain threshold (i.e. it is sparse). Because of its flexibility we have chosen a spring embedder algorithm <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b6">7]</ref> to generate a layout. According to our experience, it is also desirable to attach some ranking to the nodes depending on the application domain. For example, in the case of SEER cancer data, since the vertices are patients and attribute values, assigning some measure of relevance to the attributes is one important epidemiological question. We rank the graph vertices according to their "peeling numbers" <ref type="bibr" target="#b11">[12]</ref>.</p><p>Peeling is a time ordered process that permutes the vertices of a graph by visiting, in non decreasing order of degrees, the adjacency list of each vertex exactly once and reducing the degree of each of its highest degree neighbors by one. The order in which the vertices adjacency lists get visited is the peeling order. The current degree of a vertex when its adjacency list is visited is its peeling number. It is apparent that the peeling number of a vertex must be less than or equal to its degree. Vertices with the highest "peel" number are in some sense the most relevant in the data set, because they indicate a highly connected subset. If for example a large number of patients with a disease all share the same properties there might be a correlation between this disease and the properties.</p><p>The interface provides user interaction, with screen bounded node link layouts, by providing a color map slider that "peels" the layout according to the vertices peeling values. The edges are colored according to a refined version of the density color map used in the matrix view (see <ref type="figure" target="#fig_4">Figure 4)</ref>. The node link layout and the corresponding matrix view are linked. This feature is helpful in assessing the type of information that is more easily discernible from the matrix view versus the corresponding node-link diagram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Interaction</head><p>The user is allowed to zoom into any subcell currently visible on the screen. Mathematically this corresponds to selecting two nodes T p and T q in the current antichains and displaying expansion(T p , T q ) on the screen. Zooming out of expansion(p, q) corresponds to displaying expansion(parent(p),parent(q)). To help the user maintain context we use smooth interpolation between the two views, similar to the one used in <ref type="bibr" target="#b13">[14]</ref>. A major improvement is that we no longer require both nodes to be at the same level in the tree. Since we are retrieving edges on the fly, arbitrary sets of rows and columns can be collapsed or expanded by clicking on their respective labels. This corresponds to selecting one node p in an antichain and replacing it with children(T p ). Instead of zooming manually, the user can also opt to jump directly to a farther out antichain computed by the visualization by shift clicking on a specific cell.</p><p>We adjust the aspect ratio of the newly displayed matrix to match the screen aspect ratio. This helps us to make more effective use of screen space and avoids displaying matrices with a very unfavorable aspect ratio. Furthermore, the user can hide any row or column or have the system hide automatically any rows and columns that do not contain any data. This allows us to display sparse matrices much more efficiently. To facilitate interaction with large matrices we also implemented a geometrical zoom which allows the user to select any area of the canvas and view it in closeup. Since many of the subcells in the matrix have widely differing sizes, using a linear size mapping would make some subcells inaccessible because their relative size is simply too small. We therefore applied a logarithmic screen mapping that preserves size order but still keeps the smallest a b c subcells visible at all times. Semantics feedback is provided by static and dynamic labels. Static column and row labels describe the nodes in the graph. Dynamic labels provide information on the matrix cells (i.e. multi edges) currently displayed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">TWO SAMPLE DATA SETS</head><p>We have navigated SEER cancer incidence and survival data for US patients from 1973 up to 2003. We have also used our interface to depict the type of hierarchy obtained by a recursive algorithm that produces connectivity based clusters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Navigating SEER Cancer Data</head><p>SEER <ref type="bibr" target="#b7">[8]</ref> stands for the Surveillance, Epidemiology and End Results program of the US National Cancer Institute. It is an authoritative source of data on cancer incidence and survival. Each record consists of 72 items that provide specific cancer diagnosis and treatment information, patient demographics and geographical and temporal data. SEER data is widely utilized to identify geographic and population differences in cancer patterns, to investigate environmental factors that influence cancer incidence and survival, and to study cancer treatment outcomes. Standard epidemiological techniques include regression methods and comparison of a variety of rates and ratios. A central question of interest is to identify "clusters" or other "useful" structure in the underlying data. The approach is to use this structural information as a trigger to stimulate further processing and analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Data Model</head><p>We view the data as a bipartite graph from the set of patients to the set of attribute values. The set of patients is endowed with a geographical hierarchy with 20 subtrees corresponding to the 20 SEER registries (visible on the left hand side of the canvas, see <ref type="figure" target="#fig_3">Figure  3</ref>.5). Following epidemiologists advise, we extracted 17 attributes and build a hierarchy for them (visible at the top of <ref type="figure" target="#fig_3">Figure 3</ref>.5). This hierarchy consists of separate subtrees for cancer specific information such as primary cancer site and tumor size; treatment type (surgery, amount of radiation); temporal information (diagnosis date, age, etc) and patient demographics. This ad-hoc separation is based on the arguable assumption that geographical, temporal and demographic information may shed light on factors contributing to cancer detection and treatment. From our point of view, this is the place where strong interaction with domain experts is necessary in order to obtain specific application semantics that can be incorporated in a "useful" manner into any interface. Our approach is then to provide the interface with mechanisms that allow the user to plug hierarchy subtrees that are in his/her view more appropriate for an specific task and application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Colon Rectal, Prostate and Skin Cancer Data Sets</head><p>After the SEER data for Colon Rectal, Prostate and Skin cancer were transformed into graphs they had 437738, 358783 , 142406 vertices and 5182643, 5526803 , 1866531 edges respectively. As a byproduct of this transformation we automatically identified all those patients with missing data and all those attribute values that are complementary (i.e. Male, Female) or extremely rare (Data anomalies). So the computational infrastructure did clean the data in several ways not anticipated by us. Among the interesting typical findings we mention the following:</p><p>• The skin cancer age distribution in San Francisco county in the San Francisco -Oakland registry shows a peak (dark red area) at around 35-36 years of age. This peak is not present in other counties in the same registry. Note that the cause of this might be anything from more sun(bathing), higher skin cancer awareness in San Francisco county or simply a younger overall population, so it's very hard to draw immediate conclusions from this observation. Nevertheless, it is interesting enough to investigate further. (See figure 5a);</p><p>• Skin cancer race distribution in Iowa is severely tilted to whites. This might again be a consequence of the racial distribution in Iowa (likely) or it might be that whites are more susceptible to skin cancer (also likely). To answer these questions the data must be compared to the population distribution. (See <ref type="figure" target="#fig_5">figure 5b)</ref>.</p><p>We want to point out that our knowledge of epidemiology is very cursory and our intention is to show that with some guidance from domain experts one can enhance the interface to find "automatically" patterns like the ones described above. The reason is that these findings did not require a priori information that we could use to direct our search. A pundit could say that all of this could have been done by just using a data base query system. The point is well taken if the user knows precisely what he is looking for. However, we work under the premise that very often this is not the case. What we offer is a tool that can help domain experts formulate quickly a set of hypothesis for further analysis. It is a visual and intuitive exploratory data analysis tool that may help the user get a quick glimpse over the entire data space in a hierarchical manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Navigating aggregate US phone traffic</head><p>The work described in <ref type="bibr" target="#b2">[3]</ref> reports on the use of an external algorithm that produces a hierarchy for a phone traffic graph with over 260 million vertices (US telephone numbers) and over 4.3 billion edges (phone calls for a period of over 20 days). We did wonder if we could use our interface to navigate a restricted macro-view of the obtained hierarchy (since we have no access to the corresponding lower level data).</p><p>In this case, the tool was used to navigate a chopped hierarchy of maximum spanning forests. Contrary to the SEER data set both axes of the matrix display the same hierarchy. A subcell of the canvas depicts a maximum spanning subtree. It connects two other maximum spanning subtrees of previously connected subgraphs that were formed during the clustering algorithm recursion <ref type="figure" target="#fig_5">(See figure 5c)</ref>. In other words, the depicted hierarchy trees together with the canvas show an anatomical description of a giant semi-external graph which the first author had not seen before even though he had previously worked with the corresponding data set.</p><p>Previous approaches <ref type="bibr" target="#b2">[3]</ref> to produce a global image of such monster graphs were handicapped by the need to zoom into multi-edges which, as we alluded in the introduction, is the fundamental barrier to semantic zooming on node link diagrams. In summary, our interface has moved us closer to the challenging task of producing visual graph representations that can be navigated efficiently when just the vertex set of the graph fits in RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FURTHER WORK</head><p>We have presented a framework for the interactive navigation of (semi-)external graphs. The method assumes a given hierarchy and uses it to construct a hierarchy of adjacency matrices. This collection of matrices can then be navigated interactively. More concretely our major contributions are:</p><p>• Parametrization and scalability: Our framework is parameterized in terms of memory and screen size and is able to deal with semi-external graphs. Most other visualizations don't even deal with this case in which the graph does not fit in RAM. Parametrization also allows us to decide on the fly when we can switch from matrix views to node link diagrams or other suitable representations.</p><p>• Efficient navigation: by using antichains for navigation the user does not have to click through multiple (possibly sparse) layers in the hierarchy to view a subgraph. Instead we compute generalized views that just fit the available screen space.</p><p>• Flexibility: The ability to plug arbitrary hierarchy trees into the visualization allows us to navigate any kind of relational data no matter its size. Subcell coloring can be done on arbitrary measures, depending on the task the user wants to perform. This means that Matrix Zoom is applicable to a wide range of data domains.</p><p>• Strong visual coupling between graph hierarchies and the display: this is in our view a major improvement over previous attempts to semi-external graph navigation.</p><p>We have applied our method to semi-external graphs (with more than 5 million edges) resulting in a number of interesting patterns. Because neither of the authors has an epidemiological background their real life value will be evaluated by domain experts, but they clearly show the serendipitous nature of the provided interface. Future work will focus on enhancements to the interface that facilitate user's queries. Concretely we will provide partially automated navigation to help the user search for dense subgraphs.</p><p>As an extension on the data side, we will add features to navigate fully external graphs. This can be achieved by moving the part of the graph below the antichain T M to a server, which has its own gkd-index to answer user queries that fall below T M .</p><p>An important improvement on the visualization side is to incorporate small glyphs (such as barcharts or starglyphs) on top of the matrix view, to display a set of density values instead of a single density value per cell. This will allow us to compare related or time dependent parameters visually. For example, how does colon cancer compare with prostate, and skin cancer in the US? Note that such queries are not easily answered using node link diagrams. The resulting differences in layouts make it hard to compare different visualizations. Visualization of time dependent relational data by using adjacency matrices will be an interesting research path to explore in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Schematic illustration of graph theoretic concepts. The set of dark nodes is a sample of a maximal antichain for this tree. The operation details(p,q) returns the subgraph consisting of all leaf nodes and the dotted edges(painted blue), while expansion(p,q) yields the subgraph consisting of edges with both endpoints at depth 2(painted red).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>begin C = root(RT ); currentCoverSize = 1; degree = outdegree(C) = indegree(C) = |E(G)|; C = sort C by non-decreasing order of out degree; notFinished = true; while (notFinished) do for each p in C do if ( |children(p)| + currentCoverSize -1 &lt; |M| ) then newC = newC ∪ children(p)p; currentCoversSize = |newC| if (|newC| = |C|) then notFinished = false; C = newC; end</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Schematic depiction of antichain driven navigation. The antichain T M is a cover of an external tree T , indicating the part of the tree that fits in RAM. The antichain T S is a smaller cover of T that fits on screen. When quick-zooming into and edge (p, q) we compute new antichains on T p and T q and display the crossproduct of both antichains T p,q .• Input: Memory and Screen Parameters, |M| and |S|. A disk resident multi-digraph G = (V, E, m : V ×V → R+) with the in and out degree of each vertex. A memory resident hierarchy tree T for G with a domain specific label associated to each node of T. • Output: Two macro views T M and T S of G with the first one bounded by |M| and the second one bounded by |S|. I. Screen Regularization of T RT = Regularize(T , |S|)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>A screenshot of the interface, showing racial distribution for colon cancer cases in Connecticut counties. The overview window is in the top left, hierarchy trees are on the top and left of the matrix, node labels are on the bottom and right. Three counties (rows 1,2 and 5) show more diversified racial distributions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Node link view of part of the SEER data set. Blue nodes are properties, green nodes are patients. Consecutive peeling reveals a small clique of patients (green) that have at least four properties (blue) in common.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>(a) Distribution of skin cancer versus age in the San Francisco -Oakland register, showing a peak at earlier ages in San Francisco (4th row), (b) Distribution of skin cancer versus race in Iowa's counties and (c) high level view of a spanning tree of a 260 million node graph, detailing phone traffic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>•</head><label></label><figDesc>Output: A hierarchy tree RT for G such that each node in RT has at most |S| children.</figDesc><table><row><cell>begin</cell></row><row><cell>for each node n in T in BFS order do</cell></row><row><cell>RegularizeNode(n,S);</cell></row><row><cell>end;</cell></row><row><cell>function RegularizeNode(Node p, Size S)</cell></row><row><cell>begin</cell></row><row><cell>if nrchildren(p) &gt; S then</cell></row><row><cell>if nrisolatedvertices(children(p)) &gt; 0 then</cell></row><row><cell>group all isolated vertices under new parent</cell></row><row><cell>else</cell></row><row><cell>if nrleafchld(p) &gt; 0 and nrleafchld(p) &lt; nrchld(p) then</cell></row><row><cell>group all leafnodes under new parentnode</cell></row><row><cell>else</cell></row><row><cell>subdivide children under |S| new parentnodes;</cell></row><row><cell>end;</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors thank Fred Roberts for his encouragement and acknowledge the support provided by DIMACS and the US national Science Foundation under grants NSF CCR 00-87022 and NSF EIA 02-05116, as well as the Netherlands Organisation for Scientific Research (NWO) under grant 612.000.101. Many thanks to Professor Dona Schneider, and especially to Dave Millman for the many hours devoted to the preprocessing of SEER cancer data. Stephen Kobourov and Sandra Sudarsky entertained some discussions related to graph peeling.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A functional approach to external graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Buchsbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Westbrook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="437" to="458" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mgv: a system for visualizing massive multidigraphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Korn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="21" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Navigating giga-graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kreuseler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Proceedings of Advanced Visualization Interfaces(AVI)</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="290" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hierarchical graph indexing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Information and Knowledge Management(CIKM)</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="453" to="460" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Recent directions in netlist partitioning: A survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Charles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Alpert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kahng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, University of California at Los Angeles</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Clustering relational data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladimir</forename><surname>Batagelj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anuska</forename><surname>Ferligoj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Analysis</title>
		<editor>Gaul, Opitz, and Schader</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="3" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A heuristic for graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Congressus Numerantium</title>
		<imprint>
			<date type="published" when="1984" />
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">Seer cancer statistics review</title>
		<editor>L.A.G. Ries et al.</editor>
		<imprint>
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Graph drawing by force-directed placement. Software -Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M J</forename><surname>Fruchterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Reingold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1129" to="1164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Graph-based hierarchical conceptual clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Istvan</forename><surname>Jonyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><forename type="middle">B</forename><surname>Holder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Diane</forename><forename type="middle">J</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Artificial Intelligence Tools</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="107" to="135" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On spectral graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yehuda</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The Ninth International Computing and Combinatorics Conference (CO-COON&apos;03)</title>
		<meeting>The Ninth International Computing and Combinatorics Conference (CO-COON&apos;03)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="496" to="508" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Network structure and minimum degree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Seidman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="269" to="287" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Spectral partitioning works: Planar graphs and finite element meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Spielman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 37th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="96" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Using multilevel call matrices in large software projects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Frank Van Ham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symp. on Information Visualization</title>
		<meeting>of IEEE Symp. on Information Visualization</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="227" to="232" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
