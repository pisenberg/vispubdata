<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Drawing of Clustered Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaniv</forename><surname>Frishman</surname></persName>
							<email>frishman@tx.technion.ac.il</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ayellet</forename><surname>Tal</surname></persName>
							<email>ayellet@ee.technion.ac.il</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Technion -Israel Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering Technion -Israel Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Drawing of Clustered Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.8 [Computer graphics]: Applications; H.4.3 [Information systems applications]: Communications applications-Information browsers H.5.2 [Information interfaces and presentation]: User Interfaces-Graphical user interfaces C.2.4 [Computer-communication networks]: Distributed systems-Distributed applications graph drawing</term>
					<term>dynamic layout</term>
					<term>mobile objects</term>
					<term>software visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents an algorithm for drawing a sequence of graphs that contain an inherent grouping of their vertex set into clusters. It differs from previous work on dynamic graph drawing in the emphasis that is put on maintaining the clustered structure of the graph during incremental layout. The algorithm works online and allows arbitrary modifications to the graph. It is generic and can be implemented using a wide range of static force-directed graph layout tools. The paper introduces several metrics for measuring layout quality of dynamic clustered graphs. The performance of our algorithm is analyzed using these metrics. The algorithm has been successfully applied to visualizing mobile object software.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graphs are an important data structure for describing relationships between objects (e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b9">10]</ref>). The need to draw (i.e. layout) graphs appears in many applications and as such, is an active area of research in information visualization <ref type="bibr" target="#b15">[16]</ref>. In clustered graphs, the vertices are divided between a set of components called clusters, which form a partition of the vertex set. In some applications, the graphs are inherently clustered <ref type="bibr" target="#b3">[4]</ref>. In other cases, clustering has been successfully used in order to aid in the visualization of graphs <ref type="bibr" target="#b31">[32]</ref>.</p><p>Many applications require the ability of dynamic graph drawing, i.e., the ability of modifying the graph <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b2">3]</ref>. Different types of graph modifications may be performed: adding vertices and clusters, moving vertices between clusters, removing edges, etc. The challenge in dynamic graph drawing is to compute a new layout that is both aesthetically pleasing as it stands and fits well into the sequence of drawings of the evolving graph. The latter criterion has been termed preserving the mental map <ref type="bibr" target="#b21">[22]</ref> or dynamic stability <ref type="bibr" target="#b22">[23]</ref>. A short animation sequence showing incremental layouts of clustered graphs computed by our algorithm is shown in <ref type="figure" target="#fig_0">Figure 1</ref>. In this dynamic scenario, vertices move between clusters and thus the size of clusters change, edges are added, and clusters are added and removed. Yet, the relative locations of the clusters and the vertices are preserved, while allowing changes in the size of clusters when deemed necessary. One field in which clustered graphs arise is software visualization, and in particular, visualization of mobile object frameworks <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b20">21]</ref>. Such frameworks extend the distributed objects concept <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b25">26]</ref> in allowing the objects to migrate to remote hosts, along with their state and behavior, while the application is executing (in order to speed up interaction).</p><p>In these frameworks, the notion of a dynamic clustered graph arises quite naturally. Every object is represented by a vertex in the graph. A machine is represented as a cluster that contains the objects currently residing in it. The area occupied by a cluster is used as a visual clue to the user regarding the number of objects located in the machine represented by the cluster. Naturally, the graph being visualized evolves with time, as objects migrate between machines and machines connect and disconnect from the network. Our algorithm has been designed to show these interactions.</p><p>The general problem of drawing graphs, e.g., assigning coordinates to graph vertices, edges and other elements, has been extensively studied <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b7">8]</ref>. One popular technique is force-directed layout, which uses physical analogies in order to converge to an aesthetically pleasing drawing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b18">19]</ref>. Drawing non-point vertices using this approach is discussed in <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">15]</ref>. Extending force-directed algorithms for drawing large graphs is discussed in <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b28">29]</ref>.</p><p>Work on clustered graph drawing is less widespread. In <ref type="bibr" target="#b29">[30]</ref>, a divide and conquer approach, in which each cluster is laid out separately and then the clusters are composed to form the graph, is used. In <ref type="bibr" target="#b10">[11]</ref>, a method of drawing the clustering hierarchies of the graph using different Z coordinates in a 3D view is discussed. See  also <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b0">1]</ref> for a discussion of clustered and compound graph layout.</p><p>Incremental drawing of directed acyclic graphs is discussed in <ref type="bibr" target="#b22">[23]</ref>, which uses a modification of the Sugiyama algorithm <ref type="bibr" target="#b24">[25]</ref> in order to draw ranked digraphs. An algorithm for computing the layout of a sequence of graphs offline is described in <ref type="bibr" target="#b8">[9]</ref>. The algorithm is based on using different adjustment strategies in order to compute the new layout. The DA-TU system described in <ref type="bibr" target="#b17">[18]</ref> allows navigating and interactively clustering huge graphs. Finally, some commercial graph layout packages such as <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b30">31]</ref> contain provisions for dynamic layout of graphs. As far as we know, none of the above was designed to handle incremental drawing of clustered graphs.</p><p>In this paper we propose a new algorithm for online incremental layout of clustered graphs. The algorithm does not impose restrictions on the structure of the graph. It allows drawing of edges not only between vertices but also between clusters, which is used to convey information to the user. The algorithm provides a means of separating the set of vertices in each cluster to a subset of vertices that stay in the same cluster and a subset of vertices that might move to a different cluster. The layout of the vertices inside the cluster is influenced by this separation.</p><p>The major design consideration of our algorithm is preserving the mental map while the graph is being updated. We show that force directed layout techniques <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b18">19]</ref> can be used as a basic building block. However, they cannot be used as is, as demonstrated in <ref type="figure" target="#fig_2">Figure 2</ref>(a), where clusters and vertices move considerably between successive drawings. We propose a few enhancements to existing algorithms in order to preserve the mental map, as shown in <ref type="figure" target="#fig_2">Figure 2</ref>(b), where only small variations in cluster location and size are exhibited. Also note the stability of the vertices inside the clusters as opposed to the non-incremental layout.</p><p>A key consideration in designing algorithms is the desirable properties of the results. This paper proposes several criteria for evaluating the quality of dynamic clustered graphs. They include space compactness, minimization of the changes between frames and run-time efficiency. We demonstrate that our algorithm performs well according to these properties. Moreover, we show that this is the case when considering a software visualization application.</p><p>The rest of this paper is structured as follows. Section 2 defines the problem. Section 3 describes the algorithm. A software visualization application is presented in Section 4. Finally, Section 5 concludes and discusses future directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PROBLEM STATEMENT</head><p>This section defines clustered graphs and possible graph updates. It also discusses criteria by which the quality and stability of the layout is evaluated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1 Partition: A k-way partition of a set C is a family of subsets</head><formula xml:id="formula_0">(C 1 ,C 2 , . . . ,C k ) such that k i=1 C i = C and C i ∩ C j = / 0 for i = j.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2 Clustered Graph: A clustered graph is an ordered quadruple</head><formula xml:id="formula_1">G = (V,C, E v , E c ), where V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>is the vertex set, C is a set of clusters which form a partition of the vertex set</head><formula xml:id="formula_2">V , E v is the set of vertex-vertex edges E v ⊆ (v i , v j )|i = j, v i , v j ∈ V and E c is the set of cluster-cluster edges E c ⊆ (C i ,C j )|i = j,C i ,C j ∈ C .</formula><p>Given a series of clustered graphs G 1 , G 2 , . . . , G n , the goal of the algorithm is to produce a sequence of layouts</p><formula xml:id="formula_3">L 1 , L 2 , . . . , L n , where L i is a drawing of G i , such that the sets V i , C i , E v i , E c i are assigned coordinates.</formula><p>Since the sequence of graphs G i is not known in advance, the algorithm is an online algorithm. The updates U i that can be performed between successive elements G i−1 and G i are: Adding or removing vertices, edges or clusters, and modifying the partition of vertices into clusters (i.e. moving vertices between clusters).</p><p>A key issue in incremental graph drawing is the stability of the layouts <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref>. This is important since a user looking at a graph drawing gradually becomes familiar with the structure of the graph. We propose the following criteria for evaluating the quality of the layout:</p><p>1. The movement of clusters between successive drawings should be small. Specifically, clusters that are not modified should remain in their previous position if possible.</p><p>2. The change in the size of clusters between successive drawings should be minimal, when the number of vertices in the cluster is similar.</p><p>3. Movement of vertices inside a cluster should be minimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>The size of each cluster C i should be proportional to the number of vertices it contains.</p><p>5. The drawing of each cluster C i should be compact.</p><p>6. Overlapping between vertices should be avoided and overlapping between cluster boundaries should be minimal.</p><p>Our application to software visualization adds an additional requirement. The vertices in each cluster are divided into two subsets, static objects that remain at the same cluster throughout the animation and movable objects. This should become visually apparent.</p><p>Note that there are classical aesthetic criteria such as the number of edge crossings, the total edge length, etc. which we ignore here. However, the underlying static algorithm used addresses these criteria.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE ALGORITHM</head><p>Given a sequence of clustered graphs G 1 , G 2 , . . . , G n , our goal is to compute a sequence of graph layouts L 1 , L 2 , . . . , L n , so as to adhere as much as possible to the criteria discussed in Section 2. A possible approach is to develop an incremental algorithm for drawing clustered graphs from the ground up. A different approach, which we have pursued, is to use an existing non-incremental graph layout algorithm as a basic block, and build the incremental layout capability on top.</p><p>Among the different classes of graph drawing algorithms, the force directed algorithm class seems to be the natural choice in our case <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10]</ref>. Roughly speaking, this approach simulates a system of forces defined on the input graph and outputs a local minimum energy configuration. An edge is simulated by a spring connecting its endpoint vertices. Edge length influences the optimal spring length and edge weight determines its stiffness. The algorithm converges towards a minimum energy position, starting from an initial placement of the vertices. In our case, the previous layout, L i−1 , can be used as a starting position for the new layout, L i . Extending a force directed algorithm to perform a layout of clustered graphs is discussed in Section 3.2.</p><p>Our algorithm's requirements from the underlying force-directed static layout algorithm are that there exist ways to assign initial coordinates to vertices, to restrict their movement, to set edge lengths and to add support for drawing clusters. Since little assumptions are made regarding the underlying layout algorithm, a wide variety of existing layout tools can be used. As such, our algorithm can add incremental layout capabilities to most existing packages.</p><p>In our implementation we use the GraphViz graph drawing package <ref type="bibr" target="#b11">[12]</ref> and its force directed layout component, Neato <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b18">19]</ref>. Neato avoids overlaps between vertices and allows setting preferred edge lengths and weights. It also allows pinning down vertices. Pinned vertices are not moved while the algorithm converges by moving vertices according to the forces acting on them. However, Neato neither supports clustered graphs nor does it support controlling the repulsive forces between vertices. These deficiencies are addressed by our algorithm, as will be described next.</p><p>We adopt the proposition made in <ref type="bibr" target="#b22">[23]</ref> that vertex stability is more crucial than edge stability. Specifically, we prefer changing edge lengths rather than moving vertices. Moreover, in our case, cluster stability is more significant than vertex stability. Thus, our algorithm utilizes the following key ideas.</p><p>First, dummy vertices and edges are used in order to create a clustered structure. Since clusters are treated as vertices, their motion can be controlled. Second, invisible place-holder vertices are used in order to minimize the movement of clusters and of vertices within clusters. This is done while maintaining compactness and keeping the size of the clusters proportional to the number of vertices they contain. Third, edge length and weight are used as a means of controlling the changes made to the layout. Fourth, to achieve both dynamic stability and distinguish between stable and movable vertices, the set of vertices is partitioned into two sub-sets -stable and movable. The subsets are laid out in a structure that approximates two concentric circles around the center of the cluster. Static objects are placed in the inner circle and movable objects in the outer one.</p><p>These ideas are elaborated in this section. After outlining the algorithm, various phases and aspects of the algorithm are discussed in detail, including cluster support, minimization of visual changes, and animations of graph updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>To compute layout L i , only the last layout, L i−1 , and the new graph that needs to be laid out, G i , are used. This is a fast and simple approach that fits well with the view that incremental layout performs some local changes in the graph. In other words, the previous layout is considered as a good starting point for the new layout, with some adjustments made according to the changes that occurred.</p><p>The first step in computing the new layout, described in Section 3.4, is a merge stage, which merges layout L i−1 and graph G i . In the second stage, an actual layout, L <ref type="bibr" target="#b0">1</ref> i , is computed using a static force directed layout algorithm with the modifications described in Sections 3.2-3.3. In the third stage, the quality of this layout is checked, as described in Section 3.5. If the layout is deemed satisfactory, it is accepted and L i = L <ref type="bibr" target="#b0">1</ref> i . Otherwise, a second layout attempt is performed, producing layout L 2</p><p>i . During this attempt, more freedom is given to the layout algorithm in terms of moving vertices, at the expense of weakening the connection between the old and the new layouts. The better of L <ref type="bibr" target="#b0">1</ref> i and L 2 i is selected as the final drawing L i . The final stage of the algorithm, described in Section 3.6, animates the change between the drawings L i−1 and L i in a smooth manner. The algorithm is summarized in <ref type="figure" target="#fig_3">Figure 3</ref>. </p><formula xml:id="formula_4">procedure incremental drawing ( L i−1 , G i ) { G m i = merge graphs ( L i−1 , G i ) L 1 i = layout graph ( G m i ) if ( L 1 i is good enough ) L i = L 1 i else { L 2 i = layout graph ( modify graph ( L 1 i ) ) L i = better ( L 2 i , L 1 i ) } animate change ( L i−1 , L i ) }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Supporting Clusters</head><p>Adding an invisible dummy attractor vertex to each cluster, to which all of the vertices in the cluster are connected with invisible edges, is proposed in <ref type="bibr" target="#b3">[4]</ref>, where repulsive forces are also used, in order to increase cluster separation. One of the approaches discussed is a divide and conquer algorithm, in which the clusters are first laid out separately and then the different layouts are composed together. A hybrid approach that solves the problem of neglecting inter-cluster edges, caused by this algorithm, is discussed in <ref type="bibr" target="#b29">[30]</ref>.</p><p>We follow the approach of adding a dummy vertex to each cluster. However, separation between the clusters and meeting the other requirements described in Section 2, is achieved differently. It is accomplished through proper settings of edge lengths and weights, as described below.</p><p>Five kinds of edge lengths are utilized and indicate the expected level of proximity between their adjacent vertices. The shortest length is assigned to the invisible edges connecting static vertices to the dummy vertex of the cluster they belong to. The edges connecting movable vertices and the dummy vertex are assigned longer lengths. This creates a layout that resembles two concentric circles. The next type of edges is the edges between vertices. If both vertices at the endpoints of the edge are contained in the same cluster, a shorter length is set than if the vertices are in different clusters. This increases the separation between clusters. The last kind of edges are cluster-cluster edges. The length of these edges is variable and depends on the requested proximity between the different clusters, which is determined by the application, e.g., by the amount of interaction between clusters.</p><p>Edge weights are also used in our algorithm. Higher edge weights instruct the underlying force-directed algorithm to try harder to generate edges with lengths close to the optimal lengths supplied to the algorithm (as discussed above). Inter-cluster edges are assigned lower weights than intra-cluster edges. This is done in an attempt to give inter-cluster edges less influence on the layout. This is important when vertices move between clusters. In such cases, it is preferable to stretch or shorten the length of the edges somewhat, rather than displace vertices.</p><p>In our implementation, the lengths assigned to the edges connecting a static vertex to a dummy vertex, a movable vertex to a dummy vertex, two regular vertices in the same cluster and two regular vertices located in different clusters, are 1, 2, 1.5 and 4 units of length, respectively. The lengths assigned to cluster-cluster edges vary between 5 and 6 units, where the dummy vertices are used as endpoints for cluster-cluster edges. The weight of intra-cluster edges is set to 1 unit and the weight of inter-cluster edges is set to 2.5 units.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Minimizing Visual Changes</head><p>Invisible vertices, called spacer vertices, are added to each cluster, in an attempt to reduce the change in clusters' outlines and minimize the movement of clusters between successive layouts.</p><p>The spacer vertices are used as place-holders for regular vertices in a cluster. They are connected with invisible edges to the dummy vertex of the cluster to which they belong, like any other vertex in the cluster. When a vertex is removed from a cluster, a spacer vertex is added to the cluster instead of it. The initial location of the spacer vertex is set to be the location of the vertex that left the cluster. This is done in order to keep the size of the cluster constant and in order to reserve space for a new vertex that might be added to the cluster in the future. When a vertex moves (or is added) to a cluster, the spacer vertex that is closest to its previous location is replaced by this new vertex.</p><p>However, when adding or removing spacers, the algorithm keeps the number of spacers in a cluster between an upper and a lower fraction of the number of vertices in the cluster. This is done in order to give the algorithm breathing room when modifying clusters. Moreover, the limits are set so as to avoid a case in which a cluster with a very small number of regular, visible vertices occupies a large area due to the many spacer vertices it contains.</p><p>When calculating the outline of each cluster, which is often simply the bounding box, the spacer vertices are taken into account as if they were regular visible vertices. Obviously, this minimization of the movements comes at the expense of extra screen space, which is occupied by the spacers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Merging Graphs</head><p>The first step in performing the incremental layout is merging the new graph to be drawn, G i , and the previous graph drawing, L i−1 . The result of the merge stage is a partially laid out graph, G m i , in which some of the vertices are assigned initial coordinates. After merging, the graph G m i is laid-out by the static layout algorithm.</p><p>The quality of the resulting incremental layout depends on the initial conditions computed by the merging algorithm. Merging is performed in several steps. Unchanged and dummy vertices are assigned initial coordinates from L i−1 . Then, clusters to which vertices were both added and removed are handled. The added and removed vertices of a cluster are paired-up, and the initial coordinates of an added vertex is set to the coordinates of a removed vertex.</p><p>Then, vertices that were added to a cluster or removed from it, but cannot be paired-up, are handled, as discussed in Section 3.3. Next, the vertices in new clusters, that is clusters that exist in G i but not in L i−1 , are inserted into the graph without initial coordinates, along with new spacer vertices. The number of the latter is set to a constant fraction of the number of vertices in the cluster.</p><p>The last stage of merging involves vertex pinning, which restricts vertex movement, allowing it to move only as an indirect result of the movement of an unpinned vertex. We have experimented with several strategies for computing the set of vertices to be pinned. Our conclusion is that pinning all vertices that were assigned coordinates achieves good results in terms of the dynamic stability of the layout. We have also observed that in most cases the resulting layouts are aesthetically pleasing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Improving the Layout</head><p>After computing the graph layout L <ref type="bibr" target="#b0">1</ref> i , a cluster density metric determines whether the layout is of satisfactory quality. For a cluster C i , we define</p><formula xml:id="formula_5">density metric(C i ) = area(bounding box(C i )) number o f vertices(C i ) .</formula><p>That is, the density metric of a cluster is the ratio between the area of its bounding box and the number of vertices it contains. Higher values imply that the vertices in the cluster are spaced further apart, which is not desirable. For the entire graph G we define</p><formula xml:id="formula_6">density metric(G) = max C i ∈G {density metric(C i )}.</formula><p>Experience has shown that a correlation exists between high density metric values and overlaps between clusters. A second layout, L 2 i , is computed if the value of the graph density metric exceeds a threshold. To improve the layout, the restrictions on vertex movement are relaxed. The layout algorithm is re-run with the positions of the vertices in L 1 i as the initial condition. This time the vertices are not pinned down. This gives the layout algorithm more freedom and allows it to converge to a better result. The new layout L 2 i still resembles L 1 i because of the supplied initial condition. The final layout is selected as the layout with the lower density metric between L 1 i and L 2 i . Clearly, the choice between L <ref type="bibr" target="#b0">1</ref> i and L 2 i demonstrates the tradeoff between preserving the mental map and creating an aesthetically pleasing layout. It should be noted that initial attempts to use more relaxed constraints when computing L <ref type="bibr" target="#b1">2</ref> i , such as removing some of the assigned vertex coordinates, were counterproductive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Display and Animation</head><p>We have investigated display in three dimensions, as illustrated in <ref type="figure" target="#fig_4">Figure 4</ref>, in order to distinguish between vertex types and edge types. Vertex-vertex edges are drawn on the lower plane, while cluster-cluster edges are drawn on the upper plane. In 3D, a cluster is drawn as a semi-transparent pyramid with the cluster's dummy vertex, which is the endpoint of cluster-cluster edges, drawn at the apex of the pyramid. One of our guidelines in creating this visualization is being able to collapse the 3D view into a 2D view in a natural and comprehensible way, as illustrated in <ref type="figure" target="#fig_5">Figure 5</ref>, which shows a 2D drawing of the graph from <ref type="figure" target="#fig_4">Figure 4</ref>. Color is also employed in order to help the user comprehend the image -each cluster has a different color.</p><p>The transition between L i−1 and L i is performed using a sequence of intermediate drawings generated by a linear interpolation of the coordinates of vertices, edges and cluster boundaries. (See the attached movie.)  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">VISUALIZING MOBILE OBJECT SOFTWARE</head><p>Our layout algorithm has been used in the visualization of mobile object applications <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b20">21]</ref>. This framework extends the distributed objects concept, where objects can migrate to remote hosts, along with their state and behavior, during the execution of the application. The visualization should expose the connections, interactions and movements of the objects that are distributed throughout a computer network.</p><p>In our visualization, every object is depicted by a vertex. Connections between objects are drawn as vertex-vertex edges. Each machine is represented by a cluster that contains all of the objects currently residing on that machine. The set of cluster-cluster edges is used to display physical connections between machines, as opposed to logical relations that exist between objects.</p><p>Our algorithm is demonstrated in <ref type="figure">Figure 6</ref> as well as in <ref type="figure" target="#fig_0">Figures 1-2</ref> and in the accompanying movie. It was tested on several graph sequences. Some of them represent executions of real mobile object applications and others represent simulated data.</p><p>To measure the quality of the resulting layouts, we identify several criteria. The first is the density metric discussed in Section 3.5, which is used to measure the compactness of the layout. The second is the sum of displacement of clusters between each pair of successive layouts, which is used to measure the stability of the layout. The third is the percentage of clusters with the same size between successive layouts, which helps to demonstrate the effectiveness of using spacer vertices in minimizing visual changes to the graph.</p><p>Figures 7-10 compare the performance of our algorithm to two other algorithms. The first is a non-incremental algorithm and the second is an incremental algorithm in which vertices are assigned initial coordinates computed in the merge stage, but vertex pinning and spacer vertices are not used.</p><p>The density metric is plotted in <ref type="figure">Figure 7</ref>. Higher values in the graph represent sparse clusters, which should be avoided. All three algorithms produce similar results, which means that the incremental algorithm manages to compute compact layouts of the graph. <ref type="figure">Figure 8</ref> shows the sum of the displacements of clusters between each pair of successive layouts. Lower values imply higher stability in the location of clusters. As can be seen, our algorithm outperforms the other algorithms. <ref type="figure">Figure 9</ref> depicts the number of clusters that maintain their size between each pair of successive layouts. Higher values imply that there are less modifications to cluster outlines. It is clear from the graphs that our algorithm produces much better results than the other algorithms. Finally, <ref type="figure" target="#fig_0">Figure 10</ref> depicts the running times of the algorithms. Both incremental algorithms take more time to compute than the non-incremental algorithm. This is mostly due to the extra processing done in the merge stage. <ref type="table" target="#tab_1">Table 1</ref> summarizes the average values of each of the above metrics. All algorithms produce similar cluster densities. The cluster displacement of our algorithm is by far superior to the nonincremental algorithm, averaging about one twelfth of the nonincremental algorithm. Reducing the movement of clusters has indeed been one of the main design goals of the algorithm. The average percentage of clusters that remain with the same size in our algorithm is about four times as much as the non-incremental algorithm. This is facilitated by the spacer vertices that are used to minimize visual changes to the graph. Finally, the running times of both incremental algorithms is about twice the running time of the non-incremental algorithm, which is reasonable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION AND FUTURE WORK</head><p>We have presented an online algorithm for incremental layout of clustered graphs. The algorithm uses a force directed static layout tool as a basic building block. The key idea of the algorithm is to establish priorities of avoiding changes. First and foremost, movement of clusters should be avoided, because clusters give insight into the basic structure of the graph. Then, movement of vertices should be avoided, since vertices convey information regarding the size of the clusters and aid in navigating the graph. Movement of edges is considered the least critical.</p><p>To achieve this, our algorithm incorporates a few novel concepts. First, crucial vertices (dummy and old) are pinned down. Second, invisible place-holders are used to minimize changes. Finally, lengths and weights of edges are used to control both vertex placement and graph modifications.</p><p>It has been demonstrated that the algorithm computes a compact and space efficient graph layout, while minimizing the displace-ment and changes to clusters between layout iterations.</p><p>The algorithm has been applied to the visualization of mobile object environments, where both real and simulated data has been tested. Good results have been achieved at the expense of higher running times. This is due both to the added complexity of the algorithm and to the fact that our implementation is only loosely coupled to the underlying static layout tool.</p><p>In future research, we plan to investigate enhancements to our 3D display mode. We would also like to extend the spacer vertices concept to drawing the cluster boundaries. Allowing some flexibility in fitting the boundary around the vertices in the cluster might improve the layout. An additional layout stage where each cluster is modeled as a non-uniform node could help improve cluster separation <ref type="bibr" target="#b4">[5]</ref>. Finally, using stronger constraints when a second layout is necessary might further improve the dynamic stability of the algorithm.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Snapshots from an animation sequence</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>October 10 -</head><label>10</label><figDesc>12, Austin, Texas, USA 0-7803-8779-1/04/$20.00 ©2004 IEEE IEEE Symposium on Information Visualization 2004 (a) Force-directed non-incremental layout (b) Our incremental layout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Incremental vs. non-incremental layout (from left to right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Algorithm overview in pseudo-code</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>3D view of a clustered graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>2D view of a clustered graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :Figure 8 :Figure 9 :</head><label>689</label><figDesc>Sample animation sequence (from left to right and top to bottom) Sum of cluster displacements Number of clusters with the same size</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Running times</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table /><note>Average results of an animation sequence</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was partially supported by European FP6 NoE grant 506766 (AIM@SHAPE) and by the Israeli Ministry of Science, grant 01-01-01509.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An algorithm for drawing compound graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bertault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Symp. Graph Drawing (GD 1999), number 1731 in Lecture Notes in Computer Science</title>
		<editor>J. Kratochvíl</editor>
		<meeting>7th Int. Symp. Graph Drawing (GD 1999), number 1731 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="197" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">U. Brandes. 4. drawing on physical analogies. Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="volume">2025</biblScope>
			<biblScope unit="page" from="71" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">9. dynamic graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Branke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2025</biblScope>
			<biblScope unit="page" from="228" to="246" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">8. drawing clusters and hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Brockenauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cornelsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2025</biblScope>
			<biblScope unit="page" from="193" to="227" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Drawing graphs with nonuniform nodes using potential fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Yen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int. Symp. Graph Drawing (GD 2003), number 2912 in Lecture Notes in Computer Science</title>
		<editor>G. Liotta</editor>
		<meeting>11th Int. Symp. Graph Drawing (GD 2003), number 2912 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="460" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Cockayne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zyda</surname></persName>
		</author>
		<title level="m">Mobile Agents</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A system for graph-based visualization of the evolution of software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Collberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kobourov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nagra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pitts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wampler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM 2003 Symposium on Software Visualization</title>
		<editor>S. Diehl, J. T. Stasko, and S. N. Spencer</editor>
		<meeting>ACM 2003 Symposium on Software Visualization</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Algorithms for drawing graphs: An annotated bibliography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Di</forename><surname>Battista</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry: Theory and Applications</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="235" to="282" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">They Are Changing -Dynamic Graph Drawing for a Sequence of Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Diehl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gorg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graphs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Int. Symp. Graph Drawing (GD 2002), number 2528 in Lecture Notes in Computer Science</title>
		<editor>M. T. Goodrich and S. G. Kobourov</editor>
		<meeting>10th Int. Symp. Graph Drawing (GD 2002), number 2528 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="23" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Three dimensional UML using force directed layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Australian Symposium on Information Visualisation</title>
		<editor>P. Eades and T. Pattison</editor>
		<meeting><address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACS</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="77" to="85" />
		</imprint>
	</monogr>
	<note>Research and Practice in Information Technology</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multilevel visualization of clustered graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">W</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int. Symp. Graph Drawing (GD 1996), number 1190 in Lecture Notes in Computer Science</title>
		<editor>S. C. North</editor>
		<meeting>4th Int. Symp. Graph Drawing (GD 1996), number 1190 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996-09-20" />
			<biblScope unit="page" from="101" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graphviz -open source graph drawing tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ellson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Woodhull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Int. Symp. Graph Drawing (GD 2001), number 2265 in Lecture Notes in Computer Science</title>
		<editor>P. Mutzel, M. Jünger, and S. Leipert</editor>
		<meeting>9th Int. Symp. Graph Drawing (GD 2001), number 2265 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="483" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improved force-directed layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int. Symp. Graph Drawing (GD 1998), number 1547 in Lecture Notes in Computer Science</title>
		<editor>S. Whitesides</editor>
		<meeting>6th Int. Symp. Graph Drawing (GD 1998), number 1547 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="364" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Fast Multi-Scale Algorithm for Drawing Large Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="179" to="202" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Drawing graphs with non-uniform vertices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Working Conference on Advanced Visual Interfaces (AVI&apos;02)</title>
		<meeting>Working Conference on Advanced Visual Interfaces (AVI&apos;02)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Graph visualization and navigation in information visualization: A survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Melançon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Marshall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="43" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dynamic layout of distributed applications in fargo</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Holder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Ben-Shaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Gazit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 International Conference on Software Engineering</title>
		<meeting>the 1999 International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press / ACM Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="163" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A fully animated interactive system for clustering and navigating huge graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int. Symp. Graph Drawing (GD 1998), number 1547 in Lecture Notes in Computer Science</title>
		<editor>S. Whitesides</editor>
		<meeting>6th Int. Symp. Graph Drawing (GD 1998), number 1547 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="374" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An algorithm for drawing general undirected graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kawai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="15" />
			<date type="published" when="1989-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Drawing Graphs: Methods and Models. Number 2025 in Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Seven Good Reasons for Mobile Agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Oshima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="88" to="89" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Layout adjustment and the mental map</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Misue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="210" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Incremental layout in dynadag</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Symp. Graph Drawing (GD 1995), number 1027 in Lecture Notes in Computer Science</title>
		<editor>F. J. Brandenburg</editor>
		<meeting>3rd Int. Symp. Graph Drawing (GD 1995), number 1027 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="409" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Object Management Group. The Common Object Request Broker: Architecture and Specification. Revision 2.2</title>
		<imprint>
			<date type="published" when="1998-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Methods for visual understanding of hierachical system structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Systems, Man, and Cybernetics</title>
		<imprint>
			<date type="published" when="1981-02" />
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="109" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Sun Microsystems, Inc. Java Remote Method Invocation (RMI) Specification</title>
		<imprint>
			<date type="published" when="1997-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Graph Drawing: Algorithms for the Visualization of Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Di</forename><surname>Battista</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Tom sawyer graph layout toolkit</title>
		<ptr target="http://www.tomsawyer.com" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A Multilevel Algorithm for Force-Directed Graph Drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Walshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="253" to="285" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Generating customized layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miyamoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Symp. Graph Drawing (GD 1995), number 1027 in Lecture Notes in Computer Science</title>
		<editor>F. J. Brandenburg</editor>
		<meeting>3rd Int. Symp. Graph Drawing (GD 1995), number 1027 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="504" to="515" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">yfiles: Visualization and automatic layout of graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wiese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eiglsperger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Int. Symp. Graph Drawing (GD 2001), number 2265 in Lecture Notes in Computer Science</title>
		<editor>P. Mutzel, M. Jünger, and S. Leipert</editor>
		<meeting>9th Int. Symp. Graph Drawing (GD 2001), number 2265 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="453" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Dynamic hierarchy specification and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bergeron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization, InfoVis</title>
		<meeting>IEEE Symp. Information Visualization, InfoVis</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="65" to="72" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
