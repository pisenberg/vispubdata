<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Smooth View-Dependent Level-of-Detail Control and its Application to Terrain Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
							<email>hhoppe@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Smooth View-Dependent Level-of-Detail Control and its Application to Terrain Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The key to real-time rendering of large-scale surfaces is to locally adapt surface geometric complexity to changing view parameters. Several schemes have been developed to address this problem of view-dependent level-of-detail control. Among these, the viewdependent progressive mesh (VDPM) framework represents an arbitrary triangle mesh as a hierarchy of geometrically optimized refinement transformations, from which accurate approximating meshes can be efficiently retrieved. In this paper we extend the general VDPM framework to provide temporal coherence through the runtime creation of geomorphs. These geomorphs eliminate &quot;popping&quot; artifacts by smoothly interpolating geometry. Their implementation requires new output-sensitive data structures, which have the added benefit of reducing memory use. We specialize the VDPM framework to the important case of terrain rendering. To handle huge terrain grids, we introduce a blockbased simplification scheme that constructs a progressive mesh as a hierarchy of block refinements. We demonstrate the need for an accurate approximation metric during simplification. Our contributions are highlighted in a real-time flyover of a large, rugged terrain. Notably, the use of geomorphs results in visually smooth rendering even at 72 frames/sec on a graphics workstation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Real-time visualization of large-scale surfaces is a challenging problem. As an example, <ref type="figure" target="#fig_0">Figure 1</ref> shows a grid mesh of 4,097 2,049 vertices containing both color and elevation data. The most common approach for rendering such surfaces is to exploit the traditional 3D graphics pipeline, which is optimized to transform and texture-map triangles. The graphics pipeline has two main stages: geometry processing and rasterization.</p><p>Typically, the rasterization effort is relatively steady because the rendered surface has low depth complexity. In the worst case, the model covers the viewport, and the number of filled pixels is only slightly more than that in the frame buffer. Current graphics workstations (and soon, personal computers) have sufficient fill rate to texture-map the entire frame buffer at 30-72 Hz, even with advanced features like trilinear mip-map filtering and detail textures.</p><p>Instead, geometry processing proves to be the bottleneck. Even high-end platforms can process in real-time only a tiny fraction of the nearly 17 million triangles shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Of course, there is little point in rendering more triangles than there are pixels. In fact, the surface usually exhibits significant spatial coherence, so that its perspective projection can be approximated to an accuracy of a few pixels by a much simpler mesh (e.g. 2,000-20,000 triangle faces) as demonstrated in <ref type="figure" target="#fig_0">Figure 11</ref>. Finding such a mesh, and updating it as the viewing parameters change, is referred to as view-dependent level-of-detail (LOD) control. The challenge is to locally adjust the complexity of the approximating mesh to satisfy a screen-space pixel tolerance while maintaining a rendered surface that is both spatially and temporally continuous. To be spatially continuous, the mesh should be free of cracks and T-junctions. To be temporally continuous, the rendered mesh should not visibly "pop" from one frame to the next.</p><p>Several schemes have been developed to address view-dependent LOD control, as summarized in Section 2. Among these, the viewdependent progressive mesh (VDPM) framework <ref type="bibr" target="#b15">[16]</ref> represents an arbitrary triangle mesh as a hierarchy of geometrically optimized refinement transformations. Consequently, it is able to satisfy a given screen-space approximation tolerance with a simpler mesha key advantage in reducing the geometry bottleneck.</p><p>In this paper we first extend the general VDPM framework in the following two areas.</p><p>Memory requirements : We redesign the data structures to be output-sensitive, thereby reducing memory requirements (Section 4.1). Runtime geomorphs : We introduce a scheme for efficient runtime creation of geomorphs, which smoothly transition surface geometry over several frames to eliminate popping (Section 4.2).</p><p>To our knowledge this is the first runtime scheme for temporally smooth, view-dependent LOD control on arbitrary meshes.</p><p>Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently <ref type="bibr" target="#b9">[10]</ref> using traditional view-independent simplification techniques (e.g. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b20">21]</ref>). In our opinion, the overhead of view-dependent LOD is only justified when necessary -for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface. In other domains, examples include the virtual flythroughs of organic structures and of CAD surfaces like ship hulls <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b22">23]</ref>. In this paper we place the emphasis on terrain rendering because of its importance in the growing entertainment market.</p><p>In the second half of the paper, we specialize the VDPM framework to the special case of terrains (i.e. height fields). In particular, we add the following two enhancements:</p><p>Approximation error : We demonstrate that the common approach of measuring approximation error on height fields solely at grid points is inadequate for view-dependent LOD using irregular meshes (Section 5.1). Fortunately, exact approximation error can be computed efficiently during a preprocessing step. Scalability : To handle huge terrain models, we present a blockbased recursive simplification process (Section 5.2). The result of this process is a hierarchical progressive mesh representation that permits runtime memory management. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Height fields. Although there exist numerous multiresolution representations for height fields (see surveys in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14]</ref>), only a subset support view-dependent LOD, and it is only recently that efficient on-line algorithms have been introduced that incrementally adapt LOD as the view parameters change.</p><p>Taylor and Barrett <ref type="bibr" target="#b21">[22]</ref> extract mesh approximations from rectangular quadtree hierarchies. Both Lindstrom et al. <ref type="bibr" target="#b17">[18]</ref> and Duchaineau et al. <ref type="bibr" target="#b7">[8]</ref> define bintree hierarchies, based on binary subdivision of right isosceles triangles, and demonstrate real-time view-dependent LOD. Because these representations are based on regular subdivision, they offer concise storage. Duchaineau et al. are able to create optimal approximating meshes through incremental changes at each frame. However, the meshes are only optimal within a restricted space of meshes, since the regular subdivision structure constrains both vertex locations and face connectivities. As a result, the approximations may be far from optimal when one considers the space of all possible triangulations of the domain.</p><p>Several methods use Delaunay triangulation to develop multiresolution hierarchies <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5]</ref>. In particular, Cohen-Or and Levanoni <ref type="bibr" target="#b4">[5]</ref> support on-line view-dependent LOD with temporal coherence, but must resort to "two-stage" geomorphs. Compared to quadtrees and bintrees, these methods allow more general distribution of vertices over the domain. However, the mesh connectivities are again constrained, in this case by the Delaunay triangulation criterion. <ref type="bibr" target="#b22">[23]</ref> and Hoppe <ref type="bibr" target="#b15">[16]</ref> show that multiresolution hierarchies for arbitrary meshes can be defined using a general refinement transformation called a vertex split <ref type="figure">(Figure 2)</ref>. Whereas Xia and Varshney construct the hierarchy using an edge length heuristic, Hoppe constructs it from the geometrically optimized sequence in a progressive mesh representation (Section 3). De Floriani et al. <ref type="bibr" target="#b5">[6]</ref> introduce another related refinement hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Arbitrary meshes. Xia and Varshney</head><p>When applied to the special case of height fields, these frameworks are able to satisfy a given approximation error using fewer faces due to the absence of connectivity constraints. Lilleskog <ref type="bibr" target="#b16">[17]</ref> reports that the VDPM scheme uses 50-75% of the number of active triangles required by bintree schemes for the same screen-space error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">REVIEW OF VIEW-DEPENDENT PROGRESSIVE MESH FRAMEWORK</head><p>As introduced in <ref type="bibr" target="#b14">[15]</ref>, a progressive mesh (PM) representation describes an arbitrary triangle mesh M n as a coarse base mesh M 0 together with a sequence of n refinement transformations fvsplit0; : : : ; vsplitn,1g called vertex splits ( <ref type="figure">Figure 2</ref>) that progressively recover detail. A PM representation for M n is obtained by</p><formula xml:id="formula_0">f n1 f n3 f n2 f n0 v t v u f l f r f n1 f n3 f n2 f n0 v s vsplit ecol Figure 2:</formula><p>The vertex split refinement operation, and its inverse, the edge collapse coarsening operation. <ref type="figure">Figure 3</ref>: The vsplit refinement transformations uniquely define a vertex hierarchy.</p><formula xml:id="formula_1">v v 2 2 v v 1 1 v v 3 3 v v 10 10 v v 11 11 v v 4 4 v v 5 5 v v 8 8 v v 9 9 v v 6 6 v v 7 7 v v 12 12 v v 13 13 v v 14 14 v v 15 15 M 0 M n</formula><p>carefully simplifying it using n successive edge collapse transformations ( <ref type="figure">Figure 2</ref>), and recording their inverses. As shown in the VDPM framework <ref type="bibr" target="#b15">[16]</ref>, this same sequence of vsplit refinement transformations uniquely defines a vertex hierarchy ( <ref type="figure">Figure 3</ref>), in which the root nodes correspond to the vertices of the base mesh M 0 , and the leaf nodes correspond to the fully detailed mesh M n . This hierarchy permits the creation of selectively refined meshes, that is, meshes not necessarily in the original sequence M 0 : : : M n . A selectively refined mesh M corresponds to a "vertex front" through the vertex hierarchy (e.g. M 0 and M n in <ref type="figure">Figure 3</ref>), and is obtained by incrementally applying ecol and vsplit transformations subject to a set of legality conditions. The selectively refined mesh M, also called the active mesh, is usually much simpler than the fully detailed mesh M n .</p><p>To achieve view-dependent LOD, the active vertex front is traversed prior to rendering each frame, and each vertex may be either coarsened or refined based on view-dependent refinement criteria. In <ref type="bibr" target="#b15">[16]</ref>, a vsplit refinement is performed if its neighborhood satisfies 3 criteria: (1) it intersects the view frustum, (2) its Gauss map is not strictly oriented away, and (3) its screen-projected deviation from M n exceeds a user-specified pixel tolerance . For efficient and conservative runtime evaluation of these criteria, each vertex in the hierarchy stores the following: a bounding-sphere radius rv, a normal vectornv, a cone-of-normals angle v, and a deviation space encoded by a uniform component v and a directional com- <ref type="bibr" target="#b15">[16]</ref>. Geomorphs are demonstrated to be feasible within the VDPM framework, but their runtime creation is left as future work.</p><formula xml:id="formula_2">ponent v</formula><p>In the remainder of the paper, we assume that the size of the base mesh M 0 is insignificant compared to that of the fully refined M n , and therefore assume that M n has approximately n vertices and 2n faces. We let m denote the number of vertices in the active mesh M, so that M has approximately 2m faces. Typically, m n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EFFICIENT, TEMPORALLY SMOOTH VDPM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Output-sensitive data structures</head><p>One limitation of the original VDPM scheme <ref type="bibr" target="#b15">[16]</ref> is that all its data structures scale proportionally with the size n of the fully refined mesh M n . In particular, static storage is allocated to represent the mesh connectivity for all faces in M n even though only a small fraction are usually active at any one time. To allow the introduction of geomorphs without prohibitive memory use, we have redesigned the data structures to be output-sensitive. As shown in <ref type="figure" target="#fig_2">Figure 4</ref>, the structures are separated into two parts: a static part encoding the vertex hierarchy and refinement dependencies (size 88n bytes), and a dynamic part encoding the connectivity of just the active mesh M (size 112m bytes). Let us examine the data structures more closely. Each Vertex contains a pointer to its parent, and an index i of the vspliti that creates its children (or -1 if it is a leaf). Since vertices are numbered consecutively, the index i is sufficient to compute the indices of the two child vertices vt and vu, and of the one/two child faces fl and fr. We make several optimizations to further reduce memory. Geometry storage is reduced in half by modifying the vsplit/ecol transformation to force vertices vs and vt to have the same geometry, as illustrated in <ref type="figure">Figure 2</ref>. Experiments reveal that this vs = vt constraint results in an average increase of about 15% in active faces. Instead of storing the texture identifiers for the new faces fl and fr in Vsplit, we infer them during a vsplit from the adjacent active faces fn1 and fn3 respectively.</p><p>For concreteness, here is pseudocode for the vertex split transformation; procedure ecol(vs) is defined analogously. To enable the geomorphs described in Section 4.2, each active vertex has a field vmorph, which points to a dynamically allocated VertexMorph record when the vertex is morphing. In practice, the number g of morphing vertices is only a fraction of the number m of active vertices, which is itself only a small fraction of the total number n of vertices.</p><p>Overall, the new data structures need 88n + 112m + 52g bytes, compared to 224n bytes in <ref type="bibr" target="#b15">[16]</ref>.</p><p>Because in practice the number of active faces is 2m 12,000 65,536, the AVertex* and AFace* pointers in the static structure can be replaced by <ref type="bibr" target="#b15">16</ref>  vg. Static storage is then reduced from 88n to 56n bytes. By way of comparison, a standard representation for a pre-simplified, quantized, irregular mesh uses 42n bytes of memory ((n)(12) bytes for positions and normals, and (2n)(3)(4) bytes for connectivity). Thus the VDPM framework only requires a 33% increase in memory over a static, non-LOD representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Runtime generation of geomorphs</head><p>Two factors are crucial to a good visual flythrough simulation: a (high) steady frame rate, and the absence of popping artifacts. At first, these two goals seem contradictory. Popping is avoided if the screen-space error tolerance is kept near a value of 1 pixel, but with a constant error tolerance, the number of active faces can vary greatly depending on the model complexity near the viewpoint, leading to non-uniform frame rate. Our solution is to aim primarily for a constant frame rate by adjusting the screen-space error tolerance, and to eliminate popping by smoothly morphing the geometry. Although the model may at times have a projected geometric error of a few pixels, results indicate that geomorphs make this error nearly imperceptible. The remainder of this section describes a scheme for generating geomorphs at runtime within the VDPM framework. The geomorph scheme is effective enough that we can increase the pixel error tolerance to improve frame rate (up to 72 frames/sec) with few noticeable artifacts.</p><p>The main idea is as follows. When the refinement criteria indicate the need for an ecol or vsplit, instead of performing the transformation instantaneously, we perform it as a geomorph by gradually changing the vertex geometry over several frames. Specifically, a transformation is performed as a geomorph if and only if the region of the affected surface is visible (i.e. the region overlaps with the view frustum and is not oriented away from the viewer). Indeed, it is undesirable to initiate a geomorph on a region known to be invisible, because according to the refinement criteria, such a region may have unbounded screen-space error. If such a region were to become visible prior to the end of the geomorph, it could lead to an arbitrarily large screen-space displacement. For example, as the viewpoint pans left, the nearby off-screen region should not be morphing from its coarse state as it enters the left edge of the viewport.</p><p>Besides position, other vertex attributes interpolated during a geomorph may include normal, color, and texture coordinates. Most attributes are linearly interpolated. Normals are interpolated over the unit sphere. In our examples, texture coordinates are generated implicitly during rendering using a linear map on vertex positions. Because the map is linear, these texture coordinates are identical to those that would result if texture coordinates were tracked explicitly at vertices. <ref type="figure" target="#fig_3">Figure 5</ref> illustrates the types of changes applied to the active mesh as a user moves forward and to the left through a model. Regions of the model entering the view frustum (on the left) are instantaneously refined. Regions leaving the view frustum (on the right and near the viewer) are instantaneously coarsened. Finally, regions within the view frustum are geomorph refined. Note that in this common case of forward viewer motion, geomorph coarsening does not occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Geomorph refinement.</head><p>We first present geomorph refinements, as it is the more common case in practice. Only minor changes are made to the vsplit procedure described in Section 4.1. The mesh connectivity is still modified immediately, but we initially assign the new vertex vu the same geometry as its sibling vt, and only gradually modify the geometry of vu to its refined state over the next gtime frames. The parameter gtime is user-specified; in our prototype we have set it equal to the frame rate (30-72), so that geomorphs have a lifetime of one second. Note that the geomorphs do not require the introduction of additional faces, as the mesh connectivity is exactly that of the desired refined mesh. Here is the modified pseudocode: function is invisible <ref type="bibr">(vs)</ref> return outside view frustum <ref type="bibr">(vs)</ref> or oriented away(vs) // see <ref type="bibr" target="#b15">[16]</ref>  It should be emphasized that this modified vsplit may be applied to a vertex vs already morphing. In other words, geomorph refinements can be composed arbitrarily, even with overlapping lifetimes. Procedure vsplit simply advances the vertex front down the vertex hierarchy (possibly several "layers"), modifying the mesh connectivity instantaneously while deferring geometric changes. <ref type="figure">Figure 6</ref> shows an example in which 3 vertex splits are performed.</p><formula xml:id="formula_3">v v 2 2 v v 1 1 v v 3 3 v v 10 10 v v 11 11 v v 4 4 v v 5 5 v v 8 8 v v 9 9 v v 6 6 v v 7 7 v v 12 12 v v 13 13 v v 14 14 v v 15 15 v v 2 2 v v 1 1 v v 3 3 v v 10 10 v v 11 11 v v 4 4 v v 5 5 v v 8 8 v v 9 9 v v 6 6 v v 7 7 v v 12 12 v v 13 13 v v 14 14 v v</formula><p>As shown in the pseudocode below, at each frame we traverse the set of active vertices, and for each morphing vertex, we advance its geometry and decrement its gtime field. When gtime reaches 0, the vertex has reached its goal geometry and the VertexMorph record is deleted. Geomorph coarsening. Geomorph coarsening is more challenging within the VDPM framework. Unlike in geomorph refinement, the geometry interpolation must take place first, and only then can the mesh connectivity be coarsened. Because the mesh must remain refined during the geomorph's lifetime, evaluating the legality of further coarsening steps is non-trivial. Moreover, even if this legality could be determined, further coarsening would in general require modifying several ongoing geomorphs. These difficulties are not inherent to the VDPM framework but should arise even in multiresolution hierarchies based on uniform subdivision.</p><p>As a consequence, we only allow geomorph coarsening "one layer at a time". That is, out of the set of desired geomorph coarsenings, we simultaneously perform all the currently legal ones, and make their dependents wait for these initial geomorphs to complete. To help mitigate this delay, we reduce the gtime parameter for geomorph coarsening to half that for geomorph refinement. Fortunately, geomorph coarsening is required only when the viewer is moving backwards -a more infrequent situation.</p><p>Implementation of geomorph coarsening primarily involves changes to the function that adjusts the active vertex front: procedure adapt refinement() // compare with definition in <ref type="bibr" target="#b15">[16]</ref> for Modified screen-space error metric. Recall that a geomorph refinement is initiated when the screen-projected deviation of its mesh neighborhood exceeds a pixel tolerance . If the viewer is moving forward, the mesh neighborhood is likely closer to the viewer by the time the geomorph completes, thus invalidating the error estimate. Our solution is to anticipate the viewer location gtime frames into the future when evaluating the screen-space error metric. We estimate this future location by extrapolation based on the current per-frame viewer velocity e. A more rigorous solution to account for changes in velocity would require altering the lifetimes of ongoing geomorphs, which seems expensive. The original refinement criterion from <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b17">18]</ref> is:</p><formula xml:id="formula_4">v kv , ek s 1 , (v , e) nv kv , ek 2 ;</formula><p>where e is the viewpoint, v the mesh vertex,nv its normal, v its neighborhood's residual error, and = 2 tan '</p><p>2 accounts for field-of-view angle ' and pixel tolerance . The square-root factor allows greater simplification when the surface is viewed along the direction of its normal. For our terrain flyover, with fixed , this factor reduces the average number of active faces by only 3%, so we decided to omit it. The denominator kv , ek is an estimate of the z coordinate of the vertex v in screen space. We replace this denominator with the linear functional L e;ẽ (v) = (v , e) ẽ which computes this z coordinate directly (ẽ is the viewing direction).</p><p>Our new screen-space error criterion is v L e 0 ;ẽ (v), in which the point e 0 is either the current viewpoint e or the anticipated future viewpoint e + gtime e depending on whether eẽ is negative or positive respectively (i.e. viewer moving backwards or forwards).</p><p>Discussion. Selectively refined meshes within the VDPM framework, and in particular those resulting from geomorphs, may have thin (near-degenerate) triangles. Several papers warn against using such meshes for LOD rendering. In our opinion this is unjustified. Thin triangles can produce unsightly artifacts when they result from inaccurate computation of approximation error; however, such artifacts are avoided when computing exact error as in Section 5.1. Some authors have expressed concern that thin triangles may misbehave during rendering. However, we have not observed any rasterization artifacts on the graphics platforms we have tested (SGI Maximum Impact and Infinite Reality), as demonstrated on the accompanying video.  <ref type="figure">Figure 8</ref>: For correct approximation error, it is crucial to consider all vertices in the union partition of the two triangulations.</p><formula xml:id="formula_5">v s v t v u</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SPECIALIZATION OF VDPM TO TERRAINS</head><p>In this section we discuss how the VDPM framework can be specialized to address the rendering of height fields.</p><p>Experiments reveal that backface simplification presents little benefit. For instance, in <ref type="figure" target="#fig_0">Figure 11</ref> it does not result in any coarsening of the mesh. We therefore omit it as a view-dependent refinement criterion by simplifying the function is invisible as follows: function is invisible <ref type="bibr">(vs)</ref> return outside view frustum <ref type="bibr">(vs)</ref> Since the texture image is mapped onto the terrain using a vertical projection, we measure surface deviation parametrically using strictly a vertical distance v as done in <ref type="bibr" target="#b17">[18]</ref>. If in addition, texture mapping is performed without Gouraud shading, the storage of vertex normals becomes unnecessary.</p><p>As a consequence, we omit storing the fieldsnv, v, and v (as highlighted by the 'y' symbol in <ref type="figure" target="#fig_2">Figure 4</ref>), thereby reducing static storage to 48n bytes using 16-bit indices, quantization, and lookup tables as described in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Exact approximation error</head><p>For height fields, it is common in the literature to measure the approximation error of a simplified mesh by its maximum vertical deviation at the original grid points (e.g. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11]</ref>). For viewdependent LOD, however, measuring deviation solely at grid points is generally insufficient, which is surprising at first since the only input is the discrete set of grid points, i.e., there is no knowledge of the surface between the points. For the edge collapse transformation illustrated in <ref type="figure" target="#fig_6">Figure 7</ref>, both meshes (before and after the transformation) interpolate the grid points, yet they have different geometric shapes. Even if it is argued that both interpolants are equally valid, clearly the two rendered meshes look different, and the mesh transformation may lead to  an arbitrarily large pop. This point is more than academic; an initial implementation using the naive approximation error did in fact result in unexpectedly large pops, as demonstrated qualitatively on the video. Even though geomorphs hide such pops, it is still useful to have an accurate estimate of screen-space error.</p><p>The solution is to measure maximum (L 1 ) approximation error with respect to a reference surface. <ref type="bibr" target="#b0">1</ref> A natural choice for this reference surface is the regular triangulation of the grid points. We therefore want to compute the maximum height deviation between this triangulated grid and the open neighborhood of each edge collapse transformation. (Similar derivations are described in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b8">9]</ref>.) The maximum height deviation between two triangle meshes is known to lie at a vertex of their union partition in the plane (e.g. the vertices labeled in <ref type="figure">Figure 8</ref>). An efficient way to enumerate the vertices of the union partition is to consider: (1) the grid points internal to the faces adjacent to vs, and (2) the grid line crossings internal to the edges adjacent to vs. Note that the computed error is not just an upper-bound, it is exact, and it is always computed with respect to the original fully detailed mesh. This error, computed during the preprocessing discussed in the next section, is stored in the Vsplit field v for use in the runtime criterion of Section 4.2.</p><p>It should be pointed out that for regular subdivision schemes based on quadtrees and bintrees, all grid line crossings happen to fall exactly on grid points, so the naive approach is in fact sufficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Hierarchical PM construction</head><p>We develop a hierarchical scheme for constructing PM representations of large terrains. The scheme, applied as a preprocess, partitions surface geometry into blocks and uses bottom-up recursion to simplify and merge the block geometries. Our approach is motivated by three considerations:</p><p>Because simplification methods start from a detailed mesh and successively remove vertices, they are inherently memoryintensive. Although the mesh of <ref type="figure" target="#fig_0">Figure 1</ref> does have an acceptable approximation that fits in main memory, attempting to form this approximation by simplifying the mesh as a whole would be impractical. For height fields, an alternative approach requiring less memory is to start from a coarse approximation and progressively insert vertices <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">11]</ref>. However, such greedy refinement methods generally yield inferior approximations (e.g. compare <ref type="figure" target="#fig_3">Figures 25-26</ref> in <ref type="bibr" target="#b10">[11]</ref> with <ref type="figure">Figure 8b</ref> in <ref type="bibr" target="#b14">[15]</ref>). Our hierarchical strategy allows us to tackle the problem piecemeal with an accurate simplification-based method. For even larger models, a pre-simplified mesh may still be too large to fit in main memory. If one resorts to the operating system's virtual memory manager, the resulting paging causes <ref type="bibr" target="#b0">1</ref> The use of an L 2 norm to integrate squared error over the domain is inadequate, as reported in <ref type="bibr" target="#b10">[11]</ref>. block refinements <ref type="figure" target="#fig_0">Figure 10</ref>: Result of the hierarchical construction process.</p><p>the process to pause intermittently, disturbing frame rate. By partitioning the refinement database into a block hierarchy, we can exploit domain knowledge to explicitly pre-fetch refinement data before it is needed. Just as the geometry data may be too large for memory, so may its associated texture image. Clip-maps <ref type="bibr" target="#b19">[20]</ref> offer an elegant solution to this problem, but require hardware assistance currently available only on high-end systems. A more traditional approach is to partition the texture image into tiles that can be mip-mapped and paged independently. In our scheme, a texture tile may be associated with each block, as the PM construction can optionally guarantee that mesh faces never cross block boundaries.</p><p>After partitioning the model into blocks, the recursive scheme proceeds as illustrated in <ref type="figure" target="#fig_7">Figure 9</ref>. Starting at the lowest level, it simplifies each block by iteratively applying a sequence of ecol transformations. This sequence is chosen by selecting at each iteration the ecol giving rise to the lowest approximation error, using the metric of Section 5.1. The simplification process terminates when the approximation error of the next best ecol exceeds a userspecified threshold for the current level. In order to avoid refinement dependencies between adjacent blocks, we constrain ecol's to leave boundary vertices untouched. Above the first level, if texture tiles are desired, we also constrain ecol's to prevent displacement of tile boundaries within the block, as shown by the checkerboard pattern in Color Plate 1d-e. The simplification sequences (e.g. ecolA, ecolB) are saved to disk. Then, the resulting simplified meshes are stitched together 2 2 at a time, and the process is repeated at the next higher level using these larger blocks.</p><p>Special treatment is given to the first and last levels of simplification. In the first level, we discard for each block all initial ecol's  until a user-specified error tolerance is exceeded. Effectively this amounts to truncating the final hierarchy but it avoids the intermediate storage costs. In the last level, in which there is only a single block, we permit simplification of the mesh boundary, since interblock dependencies are no longer a concern. Thus the final base mesh M 0 consists of only 2 triangles, or 2 triangles per tile if texture tiles are desired (Color Plate 1e).</p><p>To form a hierarchical PM, we invert each recorded ecol sequence to form a vsplit sequence called a block refinement (e.g. vsplitS, vsplitA, and vsplitB in <ref type="figure" target="#fig_0">Figure 10</ref>). We concatenate these block refinements and store them along with the base mesh. As in the construction of an ordinary PM, this final assembly involves renumbering the vertex and face parameters in all vsplit records. However, the renumbering only requires depth-first access to the block refinements within the hierarchy, so that memory usage is moderate.</p><p>Although the hierarchical construction constrains simplification along block boundaries at lower levels, inter-block simplification occurs at higher levels, so that these constraints do not pose a significant runtime penalty. For our flyover example in Section 6, and for a given pixel tolerance, a non-hierarchical PM representation reduces the average number of active faces by only 0.8%.</p><p>As mentioned above, the user specifies a threshold for the maximum approximation error at each simplification level. We choose these thresholds so that block refinements at all levels have roughly the same number of vsplit refinements. For example, in Color Plate 1 the thresholds are 0.03%, 0.04%, 0.1%, and 1, expressed as fractions of the terrain width. Since these thresholds form an upperbound on the errors of all vsplit's below that level, they can be used to determine which block refinements need to be memory-resident based on the current viewing parameters, and which others should be prefetched based on the anticipated view changes. Specifically, we can use the thresholds to compute the maximum screen-projected error for each active block as in <ref type="bibr" target="#b17">[18]</ref>. If this error exceeds the screen-space tolerance , its child block refinements are loaded into memory and further tested.</p><p>Since block refinements correspond to contiguous sequences in the vertices, faces, and vsplits arrays of <ref type="figure" target="#fig_2">Figure 4</ref>, we can reserve virtual memory for the whole PM (i.e. the entire arrays), and use sparse memory allocation to commit only a fraction to physical memory. For instance, the Microsoft Windows operating system supports such a reserve/commit/decommit protocol using the VirtualAlloc() and VirtualFree() system calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>Preprocessing. The 4,097 2,049 grid of <ref type="figure" target="#fig_0">Figure 1</ref> represents actual elevation data and satellite imagery near the Grand Canyon. The elevation at each grid vertex is given as an integer in the range 0-255, where one unit represents 10 meters. To make the example more challenging, we exaggerated the elevation by 40%, assigning 14 meters to each unit. We partitioned the initial mesh into 8 4 blocks of 513 513 vertices, and applied the hierarchical construction scheme of Section 5.2. <ref type="table" target="#tab_5">Table 1</ref> shows the maximum error tolerance for each level of the hierarchy, in the original 0-255 scale, together with the total number of faces at that level. As the meshes are too dense to visualize, Color Plate 1 shows a much simpler example with 4 4 blocks of 33 33 vertices.</p><p>We pre-simplify the blocks up to an error of half the original data resolution (0.5 in the 0-255 range). With a resulting pre-simplified mesh of n = 732,722 vertices, the static data structures use 49.8 MB. (On low-end platforms where storage is at a premium, the pre-simplification error threshold can be increased to 1.0 to further reduce size to 13.1 MB.) In contrast, the dynamic data structures require only 0.6 MB of memory in a typical situation such as that in <ref type="figure" target="#fig_0">Figure 11</ref> (where the number of active vertices m = 6,000 and the number of morphing vertices g = 1,500).</p><p>Runtime. In the accompanying video, we demonstrate a 2minute flyover of the Grand Canyon terrain. In world units, speed during the flight is approximately Mach 10. The flyover is rendered in real-time on an SGI Octane workstation (single processor 195 MHz R10K with Maximum Impact graphics), in a window of 710x520 pixels. We obtain a constant frame rate of 30 frames/sec by regulating the screen-space error tolerance to maintain approximately 12,000 active faces, and by amortizing the work of the procedure adapt refinement over 3 frames, as described in <ref type="bibr" target="#b15">[16]</ref>. <ref type="figure" target="#fig_0">Figure 11</ref> shows one frame from the flyover, in which equals 2.1 pixels. Over the whole flight, the screen-space tolerance averages 1.7 pixel, and attains a maximum of 3.3 pixels. (Because of approximations in the computation of screen-space errors <ref type="bibr" target="#b15">[16]</ref>, the tolerance values are unfortunately not upper bounds on screen-space error.) The fraction of vertices undergoing geomorph refinement and coarsening averages 28.3% and 2.2% respectively. R10K-MXI 1000x1000 30 11,000 2.9 5.2 <ref type="bibr" target="#b7">[8]</ref> R10K-MXI 1000x1000 30 3,000 n/a 6.0 " Onyx-IR 1000x1000 30 6,000 n/a n/a <ref type="bibr" target="#b17">[18]</ref> Onyx-RE2 640x480 20-30 4-9,000 2.0 2.0 By modifying the regulation to instead maintain 5,000 active faces, we consistently achieve a target frame rate of 60 frames/sec. Similarly, 4,000 active faces yields a rate of 72 frames/sec. <ref type="table" target="#tab_7">Table 2</ref> lists statistics for these flyovers, as well as similar ones recorded on an SGI Onyx Infinite Reality system. As we currently only make use of a single CPU, performance gains on the Onyx are limited.</p><p>For comparison, <ref type="table" target="#tab_7">Table 2</ref> also lists statistics for some previous methods. Unfortunately, the terrains are different in each case, thus preventing direct comparisons. The quality of our results are due to the combination of three advantages:</p><p>1. The framework is efficient; by performing output-sensitive, incremental work, it is able to adapt and render an active mesh of 12,000 faces at 30 frames/second on a uni-processor workstation. 2. These mesh faces are derived from geometrically optimized refinement transformations, thus providing an accurate screenspace approximation. 3. Through temporal coherence, geomorphs mask the remaining screen-space approximation error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">GENERALIZATION: ARBITRARY MESHES</head><p>Both the output-sensitive data structures (Section 4.1) and the runtime geomorph framework (Section 4.2) apply to VDPM representations of arbitrary meshes, as demonstrated on the accompanying video. In this section we briefly discuss how the techniques of Section 5 can be generalized to work on arbitrary meshes.</p><p>Approximation error. Several recent methods are able to track upper bounds on maximum geometric error during simplification of arbitrary meshes. Among these, at least two <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">13]</ref> specifically consider sequences of edge collapse transformations. It would be easy to include these methods within the general VDPM framework. Other recent work <ref type="bibr" target="#b3">[4]</ref> obtains bounds on parametric approximation error, which is appropriate in the presence of texture mapping.</p><p>Hierarchical construction. A Voronoi construction as in <ref type="bibr" target="#b8">[9]</ref> can be used to recursively partition an arbitrary mesh into a hierarchy of regions. Although the regions are no longer square blocks, the bottom-up simplification and stitching scheme should work with little modification. The result is a base mesh M 0 and a hierarchy of block refinements. The value max indicates the maximum deviation of the meshes at the given level, as a fraction of the terrain width.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A terrain grid of 4,097 2,049 vertices containing both color and elevation data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>procedure vsplit(vs) vt &amp;vertices[jV 0 j + vs:i 2] vu vt + 1 fl &amp;faces[jF 0 j + vs:i 2] fr fl + 1 fn0::3 vsplits[vs:i]:fn[0::3] vt:avertex vs:avertex; vt:avertex:vertex vt vs:avertex 0 vu:avertex new AVertex; vu:avertex:vertex vu vu:avertex:listnode.add to list(active vertices) vu:avertex:vgeom vsplits[vs:i]:vu vgeom fl:aface new AFace; fl:aface:listnode.add to(active faces) [ Fill in entries of fl:aface ] fr:aface new AFace; fr:aface:listnode.add to(active faces) [ Fill in entries of fr:aface ] [ Update fn0::3:neighbors[::] to point to fl; fr ] [ For each face f around vu: update f :vertices[::] : vs ! vu ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Principal C++ data structures. Fields denoted by 'y' are omitted for terrain rendering (Section 5). for frv; v; v; sin 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Changes to active mesh during forward motion of viewer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>15 15Figure 6 :</head><label>156</label><figDesc>Illustration of geomorph refinement. The active mesh on the right is obtained by applying 3 vertex splits to the active mesh on the left. To obtain a smooth transition, the geometry for vertices fv13; v11; v7g are gradually interpolated from those of their ancestors as indicated by the arrows. (By construction, positions v12 = v1 and v6 = v 5 , so no interpolation is necessary for them.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>procedure update vmorphs() for each v 2 active vertices if v:vmorph v:vgeom v:vgeom + v:vmorph:vginc v:vmorph:gtime v:vmorph:gtime , 1 if v:morph:gtime = 0 delete v:vmorph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>For this edge collapse, evaluating the maximum height deviation solely at grid points gives an error of zero.edge collapse grid line interior to an edge grid point interior to a face center vertex (no error)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Steps in the hierarchical block-based simplification done as a preprocess.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>One frame from the 30 frame/sec flyover of the terrain shown inFigure 1. The screen-space error tolerance is 2.1 pixels for a 720x510 window. The active mesh has 12,154 faces and 6,096 vertices. The fraction of vertices undergoing geomorph refinement and coarsening is 26.8% and 0.2% respectively. Note how the sizes and shapes of the triangles adapt to the complex topography.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>( a )Figure</head><label>a</label><figDesc>Original mesh (129 129 vertices; 32,768 faces; max =0) (b) Pre-simplified mesh (21,622 faces; max =0.03%) (c) Level 0 simplification (11,048 faces; max =0.04%) (d) Level 1 simplification (3,594 faces; max =0.1%) Level 2 -base mesh M 0 (32 faces; max =2.8%) (f) PM hierarchy showing block refinements Color Plate 1: The hierarchical PM construction process partitions the model into blocks and recursively simplifies and combines the blocks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>-bit indices. Additionally, in Vsplit we can quantize the coordinates to 16 bits and use 256-entry lookup tables</figDesc><table><row><cell cols="2">// Statically allocated structures. (space O(n))</cell></row><row><cell>struct VGeom</cell><cell>// Vertex geometry</cell></row><row><cell>Point point y Vector normal</cell><cell>// position v // normalnv</cell></row><row><cell>struct Vertex</cell><cell>// Static vertex [2n]</cell></row><row><cell>AVertex* avertex</cell><cell>// active vertex, 0 if inactive</cell></row><row><cell>Vertex* parent</cell><cell>// parent vertex, 0 if root</cell></row><row><cell>int i</cell><cell>// index of vspliti, -1 if leaf</cell></row><row><cell>struct Face</cell><cell>// Static face [2n]</cell></row><row><cell>AFace* aface</cell><cell>// active face, 0 if inactive</cell></row><row><cell>struct Vsplit</cell><cell>// Vertex split [n]</cell></row><row><cell>VGeom vu vgeom</cell><cell>// geometry for child vertex vu</cell></row><row><cell>Face* fn[4]</cell><cell>// required neighbors fn0; fn1; fn2; fn3</cell></row><row><cell>float radius y float sin2alpha y float uni error</cell><cell>// max extent rv of affected region // cone-of-normals angle (sin 2 v) // uniform error v</cell></row><row><cell>float dir error</cell><cell>// directional error v</cell></row><row><cell>struct ListNode</cell><cell>// Node on a doubly linked list</cell></row><row><cell>ListNode* next</cell><cell></cell></row><row><cell>ListNode* prev</cell><cell></cell></row><row><cell>struct SRMesh</cell><cell>// Selectively refinable mesh</cell></row><row><cell>Array&lt;Vertex&gt; vertices</cell><cell>// all vertices in hierarchy [2n]</cell></row><row><cell>Array&lt;Face&gt; faces</cell><cell>// all faces [2n]</cell></row><row><cell>Array&lt;Vsplit&gt; vsplits</cell><cell>// vertex splits vspliti [n]</cell></row><row><cell>ListNode listnode</cell><cell>// list stringing active vertices</cell></row><row><cell>Vertex* vertex</cell><cell>// pointer back to static vertex</cell></row><row><cell>VGeom vgeom VertexMorph* vmorph</cell><cell>// vertex coordinates (x,y,z) // 6 = 0 if geomorphing (Section 4.2)</cell></row><row><cell>struct AFace</cell><cell>// Active face (on heap) [2m]</cell></row><row><cell>ListNode listnode</cell><cell>// list stringing active faces</cell></row><row><cell>AVertex* vertices[3]</cell><cell>// ordered counter-clockwise</cell></row><row><cell>AFace* neighbors[3]</cell><cell>// neighbors[j] across from vertices[j]</cell></row><row><cell>int texture id</cell><cell>// texture tile identifier</cell></row><row><cell>struct VertexMorph</cell><cell>// (on heap, see Section 4.2) [g]</cell></row><row><cell>bool coarsening</cell><cell>// true if coarsening, false if refining</cell></row><row><cell>short gtime</cell><cell>// # of geomorph frames remaining</cell></row><row><cell>VGeom vg refined</cell><cell>// refined geometry (back-up copy)</cell></row><row><cell>VGeom vginc</cell><cell>// increment per frame during morph</cell></row></table><note>ListNode active vertices // head of active vertex listListNode active faces // head of active face list // Dynamically allocated structures. (space O(m)) struct AVertex // Active vertex (on heap) [m]</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1 :</head><label>1</label><figDesc>PM hierarchy statistics.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 2 :</head><label>2</label><figDesc>Runtime statistics and comparison with previous work.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>I wish to thank Anuj Gosalia of the Microsoft Direct3D group for helpful feedback, and Cindy Grimm, John Snyder, and Rick Szeliski for comments on the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Error-bounded reduction of triangle meshes with multivariate data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SPIE</title>
		<imprint>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="34" to="45" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Representation and visualization of terrain surfaces at variable resolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="199" to="217" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Simplifying polygonal models using successive mappings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Olano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;97 Proceedings</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Appearancepreserving simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Olano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;98 Proceedings</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Temporal continuity of levels of detail in Delaunay trianulated terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Levanoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;96 Proceedings</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="37" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Building and traversing a surface at variable resolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;97 Proceedings</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="103" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multiresolution models for topographic surface description</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marzano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="317" to="345" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">ROAMing terrain: real-time optimally adapting meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;97 Proceedings</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;95 Proceedings</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Equin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;93 Proceedings</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Fast polygonal approximation of terrains and height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<idno>CMU-CS 95-181</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>CS Dept., Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;97 Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Surface simplification with variable tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gu Eziec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Symposium on Medical Robotics and Computer Assisted Surgery</title>
		<meeting>the Second International Symposium on Medical Robotics and Computer Assisted Surgery</meeting>
		<imprint>
			<date type="published" when="1995-11" />
			<biblScope unit="page" from="132" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Survey of polygonal surface simplification algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multiresolution surface modeling (SIGGRAPH &apos;97 Course notes #25). ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;96 Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;97 Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Continuous level of detail</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lilleskog</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-02" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Norwegian University of Science and Technology</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Real-time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;96 Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;97 Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">In-finiteReality: a real-time graphics system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Montrym</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dignam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Migdal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;97 Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="293" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multi-resolution 3D approximations for rendering complex scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics</title>
		<editor>T. L. Kunii</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An algorithm for continuous resolution polygonalizations of a discrete surface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">A</forename><surname>Barrett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Interface &apos;94</title>
		<meeting>Graphics Interface &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Dynamic view-dependent simplification for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;96 Proceedings</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
