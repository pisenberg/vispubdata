<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Large Scale Terrain Visualization Using The Restricted Quadtree Triangulation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
							<email>pajarola@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science ETH Zentrum</orgName>
								<address>
									<postCode>8092</postCode>
									<settlement>Zürich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eth</forename><surname>Zürich</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science ETH Zentrum</orgName>
								<address>
									<postCode>8092</postCode>
									<settlement>Zürich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Large Scale Terrain Visualization Using The Restricted Quadtree Triangulation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>algorithms</term>
					<term>computer graphics</term>
					<term>virtual reality</term>
					<term>triangulated surfaces</term>
					<term>terrain visualization</term>
					<term>terascale visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Real-time rendering of triangulated surfaces has attracted growing interest in the last few years. However, interactive visualization of very large scale grid digital elevation models is still a hard problem. The graphics load must be controlled by an adaptive surface triangulation and by taking advantage of different levels of detail. Furthermore, the management of the visible scene requires efficient access to the terrain database. We describe a all-in-one visualization system which integrates adaptive triangulation, dynamic scene management and spatial data handling. The triangulation model is based on the restricted quadtree triangulation. Furthermore, we present new algorithms of the restricted quadtree triangulation. These include among others exact error approximation, progressive meshing, performance enhancements and spatial access.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Interactive visualization of very large scale terrain data brings up a wealth of problems. The main problem in real-time graphics is rendering efficiency. To best exploit the rendering performance, the scene complexity must be reduced as much as possible without leading to an inferior visual representation. Therefore, the geometry simplification must be controlled by an approximation error threshold. Another way to increase efficiency is the use of different levels of detail (LODs) for different areas of the visible scene. Objects are displayed in lower resolutions -with higher approximation errors -the farther away they are from the view focus.</p><p>Large-scale terrains are usually too large to be displayed as a whole, even when using multiple LODs. For instance, the grid digital elevation model of Switzerland at 25 meter grid-resolution consists of more than 120 million triangles. Therefore, only a fraction of such an extensive model can be rendered at an interactive frame-rate. This partial scene, however, must be updated dynamically according to changes of the view parameters. Therefore, the data structure holding the terrain data must support spatial access. Additionally, an approximation error parameter is specified to indicate the correct LOD. Furthermore, incremental refinement must be supported. Efficient storage and compact topology is required to realize a small database and allow fast transmission.</p><p>The triangulation model is the core structure for every terrain surface visualization system. To achieve low complexity without negative impact on accuracy, the triangulation must be adaptive to the terrain surface characteristics. Furthermore, the triangulation model must provide means to extract surface representations at variable precisions so that multiple LODs can be supported. The following list briefly recalls the requirements for the visualization system, and in particular for the triangulation model. The list is not sorted by any priority, it is rather sorted by related topics. In Section 2 we briefly discuss similar terrain visualization approaches. Section 3 introduces the restricted quadtree triangulation. Two new construction algorithms are presented in Section 4, and exact error approximation is explained in Section 5. Performance issues are discussed in Section 7, and support of progressive meshing is described in Section 6. Sections 8, 9 and 10 discuss dynamic data handling, continuous LOD rendering, and storage. Experiments are presented in Section 11, and Section 12 concludes the paper with a comparison to other multiresolution triangulation models. More detailed information on all sections can also be found in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b9">10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>In <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> the restricted quadtree triangulation (RQT) was first applied to terrain visualization. Their contribution was an efficient screen-space error metric calculation, and efficient scene culling and vertex selection according to this error metric. Furthermore, they presented a cumbersome triangle strip construction algorithm. A second application of the RQT to terrain visualization is described in <ref type="bibr" target="#b4">[5]</ref>. They introduce a different notation for the same class of restricted quadtree meshes. The main contribution was a priority-queue driven mesh refinement and a combination of object-and screen-space error metric.</p><p>In contrast to <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> we provide two alternative vertex selection algorithms, and provide a more intuitive triangle strip construction method. Furthermore, we explain exact error approximation based on the RQT. Contrarily to <ref type="bibr" target="#b4">[5]</ref> we present an error calculation that can also handle non-monotonic error metrics which is essential to extract exact approximations according to the L ∞ -norm for a broader class of error metrics. Moreover, in extension to the previous applications, we combine the RQT with dynamic scene management, spatial access and progressive meshing in an integrated large scale terrain visualization system.</p><p>Other multiresolution triangulation models which can handle different classes of meshes are considered in the conclusion as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Restricted quadtree triangulation</head><p>The RQT is an adaptive, hierarchical triangulation model. In <ref type="bibr" target="#b16">[17]</ref> the restricted quadtree was used to triangulate a parametric surface. However, no algorithm was provided to efficiently build the restricted one from a plain quadtree. In addition to the algorithms in <ref type="bibr" target="#b13">[14]</ref>, we will provide two slightly different construction meth-ods, one theoretically optimal in the sense of <ref type="bibr" target="#b12">[13]</ref> and an implementation-efficient one. Furthermore, we present a new triangle strip construction, progressive meshing and spatial access, all based on the restricted quadtree. Because of space limitations only preliminary details are presented in this introduction.</p><p>The assignment of grid points to levels in the quadtree hierarchy is shown in <ref type="figure">Figure 1</ref>, with the root being level 0. Given the grid size dimension and points , the points on lower levels are given by . Note that the resolution is level dependent. The center-vertices denote points of L l which are located in the center of a quadtree block on level l-1 (white points in <ref type="figure">Figure 1</ref>). Let be all points down to level l, and be the vertices on level l of an unbalanced restricted quadtree Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 1. Hierarchy levels</head><p>An example of the recursive triangulation of a plain quadtree is shown in <ref type="figure">Figure 2</ref>. However, cracks can occur in the corresponding three-dimensional surface as shown on the right. To guarantee a matching triangulation, cracks have to be avoided. In <ref type="bibr" target="#b16">[17]</ref> this was granted by the restriction that adjacent quadtree blocks differ by at most one level in the quadtree hierarchy, and that every quadtree block is triangulated by eight triangles, or two triangles per boundary edge, unless the edge borders a larger block. However, this method may produce extra triangles, and provides no deterministic algorithm to convert a plain quadtree into a restricted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 2. Nonrestricted quadtree triangulation</head><p>Another way is to represent the restriction of the RQT as a dependency graph on the grid, see also <ref type="bibr" target="#b8">[9]</ref>. Every vertex depends on two other vertices of the same or the next higher level in the quadtree hierarchy. This means that if the vertex is selected for triangulation then the related must be selected too. The dependency graph for levels 1 and 2 is depicted in <ref type="figure">Figure 3</ref>. We use the notation to refer to the complete dependency graph, and includes all vertices . The dependency relation is denoted by the directed edges set .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 3. Dependency graph</head><p>The dependency graph G dep prevents cracks by consistently restricting the selection of points such that a matching triangulation results. <ref type="figure" target="#fig_0">Figure 4</ref> shows the restricted version of the quadtree triangulation from <ref type="figure">Figure 2</ref>, with the dependency graph shown on the right. Using G dep , any given set of points on the grid can now decisively be turned into a restricted quadtree by resolving the dependency rules. Note that the triangulation can efficiently be constructed because it is given implicitly, no geometric computations such as in-circle tests need to be preformed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Restricted quadtree construction</head><p>For the construction, we assume that the decision of selecting a point due to its approximation error can be determined by a threshold. The calculation of a suitable approximation error is described in Section 5. By collecting all vertices following the dependency graph the selection is completed to a restricted quadtree. Note that a quadtree data structure on a (2 k +1) × (2 k +1) grid can be implemented using index operations and recursion instead of using pointers and nodes. We call this an implicit quadtree defined on a grid.</p><p>In our first top-down algorithm we assume that the elevation points are kept in a region quadtree, and that an approximation error is associated to every point. Additionally, each node knows the maximal error of its own triangulation with respect to all points stored in that subtree. SelectVertices() selects all points of the current node satisfying the approximation threshold, and recursively traverses the given quadtree. For every selected vertex v, ResolveDependencies() adds the related points to the current selection, and follows the dependency graph.</p><p>The selection result QSet can be a new quadtree, or abstract in the sense that it is not another data structure but a selection of vertices in the original quadtree structure. Moreover, this restricted quadtree selection can even just be implicitly defined on the height field grid. For that, the procedures set.insert() and set.contains() can be implemented by setting and testing a flag for every point. The complexity of Algorithm 1 and the respective triangulation is linear in the size of the extracted restricted quadtree. Moreover, the complexity is theoretically optimal in the sense of <ref type="bibr" target="#b12">[13]</ref> as the RQT is a multi-triangulation. Contrarily to the top-down method in <ref type="bibr" target="#b13">[14]</ref> we do not predict and interpolate next-level vertices to guide recursive tree traversal, instead we use the exact approximation errors of Section 5. Also the restriction of the quadtree is handled differently, using the dependency relation E dep .</p><formula xml:id="formula_0">n 2 k 1 + = P i j , i j , ; 0. .n 1 - = l 0 ≥ L l P i j , h l 0 1 ..2 l , , = i ; j , 0 d l ..h , , l d l ⋅ { } P i j , L l 1 - ∉ ∧ ∈ { } = d l n 1 - ( ) 2 l ⁄ = L l center L l ∪ L k 0 = l ∪ k = L l Q ( ) L l ⊆ level 2 level 0 level 1 G dep V dep E dep , ( ) = V dep L 2 n 1 - ( ) log ∪ = E dep P 1 P 2 , ( ) dependency from P 1 to P 2 { } = level 2 level 1 level 1 level 2 p v p , ( ) E dep ∈ { }</formula><p>Our second algorithm operates iteratively bottom-up. Starting at the lowest level with the highest resolution, the algorithm iterates over all levels examining the particular points on each. But for the organization of the points in a matrix, the same presumptions hold as for Algorithm 1. During the inspection within a level a vertex is selected if its error exceeds the tolerance threshold, or if the point is marked from a dependency relation. Additionally, the two related vertices are marked accordingly.</p><p>In contrast to Algorithm 1, this bottom-up approach visits vertices only once. However, the marking mechanism has to be studied carefully such that no dependencies might be left out in any case. Consequently, no recursive resolution of the dependency graph must be performed, as well as no set-inclusion tests are needed to stop recursion. As in Algorithm 1, the selected vertices are stored in a query answer data structure, or form an implicit quadtree. The efficiency of Algorithm 2 results overall from a low number of simple operations computed per vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.2 Algorithm 2 runs in time linear of the input data size, and no dependency relation of G dep is omitted.</head><p>Proof The while loop in Algorithm 2 iterates over all levels, and for each level the inner foreach loop must only visit points on that level. For a level l and the corresponding grid resolution d l only the points are visited. Hence every vertex is visited exactly once which sums up to O(n) for n input points.</p><p>To further guarantee consideration of all relevant dependencies of G dep , the non center-vertices have to be examined first within a level. This is sufficient because the dependencies of point to , and point to vertices on level , see also <ref type="figure">Figure 3</ref>. For the inner foreach loop this can be achieved by first visiting the points and afterwards . ( abbreviates in this context)</p><p>In comparison to the algorithms in <ref type="bibr" target="#b13">[14]</ref>, we do not have to deal with insertion or merging of nodes, or examine neighboring nodes if we use an implicit quadtree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Exact error approximation</head><p>We present an error metric in the object space to exactly control the approximation accuracy. Our error for a Point P and a triangulation T is the point's euclidean distance to the triangle with . is the triangle domain in the x,y-projection IR 2 . If then . Therefore, the error of T is the maximal error of all points not in T, given by . We combine the simplification idea of <ref type="bibr" target="#b3">[4]</ref> with the partial order of G dep to calculate . The best triangulation not including is , and without , it is . The covering of P are all triangles affected by the selection of P: . Given the inverse dependency relation , the transitive closure of P is defined as the set of vertices:</p><p>Thus the approximation error of is the maximum error with respect to Cov(P) of all points in :  <ref type="figure" target="#fig_2">Figure 5</ref> illustrates a two-dimensional analog where the levels and the dependency graph are:</p><formula xml:id="formula_1">. (EQ 1) P i j , i DIV d l ( )MOD 2 0 ≠ j DIV d l ( )MOD 2 0 ≠ ∨ { } L l \L l center L l \L l center L l center L l center l 1 - P i j , i 2 d l 0 ≠ XOR j 2 d l 0 ≠ { } P i j , i 2 d l 0 ≠ j 2 d l 0 ≠ ∧ { } k 2 d l k DIV d l ( )MOD 2 e T P ( ) d P t , ( ) t T ∈ P z 0 = t ( ) ∆ ∈ t ( ) ∆ P z 0 = t ( ) ∆ ∉ d P t , ( ) 0 = e T max P T ∉ ∀ d P t , ( ) ( ) t T ∈ ∧ = e T P ( ) L l center T l 1 - RQT of L ∪ l 1 - { } = L l \L l center T l 1 - RQT of L ∪ l 1 - L l center ∪ { } = Cov P L l ∈ ( ) t T l 1 - t ( ) ∆ P z 0 = ∅ ≠ ∩ ∈ { } = P Q ← Q P , ( ) E dep ∈ ⇔ ζ P ( ) Q V dep ∈ P 1 .. P k , , P P 1 .. P k Q ← , , ← ; ∃ { }P { } ∪ = P L l ∈ ζ P ( ) e T l 1 - P ( ) max Q ζ P ( ) ∈ t Cov P ( ) ∈ , d Q t ,<label>( ) (</label></formula><p>For example, P 5 is assigned the error d' 8 because this is the maximum error of all vertices in to the line-approximation , especially</p><p>. On the next level however, the error of P 3 is exactly d 3 , because no other vertices in have a bigger distance to . A triangulation which satisfies the error tolerance ε everywhere on the input data is called an ε-approximation. Using e T (P) of Equation 1 we can construct an ε-approximation even for other non-monotonic error metrics in contrast to <ref type="bibr" target="#b4">[5]</ref>, and solve the exact approximation problem of restricted quadtrees mentioned in <ref type="bibr" target="#b1">[2]</ref>. The algorithms presented in <ref type="bibr" target="#b13">[14]</ref> cannot provide an exact εapproximation either for non-monotonic error metrics because they do not take into account errors of lower level vertices in .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Progressive meshing</head><p>Progressive meshing denotes the construction and transmission of a triangulation such that an intermediate triangulation can be updated easily given only a few new elements such as points, edges or triangles, see also <ref type="bibr" target="#b6">[7]</ref>. Preferably, an update affects the topology only nearby the new elements and can be computed in constant time. Most hierarchical triangulations <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> support progressive meshing.</p><p>A breadth-first traversal of the restricted quadtree Q builds up the progressive mesh sequence of vertices. However, on level l the vertices must be transmitted first to guarantee a RQT. Using ≤ as the ordering relation the progressive mesh sequence is: .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(EQ 2)</head><p>Each update (vertex insert) splits exactly two triangles up into four, and can be computed in constant time. A vertex location operation is needed to select the right insertion point using time in a quadtree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6.1 For a given restricted quadtree Q, the vertex ordering of Equation 2 provides a progressive, matching triangulation.</head><p>Proof This ordering takes into account all dependency relations of Q. No vertex is used before its related vertices are. Therefore, any sub-quadtree is a restricted quadtree.</p><p>A restricted quadtree ε-approximation Q ε can also incrementally be updated to a smaller approximation error δ by adding an error-range quadtree ( ). For we select vertices according to an error-range instead of comparing to a threshold. Q ε equals to , with . A progressive mesh sequence is then:</p><p>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Fast triangulation</head><p>To enhance performance of the RQT, we introduce a triangle strip construction that is more intuitive than the one presented in <ref type="bibr" target="#b8">[9]</ref>, and that operates recursively on the quadtree data structure. <ref type="figure" target="#fig_3">Figure 6</ref> shows the idea of a triangle strip for a RQT. We recursively circle counter-clock wise around the quadtree block centers and output every triangle once with alternating orientation. A triangle strip can also be regarded as a space filling curve visiting all triangles, or as a Hamiltonian path in the dual graph of the triangulation, see <ref type="figure" target="#fig_3">Figure 6</ref> on the right. For each quadtree block, we can specify the corner-vertex where the triangle strip path enters to the right (inlet) and leaves the block on the left (outlet). Therewith, all blocks can be characterized by two rotation invariant path types shown in <ref type="figure" target="#fig_4">Figure 7</ref>, together with the hierarchical decomposition. To join the triangle strips of two quadtree blocks, the first and last edge of a path must be on the block border. Some triangulation rules for different block types are depicted in <ref type="figure" target="#fig_4">Figure 7</ref> as well. With this triangulation scheme it is possible to create a triangle mesh in linear time.  Proof The quadtree traversal is limited by the one-and two-pass recursion schemes. Only the two-pass nodes are visited exactly twice, once for each inlet-outlet path. Therefore, the number of nodes processed is at most twice the number of nodes in the quadtree. Thus we visit O(|Q|) nodes. Now, for each inlet-outlet path we have to show that the corresponding sequence of vertices can be created in constant time. Note that a quadtree block with only two triangles is triangulated in its ancestor block, see also <ref type="figure" target="#fig_4">Figures 2 and 7</ref>. Therefore, every visited block has a center-vertex called c. The other vertices are numbered counter-clock wise from the inlet = 0 to the outlet = k. Each triangle strip sequence of vertices for an inlet-outlet path consists of:</p><formula xml:id="formula_2">L 0 P 1 P 9 , { } L 1 P 5 { } = L 2 P 3 P 7 , { } = , , = L 3 P 2 P 4 P 6 P 8 , , , { } = V dep L 3 ∪ = E dep P 5 P 1 , ( ) P 5 P 9 , ( ) P 3 P 1 , ( ) P 3 P 5 , ( ) ... , , , , { } = ζ P 5 ( ) P 2 P 3 P 4 P 5 P 6 P 7 P 8 , , , , , , { } = P 1 P 9 , d' 8 d 5 &gt; ζ P 3 ( ) P 2 P 3 P 4 , , { } = P 1 P 5 , P 1 P 2 P 3 P 4 P 5 P 6 P 7 P 8 P 9 d 5 d' 4 d 4 d 3 d' 8 ζ P ( ) L l center Q ( ) L 0 Q ( ) L 1 center Q ( ) L ≤ 1 Q ( )\L 1 center Q ( ) .. L 2 n 1 - ( ) log Q ( )\L 2 n 1 - ( ) log center Q ( ) ≤ ≤ ≤ O n log ( ) Q l L k 0 = l ∪ k Q ( ) { } = Q ∆ ε δ , ∆ ε δ , ε δ - = Q ∆ ε δ , Q ∆ ∞ ε , ∆ ∞ ε , ∞ ε - = Q ε 0 Q ∆ ε 0 ε 1 , .. , , ε 0 ε 1 ε 0 ∆ ε 0 ε 1 , - = ε 2 ε 1 ∆ ε 1 ε 2 , - = ... &gt; &gt; &gt; ; Q ∆ i Q ε i 1 - Q ε 0 Q ∆ k k 1 = i 1 - ∑ + = Q ∆ i O Q ∆ i ( ) =&gt; =&gt; + =</formula><p>The size of such a sequence is limited by15 if all vertices are needed for triangulation. Therefore, each inlet-outlet triangle strip sequence can be generated in constant time.</p><p>Besides the triangulation, also the construction of the restricted quadtree can be optimized. After calculating the approximation errors as described in Section 5, we maximize it on behalf of all vertices in the transitive closure:</p><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(EQ 3)</head><p>Consequently, dependencies are already encoded in the error values, and has not to be resolved because R is automatically selected if P is, since from Equation 3. Therefore, the construction of a restricted quadtree is simplified to the selection of all vertices satisfying the requested error threshold ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 7.2 The set is a restricted quadtree, given the error is calculated as in Equation 1 and maximized according to Equation 3.</head><p>Proof Assume that Q is not a restricted quadtree, then and . However, because of and Equation 3 we have . Because of we conclude that in contradiction to the assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Dynamic scene management</head><p>We use a windowing concept as shown in <ref type="figure" target="#fig_6">Figure 8</ref> to visualize very large terrain databases, because we do not assume that the whole terrain database is in main memory. Furthermore, we do not restrict access to a per file basis as in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16]</ref>. Our visible scene always represents a window onto the world. A partition of the visible scene into rectangular patches as shown in <ref type="figure" target="#fig_6">Figure 8</ref>, efficiently supports scene updates. Furthermore, the database reloads can be composed from fixed sized range-queries. Besides supporting culling of invisible patches <ref type="figure" target="#fig_3">(Figure 16</ref>), this scene map can also be used to assign different levels of detail (LODs) to different patches ( <ref type="figure" target="#fig_4">Figure 17</ref>). Refer to Section 9 for details on LOD handling. The scene map is not updated for every small variation of view position, view frustum coordinates or LOD distribution. However, an update occurs only when the variation exceeds a specific threshold. This approach of deferred cumulative updates helps to reduce the data management costs significantly without severe loss of display quality. Additionally, it provides further means to tailor the visualization system to available resources.</p><p>The dynamic scene manager maintains each terrain patch in a quadtree data structure. Whenever an update is scheduled, a RQT reflecting the new situation is extracted and provided for rendering the patch at the requested LOD. The restricted quadtree is also the basic transfer and query unit used for reloading or updating a patch from the terrain database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Continuous LOD rendering</head><p>Continuous LOD stands for three different aspects of multiresolution visualization:</p><p>1. representation of a scene in an (almost) unlimited number of different LODs, 2. display different parts of a scene at different resolutions without discontinuities in between, 3. smooth changes between different LODs of the same scene. The first aspect is handled by the restricted quadtree triangulation described in Section 3. Very important is that the different LODs do not have to be precomputed in advance and stored redundantly along with the original full-resolution model as it is the case in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>For the second aspect, an independent LOD is assigned to each terrain patch, using the object-space error metric of Section 5 that defines the approximation accuracy. The LOD is assigned based on relative distance to viewpoint and view direction, as shown in <ref type="figure">Figure 9</ref>, and demonstrated in a graphical example in <ref type="figure" target="#fig_2">Figure 15</ref>. After a terrain patch is loaded for the first time, LOD updates are performed incrementally. Note that unused vertices are never deleted until the complete patch is thrown out of the scene map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 9. LOD distribution</head><p>Avoiding discontinuity, between regions of different terrain complexity, is another requirement of aspect two of continuous LOD rendering. This is a hard problem for multiresolution triangulations <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, however, efficiently solved for grid-based inputs by the RQT. Nevertheless, neatly stitching together independent terrain patches of different resolutions is another problem. In <ref type="bibr" target="#b7">[8]</ref> discontinuities were allowed between quadtree blocks, whereas <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> solved the problem by consistently triangulating the borders of all patches at the same resolution for all LODs. A matching triangulation between two patches can be achieved by mutually exchanging the missing border vertices, which can be quite expensive for sophisticated triangulations such as <ref type="bibr" target="#b2">[3]</ref>.</p><p>Also using the RQT, modification of the triangulation is not avoidable to match adjacent, triangulated regions but it is simple and efficient. The RQT T of a patch can be modified by insertion of the missing border vertices V b . The new set of vertices is then , consisting of the old vertices V T , the missing border vertices V b and the related vertices . Note that the vertices can be interpolated without affecting the approximation precision of T, and V b can only improve the accuracy. The related vertices can be constructed or selected while traversing the quadtree Q for the insertion of V b . V b and which guarantee a matching triangulation between two patches are marked to be included in the triangulation. Otherwise, they could be left out in the construction of the modified triangulation.</p><formula xml:id="formula_3">0 1 c i 1 i k 1 - &lt; &lt; , :i c , ∀ [ ] k 1 -k , , , , , { } e P ( ) max Q ζ P ( ) ∈ e Q ( ) ( ) = P R , ( ) E dep ∈ e R ( ) e P ( ) ≥ Q P e P ( ) ε ≥ { } = e P ( ) P Q ∈ ∃ : P R , ( ) E dep ∈ R Q ∉ ∧ ⇒ R Q ∉ e R ( ) ε &lt; ⇒ P ζ R ( ) ∈ e R ( )</formula><p>Aspect number three of continuous LOD rendering calls for smooth changes between LOD updates within the visible scene. In <ref type="bibr" target="#b6">[7]</ref> the term geomorph was coined to denote morphing between different LODs of the same terrain segment. The RQT is well adapted to morphing. A new vertex v always lies in the middle of an edge between two vertices v 1 and v 2 further up in the dependency graph. Therefore, the interpolation can be calculated as . The linear blending function is , with</p><p>, and it is dependent from the distance to the observer. Morphing can be applied directly to the geometries used for rendering without retriangulation of the quadtree itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Storage and retrieval</head><p>The scene management of Section 8 requires that the terrain database supports rectangular range queries with LOD restrictions, and returns a restricted quadtree of elevation points. Therefore, the database must conform to the same assignment of points to levels L l , dependency graph G dep , and relation of points to quadtree nodes. This is defined by the dependency direction for the top-level vertex in of the root quadtree region. Among all possible data structures for maintaining a grid digital elevation model we describe one here that fits best with Algorithm 2 of Section 4, and that provides fast access to the elevation data. The input data space is partitioned into blocks of (2 k +1) × (2 k +1) grid points. This partitioning provides efficient spatial selectivity and supports physical clustering on external storage. An implicit restricted quadtree is superimposed on every block as shown in <ref type="figure" target="#fig_7">Figure 10</ref>. Note that vertices inside of a block have dependencies within the same block, whereas dependencies of border vertices also symmetrically point to the adjacent block (overlapping dependencies). Finally, the corner-vertices' dependencies point to other corner-vertices of blocks as depicted in <ref type="figure" target="#fig_7">Figure 10</ref>.</p><p>Spatial access is performed by the following steps for a query with region R, error tolerance ε, and using the index structure S:</p><p>1. find all blocks b in S intersecting R using the spatial index:</p><p>2. apply bottom-up restricted quadtree construction algorithm to , check each point against error threshold ε and intersection with R, keep track of overlapping dependencies as well 3. apply bottom-up or top-down restricted quadtree construction to the remaining corner-vertices Special attention has to be paid to the border ∂R of the query region R. The border ∂R constrains the selection to include all vertices needed to map ∂R on edges of maximal length which conform to the RQT, see <ref type="figure">Figure 11</ref>. Note that an incremental query does not have to deal with the border problem because ∂R was already consistently triangulated by the first query of R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 11. Range query constraints</head><p>Furthermore, the transfer from the terrain database to the visualization is very efficient. The triangulation topology and the dependency graph are given implicitly by the restricted quadtree. Moreover, not even the spatial location must be transmitted because it is given by the point's position in the quadtree. The transmission is reduced to a traversal of the restricted quadtree where for every point only its height and error values are sent. Furthermore, dependencies can be resolved in the errors as shown in Equation 3, simplifying the triangulation for the visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Experiments</head><p>This experimental section is not intended as a comparative study of available mesh compression methods, however, these experiments are meant to demonstrate the excellent compression potential of the restricted quadtree triangulation. Note that for this experimentation we used an object space error metric where the approximation error of a point on level L l is defined as its vertical distance to the triangulation of its quadtree block on level L l-1 . <ref type="table" target="#tab_5">Table 1</ref> shows the compression results of different error tolerance thresholds (0, 1, 2, 5 and 10 meters) for two topologically very different terrain samples. Albis represents a rather smooth hilly region and Matterhorn a very mountainous area. Both samples have an original grid resolution of 25 meters and an altitude accuracy of one meter. As can be seen from <ref type="table" target="#tab_5">Table 1</ref>, already a very small error tolerance of one or two meters results in a drastic reduction of the number of points used to approximate (triangulate) the surface.</p><formula xml:id="formula_4">V V T V b V bdep + + = V bdep P R V b ∈ ∃ : R P , ( ) E dep ∈ P V T P V b ∉ ∧ ∉ ∧ { } = V bdep V bdep V bdep v' 0.5 v 1 v 2 + ( ) = f v' v t , , ( ) 1.0 t - ( )v' tv + = t 0.0..1.0 = L 1 center B b S ∈ b R ∩ ∅ ≠ { } = b ∀ B ∈ dependency</formula><p>The visual fidelity of different error thresholds and compression ratios is depicted in <ref type="figure">Figure 12</ref>. Although the mesh complexity itself is reduced drastically, as seen in <ref type="figure">Figures 12-a, 12-</ref>  <ref type="figure" target="#fig_0">Figure 14</ref>, and allow the use of high error tolerances.</p><p>We also performed some rendering and scene update tests that are reported in <ref type="table" target="#tab_6">Tables 2 and 3</ref>. The frame rates were measured using the SGI Performer Toolkit™ statistics, and our test scene was a hilly terrain, 52km × 52km large. The results were obtained on an SGI Inigo2 High Impact10000. From <ref type="table" target="#tab_6">Table 2</ref> it can be seen that scene culling according to the view-frustum (60° viewing angle) does not influence the rendering performance a lot because the non-visible triangles are already efficiently culled by the underlying graphics system. However, the incremental dynamic scene update benefits a lot from culling on the scene management level. Furthermore, rendering performance almost doubles when using different LODs because the adaptive RQT lowers the triangle count significantly, see <ref type="table" target="#tab_6">Table 2</ref>. <ref type="figure">Figure 13</ref> shows the test scene in full resolution and adaptively triangulated. Note that despite the massive reduction of the triangle count no significant loss of detail is observable.</p><p>Our visible scene consisted of 13 × 13 patches, each 4km × 4km large and adaptively triangulated using the RQT, see also <ref type="figure">Figure 13</ref> on the right. The dynamic scene update performance was tested with a velocity of 1000 meters per second, which is triple super-sonic and much faster than needed by any aircraft simulation. Our dynamic scene management updated 65 patches in 10 seconds in real-time. Of the 10 seconds only 1570 milliseconds <ref type="bibr" target="#b0">1</ref> were used for all dynamic scene updates together. Note that this update includes loading 9922 vertices from the terrain database server over the network, constructing 65 restricted quadtrees, resolving map inconsistencies and generating a triangle strip for every updated patch. The average update time for one patch was 1. real-world time only 24 ms and had to process 152 vertices for loading, quadtree construction, and triangle strip generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.">Conclusion</head><p>The RQT has several advantages over other triangulations. Regular grid triangulations are not adaptive to the terrain structure. Maintaining a triangulation for every LOD does not support continuous LOD rendering and the storage costs are very high. More sophisticated multiresolution triangulation models <ref type="bibr" target="#b1">[2]</ref> replace a number of triangles by more and smaller triangles to refine the approximation, see also <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">13]</ref>. However, extraction and incremental refinement of a triangulation are rather complex for on-demand requirements. Furthermore, the topology representation is very complicated compared to the RQT. The same arguments hold for hierarchical triangulation models as described in <ref type="bibr" target="#b2">[3]</ref>. Furthermore, no graphics optimizations are known. Therefore, from the requirements introduced in Section 1 number 4, 5 and 8 are not met. Moreover, the triangulation topology and hierarchy is complicated, and uses much more space than the restricted quadtree. Spatial access is not as efficient as well because topology and vertices have to be extracted from the database. Hence also the demands 1 and 2 cannot be fulfilled effectively.</p><p>The visualization systems in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> do not consider the problem of very large scale terrains. Therefore, the problems 3, 6 and 9 of dynamic scene management and the database aspects 1 and 2 are ignored. The proposal of <ref type="bibr" target="#b14">[15]</ref> does not focus on the dynamic scene and database aspects too. Furthermore, it is lacking effective solutions to the triangulation requirements 4, 5 and 8. In <ref type="bibr" target="#b5">[6]</ref> no multiresolution approach is followed at all. In contrast to other triangulation and visualization models our approach fully satisfies al requirements listed in Section 1. In particular it supports many exceptional features in one multiresolution triangulation model that were also suggested in other publications:</p><p>• progressive transmission <ref type="bibr" target="#b6">[7]</ref> • smooth, continuous LOD transitions <ref type="bibr" target="#b8">[9]</ref> • fast access and manipulation of triangulation <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> • real-time triangulation <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13]</ref> • LOD constrained, spatial access <ref type="bibr" target="#b12">[13]</ref> • efficient storage costs, mesh compression <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7]</ref> Most of the presented concepts and solutions are incorporated into the newest version of the ViRGIS 2 project <ref type="bibr" target="#b11">[12]</ref>. ViRGIS mainly consists of a prototypical client-server system which allows interactive, three-dimensional visualization and exploration of large scale terrains, including texturing, see also <ref type="figure" target="#fig_0">Figure 14</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ViRGIS -Virtual Reality and Geoinformation Systems</head><p>http://www.inf.ethz.ch/personal/pajarola/virgis.html   [PK©] Cartographic raster images PK25/PK100 © 1996 Swiss Federal Office of Topography, reproduction authorization 3.6.1998.</p><p>[SAT©] Satellite images © 1994/1995 ESA/EURIMAGE, reproduction authorization 27.5.1998. a) 1 meter max. error, 76% b) 2 meter max. error, 45% d) 10 meter max. error, 7% c) 5 meter max. error, 18% e) 5 meter max. error, 40% f) 5 meter max. error, 40% g) 10 meter max. error, 25% h) 10 meter max. error, 25%</p><p>Color plates full resolution adaptively triangulated</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIGURE 4 .</head><label>4</label><figDesc>Restricted quadtree triangulation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 4 . 1</head><label>41</label><figDesc>The number of calls to set.contains() and set.insert() of Algorithm 1 is linear in the size of the resulting restricted quadtree Q. Proof A node of the input quadtree is required if the subtree of that node contains a point that does not satisfy the approximation tolerance. All required nodes are visited once by SelectVertices(). The resulting restricted quadtree Q consists at least of all required nodes of the input quadtree. Thus we have O(|Q|) calls to set.insert() and set.contains() by SelectVertices().For every selected point in SelectVertices(), ResolveDependencies() is called once. The recursion in ResolveDependencies() visits all vertices of Q at most four times as no more than four arcs of the dependency graph end in one vertex, see alsoFigure 3. Hence also here we have O(|Q|) calls to set.insert() and set.contains() by ResolveDependencies().</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 5 .</head><label>5</label><figDesc>Error calculation, 2D analog to restricted quadtree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIGURE 6 .</head><label>6</label><figDesc>RQT triangle strip</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIGURE 7 .</head><label>7</label><figDesc>Triangle strip decomposition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>7 Theorem 7 . 1 A</head><label>771</label><figDesc>triangle strip for the restricted quadtree Q can be constructed in time linear in the size of Q.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIGURE 8 .</head><label>8</label><figDesc>Dynamic scene update</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>FIGURE 10 .</head><label>10</label><figDesc>Height field partitioning</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>b, 12-c and 12-d, the visual fidelity of a moderate error tolerance of 5 meters, see Figures 12-e and 12-f, is still extremely good. Even at a 10 meter error threshold with high compression ratios, significant visual details are retained, see Figures 12-g and 12-h. Furthermore, Gouraud shading and texturing improve the visual impression of the terrain, see also</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>FIGURE 13 .FIGURE 14 .FIGURE 15 .FIGURE 16 .FIGURE 17 .</head><label>1314151617</label><figDesc>[DHM©] Textured terrain visualization [DHM©], [SAT©] View-centered LOD strategy [DHM©] Scene culling [DHM©] Scene map [DHM©]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>1. fast access to large scene database 2. effective database storage management 3. variable resolution database access 4. terse topology representation 5. quick adaptive triangulation 6. dynamic visible scene management 7. multiresolution visualization 8. high-performance geometry rendering 9. continuous level of detail rendering</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE 1 .</head><label>1</label><figDesc>Compression results</figDesc><table><row><cell></cell><cell>0 meter</cell><cell>1 meter</cell><cell>2 meter</cell><cell>5 meter</cell><cell>10 meter</cell></row><row><cell></cell><cell cols="5">points % points % points % points % points %</cell></row><row><cell>Albis</cell><cell cols="5">25921 100 19773 76 11636 45 4664 18 1789 7</cell></row><row><cell cols="6">Matterhorn 25921 100 22492 87 17156 66 10492 40 6367 25</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE 2 . Frame rates number of triangles frames per second</head><label>2</label><figDesc></figDesc><table><row><cell>full resolution</cell><cell>86000</cell><cell>20</cell></row><row><cell>culled scene</cell><cell>20000</cell><cell>21</cell></row><row><cell>adaptive triangulation</cell><cell>8000</cell><cell>38</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE 3 .65 patches in 10 seconds CPU time number of vertices</head><label>3</label><figDesc>Scene updates Triangulated surfaces [DHM©] Copyrights [DHM©] Digital elevation model DHM25/RIMINI © 1996 Swiss Federal Office of Topography, reproduction authorization 3.6.1998.</figDesc><table><row><cell>average</cell><cell>24 ms</cell><cell>153</cell></row><row><cell>total</cell><cell>1570 ms</cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On levels of detail in terrains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dobrindt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Symposium on Computational Geometry</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="26" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multiresolution models for topographic surface description</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marzano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="317" to="345" />
			<date type="published" when="1996-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hierarchical triangulation for multiresolution surface description</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="363" to="411" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Algorithms for the reduction of the number of points required to represent a digitized line or its caricature</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Douglas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">K</forename><surname>Peucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Canadian Cartographer</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="112" to="122" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Roaming terrain: Realtime optimally adapting meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization 97</title>
		<meeting>Visualization 97<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Computer graphics and remote sensing -a synthesis for environmental planning and civil engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sutter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hagger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nüesch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings EUROGRAPHICS 94</title>
		<meeting>EUROGRAPHICS 94</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Virtual GIS: A real-time 3D geographic information system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">F</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization 95</title>
		<meeting>Visualization 95<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="94" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Real-time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">F</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Access to large scale Terrain and Image Databases in Geoinformation Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, ETH Zürich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Large scale terrain visualization using the restricted quadtree triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<idno>292</idno>
		<ptr target="ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/2xx/292.ps" />
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, ETH Zürich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Virtual geoexploration: Concepts and design choices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Widmayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computational Geometry and Applications</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Variable resolution terrain surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Canadian Conference on Computational Geometry</title>
		<meeting>the 8th Canadian Conference on Computational Geometry</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="202" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Algorithms for constructing quadtree surface maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int. Symposium on Spatial Data Handling</title>
		<meeting>5th Int. Symposium on Spatial Data Handling</meeting>
		<imprint>
			<date type="published" when="1992-08" />
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Aspekte der interaktiven real-time 3D-Landschaftsvisualisierung</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Suter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
		<respStmt>
			<orgName>Remote Sensing Laboratories, University of Zürich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Automated generation of visual simulation databases using remote sensing and GIS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Suter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nüesch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization 95</title>
		<meeting>Visualization 95<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="86" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Accurate triangulations of deformed, intersecting surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Von</forename><surname>Herzen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 87</title>
		<meeting>SIGGRAPH 87</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1987" />
			<biblScope unit="page" from="103" to="110" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
