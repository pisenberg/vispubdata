<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Ray Tracing for Isosurface Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Parker</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yarden</forename><surname>Livnat</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hansen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter-Pike</forename><surname>Sloan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive Ray Tracing for Isosurface Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We show that it is feasible to perform interactive isosurfacing of very large rectilinear datasets with brute-force ray tracing on a conventional (distributed) shared-memory multiprocessor machine. Rather than generate geometry representing the isosurface and render with a z-buffer, for each pixel we trace a ray through a volume and do an analytic isosurface intersection computation. Although this method has a high intrinsic computational cost, its simplicity and scalability make it ideal for large datasets on current high-end systems. Incorporating simple optimizations, such as volume bricking and a shallow hierarchy, enables interactive rendering (i.e. 10 frames per second) of the 1GByte full resolution Visible Woman dataset on an SGI Reality Monster. The graphics capabilities of the reality monster are used only for display of the final color image.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many applications generate scalar fields x; y; z which can be viewed by displaying isosurfaces where x; y; z = iso . Ideally, the value for iso is interactively controlled by the user. When the scalar field is stored as a structured set of point samples, the most common technique for generating a given isosurface is to create an explicit polygonal representation for the surface using a technique such as Marching Cubes <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b9">10]</ref>. This surface is subsequently rendered with attached graphics hardware accelerators such as the SGI Infinite Reality. Marching Cubes can generate an extraordinary number of polygons, which take time to construct and to render. For very large (i.e., greater than several million polygons) surfaces the isosurface extraction and rendering times limit the interactivity. In this paper, we generate images of isosurfaces directly with no intermediate surface representation through the use of ray tracing. Ray tracing for isosurfaces has been used in the past (e.g. <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14]</ref>), but we apply it to very large datasets in an interactive setting for the first time. In the appendices, we provide details that are new to the literature that are necessary to implement this algorithm.</p><p>The basic ray-isosurface intersection method used in this paper is shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Conventional wisdom holds that ray tracing is too slow to be competitive with hardware z-buffers. However, when rendering a surface from a sufficiently large dataset, ray tracing should become competitive as its low time complexity overcomes its large time constant <ref type="bibr" target="#b5">[6]</ref>. The same arguments apply to the isosurfacing problem. Suppose we have an n n n rectilinear volume which for a given isosurface value has On 2 polygons generated using Marching Cubes. Given intelligent preprocessing, the rendering time will be On 2 . Since it is hard to improve performance using multiple graphics engines, this seems a hard limit when using commercially available graphics accelerators unless a large fraction of the polygons are not visible <ref type="bibr" target="#b7">[8]</ref>. If a ray tracing algorithm is used to traverse the volume until a surface is reached, we would expect each ray to do On work. If the rays are traced on p processors, then we expect the runtime for an isosurface image to be On=p, albeit with a very large time constant and a limit that p is significantly lower than the number of pixels. For sufficiently large n, ray tracing will be faster than a z-buffer algorithm for generating and rendering isosurfaces. The question is whether it can occur on an n that occurs in practice (e.g., n = 500 to n = 1000) with a p that exists on a real machine (e.g., p = 8 to p = 128).</p><p>This paper demonstrates that with a few optimizations, ray tracing is already attractive for at least some isosurface applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Algorithm</head><p>Our algorithm has three phases: traversing a ray through cells which do not contain an isosurface, analytically computing the isosurface when intersecting a voxel containing the isosurface, shading the resulting intersection point. This process is repeated for each pixel on the screen. Since each ray is independent, parallelization is straightforward. An additional benefit is that adding incremental features to the rendering has only incremental cost. For example, if one is visualizing multiple isosurfaces with some of them rendered transparently, the correct compositing order is guaranteed since we traverse the volume in a front-to-back order along the rays. Additional shading techniques, such as shadows and specular reflection, can easily be incorporated for enhanced visual cues. Another benefit is the ability to exploit texture maps which are much larger than texture memory (typically up to 64 MBytes).</p><p>In the following subsections, we describe the details of our technique. We first address the ray-isosurface intersection followed by a description of various optimizations we have performed to achieve the interactive rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Ray-Isosurface Intersection</head><p>If we assume a regular volume with even grid point spacing arranged in a rectilinear array, then the ray-isosurface intersection is straightforward. Analagous simple schemes exist for intersection of tetrahedral cells, but the traversal of such grids is left for future work. This work will focus on rectilinear data.  <ref type="figure">Figure 2</ref>: The ray traverses each cell (left), and when a cell is encountered that has an isosurface in it (right), an analytic rayisosurface intersection computation is performed.</p><p>To find an intersection <ref type="figure">(Figure 2</ref>), the ray√£ + tb traverses cells in the volume checking each cell to see if its data range bounds an isovalue. If it does, an analytic computation is performed to solve for the ray parameter t at the intersection with the isosurface:</p><p>xa + tx b ; y a + ty b ; z a + tz b , iso = 0 :</p><p>When approximating with a trilinear interpolation between discrete grid points, this equation will expand to a cubic polynomial in t. This cubic can then be solved in closed form to find the intersections of the ray with the isosurface in that cell. Only the roots of the polynomial which are contained in the cell are examined. There may be multiple roots, corresponding to multiple intersection points. In this case, the smallest t (closest to the eye) is used.</p><p>There may also be no roots of the polynomial, in which case the ray misses the isosurface in the cell. The details of this intersection computation are given in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Optimizations</head><p>For the traversal of rays through the data, we use the incremental method described by Amanatides and Woo <ref type="bibr" target="#b0">[1]</ref>. We found that traversing the cells is the computational bottleneck for large datasets, so we include optimizations to accelerate performance.</p><p>The first optimization is to improve data cache locality by organizing the volume into "bricks" that are analogous to the use of image tiles in image-processing software and other volume rendering programs <ref type="bibr" target="#b2">[3]</ref>  <ref type="figure" target="#fig_2">(Figure 3</ref>). The details of our method for efficiently indexing cells is discussed in Appendix B.</p><p>The second is to use a multi-level spatial hierarchy to accelerate the traversal of empty cells as is shown in <ref type="figure" target="#fig_3">Figure 4</ref>. Cells are grouped divided into equal portions, and then a "macrocell" is created which contains the minimum and maximum data value for it's children cells. This is a common variant of standard ray-grid techniques <ref type="bibr" target="#b1">[2]</ref> and the use of minimum/maximum caching has been shown to be useful <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17]</ref>. The ray-isosurface traversal algorithm examines the min and max at each macrocell before deciding whether to recursively examine a deeper level or to proceed to the next cell. The average complexity of this search will be O 3 p n for a three level hierarchy. While the worst case complexity is still On, it is difficult to imagine an isosurface occuring in practice approaching this worst case. Using a deeper hierarchy can theoretically reduce the average case complexity slightly, but also dramatically increases the storage cost of intermediate levels. We have experimented with modifying the number of levels in the hierarchy and empirically determined that a tri-level hierarchy (one top-level cell, two intermediate macrocell levels, and the data cells) is highly efficient. This optimum may be data dependent and is modifiable at program startup. Using a tri-level hierarchy, the storage overhead is negligible ( 0:5% of the data size). The cell sizes used in the  hierarchy are independent of the brick sizes used for cache locality in the first optimization.</p><p>Since one cannot predict a priori the complexity of extracting an isosurface from a particular screen pixel, we employ a dynamic load balancing scheme to ensure high processor utilization over a wide range of views. The screen space is first split into tiles in the image space. In our implementation, tiles are 32 pixels wide by 4 pixels high. The width of the tile (128 bytes) ensures that tiles will not share a cache line with neighboring tiles. At the beginning of a frame, each tile becomes an assignment in a queue. Each processor pulls a range of assignments from the queue, performs the assigned work, and then returns to the queue for more work. The assignments, which are initially doled out in large chunks, get smaller and smaller as the frame nears completion. The large granularity in the beginning reduces contention for a large portion of the image, and the smaller granularity near the end helps to balance the load efficiently <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>We applied the ray tracing isosurface extraction to interactively visualize the Visible Woman dataset. The Visible Woman dataset is available through the National Library of Medicine as part of its Visible Human Project <ref type="bibr" target="#b11">[12]</ref>. We used the computed tomography (CT) data which was acquired in 1mm slices with varying in-slice resolution. This data is composed of 1734 slices of 512x512 images at 16 bits. The complete dataset is 910MBytes. Rather than down-sample the data with a loss of resolution, we utilize the full resolution data in our experiments. As previously described, our algorithm has three phases: traversing a ray through cells which do not contain an isosurface, analytically computing the isosurface when intersecting a voxel containing the isosurface, and shading the resulting intersection point.       <ref type="table" target="#tab_1">Table 1</ref> shows the percentages of time spent in each of these phases, as obtained through the cycle hardware counter in SGI's speedshop. As can be seen, we achieve about 10 frames per second (FPS) interactive rates while rendering the full, nearly 1GByte, dataset. <ref type="table" target="#tab_2">Table 2</ref> shows the scalability of the algorithm from 1 to 64 processors. View 2 is simpler than view 1, and thus achieves higher frame rates. Of course, maximum interaction is obtained with 128 processors, but reasonable interaction can be achieved with fewer processors. If a smaller number of processors were available, one could reduce the image size in order to restore the interactive rates. Efficiencies are 91% and 80% for view 1 and 2 respectively on 128 processors. The reduced efficiency with larger numbers of processors ( 64) can be explained by load imbalances and the time required to synchronize processors at the required frame rate. These efficiencies would be higher for a larger image. <ref type="table">Table 3</ref> shows the improvements which were obtained through the data bricking and spatial hierarchy optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>View</head><p>Initial  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>We contrast applying our algorithm to the Visible Woman data with previous work done by GE Corporate Research and Development Center <ref type="bibr" target="#b8">[9]</ref>. <ref type="table">Table 4</ref> shows the time required by their algorithm. There are two data resolutions reported: the full resolution and the data strided by 4 in all dimensions. In that work, the isosurfaces from the Visible Woman data were extracted using the Marching Cubes algorithm. When the data was strided by 4 in all dimensions, a total of 494,802 polygons make up the bone surface. If the Marching Cubes was applied to the full resolution data, the isosurface requires almost 10 million polygons. On a MIPS R10000 running at 190Mhz, the isosurface extraction for the down-sampled data took a full 10.07 seconds. This does not include rendering time. Thus, the time to generate an isosurface is dominated by the geometry extraction algorithm. Our algorithm can render 64 times more data (the Visible Woman at full resolution) at roughly 10 frames per second. For the full resolution isosurfaces, one might expect a straightforward implementation on the SGI Infinite Reality graphics accelerator to render the 10M polygons in about ten seconds. With heavily optimized code it might be possible to reduce this time to one second at best. Note that we gain efficiency for both the extraction and rendering components by not explicitly extracting the geometry. Our algorithm is therefore not well-suited for applications that will use the geometry for non-graphics purposes. The interactivity of our system allows exploration of both the data by interactively changing the isovalue or viewpoint. For example, one could view the entire skeleton and interactively zoom in and modify the isovalue to examine the detail in the toes all at about 10 FPS.</p><p>The architecture of the parallel machine plays an important role in the success of this technique. Since any processor can randomly access the entire dataset, the dataset must be available to each processor. Nonetheless, there is fairly high locality in the dataset for any particular processor. As a result, a shared memory or distributed shared memory machine, such as the SGI Origin 2000, is ideally suited for this application. The load balancing mechanism also requires a fine-grained low-latency communication mechanism for synchronizing work assignments and returning completed image tiles. With an attached Infinite Reality graphics engine, we can display images at high frame rates without network bottlenecks. We feel that implementing a similar technique on a distributed memory machine would be extraordinarily challenging, and would probably not achieve the same rates without duplicating the dataset on each processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future Work and Conclusions</head><p>Since all computation is performed in software, there are many avenues which deserve exploration. Ray tracers have a relatively clean software architecture, in which techniques can be added without interfering with existing techniques, without re-unrolling large loops, and without complicated state management as are characteristic of a typical polygon renderer.</p><p>We believe the following possibilities are worth investigating: Using an associated color volume as a 3D texture map for an isosurface.</p><formula xml:id="formula_0">œÅ 000 (x 0 ,y 0 ,z 0 ) (0,0,0) œÅ 100 (x 1 ,y 0 ,z 0 ) (1,0,0) œÅ 110 (x 1 ,y 1 ,z 0 ) (1,1,0) œÅ 111 (x 1 ,y 1 ,z 1 ) (1,1,1) œÅ 001 (x 0 ,y 0 ,z 1 ) (0,0,1) œÅ 011 (x 0 ,y 1 ,z 1 ) (0,1,1) œÅ 101 (x 1 ,y 0 ,z 1 ) (1,0,1) x y z œÅ 010 (x 0 ,y 1 ,z 0 ) (0,1,0)</formula><p>Exploration of other hierarchical methods in addition to the multilevel hierarchy described above.</p><p>Isosurfacing of tetrahedral and hexahedral element grids.</p><p>Combination with other scalar and vector visualization tools, such as cutting planes, surface maps, streamlines, etc.</p><p>Using higher-order interpolants. Although numerical root finding would be necessary, the images might be better <ref type="bibr" target="#b10">[11]</ref> and the intersection routine is not the bottleneck so the degradation in performance could be acceptable.</p><p>We have shown that ray tracing can be a practical alternative to explicit isosurface extraction for very large datasets. As data sets get larger, and as general purpose processing hardware becomes more powerful, we expect this to become a very attractive method for visualizing large scale scalar data both in terms of speed and rendering accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgements</head><p>Thanks to Matthew Bane and Michelle Miller for comments on the paper. Thanks to Chris Johnson for providing the open collaborative research environment that allowed this work to happen. Special thanks to Steve Modica and Robert Cummins at SGI for crucial bug fixes in support code. This work was supported by the SGI Visual Supercomputing Center, the Utah State Centers of Excellence, the Department of Energy and the National Science Foundation. Special thanks to Jamie Painter and the Advanced Computing Laboratory at Los Alamos National Laboratory for access to a 128 processor machine for final benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Ray-Isosurface Intersection</head><p>A rectilinear volume is composed of a three dimensional array of point samples that are aligned to the Cartesian axes and are equally spaced in a given dimension. A single cell from such a volume is shown in <ref type="figure" target="#fig_7">Figure 7</ref>. Other cells can be generated by exchanging indices i; j; k for the zeros and ones in the figure.</p><p>The density at a point within the cell is found using trilinear interpolation: </p><formula xml:id="formula_1">u; v; w = 1 , u1 , v1 , w 000 + (1) (x 0 , y 0 ) (x 1 , y 1 ) a b a 0 b 0 a 1 b 1 u 0 v 0 v 1 u 1 (0, 0) (1, 1) (1, 1) (0, 0)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Address Management For Bricks</head><p>Effectively utilizing the cache hierarchy is a crucial task in designing algorithms for modern architectures. Bricking or 3D tiling has been a popular method for increasing locality for ray cast volume rendering. The dataset is reordered into n n n cells which then fill the entire volume. On a machine with 128 byte cache lines, and using 16 bit data values, n is exactly 4. However, using float (32 bit) datasets, n is closer to 3.</p><p>Effective TLB utilization is also becoming a crucial factor in algorithm performance. The same technique can be used to improve TLB hit rates by creating m m m bricks of n n n cells. For example, a 40 20 19 volume could be decomposed into 4 2 2 macrobricks of 2 2 2 bricks of 5 5 5 cells. This corresponds to m = 2 and n = 5 . Because 19 cannot be factored by mn = 1 0 , one level of padding is needed. We use m = 5 for 16 bit datasets, and m = 6 for float datasets.</p><p>The resulting offset q into the data array can be computed for any x; y; z triple with the expression: This expression contains many integer multiplication, divide and modulus operations. On modern processors, these operations are extremely costly (32+ cycles for the MIPS R10000). For n and m which are powers of two, these operations can be converted to bitshifts and bitwise logical operations. However, as noted above the ideal size is not a power of two. Some of the multiplications can be converted to shift/add operations, but the divide and modulus operations are more problematic. The indices could be computed incrementally, but this would require tracking 9 counters, with numerous comparisons and poor branch prediction performance.</p><p>Note that this expression can be written as: We tabulate Fx, Fy, and Fz and use x, y, and z respectively to find three offsets in the array. These three values are added to compute the index into the data array. These tables will consist of Nx, Ny, and Nz elements respectively. The total sizes of the tables will fit in the primary data cache of the processor even for very large data set sizes. Using this technique, we note that one could produce mappings which are much more complex than the two level bricking described here, although it is not at all obvious which of these mappings would achieve the highest cache utilization. For isosurfacing, each iteration through the loop examines the eight corners of a cell. In order to find these eight values, we need to only lookup Fxx, Fxx + 1 , Fyy, Fyy + 1 , Fzz, and Fzz + 1 . This consists of six index table lookups for each eight data value lookups. Lookups for macrocells can be computed in the same way. However, in this case there will be three table lookups for each macrocell. This, combined with the significantly smaller memory footprint of the macrocells made the effect of bricking the macrocells negligible.</p><formula xml:id="formula_2">q = Fxx</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A ray is intersected directly with the isosurface. No explicit surface is computed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>œÅ(x, y, z)=œÅ isox = x a + t x b y = y a + t y b z = z a + t z bray equation:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Cells can be organized into "tiles" or "bricks" in memory to improve locality. The numbers in the first brick represent layout in memory. Neither the number of atomic voxels nor the number of bricks need be a power of two.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>With a two-level hierarchy, rays can skip empty space by traversing larger cells. A three-level hierarchy is used for the Visible Woman example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Ray tracings of the skin and bone isosurfaces of the Visible Woman (see color page).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>A ray tracing with and without shadows (see color page).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5</head><label>5</label><figDesc>shows a ray tracing for two isosurface values.Figure 6illustrates how shadows can improve our the accuracy of our geometric perception.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>The geometry for a cell. The bottom coordinates are the u; v; w values for the intermediate point.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Various coordinate systems used for interpolation and intersection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>q = x n mn 3 m 3</head><label>3</label><figDesc>Nz n mNy n m + y n mn 3 m 3 Nz n m + z n mn 3 m 3 + x n m o d mn 3 m 2 + y n m o d mn 3 m + z n m o d mn 3 + x mod n nn 2 + y mod n n + z mod n where Nx, Ny and Nz are the respective sizes of the dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>+ Fyy + Fzz where Fxx = x n mn 3 m 3 Nz n mNy n m + x n m o d mn 3 m 2 + x mod n nn 2 Fyy = y n mn 3 m 3 Nz n m + y n m o d mn 3 m + y mod n n Fzz = z n mn 3 m 3 + z n m o d mn 3 + z mod n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Data From Ray Tracing the Visible Woman. The framesper-second (FPS) gives the observed range for the interactively generated viewpoints on 64 CPUs.</figDesc><table><row><cell></cell><cell cols="2">View 1</cell><cell cols="2">View 2</cell></row><row><cell># of processors</cell><cell cols="2">FPS speedup</cell><cell cols="2">FPS speedup</cell></row><row><cell>1</cell><cell>0.18</cell><cell>1.0</cell><cell>0.39</cell><cell>1.0</cell></row><row><cell>2</cell><cell>0.36</cell><cell>2.0</cell><cell>0.79</cell><cell>2.0</cell></row><row><cell>4</cell><cell>0.72</cell><cell>4.0</cell><cell>1.58</cell><cell>4.1</cell></row><row><cell>8</cell><cell>1.44</cell><cell>8.0</cell><cell>3.16</cell><cell>8.1</cell></row><row><cell>12</cell><cell>2.17</cell><cell>12.1</cell><cell>4.73</cell><cell>12.1</cell></row><row><cell>16</cell><cell>2.89</cell><cell>16.1</cell><cell>6.31</cell><cell>16.2</cell></row><row><cell>24</cell><cell>4.33</cell><cell>24.1</cell><cell>9.47</cell><cell>24.3</cell></row><row><cell>32</cell><cell>5.55</cell><cell>30.8</cell><cell>11.34</cell><cell>29.1</cell></row><row><cell>48</cell><cell>8.50</cell><cell>47.2</cell><cell>16.96</cell><cell>43.5</cell></row><row><cell>64</cell><cell>10.40</cell><cell>57.8</cell><cell>22.14</cell><cell>56.8</cell></row><row><cell>96</cell><cell>16.10</cell><cell>89.4</cell><cell>33.34</cell><cell>85.5</cell></row><row><cell>128</cell><cell>20.49</cell><cell>113.8</cell><cell>39.98</cell><cell>102.5</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table /><note>Scalability results for ray tracing the bone isosurface in the visible human. A 512x512 image was generated using a single view of the bone isosurface.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :Table 4 :</head><label>34</label><figDesc>Data From GE Work on the Visible Human.</figDesc><table><row><cell cols="4">Data Res. Isosurface No. of Triangles Time in Secs.</cell></row><row><cell>Full</cell><cell>Skin</cell><cell>6,650,596</cell><cell>1335</cell></row><row><cell>Full</cell><cell>Bone</cell><cell>9,914,122</cell><cell>1218</cell></row><row><cell>4x4x4</cell><cell>Skin</cell><cell>503,064</cell><cell>10.04</cell></row><row><cell>4x4x4</cell><cell>Bone</cell><cell>494,802</cell><cell>10.06</cell></row></table><note>Times in seconds for optimizations for ray tracing the visi- ble human. A 512x512 image was generated on 16 processors using a single view of an isosurface.</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">, u1 , vw 001 +</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>x1 , x0</p><p>(2) v = y , y0 y1 , y0 w = z , z0 z1 , z0</p><p>Note that</p><p>1 , v = y1 , y y1 , y0</p><p>1 , w = z1 , z z1 , z0 If we redefine u0 = 1 , u and u1 = u, and similar definitions for v0; v 1; w 0; w 1, then we get:</p><p>For a given point x; y; z in the cell, the surface normal is given by the gradient with respect to x; y; z: N =r = @ @x ; @ @y ; @ @z Lin and Ching <ref type="bibr" target="#b6">[7]</ref> described a method for intersecting a ray with a trilinear cell. We derive a similar result that is more tailored to our implementation. See figure 8. Given a rayp =√£ + tb, the intersection with the isosurface occurs where p = iso . We can convert this ray into coordinates defined by u0; v 0; w 0:p0 =√£0+tb0 and a second ray defined byp1 =√£1 + tb1. Here the rays are in the two coordinate systems <ref type="figure">(Figure 8</ref>): a0 = u a 0 ; v a 0 ; w a 0 =</p><p>x1 , xa x1 , x0 ; y1 , ya y1 , y0 ; z1 , za z1 , z0</p><p>x1 , x0 ; y b y1 , y0 ; z b z1 , z0 :</p><p>These equations are different because√£0 is a location andb0 is a direction. The equations are similar for√£1 andb1: Note that t is the same for all three rays. This point can be found by traversing the cells and doing a brute-force algebraic solution for t.</p><p>The intersection with the isosurface p = iso occurs where:</p><p>This can be simplified to a cubic polynomial in t:</p><p>The solution to a cubic polynomial is discussed the article by Schwarze <ref type="bibr" target="#b12">[13]</ref>. We used his code (available on the web in several Graphics Gems archive sites) with two modifications: special cases for quadratic or linear solutions (his code assumes A is non-zero), and the EQN EPS parameter was set to 1.e-30 which provided for maximum stability for large coefficients.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A fast voxel traversal algorithm for ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Amanatides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics &apos;87</title>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">A survey of ray tracing acceleration techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Arvo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kirk</surname></persName>
		</author>
		<editor>Andrew S. Glassner</editor>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Academic Press</publisher>
			<pubPlace>San Diego, CA</pubPlace>
		</imprint>
	</monogr>
	<note>, editor, An Introduction to Ray Tracing</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Application-controlled demand paging for Out-of-Core visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ellsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;97</title>
		<meeting>Visualization &apos;97</meeting>
		<imprint>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data structures for soft objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wyvill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wyvill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcpheeters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="227" to="234" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Octree optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename><surname>Globus</surname></persName>
		</author>
		<idno>RNR-90- 011</idno>
		<imprint>
			<date type="published" when="1990-07" />
		</imprint>
		<respStmt>
			<orgName>NASA Ames Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An overview and comparison of rendering methods. A Consumer&apos;s and Developer&apos;s Guide to Image Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">T</forename><surname>Kajiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Siggraph &apos;88 Course 12 Notes</title>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="259" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An efficient volumerendering algorithm with an analytic approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chyi-Cheng</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu-Tai</forename><surname>Ching</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="515" to="526" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">View dependent isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yarden</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;98</title>
		<meeting>Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998-10" />
		</imprint>
	</monogr>
	<note>This proceedings</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Marching through the visible woman</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bill</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Siggraph &apos;87 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An evaluation of reconstruction filters for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Marschner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Lobb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;94</title>
		<meeting>Visualization &apos;94</meeting>
		<imprint>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="100" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Electronic imaging: Report of the board of regents. u.s. department of health and human services, public health service, national institutes of health</title>
		<imprint>
			<date type="published" when="1990" />
			<publisher>NIH Publication</publisher>
			<biblScope unit="page" from="90" to="2197" />
		</imprint>
		<respStmt>
			<orgName>National Library of Medicine (U.S.</orgName>
		</respStmt>
	</monogr>
	<note>Board of Regents</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Cubic and quartic roots</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jochen</forename><surname>Schwarze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Gems</title>
		<editor>Andrew Glassner</editor>
		<meeting><address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="404" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast surface rendering from raster data by voxel traversal using chessboard distance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Sramek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;94</title>
		<meeting>Visualization &apos;94</meeting>
		<imprint>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="188" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Multiprocessor Methods for Computer Graphics Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Whitman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<publisher>Jones and Bartlett Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="57" to="62" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
