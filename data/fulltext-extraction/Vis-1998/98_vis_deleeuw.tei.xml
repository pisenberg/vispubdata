<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Comparing LIC and Spot Noise</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wim</forename><surname>De Leeuw</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Robert van Liere Center for Mathematics and Computer Science</orgName>
								<address>
									<region>CWI</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Comparing LIC and Spot Noise</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I</term>
					<term>3</term>
					<term>3 [Computer Graphics]: Picture/Image Generation; I</term>
					<term>3</term>
					<term>6 [Computer Graphics]: Methodology and Techniques I</term>
					<term>6</term>
					<term>6 [Simulation and Modeling]: Simulation Output Analysis flow visualization, texture synthesis</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Spot noise and line integral convolution (LIC) are two texture synthesis techniques for vector field visualization. In this paper the two techniques are compared. Continuous directional convolution is used as a common basis for comparing the techniques. It is shown that the techniques are based on the same mathematical concept. Comparisons of the visual appearance of the output and performance of the algorithms are made.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Among the techniques used for the visualization of vector fields, texture based methods are a recent development. By using texture, a continuous visualization of a two-dimensional vector field can be presented. <ref type="figure" target="#fig_9">Figure 8</ref> shows a visualization of a slice from a direct numerical simulation using texture. The images show the turbulent flow around a block. These images clearly show the power of texture as a medium for visualization. The visual effect of direction is achieved by line structures in the direction of the vector field. These lines are the result of higher coherency between neighboring pixels in the field direction. Spot noise and line integral convolution (LIC) are two texture based techniques for vector field visualization that make use of this principle.</p><p>Before texture was used for data visualization, many papers appeared dealing with the generation of textures <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b2">3]</ref>. The purpose was artistic or for giving images a realistic appearance. Perlin <ref type="bibr" target="#b8">[9]</ref> used directed convolution of random images as a texture synthesis technique to produce images of flames.</p><p>Spot noise, introduced by van Wijk <ref type="bibr" target="#b12">[13]</ref>, was the first texture synthesis technique for the visualization of vector data. A spot noise texture is synthesized by distributing a large number of small intensity functions -called spots -over the domain of the data. Data is visualized by transforming the spot as a function of the underlying vector field. Furthermore the concept of texture animation was introduced for static vector fields. Subsequent texture frames are generated by considering the spots as particles and advecting the spot positions in the vector field.</p><p>Line integral convolution, introduced by Cabral and Leedom <ref type="bibr" target="#b0">[1]</ref>, uses a piece of a streamline as a filter kernel for the convolution of a random texture. Animation can be realized by cyclic shifting of the filter kernel in subsequent frames.</p><p>In later papers both LIC and spot noise have been improved and extended. Improvements include increased texture synthesis speeds, generalizations of grid types, usage of the techniques with time dependent vector fields, and zooming in on details.</p><p>In this paper we compare both techniques and some extensions. In Section 2, spot noise and LIC are briefly described. We describe CWI, Department of Software Engineering, P.O. Box 94097, 1090 GB Amsterdam, Netherlands. E-mail fwimcjrobertlg@cwi.nl the governing algorithms and some extensions. In Section 3 a common basis is given. By using continuous directional convolution as a basis, it is shown that both techniques share a common underlying principle. We also discuss texture synthesis for time dependent vector fields using this common basis. The techniques will be compared with respect to output texture and performance in Section 4. The conclusions will be presented in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">LIC AND SPOT NOISE 2.1 Algorithm</head><p>A LIC texture is generated by convolution of an input texture with a one-dimensional filter kernel. The shape of the kernel is determined by the shape of the streamline through the pixel. A pixel in the final texture is determined by the weighted sum of a number of pixels along a line in the input texture:</p><formula xml:id="formula_0">Couti; j = X p Cinphp; (1)</formula><p>where is the set of pixels in the input texture used for convolution,</p><p>Cinp is the value of the input texture pixel at grid cell p and hp is the convolution filter.  <ref type="figure" target="#fig_0">Figure 1</ref> gives an overview of the main components of the algorithm. The inputs of the algorithm are a random texture and the vector field. Streamlines are calculated from the vector field and are used for convolution of the input texture. This results in the output texture.</p><p>A spot noise texture is generated by blending together a large number of small intensity functions at random positions on a plane. The shape of the intensity functions is deformed in relation to the vector field. Spot noise is described by the following equation:</p><formula xml:id="formula_1">fx = X aihx ,xi; (2)</formula><p>in which hx is called the spot function. It is an intensity function which has a non zero value only in the neighborhood of the origin.</p><p>ai is a random scaling factor with a zero mean andxi is a random position. The deformation used in <ref type="bibr" target="#b12">[13]</ref> was a rotation in the direction of the vector field and scaled by a factor of 1 + jṽj in the velocity direction and 1=1 + jṽj perpendicular to the field. <ref type="figure" target="#fig_2">Figure 2</ref> shows a schematic representation of the algorithm. The vector field together with a set of random positions and intensities form the input of the algorithm. From these two inputs the positions and shapes of the spots can be determined. This results, after spot blending, in the output texture.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Extensions</head><p>To be a useful tool for the analysis of vector fields, a number of extensions to spot noise and LIC have been proposed. Here we limit our discussion to six extensions:</p><p>Non-uniform grids. The data may be defined on a grid with an irregular geometry or topology. Mapping the texture to an curved surface will introduce deformations. If the data has a regular topology the deformation problem can be addressed by transforming the data to a flat geometry. This can be a uniform grid as was described in <ref type="bibr" target="#b1">[2]</ref> or a rectilinear grid <ref type="bibr" target="#b5">[6]</ref>. Using a rectilinear grid in which the size of the cells matches the cell sizes in the undeformed data results in better mapped textures because the scaling of the texture elements is more uniform.</p><p>Performance. Performance is crucial for interactive visualization. Both techniques require substantial computations and performance of the algorithm is therefore important. LIC can be parallelized by partitioning the texture in a number of sub domains <ref type="bibr" target="#b14">[15]</ref>. Each sub domain can then be processed in parallel. Furthermore, the generation of LIC texture can be accelerated by using the coherence between successive pixels on a streamline. A substantial performance gain can be achieved by generating long streamlines and reusing them for a large number of pixels. Spot noise can be parallelized because the processing of one spot can be done independently from the other spots. Therefore, processing of all spots can be distributed over a number of processors. A second method to speed up spot noise is by utilizing graphics hardware <ref type="bibr" target="#b5">[6]</ref>. Spot rendering and blending can be mapped on functions for which hardware support is available. Both ways to speed up generation have been combined <ref type="bibr" target="#b4">[5]</ref>.</p><p>Animation and time dependent flow. Although the information of a stationary flow is available in a single texture, animation can provide important additional information. Animation is even more important when the flow simulation is time dependent. For stationary flow, a technique was presented where the kernel is shifted for subsequent frames. Animation of time dependent flow can be achieved by UFLIC, described in <ref type="bibr" target="#b9">[10]</ref>. Here the values in the texture are deposited along path lines to generate subsequent textures. Using spot noise animation can be achieved by regarding the spots as particles and use advection equations to calculate new spot positions for subsequent frames <ref type="bibr" target="#b12">[13]</ref>. More about the use of texture in time dependent flow can be found in Section 3.4.</p><p>Zooming. In high resolution simulations flow features can vary three orders of magnitude in size. A single image can impossibly provide all information. Small details in the data can only be perceived if the user is able to magnify a part of the field. In LIC, zooming can be achieved by using high resolution input textures and relating the output texture resolution to the scale at which an image is desired. In spot noise, zooming requires that the texture is regenerated using a smaller part of the data using smaller spots.</p><p>3D. Visualization of 3D vector fields is possible with Volume-LIC introduced by Interrante and Grosch <ref type="bibr" target="#b3">[4]</ref>. They used the generalization of LIC to 3D in combination with volume rendering for the visualization of 3D flows. Because the presentation of dense volumes is very difficult, selection methods were used to filter the input texture and therefor the area in which the flow is shown. Work on 3D spot noise has not been reported.</p><p>Flow direction. Both spot noise and LIC are ambivalent with respect to the direction of the flow. Wegenkittl et al. <ref type="bibr" target="#b13">[14]</ref> present a modification of LIC algorithm in which sparse input textures are combined with an oriented filter. In this way the ambivalence in the direction is addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">COMMON BASIS</head><p>In the previous section, we have shown that spot noise and Line Integral Convolution textures are synthesized by considering a neighborhood of a pixel. In this section we will show that both techniques can be described in terms of convolution over a certain region. As an introduction we will use a simplified model to explain the idea. Then, a more formal treatment will be given by using continuous directional convolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Simplification</head><p>To illustrate the commonality between the LIC and spot noise techniques, we start with two simplified variations of LIC and spot noise. For LIC, a straight line segment is used in the direction of the flow at the center of the calculated pixel. This is the DDA (Digital Differential Analyzer) convolution as described in Cabral and Leedom <ref type="bibr" target="#b0">[1]</ref>. 0 (see equation 1) is the set of pixels determined by the line segment when it is rasterized. If a constant convolution kernel is assumed, then a pixel value is calculated as:</p><formula xml:id="formula_2">Couti; j = X p 0 Cinp (3)</formula><p>For spot noise, scan converted lines of a fixed length are used. The spots are placed at the center of each pixel in the direction of the flow. Now equation 2 can be rewritten as:</p><formula xml:id="formula_3">Couti; j = X p 1 Rspotp (4)</formula><p>where Rspotp is the value of the spot at position p.</p><p>These equations produce equivalent output texture because Cin is equivalent to Rspot and 0 is the same as 1. The intensity of a spot Rspotp and the pixel value in the input texture Cinp are both uniformly distributed random values. That the set of input values 0 and 1 are the same can be seen in <ref type="figure" target="#fig_3">Figure 3</ref>. On the left, the kernel and the pixels in the input texture are shown. These pixels (grey region) determine the output pixel (the small box) for DDA-convolution. The right image shows the location of spots that influence the pixel of interest (box). A spot influences the pixel of interest if it covers this pixel. Seven spots (the center is shown by black dots) define 1. Dotted lines indicate a spot's extent (to avoid cluttering only two dotted lines are drawn).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Continuous directional convolution</head><p>It is not possible to generate images using streamlines of a constant width and constant density. Due to convergence/divergence the density of lines changes resulting in a higher/lower density. Turks and Banks <ref type="bibr" target="#b11">[12]</ref> propose a method which results in an approximation of constant density by calculating the local density of an initial random set of streamlines. This set is iteratively improved by adding or deleting stream lines based on the local density. They also suggest variation of the width of stream lines to get a uniform coverage. Random value based texture techniques also give an approximation of this idea. In texture based techniques the pixels in the direction of the flow do not have equal intensity, but the impression of lines is achieved. This is the result of a higher correlation of pixels in the direction of the flow, compared to perpendicular to the flow. Due to the slow variations which occur, no discontinuities are introduced.</p><p>For a more detailed study of this idea, we in introduce continuous directional convolution. The input texture is a continuous function of position: Cinx and the convolution equation can be written as:</p><formula xml:id="formula_4">Coutx = Z 1 ,1 Cin skx ,sds (5)</formula><p>where kx is the two-dimensional kernel and x is a twodimensional deformation function. The function Cinx is a twodimensional white noise signal. Since the kernel is usually non-zero only in a finite region, the integral need only to be evaluated in a region aroundx.</p><p>The shape of the filter depends on the desired effect. Possibilities are a line with or without a certain width or a more complicated two-dimensional shape (see <ref type="figure" target="#fig_4">Figure 4)</ref>. In terms of frequencies, the purpose of the filter is to achieve an anisotropic filtering of the input where the maximum frequency in the field direction is lower as in the perpendicular direction. According to filtering theory, the best result would be achieved using the an anisotropic low-pass filter (see <ref type="figure" target="#fig_4">Figure 4</ref> lower right) with the main axis deformed using a streamline. In practice, however, the convolution must be carried out at a finite resolution. To suppress artifacts due to aliasing introduced by the finite resolution of the texture the same type of anti-aliasing used for the rendering of lines could be used.</p><p>It is also possible to encode information regarding the velocity magnitude. This can be done by a parameterizing the filter kernel with the velocity magnitude. In spot noise, the velocity magnitude is encoded in the difference of the frequency in the direction of the flow and the frequency perpendicular to the flow. The same principle could be incorporated in the continuous directional convolution by parameterizing the width of the filter inversely proportional to the velocity magnitude.</p><p>Spot noise and LIC are both approximations of continuous directional convolution. The following observations can be made with respect to the approximation:</p><p>In LIC, a scan converted curve is used as the kernel. The kernel has the shape of a connected set of pixels of a particular size. This leads to irregular filtering in the direction perpendicular to the field.</p><p>In spot noise, there are only a finite number of spots. In terms of convolution, the input texture consists of a finite number of randomly placed impulses with a random energy. Since convolution is a linear operator, the convolution integral (equation 5) over this input texture can be evaluated by summation of the separate responses to each impulse (equation 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Conversion between the methods</head><p>Continuous directional convolution can be used to 'translate' concepts used by both techniques. Concepts in spot noise can be translated to concepts in LIC and vise versa. For example, in spot noise, the magnitude of the flow is visualized using spot scaling. Because the spot shape performs the same role as the kernel shape in LIC, one might expect that similar results might be obtained in LIC by variation of the length of the kernel. Another example: in spot noise it is easy to generate animations in a stationary flow by spot advection. In LIC this could be realized by advection of the input texture. Each pixel could be regarded as a particle which is advected for some time step. Alternatively, the phase shifting of the kernel technique proposed for LIC could be implemented in spot noise by using a spot shape with a shifting phase in different frames. These examples show that concepts used by the two techniques can be mapped onto each other. The table below lists a number of similar concepts for both techniques. spot noise LIC random spot intensity random input texture spot function kernel shape spot scaling kernel length variation standard spots DDA convolution bent spots streamline convolution spot advection texture advection</p><p>We could generate spot noise textures using a variant of LIC and, vise versa, LIC textures using a variant of spot noise. The line integral convolution algorithm can be adapted to generate spot noise textures by using a two-dimensional filter domain. The shape of the domain is determined by all positions around the filtered points which, if a spot would be placed there, would cover the filtered point. The spot noise algorithm can be adapted to generate LIC textures. Spots would have the shape of a streamline and would be rendered at the center of each pixel in the texture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Time dependent vector fields</head><p>A first application of the common basis is the study of texture animation of time dependent vector fields. The challenge of texture animation is to maintain two types of coherence in the textures. To perceive flow, two issues must be addressed. First, spatial coherency (the lower frequency in the field direction as described in the previous section) must be maintained. Second, temporal coherency must be maintained. Temporal coherence is defined as the movement of patterns between texture frames. The impression of movement results when patterns are displaced for a small distance in subsequent frames.</p><p>In a stationary flow, temporal coherence is obtained by using the same principle as is used for spatial coherence. Between successive frames texture values are advected along streamlines. Particle positions on a streamline are calculated by:</p><formula xml:id="formula_5">x =x0 + Z x x 0ṽ</formula><p>xdx <ref type="bibr" target="#b5">(6)</ref> whereṽx is the velocity at positionx For time dependent flow, temporal coherence is obtained only if particle paths are used to advect the texture. A particle path is expressed as:</p><formula xml:id="formula_6">xt = xt0 + Z t t 0ṽ</formula><p>xtdt (7) For spatial coherence, streamlines should be used to determine the filtering domain. On the other hand, to get the best possible temporal coherence particle paths should used. This is illustrated in <ref type="figure" target="#fig_5">Figure 5</ref>. The three columns show different time steps of a flow field. The flow is spatially uniform and the direction varies linear with time, as illustrated in the top row of th <ref type="figure">Figure.</ref> In rows two and three, two kernels are followed over time. Dotted lines indicate particle paths. Bold lines indicate the shape of the kernel. Note that in this particular case streamlines are straight line segments which is not true in general.</p><p>Temporal coherence is maintained if particle paths are used, however, it compromises the spatial coherence of the texture. This is because particle paths, and therefore kernels, may intersect, (as is shown in the first column of the <ref type="figure">Figure)</ref> resulting in artifacts in the texture. The crossing of kernels introduces high frequency components in the direction of the flow. Using streamlines compromises the temporal coherence of the texture, as the actual path of the flow may differ from the path suggested by the texture. <ref type="figure" target="#fig_6">Figure 6</ref> compares textures generated using particle paths and streamlines for the kernel shape. The data used for this images is the rotating uniform vector field described in <ref type="figure" target="#fig_5">Figure 5</ref>. The Figure shows that using particle paths results in high frequencies in all directions and thus compromises spatial coherency in the field direc-tion. Using streamlines high frequencies occur only perpendicular to the field direction. There is no perfect solution for the coherency problem. However, useful compromises were taken by UFLIC <ref type="bibr" target="#b9">[10]</ref> in which the texture at a certain moment might not represent the current vector field perfectly. Spot noise uses streamlines for the spot shape compromising temporal coherence. These partial solutions are useful as long as the user knows the limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">COMPARISON</head><p>A comparison of the of both algorithms is difficult to realize because the algorithms produce different outputs. It is not possible to adjust the parameters for the methods such that they produce equal textures. Furthermore, there is no metric to compare the information content of texture.</p><p>Nevertheless, in this section we will present a metric for comparing textures. We use this metric as an measure to compare the performance of the techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Output texture comparison</head><p>Because both methods do not produce the same texture a metric must be found to compare output textures. We define this metric by introducing the notion of pixel coverage. Pixel coverage is defined as the number of random values contributing to a pixel. Textures are defined to be equivalent if the pixel coverage for each pixel is the same.</p><p>In the previous section we found that a spot and a kernel are comparable concepts. For a certain kernel a spot can be found such that the area covered is equal to the area of the pixels under a kernel in LIC (see <ref type="figure" target="#fig_8">Figure 7)</ref>. The average area covered be a kernel is the filter length l f multiplied by the width of a single pixel. If we normalize the width and length of the complete texture to 1 and measure the length of the kernel in pixels, then the area of a kernel  </p><formula xml:id="formula_7">A k = l f res 2<label>(8)</label></formula><p>where resis the resolution of the texture. A disc shaped spot with a comparable surface has a radius rs of</p><formula xml:id="formula_8">rs = r A k = r l f res 2 (9)</formula><p>Each pixel must be covered by l f spots therefore the number of spots N to be used is</p><formula xml:id="formula_9">N = l f r 2 s = res 2<label>(10)</label></formula><p>In <ref type="figure" target="#fig_9">Figure 8</ref> the same vector field is visualized using both techniques. The image on the left shows the field using LIC while spot noise is used for the right image. The data is a slice from a direct numerical simulation of a turbulent flow around a block and is defined on a rectilinear grid. The resolution of the data is 316 538.</p><p>The flow is from the bottom to the top of the image. The visualization shows the vortex shedding in the wake behind the block.</p><p>The resolution of both textures is 512 512. For the LIC texture a kernel length of 20 pixels was used. Using Equations 9 and 10 we obtained values giving an equal pixel coverage for the spot noise image. Because the large majority of grid cells in the data is smaller than a texel the amount of detail which could be visible is limited by the texture resolution. For further investigation we used a detail behind the block. This is shown in In <ref type="figure" target="#fig_10">Figure 9</ref>. In the lower part of the images the block is visible. The data resolution of the section shown is 166 144. Using 512 512 textures the smallest grid cells in the data are about 4 texels in size. In the top left image the filter length used for LIC is 20 pixels while in the bottom left image a filter length of 40 used. The spot noise images have equal pixel coverage using parameters calculated by Equations 9 and 10.</p><p>From this side by side comparison a number of differences can be noted. In the LIC image rotation centers are visualized more accurately. For example: the LIC images clearly show the two distinct rotation centers in the rotation area in the top left of the field. The velocity in the rotation centers is relatively low and therefor the spot noise textures become almost isotropic. In addition to displaying velocity direction information, the spot noise image shows the magnitude of the field; e.g. the upper right corner of the image shows a region of higher velocity. Unfortunately, this extra information decreases resolution of the directional information. The frequency range needed to encode the velocity magnitude reduces the frequency at which the directional information is displayed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Performance comparison</head><p>The performance can be compared in several ways. First we will do some order estimation of the performance of the algorithms. Second, we will look at extensions to the algorithms for increased performance. Finally, we will present some measurements.</p><p>In unaccelerated LIC the time needed to generate a texture increases linear with the number of pixels in the output texture and linear with the length of the kernel. For spot noise the time needed increases linear with the number of the spots and linear with the area of the spots. If the comparable textures are generated, such as described in the previous section, it is easy to see that the order of generation time of the algorithms is equal. However, the basic operations which have to be carried out are different. For spot noise scan conversion operations are needed and for LIC convolution and stream line integration operations are needed.</p><p>The previous analysis is valid for the original algorithms. Several ways have been proposed to speed up the algorithms. In the algorithm for LIC proposed by Stalling and Hege <ref type="bibr" target="#b10">[11]</ref> the algorithm consists of two steps. In the first step stream lines are calculated and in the second step the convolution is carried out by successive processing of pixels along streamlines where results are reused. In this way, the complexity of the algorithm becomes independent of the filter length. For spot noise, graphics hardware can be utilized to speed up scan conversion an blending of the spots <ref type="bibr" target="#b5">[6]</ref>. Although this does not change the order of complexity, substantial gains can be achieved in the generation time. Parallelization is another way to speed up the algorithms. LIC can be parallelized by dividing the texture in tiles <ref type="bibr" target="#b14">[15]</ref>. Parallelization of spot noise is possible by distributing the spots over the processors. The combination of hardware acceleration and parallelization for spot noise is possible if the available processor power is matched by the speed of the graphics hardware <ref type="bibr" target="#b4">[5]</ref>.</p><p>As a test case to compare the speed the algorithms we used the detail of the DNS described in the previous section (see <ref type="figure" target="#fig_10">Figure 9)</ref>. The tests were run on a SGI Indigo 2 workstation equipped with a 250 MHz R4400 processor and a High Impact graphics board. For LIC the original implementation as described in <ref type="bibr" target="#b0">[1]</ref> was used. For spot noise an implementation taking advantage of graphics hardware was used. The results for this unfair comparison were 93.5 seconds for LIC and 6.7 seconds for spot noise. For the LIC image a filter length of 20 was used, the spot noise image was generated with a spot radius of 0.005. For the images with a filter length of 40 and a spot radius of 0.007 the times were 182.3 and 6.6 respectively.</p><p>We get a better comparison if use the results of accelerated LIC with the times presented for spot noise. The timing results presented in <ref type="bibr" target="#b10">[11]</ref> indicate that 4.6 seconds are needed for the generation a similar LIC texture on slightly slower hardware using the acceleration techniques described in the paper. This would suggest that LIC is slightly faster than spot noise.</p><p>In this comparison we used textures with equal pixel coverage. However, a number of parameters in spot noise allow trading quality for speed. <ref type="figure" target="#fig_0">Figure 10</ref> shows spot noise images in which less spots were used. Compared to the spot noise textures in <ref type="figure" target="#fig_10">Figure 9</ref>, 20 percent of the number of spots were used in the left image, and 5 percent in the right image. The times needed to generate these images were 1.3 and 0.35 seconds. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>In this paper LIC and spot noise were compared. Both techniques use texture synthesis for vector field visualization. Directional information in textures is encoded by coherence between neighboring pixels. Due to differences between the techniques and the concepts used to discribe them, a direct comparison would be very difficult. By using continuous directional convolution as a model, the similarity in the underlying mathematical basis becomes clear, and similar concepts in the techniques can be found.</p><p>The diffences in information presented by both techniques are due to the fact that LIC does not encode velocity magintude. Therefore, the spatial resolution for presenting directional information is higher than for a comparable spot noise texture. If the acceleration scemes proposed for the techniques are taken into account the differences in performance of LIC is slightly better than of spot noise. Spot noise is more flexible with respect to trading texture quality for generation speed.</p><p>Continuous Directional Convolution is used to show that for texture animation of time dependent flow, it is not possible to fully satisfy the requirements of spatial coherence in the texture and temporal coherence in frames. We believe that continuous directional convolution can serve as a basis for future study and improvements of texture synthesis techniques for flow visualization.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Schematic representation of the LIC-algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Schematic representation of the spot noise algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Pixels making up the kernel shape of DDA-Convolution and the location of spots influencing the texture value in simplified spot noise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Possible filter shapes for continuous directional convolution, one-dimensional filter, triangle swept along a streamline, swept rectangle, 'spot', and low-pass filter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Stream lines or path lines used for coherence in texture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>particle paths (left) and streamlines (right) used for texture synthesis in a rotating flow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Equal coverage of a pixel: the number of input values which influence a pixel is equal for LIC (left) and spot noise (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>LIC (left) and spot noise (right) images of turbulent flow around a block.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>LIC (left) and spot noise (right) images with equal pixel coverage using a filter length of 20 and a spot radius of 0.005. (top) and using a filter length of 40 and a spot radius of 0.007. (bottom)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 :</head><label>10</label><figDesc>Trading quality for speed in spot noise. Texture using 50000 spots (left) and 12500 spots (right)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Thanks to Arthur Veldman and Roel Verstappen University of Groningen for using their data. We are grateful to the reviewers who gave valuable ideas for improvements of the paper. This work is partially funded by the Dutch foundation High Performance Computing and Networking (High Performance Visualization project).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Imaging Vector Fields Using Line Integral Convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 93 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Using Line Integral Convolution for Flow Visualization: Curvilinear Grids, Variablespeed Animation, and Unsteady Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">K</forename><surname>Forssell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="141" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Painting by Numbers: Abstract Image Representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haeberli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 90 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1990-07" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="207" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Strategies for Effectively Visualizing 3D Flow with Volume LIC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victoria</forename><surname>Interrante</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chester</forename><surname>Grosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;97</title>
		<editor>R. Yagel and H. Hagen</editor>
		<meeting>Visualization &apos;97<address><addrLine>Los Alamitos (CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="421" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Divide and Conquer Spot Noise</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>De Leeuw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Liere</surname></persName>
		</author>
		<ptr target="http://scxy.tc.cornell.edu/sc97/program/TECH/DELEEUW/INDEX.HTM" />
	</analytic>
	<monogr>
		<title level="m">Proceedings Super Computing &apos;97</title>
		<meeting>Super Computing &apos;97</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Enhanced Spot Noise for Vector Field Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>De Leeuw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;95</title>
		<editor>G.M. Nielson and D. Silver</editor>
		<meeting>Visualization &apos;95<address><addrLine>Los Alamitos (CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="233" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Texture Synthesis for Digital Painting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J-P</forename><surname>Lewis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 84 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1984-07" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="245" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Solid Texturing of Complex Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Peachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 85 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1985-07" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Image Synthesizer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Perlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 85 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1985-07" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="287" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">UFLIC: A Line Integral Convolution Algorithm for Visualizing Unsteady Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Kao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;97</title>
		<editor>R. Yagel and H. Hagen</editor>
		<meeting>Visualization &apos;97<address><addrLine>Los Alamitos (CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="317" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast and Resolution Independent Line Integral Convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stalling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 95 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="249" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Image-Guided Streamline Placement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Banks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996-07" />
			<biblScope unit="page" from="453" to="460" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Spot Noise -Texture Synthesis for Data Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 91 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast Oriented Line Integral Convolution for Vector Field Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wegenkittl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduard</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;97</title>
		<editor>R. Yagel and H. Hagen</editor>
		<meeting>Visualization &apos;97<address><addrLine>Los Alamitos (CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="309" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Parallel Line Integral Convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zöckler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stalling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings First Eurographics Workshop on Parallel Graphics and Visualization</title>
		<editor>A. Chalmers and F.W. Jansen</editor>
		<meeting>First Eurographics Workshop on Parallel Graphics and Visualization<address><addrLine>Bristol, UK</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="26" to="27" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
