<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Simplification of Tetrahedral Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Issac</forename><forename type="middle">J</forename><surname>Trotts</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Image Processing and Integrated Computing Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95616-8562</postCode>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Image Processing and Integrated Computing Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95616-8562</postCode>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
							<email>joy@cs.ucdavis.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Image Processing and Integrated Computing Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95616-8562</postCode>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">F</forename><surname>Wiley</surname></persName>
							<email>wileyg@cs.ucdavis.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Center for Image Processing and Integrated Computing Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95616-8562</postCode>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Simplification of Tetrahedral Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Approximation</term>
					<term>hierarchical representation</term>
					<term>mesh generation</term>
					<term>multiresolution method</term>
					<term>scattered data</term>
					<term>spline</term>
					<term>triangulation</term>
					<term>visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present a method for the construction of multiple levels of tetrahedral meshes approximating a trivariate function at different levels of detail. Starting with an initial, high-resolution triangulation of a three-dimensional region, we construct coarser representation levels by collapsing tetrahedra. Each triangulation defines a linear spline function, where the function values associated with the vertices are the spline coefficients. Based on predicted errors, we collapse tetrahedron in the grid that do not cause the maximum error to exceed a use-specified threshold. Bounds are stored for individual tetrahedra and are updated as the mesh is simplified. We continue the simplification process until a certain error is reached. The result is a hierarchical data description suited for the efficient visualization of large data sets at varying levels of detail.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>One of the most critical and fundamental research problems encountered in the analysis and visualization of massive data sets is the development of methods for storing, approximating, and rendering large volumes of data efficiently. The problem is to develop different representations of the data set, each of which can be substituted for the complete set depending on the requirements of the analysis or the visualization technique. The data set may be represented by a few points, or by several million if necessary, with each of the data sets capturing the features of the original data. A hierarchical representation (or multiresolution representation) allows the study of large-scale features by considering a small subset and the study of small-scale features by considering a large subset of a given scientific data set.</p><p>Most scientific data sets are multivalued, meaning that multiple dependent variables -e.g., velocity, pressure, temperature, salinity, sound speed, chemical or nuclear contamination, or even entire "matrices" (tensors) -are associated with each grid point. The grids may represent a surface or a volume in space, and the underlying grid may belong to various grid types: it may be structured, where, in the volumetric case, the grid cell arrangement consists of hexahedral cells, or it may be unstructured, with a cell arrangement consisting of tetrahedra, hexahedral cells, or even combinations of various types of cells. Extremely large data sets cannot be analyzed or visualized in real time unless data reduction/compression methods are used, or "features," extracted from the given data sets in a preprocessing step, are rendered.</p><p>In this paper, we focus on 3-dimensional tetrahedral meshes. These meshes provide the greatest possible degree of flexibility and are less restrictive than all other mesh topologies, e.g., Cartesian, rectilinear, and curvilinear. Furthermore, each mesh can be converted into a tetrahedral mesh. Data structures, data traversal, and data rendering for tetrahedral meshes are, in most cases, more involved than for more "structured" representations. Nevertheless, when visualizing very large data sets defined over complex threedimensional regions it is more convenient to use tetrahedral meshes due to their ability to better adapt to local features. It is also important to investigate means for the representation of tetrahedral meshes at various levels of detail for efficient rendering and analysis.</p><p>Our method for the generation of a hierarchy of tetrahedral meshes is based on collapsing individual tetrahedra and removing them from the mesh. Considering a particular mesh, we weigh each tetrahedron based on a predicted increase in approximation error that would result after its collapse. The tetrahedra are ordered by these weights and collapsed one-by-one, with changes in the errors of the neighboring tetrahedra reflected in the new ordering.</p><p>The construction of multiple levels of tetrahedral meshes is a preprocessing step for subsequent data visualization. Speed is not the primary concern when constructing the levels; it is more important that the resulting data format be compact and allow for simple and efficient access during the visualization process. Error estimates should be known for each level as well.</p><p>In Section 2, we review the algorithms related to mesh simplification that apply to our work. In Section 3, we illustrate our technique for triangle meshes in the plane. The main principles become very clear from the discussion of the planar case. In Section 4 we describe the needed extensions for tetrahedral meshes. Implementation issues are discussed in Section 5 and the results of our algorithm are illustrated on a set of complex examples in Section 6. Conclusions and future work are discussed in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Three classes of algorithms exist that directly pertain to our work and that deal with triangle or tetrahedral meshes: Algorithms that simplify the mesh by removing vertices; algorithms that simplify the mesh by removing edges; and algorithms that simplify the mesh by removing higher-level simplices.</p><p>Schroeder et al. <ref type="bibr" target="#b19">[17]</ref> and Renze and Oliver <ref type="bibr" target="#b18">[16]</ref> have developed algorithms that simplify a mesh by removing vertices. Vertices to be removed are identified through a distance-to-simplex criterion. Removing a vertex creates a hole in the mesh that must be retriangulated, and several strategies may be used: Schroeder et al.use a recursive loop splitting procedure to generate a triangulation of the hole, while Renze and Oliver fill the hole by using an unconstrained Delaunay triangulation algorithm.</p><p>Hoppe <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b10">10]</ref> and Hoppe and PopoviÄ‡ <ref type="bibr" target="#b16">[15]</ref> describe a progressive-mesh representation of a triangle mesh. This is a continuous-resolution representation based on an edge-collapse operation. The data reduction problem is formulated in terms of a global mesh optimization problem <ref type="bibr" target="#b12">[11]</ref>, ordering the edges according to an energy minimization function. Each edge is placed in a priority queue by the expected energy cost of its collapse. As edges are collapsed, the priorities of the edges in the neighborhood of the transformation are recomputed and reinserted into the queue. The result is an initial coarse representation of the mesh, and a linear list of edge-collapse operations, each of which can be regenerated to produce finer representations of the mesh. Other edge-collapse algorithms have been described by Xia and Varshney <ref type="bibr" target="#b20">[18]</ref>, who use the constructed hierarchy for view-dependent simplification and rendering of models, and Garland and Heckbert <ref type="bibr" target="#b3">[3]</ref>, who utilize quadratic error metrics for efficient calculation of the hierarchy.</p><p>Hamann <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b7">7]</ref>, and Gieng et al. <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref> have developed algorithms that simplify triangle meshes by removing triangles. These algorithms order the triangles according to a weight based partially on the curvature of a surface approximate, partially on the changes in the topology of the mesh due to a triangle collapse, and partially due to the predicted error of the collapse operation. Triangles are inserted into a priority queue and removed iteratively. Modified triangles receive new weights and are inserted back into the priority queue. By selecting a percentage of triangles to be collapsed it is possible to "parallelize" triangle removal.</p><p>Cohen et al. <ref type="bibr" target="#b1">[2]</ref> proposed the idea of a simplification envelope of a surface. They produce hierarchical representations of an object, each of which is guaranteed to be within a user-specified distance from the original model. They generalize the concept of offset surface to a polygonal representation of an envelope that surrounds the surface within the specified tolerance.</p><p>Cignoni et al. <ref type="bibr" target="#b0">[1]</ref> treat the tetrahedral mesh problem. They use a top-down Delaunay-based procedure to define a tetrahedral mesh that represents a three-dimensional set of points. The mesh is refined by selecting a data point whose associated function value is poorly approximated by an existing mesh and inserting this point into the mesh. The mesh is modified locally to keep the Delaunay property intact. T <ref type="figure">Figure 1</ref>: The stencil of a triangle T . The shaded triangles all share a vertex with T ; A collapse of the triangle T impacts the triangles of the stencil. This paper extends the results of Gieng et al. <ref type="bibr" target="#b5">[5]</ref> to tetrahedral meshes. The general idea is to base the scheme on the predicted deviation from the original scalar field due to a tetrahedron collapse. If the deviation can be measured closely, the complicated weights of Hoppe <ref type="bibr" target="#b12">[11]</ref> and Gieng et al. <ref type="bibr" target="#b5">[5]</ref> should not be necessary. A maximum deviation bound is kept for each tetrahedron in the mesh. This value, together with the predicted increase in the error if the tetrahedron is collapsed, enables us to determine which tetrahedron to collapse and to insure that the maximum deviation over the surface remains less than a specified value. As the mesh is simplified the maximum deviation is updated for each tetrahedron affected by the collapse operation.</p><p>Our algorithm is a bottom-up approach that produces a hierarchy of tetrahedral meshes, each of which is guaranteed to be within a specific error distance from the original mesh. A tetrahedron is selected for collapse if it leads to a minimal increase in the overall error of the approximation, and does not increase the global error beyond a maximal error tolerance. The error calculations are local calculations, so the algorithm is fairly efficient even on large meshes. The algorithm collapses an individual tetrahedron by iteratively collapsing its edges. This strategy allows us to avoid many of the topological considerations of Gieng et al.'s work. Our algorithm utilizes only the original data points, which allows us to represent the resulting hierarchy very compactly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TRIANGLE COLLAPSE IN THE PLANE</head><p>To understand the collapsing of tetrahedra in a three-dimensional mesh, it is useful to first study the collapsing of triangles in a planar mesh. Assume we have a collection of data points fv0; v 1; v 2; : : : v ng in the plane and a set of triangles fT0; T 1; : : : ; T mg defining a triangulation of the data points.</p><p>We assume that the generated triangulation is fair, i.e., the mesh is connected, and each edge in the mesh is shared by at most two triangles. Meshes should not be self-intersecting, i.e., no triangle of the mesh should have an intersection with the interior of another triangle.</p><p>We call a triangle T a vertex neighbor of a vertex v if v is a vertex of T , and T is an edge neighbor of an edge e if e is an edge of T . Each edge has two edge neighbors, while each vertex may have any number of vertex neighbors. The vertex neighbors of a triangle T consist of all triangles that share a vertex with T . The edge neighbors of T are the triangles that share an edge with T . The union of the vertex neighbors of a triangle T is called the stencil of T . The stencil contains those triangles that can be modified by collapsing T (see <ref type="figure">Figure 1</ref>).</p><p>It is possible to reduce the collapse of a triangle to a sequence of edge collapses. Given an edge e, with endpoints v1 and v2, we collapse the edge by removing the two triangles sharing the edge and by collapsing v1 to v2 (see <ref type="figure" target="#fig_0">Figure 2</ref>). This operation stretches the triangles that share v1 as a common vertex to fill the hole. The edge-collapse operation does not commute, i.e., collapsing v2 to v1 would produce a different result.</p><p>We collapse a triangle T by successively collapsing two of its edges (see <ref type="figure" target="#fig_0">Figure 2</ref>). In this case, the edge neighbors of T are eliminated from the mesh and the vertex neighbors of two of the vertices of T are stretched to include the third vertex of the triangle. There are nine ways to collapse a triangle, but the results can modify the mesh in only three ways.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Error Bounds</head><p>To calculate a bound for the error due to a triangle collapse, we assume that the triangle mesh represents a scalar field defined by a piecewise-linear spline with individual spline segments s = F u; v; w, where u; v; w are the barycentric coordinates of a point in the triangle. The spline coefficients are the function values at the mesh vertices.</p><p>Each triangle T has an associated a "maximal deviation" T , which represents a bound on the deviation between the linear spline segment defined by T and the linear spline of the original triangle mesh in the area of T . Original triangles have T = 0 , and this value is updated whenever a collapse is performed.</p><p>Suppose we have selected a triangle T for collapse, and let e be the edge v1v2. Suppose that v1 has k vertex neighbors T1; T 2; :::; Tk and suppose that Tk,1 and Tk are edge neighbors of e. Then, as v1 is collapsed to v2, the triangles T1; T 2; :::; Tk,2 are stretched to have v2 as a common vertex, and v1 is eliminated. This collapse operation (see <ref type="figure">Figure 3</ref>) creates a new set of triangles T C 1 ; T C 2 ; :::; T C k,2 , which define a new piecewise-linear function F C . We can calculate the maximal deviation between the two linear splines over each stretched triangle T C by considering the points where T C and the original triangles of the stencil of T intersect (see <ref type="figure">Figure 4)</ref>. Let c1; c 2; :::; cj be the points where the stretched triangles intersect the original triangles, and let c0 be the eliminated vertex v1 (see <ref type="figure">Figure 5</ref>). For each of these points, we know that the induced linear spline cannot deviate more than jF C ci , F cij + m a x f T g from the linear spline defined by the original triangles. This means that, for each point ci the deviation is bounded by the difference between the two linear splines at ci plus the maximum of the errors T for the triangles that contain ci as an edge point or vertex point. Therefore, an error bound for the triangle T C can be calculated by taking the maximum of this deviation over all points ci that are contained in the triangle, i.e.,</p><formula xml:id="formula_0">BT C = max i n jF C ci , F cij + max T o .<label>(1)</label></formula><p>We note that one of the stretched triangles will contain the (eliminated) vertex c0, and in this case the maximum must also include the deviation between the two linear splines at this point. Using this approximation, we can calculate a new error bound for each triangle T C .</p><p>We define the "cost" of collapsing triangle T to be</p><formula xml:id="formula_1">T = m i n max j BT C j , T ,<label>( 2 )</label></formula><p>where the minimum is taken over all six possible collapse strategies for T , and the maximum is taken over the stretched triangles formed by collapsing two edges of T . This is the difference between a predicted error bound for the region and the current error bound at T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Outline of an Algorithm</head><p>Suppose we are given a set of vertices fv0; v 1; v 2; : : : v ng in the plane and a triangulation defined by the set of triangles fT0; T 1; :::; Tmg.</p><p>Each triangle T is assigned an error measure T , initially set to zero. The value T represents a bound on the difference between the linear spline defined by T , and the linear spline segment defined by the initial mesh.</p><p>For each triangle T in the mesh, calculate a weight T which reflects the "predicted error," i.e., the maximal deviation that would result when collapsing the triangle, as defined by equation <ref type="bibr" target="#b1">(2)</ref>. Place the triangles in a priority queue ordered by increasing values of T + T . Thus, the first triangle removed from the queue should have the least effect on the change in the linear spline after the collapse operation. Next, select a maximum error 0 for which you wish a mesh to be generated and iteratively perform the following steps:</p><p>Remove a triangle T from the queue;</p><p>if T + T 0, then the triangles in the queue represent the simplified mesh;</p><p>if T + T e0, then -collapse the triangle T and remove the edge neighbors of T from the queue;</p><p>-recalculate T C and T C for each triangle T C that is stretched as a result of the collapse, and reposition it in the queue;</p><p>-recalculate T for each triangle T in the stencil of a stretched triangle T C .</p><p>The last step is necessary to keep the queue in the correct order. Once a triangle is stretched, the cost of collapsing a neighboring triangle changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">TETRAHEDRAL MESHES</head><p>We now generalize these principles to simplify a tetrahedral mesh.</p><p>We assume that we have a set of vertices fv0; v 1; v 2; : : : v ng in threedimensional space and a set of tetrahedra fT0; T 1 ; :::; Tmg defining a "triangulation" of this data set. In a similar way to the planar case, we define the vertex neighbors of a point v to be the set of tetrahedra that share v as a vertex, and define the edge neighbors of an edge e to be the set of tetrahedra in the mesh that share e as an edge. In addition, we define the face neighbors of a face f to be the (at most) two tetrahedra in the mesh that share the face f . We also define, in an analogous fashion, the vertex neighbors, edge neighbors and face neighbors of a tetrahedron. A tetrahedron has at most four face neighbors, but can have any number of edge and vertex neighbors.</p><p>We collapse a tetrahedron T by successively collapsing three of its edges. One can collapse to any of a tetrahedron's four vertices, and there are ten ways to collapse individual edges to achieve one of the four final states. A collapse removes the edge neighbors of T , and the vertex neighbors of three of the vertices of T are stretched to include the fourth vertex, the vertex to which we collapse.</p><p>We insure that the collapse operation does not produce intersecting tetrahedra by comparing the sign on the volume of the original and stretched tetrahedra. If by collapsing an edge of the tetrahedron T , the sign of the volume of a stretched tetrahedron T C flips, we label the edge as "not-collapsible."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Error Bounds</head><p>To estimate the error, we assume that the tetrahedral mesh represents a linear spline defined by individual spline segments s = F u;v;w;t, where u;v;w;t are the barycentric coordinates of a point inside a tetrahedron. The spline coefficients of F are the function values at the mesh vertices.</p><p>Each tetrahedron T will have associated a "maximal deviation"</p><p>T , which will represent a bound on the deviation between the linear spline segment defined by T and the linear spline of the original tetrahedral mesh in the area of T . An original tetrahedron T has T = 0 , and this value is updated whenever a collapse is performed.</p><p>If F C is the piecewise linear function induced by a collapse operation we can bound the error over a stretched tetrahedron T C similarly to equation <ref type="bibr" target="#b0">(1)</ref>, i.e.,</p><formula xml:id="formula_2">BT C = m a x i n jF C ci , F cij + m a x f T g o (3)</formula><p>where the ci are the intersection points of the edges of the stretched tetrahedron T C with the faces of the tetrahedra in the previous mesh (and possibly one of the eliminated vertices of the collapsed tetrahedron) and the maximum is taken over all tetrahedra that contain ci as an edge point or a vertex. We define the cost of collapsing a tetrahedron T as</p><formula xml:id="formula_3">T = m i n max j BT C j , T ,<label>( 4 )</label></formula><p>where the minimum is taken over all possible collapse strategies for the tetrahedron T , and the maximum is taken over the tetrahedra stretched by collapsing three edges of T . This value is the difference between a predicted error bound for the region and the error bound at T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Boundary Preservation</head><p>The boundary surface of a tetrahedral mesh is given by the set of all faces belonging to exactly one tetrahedron. It is desirable to preserve this boundary surface as much as possible. Some data sets have rectangular boxes as their boundaries while most are much more complex. Given a tetrahedron T , selected for collapse, we check the following:</p><p>If T has a single vertex v on the boundary, the three edges that contain v can only be collapsed to v. The other three edges of T can be collapsed in either direction.</p><p>If T has a two vertices v1 and v2 on the boundary, then the four edges of the tetrahedron containing v1 and v2 can only be collapsed to these points. The other two edges of the tetrahedron, which includes v1v2, can be collapsed in either direction.</p><p>If T has three vertices v1, v2 and v3 on the boundary, then the three edges containing the fourth point and one of v1, v2 or v3 can only be collapsed to the boundary points. The three edges on the boundary can be collapsed in either direction.</p><p>if T has a four vertices on the boundary, there are several cases to consider:</p><p>-T is at the corner of mesh. In this case T has only one face neighbor. These tetrahedra can only be collapsed to the corner.</p><p>-T is on a boundary edge. In this case T has two face neighbors. If v1 and v2 are on the edge, then the four edges containing v1 and v2 can only be collapsed to the edge. The edge v1v2 can be collapsed in either direction.</p><p>-T has one vertex on an boundary edge. In this case T has three face neighbors. If v1 is the vertex on the boundary edge, then the three edges incident to v1 can only be collapsed to v1.</p><p>Each of these cases restricts the number of possible edge collapse operations on T . In some cases, only one or two edges of T may be collapsible, and T may be collapsed to a face or an edge respectively. In general, if T has an edge with a vertex v on the boundary, then the edge must be collapsed to v. If we collapse to the other vertex, the boundary would be compromised. <ref type="figure">Figure 6</ref> illustrates this for the two-dimensional case.</p><p>In general these rules allow the simplification algorithm to work with data sets having convex polyhedral boundaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Algorithms for Mesh Simplification</head><p>Two different algorithmic strategies can be used to simplify the mesh. The first, similar to that presented in Section 3.2, utilizes a priority queue and the error prediction mechanism. The second algorithm makes a pass through the complete tetrahedral structure and attempts collapse operations, evaluating each collapse against the error threshold. Each algorithm works with a set of vertices fv0; v 1; v 2; : : : v ng, and a set of tetrahedra fT0; T 1; : : : ; T mg forming a triangulation of the vertices. Each tetrahedron T in the mesh, carries an "accumulated error" T , initially zero.</p><p>The first strategy is based upon a priority queue, where for each tetrahedron T , we calculate a weight T which reflects the predicted error increase resulting from collapsing the tetrahedron as defined by equation <ref type="bibr" target="#b4">(4)</ref>. We place the tetrahedra in the priority queue ordered by increasing T + T .</p><p>Select a maximum error 0 used to terminate the collapse algorithm, and iteratively perform the following steps:</p><p>Remove a tetrahedron T from the queue;</p><p>if T + T 0, then the set of tetrahedra in the queue represent the simplified mesh.</p><p>if T + T 0, -collapse the tetrahedron T and eliminate the face neighbors of T from the priority queue;</p><p>-recalculate T C and T C for each tetrahedron T C modified by the collapse operation; -recalculate T for each tetrahedron T in the stencil of a tetrahedron T C stretched by the collapse operation.</p><p>Three algorithms can be implemented that use the collapse operation to generate sets of meshes M0;M1; : : : ; Mn at different levels of detail approximating the original mesh. (2) Choose a specified number (or percentage) of the original tetrahedra to be collapsed at each step.  <ref type="figure">Figure 6</ref>: Collapsing edges on the boundary: (a) an edge is collapsed to a boundary vertex; (b) the boundary is destroyed when the collapse goes the other way.</p><p>(3) Similarly to Gieng et al. <ref type="bibr" target="#b5">[5]</ref>, remove a set of tetrahedra from the queue and collapse them in parallel. The only restriction is that the stencils of the tetrahedra to be collapsed must not intersect. The resulting sequence of meshes can be used for "smooth" transitions between mesh levels.</p><p>The second strategy is based upon a sweep through the grid, examining each tetrahedron individually. Attempt to collapse each edge of the selected tetrahedron until either (1) one of these collapses induces an error threshold below i, or (2) all six edges of T have been tried.</p><p>A successful collapse modifies several tetrahedra, which are "stretched" versions of their counterparts before the collapse. For each modified tetrahedron TC , calculate the error change T C and add this to T C .</p><p>Continue until the simplified mesh cannot be collapsed further without increasing the error above i.</p><p>The first strategy selects that tetrahedron that will cause the minimal increase in the error at each step. The second strategy utilizes a "greedy" method that selects an arbitrary tetrahedron and attempts to collapse it. If the collapse results in a mesh below the error bound, it is accepted and the process continues. This results in a less structured algorithm, but avoids many of the complex T calculations for tetrahedra that are removed in the collapsing process.</p><p>Using the second strategy also enables a simplified test for boundary preservation. Consider a vertex v that is removed by collapsing an edge. If v is on the boundary then if the resulting tetrahedra, modified by the collapse, does not contain v, the boundary has been compromised. Therefore, if v is not contained within the modified tetrahedra, then the collapse is rejected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION ISSUES</head><p>We have implemented this algorithm using a simple data structure for tetrahedral meshes. We store a list of vertices and a list of tetrahedra. Each tetrahedron contains links that reference the four vertices of the tetrahedron and the four face neighbors. Calculating the vertex neighbors and edge neighbors of a tetrahedron is straightforward using this data structure.</p><p>Each tetrahedron T carries an error estimate T and a predicted deviation T . The value T is determined by finding the sequence of edge collapses in T that generates the minimum error increase. We store this sequence of collapses in the tetrahedron data structure. When the tetrahedron is to be collapsed, we need not recalculate this sequence.</p><p>Our algorithm is based on an "edge collapse" paradigm and can be implemented using only edge-collapse strategies. However, we felt that the overhead of implementing and maintaining an edge data structure would be overwhelming for the large data sets that we use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>Results of our work are shown in <ref type="figure" target="#fig_5">Figures 7-15</ref>. We utilize voxelized data sets, where each voxel of the original data set is initially split into six tetrahedra (see <ref type="bibr" target="#b15">[14]</ref>). We utilized the "greedy algorithm of Section 4.3 in each case, and specified a maximum error for each approximating mesh.</p><p>Our first example, shown in <ref type="figure" target="#fig_5">Figures 7-9</ref>, collapses tetrahedra until a specified error tolerance is reached. <ref type="figure" target="#fig_5">Figure 7</ref> illustrates a piecewise-linear scalar field over a unit cube containing 41,154 tetrahedra, shown in <ref type="figure" target="#fig_4">Figure 8</ref> x if 0 x 1;</p><formula xml:id="formula_4">1 if x 1.</formula><p>Simplifying the mesh with any small user-specified error threshold yields the mesh shown in <ref type="figure" target="#fig_7">Figure 9</ref>, which contains 25 tetrahedra and still represents the scalar field exactly. (We note that 15 tetrahedra would be optimal.) One would expect that the simplification scheme works well with simple piecewise-linear functions -and it does.</p><p>Our second example is an MRI scan of a human skull and is represented by an array of 64x64x109 density values. Splitting each        <ref type="figure">Figure 14</ref>: A ray-traced image of the simplified brain data set. An error bound was chosen that reduces the data set to approximately 700,000 tetrahedra. voxel into 6 tetrahedra, yields approximately 2,700,000 tetrahedra for the original mesh. <ref type="figure" target="#fig_8">Figure 10</ref> shows an isosurface generated for the original data set. <ref type="figure" target="#fig_2">Figure 11</ref> shows an isosurface for a simplified mesh containing approximately 910,000 tetrahedra, and <ref type="figure" target="#fig_0">Figure 12</ref> shows the same isosurface on a simplified mesh containing approximately 209,000 tetrahedra -roughly 8% of the original size.</p><p>The third example is a section of a brain taken from a Macaque monkey. <ref type="figure" target="#fig_11">Figure 13</ref> shows a ray-traced image of the brain using the original data set. This contains approximately 1.3 million tetrahedra. <ref type="figure">Figure 14</ref> shows a simplified brain data set with approximately 700,000 tetrahedra. This image is almost identical to that shown in <ref type="figure" target="#fig_11">Figure 13</ref>. <ref type="figure">Figure 15</ref> shows the image of a simplified brain data set with approximately 158,000 tetrahedra -approximately 12% of the size of the original. Despite some "feathering" in the lower-left corner of this image, the image is quite good. <ref type="bibr">1 1</ref> We note that a 32x32x32 data set with each voxel split into 6 tetrahedra would contain 196,608 tetrahedra. <ref type="figure">Figure 15</ref>: A ray-traced image of a simplified brain data set. An error bound was chosen that reduced the set to approximately 158,000 tetrahedra.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>We have presented a method for the simplification of tetrahedral meshes approximating a trivariate function. The simplification of the mesh is based upon a tetrahedral collapse algorithm and local error calculations that insure that the mesh remains within a userspecified tolerance of the original. Several methods can be applied to generate various mesh hierarchies to be used in level-of-detail applications. We have found this a useful tool to treat massive threedimensional data sets defined by arbitrary grid structures.</p><p>We plan to generalize our approach to allow more flexible placement of vertices when collapsing tetrahedra and to compute the linear spline coefficients in an optimal way for each triangulation level (see <ref type="bibr" target="#b8">[8]</ref>). Furthermore, we intend to extend and apply our algorithm to vector fields and time-varying fields.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>A two-edge collapse of a triangle T : (a) the triangle and its associated stencil; (b) the mesh after the collapse of edge e1; (c) the mesh after the collapse of both e1 and e2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :Figure 4 :Figure 5 :</head><label>345</label><figDesc>Calculation of the error introduced by collapsing an edge: (a) the triangle T and original mesh; (b) the triangulation after the collapse of edge e. Calculation of the error for a stretched triangle T C . A bound on the increase in the deviation from the original triangles T1, T2 and T3 is the maximum of the deviations measured at c1, c2, and Calculation of the error bound: c0 is the location of the eliminated vertex v1; the points ci; i= 1 ; :::; k, are the intersection points of the stretched triangles and the triangles of the previous mesh. A bound on the error for each stretched triangle can be calculated by finding the deviations in the linear splines at the ci and adding these values to the maximum of the errors over the original triangles at these points.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>( 1 ) 1 .</head><label>11</label><figDesc>Choose a sequence of error bounds 0 Select tetrahedra from the queue, collapse the tetrahedra, and reinsert the stretched tetrahedra into the queue until the tetrahedron T at the front of the queue satisfies T + T 0. The set of tetrahedra in the priority queue define the mesh M0. Using the mesh M0, collapse the tetrahedra in the queue until the tetrahedron T at the front of the queue satisfies T + T The set of tetrahedra in the queue defines the mesh M1. The algorithm continues in this way until mesh Mn is gener-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>For each i, Make a sweep through the grid, examining each tetrahedron T .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>8 :0</head><label>8</label><figDesc>. The function is defined by f x;y; z = if x 0;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>A piecewise-linear example: The values of the scalar field are only rendered on the boundary of the grid.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>The underlying tetrahedral mesh for the function shown inFigure 7. The field contains 41,154 tetrahedra. The edges are colored according to the scalar function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>The reduced tetrahedral mesh for the function shown inFigure 7. This mesh contains 25 tetrahedra and represents the scalar field exactly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>An isosurface of a skull data set containing 2.7 million tetrahedra in the original mesh.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Simplified skull data set: An error bound was chosen that reduces the data set to approximately 910,000 tetrahedra. The same isosurface value was used as inFigure 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Skull data simplification containing approximately 209,000 tetrahedra: The isosurface is shown using the same value as inFigure 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 13 :</head><label>13</label><figDesc>A ray-traced image of a section of the brain of a Macaque monkey. The original data set contains approximately 1.3 million tetrahedra.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">ACKNOWLEDGMENTS</head><p>This work was supported by the National Science Foundation under contract ASC 9624034, the Office of Naval Research under contract N00014-97-1-0222, the NASA Ames Research Center under the NRA2-36832(TLL) program, the Army Research Office under contract ARO 36598-MA-RIP, and Lawrence Livermore National Laboratory under contract W-7405-ENG-48 (B335358). We would like to thank the members of the Visualization Group at the Center for Image Processing and Integrated Computing (CIPIC) at the University of California, Davis, for their support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multiresolution modeling and visualization of volume data based on simplicial complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Volume Visualization</title>
		<editor>A. Kaufman and W. Krueger</editor>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Simplification envelopes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">Annual Conference Series, ACM SIGGRAPH</title>
		<editor>H. Rushmeier</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
	<note>Conference Proceedings</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Series, ACM SIGGRAPH</title>
		<editor>T. Whitted</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
	<note>SIGGRAPH 97 Conference Proceedings</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Smooth hierarchical surface triangulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Gieng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Schussman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">J</forename><surname>Trotts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization 97</title>
		<editor>H. Hagen and R. Yagel</editor>
		<meeting>Visualization 97<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="379" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Constructing hierarchies for triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Gieng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Schussman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">J</forename><surname>Trotts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A data reduction scheme for triangulated surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="197" to="214" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data point selection for piecewise linear curve approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="301" />
			<date type="published" when="1994-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Triangulations from repeated bisection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Methods for Curves and Surfaces II</title>
		<editor>M. Daehlen, T. Lyche, and L. Schumacker</editor>
		<meeting><address><addrLine>Nashville, Tennessee</addrLine></address></meeting>
		<imprint>
			<publisher>Vanderbilt University Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="229" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Series, ACM SIGGRAPH</title>
		<editor>H. Rushmeier</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
	<note>SIGGRAPH 96 Conference Proceedings</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings</title>
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Whitted</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ed</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Series</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Mesh optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;93 Proceedings)</title>
		<editor>J. T. Kajiya</editor>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="165" to="167" />
			<date type="published" when="1996-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Mesh reduction with error control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Liebich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;96</title>
		<meeting>IEEE Visualization &apos;96<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="311" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>MÃ¼ller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<title level="m">Scientific Visualization: Overviews, Methodologies, and Techniques</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Progressive simplicial complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>PopoviÄ‡</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings</title>
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Whitted</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ed</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Series</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Generalized unstructured decimation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Renze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Oliver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="24" to="32" />
			<date type="published" when="1996-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;92 Proceedings</title>
		<editor>E. E. Catmull</editor>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Dynamic view-dependent simplification for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;96</title>
		<meeting>IEEE Visualization &apos;96<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
