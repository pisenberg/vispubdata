<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Display Of Very Large Textures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cline</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Brigham Young University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parris</forename><forename type="middle">K</forename><surname>Egbert</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Brigham Young University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive Display Of Very Large Textures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.7 [ComputerGraphics]: Picture/Image Generation-texture Texture Caching</term>
					<term>Bandwidth-Limited Resource</term>
					<term>Texture Mapping</term>
					<term>Real-Time Display</term>
					<term>Interactivity</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Large textures cause bottlenecks in real-time applications that often lead to a loss of interactivity. These performance bottlenecks occur because of disk and network transfer, texture translation, and memory swapping. We present a software solution that alleviates the problems associated with large textures by treating texture as a bandwidth-limited resource rather than a finite resource. As a result the display of large textures is reduced to a caching problem in which texture memory serves as the primary cache for texture data, main memory the secondary cache, and local disk the tertiary cache. By using this cache hierarchy, applications are able to maintain realtime performance while displaying textures hundreds of times larger than can fit into texture memory.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A texture map, or texture, is an image used to provide surface detail in a computer generated scene. At the most basic level, textures supply a scene with "visual interest". On a much deeper level, textures provide important visual clues to the user and help increase the perceived realism of the environment. In some cases, such as <ref type="bibr" target="#b18">[19]</ref>, textures replace complex geometry. Image based rendering techniques, such as Quicktime VR <ref type="bibr" target="#b5">[6]</ref>, take this idea to its limit, reducing a scene to just a few primitives that serve as projection screens for textures.</p><p>When textures form an important part of scene content, reduction in texture detail may mean a loss of scene comprehension. In addition, interactivity may be important to scene understanding, so that when the frame rate drops, so does the scene's utility. Some high-end platforms are designed to display very large textures in real time, but the cost of such hardware makes it prohibitively expensive for most users. Mid-range to low-end graphics workstations can usually draw some textured objects in real time, but they are not generally equipped to deal with large textures directly. This paper presents a software approach to texture caching designed to allow interactive display of very large textures on mid to low-end workstations. The new approach has as its basis the following goals:</p><p>• Very large textures should be supported, larger than can be held in either texture or main memories.</p><p>• Scene startup time should be as fast as possible, and independent of the textures present.</p><p>• The system should be implementable on existing low-end graphics workstations using current graphics API's.</p><p>• The difference in frame rate between an application using texture caching and the same application using static textures that all fit into texture memory should be negligible.</p><p>1 cline@neptune.cs.byu.edu, http://orca.cs.byu.edu/∼cline 2 egbert@cs.byu.edu</p><p>• Maintaining an interactive frame rate should take precedence over instantaneous detail.</p><p>• The system should perform reasonably well when textures must be fetched over a slow network.</p><p>• The system should form a general framework for a wide variety of applications that require large textures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Most research in texture mapping to date has focused on four areas: anti-aliasing techniques, acceleration of texture rendering, applying texture mapping to new rendering problems, and texture synthesis.</p><p>Since the development of low-cost rendering hardware, however, increasing the size of textures that can be practically rendered has become a popular avenue for investigation. Such research is needed because the demand for texture processing has more than kept pace with hardware advances. This trend does not show signs of letting up, so for the foreseeable future texture memory alone will not be sufficient to handle users' wants.</p><p>The remainder of this section discusses techniques designed to overcome the hardware-imposed upper limit on texture size. Included among these are texture compression and texture caching algorithms. Other areas of interest that will be discussed are progressive image transmission and methods for dealing with bandwidthlimited resources.</p><p>Texture compression. Ideally, texture compression should take place in texture memory, effectively increasing its size. By using compression the hardware can accommodate larger textured scenes without swapping. One shortcoming of algorithms that keep textures compressed in texture memory is that they require hardware support, so the compression algorithm must be built into the hardware. Although not usually considered to contain texture compression facilities, Iris GL <ref type="bibr" target="#b11">[12]</ref> provides three rudimentary examples of texture compression in texture memory. These include selection of texel size, texture lookup tables, and detail textures. Another example of hardware texture compression is found in the Talisman architecture. Talisman <ref type="bibr" target="#b20">[21]</ref> employs a hardware-based compression scheme similar to JPEG that keeps textures in a compressed state in texture memory.</p><p>Software approaches to texture compression cannot increase the effective size of texture memory. Instead, they allow more texture to be held in main memory, reducing the need for virtual memory swapping. To be effective, software-based texture compression must allow for fast texture decoding, so that decompression time does not dominate rendering activities. Beers et al. <ref type="bibr" target="#b0">[1]</ref>, and Levoy and Hanrahan <ref type="bibr" target="#b9">[10]</ref> advocate the use of vector quantization to compress textures held in main memory precisely because of decoding speed.</p><p>Texture caching. Even with compression, texture data may be larger than the memory capacity. When this occurs, some form of caching must be used to manage texture data. A good portion of the texture caching algorithms described in the literature are application-specific measures designed to solve a particular caching problem. For example, Quicktime VR <ref type="bibr" target="#b5">[6]</ref> cuts texture panoramas into vertical strips for caching purposes. Cohen-Or et al. <ref type="bibr" target="#b7">[8]</ref> describe a system that caches photo-textured terrain data. The data is fetched at different resolutions based on the distance from the viewer. Oborn <ref type="bibr" target="#b13">[14]</ref> also uses a distance metric to determine the texture level of detail that will be fetched. In another terrain viewing application, Lindstrom et al. <ref type="bibr" target="#b10">[11]</ref> use the angle at which textures are viewed to reduce texture requests over using a simple distance metric. Blow <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> gives an overview of several texture caching schemes currently in use in the video game industry. He also discusses the implementation details of the caching system used to manage large terrain textures in a video game setting.</p><p>Besides problem-specific texture caching solutions, some work has been done to provide general support for very large textures in non real-time applications. Pharr et al. <ref type="bibr" target="#b15">[16]</ref> use a caching scheme that dices textures into small tiles that are paged into memory as needed. Using this architecture, their ray tracing software can efficiently render scenes with textures many times larger than the texture cache. SGI's ImageVision library <ref type="bibr" target="#b12">[13]</ref> uses a similar caching system based on cutting images into "pages" that can be manipulated efficiently.</p><p>Unfortunately, none of the above mentioned systems serves as a general framework for the display of large textures in interactive environments. One system that is designed for real-time display of large textures is SGI's InfiniteReality Engine <ref type="bibr" target="#b16">[17]</ref>. It uses a virtual texture scheme called a "clip-map" to deal with textures too large to fit in memory. Unlike most texture caching systems, the clip-map algorithm does not cut a large texture into tiles. This has the benefit that since there are no texture tiles, scene geometry does not have to be diced along tile boundaries. Although the clip-map algorithm can produce impressive results, it has several drawbacks that make it a bad choice for current low-end hardware. First, it requires a large hardware texture capacity. <ref type="bibr" target="#b2">3</ref> Second, an efficient implementation of clip-mapping for real-time display is likely to require some hardware assistance, so it is probably the wrong choice for a software add-on. Finally, the clip-map algorithm relies on fast local disk access to retrieve texture data, and so does not serve as a framework for texture caching in low bandwidth situations.</p><p>Topics related to texture caching. A successful texture caching strategy for low-end systems needs to utilize available bandwidth effectively. Thus, progressive image transmission algorithms and methods designed to deal with limited bandwidth situations are related to the display of very large textures. This is especially true for textures stored remotely and accessed across a slow network.</p><p>Hill et al. <ref type="bibr" target="#b8">[9]</ref> describe an early attempt to use progressive image transmission. Their system was designed to send Landsat images over a slow modem connection. It worked by selectively refining user-specified areas of interest. In more recent work, Strobel et al. <ref type="bibr" target="#b19">[20]</ref> suggest a method to store and retrieve large image databases based on wavelet transforms.</p><p>Bukowski and Sequin <ref type="bibr" target="#b3">[4]</ref> faced a more dynamic data stream than still images. They designed a viewing program to display information from a fire simulation. The program allowed users to generate queries for a fire simulation running on a remote machine. A "bandwidth manager" was used to optimize data requests.</p><p>3 Clip-mapping as described in <ref type="bibr" target="#b16">[17]</ref> requires more than 22 million texels, or about 85 MB of texture memory for a 32-bit color implementation. This number may be reduced to under 7 million texels for 640 × 480 graphics screens, however.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Typical Texture Loading</head><p>The common approach to texture mapping in interactive applications is to treat texture memory as a finite resource, and texture images as atomic resources. Such a texture paradigm leads to two very specific texture loading practices. First, because texture memory is viewed as a finite resource, there is an upper limit on the number of bytes of texture that a scene may contain. Second, since scene designers view texture images as atomic resources, they usually store each image in one piece on disk, and often do not store MIP maps on disk at all, preferring to let the viewing program create the MIP maps when loading textures. At run time, the viewing program loads every texture image in a scene before any interaction takes place, and the user must wait while the textures are loaded. <ref type="figure" target="#fig_0">Figure 1</ref> shows the common approach to texture mapping in real-time applications.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Performance Bottlenecks</head><p>Treating texture as a finite and atomic resource is conceptually simple and works well in many situations, but it breaks down as texture size increases. When a scene's texture memory requirements begin to exceed texture memory size, four performance bottlenecks appear that can prevent real-time interaction. They are</p><p>• Disk or network transfer. If large textures must be loaded from disk or across a network before interaction takes place, the user may be subjected to a significant initial wait. In addition, a disk access causes the process which initiated it to block until the data transfer completes; consequently, the user cannot interact with a process while it accesses the disk.</p><p>• Texture translation. If a texture image is stored on disk in a compressed format it must be decompressed before use. Additionally, odd sized textures must be resized to have widths and heights that are powers of 2. Finally, MIP maps may be created from the original texture images. Since these steps may be CPU intensive, they can prevent real-time interaction with the scene even if the viewing program is designed to allow interaction while loading textures.</p><p>• Texture memory thrashing. Most hardware texture mapping systems place textures in dedicated texture memory. If texture memory requirements exceed texture memory size, textures are swapped to main memory by the operating system. When large amounts of texture must be transferred from main to texture memory for each frame of an interactive application, the frame rate can drop drastically.</p><p>• Virtual memory swapping. If texture memory requirements exceed main memory size, the operating system swaps textures to disk. When a texture that has been swapped to disk is requested, the interactive program must wait while the texture is reloaded into main and texture memories.</p><p>Because the common approach to texture mapping in interactive applications creates performance bottlenecks, it is difficult to accomodate very large textures in real-time scenes without increasing texture memory size. Our solution to the problem of large textures, outlined in the next section, bypasses the operating system's texture caching policies by explicitly creating a hierachy of texture caches, with a seperate process handling each cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">An Approach to Texture Caching</head><p>This section presents an overview of our approach to texture caching. At the core, we base our strategy on the assumption that instantaneous texture detail (detail in the current frame) can be sacrificed in favor of a higher frame rate. Thus we do not guarantee that rendered frames will have all the desired texture detail immediately. The ability to sacrifice instantaneous detail differentiates our approach from texture caching algorithms designed simply to accelerate rendering of desired frames. These algorithms, while useful, are essentially virtual memory schemes. Our algorithm goes beyond simple memory management to deal with bandwidth concerns related to real-time display.</p><p>The remainder of this section describes the three essential pieces of our algorithm. They are the pre-processing of texture images, the use of texture servers and regulation of texture flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Mip-Map Caching</head><p>Although the original purpose of the MIP map <ref type="bibr" target="#b21">[22]</ref> was to reduce the cost of antialiasing, it can also be used for caching purposes. In order to do this, the MIP map must be precomputed and stored on disk. By loading coarse versions of the textures initially, then refining those textures as time progresses, startup time for programs that use large textures can be significantly reduced. In addition, if texture detail is loaded on an as-needed basis, some parts of the MIP map may never be fetched during a given run of the program, reducing total disk access.</p><p>Taking into account only the need to load coarse versions of images before more detailed versions, one might consider making a separate image file for each level of the MIP map and then load these files as needed. Unfortunately, this approach is ineffective for higher levels in the MIP map because each successive level is four times larger than its parent, and the highest MIP-map level is as large as the original image. What is needed is a mechanism to load manageable pieces of texture from anywhere in the MIP map on an asneeded basis. The route our algorithm takes is to cut the large MIP map into a quadtree <ref type="bibr" target="#b17">[18]</ref> of uniform texture tiles. Uniform tiles have several advantages over non-uniform sized tiles, namely, they can be expected to have fairly consistent load times, they simplify memory management issues, and they help prevent memory fragmentation. For the remainder of this paper, the word "quadtree" refers to the quadtree MIP map unless otherwise stated. <ref type="figure" target="#fig_1">Figure 2</ref> shows a quadtree MIP map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Texture Servers</head><p>One of the biggest obstacles to texture caching for real-time display is the blocking of a process when data is requested from the disk. Because of this blocking, most real-time applications do not access the disk extensively during interaction. Instead, the data that a scene needs is loaded before interaction begins, and there is a delay between scenes while new data is loaded. Pausche <ref type="bibr" target="#b14">[15]</ref> used a clever trick to get around stopping interaction between scenes. Instead of pausing, he required the user to fly through a long corridor containing minimal texture. The system then had time to swap textures for the new scene into texture memory. For our texture caching system, however, we needed to make a general framework that would allow continuous texture loading simultaneous to normal scene interaction. To prevent blocking during interaction, our system employs an additional process called the Texture Server. The Texture Server handles texture loading and decompression, and manages an in-memory texture cache.</p><p>A problem similar to disk blocking can occur when texture data resides across a slow network. If textures from the network are cached on a local disk, texture access time becomes bimodal. That is, access to textures already in the local disk cache is fast, but access to textures that must be downloaded over the network is slow, and the Texture Server may end up waiting for the network when it could be filling requests for textures stored locally. The solution to this problem is to employ a third process, the Meta-texture Server, to download textures over a slow network.</p><p>By using a Texture Server and Meta-texture Server, a three-level hierarchy of texture caches emerges, each level tended by a separate process. The application program regulates texture memory, the Texture Server takes care of the main memory cache, and the Metatexture Server tends the local disk cache. <ref type="figure" target="#fig_2">Figure 3</ref> shows how the application and texture servers work together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Texture as a Bandwidth-Limited Resource</head><p>All computers have limited bandwidth. By bandwidth we mean time-constrained resources, such as CPU cycles per second, disk access rates, and network speed. Any real-time application requires some percentage of the computer's bandwidth to run. If texture flow (loading texture from disk or over a network, decompressing textures, copying textures and texture definition) consumes too much bandwidth, real-time performance will be lost. For this reason the application program and the texture servers must work together to constrain texture flow so that sufficient bandwidth is available for scene interaction.</p><p>The application program's main responsibility with respect to texture flow is to prevent texture memory thrashing. Thus, the application may only use as much texture at a time as can fit into texture memory. In addition, the application must decide what textures to discard when texture memory is full. When a desired piece of texture is not resident in texture memory, the application requests it  from the Texture Server, in the meantime drawing the scene with a coarse version of the desired texture if one is available. The application must be careful to limit the rate at which it requests texture fragments, as the Texture Server may get bogged down processing old requests. Since it usually cannot request every texture that it wants, the application collects potential requests in a priority queue, called the "pre-queue", as it draws the scene. At the end of each frame, the pre-queue is used to fill the Texture Server's request queue, and then is cleared.</p><p>The Texture Server has several responsibilities related to texture flow. To prevent virtual memory swapping, the Texture Server limits the size of the in-memory texture cache. In addition, the Texture Server must limit the rate at which it loads textures, decompresses them, and transfers them to the application. If the Texture Server works too quickly it will consume needed machine bandwidth, reducing interactivity.</p><p>The Meta-texture Server may begin to use excessive machine bandwidth in some circumstances. For example, If the application program requires data from across the network, the Meta-texture Server must make sure not to saturate network bandwidth, preventing vital non-texture data from reaching the application program. Another example of the Meta-texture Server using too much bandwidth is if it is given the task of decompressing texture files as they come across the network. Compute-intensive image decompression may consume needed CPU bandwidth, preventing interactivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>This section describes our implementation of an application program, Texture Server, and Meta-texture Server. The application, a program to view phototextured terrain, uses a quadtree based terrain decimation scheme called Q-morphing <ref type="bibr" target="#b6">[7]</ref> that meshes well with the texture caching system. As mentioned in Section 3.1, the MIP-map tiles for the terrain texture are computed in advance and stored on disk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Finding the Right Texture Tile</head><p>Graphics APIs that provide MIP-mapping generally compute the MIP-map level that will be used for rendering automatically. Our system cannot use this facility, however. Instead, we explicitly compute the appropriate MIP-map level to use for each polygon or group of polygons to be rendered. This is done in a three step process. First, the screen radius of the polygon is calculated. Second, the texture radius of the polygon is calculated for a texture tile somewhere in the quadtree. Finally, the algorithm ascends or descends the quadtree until the polygon's texture radius matches its screen radius as closely as possible.</p><p>Computing the screen radius. The screen radius of a polygon is an estimate of the polygon's rendered size. It is defined as the length of the semi-minor axis of the projected bounding circle of the polygon. A good approximation to the screen radius of a polygon, or group of polygons, is derived in <ref type="bibr" target="#b10">[11]</ref>. We use a slightly modified version of this formula:</p><formula xml:id="formula_0">rs = h ψ × r cos φ d<label>(1)</label></formula><p>where rs = screen radius of the polygon h = height of viewport in pixels ψ = vertical field of view angle in radians r = world radius of polygon (maximum distance from centroid to a vertex in world space) φ = angle between polygon normal and ray from polygon centroid to viewpoint d = distance from viewpoint to polygon centroid It may be inefficient to find a separate texture tile for each polygon, so one tile may be used for a group of polygons. The screen radius of a group of semi-coplanar polygons is defined as:</p><formula xml:id="formula_1">rs = h ψ × r cos( max( 0, φ − υ) ) d (2)</formula><p>where υ is the maximum, or mean, deflection angle between the group's mean normal and the polygon normals of the group, and other variables are as defined above.</p><p>Computing the texture radius. The texture radius of a polygon is an estimate of the amount of texture that the polygon covers, and is defined as the maximum distance in texels from the centroid of the polygon to any vertex in texture space. Assuming texture coordinates do not change, the texture radius of a polygon on a particular texture tile is constant and need be computed only once.</p><p>Traversing the quadtree. Given the texture radius of a polygon for a reference texture tile, r tref , and the screen radius of the same polygon, rs, the next task is to find the appropriate level of the quadtree to use for rendering. This is done by ascending or descending the quadtree until rt, the texture radius of the polygon, matches most closely with its screen radius. More precisely, the correct tile is found when rt ≤ rs and 2rt &gt; rs. Note that the texture radius doubles for each level of descent in the quadtree, and halves for each level of ascent. Thus the approriate level of the quadtree is log 2 (rs/r tref ) levels below the reference tile, counting negative values as levels above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Texture Coordinates</head><p>Ascending and descending the quadtree. For this discussion, assume that the origin of a texture is the bottom left corner, and texture coordinates u and v increase to the right and up respectively. Children in the quadtree are numbered from left to right and bottom to top as follows: 0 1</p><p>Ascending or descending the quadtree requires a modification to a point's texture coordinates. This modification is based on the point's current texture coordinates and its location in the parent or child level. Pseudocode for the texture coordinate modification is given in <ref type="figure" target="#fig_3">Figure 4</ref>. Unfortunately, descending the quadtree may cause a single polygon to span multiple texture tiles, requiring a polygon split. To avoid polygon splitting, our terrain viewing application divides the terrain into small "gridlets" that are aligned with the nodes in the texture quadtree. Decisions about which texture tile to use are made on a per-gridlet basis, so no splitting is necessary. A similar partitioning of geometry is not practical for all applications, however, so geometry splitting may be a necessity in some cases. The benefit of polygon splitting is that it allows the quadtree MIP map to be applied to arbitrary polygonal geometries. Splitting may be done at scene creation time or at render time. Splitting at render time has the advantage that it can be done adaptively, producing fewer polygons than splitting done at scene creation time. The disadvantage, of course, is the computational cost of the splitting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Texture Loading</head><p>To load textures, the application program requests image tiles from the Texture Server. If the application were to request textures as fast as the need arose, the Texture Server would get bogged down processing old requests. For this reason, the application program prioritizes requests for texture, sending only the most urgent requests to the Texture Server. This prioritization is done by means of a priority queue called the "pre-queue". Each time the renderer asks for a piece of texture that is not available, a request for that texture is placed in the pre-queue based on a priority that will be explained later. At the end of each frame, the requests in the pre-queue are emptied into the Texture Server's actual request queue up to some maximum depth. The pre-queue is then cleared before the start of the next frame. When a texture request is sent to the Texture Server, the requested tile is marked as "pending". Texture requests that were pushed out of the pre-queue or that did not make it into the Texture Server's request queue will be regenerated during the next frame. <ref type="figure">Figure 9</ref> gives pseudocode for the generation of texture requests.</p><p>The maximum depth of the request queue going to the Texture Server should be kept as short as possible while still allowing for efficient bandwidth use. This is consistent with Bukowski and Sequin's idea of running a bandwidth-limited resource in "starvation mode" <ref type="bibr" target="#b3">[4]</ref>. We tried maximum request queue depths of 1 and 2 with similar results in both cases. The request queue going to the Texture Server was implemented using a datagram socket in our system.</p><p>To fill a request for texture, the Texture Server loads the desired image and constructs it in a shared memory segment. The application then copies the image and defines it as a texture. We control which texture is overwritten in texture memory by using a texture handle stack. At texture definition time, a handle is popped off the stack and given to the texture tile. When the texture tile is discarded, its handle is pushed back onto the handle stack.</p><p>To keep the texture server from working too quickly, we only provide one location in shared memory where the requested image may be placed. Hence, the Texture Server must wait for the application to release shared memory before it can construct another image. Pseudocode for the Texture Server's main loop is given in <ref type="figure">Figure  6</ref>. Since our system only allows one texture to be defined during a given animation frame, a good portion of texture flow regulation becomes choosing the right texture tile size. We found 256 × 256 tiles to be the best suited for the configurations with which we experimented. <ref type="figure">Figure 5</ref> gives texture definition times for the Reality Engine and O2. We set the maximum queue depth for requests going to the Metatexture Server to 1. The rationale behind this restriction is that any extra requests in the Meta-texture Server's queue will likely be obsolete before they can be filled. To pass data to the Texture Server, the Meta-texture Server copies files to the disk cache, and then returns the request to the Texture Server through a priority channel. In this way a request from the Meta-texture Server need not be placed in the rear of the Texture Server's request queue. The main loop of the Meta-texture Server is given in <ref type="figure">Figure 7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RE2</head><p>We did not want the application program to have to know in advance which requests can be filled by the Texture Server, and which must go to the Meta-texture Server, so a feedback mechanism is employed which returns requests to the application program unfilled when the Meta-texture Server's queue is full. To process a returned request, the application simply clears the requested texture's pending flag so that it can be requested again. By using the feedback mechanism, the application can make arbitrary texture requests without clogging the queue to the Meta-texture Server. Pseudocode for the application program is given in <ref type="figure" target="#fig_5">Figure 8</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Caching Algorithms</head><p>Unlike caching problems in which all requested data must be fetched before computation can take place, our texture caching system relies on the fact that the scene is still useful even if its textures momentarily contain less than full detail. Even so, the most important caching choice that the application program needs to make is which texture tile to request, that is, what priority algorithm to use for the pre-queue. Our approach to this algorithm is to treat texture retrieval as a progressive transmission problem. Thus the application does not request a texture tile until its parent is resident in texture memory or currently pending. In order to keep scene texture quality as uniform as possible, the priority for texture requests is based on the distance between the requested tile and its ideal counterpart in the quadtree. The priority is given by pr = rs rt</p><p>where pr is the tile's request priority, rs the screen radius of a polygon requesting the tile, and rt the polygon's texture radius in the re-  TextureTile *T; p = PolygonScreenRadius / PolygonTextureRadius; T = DesiredTile; while ( T not in texture memory ) if ( T not pending AND ( Parent(T) in texture memory or pending ) ) place request for T in pre-queue with priority p. p *= 2; T = Parent( T ); Modify C using Ascend(). return T; } <ref type="figure">Figure 9</ref>: Finding the right texture quested texture tile. Given the desired texture tile for a polygon, the actual tile used in rendering is found by ascending the quadtree until a resident tile is found, placing requests in the pre-queue as needed. <ref type="figure">Figure 9</ref> gives pseudocode for this operation.</p><p>Determining which texture tiles to discard from the three texture caches (texture memory, main memory, and local disk) is important, but not as vital as choosing which texture to fetch. We use a modified LRU discarding rule for tiles in texture memory that favors keeping tiles based on their distance from the root. The priority is given by</p><formula xml:id="formula_3">p d = f (l + 1)<label>(4)</label></formula><p>where p d is the discard priority for the tile, f the number of frames since the tile was last used, and l the tile's quadtree level, counting root level as zero. For the other two caches, the in-memory cache and the local disk cache, LRU and FIFO are used respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Texture Compression</head><p>Image compression in our system plays two important roles. First, it serves to increase the effective size of the main memory and disk caches. Second, it increases the effective transfer rate of texture images over a slow network. In both cases, however, the main purpose of compression is to increase the flow rate of textures from secondary storage to texture memory without degrading real-time performance. One of our main design goals was to make a texture caching system compatible with a wide variety of existing hardware. For this reason we could not expect to achieve compression for textures stored in texture memory. The main memory cache and the local disk cache, on the other hand, are more readily accessible and can be used to hold compressed textures.</p><p>We experimented with two types of compression, JPEG and Vector Quantization (VQ) <ref type="bibr" target="#b0">[1]</ref>. <ref type="figure" target="#fig_0">Figure 10</ref> gives CPU usage for decompression of JPEG and VQ texture tiles. For the single processor systems that we were using, decompression complexity turned out to be a big issue. JPEG decoding is quite CPU intensive, and produces a visible stutter in frame rate each time a texture tile is expanded. To lessen this effect, the Meta-texture server decompresses JPEG textures when they are put into the disk cache. Vector Quantization, on the other hand, is particularly efficient at decompression, so the system keeps these textures compressed in the main memory cache. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RE2</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>We tested our sample application running a Texture Server and Meta-texture Server on two platforms, an SGI Reality Station (RE2), and an SGI O2. The RE2 was equipped with 16 MB of texture memory and a single R10000 processor. The O2 also had a single R10000 processor, and used 16 MB of RAM as texture memory. <ref type="bibr" target="#b3">4</ref> The main memory cache for both systems was constrained to 100 MB. Frame rate and MSE trials were calculated for a 1383 frame flyby of Park City, Utah. The original texture image for the dataset is 6121 × 7651 pixels in size. The quadtree MIP map contains 965 256 × 256 texture tiles. Disk usage for the texture tiles exceeds 60 MB.</p><p>Trial 1-Frame rate. To get a feel for how much frame rate would degrade while running the Texture Server, we ran the Park City animation twice, using PGM versions of the texture files. <ref type="bibr" target="#b4">5</ref> On the first pass, we started the animation with only the root texture loaded, and allowed normal texture loading. On the second pass, however, we killed the Texture Server to prevent texture loading during the animation. By comparing the frame rates for the two passes, we were able to measure the frame rate degredation caused by running the Texture Server. Frame rate results for the Park City flyby are given in <ref type="figure" target="#fig_0">Figure 11</ref>. As evidenced by the figure, the Texture Server has only a minimal impact on a program's interactivity. <ref type="bibr" target="#b3">4</ref> The O2 uses a unified memory architecture, and has no dedicated texture memory. <ref type="bibr" target="#b4">5</ref> We did not use the Meta-texture Server for this timing trial. This reflects actual practice since the Meta-texture Server should not be used unless texture access characteristics become strongly bimodal.   <ref type="figure" target="#fig_0">Figure 12</ref>. <ref type="figure" target="#fig_0">Figure 13</ref> demonstrates the image quality degredation that occurs when disk bandwidth is constrained to simulate a slow network.</p><p>The largest practical dataset that we have made to date covers a 51×98 km region of the Wasatch Front in Northern Utah. <ref type="figure" target="#fig_0">Figure 14</ref> shows screen captures from this scene. The quadtree MIP map for the scene contains 60,309 256 × 256 image tiles. Total disk usage for the PGM tiles is 3.68 gigabytes. Since the grayscale texel size for the RE2 is 2 bytes, its 16 MB texture cache can hold at most 128 of the texture tiles. The texture quadtree for the scene is 471 times larger than texture memory capacity, and would not be displayable at all using traditional texture mapping methods. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Future Work</head><p>There are a number of open issues with respect to texture caching that we have not explored.</p><p>Our implementation does not provide trilinear MIP-mapping capability. Future implementations may provide trilinear filtering by defining a standard MIP map for each texture tile.</p><p>Image compression remains an area for further research. Thus far we have only considered two image compression schemes, JPEG and VQ. Other compression algorithms such as GIF or CCC encoding <ref type="bibr" target="#b4">[5]</ref> may prove useful. We have also not considered progressive image encoding algorithms, which may be able to leverage the information of parent texture tiles to build their children.</p><p>One thing we have not discussed is how to quickly map the quadtree of textures onto arbitrary polygonal topologies. When a polygon spans more than one texture tile, it must be split. If realtime performance is to be maintained for arbitrary topologies, the modeler cannot simply dice polygons so that each piece covers a single leaf texture.</p><p>Prediction is another area in which additional work could be done. By using appropriate prediction, the bandwidth available for texture flow could be more efficiently utilized, increasing the quality of rendered images.</p><p>Finally, we have not thoroughly explored caching and priority algorithms. There may be more effective criteria than the ones we are currently using to determine which texture tiles to fetch and which to discard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have developed a texture caching system suitable for interactive display of very large textures. The new approach eliminates the performance bottlenecks associated with large textures by treating texture as a bandwidth-limited resource, allowing an application to maintain real-time performance while rendering textures nearly five hundred times larger than the hardware texture cache. For some datasets, the textures that the system can display in real time are larger than can be feasibly displayed at all using traditional texture mapping methods. The approach is completely software based and can be impemented on existing low-end graphics workstations. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Typical texture loading for real-time applications</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Original image (left) and quadtree MIP map of the same image (right). Empty tiles are not stored.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Texture management using texture servers. Bold arrrows indicate texture flow. Other arrows indicate inter-process communication.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>TextureTile *Ascend( float &amp;U, float &amp;V, int ChildNum, TextureTile *ThisTile ) { U *= 0.5; if ( ChildNum == 1 OR ChildNum == 3 ) U += 0.5; V *= 0.5; if ( ChildNum == 2 OR ChildNum == 3 ) V += 0.5; return Parent( ThisTile ); } TextureTile *Descend( float &amp;U, float &amp;V, TextureTile *ThisTile ) { int ChildNum=0; U *= 2.0; if ( U &gt; 1.0 ) U -= 1.0; ChildNum += 1; V *= 2.0; if ( V &gt; 1.0 ) V -= 1.0; ChildNum += 2; return Child( ChildNum, ThisTile ); } Texture coordinate modification for ascending and descending the quadtree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Texture Server main loop MetaTextureServerMainLoop() { repeat Read request from Texture Server. if ( request == "quit" ) return; Copy requested file or URL to disk cache. Send request to Texture Server's priority channel. while ( disk cache size &gt; MAX disk cache size ) Delete least significant bitmap file. /* FIFO */ } Meta-texture Server main loop</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Pseudocode for the application program TextureTile *TileToUse( TextureTile *DesiredTile, TextureCoordinates &amp;C ) { float p;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 12 :Trial 2 -</head><label>122</label><figDesc>Mean squared error for frames extracted from the Park City flyby. Compression for vector quantized tiles was 3.8:1. Average compression for JPEG was 7.4:1. Bandwidth limits correspond roughly to a T1 line and an ISDN line. Mean Squared Error. An important indicator of the quality of our system is an error metric between desired frames and actual frames from the same camera path under differing disk bandwidths and compression schemes. For comparison purposes we used the mean squared error per color component, not considering untextured background pixels. MSE results are given in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 13 :</head><label>13</label><figDesc>A frame from the Park City flyby under differing bandwidths. Unrestricted disk bandwidth with PGM textures (left). Bandwidth restricted to 8000 bytes/sec with JPEG textures (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 14 :</head><label>14</label><figDesc>Frames from a flythrough of the Wasatch Front dataset. The images were captured at a resolution of 1024 × 512 pixels. Rectangles show the approximate framing of successive viewpoints.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Measured times for definition of 256 × 256 texture tiles on a Reality Station 10000 and O2. Both computers have a single R10000 processor. Times are given in milliseconds. The first three rows of the table show times for Iris GL texture definition. The next two give data for OpenGL. The last row of the table shows the time required to create MIP-map images using a simple box filter in software.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>O2</cell><cell></cell></row><row><cell></cell><cell>Definition Type</cell><cell>gray</cell><cell>color</cell><cell cols="2">gray color</cell></row><row><cell></cell><cell>Fast Define</cell><cell cols="2">&lt; 0.1 &lt; 0.1</cell><cell>-</cell><cell>-</cell></row><row><cell>Iris GL</cell><cell>No MIP map</cell><cell>11.4</cell><cell>18.2</cell><cell>12.2</cell><cell>50.2</cell></row><row><cell></cell><cell>With MIP map</cell><cell cols="4">208.0 216.0 264.0 354.0</cell></row><row><cell cols="2">OpenGL No MIP map</cell><cell>4.5</cell><cell>19.9</cell><cell>13.8</cell><cell>32.5</cell></row><row><cell></cell><cell>With MIP map</cell><cell>8.1</cell><cell>26.1</cell><cell>22.9</cell><cell>48.3</cell></row><row><cell cols="2">Software Resampling</cell><cell>4.5</cell><cell>11.3</cell><cell>5.0</cell><cell>12.8</cell></row><row><cell>Figure 5:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Figure 10: CPU usage for decompression of 256 × 256 images on the RE2 and O2. Times are in milliseconds. JPEG measurements are based on a library from the Independent JPEG Group.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>O2</cell><cell></cell></row><row><cell></cell><cell cols="4">gray color gray color</cell></row><row><cell>PPM</cell><cell>0.5</cell><cell>6.2</cell><cell>0.6</cell><cell>7.2</cell></row><row><cell cols="2">JPEG 17.2</cell><cell cols="2">32.2 19.6</cell><cell>37.5</cell></row><row><cell>VQ</cell><cell>0.6</cell><cell>1.8</cell><cell>0.7</cell><cell>2.2</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Frame rates for RE2 and O2 during Park City flyby showing the frame rate degredation caused by the Texture Server. The important thing here is not the actual frame rate achieved, but the drop in frame rate caused by running the Texture Server.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">RE2(1024x800): no texture server</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">RE2(1024x800):</cell><cell>texture server</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">O2(800x600): no texture server</cell></row><row><cell>Frames / Sec.</cell><cell>20 30</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>O2(800x600):</cell><cell>texture server</cell></row><row><cell></cell><cell>10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>200</cell><cell>400</cell><cell>600</cell><cell>800</cell><cell>1000</cell><cell>1200</cell><cell>1400</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Frame Number</cell><cell></cell><cell></cell></row><row><cell cols="2">200 400 600 1000 Figure 11: 0 MSE 800</cell><cell></cell><cell cols="5">MSE for Park City flyby on the RE2(1024x800) unrestricted: pgm 200,000 Bps: pgm 200,000 Bps: vq2x2 8,000 Bps: vq2x2 8,000 Bps: jpeg</cell></row><row><cell></cell><cell>0</cell><cell>200</cell><cell>400</cell><cell>600</cell><cell>800</cell><cell>1000</cell><cell>1200</cell><cell>1400</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Frame Number</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">MSE for Park City flyby on the O2(800x600)</cell><cell></cell></row><row><cell></cell><cell>1000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">unrestricted: pgm 200,000 Bps: pgm</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">200,000 Bps: vq2x2</cell></row><row><cell></cell><cell>800</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">8,000 Bps: vq2x2 8,000 Bps: jpeg</cell></row><row><cell>MSE</cell><cell>600</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>400</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>200</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>200</cell><cell>400</cell><cell>600</cell><cell>800</cell><cell>1000</cell><cell>1200</cell><cell>1400</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Frame Number</cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowlegements</head><p>Thanks to Kirk Duffin for his work in building the terrain datasets. Thanks also to the USGS for providing the data. This work was funded in part by a grant from the Utah State Center of Excellence.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Rendering from Compressed Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">C</forename><surname>Beers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maneesh</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navin</forename><surname>Chaddha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="373" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Implementing a Texture Caching System. Game Developer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Blow</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-04" />
			<biblScope unit="page" from="46" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Texture Cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Blow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 Computer Game Developers Conference. Bolt Action Software</title>
		<meeting>the 1998 Computer Game Developers Conference. Bolt Action Software</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Interactive Simulation of Fire in Virtual Building Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Bukowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlo</forename><surname>Sequin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="35" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Two Bit/Pixel Full Color Encoding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Defanti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Joyce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><forename type="middle">A</forename><surname>Leske</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">A</forename><surname>Lindberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Sandin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 86 Conference)</title>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="215" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Quicktime VR -An Image-Based Approach to Virtual Environment Navigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename><surname>Shenchang Eric</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 95 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="29" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Interactive Display of Very Large Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cline</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<pubPlace>Provo UT 84602</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Brigham Young University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s Thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Real-Time Photo-Realistic Visual Flythrough</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Rich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ui</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Shenkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="255" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interactive Image Query System using Progressive Transmission</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">S</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sheldon</forename><surname>Walker</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fuwen</forename><surname>Gao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 83 Conference)</title>
		<imprint>
			<date type="published" when="1983" />
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Light Field Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Level-of-Detail Management for Real-Time Rendering of Phototextured Terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><forename type="middle">F</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Turner</surname></persName>
		</author>
		<ptr target="file://ftp.gvu.gatech.edu/pub/gvu/tr/95-06.ps.z.GIT-GVUTech-nicalReport" />
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="95" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graphics Library Programming Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><surname>Mclendon</surname></persName>
		</author>
		<idno>007-1702-010</idno>
	</analytic>
	<monogr>
		<title level="j">Silicon Graphics</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">ImageVision Library Programming Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacke</forename><surname>Neider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tillman</surname></persName>
		</author>
		<idno>007-1387-020</idno>
	</analytic>
	<monogr>
		<title level="j">Silicon Graphics</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">UTAH: The Movie</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaun</forename><forename type="middle">M</forename><surname>Oborn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<pubPlace>Logan UT</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Utah State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s Thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Disney&apos;s Aladdin: First Steps Towards Story Telling in Virtual Reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randy</forename><surname>Pausch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Snoddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Halestine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="193" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Rendering Complex Scenes with Memory-Coherent Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matt</forename><surname>Pharr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Kolb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reid</forename><surname>Gershbein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="101" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">InfiniteReality: A Real-Time Graphics System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Montrym</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">L</forename><surname>Dignam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">J</forename><surname>Migdal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="293" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Quadtree and Related Hierarchical Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Comp. Surveys</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="178" to="260" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hierarchical Image Caching for Accelerated Walkthroughs of Complex Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dani</forename><surname>Lischinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">H</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Approach to Efficient Storage, Retrieval, and Browsing of Large Scale Image Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Norbert</forename><surname>Strobel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sanjit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Manjunath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SPIE</title>
		<meeting>the SPIE</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="volume">2606</biblScope>
			<biblScope unit="page" from="324" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Talisman: Comodity Realtime 3D Graphics for the PC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jay</forename><surname>Torborg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">T</forename><surname>Kajiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="353" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Pyramidal Parametrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lance</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH 83 Conference)</title>
		<imprint>
			<date type="published" when="1983" />
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
