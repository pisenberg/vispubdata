<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visualizing Hilbert Curves</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
							<email>max2@llnl.gov</email>
							<affiliation key="aff0">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Visualizing Hilbert Curves</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>A computer animated movie was produced, illustrating both 2D and 3D Hilbert curves, and showing the transition from 2D to 3D with the help of volume rendering.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Hilbert curves are continuous curves which pass at least once through each point of a square <ref type="bibr" target="#b0">[Hilb91]</ref> or cube. They can be defined as the limit of a sequence of mappings of successively smaller dyadic subintervals of the unit interval to small subsquares or subcubes.</p><p>These finite approximations are useful for coding images or volumes. Area coherence in an image produces high correlation in the sequence of data values at pixels, when they are traversed in the order of a Hilbert curve approximation, allowing efficient data compression. Similarly, tracing out a volume Hilbert curve can take advantage of data coherence in all three dimensions.</p><p>This paper describes the production of an animated film illustrating 2D and 3D Hilbert curves. The content of the film is described in section 1, the mathematical definitions and algorithms for the approximations are given in section 2, and the volume rendering techniques are discussed in section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">The Film Plot</head><p>The animation starts with a circular tube, which deforms continuously through smooth piecewise-circular approximations to the 2D Hilbert curve. <ref type="figure">Figure 1</ref> shows the fourth order approximation. (See color supplement at the end of the volume for figures 1 to 8.) The tube changes to a square cross section, and by the fifth order approximation, shown in figure 2, it is touching itself. The circular arcs then square off so that the approximation appears to cover the square, and the surfaces become partially transparent, to reveal the glowing volume density shown in figure 3.</p><p>The curve is yellow, with its parametrization indicated by short segments in light green, purple, and dark green, repeated in eight cycles. The origin of the parametrization is advanced along the curve as the animation progresses, so that it looks like a crawling colored snake. This indicates the path of the curve even when the whole square is filled up. Volume rendering extends this color indication of the path to three dimensions, and the marble tile background helps in perceiving the volume opacity.</p><p>The closed curve breaks between a purple and dark green band and the front part begins filling up the cube as a 3D Hilbert curve. By figure 4, the second purple band has started into the cube, and by figure 5, the whole curve has moved over to the cube, and again becomes closed.</p><p>Figures 3 through 5 show high order approximations, using a recursive rendering algorithm described in section 3, which only subdivides squares or cubes which are not of homogeneous color. Between any two frames in the animation, many tiny squares or cubes change color, so the motion is jerky. <ref type="figure">Figure 6</ref> shows a switch to the third order approximation, where the color boundaries move smoothly. The surface is incised between cubes which are not adjacent on the approximation path, and in figure 7, the incisions have widened to reveal the squared off tube. This is the reverse of the process, not illustrated here, between figures 2 and 3. Finally in figure 8 the tube becomes rounded, to give the 3D version of figure 1. In the animation sequence including figures 5 through 8 the camera is slowly rotated about the curve, so that motion parallax can help make the 3D structure more evident. The higher order bits are defined recursively, using rotated versions of this order, as shown at the left of figure 10. In the squares labeled 1 and 2 in figure 9, the pattern is just a reduced and translated version of the pattern in figure 9, but in squares 0 and 3, it is reflected and rotated. Apart from the scaling and translation, the basic transformation for the pattern is given by one of the following four orthogonal matrices: I assume that for the nth approximation, the coordinates of x and y are given by n bit integers, ix and iy, with the highest order bit of x indicated by x 0 , the next highest by x 1 , and so on. When divided by the implied denominator 2 n , these ix and iy coordinates give the position of the lower left corner (x, y) of the corresponding subsquare. Similarly, the 2n bit integer it is divided by 2 2n to get the left hand endpoint t of the corresponding subinterval. Thus the arrays xbit2D and ybit2D determine x 0 and y 0 from the first two bits t 01 of t. To get the next highest bits x 1 and y 1 from the next two bits t 23 of t, we must translate figure 9 by (-.5, -.5) so that the center is at the origin, rotate by R2D[t 01 ], and then translate back. The product of these three affine transformations can be represented by a 3 x 3 integer matrix for homogeneous coordinates, which is used to transform the vector (xbit2D[t 23 ], ybit2D[t 23 ], 1) to get (x 1 , y 1 , 1). However it is more efficient to code, and easier to understand, if the 2 x 2 matrices given above are used, and the two translations are done separately. As show in the code below, the coordinates are multiplied by two before the first translation, and divided by two after the second, to keep all arithmetic in integers. The matrices S2D are described below.  To guarantee the continuity of the limit curve, I then used the matrices R2D for all subsequent bits of x and y, so that a half-sized copy of figure 10a) appears in each of the subsquares of figure As many as 4 different values of t can map to the same common subsquare corner point (x, y), so the limit mapping is not one-toone, and has no inverse. However, there is a well defined inverse mapping from finite dyadic subsquares to finite dyadic subintervals in t. It is needed to determine the color of a subsquare according to the moving colored bands defined by t and the frame number. This inverse is computed using the array tbits2D, and the transpose to get the inverse of a rotation matrix.  The matrices to rotate this pattern into position in each of the eight subcubes are essentially those given in <ref type="bibr" target="#b1">[Liu97]</ref> but I have incorporated a reflection that reverses the order of traversal where necessary. This obviates keeping track of the traversal order, which makes the algorithm in <ref type="bibr" target="#b1">[Liu97]</ref> unnecessarily complicated. Thus the 3D rotation matrices are: As in the 2D case, I needed a set of revised matrices for the second order approximation, to produce a closed curve which agrees with the 3D Hilbert curve of <ref type="bibr" target="#b1">[Liu97]</ref> in the top half of the cube, and follows its mirror image in the bottom half. Only the matrices for the bottom four subcubes need be revised, and since in figure 12, the curve in the subcubes 1 and 6 of figure 11 is already the mirror image of the curve in subcubes 2 and 5, respectively, the only new matrices are S3D[0] = , and S3D[7] = .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Defining the Approximations.</head><formula xml:id="formula_0">R2D[0] = ,</formula><p>To get the piecewise circular approximation to the curve inside the square (x, y) shown in <ref type="figure">figure 13, I computed t from (x, y)</ref> and then found the previous square (xp, yp) from t-1, and the following square (xf, yf) from t+1. I connected the center A of the edge separating square (x, y) and square (xp, yp) to the center B of the edge separating square (x, y) and square (xf, yf), by a 90° circular arc whose center C is the corner where these three squares meet. If the three squares are in a row, with no common corner, I joined A and B by a straight line. The same scheme works in 3D; the circular arc joins the centers of two faces of the cube.</p><p>It was a challenge to deform this arc through a continuous family of piecewise circular curves into its position in the next approximation. I had initially planned to end the film by unwinding the 3D Hilbert curve back to a simple circle, but I did not have time to design the necessary 3D deformation. It was also a challenge to get a smoothly varying parametrization of the piecewise circular curves in the family, for the purpose of deciding where to switch between the different colored bands. The parametrization had to be nearly proportional to arc length, but also assign the same parameter increase to the circular arc in figure 13 as to the straight line in the case that all three squares are in a row.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Rendering Issues.</head><p>As described in section 1, and shown in the color figures 1 through 8, the colored bands move along the curve during the animation. Thus, if f is a real number proportional to the frame count, and t is the real parameter in [0,1] along the curve, the color is determined by a periodic piecewise constant function C(t -f) of the difference t -f. The colors have four components, red, green, blue, and opacity α, which is interpreted as the extinction coefficient for volume rendering. In the limit curves, which fill in the whole square or cube, the path of the curve is indicated by these moving colored bands. They are revealed in the 3D case using semi-transparent volume rendering.</p><p>The volume rendering is based on recursive octree subdivision of the level 0 unit cube. The octree node cube at level k is indexed by integers (ix, iy, iz), obtained by multiplying the coordinates of its front lower left corner (x, y, z) by 2 k . This cube corresponds to an integer it by the inverse mapping discussed in section 2, and to the subinterval of length 2 -3k of the unit interval, starting at t = 2 -3k it. If [t -f, t + 2 -3k -f] lies within one of the ranges where the color C is constant, or if k = kmax, the maximum level of recursion, the cube has a constant color, and can be composited onto the image. If not, it is subdivided into its eight subcubes, they are sorted in back to front order according to the position of the viewpoint, and the recursive routine is called for each.</p><p>The volume projection uses the SGI hardware pipeline, as described in <ref type="bibr" target="#b3">[WMS98]</ref>. The projections of the edges of a cube divide the image plane into polygons onto which a single front cube face and a single rear cube face project. The thickness l varies linearly across such a polygon, and can be interpolated as a texture coordinate by the texture mapping hardware. The second texture coordinate is the extinction coefficient τ, which in this application is constant on each cube. The texture map stores α = 1. -exp(-lτ), which is the polygon opacity needed for correct compositing of a semitransparent volume density. (See [WMS97] for details.)</p><p>When I produced the volume rendered Hilbert curve with this rendering method, it looked too fuzzy, because there were no clearly defined surfaces bounding each volume region. Therefore I added semitransparent polygons to the front surfaces of a cube, if such surfaces separated volumes of different colors. The determination of these separating faces, for each cube rendered by the volume recursion above, also requires recursion. The recursive pseudocode below is called for each front-facing face F of a volume rendered cube C at recursion level k. Because all rendering was done by the SGI hardware, through OpenGL calls, it only took a few seconds a frame. The images were generated at 1270 x 970 pixel resolution, and then averaged down to 635 x 485 resolution for video recording, providing 2 x 2 supersampled antialiasing.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Draw</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>The 2D Hilbert curve maps a t in the unit interval [0, 1] to a pair (x, y) in the unit square [0, 1] x [0, 1]. An approximation of order n assigns the first n binary digits of x and y, given the first 2n binary digits of t. The first bits of x and y come from the first two bits of t according to the ordering of the four subsquares shown in figure 9. Thus xbit2D[4] = {0, 0, 1, 1}, ybit2D[4] = {0, 1, 1, 0}, and, for the inverse mapping, tbits2D[2][2] = {0, 1, 3, 2}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 9. Ordering of the four subsquares.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>For</head><label></label><figDesc>the film plot described above, I needed a closed curve, so I used the variant second approximation shown in figure 10b). To move the pattern in figure 9 to the four subsquares infigure 10b), I used the matrices:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>10b), oriented by the matrix S2D[t 01 ]. Thus the combined rotation to determine x 2 and y 2 from t 45 is S2D[t 01 ] R2D[t 23 ], and the R2D matrices are also used in the rest of the recursion. The resulting curve agrees with Hilbert's on the top half of the square, and the bottom half is the mirror image of the top half. In this ordering of the subsquares by t, consecutive dyadic intervals map to adjacent subsquares, which is what makes the limit mapping continuous.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>void xy_to_t(int n, int ix, int iy, int *it){ int j,k,l,m,rt[2][2],rq[2][2],va[2],vb[2]; identity_matrix2D(rt); *it = 0; for (k = n-1; k &gt;= 0; --k) { if (k == n-1) { l = 1 &amp; (ix &gt;&gt; k); m = 1 &amp; (iy &gt;&gt; k); } j = tbits2D[l][m]; *it += j &lt;&lt; (2*k); if (k &gt; 0) { matrix_copy2D(rt, rq); if(k == n-1) matrix_multiply2D(rq, S2D[j], rt); else matrix_multiply2D(rq, R2D[j], rt); matrix_transpose2D(rt, rq); va[0] = 2*(1 &amp; (ix &gt;&gt; (k-1))) -1; va[1] = 2*(1 &amp; (iy &gt;&gt; (k-1))) -1; matrix_times_vector2D(rq, va, vb); l = (vb[0] + 1)/2; m = (vb[1] + 1)/2; }}} The Hilbert curve in 3D is generated in the same way, using 3D vectors and matrices. The basic pattern shown in figure 11 results in xbit3D[8] = {0, 0, 0, 0, 1, 1, 1, 1}, ybit3D[8] = {0, 1, 1, 0, 0, 1, 1, 0}, zbit3D[8] = {0, 0, 1, 1, 1, 1, 0, 0},</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure</head><label></label><figDesc>Figure 10. Second order approximations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>R3D</head><label></label><figDesc>is similar to the 2D case. The second approximation is shown in figure 12.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 12 .Figure 13 .</head><label>1213</label><figDesc>The second 3D Hilbert curve approximation. Construction of a circular arc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(k, F, C){ if(F lies on one of the outside faces of the level 0 cube) {render(F); return;} find the cube D of the same size as C on the opposite side of face F; if(Color(D) is homogeneous or k == kmax) if(Color(D) != Color(C) ) render(F); else subdivide F into four subfaces Fs[i], bounding four subcubes Cs[i]of C; for(i = 0; i &lt; 4; ++i) Draw(k+1, Fs[i], Cs[i]); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Figure 3 Figure 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 4 .</head><label>4</label><figDesc>Figure 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>In the next stage we rotate figure 10a) by the matrix R2D[t 01 ], shrink it to half size, and use it in each of the four subsquares. Thus the combined rotation R2D[t 01 ]R2D[t 23 ] is used to determine x 2 and y 2 from t 45 . We continue recursively generating the subsequent digits.</figDesc><table><row><cell>void t_to_xy(int n, int it, int *ix, int *iy) {</cell></row><row><cell>int j,k,rt[2][2], rq[2][2], va[2], vb[2];</cell></row><row><cell>identity_matrix2D(rt);</cell></row><row><cell>*ix = *iy = 0;</cell></row><row><cell>for (k = n-1; k &gt;= 0; --k) {</cell></row><row><cell>j = 3 &amp; (it &gt;&gt; (2*k));</cell></row><row><cell>va[0] = 2*xbit2D[j] -1;</cell></row><row><cell>va[1] = 2*ybit2D[j] -1;</cell></row><row><cell>matrix_times_vector2D(rt, va, vb);</cell></row><row><cell>*ix += ((vb[0] + 1)/2) &lt;&lt; k;</cell></row><row><cell>*iy += ((vb[1] + 1)/2) &lt;&lt; k;</cell></row><row><cell>if (k &gt; 0) {</cell></row><row><cell>matrix_copy2D(rt, rq);</cell></row><row><cell>if (k == n-1)</cell></row><row><cell>matrix_multiply2D(rq, S2D[j], rt);</cell></row><row><cell>else</cell></row><row><cell>matrix_multiply2D(rq, R2D[j], rt);</cell></row><row><cell>}}}</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under contract number W-7405-ENG-48. Brett Keating produced the marble texture, using algorithms from <ref type="bibr" target="#b2">[Perl85]</ref>. Mark Duchaineau provided a window opening and image read-back facility that relieved me of learning the details of X. Dietmar Saupe pointed me to reference <ref type="bibr" target="#b1">[Liu97]</ref>. Brian Cabral and Dan Schikore provided debugging help. Jan Nunes, Ross Gaunt, and Eugene Cronshagen recorded the video. Don Patterson, Mike Miller, and Charlene Frey provided emergency system help. The IEEE reviewers made useful suggestions and corrected errors in the code fragments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Uber die stetige Abbildung einer Linie auf ein Flächenstück</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Hilbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Annalen</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="459" to="460" />
			<date type="published" when="1891" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An algorithm for encoding and decoding the 3-D Hilbert order</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xian</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Günther</forename><surname>Schrack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1333" to="1337" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An image synthesizer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Perlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Siggraph &apos;85 Proceedings</title>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="287" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A high accuracy volume renderer for unstructured data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clifford</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="54" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
