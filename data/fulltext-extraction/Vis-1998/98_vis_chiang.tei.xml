<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Out-Of-Core Isosurface Extraction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi-Jen</forename><surname>Chiang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Polytechnic University IBM T. J. Watson Research Center Kitware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cl√°udio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Polytechnic University IBM T. J. Watson Research Center Kitware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Polytechnic University IBM T. J. Watson Research Center Kitware</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive Out-Of-Core Isosurface Extraction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Isosurface Extraction</term>
					<term>Marching Cubes</term>
					<term>Out-Of-Core Computation</term>
					<term>Interval Tree</term>
					<term>Scientific Visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper, we present a novel out-of-core technique for the interactive computation of isosurfaces from volume data. Our algorithm minimizes the main memory and disk space requirements on the visualization workstation, while speeding up isosurface extraction queries. Our overall approach is a two-level indexing scheme. First, by our meta-cell technique, we partition the original dataset into clusters of cells, called meta-cells. Secondly, we produce metaintervals associated with the meta-cells, and build an indexing data structure on the meta-intervals. We separate the cell information, kept only in meta-cells in disk, from the indexing structure, which is also in disk and only contains pointers to meta-cells. Our meta-cell technique is an I/O-efficient approach for computing a k-d-tree-like partition of the dataset. Our indexing data structure, the binaryblocked I/O interval tree, is a new I/O-optimal data structure to perform stabbing queries that report from a set of meta-intervals (or intervals) those containing a query value q. Our tree is simpler to implement, and is also more space-efficient in practice than the existing structures. To perform an isosurface query, we first query the indexing structure, and then use the reported meta-cell pointers to read from disk the active meta-cells intersected by the isosurface. The isosurface itself can then be generated from active meta-cells. Rather than being a single-cost indexing approach, our technique exhibits a smooth trade-off between query time and disk space.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Isosurface extraction represents one of the most effective and widely used techniques for the visualization of volume datasets.</p><p>Formally, a scalar volume dataset consists of tuples x; Fx, where x is a 3D point and F is a scalar function defined over 3D points. Given an isovalue q, extracting the isosurface of q is to compute the isosurface Cq = fxjFx = qg. The computation process can be divided into two phases: First, one finds the active cells that are intersected by the isosurface (the search phase), and then, one can compute the isosurface from the active cells (the generation phase). Most of the isosurface algorithms require the entire dataset to be kept in main memory, which is a severe limitation on their applicability, especially for large scientific applications.</p><p>In this paper, we present an isosurface technique whose main memory and disk space requirements on the visualization workstation are minimized, while speeding up the isosurface extraction procedure. In the same flavor as the methods of <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, we index the dataset cells to achieve output-sensitive searches. Also, as in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, we keep both the indices (i.e., intervals obtained from the cells) and the original dataset in disk, rather than in main memory. Moreover, during isosurface queries only a small portion of the dataset is touched and brought to main memory, by performing yjc@photon.poly.edu y csilva@watson.ibm.com z william.schroeder@kitware.com (using an indexing data structure) stabbing queries that report from a set of intervals those containing the query value q.</p><p>In <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, to avoid inefficient pointer references in disk, the direct cell information is stored with its interval, in the indexing data structure. This is very inefficient in disk space, since the vertex information is duplicated many times, once for each cell sharing the vertex. Moreover, in the indexing structures <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">18]</ref> used, each interval is stored three times in practice, increasing the duplications of vertex information by another factor of three. To eliminate this inefficiency, our indexing scheme uses a two-level structure. First, we partition the original dataset into clusters of cells, called meta-cells. Secondly, we produce meta-intervals associated with the meta-cells, and build our indexing data structure on the metaintervals. We separate the cell information, kept only in meta-cells in disk, from the indexing structure, which is also in disk and only contains pointers to meta-cells. Isosurface queries are performed by first querying the structure, then using the reported meta-cell pointers to read from disk the active meta-cells intersected by the isosurface, which can then be generated from the active meta-cells.</p><p>While we need to perform pointer references in disk from the indexing structure to meta-cells, the spatial coherences of isosurfaces and of our meta-cells ensure that each meta-cell being read contains many active cells, so such pointer references are efficient. Also, a meta-cell is always read as a whole, hence we can use pointers within a meta-cell to store each meta-cell compactly. In this way, we obtain efficiencies in both query time and disk space. Two new techniques lie at the heart of this paper. One is the meta-cell technique that computes the spatially coherent meta-cells. The other is the binary-blocked I/O interval tree, a new I/O-optimal stabbingquery data structure that is simpler to implement and more spaceefficient in practice than those in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">18]</ref>. We believe both techniques will find applications other than efficient out-of-core isosurface extraction.</p><p>We summarize the contributions of this work as follows.</p><p>We present a novel out-of-core isosurface technique that improves <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. While keeping the querying time and main memory requirement small, the disk space overhead is reduced by more than one order of magnitude.</p><p>We give a new meta-cell technique that partitions a volume dataset into spatially coherent meta-cells. This can be viewed as an out-of-core k-d-tree-like partition, and is efficiently carried out by performing external sorting a few times.</p><p>We propose the binary-blocked I/O interval tree, a new I/Ooptimal stabbing-query data structure. Previous such structures <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">18]</ref> both have three types of secondary lists, but our tree has only two types of lists (as in the original main memory interval tree of <ref type="bibr" target="#b13">[14]</ref>), so it has the tree size reduced by a factor of 2/3 in practice, and is also simpler to implement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Previous Related Work</head><p>We first briefly review the work on out-of-core, or I/O techniques. In addition to early work on sorting and scientific computing, recently there have been I/O algorithms for graphs and for computational geometry; see <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> for the references. Although most of the results are theoretical, the experiments of Chiang <ref type="bibr" target="#b7">[8]</ref>, Vengroff and Vitter <ref type="bibr" target="#b26">[27]</ref>, and Arge et al. <ref type="bibr" target="#b1">[2]</ref> on some of these techniques show that they result in significant improvements over traditional algorithms in practice. Teller et al. <ref type="bibr" target="#b23">[24]</ref> describe a system to compute radiosity solutions for polygonal environments larger than main memory, and Funkhouser et al. <ref type="bibr" target="#b14">[15]</ref> present prefetching techniques for interactive walk-throughs in large architectural virtual environments. Very recently, Pharr et al. <ref type="bibr" target="#b20">[21]</ref> give memory-coherent ray-tracing algorithms, Cox and Ellsworth <ref type="bibr" target="#b12">[13]</ref> present application-controlled demand paging methods, and Ueng el al. <ref type="bibr" target="#b24">[25]</ref> propose out-of-core streamline techniques. As for isosurface extraction, there is a very rich literature. Here we only briefly review the results that focus on speeding up the search phase. We let N denote the number of cells in the dataset, and K the number of active cells. In Marching Cubes <ref type="bibr" target="#b19">[20]</ref>, all cells are searched for isosurface intersection, and thus ON time is needed. Techniques avoiding exhaustive scanning include using an octree <ref type="bibr" target="#b27">[28]</ref>, identifying a collection of seed cells and performing contour propagation from the seed cells <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b25">26]</ref>, NOISE <ref type="bibr" target="#b18">[19]</ref>, and other nearly optimal isosurface extraction methods <ref type="bibr" target="#b22">[23]</ref>. The first optimal isosurface extraction algorithm was given by Cignoni et al. <ref type="bibr" target="#b11">[12]</ref>, based on the following two ideas. First, for each cell, they produce an interval I = min; max where min and max are the minimum and maximum of the scalar values in the cell vertices. Then the active cells are exactly those cells whose intervals contain q. Searching active cells then amounts to performing stabbing queries. Secondly, the stabbing queries are solved by using an internal-memory interval tree <ref type="bibr" target="#b13">[14]</ref>. After an ON log N-time preprocessing, active cells can be found in optimal Olog N + K time.</p><p>The first out-of-core isosurface technique was given by Chiang and Silva <ref type="bibr" target="#b9">[10]</ref>. They follow the ideas of Cignoni et al. <ref type="bibr" target="#b11">[12]</ref>, but use the I/O-optimal interval tree of <ref type="bibr" target="#b2">[3]</ref> to solve the stabbing queries. In their follow-up paper <ref type="bibr" target="#b10">[11]</ref>, they replaced the I/O interval tree of <ref type="bibr" target="#b2">[3]</ref> with the metablock tree <ref type="bibr" target="#b17">[18]</ref>. With their techniques, datasets much larger than main memory can be visualized very efficiently. The major drawback is the large overhead in disk space to hold the search structure, and the disk scratch space needed to build the structure. Another out-of-core isosurface technique, based on contour propagation from seed cells, is recently proposed in <ref type="bibr" target="#b4">[5]</ref> (where no out-of-core implementation is reported).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Main Techniques</head><p>In this section we present our isosurface algorithm. There are two major techniques: the meta-cell technique, which is used to construct meta-cells from dataset cells, and the binary-blocked I/O interval tree, which is a new I/O-optimal stabbing-query data structure, used to serve as an indexing structure for the meta-cells. We show the preprocessing pipeline of our overall algorithm in <ref type="figure">Fig. 1</ref>. The main tasks are as follows:</p><p>(1) Group spatially neighboring cells into meta-cells. The total number of vertices in each meta-cell is roughly the same, so that during queries each meta-cell can be retrieved from disk with approximately the same I/O cost. Each cell is assigned to exactly one meta-cell.</p><p>(2) Compute and store in disk the meta-cell information for each meta-cell. We describe the representation of meta-cells. Each meta-cell has a list of vertices, where each vertex entry contains its x-, y-, z-</p><p>and scalar values, and a list of cells, where each cell entry contains pointers to its vertices in the vertex list. In this way, a vertex shared by many cells in the same meta-cell is stored just once in that meta-cell. The only duplications of vertex information occur when a vertex belongs to two cells in different meta-cells; in this case we let both meta-cells include that vertex in their vertex lists, so that each meta-cell has self-contained vertex and cell lists. We store the meta-cells, one after another, in disk. The purpose of meta-intervals for a meta-cell is analogous to that of interval for a cell: a meta-cell is active, i.e., intersected by the isosurface of q, if and only if one of its meta-intervals contains q. Intuitively, we could just take the minimum and maximum scalar values among the vertices to define the meta-interval (as cell intervals), but such big range would contain gaps in which no cell interval lies. Therefore, we break such big range into pieces, each a metainterval, by the gaps. Formally, we define the meta-intervals of a meta-cell as the connected components among the intervals of the cells in that meta-cell. With this definition, searching active metacells amounts to performing stabbing queries on the meta-intervals. The query pipeline of our overall algorithm is shown in <ref type="figure" target="#fig_0">Fig. 2</ref>. We have the following steps:</p><p>(1) Find all meta-intervals (and the corresponding meta-cell ID's) containing q, by querying the binary-blocked I/O interval tree in disk.</p><p>(2) (Internally) sort the reported meta-cell ID's. This makes the subsequent disk reads for active meta-cells sequential (except for skipping inactive meta-cells), and minimizes the disk-head movements.</p><p>(3) For each active meta-cell, read it from disk to main memory, identify active cells and compute isosurface triangles, throw away the current meta-cell from main memory and repeat the process for the next active meta-cell. At the end, patch the generated triangles and perform the remaining operations in the generation phase to generate and display the isosurface.</p><p>Now we argue that in step (3) the pointer references in disk to read meta-cells are efficient, i.e., there are many active cells in an active meta-cell. Intuitively, by the way we construct the metacells, we can think of each meta-cell as a cube, with roughly the same number of cells in each dimension. Also, by the spatial coherence of an isosurface, usually there are not many meta-cells that  are cut only through corners by the isosurface. Thus by a dimension argument, if an active meta-cell has C cells, for most times the isosurface cuts through C 2=3 cells. This is similar to the argument that usually there are N 2=3 active cells in an N-cell volume dataset. Then this means that we read C cells (a whole meta-cell) for every C 2=3 active cells, i.e., we traverse a thickness of C 1=3 layers of cells, for one layer of isosurface. Therefore we read C 1=3 K=B disk blocks for K active cells, which is a factor of C 1=3 from optimal (B is the number of cells fitting in one disk block). Notice that when the size of meta-cells is increased, the number of duplicated vertices is decreased (less vertices in meta-cell boundaries), and the number of meta-intervals is also decreased (less meta-cells), while the number C is increased. Hence we have a trade-off between space and query time, by varying the meta-cell size. Since the major cost in disk reads is in disk-head movements (e.g., reading two disk blocks takes approximately the same time as reading one block, after moving the disk head), we can increase meta-cell sizes while keeping the effect of the factor C 1=3 negligible. (We shall see the actual trade-off between disk space and query time when we present the experimental results in Section 3.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Meta-Cell Computation</head><p>The efficient subdivision of the dataset into meta-cells lies at the heart of our overall isosurface algorithm. The computation is similar to the partition induced by a k-d-tree <ref type="bibr" target="#b5">[6]</ref>, but we do not need to compute the multiple levels. Since direct random access to vertices is very inefficient in disk, we develop a new technique that is I/Oefficient, by essentially performing external sorting a few times. We assume that the input dataset is in a general "index cell set" (ICS) format, i.e., there is a list of vertices, each containing its x-, y-, zand scalar values, and a list of cells, each containing pointers to its vertices in the vertex list. We want to partition the dataset into H 3 meta-cells, where H is a parameter we can adjust to vary the metacell sizes, usually several disk blocks. The final output of meta-cell computation is a single file that contains all meta-cells, one after another, each an independent ICS file (i.e., the pointer references from cells of a meta-cell are within the meta-cell). We also produce meta-intervals for each meta-cell.</p><p>For simplicity, we assume that the input cell list contains cells of the same type (e.g., tetrahedral cells). If this is not the case, we can first scan the cell list and put different types of cells into different cell lists. In the following, we refer to meta-cell ID's as numbers 0; 1; to number the meta-cells; we refer to them as pointers to the meta-cell positions in disk, as we previously do, only after the meta-cell computation is complete. Our meta-cell computation consists of the following steps. 1. Partition vertices into clusters of equal size. This is the key step in constructing meta-cells. We use each resulting cluster to define a meta-cell, whose vertices are those in the cluster, plus some duplicated vertices to be constructed later. Observe that meta-cells may differ dramatically in their volumes, but their numbers of vertices are roughly the same. The partitioning method is very simple. We first externally sort all vertices by the x-values, and partition them into H consecutive chunks. Then, for each such chunk, we externally sort its vertices by the y-values, and partition them into H chunks. Finally, we repeat the process for each refined chunk, except that we externally sort the vertices by the z-values. We take the final chunks as clusters. Clearly, each cluster has spatially neighboring vertices. The computing cost is bounded by three passes of external sorting. This step actually assigns vertices to meta-cells.</p><p>We produce a vertex-assignment list with entries v id ; m id , indicating that vertex v id is assigned to meta-cell m id .</p><p>2. Assign cells to meta-cells and duplicate vertices. Our assignment of cells to meta-cells attempts to minimize the wasted space. The basic coverage criterion is to see how a cell's vertices have been mapped to meta-cells. A cell whose vertices all belong to the same meta-cell is assigned to that meta-cell. Otherwise, the cell is in the boundary, and a simple voting scheme is used: the metacell that contains the most vertices owns that cell, and the missing vertices of the cell have to be duplicated and inserted to this metacell. We break ties arbitrarily. In order to determine this assignment, we need to obtain for each cell, the destination meta-cells of its vertices. For in-core computation, this is easily computed by a pointer de-reference. But the out-of-core counterpart of this computation is not so simple. Our basic operation is the join operation (commonly used in database), using the vertex ID as the key, in both the cell list and the vertex-assignment list. The join operation can be performed I/O-efficiently, by externally sorting both lists by the key, and scanning through both lists to fill in the information needed <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9]</ref>. For example, to fill in the destination meta-cell ID of the first vertex in each cell, we sort the cell records in the cell list by the vertex ID's of their first vertices, so that the first group contains the cells whose first vertices are vertex 1, the second group contains the cells whose first vertices are vertex 2, and so on. We also sort the vertex-assignment list by vertex ID, so that we know the destination meta-cell ID's of vertex 1, of vertex 2, etc., in that sequential order. We then scan through both lists and fill in the destination meta-cell ID of the first vertex, for each cell in the cell list. We need to perform as many join operations as the degree of the cell (i.e., for tetrahedra we need to perform four joins). Once all the vertex-to-meta-cell assignments have been propagated to the cell list, a single scan is enough not only to assign cells to meta-cells, but also to decide which vertices to duplicate and insert to which meta-cells. For the latter, we produce a vertex-duplication list with entries v id ; m id , indicating that vertex v id has to be duplicated and inserted to meta-cell m id .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Compute the vertex and cell lists for each meta-cell.</head><p>To actually duplicate vertices and insert them to appropriate meta-cells, we first need to de-reference the vertex ID's (to obtain the complete vertex information) from the vertex-duplication list. We can do this by using one join operation, using vertex ID as the key, on the original input vertex list and the vertex-duplication list. Now the vertex-duplication list contains for each entry the complete vertex information, together with the ID of the meta-cell to which the vertex must be inserted. We also have a list for assigning cells to meta-cells. To finish the generation of meta-cells, we use a main join operation on these lists, using meta-cell ID as the main key. To avoid possible replications of the same vertex inside a meta-cell, we use vertex ID's as the secondary key during the sorting for the join operation. Finally, we update the vertex pointers for the cells within each meta-cell. This can be easily done since each meta-cell can be kept in the main memory. 4. Compute meta-intervals for each meta-cell. Since each metacell can fit in main memory, this step only involves in-core computation. First, we compute the interval for each cell in the metacell. Then we sort all interval endpoints. We scan through the endpoints, with a counter initialized to 0. A left endpoint encountered increases the counter by 1, and a right endpoint decreases the counter by 1. A "0 ! 1" transition gives the beginning of a new meta-interval, and a "1 ! 0" transition gives the end of the current meta-interval. We can easily see that the computation is correct, and the computing time is bounded by that of internal sorting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Binary-Blocked I/O Interval Tree</head><p>Now we present our binary-blocked I/O interval tree. Since it is a general stabbing-query data structure, we use the general term interval to refer to the underlying intervals or meta-intervals being manipulated. We use unique cell ID's to break a tie between endpoint values. In the case of meta-intervals and meta-cells, it is easy to see that each entry of (endpoint value, meta-cell ID) is distinct.</p><p>We use N to denote the total number of intervals considered, and M and B the numbers of intervals fitting in main memory and in one disk block, respectively. One I/O operation reads or writes one disk block.</p><p>Our interval tree is I/O-optimal in space, query, and preprocessing, and is an extension of the original (main memory, binary) interval tree of <ref type="bibr" target="#b13">[14]</ref>. Our branching factor Bf (i.e., the maximum number of children of an internal node) is increased from 2 to B, to reduce the tree height from Olog 2 N to Olog B N, like B-trees.</p><p>We remark that the previous I/O-optimal interval tree of <ref type="bibr" target="#b2">[3]</ref> also increases Bf (to p B) to make tree height Olog B N, but an additional type of secondary lists is introduced, which potentially increases the space by a factor of 3/2 (originally the binary interval tree has two types of secondary lists). Our tree does not introduce any new type of lists, so is simpler to implement and also is more space-efficient in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Data Structure</head><p>Before describing our binary-blocked I/O interval tree, we first review the original (main memory) interval tree of <ref type="bibr" target="#b13">[14]</ref>. Given a set of N intervals, such interval tree T is defined recursively as follows. If there is only one interval, then the current node r is a leaf containing that interval. Otherwise, node r stores as a key the median value m that partitions the interval endpoints into two slabs, each having the same number of endpoints that are smaller (resp. larger) than m. The intervals that contain m are assigned to node r. The intervals with both endpoints smaller than m are assigned to the left slab; similarly, the intervals with both endpoints larger than m are assigned to the right slab. The left and right subtrees of r are recursively defined as the interval trees on the intervals in the left and right slabs, respectively. In addition, each internal node u of T has two secondary lists: the left list, which stores the intervals assigned to u, sorted in increasing left endpoint values, and the right list, which stores the same set of intervals, sorted in decreasing right endpoint values. It is easy to see that the tree height is Olog 2 N. Also, each interval is assigned to exactly one node, and is stored either twice (when assigned to an internal node) or once (when assigned to a leaf), and thus the overall space is ON.</p><p>In our binary-blocked I/O interval tree, T , each node is one disk block, capable of holding B items. We want to increase the branching factor Bf so that the tree height is Olog B N. The intuition of our method is extremely simple: we block a subtree of the binary interval tree T into one node of T (see <ref type="figure">Fig. 3</ref>). In the following, we refer to the nodes of T as small nodes. We take the branching factor Bf to be B. Then in an internal node of T , there are Bf,1 small nodes, each having a key, a pointer to its left list and a pointer to its right list, where all left and right lists are stored in disk. Now we give a more formal definition of tree T . First, we sort all left endpoints of the N intervals in increasing order from left to right, into set E. We use (meta-)cell ID's to break ties. Set E is used to define the keys in small nodes. Then tree T is recursively defined as follows. If there are no more than B intervals, then the current node u is a leaf node storing all intervals. Otherwise, u is <ref type="figure">Figure 3</ref>: Intuition of binary-blocked I/O interval tree T : each circle is a node in the binary interval tree T, and each rectangle, which blocks a subtree of T, is a node of T . an internal node. We take Bf , 1 median values from E, which partition E into Bf slabs, each with the same number of endpoints.</p><p>We store sorted, in non-decreasing order, these Bf,1 median values in node u, which serve as the keys of the Bf , 1 small nodes in u. We implicitly build a subtree of T on these Bf , 1 small nodes, by a binary-search scheme: the root key is the median of the Bf , 1 sorted keys, the key of the left child of the root is the median of the lower half keys, and the right-child key is the median of the upper half keys, and so on. Now consider the intervals. The intervals that contain one or more keys of u are assigned to u. In fact, each such interval I is assigned to the highest small node (in the subtree in u) whose key is contained in I; we store I in the corresponding left and right lists of that small node. For the remaining intervals, each has both endpoints in the same slab and is assigned to that slab. We recursively define the Bf subtrees of node u as the binary-blocked I/O interval trees on the intervals in the Bf slabs.</p><p>Notice that with the above binary-search scheme for implicitly tree T has height Olog B N, and the overall space complexity is optimal ON=B disk blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Query Algorithm</head><p>Our query algorithm for the binary-blocked I/O interval tree T is very simple and mimics the query algorithm for the binary interval tree T. Given a query point q, we perform the following recursive process starting from the root of T . For the current node u, we read u from disk. Now consider the subtree Tu implicitly built on the small nodes in u by the binary-search scheme. Using the same binary-search scheme, we follow a root-to-leaf path in Tu. Let r be the current small node of Tu being visited, with key value m. If q = m, then we report all intervals in the left (or equivalently, right) list of r and stop. If q m , we scan and report the intervals in the left list of r, until the first interval with left endpoint larger than q is encountered. Recall that the left lists are sorted by increasing left endpoint values. After that, we proceed to the left child of r in Tu. Similarly, if q m, we scan and report the intervals in the right list of r, until the first interval with right endpoint smaller than q is encountered. Then we proceed to the right child of r in Tu. At the end, if q is not equal to any key in Tu, the binary search on the Bf , 1 keys locates q in one of the Bf slabs. We then visit the child node of u in T which corresponds to that slab, and apply the same process recursively. Finally, when we reach a leaf node of T , we check the OB intervals stored to report those that contain q, and stop. Although the tree height is Olog B N, in the worst-case we might need to perform a total of Olog 2 N=B + K=B I/O operations for a query. We can improve this bound to optimal Olog B N + K=B I/O's by using the corner structures <ref type="bibr" target="#b17">[18]</ref>; we omit the details here in order to stay within the page limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Preprocessing Algorithm</head><p>We describe our preprocessing algorithm for building the tree T .</p><p>It is based on the scan and distribute paradigm originated from the distribution sweep I/O technique <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">16]</ref> , as the external sorting bound <ref type="bibr" target="#b0">[1]</ref>, where M is the number of intervals fitting in main memory) by the tree-height conversion method in <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experimental Results and Analysis</head><p>In this section, we attempt to experimentally assess the advantages and shortcomings of our new technique, in particularly as compared to our previous work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. We consider five datasets in our study. Four of them were used in our previous papers <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, and a new, larger dataset, Cyl3 with about 5.8M cells has been added to our test set. <ref type="table" target="#tab_3">Table 1</ref> summarize their properties.</p><p>Our experimental set-up is similar to the one we used in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. Our benchmark machine is an off-the-shelf PC: a Pentium Pro, 200MHz with 128M of RAM, and 768M of swap space. Using Linux, we booted the machine in two different configurations, with 64M and 128M of main memory. For preprocessing, we used the machine with only 64M of main memory, and for computing the isosurfaces we varied the amount of main memory. Because of the usage of the operating system and X-windows, we estimate that only half to two thirds of main memory was actually available for computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Meta-cell Generation</head><p>Computing the meta-cells is a core operation of our technique, and one of the main differences between our new method and <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. Meta-cell generation is basically divided into five parts: (1) normalizing the original file, which involves separating the vertices and each type of cells into their own files, (2) mapping the vertices into meta-cells, (3) mapping the cells into meta-cells, (4) completing the meta-cell information and writing to the meta-cell file, and <ref type="formula">5</ref>computing the meta-intervals used for indexing. As can be seen in <ref type="table">Tables 2 and 3</ref>, meta-cell generation can be expensive, in particular for large datasets, such as Cyl3. The main reason for this is that we do not assume any kind of pre-determined spatial coherence in our input, forcing us to perform several external sorts on different keys, over very large files.</p><p>There are several ways to make this faster. The most obvious would be to use a larger machine with enough main memory for the computation. In this case, the geometric hashing we are using becomes trivial, and clearly can be performed very efficiently. A less obvious observation is that due to the fact that we are essentially performing a global geometric hashing operation, given information about the relative positions of the vertices (basically, rough bounding boxes), the computation can be performed more efficiently. For instance, if we already have some meta-cell subdivision, we do not need to recompute another one from scratch, instead it is possible to either refine a coarser subdivision, or join multiple fine subdivisions into coarser ones. We conjecture (though have not tried yet) that we should be able to manage multi-gigabyte scientific datasets computed in distributed memory parallel machines, by running our meta-cell generation on each piece individually, since, in general, they are organized in mostly disjoint chunks of spatially coherent data. <ref type="table">Tables 2 and 3</ref> give some important performance statistics. In <ref type="table">Table 2</ref>, a global view of the performance of our technique can be seen on four different datasets. It is interesting to note that by varying the number of meta-cells, we can effectively control the disk space overhead. In general, the smaller number of cells in a meta-cell, the faster the querying and fetching, and also the more accurate the isosurface search. In <ref type="table">Table 3</ref> we vary the number of meta-cells used for the Delta dataset. This table shows that our algorithm scales well with increasing meta-cell sizes. The most important feature is the linear dependency of the querying accuracy versus the disk space overhead. For example, using a total of 146 meta-cells (at 7% disk overhead), for a given isosurface, we need 3.34s to find the active cells. When using 30,628 meta-cells (at 63% disk overhead), we only need 1.18s to find the correct cells. Basically, the more meta-cells, the more accurate our active-cell searchers, and the less amount of data we need to fetch from disk. 0.35s 0.67s 1.23s 43s <ref type="table">Table 2</ref>: Statistics for preprocessing isosurfaces on different datasets. First, we show the number of meta-cells used for partitioning the dataset, followed by the times for each step of the metacell computation and its total time. Secondly, the original dataset size and the size of the meta-cell file are shown. We also show the average numbers of vertices and of cells per meta-cell, and the overall increase in storage. Finally, we show the size (in bytes) of the BBIO tree and its construction time.</p><p>An interesting point is that the more data fetched, the more work (and main memory usage) for the isosurface generation engine. By paying the 63% disk overhead, we only need to fetch 16% of the dataset into main memory, which is clearly a substantial saving. <ref type="figure">Figs. 4a and 5a</ref> show the bounding boxes of two meta-cell decompositions on the same dataset. The dataset used was a low resolution version of the dataset Cyl3 used in <ref type="table">Tables 2 and 4</ref> to avoid cluttering. One can see from the two figures that our algorithm samples the higher-resolution areas with more meta-cells, while using lower numbers of meta-cells in areas with less details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Meta-cell Indexing</head><p>The number of meta-intervals generated is directly proportional to the number of meta-cells. The size of the interval tree (denoted by BBIO tree) increases when the dataset gets larger (e.g., for the Cyl3 dataset shown in <ref type="table">Table 2</ref> is 1.7M), and may be well beyond the main memory size for larger dataset. This is the major reason why we need the BBIO tree, to ensure the scalability for a large number of meta-intervals being indexed. In addition, as opposed to in-core indexing structures, we need not spend the time to build/load the tree in main memory every time the process starts to run. <ref type="table">Tables 2 and 3</ref> also contain information related to the construction of the trees, and their respective sizes. Having the indexing data structure separated from the meta-cells is important, since in several applications multiple indexing structures can point to the same set of meta-cells. For instance, in handling time-varying datasets, one can keep a single copy of the geometric data (in the meta-cells), and have multiple BBIO trees for indexing different time steps. <ref type="table">Table 3</ref> already presents some limited querying information that demonstrates the effectiveness of the meta-cell blocking as a function of the disk space overhead. Particularly interesting are the data given in <ref type="table">Table 3</ref>, which shows how the isosurface extraction cost changes with meta-cell sizes. As the number of meta-cells increases (and the disk space overhead also increases due to more vertex replications), the query time decreases. This shows that our technique provides a smooth trade-off between disk space overhead and querying performance. A visual representation of this effect can be seen from <ref type="figure">Figs. 4b and 5b</ref>, which show the bounding boxes of the fetched (i.e., active) meta-cells during the query of the isosurface with value 0.0623775 in the Cyl dataset. <ref type="figure">Figs. 4c and 5c</ref> show the actual isosurfaces superimposed to the active meta-cells. Even for this down-sampled dataset and the coarse meta-cells, one can see the effect of more meta-cells in culling away larger portions of the dataset not containing the isosurface. Note the difference between Figs. 4b and 5b in the middle of the dataset where the cells do not get touched. As the number of meta-cells increases, the active meta-cells are refined and resemble the isosurface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Isosurface Extraction Queries</head><p>It is important to study the overall performance of the isosurface extraction query pipeline. Ideally, we would like to compare four different techniques: (1) the plain Vtk <ref type="bibr" target="#b21">[22]</ref> pipeline; (2) an outputsensitive in-core isosurface algorithm (such as the one presented in <ref type="bibr" target="#b11">[12]</ref>); (3) our previous work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>; (4) our new algorithm. Unfortunately, we do not have (2) y . With respect to the comparisons with (3) [10], we will not be able to compare for the Cyl3 dataset, since we would need over 2.4GB of disk to perform the preprocessing (and several hours). <ref type="table">Table 4</ref> summarizes our benchmarks. Points worth noting:</p><p>Our previous technique, ioQuery <ref type="bibr" target="#b9">[10]</ref>, performs better than both mcQuery (our new code) and vtkIso (the pure Vtk code) in all cases. This is not really a surprise, since ioQuery performs an exact search, only bringing active cells into main memory. Thus, it does not waste either disk bandwidth or main memory space. Unfortunately, as we pointed out before, ioQuery is not practical, since it uses about 8 times as much disk space as the original dataset to keep the search structure, and it needs 16 times as much disk scratch space for preprocessing.</p><p>Our new querying code, mcQuery, performs better than vtkIso for most examples. In particular, for Cyl3, it is over 20 times faster than pure Vtk, and even in cases where there is enough main memory such as for the Delta dataset, with only 63% disk overhead, it is about five times faster than Vtk. In fact, in some cases (such as for Post and Delta), we are able to finish querying while Vtk is still reading the dataset.</p><p>One last note about the implementation. Some might be wondering how come Vtk needs so much main memory to compute isosurfaces. In fact, it might require two to three times as much main memory as the original dataset. Without further study, we can only speculate. There are several main memory overheads for isosurface calculation, besides the isosurface itself. For instance, one <ref type="bibr">y</ref> We believe techniques such as <ref type="bibr" target="#b11">[12]</ref> have active cell search times at least comparable to the ones we have, but in general, these other techniques need the whole dataset to be loaded into main memory, and the preprocessing has to be done each time the dataset is loaded. Also, the indexing data structures increase the amount of main memory needed (if only by a small amount), thus making these methods less likely to be used for very large datasets.  <ref type="table">Table 3</ref>: Statistics for preprocessing and querying isosurfaces on the Delta dataset (original binary file size 19.4M). The entries for preprocessing are as defined in <ref type="table">Table 2</ref>. We also show the performance of a representative isosurface query with 64M of RAM: number of active cells ("act"), number of cells fetched ("fetch"), number of fetched (i.e., active) meta-cells ("mc"), the ratio between the numbers of active and overall meta-cells ("Perc. (mc)"), and finally the time for finding the active cells (the time for actual isosurface generation is not included).</p><p>is the Vtk "locator" class, which is used to avoid outputting multiple vertices for the same spatial location.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions</head><p>In this paper we present a new out-of-core algorithm for outputsensitive isosurface extraction. In our tests, our algorithm has shown to be both robust and effective in optimizing isosurface queries. Regardless of the size of the dataset, our techniques provide a cost-effective method to speed up isosurface extraction from volume data. The actual code can be made much faster by fine tuning the disk I/O. This is an interesting but hard and time-consuming task, and might often be non-portable across platforms, since the interplay among the operating system, the algorithms, and the disk is non-trivial to optimize. We believe that a substantial speed-up can be achieved by optimizing the external sorting and the file copying primitives.</p><p>In the process, we developed two new techniques of independent interest. First, our binary-blocked I/O interval is easier to implement, and uses less disk space than the existing external-memory stabbing-query data structures. Secondly, the technique we use to compute the meta-cells has a wider applicability in the preprocessing of general cell structures larger than main memory. For example, one could use our technique to break polyhedral surfaces larger than main memory into spatially coherent sections for simplification, or to break large volumetric grids into smaller ones for rendering purposes.</p><p>We believe this work brings efficient out-of-core isosurface techniques closer to practicality. One remaining challenge is to improve the preprocessing times for large datasets, which, even though is much lower than the ones presented in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, is still fairly costly.  <ref type="table">Table 4</ref>: Statistics for querying isosurfaces on different datasets using 3 different codes: mcQuery, vtkIso, and ioQuery, under two different main memory configurations (64M and 128M). On the top, we specify the datasets, the total number of meta-cells, the meta-cell disk space overhead, the isosurface value being queried, the number of active cells for the particular isovalue, the percentage of the dataset that was fetched during querying, and the actual number of fetched cells. We highlight in bold the overall isosurface generation time for each run. Below we break the times up into its major components. "Iso comp." is always the time to actually compute the isosurface (depending on the method, the number of cells being used for the computation varies). For mcQuery, BBIO is the time it takes to query the BBIO tree; Disk I/O is the time to bring the active meta-cells into main memory. For vtkIso, Disk I/O is the time to read the dataset from disk. For ioQuery, Disk I/O is the time to search (and fetch at the same time) the active cells from disk. Note that mcQuery reduces the disk space overhead of ioQuery by more than one order of magnitude. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>The query pipeline of our isosurface technique.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>building a (sub)tree on the keys stored in an internal node u, Bf does not need to be a power of 2 -we can make Bf as large as possible, as long as the Bf , 1 keys, the 2Bf , 1 pointers to the left and right lists, and the Bf pointers to the children, etc., can all fit into one disk block. As a comparison, in the I/O interval tree of<ref type="bibr" target="#b2">[3]</ref>, each internal node has Bf left lists, Bf right lists, and additional Bf 2 multi lists, and thus Bf is taken as p B. Also, an interval can be stored up to three times. It is easy to see that our</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Illustration for the distribution of 6 3 meta-cells: (a) the bounding boxes of the meta-cells; (b) the bounding boxes of the fetched meta-cells during a query; (c) the fetched meta-cells superimposed with the isosurface. Illustration for the distribution of 10 3 meta-cells in the same dataset as inFig. 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>. Our algorithm follows the definition of T given in Section 2.2.1. In the first phase, we sort (using external sorting) all N input intervals in increasing left endpoint values from left to right, into a set S. We use (meta-)cell ID's to break a tie. We also copy the left endpoints, in the same sorted order, from S to another set E. The set E is used to define median values to partition E into slabs throughout the process.The second phase is a recursive process. If there are no more than B intervals, then we make the current node u a leaf, store all intervals in u and stop. Otherwise, node u is an internal node. We first take the Bf , 1 median values from E that partition E into Bf slabs, each containing the same number of endpoints. We store We perform this binary search on these keys to find the highest small node r whose key is contained in I, in which case we assign I to small node r (and also to the current node u), by appending the small node ID of r to I and putting it to the temporary list for node u, or to find that no such small node exists and both endpoints of I lie in the same slab, in which case we distribute I to that slab by putting I to the corresponding temporary list. When all intervals in S are scanned and distributed, each temporary list has all its intervals, automatically sorted in increasing left-endpoint values. Now we sort the intervals belonging to node u by small node ID as the first key and the left-endpoint value as the second key, in increasing order, so that intervals assigned to the same small node are put together, sorted in increasing left-endpoint values. We read these intervals to set up the left lists of all small nodes in u. Then we copy each such left list to its corresponding right list, and sort the right list by decreasing right-endpoint values. The corner structure for node u, if we want to construct, can be built at this point. This completes the construction of node u. Finally, we perform the process recursively on each of the Bf slabs, using the intervals in the corresponding temporary list as input, to build each subtree of node u. remark that in the above scan and distribute process, instead of keeping all intervals assigned to the current node u in one temporary list, we could maintain Bf , 1 temporary lists for the Bf , 1 small nodes of u. This would eliminate the subsequent sorting by small node ID's (which is used to re-distribute the intervals of u</figDesc><table><row><cell>We into individual small nodes). But for the actual implementation,</cell></row><row><cell>our method is used to address the system issue that a process can-</cell></row><row><cell>not open too many files simultaneously, while avoiding a blow-up</cell></row><row><cell>in disk scratch space. It can be shown that the overall preprocess-ing takes nearly optimal O N B log B N I/O's. We can also make the bound optimal (O N B log M B N B</cell></row></table><note>sorted in u, in non-decreasing order from left to right, these median values as the keys in the small nodes of u. We now scan all intervals (from S) to distribute them to node u or to one of the Bf slabs. We maintain a temporary list for node u, and also a temporary list for each of the Bf slabs. For each temporary list, we keep one block in the main memory as a buffer, and keep the remaining blocks in disk. Each time an interval is distribute to node u or to a slab, we put that interval to the corresponding buffer; when a buffer is full, it is written to the corresponding list in disk. The distribution of each interval I is carried out by the binary-search scheme described in Section 2.2.1, which implicitly defines a balanced binary tree Tu on the Bf , 1 keys and the corresponding small nodes in u.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>A list of the datasets used for testing. Original size is the file size as an ASCII ".scalar" or ".vtk" file.</figDesc><table><row><cell>Name</cell><cell cols="4"># of Cells Original Size Binary Size</cell></row><row><cell>Blunt Fin</cell><cell>187K</cell><cell cols="2">5.8M</cell><cell>3.7M</cell></row><row><cell>Comb. Chamber</cell><cell>215K</cell><cell cols="2">6.8M</cell><cell>4.2M</cell></row><row><cell>Liquid Oxygen Post</cell><cell>513K</cell><cell cols="2">16.4M</cell><cell>10M</cell></row><row><cell>Delta Wing</cell><cell>1M</cell><cell cols="2">33.8M</cell><cell>19.4M</cell></row><row><cell>Cyl3</cell><cell>5.8M</cell><cell cols="2">337M</cell><cell>152M</cell></row><row><cell></cell><cell>Blunt</cell><cell>Chamber</cell><cell>Post</cell><cell>Cyl3</cell></row><row><cell># of meta-cells</cell><cell>737</cell><cell>1009</cell><cell>1870</cell><cell>27896</cell></row><row><cell>Normalization</cell><cell>3.1s</cell><cell>3.5s</cell><cell>8.8s</cell><cell>158s</cell></row><row><cell>Vertex Map</cell><cell>2.8s</cell><cell>3.6s</cell><cell>8.3s</cell><cell>382s</cell></row><row><cell>Cell Map</cell><cell>19s</cell><cell>24.1s</cell><cell>58.1s</cell><cell>783s</cell></row><row><cell>Meta-Cell Info</cell><cell>20.8s</cell><cell>24s</cell><cell>67.8s</cell><cell>1179s</cell></row><row><cell>Meta-Intervals</cell><cell>4.2s</cell><cell>4.8s</cell><cell>11.7s</cell><cell>147s</cell></row><row><cell>Total</cell><cell>50s</cell><cell>60s</cell><cell cols="2">154.8s 3652s</cell></row><row><cell>Original Size</cell><cell>3.65M</cell><cell>4.19M</cell><cell>10M</cell><cell>152M</cell></row><row><cell>Meta-Cell Size</cell><cell>4.39M</cell><cell>5M</cell><cell cols="2">12.2M 271M</cell></row><row><cell>Avg Vertex</cell><cell>118.1</cell><cell>102.1</cell><cell>133.2</cell><cell>399</cell></row><row><cell>Avg Cell</cell><cell>254.2</cell><cell>213.1</cell><cell>274.5</cell><cell>208</cell></row><row><cell>Increase</cell><cell>20%</cell><cell>21%</cell><cell>22%</cell><cell>78%</cell></row><row><cell>BBIO Tree (size)</cell><cell>29K</cell><cell>28K</cell><cell>84K</cell><cell>1.7M</cell></row><row><cell>BBIO Tree (time)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>8M 21.5M 22.6M 23.7M 24.6M 26.7M 31.7M</figDesc><table><row><cell># of meta-cells</cell><cell>146</cell><cell>361</cell><cell>1100</cell><cell>2364</cell><cell>3600</cell><cell>8400</cell><cell>30628</cell></row><row><cell>Total Time</cell><cell>618s</cell><cell>427.4s</cell><cell>346s</cell><cell>331s</cell><cell>331s</cell><cell>347s</cell><cell>376s</cell></row><row><cell cols="2">Meta-Cell Size 20.Avg Vertex 2032.8</cell><cell>940.1</cell><cell>370.4</cell><cell>202.8</cell><cell>148.2</cell><cell>79.3</cell><cell>31.4</cell></row><row><cell>Avg Cell</cell><cell cols="2">6888.1 2785.8</cell><cell>914.2</cell><cell>425.4</cell><cell>279.35</cell><cell>119.7</cell><cell>32.8</cell></row><row><cell>Increase</cell><cell>7%</cell><cell>10%</cell><cell>16%</cell><cell>22%</cell><cell cols="2">26.9% 37.9%</cell><cell>63%</cell></row><row><cell>BBIO Tree (size)</cell><cell>4K</cell><cell>16K</cell><cell>48K</cell><cell>112K</cell><cell>168K</cell><cell>640K</cell><cell>1.7M</cell></row><row><cell>BBIO Tree (time)</cell><cell>0.42s</cell><cell>0.61s</cell><cell>1.51s</cell><cell>1.94s</cell><cell>3.78s</cell><cell>13.1s</cell><cell>31.9s</cell></row><row><cell>Query (act)</cell><cell>49.3K</cell><cell>49.3K</cell><cell>49.3K</cell><cell>49.3K</cell><cell>49.3K</cell><cell>49.3K</cell><cell>49.3K</cell></row><row><cell>Query (fetch)</cell><cell>704K</cell><cell>560K</cell><cell>418K</cell><cell>345K</cell><cell>320K</cell><cell>247K</cell><cell>167K</cell></row><row><cell>Query (mc)</cell><cell>87</cell><cell>189</cell><cell>414</cell><cell>754</cell><cell>1094</cell><cell>1996</cell><cell>4923</cell></row><row><cell>Perc. (mc)</cell><cell>59%</cell><cell>52%</cell><cell>37%</cell><cell>31%</cell><cell>30%</cell><cell>23%</cell><cell>16%</cell></row><row><cell>Query Time</cell><cell>3.34s</cell><cell>2.76s</cell><cell>2.09s</cell><cell>1.82s</cell><cell>1.73s</cell><cell>1.5s</cell><cell>1.18s</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Yi-Jen Chiang was supported in part by NSF Grant DMS-9312098. The work of Cl√°udio T. Silva was partially supported by Sandia National Labs and the Dept. of Energy Mathematics, Information, and Computer Science Office, and by NSF Grant CDA-9626370.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The input/output complexity of sorting and related problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1116" to="1127" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Theory and practice of I/O-efficient algorithms for multidimensional batched searching problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Procopiuc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramaswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Suel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symp. on Discrete Algorithms</title>
		<meeting>ACM-SIAM Symp. on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Optimal interval management in external memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Foundations of Comp. Sci</title>
		<meeting>IEEE Foundations of Comp. Sci</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="560" to="569" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fast isocontouring for improved interactivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1996 Volume Visualization Symposium</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="39" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast isocontouring for structured and unstructured meshes in any dimension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Late Breaking Hop Topics</title>
		<meeting>Late Breaking Hop Topics</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="25" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="509" to="517" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Dynamic and I/O-efficient algorithms for computational geometry and graph problems: theoretical and experimental results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<idno>CS-95-27</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Dept. Computer Science, Brown University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Experiments on the practical I/O efficiency of geometric algorithms: Distribution sweep vs. plane sweep</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry: Theory and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="211" to="236" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">External-memory graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symp. on Discrete Algorithms</title>
		<meeting>ACM-SIAM Symp. on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="139" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">I/O optimal isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="293" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Isosurface extraction in large scientific visualization applications using the I/O-filter technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
		<respStmt>
			<orgName>University at Stony Brook</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal isosurface extraction from irregular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Volume Visualization Symposium</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Application-controlled demand paging for out-of-core visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A new approach to rectangle intersections, Part I. Internat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Math</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="209" to="219" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Database management for models larger than main memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>S√©quin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Khorramabadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presence: Teleoperators and Virtual Environments</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Externalmemory computational geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-J</forename><surname>Tsay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Foundations of Comp. Sci</title>
		<imprint>
			<biblScope unit="page" from="714" to="723" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automatic isosurface propagation using an extrema graph and sorted boundary cell lists</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="319" to="327" />
			<date type="published" when="1995-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Indexing for data models with constraints and classes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramaswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Database Sys</title>
		<meeting>ACM Symp. on Principles of Database Sys</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="233" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="84" />
			<date type="published" when="1996-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;87</title>
		<meeting>SIGGRAPH &apos;87</meeting>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Rendering complex scenes with memory-coherent ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matt</forename><surname>Pharr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Kolb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reid</forename><surname>Gershbein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;97</title>
		<meeting>SIGGRAPH &apos;97</meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="101" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<title level="m">The Visualization Toolkit</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Isosurfacing in span space with utmost efficiency (ISSUE)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Partitioning and ordering large radiosity computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;94</title>
		<meeting>SIGGRAPH &apos;94</meeting>
		<imprint>
			<date type="published" when="1994-07" />
			<biblScope unit="page" from="443" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Out-of-core streamline visualization on large unstructured meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Ueng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sikorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="370" to="380" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Contour trees and small seed sets for isosurface traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Oostrum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Proc. ACM Symp. on Comput. Geom</title>
		<imprint>
			<biblScope unit="page" from="212" to="220" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">I/O-efficient scientific computation using TPIE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Parallel and Distributed Computing</title>
		<meeting>IEEE Symp. on Parallel and Distributed Computing</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics</title>
		<meeting><address><addrLine>San Diego Workshop on</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-11" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="57" to="62" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
