<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interpolation of Triangle Hierarchies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Axel</forename><surname>Friedrich</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University Berlin</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Polthier</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University Berlin</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Schmies</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University Berlin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Interpolation of Triangle Hierarchies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling -Surface and object representations-</term>
					<term>I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling -Hierarchy and geometric transformations-</term>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques -Graphics data structures and data types-</term>
					<term>I.3.7 [Computer Graphics]: Threedimensional graphics and realism -animation- animation, shape interpolation, adaptive refinement, level-of-detail, multiresolutional representation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We consider interpolation between keyframe hierarchies. We impose a set of weak constraints that allows smooth interpolation between two keyframe hierarchies in an animation or, more generally, allows the interpolation in an n parameter family of hierarchies. We use hierarchical triangulations obtained by the Rivara element bisection algorithm and impose a weak compatibility constraint on the set of root elements of all keyframe hierarchies. We show that the introduced constraints are rather weak. The strength of our approach is that the interpolation works in the class of conforming triangulations and simplifies the task of finding the intermediate hierarchy, which is the union of the two (, or more,) keyframe hierarchies involved in the interpolation process. This allows for an efficient generation of the intermediate connectivity and additionally ensures that the intermediate hierarchy is again a conforming hierarchy satisfying the same constraints.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Surfaces in animation often change their shape in time. If there is no functional description of the deformation available, one often uses the keyframe technique to describe the animation. Here a surface is stored at a finite set of key-times, and in-between surfaces are computed by interpolating between adjacent keyframes. In the special case that all keyframe surfaces have the same underlying simplicial complex, the interpolation task reduces to the simple linear interpolation between corresponding pairs of vertices, or interpolation of higher polynomial order if more keyframes are considered.</p><p>The interpolation task becomes more delicate if the keyframe surfaces are allowed to have different underlying simplicial complexes. In our discussion we restrict all surfaces of an animation to be topologically equivalent, i.e. they have the same genus and boundary curves. Nevertheless, our task remains to interpolate between topologically equivalent -but differently discretized -surfaces. Such surfaces occur naturally, in numerics when an initial surface evolves by minimizing an energy functional and it is adaptively refined and coarsened after each time step. These surfaces also arise in flow visualization, where an initial test ball is inserted in the flow and after some time-steps the ball strongly deforms, requiring an adaptive change of its mesh. In both cases one obtains a new keyframe object after each time-step, and interpolation be-Sonderforschungsbereich 288, Technical University Berlin, axel, konrad, tn13 @sfb288.math.tu-berlin.de tween keys with different meshes is required for slow-motion playback. We consider hierarchies of triangles obtained by an element bisection algorithm, rather than by vertex split/edge collapse methods, and impose the following two constraints: firstly, the bisection scheme in each hierarchy follows the rules of Rivara <ref type="bibr" target="#b13">[14]</ref> and, secondly, a certain correspondence between the root elements of all hierarchies is required. These assumptions are rather weak, especially since it is only the second constraint which requires an adjustment between different hierarchies. After this initial adjustment, each keyframe hierarchy may be locally refined and coarsened depending only on its own error criteria without any reference to the other hierarchies of the family. The compatibility of different meshes follows from the Rivara bisection method.</p><p>Instead of using the Rivara bisection method, one might try to use a 4-1 split as subdivision rule. After a local refinement the 4-1 split must be accompanied by a process called conformal closure to remove hanging vertices, e.g. by introducing so-called green edges <ref type="bibr" target="#b0">[1]</ref>. These green edges are responsible for case distinctions and require further subdivisions when interpolating between different hierarchies. These tasks can be handled, but the effort increases when interpolating in multi-parameter families.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Review</head><p>Triangle mesh as a simplicial complex In computer graphics and numerics a variety of different triangle meshes are used. We restrict ourselves to conforming triangulations: a triangle is not allowed to have a vertex of another triangle in the interior of one of its edges. This avoids discontinuity problems in the shape and so-called hanging nodes, vertices which are required to lie on an edge. It is not essential to constrain to conforming triangulations, but it avoids a number of unwieldy distinctions related to hanging nodes. Further, we restrict our discussion to piecewise linear meshes although piecewise "higher order" triangular meshes would also work.</p><p>In our concept the interpolation property between two different surfaces depends on their underlying topological simplicial complexes rather than on the actual geometric shapes. It is important to distinguish between the topology of the mesh, i.e. the combinatorics, and the geometric position of the vertices. Such a distinction is also essential in mesh optimization algorithms, see <ref type="bibr" target="#b9">[10]</ref>, where the same shape is equipped with different topological meshes.</p><p>Formally, a triangular mesh T has the topology of an abstract simplicial complex K combined with a geometric realization. The latter is uniquely determined by a set of geometric vertices</p><formula xml:id="formula_0">V v 1 v m 3</formula><p>, and we can identify T with the pair K V . The simplicial complex K formally represents the connectivity of the mesh. It is given by a finite set of abstract vertices and a finite set of subsets S, called simplices, representing the vertices, edges, and triangles of the mesh. Further it is required that if S is a simplex, then every subset is also a simplex S. Each abstract n simplex S containing n 1 abstract vertices has a topological realization as the standard simplex e 1 e n 1 n 1 , the convex hull of the unit vectors e 1 e n 1 in n 1 .</p><p>A geometric realization of an abstract simplicial complex K V is uniquely given by the set of geometric vertices V and a set V of affine maps :</p><formula xml:id="formula_1">convexHull v i 1 v i n 1 3</formula><p>for each abstract simplex S with</p><formula xml:id="formula_2">i 1 i n 1 .</formula><p>In the same way as in <ref type="bibr" target="#b9">[10]</ref> we denote the geometric realization by V to emphasize that it is fully specified by the set of geometric vertices V .</p><p>If two, or more, abstract triangles share a common edge, they are called adjacent or neighbours. An edge belonging to only one triangle is part of the boundary. The above material can be found in any text book on algebraic topology, one source is the recent introduction by Bloch <ref type="bibr" target="#b2">[3]</ref>.</p><p>Bisection method of Rivara Refinement and coarsening algorithms have a long tradition in numerics and computer graphics, and some can be used to generate hierarchical data representations where each child triangle is combinatorially a subset of its parent. Since we consider curved surfaces in <ref type="bibr" target="#b2">3</ref> , it is essential to maintain the distinction between the simplicial combinatorics and the geometric realization: if we bisect a triangle to obtain two children, then combinatorially the two children are considered as subsets of its parent, but in the geometric realization the children need not be part of its parent triangle.</p><p>There exist different types of hierarchical triangulations, and a good overview and formal concept are given in DeFloriani and Puppo <ref type="bibr" target="#b5">[6]</ref>. The concept of vertex-based hierarchies is described in detail in Hoppe's papers <ref type="bibr" target="#b7">[8]</ref> and <ref type="bibr" target="#b8">[9]</ref>. In numerics, it is essential to ensure stability of a sequence of triangulations or a hierarchical triangulation, i.e. to bound the angles inside all triangles uniformly from below. In visualization, small angles may also disturb the visual perception since they sometimes allow, the element normals to vary heavily in the neighbourhood of such a degenerate triangle.</p><p>The bisection algorithm of Rivara <ref type="bibr" target="#b13">[14]</ref> addresses the problem of how to locally refine a conforming triangulation to a new conforming triangulation and, additionally, of how to ensure that all angles in subsequently refined triangulations are greater than or equal to half of the smallest angle in the original triangulation. The method leads to nested triangulations and allows smooth transition between different levels of detail. In his original formulation, Rivara bisects a triangle exactly at the longest edge. Bänsch <ref type="bibr" target="#b1">[2]</ref> generalized the method by introducing a formal refinement edge. In each triangle a single edge is marked as refinement edge, i.e. if the triangle is refined, then it is refined by bisecting its refinement edge, and the two child triangles inherit a refinement edge in the manner shown in figure 1. In the simplicial complex an additional vertex is inserted at the midpoint of the refinement edge. Formally, the Rivara algorithm assumes that in a conforming triangulation T each triangle has an arbitrary edge marked as refinement edge. Let T k be a conforming triangulation with a subset of triangles S T marked for refinement, usually according to some local error criteria, then the method consists of the following steps:</p><formula xml:id="formula_3">Rivara Bisection Method (A)</formula><p>1. All marked triangles S are bisected according to the Rivara bisection rule. This produces a (possibly empty) new set of non-conforming triangles.</p><p>2. Mark all non-conforming triangles for refinement; the set is again denoted with S.</p><p>3. If S is not empty, then go to 1. Otherwise, there are no marked triangles and the algorithm stops. The new triangulation is T k 1 .</p><p>When the algorithm stops the new triangulation is conforming. As shown in <ref type="bibr" target="#b1">[2]</ref> the algorithm stops after a finite number of steps since in one pass it inserts at most a single vertex on each edge. This is a fairly rough upper estimate for theoretical purposes -and one can construct such badly behaved examples -but, in practice, the subdivision has only local influence on the triangulation, see <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b13">[14]</ref>. The sequence T k is stable, i.e. all triangle angles are bounded from below by half the minimum triangle edges of the first triangulation T 1 . The method using 4-1 splits, where each parent triangle is decomposed into four similar children, leads to non-conforming vertices if applied locally. Bank and Sherman <ref type="bibr" target="#b0">[1]</ref> introduced so-called green triangles which join a non-conforming vertex with the opposite vertex of the non-conforming triangle, but this approach leads to non-nested triangulations over the green triangles. Rheinbold and Mesztenyi <ref type="bibr" target="#b12">[13]</ref> work with non-conforming grids and, in order to maintain the continuity of the surface over the non-conforming points, they impose the condition that the geometric vertex over each non-conforming point is equal to the values interpolated from the nearby conforming points. However, the appearance of the nonconforming vertices complicates further geometrical or numerical computations because of the additional constraints. The Rivara method (A) is a formalized version of the rule "bisect a triangle at its longest edge," where the method has its origin. We will later use the algorithm to ensure the interpolation property between hierarchies. Further, this algorithm bounds all triangle angles away from zero and therefore it guarantees numerical stability. We also note the following close connection: after applying the Rivara bisection method twice the same vertices as in a 4-1 split of triangles have been introduced (compare <ref type="figure" target="#fig_2">Figure 2)</ref>. Therefore, the Rivara method does not differ too much from the well-used 4-1 rule, but merely eliminates the case distinctions occurring in connection with the conformal closure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Triangle Hierarchy</head><p>A triangle hierarchy is a hierarchical structure of triangular elements where each element has a reference to one parent element, to one child, and to a sibling. The sibling is a child of the same parent and the children shall be produced by subdivision of the parent. Elements with no parents are called root elements, and elements with no children are leaf elements. We assume that the geometric vertices of a hierarchy are given in a global vertex array, and each triangle is determined by three vertex indices. Vertices and elements usually have color and material properties, or carry texture coordinates. Elements may have references to neighbour elements.</p><p>Similar to the situation with meshes, it is essential to maintain the distinction between the topological, i.e. combinatorial, structure of the hierarchy and the geometric shape. For example, when bisecting a parent triangle, from the topological viewpoint we identify the two children with subsets of the parent triangle. But in the geometric view, the additional geometric vertex introduced during bisection (possibly as the midpoint of an edge) may deviate from its original position on the parent edge after a further numerical process.</p><p>The main value of this distinction for interpolation different hierarchies is the existence of a unique relationship between each additional geometric vertex and a topological point in the parent triangle (as given explicitly by the level maps below).</p><p>For our interpolation property of a sequence of key hierarchies, it is essential that each hierarchy is generated using the Rivara bisection algorithm (A). In the implementation, we use a fixed numbering of the three vertex indices of each of the two child triangles (consider figure 4). If the parent p is determined by three indices i j k which refer to the vertices v i , v j , and v k in the global vertex array v, then we assume the two child triangles to reference vertices l k i and l i j in this specific order, where v l is the new vertex inserted during bisection. The specific ordering of the vertices in the children simplifies the location of each child triangle within its parent in the topological mesh. Additionally, the refinement edge of the children is always opposite to the first vertex and, therefore, the information is implicitly given by the vertex ordering. The refinement rule is then reformulated to 'refine a leaf triangle at the edge opposite to its first vertex'. Further, the second and third vertex refer to parent vertices and are therefore implicitly given and do not need to be explicitly referenced. Both observations save memory, but the latter requires recursive calls to obtain the two vertex indices from one of its ancestral triangles. Only the root elements must have references to three vertices in the global vertex array.  <ref type="figure">Figure 4</ref>: The refinement edge used in the Rivara bisection method can be implicitly stored to be opposite to vertex 1.</p><p>For smooth level-of-detail interpolation, it is important to observe that the new geometric vertex on a refined edge can be uniquely associated with the topological midpoint of the original edge in the simplicial complex. Let p be a parent triangle with two children, 1 and 2 , generated by Rivara bisection. </p><formula xml:id="formula_4">v 1 v 2 v 3 . Explicitly, if p b 1 v 1 b 2 v 2 b 3 v 3</formula><p>we use the notation p b b 1 b 2 b 3 for its barycentric representation. Then we can describe the parent-child relationship by two linear maps f i : i p given by</p><formula xml:id="formula_5">f 1 b 1 b 2 b 3 0 1 0 1 2 0 1 1 2 0 0 b 1 b 2 b 3<label>(1)</label></formula><p>and</p><formula xml:id="formula_6">f 2 b 1 b 2 b 3 0 0 1 1 2 0 0 1 2 1 0 b 1 b 2 b 3</formula><p>which relate every point in a child triangle to a point in its parent. This relationship is only on the combinatorial level of the hierarchy connectivity, and it does not mean that, for a geometric point p i , we have f i p p. We observe that we can now relate each triangle n of the hierarchy on level n with a subset of one of the root elements 1 by a recursive application of level functions f , namely f n 1 n : f f n 1 . The computational cost is reduced when using barycentric coordinates -since only division by two and addition are used in each composition. When the composite level function f i n has been computed, it is applied to the geometric x y z coordinate representation of points. The level maps are also used in the computation of the local texture coordinate of a triangle, which are implicitly given via the texture coordinates of the root triangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Interpolating Different Hierarchies</head><p>Animation in computer graphics can be classified by imagebased, see Stekettee and Badler <ref type="bibr" target="#b14">[15]</ref>, and geometry-based methods. Geometry-based methods split further into keyframe animations and into functional (resp. algorithmic) animations. For an overview we refer to the book <ref type="bibr" target="#b10">[11]</ref> and its detailed bibliography.</p><p>We concentrate on the problem of interpolation between keyframe geometries and propose (in section 3.2) some constraints on the geometries. The constraints guarantee a smooth interpolation without the need to remesh during the interpolation process, and then further ensure the freedom for local grid modifications separately on each keyframe. This means that the refinement and coarsening process can be applied to a single keyframe without disturbing the interpolation property.</p><p>Finally, our constraints efficiently allow higher order spline interpolation and interpolation in a multi-parameter family of geometries shown in section 4.1 and 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Review of Keyframe Interpolation</head><p>The keyframe technique is a common and old technique in animation. The animator specifies, say n, key geometries G i at certain time steps t i , i 1 n . If there exists an interpolation method between each two successive pairs G i and G i 1 then a smooth animation is obtained by generating the geometry at time t t i t i 1 on the fly by interpolating between key geometries G i and G i 1 .</p><p>Any geometry mesh can be used in a keyframe animation if there exists an interpolation method, see Burtnyk and Wein <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref> for general shape interpolation techniques. In the simplest case, all key geometries have the same combinatorial mesh and differ only in their vertices. In this case the interpolation object at time t uses the same topological mesh and has vertices v j t <ref type="bibr" target="#b2">3</ref> , j 1 m . They are given by linear combinations</p><formula xml:id="formula_7">v j t 1 t v i j tv i 1 j<label>(2)</label></formula><p>where v i j is the j-th vertex of G i . Here, one can include more key geometries in the interpolation scheme and use polynomial interpolation of higher order in t.</p><p>In many applications the animated geometry varies heavily in time, and one would like to make local adaptions of the mesh on each keyframe geometry based on some local error criteria. But this spoils the simple interpolation technique above.</p><p>In <ref type="bibr" target="#b11">[12]</ref>, Polthier and Rumpf require at each time step t i two topological meshes whose geometric realizations are of the same geometric shape. One connectivity is used to interpolate with the previous keyframe, and the other connectivity for interpolation with the next keyframe. In effect, they associate one connectivity per time interval t i t i 1 , and require two geometric realizations at each time step. Besides the additional storage requirement of two geometric realizations, this approach does not allow further modifications of keyframes since both geometric realizations must be modified in the identical way. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Interpolation Constraints for Hierarchies</head><p>We now specify constraints on the key hierarchies that, firstly, guarantee a smooth interpolation without the need to remesh during the interpolation process, and, secondly, ensure the freedom for local grid modifications separately on each keyframe.</p><p>A family of triangle hierarchies F must fulfill the Interpolation Constraints (B)</p><p>1. The simplicial complex of the root triangles of each hierarchy is the same for all hierarchies in F, i.e. for each pair of hierarchies G H F there exists a bijective simplicial map GH between the set of root triangles.</p><p>2. Each root triangle has a refinement edge, and the simplicial map GH maps each refinement edge to a refinement edge, i.e. the root triangles of all hierarchies are marked in the same way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Each hierarchy is refined using the Rivara Algorithm (A).</head><p>The root triangles can be interpreted as charts of each hierarchy, and condition 1. requires a bijective correspondence between the charts of different hierarchies. Conditions 2. and 3. ensure that hierarchies are automatically refined in a synchronized way without further restricting the refinement process in each hierarchy. Each hierarchy can be refined according to its own error criteria without a posteriori synchronization with the other key hierarchies. Once one has agreed to use the Rivara bisection method, it only remains to ensure properties 1. and 2. for the family F in an initial synchronization step.</p><p>The Rivara bisection algorithm depends only on the initial choice of the refinement edges in the root elements. The subsequent position of the refinement edge in each child and further descendants is predetermined by the algorithm. Therefore we have Theorem 1 If two hierarchies G and H fulfill the interpolation constraints (B) then both of their topological simplicial complexes are a subcomplex of the same infinite complex obtained by infinitely refining the simplicial complex of the root triangles, see <ref type="figure" target="#fig_7">figure 6</ref>.</p><p>Of course, the geometric representations of G and H are usually not identical since their geometric vertices differ.</p><p>In scientific computing a close connection between numerical computations and visualization is desirable. Since the Rivara method is a suitable tool in both fields, hierarchies generated with the Rivara bisection method allow smooth transition of data between numerical and visualization methods. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Interpolating between Hierarchies</head><p>We prove the interpolation property between hierarchies fulfilling the interpolation constraints (B) in a general form which, includes standard keyframe animation with a time parameter t described in section 3.1. Additionally, it covers higher order spline interpolation and interpolation in a multi-parameter family of hierarchies which we will apply in section 4.1 and 4.2. which depends smoothly on b, and its underlying simplicial hierarchy is the union of the simplicial hierarchies of each H i . Further, the interpolated hierarchy H depends smoothly on b and fulfills the same interpolation constraints as the elements of F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 Let</head><p>Proof: For the proof we restrict ourselves to two hierarchies H 1 and H 2 and show how to interpolate between both. First we recall the existence of a bijective simplicial map between the two simplicial complexes formed by the root elements. Since extends to a bijective map between the refinement edges of the root triangles, the Rivara algorithm ensures that the different simplicial hierarchical complexes of H 1 and H 2 are subcomplexes of a theoretically infinite hierarchy which is obtained by infinitely refining the simplicial complex of the root triangles, see theorem 1 and figure <ref type="bibr">6.</ref> It follows that interpolation between the common hierarchical subcomplex C of H 1 and H 2 can be done by simply interpolating corresponding geometric vertices.</p><p>Now assume H 1 is locally more refined than H 2 . Then there exists a situation, as shown in <ref type="figure">figure 7</ref>, where a topological leaf triangle T of the common subhierarchy C is a leaf triangle of the complex of H 2 but not a leaf triangle of H 1 (since H 1 is more refined). Of course, T has different geometric realizations in H 1 and H 2 . <ref type="figure">Figure 7</ref>: The central step when interpolating between two hierarchies.</p><p>All children and further descendants of T in H 1 are associated with a unique position in T via the level maps defined in equation 1.</p><p>The topological subtree generated by T in H 1 can be projected via the level maps onto T and then associated with geometric positions of T in H 2 . Here we make essential use of the distinction between topological and geometric realizations. The level maps operate on the topological realization and give for each geometric vertex v 1 in a leaf triangle L in H 1 the topological, i.e. barycentric, position b 2 in T . From the barycentric coordinates b 2 , with respect to the vertices of T in H 2 , one can immediately compute the geometric position v 2 .</p><p>For the practical interpolation between a geometric leaf triangle L of H 1 and the corresponding subset of the geometric realization of T in H 2 , we need to compute the barycentric coordinates of each vertex of L with respect to T . Let v 1 be one vertex of L with barycentric coordinates b 1 in L. Then we compose a level map f for the transition of L to T and use f to compute the barycentric coordinates b 2 of v 1 with respect to T :</p><formula xml:id="formula_8">b 2 f b 1</formula><p>By weighting the three vertices of the geometric realization of the triangle T in H 2 with b 2 , we obtain the geometric position of v 2 . Now we can interpolate between</p><formula xml:id="formula_9">v 1 H 1 and v 2 H 2 v t 1 t v 1 tv 2</formula><p>Applying the same procedure to the other two vertices of L gives the interpolation for L. It is remarkable that the interpolation hierarchy is not more refined than the union of its keyframe hierarchies.</p><p>The interpolation hierarchy fulfills the same interpolation constraints as the keyframes. This is relevant in the following section for higher order interpolation and for further numerical or graphical processing, e.g. the interpolation hierarchy can immediately be used as a new keyframe. Additionally, each subhierarchy of a hierarchy in F fulfills the interpolation constraints (B) as soon as its leaf triangles form a conforming triangulation. This allows for smooth level-of-detail transitions within a single hierarchy and, by theorem 2, between different levels-of-detail of different hierarchies of F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Higher Order Spline Interpolation</head><p>The interpolation property of theorem 2 immediately allows higher order interpolation in a keyframe animation. Let H i ,..,H i n be n 1 successive keyframe hierarchies fulfilling the interpolation constraints (B), then</p><formula xml:id="formula_10">H t n i 0 B i n t H i (4)</formula><p>is a polynomial hierarchy interpolant of degree n where B i n t are the Bernstein polynomials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Multi-Parameter Families of Hierarchies</head><p>The idea of smooth interpolation in a set of hierarchies can be pursued to the interpolation in a two-or multi-parameter family of hierarchies (as shown in figures 8 and 9 in the appendix). The vertices of the discretized parameter domain, a square with four triangles and five vertices, represent five keyframe hierarchies at different resolutions and are shown in the lower part: an icosahedron, a bone, a cushion, a star, and a sphere in the midpoint of the domain. Each vertex of the domain represents a key hierarchy, and the set of keyframe hierarchies fulfills the interpolation property (B). This allows a barycentric interpolation in each domain triangle between the three key hierarchies at the vertices of each triangle. Let H 1 , H 2 , and H 3 denote the key hierarchies at the vertices of a domain triangle, and let b b 1 b 2 b 3 be the barycentric coordinate of the point in the domain triangle. Then the interpolation hierarchy is given by</p><formula xml:id="formula_11">H b b 1 H 1 b 2 H 2 b 3 H 3<label>(5)</label></formula><p>Similar to the 1-dimensional case, with time parameter t, the combinatorial structure of the interpolation hierarchy H b is the topological union of all its three key hierarchies. Multiparameter families of hierarchies occur frequently in geometrical and numerical problems depending on more than one parameter. But even when studying one-parameter families, the inclusion of a view-dependent rendering may be considered to be a 2-parameter family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Hierarchy Generation</head><p>In practice, hierarchies are generated by two different approaches: One starts with a high resolution data set and iteratively coarsens the geometry to produce a hierarchy. This 'bottom up' approach is successfully used by Hoppe <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> in the progressive mesh concept to obtain a vertex-based hierarchy by successive vertex-split and edge-collapse steps. As shown by Hoppe, different sections of one hierarchy can be interpolated, so-called geomorphs. The handling of arbitrary initial data sets is flexible, but this restricts the compatibility of two hierarchies obtained from similar initial geometries and reduces the possibility of interpolating between different hierarchies.</p><p>Generating a hierarchy 'top down' from a given coarse triangulation is ideal for element based approaches. One sets the triangles of the initial triangulation as root elements of a hierarchy, and successively refines according to some error criteria. For example, in the numerics of a boundary value problem for a partial differential equation one starts with a rough approximation of the solution and then refines/coarsens the geometry depending on a local numerical error.</p><p>Eck et al. <ref type="bibr" target="#b6">[7]</ref> produce, from a given fine resolution mesh, a new element-based hierarchy for usage in multiresolution analysis. Their approach should also apply in generating hierarchies based on the Rivara bisection method since they already solved the major task of distributing vertices equidistantly on the surface.</p><p>We have imposed some weak interpolation constraints (B) on a family of triangle hierarchies to allow interpolation while maintaining the freedom to locally refine each key hierarchy. The interpolation hierarchy, is combinatorially the union of its keyframe hierarchies and it therefore has the simplest structure possible without loosing information.</p><p>We introduced the Rivara bisection method as an alternative to the 4-1 split of triangles. Together with our constraints (B), the Rivara method ensures the interpolation property. Additionally, the Rivara method avoids a number of case distinctions occurring with hanging vertices in the 4-1 split approach. On the other hand, the Rivara method is similar to the 4-1 split since it inserts the same vertices after successive refinements.</p><p>For numerical purposes the interpretation of the parameter domain of a, say, two-parameter family as a triangulation has significant further implications. Similar to the approximation of a smooth surface by a triangulation, the triangulated domain may approximate a smooth family of surfaces. One may use an adaptive refinement of the parameter domain, i.e. an automatic process which inserts a new key hierarchy in the domain, if the interpolation hierarchy does not satisfy a given error threshold. <ref type="table">bunny1  400  127000  63520  17  13  5  bunny2  400  611340  305690  80  60  24  sphere  20  204800  102420  27  20  8  brezel  144  128280  64120  17  13  5</ref> This table shows the memory requirements for some models using the principal hierarchical structures and a slightly optimized implementation in contrast to a non-hierarchical representation of the triangulation on the finest level. The non-hierarchical representation stores for each vertex the coordinates, the normals, and for each element the vertex indices, neighbour indices and the vertex texture coordinates. For the optimized hierarchical representation we used a data-structure which allowed us to store vertex information only once per refined root node.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>The Rivara bisection method refines a triangle exactly at its refinement edge. Each child inherits a refinement edge as shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Successive applications of the Rivara algorithm introduce new vertices matching those retrieved by 4-1 splits.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>A single step of the Rivara bisection method with refinement edges and marked triangles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Let us work with barycentric coordinates and represent each point p of a triangle by its barycentric coordinate b 1 b 2 b 3 with respect to the triangle vertices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>A simple example where the green elements in a 4-1 split require further subdivision if one interpolates between two key hierarchies H 1 and H 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Two hierarchies fulfilling the interpolation constraints (B) are subsets of the same infinite hierarchy. The interpolation hierarchy H is the union of H 1 and H 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>F H 1</head><label>1</label><figDesc>H 2 be a family of hierarchies which fulfill the interpolation constraints (B) and let b b 1 b 2 , b i , be a set of weights. Then there exists an interpolated hierarchy</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Interpolation between a two-dimensional set of keyframe hierarchies. The vertices of the parameter domain represent the four hierarchies on the bottom right and a sphere at the midpoint. All hierarchies have a different combinatorics, but fulfill the interpolation constraints mentioned in the paper. This allows for a continuous interpolation when varying the position in the parameter domain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Interpolation between three keyframe hierarchies (a bone, the Stanford Bunny, and a sphere). The three models have different connectivities adjusted to their curvature.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgments</head><p>The Bunny geometry was produced by the Stanford Computer Graphics group. The second author thanks Martin Rumpf for fruitful discussions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix: Space Requirements</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The use of adaptive grid refinement for badly behaved elliptic partial differential equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Bank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">H</forename><surname>Sherman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Computer Methods for Partial Differential Equations</title>
		<imprint>
			<date type="published" when="1979" />
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Local mesh refinement in 2 and 3 dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bänsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IMPACT of Computing in Science and Engineering</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A First Course in Geometric Topology and Differential Geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">D</forename><surname>Bloch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Birkhäuser</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Computer generated key-frame animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Burtnyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Soc. Motion Picture and Television Engineers</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<date type="published" when="1971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive skeleton techniques for enhancing motion dynamics in key frame animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Burtnyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hierarchical triangulation for multiresolution surface description</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Defloriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 95 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
		<title level="m">Mesh optimization. SIGGRAPH 95 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Computer Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Magnenat-Thalmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thalmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Workbench</title>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A concept for time-dependent processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Polthier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization in Scientific Computing</title>
		<editor>M. Göbel, H. Müller, and B. Urban</editor>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On a data structure for adaptive finite element mesh refinements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Rheinboldt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">K</forename><surname>Mesztenyi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Algorithms for refining triangular grids suitable for adaptive and multigrid techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rivara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International J. for Numerical Methods in Engineering</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Parametric keyframe interpolation incorporating kinetic adjustment and phrasing control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">N</forename><surname>Steketee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">I</forename><surname>Badler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 85 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
