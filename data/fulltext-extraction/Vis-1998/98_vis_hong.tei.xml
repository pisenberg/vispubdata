<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Accelerated Ray-Casting for Curvilinear Volumes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lichan</forename><surname>Hong</surname></persName>
							<email>lhong@research.bell-labs.com</email>
							<affiliation key="aff0">
								<orgName type="department">Software Production Research Department Bell Laboratories</orgName>
								<orgName type="institution">Lucent Technologies Room</orgName>
								<address>
									<addrLine>263 Shuman Blvd Naperville</addrLine>
									<postCode>2F-321, 60566-7050</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Center for Visual Computing (CVC) and Department of Computer Science State University of New York at Stony Brook Stony Brook</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Accelerated Ray-Casting for Curvilinear Volumes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Volume Visualization</term>
					<term>Volume Rendering</term>
					<term>Irregular Grid</term>
					<term>Curvilinear Grid</term>
					<term>Ray-Casting</term>
					<term>Parallel Rendering</term>
					<term>Dynamic Simulation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present an efficient and robust ray-casting algorithm for directly rendering a curvilinear volume of arbitrarily-shaped cells. We designed the algorithm to alleviate the consumption of CPU power and memory space. By incorporating the essence of the projection paradigm into the ray-casting process, we have successfully accelerated the ray traversal through the grid and data interpolations at sample points. Our algorithm also overcomes the conventional limitation requiring the cells to be convex. Application of this algorithm to several commonly-used curvilinear data sets has produced a favorable performance when compared with recently reported algorithms.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A major barrier preventing the widespread usage of volume rendering technology is its substantial requirements for computational power and memory space. In the past few years, numerous algorithms have been investigated to improve the rendering performance of rectilinear volumes. However, volume rendering of nonrectilinear (i.e., curvilinear and unstructured) grids <ref type="bibr" target="#b14">[15]</ref> is still relatively under-explored.</p><p>A curvilinear grid can be considered as the result of a rectilinear grid of cubic voxels subjected to non-linear transformations, so as to fill or warp around an object of complex shape while preserving the grid topology. The curvilinear grid has the same implicit connectivity as the rectilinear grid, yet unlike the rectilinear grid, the 3D locations of its grid vertices must be explicitly defined. As a result, each quadrilateral cell-face is not necessarily planar and each six-sided cell is not necessarily convex. Curvilinear grids are commonly utilized in a variety of applications such as scientific computing and computer-based modeling. For example, in a Computational Fluid Dynamics (CFD) simulation, a curvilinear grid can be employed to efficiently model the surrounding area of an aerodynamic object <ref type="bibr" target="#b13">[14]</ref>. While in the case of dynamic simulation <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21]</ref>, even if a deformable object may initially be represented as a rectilinear volume, the volumetric object dynamically changes its underlying grid structure and soon becomes curvilinear, due to the influence of internal and external factors (e.g., when colliding with another object).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>The irregularity of the curvilinear grid, in comparison with the rectilinear grid, imposes a much higher complexity on the rendering process. The simplest way of visualizing a curvilinear volume is to resample it into a rectilinear grid and subsequently render the new volume with algorithms for rectilinear data <ref type="bibr" target="#b7">[8]</ref>. Since the curvilinear grid could consist of cells of drastically different sizes, a significantly large rectilinear volume has to be employed in order to preserve the details of the smallest curvilinear cells (which usually include data of ultimate importance). In addition, the resampling abandons the original grid structure and may introduce sampling errors <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16]</ref>. Alternatively, one may decompose each curvilinear cell into five tetrahedra and then further process the tetrahedral representation <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20]</ref>. As a result, the implicit cell connectivity in the original grid structure is abandoned and a significant amount of memory space has to be allocated to explicitly define the connectivity of the tetrahedral cells. Commonly, the extra storage required is several times the amount of space needed to store the original curvilinear volume.</p><p>Yet another approach is to perform the rendering directly on the curvilinear volume, without converting it into an intermediate grid.</p><p>Generally speaking, there are two such techniques: projection and ray-casting. In Van Gelder and Wilhelms <ref type="bibr" target="#b4">[5]</ref>, each curvilinear cell was projected onto the image screen in a certain visibility order, with its contributions to the image pixels being calculated with graphics hardware. To obtain the visibility order, the cells were approximated as convex hexahedra and sorted using a linear-time topological sorting algorithm. To overcome the potential problem that the cell visibility order may be impossible to find <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b18">19]</ref>, Wilhelms et al. <ref type="bibr" target="#b16">[17]</ref> treated each cell-face as a projection primitive and independently scan-converted the cell-faces in software. All the polygons contributing to a particular image pixel were then sorted by depth obtained from the scan-conversion and correctly composited to produce the pixel color.</p><p>Using ray-casting to directly render a curvilinear volume has also been studied <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14]</ref>. Typically, a ray is cast from the virtual camera through each image pixel into the curvilinear volume. All the cellfaces intersecting with the ray are found and data are interpolated for the ray/cell-face intersection points. The pixel color is then determined by accumulating the contributions of the intersecting cells along the ray. Both Uselton <ref type="bibr" target="#b13">[14]</ref> and Ramamoorthy and Wilhelms <ref type="bibr" target="#b8">[9]</ref> approximated each cell-face to be planar and adapted Garrity's ray-casting algorithm of tetrahedral grids <ref type="bibr" target="#b3">[4]</ref> to the curvilinear domain. Ramamoorthy and Wilhelms <ref type="bibr" target="#b8">[9]</ref> also described their efforts in accelerating the rendering at the expense of extra memory space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Contribution</head><p>Our work in curvilinear volume rendering was mainly driven by our project on dynamic simulation of deformable objects <ref type="bibr" target="#b20">[21]</ref>. The goal of this project is to simulate how deformable objects dynamically change their shapes under certain circumstances. The FEM simulation model includes volumetric objects whose grid structures are initially rectilinear but quickly deform and become curvilinear. Subsequently, the curvilinear grid is likely to deform into another curvilinear grid at each time step of the simulation. Due to the extraordinary consumption of computational power and memory space by the simulation, in conjunction with the desire to perform the volume visualization on the same platform, our objective has been to find a fast rendering algorithm which does not rely on an extensive precomputation or a considerable amount of extra storage. In addition, the algorithm would have to be robust enough to process both convex and concave cells. Furthermore, we expected that the algorithm could be readily parallelized on a multi-processor computer, and extensible in the future to handle multiple objects as well as produce realistic effects such as shadows and reflections. After thoroughly evaluating the features of existing techniques, we found that none of them was well suited for our application and decided to develop a new rendering algorithm of our own, which is presented in this paper.</p><p>Like the previous work by Uselton <ref type="bibr" target="#b13">[14]</ref> and Ramamoorthy and Wilhelms <ref type="bibr" target="#b8">[9]</ref>, our algorithm is a ray-casting technique directly generating images from the curvilinear volume. Our major contribution is in incorporating the essence of the projection approach into the ray-casting to speed up the critical steps of ray traversal and data interpolations <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9]</ref>. The acceleration is achieved without incurring any precomputation nor requiring a vast amount of extra storage. Specifically, to find the first-entry and re-entry cell-faces for a ray, we employ a pixel bucket to depth-sort those exterior cell-faces intersecting with the ray. When the ray enters a cell, we project the candidate cell-faces onto the image screen and efficiently perform the ray/cell-face intersection tests to identify the cell-face from which the ray exits the cell. This also enables us to overcome the limitation of Garrity's algorithm <ref type="bibr" target="#b3">[4]</ref> which requires the cell to be convex. As a by-product of the tests, the data at the ray/cell-face intersections are reconstructed and subsequently used in the accumulation of color and opacity.</p><p>The remainder of this paper is structured as follows: In Section 2, we describe our ray-casting algorithm, and outline how we accelerate the ray traversal as well as the data interpolations. We also present the parallelization of our ray-casting algorithm on a shared-memory, multi-processor architecture. Then, in Section 3, we apply our algorithm on several well-known curvilinear data sets and compare its performance with two recently reported algorithms <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b19">20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Acceleration Techniques for Ray-Casting</head><p>In the ray-casting, a ray is cast from each image pixel into the curvilinear volume, as illustrated in <ref type="figure">Fig. 1</ref>. To accumulate the color c and opacity o along the ray for a pixel x; y, a function in the form of CastOneRay is used (see challenges in the ray-casting process <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9]</ref> as follows:</p><p>(1) Identifying the exterior cell-faces through which a ray first enters and possibly re-enters the grid after the ray exits from an exterior cell-face; (2) Determining the cell-face through which a ray exits the current cell and enters the next cell; <ref type="formula">3</ref>Reconstructing data values at the intersections between a ray and the cell-faces.</p><p>An exterior cell-face is a cell-face that belongs to the grid boundary and is exclusively owned by a cell, while an interior cell-face is the common wall shared by two adjacent cells. Since a great deal of rendering time is taken by these three operations, our goal is to accelerate them so as to improve the overall rendering speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Determining Entry Cell-Faces</head><p>As shown in <ref type="figure">Fig. 1</ref>, to traverse along the ray, we need to find the exterior cell-face from which the ray first enters the volume. In addition, since the grid is likely to be concave, after the ray exits the volume from an exterior cell-face, it can potentially re-enter the grid multiple times (see <ref type="figure">Fig. 1</ref>). To quickly locate the first-entry and re-entry exterior cell-faces, both Garrity <ref type="bibr" target="#b3">[4]</ref> and Ramamoorthy and Wilhelms <ref type="bibr" target="#b8">[9]</ref> suggested superimposing a rectilinear grid of certain resolution over the curvilinear grid. At a preprocessing step, each voxel of the embedded rectilinear grid is associated with a list of exterior cell-faces that are totally or partially within the voxel. During the rendering, when there is a need to find the first-entry cell-face or check whether the ray re-enters the volume, those rectilinear voxels intersecting with the ray are identified and their associated exterior cell-faces are tested against the ray. Due to the fact that the grid structure changes over time in our application, it may be undesirable to use such an embedding scheme which was originally designed for a static grid. In addition to the extra storage, a new curvilinear grid at each time step of the simulation would require that the exterior cell-faces be re-distributed into the voxels of the rectilinear grid, which could probably have been reconfigured. Instead, by leveraging the projection paradigm, we have developed an alternative approach in our algorithm, as illustrated in the simplified 2D example of  Without incurring any extra storage, we first implicitly subdivide each quadrilateral cell-face (both exterior and interior) into two triangles. The triangle approximation is chosen over a bilinear patch because of our thrust to speed up the ray/cell-face intersections in the algorithm. Note that there are two possible ways of triangulating a cell-face, which may affect the data values reconstructed at the sample points (see Section 2.3). For simplicity, similar to the cell subdivision approach <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20]</ref>, we arbitrarily choose one triangulation and consistently use it throughout the ray-casting process. Then, for each pixel on the image screen, we set up a bucket. Next, each exterior triangle is independently projected onto the image screen and scan-converted according to the image resolution. For each pixel x; y covered by the projection of an exterior triangle, a tuple id; z is generated from the 2D scan-conversion, where id is a unique identification number assigned to the triangle (see <ref type="figure" target="#fig_1">Fig. 3a)</ref> and z is the depth (screen-z) interpolated from the triangle vertices. This tuple id; z indicates that the ray cast from the pixel x; y intersects the exterior triangle id at the depth z. We place the tuple id; z into the bucket of pixel x; y. As a result, after all the exterior triangles have been processed, within each pixel bucket there is a list of tuples which represent the exterior triangles intersecting with the ray cast from that pixel. For each bucket, we sort the tuples by the depth z, as shown in <ref type="figure" target="#fig_1">Fig. 3b</ref>. Subsequently, during the traversal of a ray, we retrieve the sorted tuples from the corresponding pixel bucket to find the first-entry and re-entry triangles.</p><p>This method is conceptually similar to Wilhelms et al. <ref type="bibr" target="#b16">[17]</ref>. However, unlike their algorithm, where both the exterior and interior cell-faces are scan-converted and depth-sorted, at this phase we only process those exterior triangles that assist us in identifying the first-entry and re-entry triangles. For a typical curvilinear volume, since a ray usually re-enters the grid a limited number of times, the space consumed by our pixel buckets is mostly determined by the image resolution and should not be significant in comparison with the embedding scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Identifying Exiting Cell-Faces</head><p>Once the ray enters a cell from one of its six cell-faces, it is necessary to find the cell-face from which the ray exits the current cell and enters the next cell. Garrity <ref type="bibr" target="#b3">[4]</ref> showed that for a convex cell, one can intersect the ray with the 3D planes containing the candidate cell-faces. The cell-face whose intersection lies after the entry point and has the smallest distance from the entry point is the exiting cell-face. This technique was extended to the curvilinear domain by Uselton <ref type="bibr" target="#b13">[14]</ref> and Ramamoorthy and Wilhelms <ref type="bibr" target="#b8">[9]</ref>. Both groups employed a planar quadrilateral to approximate every cell-face. Furthermore, to speed up the ray/cell-face intersections, Ramamoorthy and Wilhelms <ref type="bibr" target="#b8">[9]</ref> pre-computed the 3D planes containing the cell-faces and stored them at the expense of extra space.</p><p>Unfortunately, for a non-convex cell, Garrity's method <ref type="bibr" target="#b3">[4]</ref> is no longer valid. As illustrated in <ref type="figure" target="#fig_3">Fig. 4</ref>, a ray enters the cell through cell-face AB. Following Garrity's technique, AD will be chosen as the exiting cell-face, although C Dis the real exiting cell-face in this example. It can be seen that the additional requirement needed for a correct method is that the ray/cell-face intersection has to be inside the exiting cell-face. In other words, to handle both convex and concave cells, the algorithm would have to compute the 3D plane containing a candidate cell-face, find the 3D location of the ray/plane intersection, and check whether the intersection lies inside the cell-face. This could involve a great deal of computation. One may argue that for the curvilinear grids used in scientific computing, the cells are unlikely to be concave. However, even a small likelihood <ref type="bibr" target="#b8">[9]</ref> makes the algorithm rather complicated to implement. It also prevents the algorithm from being applied on those curvilinear data where cell convexity can not be readily guaranteed.</p><p>In the following, we present an efficient alternative which can be used in both convex and concave cells.</p><p>Since we have subdivided each cell-face into two triangles, each cell consists of twelve triangles. As the ray enters a cell from one triangle, we check the ray against the other eleven triangles of the cell to find the exiting triangle. Instead of conducting the tests in 3D, we again explore the projection paradigm. Specifically, we project each candidate triangle T onto the image screen and test whether the 2D projected triangle contains the pixel x; y from which the ray is cast, as illustrated in <ref type="figure">Fig. 5</ref>. Note that this function is essentially equivalent to the operations of computing the ray/triangle intersection in 3D and checking whether the intersection lies within the triangle. x; y intersects with triangle T.</p><p>If the ray intersects with the triangle T, the function IntersectTrianglex; y; T; z will return TRUE coupled with the depth z of the intersection; otherwise, it will return FALSE. Steps 2-4 of the function are three operations of progressively increasing complexity. Their objective is to quickly terminate the test when the ray does not intersect with the triangle T, which usually happens to most of the candidate triangles. At Step 4, where pixel x; y is confirmed to be inside the 2D projected triangle, a linear interpolation scheme similar to 2D scan-conversion is used to reconstruct the depth of the intersection from the triangle vertices. Subsequently, if more than one triangle returns TRUE from the intersection test (i.e., the ray intersects with the cell multiple times), we designate the exiting triangle as the one whose intersection lies after the entry point and has the smallest depth. This allows the ray to re-enter the same cell at a later stage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Data Interpolations</head><p>To accumulate the color c and opacity o along a ray, as well as the depth z, the scalar s at the ray/cell-face intersections has to be reconstructed from the grid vertices. That is, given the scalar values at the four grid vertices of a cell-face, one needs to find the scalar data for a sample point within the cell-face. The common solution is to transform the cell-face from its arbitrary 3D orientation to one of the coordinate planes (e.g., the X Y-plane), and calculate the bilinear interpolation offsets in 2D <ref type="bibr" target="#b8">[9]</ref>. This method unfortunately requires a considerable amount of computation.</p><p>Since we have used two triangles to approximate a quadrilateral cell-face in our algorithm, the task is reduced to interpolating the scalar data at the intersection from the triangle vertices. Taking advantage of the 3D-to-2D projection transformation already performed in the function IntersectTriangle (see <ref type="figure">Fig. 5</ref>), we implement the data interpolation as part of the ray/triangle intersection test. Specifically, at Step 4 of the function IntersectTriangle, where the ray is confirmed to have intersected with the triangle, we interpolate not only the depth z but also the scalar s from the triangle vertices. That is, the function becomes IntersectTrianglex ;y;T;z;s.</p><p>Accommodating this extra interpolation may slightly increase the execution time of IntersectTriangle, but it completely eliminates a separate data interpolation phase. Now that we have the depth z and scalar s for the intersections, ray integral equations (the same as in <ref type="bibr" target="#b8">[9]</ref>) which take into account the varying distances between consecutive samples are used to accumulate the color c and opacity o.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Algorithm Parallelization</head><p>Parallelization of the ray-casting algorithm was motivated by the fact that our FEM simulation was performed on a shared-memory, multi-processor architecture <ref type="bibr" target="#b20">[21]</ref> and we expected to conduct the volume visualization of the simulation result on the same platform. Fortunately, as the rays are relatively independent of each other and only a single copy of the volumetric data is needed in the shared memory, it becomes fairly easy to parallelize the algorithm.</p><p>We have found from our initial experiments that in the sequential algorithm, less than 3% of the rendering time is spent on finding the first-entry and re-entry exterior triangles. Because of its interactions with the pixel buckets, a global resource shared by the exterior triangles, our parallel version of this step turned out to be not as fast as its sequential counterpart, considering the overheads caused by the parallelization. Therefore, we decided to run this step sequentially on a single processor. For the other steps of the algorithm, we have successfully parallelized them with a simple partitioning scheme and achieved satisfactory speedups (see Section 3.2). Specifically, given n 2 processors in the shared-memory architecture, we partition the image screen into sub-blocks of nn pixels. For each pixel of a sub-block, we assign a processor to traverse the ray for computing the pixel color. When the ray traversal is terminated, the processor moves on to its corresponding pixel on the next sub-block. The overall computation is reasonably well distributed among the processors, due to the spatial coherence among the rays within a sub-block. <ref type="figure" target="#fig_6">Fig. 6</ref> provides a brief description of the parallel implementation.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experimental Results</head><p>In our project, the ray-casting algorithm and the FEM simulation model have been developed simultaneously. Before the simulation model had been well defined, we used several well-known curvilinear data sets to evaluate the consumption of computational power and memory space by our rendering algorithm. These included the Blunt Fin (403232) <ref type="bibr" target="#b5">[6]</ref>, Liquid Oxygen Post (387638) <ref type="bibr" target="#b9">[10]</ref>, and Delta Wing (56 5470) <ref type="bibr" target="#b1">[2]</ref>, all freely available from NASA.</p><p>In the following we present our testing results obtained from both the sequential and parallel implementations. See <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21]</ref> for our examples of the dynamic simulation of muscle volume deformation using FEM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sequential Implementation</head><p>The sequential algorithm was measured on an SGI Onyx (one 194MHz R10000 processor, 640MB memory, RE2 graphics). Using the ray-casting algorithm, we generated an animation which depicted a flight around the Blunt Fin. This animation consisted of more than 100 individual frames with the virtual camera looking at the Blunt Fin from different angles. All the images were rendered using the same transfer functions, with high density mapped to red and low density mapped to green. <ref type="figure" target="#fig_7">Fig. 7</ref> (in the Color Section) shows three frames of the animation. <ref type="table" target="#tab_0">Table 1</ref> illustrates the average time spent on each step of the algorithm and the total rendering time.</p><p>Similarly, we generated animations for the Liquid Oxygen Post and the Delta Wing. <ref type="figure" target="#fig_8">Fig. 8</ref> (in the Color Section) shows three images produced by rendering the energy scalar field of the Liquid Oxygen Post, where low energy was mapped to red and high energy was mapped to green. The rendering time distribution for this data set is illustrated in <ref type="table" target="#tab_1">Table 2</ref>. Additionally, three images of the Delta Wing are shown in <ref type="figure" target="#fig_9">Fig. 9</ref> (in the Color Section), with low density mapped to green and high density mapped to red. <ref type="table" target="#tab_2">Table  3</ref> illustrates the rendering time distribution. Note that the images in Figs. 7-9 are relatively transparent. If a more opaque transfer function were employed to accumulate the opacity along the rays, many rays could have been terminated earlier, further reducing the rendering time.   In the following, we compare our algorithm with two techniques recently proposed by Silva and Mitchell <ref type="bibr" target="#b11">[12]</ref> and Yagel et al. <ref type="bibr" target="#b19">[20]</ref>. We have chosen these two algorithms because they represent stateof-the-art research on the rendering of non-rectilinear volumes and provide testing results on the same three data sets. Unlike our algorithm which performs the ray-casting directly on the curvilinear volume, both Silva and Mitchell <ref type="bibr" target="#b11">[12]</ref> and Yagel et al. <ref type="bibr" target="#b19">[20]</ref> decomposed the curvilinear cells into tetrahedra and then rendered the tetrahedral representation. Silva and Mitchell intersected the tetrahedral grid with sweep-planes going through the scanlines and being perpendicular to the image screen. Polygons formed on each sweep-plane were then rendered in a sweep-line manner to generate pixel colors for the scanline. Alternatively, Yagel et al. intersected the tetrahedral volume with a set of slicing planes parallel to the image screen and used graphics hardware to project the 2D polygons formed on the planes. We do not compare against previous ray-casting techniques for curvilinear volumes <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14]</ref>, because they were developed several years ago on platforms considered today to be out-of-date. <ref type="table" target="#tab_3">Tables 4-6</ref> show the performance comparison on the Blunt Fin, Liquid Oxygen Post, and Delta Wing, respectively. When interpreting these tables, note that different rendering parameters   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Parallel Implementation</head><p>Our parallel algorithm was implemented on an SGI Power Challenge (sixteen 194MHz R10000 processors, 3GB memory, IR graphics). The measurements were obtained while the machine was being routinely used by other users as well. For illustration purposes, in the following we divide the rendering process into two phases: Entry and Others. The former corresponds to Step 1 of function ParallelRayCasting (see <ref type="figure" target="#fig_6">Fig. 6</ref>), where only one process is employed to set up the pixel buckets. While the latter corresponds to Step 2 of function ParallelRayCasting, where multiple processors are concurrently used to traverse the rays and perform the accumulations. We ran our parallel algorithm on nine processors and sixteen processors of the Challenge, respectively. Tables 7-9 show the performance comparison on the three data sets. The slight increase in the time taken by the Entry phase was due to the overheads of setting up the parallelization. The parallelized Others phase achieved an average speedup of 8:79 on nine processors, leading to an overall average speedup of 7:51 for the parallel algorithm. With sixteen processors, the Others phase achieved an average speedup of <ref type="bibr">14:95,</ref> resulting in an overall average speedup of <ref type="bibr">11:48</ref> for the parallel algorithm. The algorithm non-linear scalability on all sixteen processors could be due to the cache and/or bus contentions, as well as the system resources taken by other users when the measurements were conducted.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions and Future Work</head><p>In this paper, we have presented an efficient yet robust ray-casting algorithm for high-quality rendering of a curvilinear volume. As demonstrated in the experimental studies, with this algorithm we have successfully achieved the goal of alleviating the consumption of both computational power and memory storage. To the best of our knowledge, our unoptimized rendering time and memory usages on the Blunt Fin, Liquid Oxygen Post, and Delta Wing, respectively, are the best reported to date in the literature. Although this work was originally driven by our application of dynamic simulation, the generality and favorable performance of our algorithm also makes it an appealing alternative to existing rendering techniques.</p><p>As indicated in <ref type="table" target="#tab_0">Tables 1-3</ref>, for the sequential implementation about 95% of the rendering time is currently taken by the steps of Traversal and Interpolations (i.e., function IntersectTriangle). We plan to further optimize this function to improve the overall rendering performance. For the parallel implementation the resulting speedup of the Others phase is rather satisfactory, but the sequential execution of the Entry phase negatively affects the overall speedup. We are working on techniques to address this issue.</p><p>As a long term goal, we plan to extend the proposed acceleration techniques to the rendering of unstructured grids. Since the projection method employed in our algorithm does not inherently depend on the structure of curvilinear cells, it should be applicable to unstructured cells as well. Another plan for future research is the anti-aliasing rendering for non-rectilinear grids. Although the ray-casting approach has taken into account the changing grid density along the screen-z direction, the potential under-sampling/oversampling problem in the screen-x and screen-y directions needs to be investigated as well.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 )Figure 1 : 1 )( 2 ) 3 )Figure 2 :</head><label>211232</label><figDesc>. In general, there are three major Ray-casting a curvilinear volume. CastOneRay(x; y; c; o) f (cast a ray from pixel x; y and find the first cell-face intersected by the ray while (the ray has not exited the grid and opacity o has not reached unity) f (2a) locate the exiting cell-face of the current cell (2b) reconstruct the scalar s and depth z at the intersection between the ray and the exiting cell-face (2c) accumulate c and o, based on the values of s and z g (if opacity o has not reached unity and the ray re-enters the grid, go to (2a) g The function for casting a ray from pixel x; y to accumulate color c and opacity o.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>(a) Assign a unique identification number to each exterior cell-face and project it onto the image screen. (b) For each image pixel, sort the intersecting exterior cell-faces by depth.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>AFigure 4 :</head><label>4</label><figDesc>Find the exiting cell-face of a non-convex cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 )( 2 )( 3 )( 4 )Figure 5 :</head><label>12345</label><figDesc>Boolean IntersectTriangle(x; y; T; z) f (project the three vertices of the triangle T onto the image screen check pixel x; y against the bounding rectangle of the 2D projected triangle. If the pixel is outside the bounding rectangle, return FALSE check pixel x; y against the three edges of the 2D projected triangle. If the pixel is outside the projected triangle, return FALSE interpolate the depth z at pixel x; y from the triangle vertices and return TRUE g The function for testing whether a ray cast from pixel</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>( 1 )( 2 )</head><label>12</label><figDesc>using processor 0, project every exterior triangle onto the image screen and depth-sort the tuples inside each pixel bucket while (processor i is idle) f (2a) find its corresponding pixel on the next partitioning sub-block and cast a ray from that pixel (2b) with the assistance of the pixel bucket, traverse the ray from cell to cell and accumulate the color c &amp; opacity o based on the interpolated data g g</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Parallel version of our ray-casting algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Images of the Blunt Fin from three di erent viewing angles high density is mapped t o r ed and low density is mapped to green.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Images of the Liquid Oxygen Post from three di erent viewing angles low energy is mapped to red and high energy is mapped to green.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Images of the Delta Wing from three di erent viewing angles low density is mapped to red and high density is mapped to green.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Average time (seconds) spent on ray-casting the Blunt Fin with image size 500 500.</figDesc><table><row><cell>Data Set</cell><cell>Blunt Fin</cell></row><row><cell>First-Entry &amp; Re-Entry</cell><cell>0.43</cell></row><row><cell>Traversal &amp; Interpolations</cell><cell>18.63</cell></row><row><cell>Color &amp; Opacity Compositing</cell><cell>0.65</cell></row><row><cell>Total</cell><cell>19.71</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Average time (seconds) spent on ray-casting the Liquid Oxygen Post with image size 500 500.</figDesc><table><row><cell>Data Set</cell><cell>Liquid Oxygen Post</cell></row><row><cell>First-Entry &amp; Re-Entry</cell><cell>0.69</cell></row><row><cell>Traversal &amp; Interpolations</cell><cell>38.17</cell></row><row><cell>Color &amp; Opacity Compositing</cell><cell>1.51</cell></row><row><cell>Total</cell><cell>40.37</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Average time (seconds) spent on ray-casting the DeltaWing with image size 500 500.</figDesc><table><row><cell>Data Set</cell><cell>Delta Wing</cell></row><row><cell>First-Entry &amp; Re-Entry</cell><cell>0.75</cell></row><row><cell>Traversal &amp; Interpolations</cell><cell>38.93</cell></row><row><cell>Color &amp; Opacity Compositing</cell><cell>1.15</cell></row><row><cell>Total</cell><cell>40.83</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Performance comparison among Silva and Mitchell<ref type="bibr" target="#b11">[12]</ref>, Yagel et al.<ref type="bibr" target="#b19">[20]</ref>, and our algorithm on the Blunt Fin data set.</figDesc><table><row><cell>Algorithm</cell><cell>S &amp; M</cell><cell>Yagel et al.</cell><cell>Ours</cell></row><row><cell>Image Size</cell><cell cols="3">530 230 not reported 300 300</cell></row><row><cell>Rendering (sec)</cell><cell>22</cell><cell>9.11</cell><cell>7.09</cell></row><row><cell>Memory (MB)</cell><cell>8</cell><cell>21.2</cell><cell>1.8</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Performance</figDesc><table><row><cell></cell><cell cols="3">comparison among Silva and Mitchell [12],</cell></row><row><cell cols="4">Yagel et al. [20], and our algorithm on the Liquid Oxygen Post data</cell></row><row><cell>set.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Algorithm</cell><cell>S &amp; M</cell><cell>Yagel et al.</cell><cell>Ours</cell></row><row><cell>Image Size</cell><cell cols="3">300 300 not reported 300 300</cell></row><row><cell>Rendering (sec)</cell><cell>37</cell><cell>20.45</cell><cell>14.60</cell></row><row><cell>Memory (MB)</cell><cell>22</cell><cell>56.7</cell><cell>3.7</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 :</head><label>6</label><figDesc>Performance comparison among Silva and Mitchell<ref type="bibr" target="#b11">[12]</ref>, Yagel et al.<ref type="bibr" target="#b19">[20]</ref>, and our algorithm on the Delta Wing data set. RE graphics), but using only 50 slicing planes. In terms of image quality, our algorithm is comparable to that of Silva and Mitchell, but Yagel et al.'s algorithm may not approach our image quality. This is because, instead of adaptively sampling along each individual ray to account for the change of grid density, even the adaptive slicing scheme proposed by Yagel et al. imposed the same screen-z sampling rate for all the image pixels. Consequently, some areas of the grid may be under-sampled, while other areas may be over-sampled. To capture the details of the small cells, a much higher number of slicing planes would have been required, leading to a significant increase in both rendering time and memory usage.</figDesc><table><row><cell>Algorithm</cell><cell>S &amp; M</cell><cell>Yagel et al.</cell><cell>Ours</cell></row><row><cell>Image Size</cell><cell cols="3">300 300 not reported 300 300</cell></row><row><cell>Rendering (sec)</cell><cell>64</cell><cell>42.97</cell><cell>14.79</cell></row><row><cell>Memory (MB)</cell><cell>44</cell><cell>111.7</cell><cell>5.7</cell></row><row><cell cols="4">and computer workstations were used in these three algorithms.</cell></row><row><cell cols="4">Silva and Mitchell performed the measurements on a single pro-</cell></row><row><cell cols="4">cessor of an SGI Power Challenge (sixteen 194MHz R10000 pro-</cell></row><row><cell cols="4">cessors, 3GB memory, IR graphics), while Yagel et al. obtained</cell></row><row><cell cols="4">the timing from an SGI Crimson (one 100MHz R4000 processor,</cell></row><row><cell>64MB memory,</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7 :</head><label>7</label><figDesc>Comparison between the sequential and parallel algorithms on ray-casting the Blunt Fin with image size 500 500.</figDesc><table><row><cell></cell><cell cols="3">Entry Others Total</cell></row><row><cell>1 Processor (sec)</cell><cell>0.38</cell><cell>19.19</cell><cell>19.57</cell></row><row><cell>9 Processors (sec)</cell><cell>0.47</cell><cell>2.17</cell><cell>2.64</cell></row><row><cell>9 Processors Speedup</cell><cell>0.81</cell><cell>8.84</cell><cell>7.41</cell></row><row><cell>16 Processors (sec)</cell><cell>0.47</cell><cell>1.30</cell><cell>1.77</cell></row><row><cell>16 Processors Speedup</cell><cell>0.81</cell><cell>14.76</cell><cell>11.06</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 8 :</head><label>8</label><figDesc>Comparison between the sequential and parallel algorithms on ray-casting the Liquid Oxygen Post with image size</figDesc><table><row><cell>500 500.</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">Entry Others Total</cell></row><row><cell>1 Processor (sec)</cell><cell>0.66</cell><cell>40.22</cell><cell>40.88</cell></row><row><cell>9 Processors (sec)</cell><cell>0.80</cell><cell>4.56</cell><cell>5.36</cell></row><row><cell>9 Processors Speedup</cell><cell>0.83</cell><cell>8.82</cell><cell>7.63</cell></row><row><cell>16 Processors (sec)</cell><cell>0.81</cell><cell>2.63</cell><cell>3.44</cell></row><row><cell>16 Processors Speedup</cell><cell>0.81</cell><cell>15.29</cell><cell>11.88</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 9 :</head><label>9</label><figDesc>Comparison between the sequential and parallel algorithms on ray-casting the Delta Wing with image size 500 500.</figDesc><table><row><cell></cell><cell cols="3">Entry Others Total</cell></row><row><cell>1 Processor (sec)</cell><cell>0.70</cell><cell>40.22</cell><cell>40.92</cell></row><row><cell>9 Processors (sec)</cell><cell>0.85</cell><cell>4.62</cell><cell>5.47</cell></row><row><cell>9 Processors Speedup</cell><cell>0.82</cell><cell>8.71</cell><cell>7.48</cell></row><row><cell>16 Processors (sec)</cell><cell>0.84</cell><cell>2.72</cell><cell>3.56</cell></row><row><cell>16 Processors Speedup</cell><cell>0.83</cell><cell>14.79</cell><cell>11.49</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported by the National Science Foundation (grant MIP-9527694), the Office of Naval Research grant (N000149710402), the Naval Research Laboratory (grant N00014961G015), and by a grant from the Mitsubishi Electric Research Laboratory. The three curvilinear data sets of Blunt Fin, Liquid Oxygen Post, and Delta Wing are courtesy of NASA. Thanks to Chi-kun Lam for his implementation of the parallel algorithm. We also thank Kathleen McConnell, Edmond Prakash, Claudio Silva, and Ming Wan for valuable comments on drafts of the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Physicallybased animation of volumetric objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer Animation &apos;98</title>
		<meeting>Computer Animation &apos;98</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="154" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Vortical flows over delta wings and numerical prediction of vortex breakdown</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ekaterinaris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Schiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AIAA Aerospace Sciences Conference</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
	<note>Paper 90-0102</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Raycasting of nonregularly structured volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Frühauf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum (Proc. EUROGRAPHICS &apos;94)</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. 1990 ACM Workshop on Volume Visualization)</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="35" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Rapid exploration of curvilinear grids using direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;93</title>
		<meeting>IEEE Visualization &apos;93</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="70" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Simulation of blunt-fin induced shock wave and turbulent boundary layer separation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AIAA Aerospace Sciences Conference</title>
		<imprint>
			<date type="published" when="1984" />
		</imprint>
	</monogr>
	<note>Paper 84-0457</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Area and volume coherence for efficient visualization of 3D scalar functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. 1990 ACM Workshop on Volume Visualization)</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="27" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Volume rendering of unstructured grids: A voxelization approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Manohar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="711" to="726" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">An analysis of approaches to ray-tracing curvilinear grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramamoorthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>UCSC- CRL-92-07</idno>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
		<respStmt>
			<orgName>University of California at Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A numerical study of threedimensional incompressible flow around multiple posts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Kau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AIAA Aerospace Sciences Conference</title>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
	<note>Paper 86-0353</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. 1990 ACM Workshop on Volume Visualization)</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="63" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The lazy sweep ray casting algorithm for rendering irregular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="142" to="157" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sorting and hardware assisted rendering for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1994 ACM Symposium on Volume Visualization</title>
		<meeting>1994 ACM Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="83" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Volume rendering of computational fluid dynamics: Initial results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Uselton</surname></persName>
		</author>
		<idno>RNR-91-026</idno>
		<imprint>
			<date type="published" when="1990" />
			<pubPlace>Moffett Field, California</pubPlace>
		</imprint>
		<respStmt>
			<orgName>NAS-NASA Ames Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Pursuing interactive visualization of irregular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="450" to="458" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Direct volume rendering of curvilinear volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Challinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Alper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramamoorthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vaziri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. 1990 ACM Workshop on Volume Visualization)</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Hierarchical and parallelizable direct volume rendering for irregular and multiple grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tarantino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;96</title>
		<meeting>IEEE Visualization &apos;96</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Interactive splatting of nonrectilinear volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;92</title>
		<meeting>IEEE Visualization &apos;92</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Visibility ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Hardware assisted volume rendering of unstructured grids by incremental slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1996 ACM/IEEE Symposium on Volume Visualization</title>
		<meeting>1996 ACM/IEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="55" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Real-time biomechanically-based muscle volume deformation using FEM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROGRAPHICS &apos;98</title>
		<meeting>EUROGRAPHICS &apos;98</meeting>
		<imprint/>
	</monogr>
	<note>To appear in</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
