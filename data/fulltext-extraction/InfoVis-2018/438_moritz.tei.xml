<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Formalizing Visualization Design Knowledge as Constraints: Actionable and Extensible Models in Draco</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dominik</forename><surname>Moritz</surname></persName>
							<email>domoritz@uw.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenglong</forename><surname>Wang</surname></persName>
							<email>clwang@uw.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><forename type="middle">L</forename><surname>Nelson</surname></persName>
							<email>glnelson@uw.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Halden</forename><surname>Lin</surname></persName>
							<email>haldenl@uw.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
							<email>amsmith@ucsc.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bill</forename><surname>Howe</surname></persName>
							<email>billhowe@uw.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Heer</surname></persName>
							<email>jheer@uw.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Dominik Moritz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graphical</forename><surname>Design</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California Santa Cruz</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Formalizing Visualization Design Knowledge as Constraints: Actionable and Extensible Models in Draco</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Automated Visualization Design</term>
					<term>Perceptual Effectiveness</term>
					<term>Constraints</term>
					<term>Knowledge Bases</term>
					<term>Answer Set Programming</term>
				</keywords>
			</textClass>
			<abstract>
				<p>There exists a gap between visualization design guidelines and their application in visualization tools. While empirical studies can provide design guidance, we lack a formal framework for representing design knowledge, integrating results across studies, and applying this knowledge in automated design tools that promote effective encodings and facilitate visual exploration. We propose modeling visualization design knowledge as a collection of constraints, in conjunction with a method to learn weights for soft constraints from experimental data. Using constraints, we can take theoretical design knowledge and express it in a concrete, extensible, and testable form: the resulting models can recommend visualization designs and can easily be augmented with additional constraints or updated weights. We implement our approach in Draco, a constraint-based system based on Answer Set Programming (ASP). We demonstrate how to construct increasingly sophisticated automated visualization design systems, including systems based on weights learned directly from the results of graphical perception experiments.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Visualization designers benefit from familiarity with both the data domain under consideration and principles of effective visual encoding. Although designers can learn these principles from books, research papers, and experience, they do not always follow these principles in practice <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b42">42]</ref>. Automated design tools <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b66">66]</ref> are designed to help address this problem: they use formally-encoded design guidelines to promote effective visualizations. However, our design knowledge is incomplete and continually evolving. In order to incorporate new experimental results or compare different theories of effective design, we need to elaborate and refine these bodies of formal design knowledge.</p><p>Visualization researchers regularly publish empirical study results of how people decode and interpret visualizations (e.g., <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b61">61]</ref>). However, new results often make their way into practical tools slowly: even though our knowledge is evolving, we lack a shared medium for representing and acting upon this knowledge. For example, existing automated design systems <ref type="bibr" target="#b37">[37]</ref><ref type="bibr" target="#b38">[38]</ref><ref type="bibr" target="#b39">[39]</ref><ref type="bibr" target="#b65">65]</ref> do not explicitly reuse the knowledge bases implemented in previous systems. Rather than building idiosyncratic representations of design knowledge for individual systems, we seek to make formal models of design knowledge a shared resource for the visualization community.</p><p>We present Draco, a formal model that represents visualizations as sets of logical facts and represents design guidelines as a collection of hard and soft constraints over these facts. Draco can systematically enumerate the visualizations that do not violate the hard constraints and find the most preferred visualizations according to the soft constraints. We first formulate a simple yet powerful visualization description language based on the Vega-Lite grammar <ref type="bibr" target="#b52">[52]</ref> and then extend this language to express dataset and task characteristics. To represent design knowledge, we contribute a set of extensible constraints that can encode expressiveness criteria <ref type="bibr" target="#b37">[37]</ref>, preference rules validated in perception experiments, and general visualization design best practices.</p><p>We view the constraints in Draco as the starting point of an evolving knowledge base of design considerations for researchers and tool designers to extend and use. Hard constraints must be satisfied (e.g., shape encodings cannot express quantitative values), whereas soft constraints express a preference (e.g., temporal values should use the x-axis by default). By changing the weights associated with soft constraints, we can trade off the relative importance of these preferences. However, updating these weights presents a challenge, as local changes may have unexpected global effects. To update preferences in a principled manner, we also contribute a method to automatically configure weights from experimental data. By formulating this process as a learning to rank <ref type="bibr" target="#b36">[36]</ref> problem, we can begin to integrate knowledge scattered across various research papers into a single system.</p><p>We implement Draco using Answer Set Programming, a domainindependent constraint programming language. We formalize the problem of finding appropriate encodings as the problem of finding optimal answer sets <ref type="bibr" target="#b17">[18]</ref>, which provides well-defined semantics and can be solved with efficient domain-independent algorithms.</p><p>We first evaluate Draco by using it to re-implement the APT <ref type="bibr" target="#b37">[37]</ref> and CompassQL <ref type="bibr" target="#b65">[65]</ref> automated design tools, demonstrating Draco's expressiveness and improved performance. We then show how Draco can go beyond these systems by adding new constraints concerning data and a user's primary task. Instead of manually specifying weights, we learn them from two independent graphical perception studies <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b51">51]</ref>. We compare the learned visualization model to a hand-tuned model, demonstrating improved automated design suggestions.</p><p>Encoding design knowledge as constraints has many advantages from both practical and academic perspectives <ref type="bibr" target="#b58">[58]</ref>. Tool builders can use evolving knowledge bases of best practices instead of (re)implementing ad-hoc rules, and can benefit from the efficient search algorithms provided by state-of-the-art constraint solvers. Most importantly, an independent knowledge base may allow anyone to formulate and disseminate design preferences as a small set of independent constraints and/or weight updates. Accordingly, we believe Draco can accelerate the transfer of research knowledge into practical tools. Researchers can also use Draco to systematically sample, enumerate, and reason about the design space of possible visualizations, or to concretely compare different design models. We make Draco available as open source software with supporting tools, documentation, and examples at https://uwdata.github.io/draco/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Draco builds on prior work on automated visualization design systems, visualization specification languages, and constraint programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Automated Visualization Design</head><p>To recommend a visualization, automated design systems enumerate visual encodings that satisfy both user-defined constraints (such as which fields to visualize) and design constraints ( <ref type="figure" target="#fig_0">Fig. 1)</ref>. They then rank candidate visualizations by a utility function. These systems may return the top encodings or perform subsequent clustering to avoid redundancy <ref type="bibr" target="#b65">[65]</ref>.</p><p>Mackinlay's APT system <ref type="bibr" target="#b37">[37]</ref> automatically designs graphical representations of relational data using expressiveness and effectiveness criteria to prune and rank encoding choices. A visualization is considered expressive if it conveys all the facts in the data, and only the facts in the data. A visualization is considered most effective when the information it conveys is more readily perceived than with other visualizations. The original APT system consists of roughly 200 rules in a declarative logic programming language. The logic programming approach has a number of advantages over procedural approaches. First, it is flexible and can be adapted with additional constraints. Second, global optimization can find satisfiable solutions that procedural approaches may fail to identify. Draco takes the logic programming approach from APT but extends it in a few ways. The search strategy in APT is depth-first search with simple backtracking, which is inefficient for large design spaces. Draco uses a modern constraint solver and a standardized representation language. APT is built on a graphical algebra that is no longer used, whereas Draco synthesizes Vega-Lite, a more complete graphical language. Lastly, Draco can deal with multiple (possibly competing) criteria, which was beyond the scope of APT.</p><p>The SAGE project <ref type="bibr" target="#b39">[39]</ref> extends APT by considering additional data properties such as cardinality, uniqueness, and functional dependencies. We adopt this idea in Draco. Casner's BOZ <ref type="bibr" target="#b7">[8]</ref> additionally models the low-level perceptual tasks of reading and comparing values. In addition to value tasks, Draco's model includes summary tasks involving aggregate properties of visual ensembles <ref type="bibr" target="#b62">[62]</ref>. ShowMe <ref type="bibr" target="#b38">[38]</ref> uses heuristic rules to suggest encodings from groups of charts, including trellis plots. Draco similarly models faceting of data into trellis plots.</p><p>While traditional systems rely on carefully designed rules and defaults, more recent systems like Voyager's CompassQL <ref type="bibr" target="#b65">[65]</ref><ref type="bibr" target="#b66">[66]</ref><ref type="bibr" target="#b67">[67]</ref> use hand-tuned scores to specify fine-grained criteria such as space efficiency and legibility based on encoding and data properties. Draco is most similar to CompassQL and its weighted preferences. However, CompassQL is implemented in imperative JavaScript. Moreover, like all prior systems presented in this section, it uses similar heuristics and ad-hoc rules. In contrast, Draco's learning approach offers a "programmatic" way to turn experimental results into preference rankings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Effective Visualization Design</head><p>To rank candidate visualizations, automated design tools use models of visual encoding effectiveness. These models encode the insights of Bertin <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr">Cleveland &amp; McGill [9]</ref>, and others that encoding effectiveness varies depending on the visualized data type and related perceptual tasks. For example, APT uses a ranking of encoding channels by data type informed by human-subjects studies of visual decoding performance. Other studies (e.g., <ref type="bibr" target="#b25">[26]</ref>) confirm and extend such rankings.</p><p>However, most work on effectiveness focuses on the performance of reading or comparing individual marks in a visualization. Recent work investigates the effects of reading ensembles of visual elements <ref type="bibr" target="#b62">[62]</ref>: for example, how users read aggregates <ref type="bibr" target="#b21">[22]</ref>, distributions, trends, or correlation <ref type="bibr" target="#b23">[24]</ref>. Experimental results from Kim et al. <ref type="bibr" target="#b30">[30]</ref> and <ref type="bibr">Saket et al. [51]</ref> analyze how effectiveness varies by task. These results also show that effectiveness varies with respect to data characteristics, such as the cardinality or entropy of data fields. Draco's declarative design can combine classical work on effectiveness using strict preference rules with recent work that considers data and task characteristics in a single system. If activity-oriented <ref type="bibr" target="#b40">[40]</ref> or low-level <ref type="bibr" target="#b1">[2]</ref> task taxonomies were expressed as constraints, they could be used in automated design systems. To demonstrate this conceptually, we use a simple task classification into value tasks for reading and comparing values and summary tasks for comparing ensembles <ref type="bibr" target="#b30">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Visualization Specification</head><p>Automatic visualization tools synthesize graphical designs, which are abstract descriptions of visualizations ( <ref type="figure" target="#fig_0">Fig. 1</ref>). For example, the underlying language for APT describes graphical techniques (e.g., color variation and position on axis) to encode information, whereas ShowMe <ref type="bibr" target="#b38">[38]</ref> synthesizes encodings using VizQL <ref type="bibr" target="#b22">[23]</ref>. Following CompassQL <ref type="bibr" target="#b65">[65]</ref>, Draco uses a logical representation of the Vega-Lite grammar <ref type="bibr" target="#b52">[52]</ref>.</p><p>Vega-Lite enables concise descriptions of visualizations by encoding data as properties of graphical marks. The language is inspired by other high-level visualization languages such as Wilkinson's Grammar of Graphics <ref type="bibr" target="#b64">[64]</ref>, Wickham's ggplot2 <ref type="bibr" target="#b63">[63]</ref>, and the VizQL formalism underlying Tableau. Vega-Lite represents single plots using a set of encoding definitions that map data fields to visual channels such as position, color, shape, and size. Encodings may include common data transformations such as binning, aggregation, sorting, and filtering. Vega-Lite was specifically designed to facilitate search and inference over the space of possible visualizations <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b65">65,</ref><ref type="bibr" target="#b66">66]</ref>.</p><p>In addition to single plots, Vega-Lite supports faceting into trellis plots, layering, and arbitrary concatenation. In this paper, we focus on single views and faceted views (using the row and column encoding channels). Previous work has focused on similarly restricted design spaces <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b44">44,</ref><ref type="bibr" target="#b65">65,</ref><ref type="bibr" target="#b66">66]</ref>. This subset of Vega-Lite is capable of expressing a variety of plots of both raw and aggregate data, including bar charts, histograms, dot plots, scatter plots, line graphs, and area graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Constraint-Based Knowledge Representation</head><p>Constraint programming is a declarative programming paradigm with wide applications in scheduling <ref type="bibr" target="#b11">[12]</ref>, graphical design <ref type="bibr" target="#b4">[5]</ref>, and natural language specification <ref type="bibr" target="#b45">[45]</ref>. A constraint program is a set of constraints defining relations among several unknowns (i.e., variables) that must be or should be satisfied by its solutions. Constraints thus restrict the possible values that variables can take, representing partial information about the variables of interest <ref type="bibr" target="#b2">[3]</ref>. Solutions are computed by constraint solvers via inference and search over the constrained space <ref type="bibr" target="#b28">[28]</ref>. In visualization, the design recommendation process (i.e., generating, testing <ref type="bibr" target="#b50">[50]</ref>, subsequent ranking) can be modeled as a constrained combinatorial optimization problem.</p><p>The declarative nature of constraint programming allows users to focus on modeling high-level knowledge, while delegating low-level algorithmic details to off-the-shelf constraint solvers. In contrast, imperative implementations of recommendation systems are often hard to implement efficiently and maintain. For example, CompassQL wastes resources in enumerating and evaluating infeasible solutions. Changes in the specification may require a complete overhaul of generators with an imperative implementation <ref type="bibr" target="#b56">[56]</ref>. When building on a constraint programming language of sufficient expressiveness (such as beyond-NP reach of ASP technology), complex tests can be folded into the generation part without inventing new algorithms <ref type="bibr" target="#b57">[57]</ref>.</p><p>In Draco, we model visualization knowledge using Answer Set Programming (ASP) <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b35">35]</ref>, a declarative constraint logic programming language that seeks to balance expressivity, efficiency, and ease of use. ASP has been deployed in contexts such as decision support systems <ref type="bibr" target="#b41">[41]</ref>, product configuration <ref type="bibr" target="#b59">[59]</ref>, and educational game design <ref type="bibr" target="#b57">[57]</ref>. Draco uses Clingo <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>, a state-of-the-art answer set solver. Clingo leverages conflict reasoning <ref type="bibr" target="#b19">[20]</ref> and heuristics <ref type="bibr" target="#b15">[16]</ref> to direct the search process and efficiently solve problems with up to millions of variables. The Clingo guide <ref type="bibr" target="#b14">[15]</ref> provides a comprehensive resource of the ASP language features that Draco uses ( §3), advice for how to model problems ( §1 and §6), and documentation of the constraint solver ( §7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Learning Preferences</head><p>Both CompassQL and Draco use weights of visualization features to trade-off competing effectiveness criteria. Although the weights can be defined by visualization experts, tuning these weights involves ad-hoc choices that are difficult to maintain and extend, especially when the visualization model is complex.</p><p>Instead, the preference model might be learned from data. For example, VizDeck <ref type="bibr" target="#b29">[29]</ref> learns a linear scoring function that uses data statistics and chart type to predict users' up/down votes on presented charts. However, VizDeck's model features only capture direct correlations between data statistics and chart type, and its learning algorithm is limited to a small set of predefined visualizations.</p><p>To improve expressivity and extensibility, Draco leverages domain knowledge from experts (in the form of soft constraints) as visualization features. Draco's preference model forms a Markov logic network (MLN) <ref type="bibr" target="#b49">[49]</ref>, where the weights corresponding to soft constraints are learnable parameters reflecting preference levels. Draco can capture rich attribute relations using a small number of expert-defined rules due to the expressive and compact nature of MLNs <ref type="bibr" target="#b45">[45,</ref><ref type="bibr" target="#b55">55]</ref>.</p><p>To train a recommendation model, a common practice is to use pairs of incomplete specifications and their corresponding optimal completion <ref type="bibr" target="#b54">[54]</ref>. However, for visualization, such training datasets are not generally available and are hard to obtain because there typically does not exist a single optimal completion. Instead, with Draco we take a learning to rank <ref type="bibr" target="#b36">[36]</ref> approach, where the preference model is learned from ordered pairs of visualizations (i.e., complete specifications). A dataset of ranked pairs can either be harvested from experimental data based on human-subject performance measures or solicited from experts. To learn a preference model, we use RankSVM <ref type="bibr" target="#b27">[27]</ref> over the structural features defined by Draco's soft constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BACKGROUND: ANSWER SET PROGRAMMING</head><p>The building blocks of ASP programs are atoms, literals, and rules. Atoms are elementary propositions that may be true or false. Literals are atoms A or their negation not A. Rules are expressions of the form</p><formula xml:id="formula_0">A :-L 1 , . . . , L n .</formula><p>where each L i is a literal. The atom A of a rule (also called its head) is derivable (true) if all literals in the body (right of :-) L 1 , . . . , L n are true. A positive literal is true if it has a derivation, and a negative literal not B is true if the atom B does not have a derivation. For example, the rule light_on :-power_on, not broken. informally states that the light is on if we can derive that the power is on and there is no reason to say that the lamp is broken <ref type="bibr" target="#b6">[7]</ref>.</p><p>Rules can be bodiless or headless. A bodiless rule, such as power_on :-., simply asserts the fact that its head is true. A fact can also be stated using only its head, e.g., power_on.. Headless rules of the form :-L 0 , . . . , L n are integrity constraints that derive false from their body. Thus, satisfying the body L 0 , . . . , L n results in a contradiction.</p><p>An ASP program consists of a set of rules. Note that not in an ASP program means "not derivable". For example, given the two rules described above, power_on can be derived from a fact (our bodiless rule), while broken cannot. Consequently, we can derive light_on. Such derivations are formally defined as stable models <ref type="bibr" target="#b20">[21]</ref> or answer sets: sets of atoms that are consistent with the constraints, justified by a derivation, and minimal with respect to unknown facts. Answer Set Programming has a constructive flavor: negative literals need only be true, whereas positive ones must also be provable.</p><p>On top of the stable model formalism, the language of ASP <ref type="bibr" target="#b13">[14]</ref> introduces powerful modeling constructs. Aggregate rules of the form l {A 0 , . . . , A n } k are read as: at least l and at most k atoms in the set {A 0 , . . . , A n } are true. Aggregates can appear in the head or body of a rule and aggregate rules can be used to define a design space. We can eliminate answer sets with integrity constraints (headless rules) to restrict the design space. Soft constraints are headless rules with an associated weight and are written as :</p><formula xml:id="formula_1">∼ L 0 , . . . , L n . [w]</formula><p>. Unlike hard constraints, soft constraints may be violated by a solution, but each violation of a soft constraint imposes a penalty (or cost) equal to its weight w. Soft constraints can express preferences in the search. In a program with soft constraints, an answer set is optimal if it minimizes the sum of weighted costs of all violated soft constraints. Although mark(bar). encoding(e0). channel(e0,x). type(e0,ordinal). field(e0,cylinders). encoding(e1). channel(e1,y). type(e1,quant). field(e1,horsepower). aggregate(e1,mean). { "data": {"url": "cars.csv"}, "mark": "bar", "encoding": { "x": { "field": "Cylinders", "type": "ordinal" }, "y": { "field": "Horsepower", "type": "quantitative", "aggregate": "mean" } } }  <ref type="figure">Fig. 2</ref>. An example of a bar chart, its Vega-Lite specification (in Vega-Lite JSON), and its equivalent specification using Draco constraints (in ASP). The specification defines the marktype and encodings, which includes a specification of the fields, data type, and data transformations.</p><p>one can express richer forms of optimization in ASP (such as Pareto optimality for combining preferences without first establishing a fixed trade-off between them) <ref type="bibr" target="#b17">[18]</ref>, the weighting scheme for soft constraints is sufficient for the linear preference models we will learn from data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MODELING VISUALIZATION DESIGN IN DRACO</head><p>In this section, we first describe how we model visualizations as sets of facts. We then explain the design space of our model and how we can query the model with constraints. Modern constraint solvers efficiently search for optimal visualization specifications within a defined space. Imperative systems, which use an exhaustive generate and test method, couple knowledge representation and the algorithm for finding effective designs. In Draco, solutions to the base problem of finding optimal designs should be found via automated search, whereas solutions to the higher level problem of what preferences should be used and how competing preferences are resolved should be determined by designers (via refinement of the design space and preference definition).</p><p>The term "optimal" here does not refer to the definitively best or "correct" visual design, as this would make two arrogant presumptions. First, the system would have to fully understand the user's intentions and their ability to read visualizations-an unlikely proposition. Visualization is always an abstraction where choices are made about what to emphasize. Second, visual analysis is an iterative process, involving any number of visualizations, not just a singular view. By "optimal", we refer to an optimal specification according to a set of formally-defined preferences: the system can find no other visualization that would be scored as preferred to this one. A user-facing application can show more than just an optimal visualization, and a user may select between multiple recommendations or refine their query until they have the right design(s) for their task <ref type="bibr" target="#b65">[65,</ref><ref type="bibr" target="#b66">66]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Mapping Visualization Specifications to Logical Facts</head><p>A Vega-Lite specification describes a single Cartesian plot with a backing dataset, a given mark type, and a set of one or more encoding definitions for the visual channels. <ref type="figure">Fig. 2</ref> shows a Vega-Lite specification for a bar chart. Vega-Lite expects a relational table of records with named fields. The mark type specifies the geometric objects used to visually encode data records. Possible values include bar, point, area, line, and tick. The encodings determine how data fields map to visual properties of the marks. An encoding uses a visual channel such as spatial position (x, y), color, size, shape, or text. A detail channel can be used to add group-by fields in aggregate plots. An encoding includes the data field to visualize and its given data type (nominal, ordinal, quantitative, temporal). The data can also be transformed via binning, aggregation (sum, average, etc.), and sorting. An encoding may specify scales that define how the data domain maps to the visual range or guides that visualize scales (axis and legend). Examples include whether a scale domain should include zero or whether the scale is linear or logarithmic. If omitted, the Vega-Lite compiler will infer defaults based on the channel and data type.</p><p>We represent the Vega-Lite specification, user task, and data schema as a set of atoms. To enable reasoning over atoms, we encode them as predicates (i.e., relations or functions). A predicate defines what value is assigned to an attribute of a visualization specification. To set the mark type, we use a predicate mark/1. 1 For example, mark(bar). defines that the visualization should use the bar mark (i.e., assign the value bar to the attribute mark).</p><p>To define an encoding, we use encoding/1 to establish that it exists. For example encoding(e). declares the encoding e. We then use binary predicates to define properties of the encoding. channel(e,x). defines that the encoding e uses the x encoding channel. The field being visualized is defined with field/2. In addition, we use aggregate/2 to define an aggregation function, bin/2 to discretize continuous data, stack/1 to define whether marks should be stacked, and zero/1 and log/1 to customize scales. Compared to Vega-Lite's JSON syntax, we un-nest scale properties to simplify the logical encoding.</p><p>The data schema is defined as the size of the data num_rows/1 (e.g., num_rows(42).) and facts about data fields. We use fieldtype/2 to specify the data type (string, number, date, . . . ) and cardinality/2 to define how many distinct entries there are, entropy/2 to define the entropy, and extent/3 to set the minimum and maximum values. We see this set of data attributes as a starting point; future extensions of Draco can define other features relevant to automated design.</p><p>We currently model a user's primary task as a single function task/1. Following Kim et al. <ref type="bibr" target="#b30">[30]</ref>, we distinguish between value and summary tasks. Since tasks regard specific fields (e.g., "What is the maximum acceleration across cars?"), fields can be marked as relevant to the task with interesting/2.</p><p>We designed this logical visualization language to be extensible and enable reasoning. For example, we could have defined predicates for each channel such as field_x, aggregate_x. This design would automatically ensure that each channel is only used once; however, it would limit the expressiveness of the language (e.g., detail can in fact be used multiple times) and would make it more difficult to define general constraints over attributes that are not tied to a specific channel. One way of extending Draco is to define new attributes as predicates. For example, to add a data property that measures data skew, we can add kurtosis/2 where the first argument is the field and the second is the kurtosis measure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Representing Design Knowledge as Constraints</head><p>The goal of a visualization model is to distinguish desirable visualizations from undesirable ones. In Draco, our visualization model consists of two parts: the space of all visualizations considered valid, and an evaluation function over the space to measure preferences. <ref type="figure" target="#fig_2">Fig. 3</ref> illustrates the design space. We describe a visualization model in Draco as a declarative answer set program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Design Space Definition</head><p>The design space of a visualization model is defined by a set of constraints. A visualization is considered valid only if all constraints are satisfied. Following best practices in logic program design <ref type="bibr" target="#b34">[34]</ref>, we define the space of possible visualization specifications with two sets of rules: (1) a set of aggregate rules that specifies the domains of the attributes defined in the previous section (mark, encoding, . . . ) and (2) a set of integrity constraints that defines how different attributes can interact with each other.</p><p>We use aggregate rules to define which values can be assigned to a visualization attribute. For example, the rule 1 { mark(bar); mark(line); mark(area); mark(point) } 1. restricts choices of mark to one of bar, line, area or point. Similarly, we can use the constraint 0 { aggregate(E,count), aggregate(E,mean), aggregate(E,median), aggregate(E,sum) } 1 :-encoding(E). to declare that each encoding may have up to one aggregate of count, mean, median, or sum. Note that E is capitalized, which identifies it as a variable. To extend the domain of an attribute (e.g., support tick marks), we would add facts to existing aggregate rules (e.g., by adding mark(tick)). The complete list of aggregate rules, and all other constraints in this section, are included as supplemental material.</p><p>The aggregate rules declare the domain of attributes, but not the validity of interactions of different attribute values. To capture such interactions, we introduce an additional set of constraints. Using ASP notation, we write these constraints as a headless rule (integrity constraint). :-X. is read as "it cannot be the case that X". Integrity constraints can be used to encode expressiveness and restrictions to the attributes of a visualization specification, for example, to match the implementation of Vega-Lite.</p><p>First, we use constraints to rule out specifications that do not specify a valid visualization (i.e., that are ill-formed or ungrammatical). We call these constraints well-formedness constraints. For example, the constraint :-channel(_,shape), not mark(point). is an integrity constraint stating that it cannot be the case that there exists a shape encoding unless the mark that is used to encode data is "point", as other mark types such as area, line, bar, or text cannot encode a shape. Another example is :-log(E), zero(E). which ensures that we do not synthesize a log scale that requires zero in its domain. We also assert that visualizations must use a text mark when the text channel is used (and vice versa) and that only discrete data can be mapped to facet (row and column) channels. Well-formedness depends on the syntax and semantics of the graphical language. We can use constraints to generate only visualization specifications that are supported by a concrete visualization model such as Vega-Lite. For example, Vega-Lite only implements 8 shape types; we can use the integrity constraint :channel(E,shape), cardinality(E,C), C &gt; 8. to model this restriction. When defining the design space, conflicting constraints must be avoided, as they result in an empty space that cannot be satisfied by any visualization.</p><p>Second, we use constraints to eliminate non-expressive visualizations that do not convey all and only the facts in the data. For example :-mark(bar), channel(E,y), continuous(E), not zero(E). ensures that the model will not consider vertical bar charts that do not use zero as a baseline. (We actually implement this as a more general rule :-mark(bar), channel(E,(x;y)), continuous(E), not zero(E)., which also covers horizontal bar charts. Here the semicolon denotes an expansion into disjunctions, implying one constraint for each channel type.) Another expressiveness constraint is :-channel(E,size), type(E,nominal)., which ensures that size is not used to encode nominal data, as size implies an order. We also assert that the size channel is only permitted for compatible marks, that zero baselines are used for area and bar charts, and that bar charts with a color channel encoding use stacking so that bars do not occlude each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Preference Over the Design Space</head><p>We now define an evaluation function over the visualization design space to encode preferences. The (linear) evaluation function maps a valid visualization specification into an integer representing its preference level. This function defines a total ordering over the design space,  <ref type="figure">4</ref>. To find the optimal completion of a partial specification, Draco compiles a user query into a set of constraints that removes all candidates () that do not match the query from the design space illustrated in <ref type="figure" target="#fig_2">Fig. 3</ref>. Draco selects the optimal visualization ( ) within the remaining space.  as illustrated in <ref type="figure" target="#fig_2">Fig. 3</ref>. Instead of defining the evaluation function as a procedure, we use a set of soft constraints to implicitly define it. The weight of a soft constraint reflects its strength: the higher the weight (penalty), the higher cost that violating the constraint imposes on the cost of an answer set. Soft constraints are similar to integrity constraints, but start with :∼ instead of :-and include a weight declared in square brackets. They can be read as "prefer not to . . . ". As an example, the soft constraint :~continuous(E), not zero(E). <ref type="bibr" target="#b4">[5]</ref> states that the model prefers to include zero for continuous fields and that violating the rule increases the cost of the visualization by 5. A soft constraint is appropriate: though omitting a zero baseline for ratio data can mislead <ref type="bibr" target="#b42">[42]</ref>, it is still sometimes reasonable to do. Note that a visualization may violate a soft constraint multiple times. For example, given a visualization with two encodings, the soft constraint above may be violated twice if two of its encodings use continuous fields but omit zero.</p><formula xml:id="formula_2">✓ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ ✘ Fig.</formula><p>In order to extend Draco to support new visualization types or data properties, a visualization expert can add soft constraints to capture intended preferences. For example, in order to extend a visualization model to handle the relation between the new data property kurtosis (as discussed in the previous section) and using a log scale, we add the soft constraint :~kurtosis(F,K), field(E,F), log(E), K &gt; 42. <ref type="bibr">[w]</ref>.</p><p>The set of soft constraints defines a cost model for visualizations in the design space that we can use to evaluate preferences. The cost of a visualization is the sum of the costs of all soft constraint violations multiplied by their count of violations. Concretely, given a set of soft { "data": { "url": "cars.csv" }, "encoding": [ {"channel": "x", "bin": true, "field": "horsepower"} ] } <ref type="figure">Fig. 6</ref>. An example query over the cars dataset, in the form of a partial (incomplete) Vega-Lite specification.</p><p>constraints S = {(p 1 , w 1 ), . . . ., (p m , w m )}, the cost of a visualization specification v is calculated as follows, where n p i is the number of violations of the soft constraint p i by v: Draco's preference model forms a Markov logic network (MLN), a graphical model that integrates logic with statistical reasoning to handle uncertainty in a robust way <ref type="bibr" target="#b49">[49]</ref>. This interpretation as an MLN offers theoretical insight into the expressiveness of our model. The soft constraints are structural features of visualizations that capture hidden relations among visualization attributes, and their weights are learnable parameters reflecting their importance. We discuss MLNs in more detail in the appendix.</p><formula xml:id="formula_3">Cost(v) = ∑ i=1...k w i • n p i (v) Given a visualization v, the vector x = [n p 1 (v), . . . , n p k (v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Completing Specifications by Solving Constraints</head><p>Given a visualization model, a user can query said model for optimal completions of a partially specified visualization. <ref type="figure">Fig. 4</ref> illustrates the search process, while <ref type="figure" target="#fig_4">Fig. 5</ref> summarizes our implementation of it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Partial Specification</head><p>A user's query is a partial specification that describes their incomplete intent for a desired visualization. Our partial specification language allows the user to specify unknown visualization attributes by leaving them blank. Draco also supports converting CompassQL queries and Vega-Lite specifications into queries. In addition to a partial specification, a query can specify the schema of the dataset and the user's primary task.</p><p>As an example, <ref type="figure">Fig. 6</ref> shows a query over the classic cars dataset <ref type="bibr" target="#b0">[1]</ref>. In this query, the user specifies that "I want a visualization that shows binned horsepower along the x-axis". Using this query, Draco must then determine completions of the mark and other attributes of the specified encoding, as well as whether other encodings are necessary. Draco then searches to find the mark for the chart, completes the specified encoding, and potentially adds additional encodings (including which channels to use, whether to use aggregation, etc.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Queries as Constraints over the Design Space</head><p>To answer a query, Draco first compiles the query into a set of facts and constraints that defines a subspace of visualizations and then searches over the subspace for the lowest-cost specifications <ref type="figure">(Fig. 4)</ref>. Concretely, the subspace is defined by (1) a set of facts describing the dataset specified in the query (Sect. 4.1) and (2) a set of constraints that restrict the available choices for visualization attributes.</p><p>For example, the query in <ref type="figure">Fig. 6</ref> is compiled into a set of facts and constraints. Unless the data schema is provided explicitly, Draco infers a schema (including fields, their types, and data properties) from the provided dataset ("cars.csv") and uses it to generate facts that describe the dataset's size and fields: num_rows(407). fieldtype(name,string). cardinality(name,311). fieldtype(miles_per_gallon,number). cardinality(miles_per_gallon,130). ...</p><p>Based on the partial specification, Draco then generates a fact declaring an encoding e1 and associated constraints. These constraints restrict the design space to specifications with an encoding e1 that uses the x encoding channel for binned values from the horsepower field: encoding(e1). :-not channel(e1,x). :-not field(e1,horsepower). :-not bin(e1,_).</p><p>To find optimal specifications within the subspace, Draco sends data constraints, query constraints, and constraints from the knowledge base to the Clingo solver <ref type="figure" target="#fig_4">(Fig. 5</ref>). For example, Draco suggests the following optimal completion of the query above, which adds a new encoding e2 on the y-axis for a count aggregate.</p><p>encoding(e2). channel(e2,y). aggregate(e2,count).</p><p>Finally, Draco converts the optimal solutions to Vega-Lite specifications and returns them to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">LEARNING PREFERENCE MODELS</head><p>Although it is possible for model designers to tune preference weights for small models, tuning weights for complex models is challenging: it requires the visualization expert to reason globally about competing conditions among different preferences. In this section, we describe a learning algorithm that allows the model to learn soft constraint weights w = [w 1 , ..., w k ] from ranked pairs of visualizations.</p><p>We learn weights using a RankSVM (Support Vector Machine) model <ref type="bibr" target="#b27">[27]</ref> trained on labeled visualization pairs. Given a visualization pair (v 1 , v 2 ), the cost model should determine whether or not v 1 is preferred to v 2 based on sign(Cost(v 1 ) − Cost(v 2 )). This model can be learned from a dataset where each entry (v 1 , v 2 ; y) is a visualization pair associated with a label y indicating if v 1 is preferred to v 2 (y = −1) or vice versa (y = 1). Given a visualization model with a set of soft constraints S = {p 1 , . . . , p k }, we show how we train the cost model (i.e., training weights w = [w 1 , ..., w k ] for S) using a dataset</p><formula xml:id="formula_4">D = {(v 11 , v 12 ; y 1 ), . . . , (v n1 , v n2 ; y n )}.</formula><p>As shown in Sect. 4.2.2, the cost of a visualization v is determined by its feature vector</p><formula xml:id="formula_5">x = [n p 1 (v), . . . , n p k (v)]</formula><p>. Accordingly, we first run Clingo on the complete specifications and count how often each soft constraint is violated to vectorize all visualizations in the dataset D and obtain their vector representation:</p><formula xml:id="formula_6">D = {(x 11 , x 12 ; y 1 ), . . . , (x n1 , x n2 ; y n )}.</formula><p>The cost model is a linear model over soft constraint weights. Given a pair (v 1 , v 2 ) with feature vectors x 1 , x 2 , its class is determined by the sign of the following function:</p><formula xml:id="formula_7">f (v 1 , v 2 ) = Cost(v 1 ) − Cost(v 2 ) = w T (x 1 − x 2 )</formula><p>Using the RankSVM algorithm to train weights w, we perform linear regression (with L 2 regularization) over the dataset D by minimizing the hinge loss. The loss function L is defined as follows, and it is minimized by the solution w * .</p><formula xml:id="formula_8">L = 1 n k ∑ i=1 max 0, 1 − y i w T (x i1 − x i2 ) + λ w 2 w * = arg min w L</formula><p>As the cost model is a linear model over inputs (x i1 − x i2 ), the weights w * can be efficiently found using an off-the-shelf linear optimizer. By minimizing the loss function L, we obtain a cost model with weights w * that is most consistent with the rankings of visualization pairs in the dataset. The order of v 1 , v 2 in a visualization pair from the training data does not matter, as the classification problem is symmetric with respect to the origin (−y i w T (x i1 − x i2 ) = y i w T (x i2 − x i1 ) in the loss function). Thus, a pair (v 1 , v 2 ; y) is equivalent to (v 2 , v 1 ; −y) in the training set and we can standardize all pairs in the form</p><formula xml:id="formula_9">(v 1 , v 2 ; −1) (such that v 1 is preferred over v 2 )</formula><p>without worrying about an imbalance between classes. For our initial experiments, we set the regularization parameter λ to 0.1.</p><p>By integrating the learned weights w * , the visualization model becomes a knowledge base for visualization recommendation that integrates both expert knowledge and empirical data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DEMONSTRATION OF DRACO</head><p>We present three applications of Draco to demonstrate its expressivity, extensibility, and usability. First, we implement APT's preference rules via a set of strict preference constraints (Draco-APT); this shows Draco can express a classic yet useful automated design system. Next, we reimplement CompassQL by adding soft constraints with weights handtuned by experts to match the semantics of CompassQL (Draco-CQL). Finally, we introduce additional effectiveness criteria learned from data from two different studies (Draco-Learn); this shows how Draco can partially automate combining effectiveness results from different research studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Reimplementing APT: Draco-APT</head><p>Draco-APT provides a re-implementation of APT's channel preferences as a set of soft constraints. APT uses a principle of importance ordering: each field is assigned to the most effective channel (for the corresponding data type) in order of decreasing user-specified importance.</p><p>Draco-APT starts with the set of well-formedness and expressiveness constraints from Sect. 4.2. We add a set of soft constraints to express channel preferences. Each preference constraint is of the form :t ype(E,T), channel(E,C), priority(E,P). [w@P,E], which states that for any encoding E, using channel C for a field of type T incurs a cost of w at priority level P equivalent to the priority of the field. To determine the optimal solution, the solver first satisfies all hard constraints followed by soft constraints, ordered by priority level. Using Draco-APT, we can find optimal completions of partial specifications using APT's effectiveness criteria. For example, given a query with four fields with decreasing priority-two quantitative fields (encoded as e_q1 and e_q2), one nominal field (e_n), and one ordinal field (e_o)-Draco-APT synthesizes the following two optimal results. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Reimplementing CompassQL: Draco-CQL</head><p>We now show that Draco is expressive enough to re-implement Com-passQL <ref type="bibr" target="#b65">[65]</ref>, a state-of-the-art automated visualization design system that includes additional forms of effectiveness knowledge. We compare the original CompassQL implementation with our new implementation,</p><p>showing Draco-CQL is more concise, extensible, and provides superior performance when searching for optimal visualizations. CompassQL uses a generate and test approach <ref type="bibr" target="#b50">[50]</ref>: for a given partial specification, CompassQL generates all matching full specifications. The changes made to the partial specification may include both data query parameters (e.g., fields, aggregation) and encoding parameters (e.g., channels). It then uses data query, encoding, and expressiveness constraints similar to those described in Sect. 4.2 to eliminate invalid encodings. The system then assigns each valid candidate an effectiveness score. The scoring function incorporates preferences for type-channel interactions (e.g., it is preferred to encode nominal fields using x or y before using row or column) and mark-type interactions (e.g., point marks are preferred over tick marks for quantitative by quantitative plots). These effectiveness scores are then used to rank and recommend visualizations. Critically, this approach allows CompassQL to trade off among competing preferences.</p><p>We identified two places for improvement in the process taken by CompassQL. First, CompassQL generates and tests all possible candidate visualizations, which leads to an ineffective exhaustive search. By expressing the hard constraints as integrity constraints, we can pass this process off to a modern constraint solver. Moreover, ASP allows for concise representations. For example, the constraint that invalidates encodings that reuse channels that should only be used once, requires 14 lines of JavaScript code in CompassQL but can be expressed in Draco as :-single_channel(C), 2 { channel(_,C) }. stating that we prefer not to use a single channel 2 or more times.</p><p>Second, CompassQL's scoring function can be expressed naturally in Draco with soft constraints. For example, CompassQL penalizes aggregation when grouping by a continuous field, implemented in 12 lines of code. Draco's implementation is more concise and readable:</p><p>:~aggregate(_,_), continuous(E), not aggregate(E,_). <ref type="bibr" target="#b2">[3]</ref>.</p><p>Reimplementing CompassQL in Draco requires authoring soft constraints that express CompassQL's imperative rankings and design preferences. These constraints include channel, mark type, and aggregation function rankings as well as soft constraints to prefer compact layouts (e.g., fewer encodings) or promote best practices such as placing time on the horizontal axis. For example, channel preferences for nominal fields can be expressed as follows, where lower weights (penalties) indicate higher preference:</p><p>:~channel(E,y), type(E,nominal). [0] :~channel(E,x), type(E,nominal). <ref type="bibr" target="#b0">[1]</ref> :~channel(E,row), type(E,nominal). <ref type="bibr" target="#b5">[6]</ref> :~channel(E,column), type(E,nominal). <ref type="bibr" target="#b6">[7]</ref> :~channel(E,color), type(E,nominal). <ref type="bibr" target="#b6">[7]</ref> :~channel(E,shape), type(E,nominal). <ref type="bibr" target="#b7">[8]</ref> :~channel(E,text), type(E,nominal). <ref type="bibr" target="#b8">[9]</ref> :~channel(E,detail), type(E,nominal). <ref type="bibr" target="#b19">[20]</ref> Using a full set of these constraints, Draco-CQL synthesizes identical optimal specifications as CompassQL for all 17 partial specifications included in CompassQL's test suite. It does so while reducing specification complexity. Draco-CQL is implemented as 70 hard and 110 soft constraints. In contrast, CompassQL is implemented in 4, 324 lines of imperative code, with 1, 134 of those lines devoted to hard constraints and 786 devoted to scoring logic.</p><p>Draco-CQL also exhibits better performance, especially for highly unconstrained problems. <ref type="figure">Fig. 7</ref> shows the results of a benchmark study comparing CompassQL and Draco-CQL across varied numbers of input dataset fields and output encoding channels. All measurements were taken on CentOS Linux 7 with an Intel Xeon CPU E5-2690 v3 with 2.60GHz; CompassQL used Node v9.9.0. Other than a constant startup overhead, Draco exhibits superior scalability. On a real dataset with 25 fields and a query with 5 encodings, Draco returns an answer in less than half a second. In contrast, CompassQL's exhaustive search runs out of heap memory after a few minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Learning Preferences from Experiments: Draco-Learn</head><p>When developing automated visualization design systems, developers may hand-tune weights until the system synthesizes the desired Runtime in Seconds <ref type="figure">Fig. 7</ref>. Median runtime for CompassQL (blue) and Draco (orange) across different numbers of data fields and encodings. CompassQL performance rapidly degrades with additional encodings and runs out of heap memory (set to 4GB) for most queries with four or more encodings because it exhaustively searches all combinations of fields in the schema.</p><p>specifications across test cases. This process is time-consuming and error-prone. Instead, Draco can automatically learn parameters from data. Draco's preference model allows competing preferences and, via learning to rank, can learn weights for soft constraints from ranked pairs of visualizations. The same generalizability and validity issues that all empirical studies have also apply to Draco's empirically learned weights. Draco's flexible learning system allows us to harvest training pairs from data originating from different experimental studies, even those carried out under different conditions.</p><p>To demonstrate this advantage, we harvested ranked pairs from two recent experiments on effectiveness. Kim et al. <ref type="bibr" target="#b30">[30]</ref> measured subject performance across task types and data distributions. They compared performance across 12 scatterplot encoding specifications of trivariate data involving 1 categorical and 2 quantitative fields, encoded with x and y channels along with the color, size, or row channel -in total, 185,000 responses from 1,920 participants. The visualizations tested by Kim et al. are only a fraction of the design space that Draco supports; thus, we are not able to learn the weights of a system that can compete with CompassQL from this data alone. Saket et al. <ref type="bibr" target="#b51">[51]</ref> conducted a similar experiment with 180 participants to evaluate task performance across visualization types. Their study is limited to encodings with one quantitative y-encoding with a mean aggregate, and an x-encoding with nominal, ordinal, or quantitative data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Harvesting Training Data and Learning Weights</head><p>For both studies, the data contains the visualization type, data properties, task, and whether the user correctly completed the task. To create ranked pairs, we first group the response data by data schema and task. Within each group, we group again by visualization and create every possible pair. The difference in task performance between the visualizations in each pair may or may not be significant. We use Fisher's test to check whether the accuracy scores are significantly different between the two visualizations. We keep only pairs where the p-value is lower than a threshold (in our case 0.01). We consider both accuracy and timing results and include a pair if either exhibits a significant difference. Ranked pairs of visualizations could be harvested from other studies in a similar fashion. Our harvesting results in about 1, 100 pairs from Kim et al. and 10 pairs from Saket et al. We get few pairs for Saket et al. because for each data and task combination, only three visualizations are compared (Vega-Lite supports bar, line, and scatter) and few exhibit significant differences.</p><p>We then apply the learning approach described in Sect. 5. First, we transform every visualization that appears in the dataset into a feature vector of soft constraint violation counts in Draco. We start with Draco-CQL's constraints and add soft constraints for the preferences described in Kim et al.'s paper. Specifically, we added rules to capture taskchannel and task-marktype interactions, along with a handful of rules for the most important interactions from the discussion of the paper (see supplemental material for a full listing). We implemented these rules in a few hours. These preference rules can be also included in the CompassQL implementation from the previous section, as we can simply initialize the weights for new constraints to zero. With the new rules, we train a classifier on the difference between the two feature vectors for each pair of ranked visualizations using RankSVM. We trained an off-the-shelf SVM from scikit-learn <ref type="bibr" target="#b43">[43]</ref> on the two datasets derived from the studies by Kim et al. and Saket et al.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Applying the Learned Model</head><p>We first evaluate our trained model directly on ranked pairs by measuring the percentage of pairs that are correctly ranked based on their costs. We train our model on a training set of 55% of the full data, validate on 15% of the data, and assess generalization of the final model with 30% test data <ref type="bibr" target="#b24">[25]</ref>. The trained model achieves 93% accuracy on the test set, whereas Draco-CQL with hand-tuned weights achieves 65% accuracy-only slightly better than chance. Our model achieves perfect training accuracy on the dataset from Saket et al. even if we include all data harvested from Kim et al. Our model was able to learn from different datasets without degrading performance in either of them. The model correctly labels 96% of the validation dataset when we increase the p-value threshold for harvesting from 0.01 to 0.1. We also found that the test accuracy only starts to significantly fall behind the validation accuracy when we train on less than 250 pairs. This observation indicates that there is redundancy in the data and that our model generalizes. These results support our model and feature selection choices.</p><p>In practice, finding the optimal encoding given a dataset, task, and partial specification matters more than accuracy across all ranked pairs of visualizations. For example, correctly ordering the second and third best visualizations may matter less than getting the optimal encoding right. We built Draco-Learn using only the trained weights for the soft constraints in our preference model. First, we restrict the design space to only those encodings used in Kim et al. and Saket et al.'s studies (as described at the beginning of this section) by adding about 10 additional constraints each (included in supplemental material). Adding these constraints adapts Draco-Learn to synthesize only specifications that are in a restricted design space. We then query Draco-Learn to synthesize specifications for all combinations of data properties (cardinality and entropy) and tasks (value and summary). In all conditions (48 for Kim et al., 8 for Saket et al.), Draco-Learn returns a top-performing encoding for the harvested data.</p><p>Draco-Learn outperforms Draco-CQL within the restricted design space covered by the experimental data. <ref type="figure" target="#fig_9">Fig. 8</ref> shows the optimal visualizations synthesized by Draco with default weights (Draco-CQL) and with learned weights (Draco-Learn) for a specification with three encodings across value and summary tasks. In Draco-CQL, the weights for all features related to task are zero. Consequently, Draco-CQL synthesizes the same specification regardless of task: a scatterplot with the primary variable (Q1) on y and category (N) on color. Draco-Learn synthesizes different charts depending on the task. To compare individual values, the scatterplot works well and reduces overplotting. However, to summarize Q1 relative to N, spatially grouping values by category (N) better facilitates perception of distributional properties such as min, max, or average <ref type="bibr" target="#b30">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION AND FUTURE WORK</head><p>We presented Draco, a formal model for visualization knowledge representation, and demonstrated its use for automated visualization design. Draco models visualization design knowledge using constraints and associated weights; this separation of knowledge representation from search procedures enables easier development and maintenance. The Draco-APT and Draco-CQL examples demonstrate how Draco can support increasingly sophisticated visualization design tools with less development effort and better performance than prior approaches. The Draco-Learn example demonstrates that Draco can combine data from different studies to learn weights for a state-of-the-art visualization design tool, further accelerating modeling efforts.</p><p>We now discuss how Draco's constraint system can enable new usage scenarios, such as design space enumeration, visualization model comparison, and design debugging. We go on to describe how future work might address current limitations of Draco's implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Draco from a Software Engineering Perspective</head><p>Draco's use of constraint programming enables easier development and maintenance of automated visualization design tools. Due to implementation complexity, prior approaches often have to compromise the implementation of effectiveness criteria. Although Draco does not completely solve this problem, it shifts the problem to the more tractable and well-defined problem of defining weights to trade-off competing preferences. We show that these weights can be effectively learned from data even when the dataset is assembled from different sources. Using constraints also decouples knowledge representation from the code that applies that knowledge. Although this approach aims to benefit visualization tool developers, it may also benefit end-users as it makes knowledge bases easier to contribute to. Visualization researchers can disseminate their results as constraints to make them more easily accessible by visualization designers; in a declarative system, designers might use more nuanced models that would otherwise be too complex to maintain. We contend that software engineering and developer productivity should be given more attention in the visualization community. Human designers should focus on the design of the visualization design space and preferences rather than the design of search algorithms that are already available in domain-independent constraint solvers.</p><p>Draco's knowledge base can be adapted or extended to fit specific needs. Each component of Draco can be easily modified: the definition of the design space, the preferences within the valid solution space, their weights, and how the visualization model is queried. For example, in Sect. 6.3.2, we limited the design space to scatter plots with three encodings (two quantitative, one nominal). The same expressiveness and preference constraints could be used in a tool that targets full Vega-Lite specifications or in a tool that targets only specific visualizations, such as vertical bar charts. Similarly, Draco can be extended with richer descriptions of input data (Sect. 4.1) that can then be referenced by new soft constraints (Sect. 4.2.2). A researcher who wants to extend the Draco knowledge base with new design rules could distribute their rules as an independent set of constraints or updates to the weights.</p><p>We hope that Draco's current set of constraints can serve as the starting point of an evolving knowledge base that can be extended by researchers and practitioners. For example, Draco could be extended to include richer task taxonomies <ref type="bibr" target="#b1">[2]</ref>. One challenge for visualization design tools is that the "task" is typically inaccessible (e.g., within a user's mind). Natural language interfaces may be better suited for communicating user intent <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b60">60]</ref>, which could then be expressed as Draco constraints. The visualization model in this paper supports synthesis of marks, encodings, and simple transformations (binning and aggregation). We plan to extend the model to transformations such as filtering and sorting, and incorporate Vega-Lite's interaction primitives <ref type="bibr" target="#b52">[52]</ref>.</p><p>We are excited to explore how our visualization model can be extended to support chart composition, for instance into layered views or dashboards. Applying design guidelines to multiple charts separately can lead to locally effective, yet globally inconsistent views <ref type="bibr" target="#b47">[47]</ref>. For example, different fields might confusingly be encoded with the same color scheme across charts. With the right set of weighted constraints, Draco could trade-off among the effectiveness of single views and global consistency within a multi-view display <ref type="bibr" target="#b47">[47,</ref><ref type="bibr" target="#b66">66]</ref>.</p><p>In our demonstration of Draco-Learn, we modeled a restricted subspace of visualizations that mirrors the limits of the available experimental data. We hope to encourage more researchers to make data from effectiveness studies available, such that their results may be used by Draco or related systems. Future work might provide tools to help researchers convert their results into constraints or ranked pair datasets. We plan to collect more comprehensive data by systematically generating visualization pairs and having human subjects evaluate them. In addition to independent studies, we might leverage Draco's design space to guide data collection in an active learning process.</p><p>With sufficient data, it may even be possible to go beyond learning weights and attempt to learn preference rules themselves. The AI community uses inductive logic programming methods to infer logic programs from databases of positive and negative examples <ref type="bibr" target="#b48">[48]</ref>. To learn from noisy data (common in the visualization domain!), we could combine inductive logic programming with statistical models such as Markov logic networks <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b32">32]</ref>. For example, Law et al.'s ILASP (Inductive Learning of Answer Set Programs) <ref type="bibr" target="#b33">[33]</ref> is a logic-based learning system that can learn preferences in answer set programs. To understand differences in preferences represented by two or more distinct data sources, we can use multi-objective (Pareto) optimization in ASP to enumerate designs that map the trade-off frontier.</p><p>Because the effectiveness of a visualization can depend on lowlevel features not captured in a high-level specification (for example, over-plotting), we can imagine applying a re-ranking strategy in which Draco enumerates a number of top-scoring candidate designs (ranked by high-level features) that are then re-ranked by another learned classifier operating on low-level features that may be impractical to model directly in ASP. The sub-symbolic models learned by such classifiers could constitute another valuable form of visualization design knowledge to represent and share.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Beyond Automated Visualization Design</head><p>Up to this point, we have positioned Draco as a tool for synthesizing optimal visualization designs from partial specifications. However, Draco could be used in a variety of other contexts. In the following, we discuss four directions that Draco could be extended.</p><p>First, Draco can be used as a general "visualization spell checker" to validate and auto-correct designs independently, or within a broader system for people to "learn by doing". Currently, Draco is able to use expressiveness and effectiveness constraints to report errors for designs that violate design guidelines. However, given a visualization, we could extend Draco to additionally automatically correct the visualization, removing the most severe violations and suggesting alternative valid designs to users. The problem of finding the minimal set of constraints that need to be removed for the remaining constraints to be satisfiable is known as the unsatisfiable cores problem <ref type="bibr" target="#b9">[10]</ref>; related techniques could be applied to visualization design constraints. Draco might also explain those violations and why they matter, to teach students or visualization designers about best practices, help them spot (intentionally or unintentionally) misleading visualizations, critique visualizations, and perhaps contribute new visualization knowledge or explanations.</p><p>Second, Draco can facilitate exploration of the visualization design space. Besides surfacing violations of design guidelines, Draco can rank visualizations by their costs. Designers might use this function of Draco to choose among different alternative designs. Draco could also be used to cluster designs based on their violations (using the same feature vectors used in our learning to rank approach). An exciting avenue for future research is to use Draco's design space definition to systematically generate visualizations to build a corpus of visualizations and interactions. Creating such a corpus is as simple as running Clingo on the Draco design space definition without preferences, which enumerates all valid answer sets. Testing generated designs with human subjects will allow us to understand the costs and benefits of different encodings and interactions. Although the current design space in Draco is limited, as noted above we plan to extend the model further, including interaction primitives such as Vega-Lite selections <ref type="bibr" target="#b52">[52]</ref>.</p><p>Third, Draco can be used as a tool for researchers to compare the implications of different effectiveness studies. Concretely, if a researcher finds a new design guideline, they could add it to Draco as a constraint and assess whether it conflicts with, or is subsumed by, existing design guidelines. Based on comparison results, researchers could share their design results as constraints to improve the common knowledge base of visualization design tools.</p><p>Lastly, an important future extension is tooling to support developers, researchers, and designers. In addition to collecting more data to learn preference weights, we hope to provide tools to browse the visualization design space and knowledge base rules, as well as tools to understand violations and fine-tune trade-offs among competing design guidelines. With the right tooling and fine-tuned visualization models, Draco's declarative approach to automated visualization design could bring us one step closer towards building assistive interfaces for effective design that canvas a much broader swath of the visualization design space. Such interfaces should allow visualization designers to consider a greater variety of approaches, while also focusing on the creative aspects of visualization design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix: Preference Models as Markov Logic Networks</head><p>Our preference model forms a Markov logic network (MLN) <ref type="bibr" target="#b49">[49]</ref> that describes a distribution over visualizations. In MLNs, soft constraints are structural features of the model, and their weights reflect the difference in log probability between a visualization satisfying the constraint and one that does not. The joint distribution modeled by a MLN is:</p><formula xml:id="formula_10">P(v) = e −Cost(v) ∑ u∈V e −Cost(u) = e − ∑ k i=1 w i n p i (v) ∑ u∈V e − ∑ k i=1 w i n p i (u)</formula><p>The probability P(v) of a visualization in the distribution is its exponentiated cost normalized by the exponentiated costs of all visualizations in the design space V , using a softmax function. Note that the partition function Z = ∑ u∈V e − ∑ k i=1 w i n p i (u) is a fixed term in a given visualization model, and the difference of costs of two visualizations v 1 , v 2 results in the log difference of their probability in the model.</p><p>The problem of finding the optimal completion of a partial specification is the same as performing maximum a posteriori (MAP) inference in the probability model <ref type="bibr" target="#b54">[54]</ref>. Given a partial specification Y , its optimal completion X maximizes the posterior probability of P(x | y = Y ) (i.e., X = max x P(x | y = Y )). The ASP solver solves this inference problem efficiently by minimizing the overall cost of the generated visualization; it is not necessary to compute the partition function.</p><p>Since a MLN is a linear model over structural features rather than linear model directly over attributes, it has the advantage of capturing structural relations between attributes that cannot be captured otherwise. For example, a channel ranking that is independent of the data type would have to prefer color and size independent from the data type. Moreover, as opposed to explicitly representing correlations between every attribute and all other attributes, a MLN is more compact and interpretable.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>A model of automated visualization design tools, inspired by APT. One component synthesizes a design from data and incomplete specifications, and the other renders the design. Draco produces Vega-Lite specifications as output.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Illustration of the design space in Draco. The set of valid Vega-Lite specifications is a subset of all possible visualizations, and Draco's design space overlaps with that subset. Given a preference model, expressive visualizations are ranked according to their preference scores in the model. Draco eliminates ill-formed or non-expressive specifications using hard constraints and encodes preferences using soft constraints.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Our implementation of the optimal encoding search process using constraints. Draco compiles a user query (including the dataset, the partial specification, and the task) into a set of rules and combines them with the existing knowledge base to form an ASP program. Draco then calls Clingo to solve the program to obtain the optimal answer set. Finally, Draco translates the answer set into a Vega-Lite specification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>)] fully determines the cost of v in the given visualization model, and we refer to x as the feature vector of v. Using the feature vector x, the cost of v can be represented asCost(v) = x T w, where w = [w 1 , . . . , w k ]is the vector consisting of all soft constraint weights. Note that setting the weight w for this new rule requires the expert to know the existing constraints and carefully trade-off among competing preferences. In Sect. 5, we instead present a method to learn w from data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>:</head><label></label><figDesc>~type(E,quant), channel(E,x), priority(E,P). [1@P,E] :~type(E,quant), channel(E,y), priority(E,P). [1@P,E] :~type(E,quant), channel(E,size), priority(E,P). [2@P,E] :~type(E,quant), channel(E,color), priority(E,P). [3@P,E] :~type(E,ordinal), channel(E,x), priority(E,P). [1@P,E] :~type(E,ordinal), channel(E,y), priority(E,P). [1@P,E] :~type(E,ordinal), channel(E,color), priority(E,P). [2@P,E] :~type(E,ordinal), channel(E,size), priority(E,P). [3@P,E] :~type(E,nominal), channel(E,x), priority(E,P). [1@P,E] :~type(E,nominal), channel(E,y), priority(E,P). [1@P,E] :~type(E,nominal), channel(E,color), priority(E,P). [2@P,E] :~type(E,nominal), channel(E,shape), priority(E,P). [3@P,E] :~type(E,nominal), channel(E,size), priority(E,P). [4@P,E]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>1</head><label></label><figDesc>channel(e_q1,y) channel(e_q2,x) channel(e_n,color) channel(e_o,size) → 2 channel(e_q1,x) channel(e_q2,y) channel(e_n,color) channel(e_o,size) →</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Q1Fig. 8 .</head><label>8</label><figDesc>The optimal visualization synthesized by Draco with hand-tuned weights (left) and Draco with learned weights (rights) for two queries with varying tasks. Draco with default weights cannot distinguish by task as the weights for all soft constraints related to task are set to zero.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Per Prolog traditions, predicates are identified by their symbolic name and the number of arguments they take (signified with /n).</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We are immensely grateful to Alan Borning, Kevin Jamieson, Pedro Domingos, Kanit "Ham" Wongsuphasawat, and Danyel Fisher whose advice shaped this work. We also thank members of the HCI group at UW and the anonymous reviewers for their feedback. This work was supported by a Moore Foundation Data-Driven Discovery Investigator Award and the National Science Foundation (IIS-1758030).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Instance-based prediction of real-valued attributes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Aha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Kibler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Albert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Low-level components of analytic activity in information visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Amar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
		<idno type="DOI">10.1109/INFOVIS.2005.24</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Information Visualization</title>
		<meeting><address><addrLine>Minneapolis, MN, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-10" />
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Constraint programming: What is behind</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Barták</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CPDC99</title>
		<meeting>CPDC99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="7" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Semiology of graphics: diagrams, networks, maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bertin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ThingLab -an object-oriented system for building simulations using constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Borning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Joint Conference on Artificial Intelligence</title>
		<meeting>the 5th International Joint Conference on Artificial Intelligence<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977" />
			<biblScope unit="page" from="497" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A principled way of assessing visualization literacy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Boy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Rensink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bertini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Fekete</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2014.2346984</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1963" to="1972" />
			<date type="published" when="2014-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Answer set programming at a glance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Brewka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Truszczyński</surname></persName>
		</author>
		<idno type="DOI">10.1145/2043174.2043195</idno>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="92" to="103" />
			<date type="published" when="2011-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Task-analytic approach to the automated design of graphic presentations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Casner</surname></persName>
		</author>
		<idno type="DOI">10.1145/108360.108361</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="151" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Graphical perception: Theory, experimentation, and application to the development of graphical methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">S</forename><surname>Cleveland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mcgill</surname></persName>
		</author>
		<idno>doi: 10. 1080/01621459.1984.10478080</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">387</biblScope>
			<biblScope unit="page" from="531" to="554" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An efficient algorithm for the minimal unsatisfiability problem for a subclass of cnf</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Davydov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Davydova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">K</forename><surname>Büning</surname></persName>
		</author>
		<idno type="DOI">10.1023/A:1018924526592</idno>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="229" to="245" />
			<date type="published" when="1998-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Learning explanatory rules from noisy data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grefenstette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="1" to="64" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Constraint-Directed Search: A Case Study of Job-Shop Scheduling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Fox</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983-12" />
			<pubPlace>Pittsburgh, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Datatone: Managing ambiguity in natural language interfaces for data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dontcheva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Adar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">G</forename><surname>Karahalios</surname></persName>
		</author>
		<idno type="DOI">10.1145/2807442.2807478</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual ACM Symposium on User Interface Software and Technology, UIST &apos;15</title>
		<meeting>the 28th Annual ACM Symposium on User Interface Software and Technology, UIST &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="489" to="500" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Abstract gringo. TPLP</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="449" to="463" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Potassco user guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lindauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ostrowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Thiele</surname></persName>
		</author>
		<ptr target="https://github.com/potassco/guide/releases/" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
		<respStmt>
			<orgName>Institute for Informatics, University of Potsdam</orgName>
		</respStmt>
	</monogr>
	<note>second edition edition</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Answer Set Solving in Practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
		<idno>doi: 10.2200/ S00457ED1V01Y201211AIM019</idno>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Artificial Intelligence and Machine Learning</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="238" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
		<idno>abs/1405.3694</idno>
	</analytic>
	<monogr>
		<title level="j">Clingo = ASP + control: Preliminary report. CoRR</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Complex optimization in answer set programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-07" />
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Potassco: The potsdam answer set solving collection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ostrowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Commun</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="107" to="124" />
			<date type="published" when="2011-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Conflict-driven answer set solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2007, Proceedings of the 20th International Joint Conference on Artificial Intelligence</title>
		<meeting><address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page">386</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The stable model semantics for logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>MIT Press</publisher>
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Perception of average value in multiclass scatterplots</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gleicher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Correll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Nothelfer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Franconeri</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2013.183</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2316" to="2325" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Vizql: a language for query, analysis and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<idno type="DOI">10.1145/1142473.1142560</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page">721</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Ranking visualizations of correlation using weber&apos;s law</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Franconeri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chang</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2014.2346979</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1943" to="1952" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The elements of statistical learning: data mining, inference, and prediction, 2nd Edition. Springer series in statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hastie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tibshirani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Friedman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Crowdsourcing graphical perception: Using mechanical turk to assess visualization design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th</title>
		<meeting>the 28th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<idno type="DOI">10.1145/1753326.1753357</idno>
		<title level="m">Annual Chi Conference on Human Factors in Computing Systems</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="203" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Support vector learning for ordinal regression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Herbrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Graepel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Obermayer</surname></persName>
		</author>
		<idno type="DOI">10.1049/cp:19991091</idno>
	</analytic>
	<monogr>
		<title level="m">Ninth International Conference on Artificial Neural Networks ICANN 99. (Conf. Publ. No. 470)</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="97" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Constraint logic programming: A survey. The journal of logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="503" to="581" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Vizdeck: self-organizing dashboards for visual analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Key</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Aragon</surname></persName>
		</author>
		<idno type="DOI">10.1145/2213836.2213931</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2012</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data, SIGMOD 2012<address><addrLine>Scottsdale, AZ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="681" to="684" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Assessing effects of task and data distribution on the effectiveness of visual encodings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroVis)</title>
		<meeting>EuroVis)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">GraphScape: A model for automated reasoning about visualization similarity and sequencing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hullman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1145/3025453.3025866</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems, CHI &apos;17</title>
		<meeting>the 2017 CHI Conference on Human Factors in Computing Systems, CHI &apos;17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2628" to="2638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Learning the structure of markov logic networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kok</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<idno>doi: 10. 1145/1102351.1102407</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd International Conference on Machine Learning, ICML &apos;05</title>
		<meeting>the 22Nd International Conference on Machine Learning, ICML &apos;05<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="441" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The ILASP system for learning answer set programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Broda</surname></persName>
		</author>
		<ptr target="https://www.doc.ic.ac.uk/~ml1909/ILASP" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Answer set programming and plan generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0004-3702(02)00186-8</idno>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="39" to="54" />
			<date type="published" when="2002-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">What is answer set programming?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd National Conference on Artificial Intelligence</title>
		<meeting>the 23rd National Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1594" to="1597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Learning to rank for information retrieval</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-Y</forename><surname>Liu</surname></persName>
		</author>
		<idno>doi: 10.1561/ 1500000016</idno>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Information Retrieval</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="225" to="331" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Automating the design of graphical presentations of relational information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
		<idno type="DOI">10.1145/22949.22950</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="110" to="141" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Show Me: Automatic presentation for visual analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2007.70594</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1137" to="1144" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Describing complex charts in natural language: A caption generation system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">O</forename><surname>Mittal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Carenini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="431" to="467" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Visualization analysis and design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>CRC press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">An a-prolog decision support system for the space shuttle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nogueira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balduccini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Barry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Symposium on Practical Aspects of Declarative Languages, PADL &apos;01</title>
		<meeting>the Third International Symposium on Practical Aspects of Declarative Languages, PADL &apos;01<address><addrLine>London, UK, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="169" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">How deceptive are deceptive visualizations?: An empirical analysis of common distortion techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Satterthwaite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Nov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bertini</surname></persName>
		</author>
		<idno type="DOI">10.1145/2702123.2702608</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems, CHI &apos;15</title>
		<meeting>the 33rd Annual ACM Conference on Human Factors in Computing Systems, CHI &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1469" to="1478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Scikitlearn: Machine learning in Python</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Thirion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grisel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Prettenhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Dubourg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vanderplas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Passos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cournapeau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brucher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Perrot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Duchesnay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2825" to="2830" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Extracting and retargeting color mappings from bitmap images of visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Poco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mayhua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2744320</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="637" to="646" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Unsupervised semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, EMNLP &apos;09</title>
		<meeting>the 2009 Conference on Empirical Methods in Natural Language Processing, EMNLP &apos;09<address><addrLine>Stroudsburg, PA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Keeping multiple views consistent: Constraints, validations, and exceptions in visualization authoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hullman</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2744198</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="468" to="477" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Keeping multiple views consistent: Constraints, validations, and exceptions in visualization authoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hullman</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2744198</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="468" to="477" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Learning logical definitions from relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF00117105</idno>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="1990-08" />
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="239" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Markov logic networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10994-006-5833-1</idno>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="2006-02" />
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="107" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Data characterization for intelligent graphics presentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">F</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mattis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</title>
		<meeting>the SIGCHI Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="193" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Task-based effectiveness of basic visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saket</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Endert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Demiralp</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2018.2829750</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Vis (Proc. InfoVis)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Vega-Lite: A grammar of interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Satyanarayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2016.2599030</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="341" to="350" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Eviza: A natural language interface for visual analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Setlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Battersby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tory</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gossweiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">X</forename><surname>Chang</surname></persName>
		</author>
		<idno type="DOI">10.1145/2984511.2984588</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual Symposium on User Interface Software and Technology, UIST &apos;16</title>
		<meeting>the 29th Annual Symposium on User Interface Software and Technology, UIST &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Discriminative training of markov logic networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Singla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th National Conference on Artificial Intelligence</title>
		<meeting>the 20th National Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="868" to="873" />
		</imprint>
	</monogr>
	<note>AAAI&apos;05</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Entity resolution with markov logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Singla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDM.2006.65</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Conference on Data Mining, ICDM &apos;06</title>
		<meeting>the Sixth International Conference on Data Mining, ICDM &apos;06<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="572" to="582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A case study of expressively constrainable level design automation tools for a puzzle game</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mateas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Popović</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on the Foundations of Digital Games</title>
		<meeting>the International Conference on the Foundations of Digital Games</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="156" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Quantifying over play: Constraining undesirable solutions in puzzle design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Popovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Foundations of Digital Games, FDG</title>
		<meeting>the Foundations of Digital Games, FDG</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="221" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Answer set programming for procedural content generation: A design space approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mateas</surname></persName>
		</author>
		<idno type="DOI">10.1109/TCIAIG.2011.2158545</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computational Intelligence and AI in Games</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="187" to="200" />
			<date type="published" when="2011-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Developing a declarative rule language for applications in product configuration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Soininen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Niemelä</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Practical Aspects of Declarative Languages, PADL &apos;99</title>
		<meeting>the First International Workshop on Practical Aspects of Declarative Languages, PADL &apos;99<address><addrLine>London, UK, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="305" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Natural language interfaces for data analysis with visualization: Considering what has and could be asked</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroVis</title>
		<meeting>EuroVis</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="55" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Modeling color difference for visualization design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Szafir</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2744359</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="392" to="401" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Four types of ensemble coding in data visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Szafir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Haroz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gleicher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Franconeri</surname></persName>
		</author>
		<idno type="DOI">10.1167/16.5.11</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Vision</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">ggplot2: Elegant Graphics for Data Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wickham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">The grammar of graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wilkinson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Towards a general-purpose query language for visualization recommendation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1145/2939502.2939506</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Human-In-the-Loop Data Analytics -HILDA &apos;16</title>
		<meeting>the Workshop on Human-In-the-Loop Data Analytics -HILDA &apos;16</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Voyager: Exploratory analysis via faceted browsing of visualization recommendations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2015.2467191</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="649" to="658" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Voyager 2: Augmenting visual analysis with partial view specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ouk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1145/3025453.3025768</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems</title>
		<meeting>the 2017 CHI Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2648" to="2659" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
