<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Temporal Treemaps: Static Visualization of Evolving Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wiebke</forename><surname>Köpp</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">KTH Royal Institute of Technology</orgName>
								<address>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tino</forename><surname>Weinkauf</surname></persName>
							<email>wiebkek|weinkauf@kth.se</email>
							<affiliation key="aff0">
								<orgName type="institution">KTH Royal Institute of Technology</orgName>
								<address>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Temporal Treemaps: Static Visualization of Evolving Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Index Terms-Treemaps, Temporal trees</keywords>
			</textClass>
			<abstract>
				<p>We consider temporally evolving trees with changing topology and data: tree nodes may persist for a time range, merge or split, and the associated data may change. Essentially, one can think of this as a time series of trees with a node correspondence per hierarchy level between consecutive time steps. Existing visualization approaches for such data include animated 2D treemaps, where the dynamically changing layout makes it difficult to observe the data in its entirety. We present a method to visualize this dynamic data in a static, nested, and space-filling visualization. This is based on two major contributions: First, the layout constitutes a graph drawing problem. We approach it for the entire time span at once using a combination of a heuristic and simulated annealing. Second, we propose a rendering that emphasizes the hierarchy through an adaption of the classic cushion treemaps. We showcase the wide range of applicability using data from feature tracking in time-dependent scalar fields, evolution of file system hierarchies, and world population.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="figure">Figure 1</ref><p>. Our method optimizes a layout for a series of trees and renders it using an adaptation of cushion rendering. Notably, we support topological changes to the trees such as merges and splits on all hierarchy levels. The shown example displays five time steps in the evolution of a file system hierarchy, roughly resembling the code base for this paper, where folders and files merge, split, appear, and disappear (top). Our method displays these evolving trees in a single layout paying attention to both the merges/splits as well as the hierarchical nesting (bottom).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Hierarchical data structures are common. Filesystems, source code repositories, HTML/XML files, or the organizational structure of states and companies are only few examples. The large amount of different visualization approaches for trees speaks to both the importance of the data type and its ability to spark the interest of the visualization community.</p><p>It is particularly useful to associate data to the nodes of a tree. Different methods can then be used to reveal the largest or smallest parts of the hierarchy. The concept of nested layouts, in particular treemaps <ref type="bibr" target="#b27">[28]</ref>, is a wide-spread visualization approach for such trees.</p><p>Data associated with a tree may change over time and it is of high interest to observe the temporal development of this data. Dynamically adjusting treemaps <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref><ref type="bibr" target="#b36">37]</ref> have been proposed for this. Furthermore, stream graphs enhanced with hierarchical information <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b39">40]</ref> provide a static overview of the entire temporal development of trees with dynamically changing data. This paper deals with trees whose data and topology change over time. Essentially, the entire tree can transform almost arbitrarily as long as it remains a tree. To be precise, we consider a time series of trees with a node correspondence per hierarchy level between consecutive time steps. Tree nodes may appear and disappear, merge and split on all  hierarchy levels, and the associated data may change. We only exclude cases where a child changes its parent.</p><p>Temporally evolving trees can of course be visualized generically by applying any tree visualization method to each individual time step. This is often not satisfying, since discontinuous layout changes make it difficult to observe the data. Recently, Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> presented Nested Tracking Graphs, the first method to address such data. While the method has been described in the context of hierarchically nested graphs, such data can just as well be seen as a time series of trees. Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> represent time statically along a spatial axis and draw nodes as bands of varying thickness along this axis. They are nested inside their parent's band. The method exhibits a large amount of intersections, since the layout algorithm largely ignores the hierarchical relationships. Furthermore, the method has been designed for data where the parent's data value exceeds the sum of the children's data. This makes it inapplicable in the large number of application scenarios where the sum of the children's data equals the parent's data (e.g., a filesystem).</p><p>We give the following contributions:</p><p>• We present a novel layout algorithm for temporally evolving trees with changing topology and data. It considers the entire hierarchy and time span at once to produce a layout with as few intersections as possible. This is based on a combination of a heuristic and a simulated annealing optimization approach. The layout algorithm runs on the order of a few seconds.</p><p>• We propose a rendering scheme that emphasizes the hierarchy through an adaptation of the classic cushion treemaps <ref type="bibr" target="#b37">[38]</ref>. This makes our method applicable to data sets where the sum of the children's data equals the parent's data.</p><p>• We propose a data structure for temporally evolving trees, which records only the changes to the tree. Besides its space-efficiency, it also reduces the computation times of the layout algorithm drastically.</p><p>• We showcase the wide range of applicability using data from feature tracking in time-dependent scalar fields, evolution of file system hierarchies, and world population.</p><p>The paper is organized as follows: Section 2 recollects the theory and previous work around trees, treemaps, and related visualization methods. We present our data structure for temporally evolving trees in Section 3. Our two main contributions, the layout and the rendering, are presented in Section 4. We evaluate our method in Section 5, show results from different domains in Section 6, and conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK AND BACKGROUND 2.1 Trees and Treemaps</head><p>A tree T = (N, E) is a hierarchical data structure with a set of nodes N and a set of directed edges E. Exactly one node is the root of the tree which has only outgoing edges. All other nodes have exactly one incoming edge from their parent, and zero or more outgoing edges to their children. Nodes with no children are called leaves. The hierarchy level of a node is determined as the number of edges in the uniquely defined path from the root to that node. See <ref type="figure" target="#fig_1">Figure 2a</ref>.</p><p>A common and useful way of associating data to a tree is to prescribe data values at the leaves and describe the data at each parent node p as the sum of the data of its children</p><formula xml:id="formula_0">c i d(p) = ∑ d(c i ) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(1)</head><p>A fitting example is a file system hierarchy where the files (leaves) occupy a certain size on disk, while the directories (parents) are a mere container with its size being the sum of their files and subdirectories.</p><p>Treemaps are a common tool for visualizing trees with associated data in a space-filling, nested layout. Each node is drawn in a size that relates to its data and serves as a container for drawing its children. Johnson and Shneiderman <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b27">28]</ref> introduced the general concept: a rectangular space is associated with the root. Its children are drawn by dividing the rectangle along the x-axis in relation to the amount of data per child. This process continues by alternating the partitioning axis in each hierarchy level. <ref type="figure" target="#fig_1">Figure 2b</ref> illustrates this.</p><p>Different treemap layout variations have been proposed. Bruls et al. <ref type="bibr" target="#b7">[8]</ref> strive for creating squares when partitioning the space in order to make tree nodes easier to compare. Bederson et al. <ref type="bibr" target="#b28">[29]</ref> propose treemaps that preserve a given order in the original data. Other shapes than nested rectangles have been proposed as well, including general polygons within rectangles <ref type="bibr" target="#b15">[16]</ref> , Voronoi cells <ref type="bibr" target="#b0">[1]</ref>, and bubbles <ref type="bibr" target="#b17">[18]</ref> with the latter specifically targeting visualizing uncertainty in the data.</p><p>Treemap rendering methods differ in how a node's hierarchy level is displayed. Johnson and Shneiderman <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b27">28]</ref> use boundary lines between the rectangles. Balzer and Deussen <ref type="bibr" target="#b0">[1]</ref> emphasize the hierarchy through boundaries and color variation. Van Wijk and van de Wetering <ref type="bibr" target="#b37">[38]</ref> propose cushion treemaps, which emulate a diffusely lit surface of varying height according to the hierarchy. In this paper, we adapt this strategy for our temporal treemaps, see Section 4.3.</p><p>Note that treemaps can also be defined in other dimensions. As noted already by Shneiderman <ref type="bibr" target="#b27">[28]</ref>, a treemap can be defined in 3D by subdividing a cube or in 1D by recursively subdividing a straight line. Neumann et al. <ref type="bibr" target="#b26">[27]</ref> make use of a 1D nested layout to augment the hierarchical information with non-hierarchical relations. A 1D treemap frees up one display dimension for other information; we will exploit this later for incorporating the time dimension. <ref type="figure" target="#fig_1">Figure 2c</ref> shows a 1D treemap.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Visualization Approaches for Time-dependent Trees</head><p>Time can affect different aspects of a tree: The data at the nodes may change over time, or the topology of the tree may change, or both. Different visualization approaches cover different aspects, as discussed in the following. Consider time-dependent data values on an otherwise static tree. This can be described using a time series at each node [d 1 , . . . , d n ] for n time steps. In the case that the data value of a parent is the sum of its children, it suffices to store the time series at the leaves and restore them at all other nodes using Equation (1).</p><p>Many methods exist to represent several 1D graphs stacked on top of each other. Each individual graph is essentially a thick band representing the evolution of a topic or similar. ThemeRiver by Havre et al. <ref type="bibr" target="#b20">[21]</ref> is among the first ones. The bands are ordered so that the evolution of a single band has as little as possible effect on the other bands. Detailed discussions of the amount of "wiggles" in such visualizations have been made by Byron and Wattenberg <ref type="bibr" target="#b10">[11]</ref> as well as Bartolomeo and Hu <ref type="bibr" target="#b1">[2]</ref>. A number of works <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b39">40]</ref> incorporate hierarchical information into stacked graphs. Hierarchy is conveyed through color encoding <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b39">40]</ref>, joint displaying of a tree <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b39">40]</ref>, or showing hierarchy layers separately <ref type="bibr" target="#b2">[3]</ref> and facilitates interactive exploration of the data <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b39">40]</ref>. In contrast to our approach, the topology of the tree remains static and nodes do not appear or disappear.</p><p>Several approaches extend the treemap concept to show timedependent data on topologically static trees: animation is used to blend between the different time steps. The challenge is to balance between a good treemap layout and the number of layout changes <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref><ref type="bibr" target="#b36">37]</ref>.</p><p>Consider both the topology of the tree and the node data change over time. Recently, Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> presented a method for dealing with this kind of data. While it is phrased orthogonally as a method to work on nested graphs rather than a series of trees, it can just as well be seen as the latter. The method uses the Graphviz library <ref type="bibr" target="#b16">[17]</ref> for the layout and while this produces great results, the final compositing step induces a larger number of intersections/crossings, because the hierarchical information is not used when computing the graph layout. We will detail this in Section 4.1. This paper presents a novel algorithm for the graph layout which is able to produce layouts with less intersections/crossings. Merges and splits in connection to hierarchy have also been explored by Cui et al. <ref type="bibr" target="#b14">[15]</ref>. They visualize the evolution of topics in text corpora. However, not the entire tree is shown in each time step, but rather just a cut through the tree at possibly varying hierarchy levels.</p><p>Burch et al. <ref type="bibr" target="#b9">[10]</ref> draw dynamically changing graphs with a hierarchical nesting next to each other. The resulting edge crossings are anticipated and managed with a splatting technique. Other methods for general dynamic graph visualization are discussed in Beck et al. <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Approaches to Constrained Ordering</head><p>We model our layout computation by creating a constrained ordering of objects. Each constraint requires the involved objects to appear consecutively within the ordering. A similar problem occurs in finding path supports in hypergraphs <ref type="bibr" target="#b8">[9]</ref>. In contrast to regular graphs, edges of hypergraphs can involve more than two nodes. In a path support, all nodes incident to an edge are positioned next to each other. Algorithms exist to compute path supports in polynomial time iff all constraints can be fulfilled <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b21">22]</ref>. However, computing optimal partial solutions, i.e., fulfilling as many constraints as possible if it is impossible to fulfill all constraints, has been shown to be NP-complete <ref type="bibr" target="#b19">[20]</ref>.</p><p>By interpreting leaves as nodes and constraints as edges of a hypergraph, our layout problem can be transformed into a path support problem. However, this neglects the temporal aspect of our nodes which leads to a substantially larger solution space. Nevertheless, future versions of our framework may potentially test for the existence of an optimal solution.</p><p>Apart from our scenario, constrained ordering also occurs in the evolution of stories <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b35">36]</ref>, where the co-location of characters imposes restrictions. The problem has been approached using a hypergraph formulation as above <ref type="bibr" target="#b35">[36]</ref> as well as the computation of an initial solution allowing for interactive reordering to further minimize crossings <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DATA STRUCTURE FOR TIME-DEPENDENT TREES</head><p>A practically useful definition for temporally evolving trees has recently been given by Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref>: a nested tracking graph G = (N, E T , E N ) consists of a set of nodes n t ∈ N where each node has a time step t, a hierarchy level , and a data value d. Edges in E N exclusively describe the hierarchical relationships in a time step, i.e., the restriction of G to a time step t yields a proper tree G| t = ( N| t , E N | t ) as defined above, or possibly a forest of such trees. Edges in E T exclusively connect nodes of the same hierarchical layer , i.e., a restriction G| = ( N| , E T | ) gives a tracking graph, in which nodes may appear, disappear, merge, or split. <ref type="figure" target="#fig_4">Figure 3a</ref> shows an illustration.</p><p>Essentially, nested tracking graphs store a tree per time step and the tracking information in between. This definition serves well when tracking super-or sublevel sets <ref type="bibr" target="#b25">[26]</ref> in time-dependent scalar fields, where every node's data value changes in every time step. However, such a data structure is rather space-consuming when dealing with data sets where only few nodes change in every time step such as in a file system hierarchy: storing an entire file system tree for each change to a file quickly leads to a large number of nodes and edges.</p><p>We define an aggregated temporal tree T = (N , E T , E N ) following the nested tracking graphs of Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> with the adaption that a node n t a ,t b ∈ N exists over a time span [t a ,t b ] and stores a time series of data values</p><formula xml:id="formula_1">[d t a , . . . , d t b ]</formula><p>. This allows for a compact encoding of data values that records only changes. <ref type="figure" target="#fig_4">Figure 3b</ref> shows an illustration.  <ref type="figure">Figure 4</ref>. Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> uses Graphviz <ref type="bibr" target="#b16">[17]</ref> to produce the graph layout in each hierarchy level independently (left). These layouts are optimized to have as few intersections as possible. But when combining all levels into a nested drawing by forcing the children to live inside their parents' space, it becomes apparent that the graph layout has no knowledge of the hierarchical nesting in G, and we get a number of intersections (right). This example has been created with the original software of <ref type="bibr" target="#b25">[26]</ref>. Note that the underlying cause for the intersections is the violation of two hierarchical constraints in the sorting of the leaves in layer 2 , as discussed in Section 4.2 and illustrated in <ref type="figure">Figure 6</ref>. See <ref type="figure">Figure 7</ref> for the result of our method, and <ref type="figure" target="#fig_4">Figure 3</ref> for the underlying data.</p><p>We can use the classic tree terminology also for T . We have different hierarchy levels , parent nodes, children nodes, leaves, etc. In contrast to G, we define T such that it always has a single root from which we can access all other parts of the temporal tree, e.g., by following the hierarchical edges E N .</p><p>While the tree is temporally evolving, it may undergo structural changes. We call them topological events and they are the appearance of a node, the disappearance of a node, the merge of several nodes, and the split into several nodes. Merges and splits are the most important topological events for computing the layout, since they require that the involved nodes are right next to each other. A merge and a split event are indicated in <ref type="figure" target="#fig_4">Figure 3</ref>.</p><p>It is straightforward to convert G into T and vice versa. We convert G into T by eliminating direct temporal correspondences. Two nodes u, v have a direct temporal correspondence, if the edge (u, v) ∈ E T is the only outgoing temporal edge of u and the only incoming temporal edge of v. We aggregate a chain of such nodes and edges into a single node with a time series of data values. We convert T into G by collecting all time steps from all time series in T and deaggregating all nodes n t a ,t b ∈ N into a chain with direct temporal correspondences for all time steps overlapping the range [t a ,t b ].</p><p>Note that in graph theory, nodes are considered zero-dimensional structures whereas our aggregated nodes are one-dimensional entities. As such, aggregated nodes can intersect each other when being drawn in the plane, which translates to an edge crossing in the planar embedding of two node-edge chains. In the rest of the paper, we will often just speak of "nodes" when referring to "aggregated nodes."</p><p>We also note that all algorithms in this paper can be run on the nonaggregated G or the aggregated T , incurring different computational costs. Most notably, the graph layout optimization in Section 4.2.3 has drastically shorter computation times when running on the aggregated T . We evaluate the runtime aspects of our method in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">TEMPORAL TREE MAPS</head><p>Our goal is to create static visualizations of time-varying trees including topological events. We use the two-dimensional plane for our layout: one dimension represents time, while the other dimension represents the hierarchical nesting similar to a 1D treemap layout (cf. <ref type="figure" target="#fig_1">Figure 2c)</ref>.</p><p>The next section characterizes this as a graph drawing problem and reviews the shortcomings of existing approaches. Section 4.2 follows with our own solution to the problem. Section 4.3 presents our adaptation of cushion treemaps to temporal trees. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Characterization as a Graph Drawing Problem</head><p>Our data structure T is a hierarchically nested graph. If we consider for a moment each hierarchy level independently, then the nodes in each level form a directed graph with topological events as given by the edges in E T . This is by itself already a graph drawing problem for each hierarchy level.</p><p>The challenging part is due to the hierarchical nesting: the goal is to draw all these graphs inside each other, i.e., the graph of hierarchy level shall be drawn inside the graph of hierarchy level − 1. This means that a topological event in a layer − 1 has an impact on the graph drawing in layer . For example, consider the merge of two nodes in layer − 1 at time t i . Each of them has children, which have to be drawn in layer such that they are next to each other at time t i to accommodate the merge of the parents. If the children were not next to each other at time t i , they would need to intersect other nodes in order to be drawn inside their newly merged parent from t i onwards. In other words, the hierarchical nesting imposes constraints on the graph drawing in each layer.</p><p>Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> presented the first approach to drawing nested graphs by computing the graph layout in each hierarchy level independently and forcing them to nest inside each other in the final drawing stage. This leads to a large amount of intersections in the final image. The graph layout of each hierarchy level is done using the Graphviz library <ref type="bibr" target="#b16">[17]</ref>. The optimized graph layout of this library makes sure to avoid intersections as much as possible in each hierarchy level. But since no knowledge of the hierarchical nesting is given, the graph layout cannot accommodate the constraints from other hierarchy levels. The final drawing stage then uses only the graph layout of = 0 directly. All other levels force the children to live inside their parents as follows: for a parent p and a time step t i , find the children of p in the graph layout of the children's level and draw them inside p in the same order as they have been encountered in the children's level. <ref type="figure">Figure 4</ref> illustrates how the graph layout of each level is done independently and how this causes the intersections in the final drawing stage. This example has been created with the original software of <ref type="bibr" target="#b25">[26]</ref>.</p><p>It should be noted that it is not always possible to draw a graph intersection-free. It is well-known that not every graph can be embedded in the plane <ref type="bibr" target="#b4">[5]</ref>. In addition to that, our setting restricts the embedding, namely the nodes are aligned with time steps, i.e., their x-coordinate is fixed. <ref type="figure" target="#fig_6">Figure 5</ref> shows an example of this. While an intersection-free layout cannot be expected for every data set, we should strive for a minimal number of intersections. This is the topic of the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Graph Layout using Constrained Sorting of Leaves</head><p>The nested drawing of a temporal tree T requires the joint consideration of the topological events in each hierarchy level as well as the constraints due to the hierarchical nesting. We bring both requirements into a common setting, where we search for a solution with a minimal number of intersections.</p><p>Our approach centers around ordering the leaves of T . We will impose constraints on this order that follow directly from the topological events and the hierarchical nesting of T . We propose a fast heuristic and an optimization approach to find an ordering that fulfills most constraints. Given a leaf order for T , we show how to compute a sorting order for all other nodes of T . Details follow below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Ordering and Constraints</head><p>Let B = {b 1 , . . . , b n } be the set of all leaves of the temporal tree T with B ⊆ N . We aim to establish an ordering for the leaves, denoted by σ = (b 1 , . . . , b n ), which is essentially an ordered sequence of the elements of B, or a permutation. This can be seen as a function where σ (b i ) returns the index of b i in the ordering. Since a node of a temporal tree exists only over a certain time span, we introduce the notation σ | t a ,t b as the order of all leaves whose lifetime overlaps with the time span [t a ,t b ]. This restricted ordering is directly obtained from the unrestricted ordering σ by removing leaves that do not exist in this time span and keeping the relative order of all other elements. If we want to address the ordering of a subset G of the leaves, independent of a time span, we use the notation σ | G .</p><p>We introduce an ordering constraint as a tool to require that a certain set of leaves is next to each other in a given time span. More formally, consider a set of leaves G = {g 1 , . . . , g n } which at least partially overlap with the time span [t a ,t b ]. The ordering constraint C = (G,t a ,t b ) is fulfilled if these leaves are next to each other in the corresponding ordering, which can be expressed as</p><formula xml:id="formula_2">|G| = max G σ | t a ,t b − min G σ | t a ,t b + 1.<label>(2)</label></formula><p>Note that we do not require a specific ordering for the leaves in G, only that there is no other leaf between them. We now have the formalism required to describe the hierarchical nesting of T and its topological events as ordering constraints. We introduce the following constraints on the leaf order:</p><p>• A hierarchical constraint imposes that the leaves reachable from an internal node p are next to each other during the lifetime of p.</p><p>The internal node p can be any non-leaf node of T . Considering its lifetime [t a ,t b ], a hierarchical constraint is formally written as C H = (leaves(p),t a ,t b ).</p><p>• A topological constraint imposes that the leaves reachable from merging and splitting nodes are next to each other at the time step of the event. A merge/split event occurs at time step t i and includes the nodes L whose lifetime ends at t i by merging and/or splitting into the nodes R whose lifetime starts at t i+1 . A topological constraint is formally written as C T = (leaves(L ∪ R),t i ,t i+1 ). <ref type="figure">Figure 6</ref> illustrates these constraints using the same example that we used already earlier.</p><p>Assume an ordering constraint C = (G,t a ,t b ) is not fulfilled for a given ordering σ . This means, the leaves G = {g 1 , . . . , g n } are not next to each other because a number of other leaves H = {h 1 , . . . , h m } are mixed in:</p><formula xml:id="formula_3">σ | t a ,t b = (. . . , g 1 , . . . , h 1 , . . . , g i , h j , . . . , h m , . . . , g n , . . .) .<label>(3)</label></formula><p>We can always fulfill this constraint, at the possible cost of breaking others, by moving the leaves H before g 1 and/or after g n . We identify m + 1 new sorting orders σ as follows:</p><formula xml:id="formula_4">σ 0 = (. . . , h 1 , . . . , h m , g 1 , . . . , g n , . . .)</formula><p>. . . <ref type="figure">Figure 6</ref>. We want to sort the red, green and blue leaves of the temporal tree T . Several constraints are imposed on their ordering due to the hierarchical nesting (yellow and orange constraints) and due to topological events (gray constraints). In order to fulfill a constraint, the involved leaves need to be next to each other in the ordering during the defined time span. Note that we only add a constraint to our system if they are not trivially fulfilled. For example, the root would always impose a hierarchical constraint on all leaves over the entire time, yet any ordering fulfills that. In this example, the two topological constraints are trivially fulfilled as well and would not actually be considered by our method. In fact, just considering the shown two hierarchical constraints suffices to properly sort the leaves. The final nested drawing is shown in <ref type="figure">Figure 7</ref>.</p><formula xml:id="formula_5">σ k = (. . . , h 1 , . . . , h m−k , g 1 , . . . , g n , h m−k+1 , . . . , h m , . . .) . . . σ m = (. . . , g 1 , . . . , g n , h 1 , . . . , h m , . . .) .<label>(4)</label></formula><formula xml:id="formula_6">t 0 t 1 t 2 t 3 t 4 time hierarchical constraint topol. constraint (merge) topol. constraint (split) hierarchical constraint time t 0 t 1 t 2 t 3 t 4</formula><p>Note how the ordering of the moved leaves σ | H does not change, which may be vital for keeping other constraints intact. Furthermore, the leaves are moved directly in front of g 1 or behind g n , which also avoids potential conflicts with other constraints as much as possible.</p><p>If an ordering σ fulfills all constraints, then the nested drawing of the temporal tree can be done without intersections. This follows directly from the definitions above. If an ordering σ does not fulfill all constraints, then the severity of the visual artifacts depends on the chosen rendering method. We target two rendering methods: the nested drawing akin to Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> as well as our proposed cushion rendering <ref type="figure" target="#fig_4">(Section 4.3)</ref>. The former will show a certain number of intersections, where an unfulfilled constraint can lead to a single intersection between two curves, or just as well to a larger set of intersections (cf. <ref type="figure">Figure 4</ref>). Our cushion rendering, on the other hand, draws exclusively the leaves as curves without intersection, but unfulfilled constraints show up in the form of visual artifacts in the cushion shading. <ref type="figure" target="#fig_6">Figure 5</ref> shows how both rendering approaches deal with violated constraints.</p><p>In order to support both rendering methods, we focus on obtaining a σ fulfilling as many constraints as possible. In the following, we propose a heuristic approach that may suffice for simpler examples, and an optimization approach for larger data sets. <ref type="figure">Figure 7</ref>. Solving for the hierarchical constraints, the three leaves (See <ref type="figure">Figure 4</ref>) can be properly sorted and will not intersect each other in the nested drawing. Obtained with our heuristic in one single iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Heuristic for Solving Constraints</head><p>Consider the leaves of a temporal tree in any given ordering. We record the ordering constraints as discussed in the previous section by iterating over all inner nodes and over all topological events. All unfulfilled constraints are pushed into a first in, first out queue (FIFO). We iterate over this queue: after popping the first element from the queue and checking whether it is still unfulfilled, we compute the new sorting orders σ 0 , . . . , σ m following (4) as described above. We continue with the sorting order fulfilling most constraints. If we have several of those, we choose one of those randomly. All constraints that became unfulfilled by this procedure are pushed into the queue. <ref type="bibr" target="#b0">1</ref> We stop this procedure either when the queue is empty or after a certain number of iterations, typically after processing twice as many constraints as we had in the queue to begin with.</p><p>In many cases, this heuristic can solve all constraints. <ref type="figure">Figure 7</ref> shows the computed ordering for the example data set that we have been using throughout this section. The heuristic is able to solve this with one single iteration. In fact, the heuristic is able to find an optimal solution for all examples in this paper except for the data set in <ref type="figure" target="#fig_10">Figure  9</ref>. Hence, we see this heuristic as a simple-to-implement option for some applications.</p><p>In complex data sets such as the one shown in <ref type="figure" target="#fig_10">Figure 9</ref> or the large graphs shown in the supplemental material, this heuristic is able to at least drastically reduce the number of unfulfilled constraints. However, it often gets stuck in loops, i.e., it fulfills and breaks the same cycle of constraints over and over again. Nevertheless, it is still useful in these settings for finding a good starting point for the more advanced optimization method introduced in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Simulated Annealing for Solving Constraints</head><p>A leaf order σ is a permutation of the leaves of the temporal tree. If we have n leaves, then we have n! different σ . Our goal is to find a particular leaf order σ violating no or only a small number of ordering constraints. To do so, we apply an optimization method. This requires us to define an objective function to assign a measure of quality to each leaf order. With the optimization method we try to find the leaf order minimizing this function.</p><p>Let {C} be the set of all hierarchical and topological ordering constraints. Given a particular leaf order σ , some of them may be violated. We denote the set of violated constraints for a given σ with {C σ }. We define the violation ratio v(σ ) as a means to assess the amount of violated constraints in a normalized manner:</p><formula xml:id="formula_7">v(σ ) = |{C σ }| |{C}| 0 ≤ v ≤ 1 .<label>(5)</label></formula><p>Note that lower values of v are considered to be better, i.e., we want to minimize that function. The optimization problem can now be stated as arg min</p><formula xml:id="formula_8">σ v(σ ) .<label>(6)</label></formula><p>We approach it using Simulated Annealing <ref type="bibr" target="#b23">[24]</ref>, which works in a nutshell like this: we start with an initial leaf order σ 0 . To compute a new leaf order σ i in each iteration, we take the one from the previous iteration σ i−1 and resolve one random, currently violated constraint. This gives us, according to (4), possibly several new leaf orders of which we randomly choose one, denoted by σ . If v(σ ) ≤ v(σ i−1 ), then we set σ i = σ and move on to the next iteration. If, however, v(σ ) &gt; v(σ i−1 ), then the main feature of Simulated Annealing comes into effect: the new leaf order is worse than the previous one, but it may be accepted by Simulated Annealing in an attempt to not get stuck in local minima or loops. This is steered by a parameter called temperature T, which is initialized with a high value and then slowly decays with a factor 0 &lt; d &lt; 1 to be applied every k iteration steps:</p><formula xml:id="formula_9">T 0 = T init , T i = d T i−1 .<label>(7)</label></formula><p>1 Some constraints may have become fulfilled by this procedure as well. They are still in the queue and will be removed when they appear at the front of the queue.</p><p>In this setting, we are more likely to choose a worse new leaf order if the temperature is high. The probability for accepting a worse leaf order is computed as</p><formula xml:id="formula_10">p = e v(σ i−1 )−v(σ ) T .<label>(8)</label></formula><p>The process stops once the temperature drops below a near-zero threshold, or a maximal number of iterations is reached, or all constraints are fulfilled.</p><p>We initialize this optimization with a leaf order obtained with the heuristic from the previous section. Simulated annealing has always been able to improve on that initial ordering. The running times range from a few seconds to minutes, depending on the size of the problem and the initial temperature. We evaluate this approach in Section 5 in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Sorting Order for all Nodes</head><p>Drawing a temporal tree requires an ordering of all nodes, which can be computed from the leaf order σ straightforwardly: for each inner node p of T , find the first leaf in σ reachable from p and use this index to sort p among the other nodes from the same hierarchy level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Adaptation of Cushion Maps</head><p>In many application cases (e.g., filesystem), the data value at each parent node is the sum of the data of its children, see Equation <ref type="bibr" target="#b0">(1)</ref>. If the drawing is supposed to represent the data truthfully, then the entire space of a parent is consumed by its children. In fact, the leaves of the entire tree consume the entire drawing space, since their data sums up to the data value of the root. A nested drawing with space for the parents as in <ref type="figure">Figure 7</ref> is not the best choice for such application cases.</p><p>We propose a drawing scheme for temporal trees taking into account exactly those application cases. It is an adaptation of the classic cushion treemaps <ref type="bibr" target="#b37">[38]</ref>, which computed the value of the cushion for each pixel on the CPU. We want to exploit graphics hardware and utilize the GPU for this. Hence, we will triangulate the leaves of the tree and provide each vertex with enough information such that the cushions can be computed on the GPU in a shader. We will detail this in the following.</p><p>First, we need to identify all time steps in which any data value changes in the temporal tree. This can easily be obtained by iterating over all leaves and collecting the time steps of their time series. This globally unique and sorted list of time steps is used to divide the time axis (x-axis) of the drawing. Furthermore, we obtain the sum of all leaves' data values for these time steps. This can be used to normalize the values in each time step.</p><p>As just observed, it suffices to draw the leaves as they sum up to the data value of the root. Given the optimized leaf order σ , we start with the first leaf b 1 . It extends over the time span [t a ,t b ]. We place a triangle strip at the bottom of the drawing space. The x-coordinates are given by the global time steps <ref type="figure">in [t a ,t b ]</ref>. The y-coordinates are given by the normalized data value in each time step. We add a triangle strip for every subsequent leaf in the same manner, except that they attach to the top of previously drawn leaves.</p><p>Topological events need special treatment. Our goal is to indicate the merge or split by means of a merging/splitting highlight curve in the final cushion rendering. We make the transition as follows: consider a split event where a leaf b 1 splits into leaves b 2 , b 3 . Due to our data structure, b 1 ends directly at the time of the split, while b 2 , b 3 start there. Also, they match in size, i.e., d(b</p><formula xml:id="formula_11">1 ) = d(b 2 ) + d(b 3 ).</formula><p>We insert a new vertex a bit before the event into the triangle strip of b 1 . It is placed directly on top of the cushion highlight and connected to the regular first vertices of b 2 , b 3 . This way, we impose a split on the cushion highlight following the split in the data. This works just as well for merges and also for events with more splits/merges than two.</p><p>Once the triangulation is done, we provide cushion information to each vertex. Cushion rendering <ref type="bibr" target="#b37">[38]</ref> has the goal to communicate hierarchical information even in situations where the parents cannot be seen. The main idea is to simulate a virtual "landscape" that reveals the nesting information through shading. Basically, each node of the tree is assigned a parabola with the height depending on the hierarchy level of the node. Assume a node is placed between [y 0 , y 1 ] in a given time step, then the parabola is given as:</p><formula xml:id="formula_12">∆z(y) = 4 f h (y − y 0 ) (y 1 − y) y 1 − y 0 ,<label>(9)</label></formula><p>where h is a base height for all cushions and 0 &lt; f &lt; 1 determines the height decay over increasing hierarchical levels. The final cushion "landscape" is the sum of the parabolas of all nodes. Thankfully, the sum of two parabolas is a parabola itself! Hence, we can describe the final cushion "landscape" by assigning an appropriately summed-up parabola to each leaf. Technically, we store the parabola parameters at the vertices of the leaf triangulation and use this to perform shading calculations on the GPU. Lastly, we also use color to indicate the hierarchical nesting. To do so, we traverse T starting at the root, visiting each node and distributing colors between user-defined hierarchy levels. The colors are chosen in different ways, e.g., randomly, along the hue axis of the HSV color model, or using different colorbrewer schemes <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Interacting with Temporal Treemaps</head><p>Our final visualization comes with a number of interactive elements. Aspects such as color, cushions, lighting conditions, node selection can be modified interactively after the finalization of the order.</p><p>Through exploiting GPU shading procedures, we can interactively change light attributes such as its direction or ambient/diffuse colors. For the cushions, varying the parameters h and f highlights different aspects of the hierarchy. A lower factor f puts more focus on the first hierarchy layers, whereas higher values emphasize deeper parts. Changes in height h lead to overall flatter or steeper height profiles. We can also choose a depth range for coloring and cushioning. This allows to explore the data through focusing on selected hierarchical layers. Further filtering on the time span and toggling of first level hierarchy nodes is supported as well.</p><p>We refer the reader to the supplemental video where these interactions are showcased.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION 5.1 Comparison to Lukasczyk et al. [26]</head><p>We start with a comparison using a closeup of the Viscous Fingers data set, which was used in the publication of the original method for Nested Tracking Graphs <ref type="bibr" target="#b25">[26]</ref>. We thank the authors for making their code and data publicly available. <ref type="figure" target="#fig_8">Figure 8</ref> shows a side-by-side comparison of the graph layouts. It can easily be seen that our method creates an intersection-free layout, while the original method fails to do so. <ref type="figure" target="#fig_10">Figure 9</ref> tells a similar story, except that this data has more time steps and shows even more intersections for the original method. The underlying time-dependent data, which we will refer to as the Cylinder data set, describes vortex activity in the wake of a square cylinder by means of the Okubo-Weiss criterion <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b38">39]</ref>. We look at a part of a temporal zoom-in of 15 time steps.</p><p>In <ref type="table">Table 1</ref> we compare the data structures employed by either method in a quantitative manner. The compression ratio of our new aggregated temporal tree T is highest for data sets where only a few nodes change per time step. The Pyhton data set is an example for this as it records all changes to the Python source code file tree by scanning over 100k commits to the repository over a time range from the 1990s to now.</p><p>The most important advantage of the aggregation are the drastically reduced computation times of our algorithm. For example, our method needs 30 seconds for the aggregated version of the Cylinder data set with its total of 508 time steps. The non-aggregated version incurs a running time of 30 minutes.</p><p>We deem it unfeasible and not constructive to compare our method and the method of Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> in terms of computation times. We employ drastically different technologies. While Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> call Graphviz for most of the layout, the final drawing happens in Javascript in the browser. In our case, everything is done native in C++. Still, in neither case, a user has to wait longer than half a minute to get a result.   <ref type="bibr" target="#b25">[26]</ref>. We zoomed into the time range <ref type="bibr" target="#b39">[40,</ref><ref type="bibr">47]</ref> to highlight the intricate structures. Note how our algorithm produces an intersection-free layout, whereas some bands are intersecting each other for the original method.  The red circles indicate regions where the original method for Nested Tracking Graphs <ref type="bibr" target="#b25">[26]</ref> produces a layout with many intersections. Our method is able to produce a layout with just one intersection. We are looking at a temporal and spatial zoom-in covering about 15 time steps. A larger, zoomed-out version is shown in the supplemental material.</p><p>Nevertheless, it should be noted that our method needed less than a second for the results shown in <ref type="figure" target="#fig_8">Figures 8b and 9b</ref>   <ref type="figure">Figure 10</ref>. This parameter study for the Simulated Annealing method shows that, on average, it behaves quite stable. We investigated three initial temperatures T 0 (2, 5, 10), four settings for the number of iterations k until a temperatures decay occurs <ref type="bibr" target="#b4">(5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr">50,</ref><ref type="bibr">100)</ref>, and three distinct settings for the temperature decay factor d (0.8, 0.85, 0.9). See Equation <ref type="formula" target="#formula_9">7</ref>. Each bar summarizes 100 runs for the respective setting. The plots show that very good results can be obtained with any of the presented settings, but the spread of the individual runs should not be neglected. We propose to run several times, possibly in parallel, since a single run takes less than a second. <ref type="figure">Figure 11</ref> plots the number of violated constraints during a run of the Simulated Annealing method on the Cylinder data set shown in <ref type="figure" target="#fig_10">Figure  9b</ref>. The method starts with only a few violated constraints, but after about 25 iterations and with still high temperature it chooses to worsen the condition and break some constraints in an attempt to find a globally better solution. This is a typical behavior of Simulated Annealing and actually one of its advantages. Once the temperature cools down, the fluctuations lessen and the method found a good solution around iteration 350. This whole procedure takes less than a second.  <ref type="figure">Figure 11</ref>. We fist run the heuristic for twice as many iterations as there are constraints. The approach then may choose to run into worse conditions (violate more constraints) during the Simulated Annealing part in order to not get stuck in local minima. Still, it found a configuration after 355 iterations that violates only a few topological constraints. This is a run on the Cylinder data set shown in <ref type="figure" target="#fig_10">Figure 9b</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Evaluation of Simulated Annealing</head><p>We conducted a parameter study for the very same data set. We investigated three initial temperatures, four settings for the number of iterations until a temperature decay occurs, and three settings for the temperature decay factor. We ran Simulated Annealing for the entire so-defined 3D parameter space and <ref type="figure">Figure 10</ref> shows the three two-dimensional projections of the results. The plots show that very good results can be obtained with many different settings. We observe a slight advantage of parameter settings with longer run times, i.e. higher initial temperature, more iterations per temperature and higher decay. On average, the method behaves nicely and leads to stable results. However, since it uses randomness by design, the spread of the individual runs needs to be accounted for. For example, it is advisable to run the method several times and choose the best result. This can be done in parallel. Our implementation is currently not parallel and requires less than a second on current hardware.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>Besides the already shown results, we would like to showcase the utility of our approach with three more data sets. Different types of data normalization can be used with our method. <ref type="figure" target="#fig_1">Figure 12</ref> exemplifies this showing the development of the world population until the year 2100 as projected by the United Nations in World Population Prospects: The 2017 Revision <ref type="bibr" target="#b34">[35]</ref> according to different models making assumptions on fertility, mortality and net migration. We show two of the nine variants here; see the supplemental material for all variants and details. <ref type="figure" target="#fig_1">Figure 12a</ref> shows the population development assuming that fertility and mortality remain unchanged. The left image shows the data with a normalization per time step. This utilizes the entire visualization space and supports relative size comparisons: Europe's fraction of the world population declines over the entire time span, Asia's fraction declines since the early 21st century, whereas more than every second human will live in Africa by the year 2100. The right image in <ref type="figure" target="#fig_1">Figure 12a</ref> shows the same data in absolute terms (normalized to the global maximum), which reveals that the absolute population numbers are constant for all regions at least since the early 21st century, except for Africa experiencing a strong increase. Note that this model is considered to be unrealistic. The most likely model according to <ref type="bibr" target="#b34">[35]</ref> is shown in <ref type="figure" target="#fig_1">Figure 12b</ref>. The right image reveals that the world population levels out at around 11 billion people. The data in the previous example does not contain topological events, even though an accurate depiction of history would show splitting and merging countries. Especially Europe has been subject to a number of such cases in the 20th century. We use the latest available demographic data <ref type="bibr" target="#b33">[34]</ref> for Europe's population between 1975 and 2016 and adhere to historical events such as the German unification in 1990 and the dissolution of the Soviet Union in 1991. The result in <ref type="figure" target="#fig_4">Figure 13</ref> shows how the cushion rendering is effective in conveying these events. <ref type="figure">Figure 14</ref> shows the development of the CPython source code repository <ref type="bibr" target="#b12">[13]</ref> since its early development. The covered time span is between August 1992 and March 2018 obtained by sampling every 1000th of the 101181 commits. The colored cushion rendering is effective in revealing two interesting events. First, the relative size of the Doc folder first decreases and then increases tremendously during 2007: the Python documentation switched from L A T E X to reStructuredText and during a brief period the Doc folder does not exist at all. Second, the Mac folder seems to be added only around 1995. Upon further investigation, this folder exists from the very beginning, albeit almost empty. An introduction on how to use Python on Mac is introduced in August 1994. <ref type="figure">Figure 14</ref> shows that our rendering method can be used to identify major trends in such data. A shortcoming of our current implementation can be seen as well. We do not apply any form of smoothing, which makes some parts of the plot rather discontinuous. Furthermore, it is yet to be determined, e.g., through a user study, whether the cushions alone allow for perception of the hierarchical nature of the data. We suspect the combination of color and cushions is needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS AND FUTURE WORK</head><p>We presented a novel layout algorithm for temporally evolving trees with changing topology and data. Based on a combination of a heuristic and simulated annealing, it produces a layout with as few intersections as possible. Our evaluation has shown that the algorithm runs fast, which is also fostered by our new data structure for temporally evolving trees, recording only the changes to the tree. Our new cushionbased rendering scheme highlights temporal evolution and hierarchical nesting at the same time.</p><p>Our current objective function in Equation (5) essentially only counts the number of violated constraints. It is an interesting avenue for future research to incorporate more aspects such as the severity of the visual artifact of an unfulfilled constraint depending on the chosen rendering  <ref type="figure">Figure 14</ref>. Evolution of the Python repository from 1992 until now. We can see the major development trends with some folders becoming very large and supposedly important over time.</p><p>method, the associated data values (thickness in the final drawing), or the wigglyness of the final drawing similar to how Bartolomeo and Hu <ref type="bibr" target="#b1">[2]</ref> did this for stream graphs.</p><p>We excluded cases where a child changes its parent. This happens often in filesystems: a file is moved from one folder to another. In <ref type="figure" target="#fig_4">Figure 13</ref> we have modeled this case for the Soviet Union by splitting the parent into two separate nodes: one before the move and one after the move. However, for a data set with many moving nodes, the introduction of splits diminishes some of the efficiency gained by our data structure. A direct support for moving a node to a different parent is desirable, yet any such move leads to an intersection in the drawing, since the child needs to cross over to the other parent. Nonetheless, one may be able to minimize the number of intersected bands.</p><p>Furthermore, we believe the navigation of our visualization can be enhanced by connecting it to a snapshot visualization through linking and brushing. Lukasczyk et al. <ref type="bibr" target="#b25">[26]</ref> display the isosurfaces for a hierarchy level alongside the Nested Tracking Graph allowing for selection and highlighting of components. For the other types of data sets (file systems, world population), a 2D treemap or a world map can serve to visualize the state of the chosen time step in a different context.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>2D treemap layout as introduced by Johnson and Shneiderman<ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b27">28]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Treemaps can be defined in different dimensions. A classic 2D layout makes excellent use of a 2D display space, but incorporating a temporal dimension is difficult. A 1D treemap layout frees up one spatial dimension for incorporating the temporal evolution of the tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>G = (N, E T , E N ):Time series of trees with node correspondences between time steps<ref type="bibr" target="#b25">[26]</ref>. This example has 29 nodes and 48 edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>T = (N , E T , E N ):Aggregated temporal tree with time series of data values at the nodes. This example has 9 nodes and 18 edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>Aggregated temporal trees (right) encode information more space-efficiently than a time series of trees (left), especially when only a few nodes change their data values in every time step such as in the history of a file system. See also Section 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 .</head><label>5</label><figDesc>It is not always possible to draw a graph intersection-free. In particular, this is the case in our setting, where the nodes are aligned with time steps. The rendering method of Lukasczyk et al.<ref type="bibr" target="#b25">[26]</ref> shows intersections directly (top-right image), whereas they appear as discontinuities in the cushion rendering (bottom-right image) discussed in Section 4.3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(a) Layout using the method of Lukasczyk et al.<ref type="bibr" target="#b25">[26]</ref>.(b) Layout using our algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 .</head><label>8</label><figDesc>Closeup of the Viscous Fingers data set from</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(a) Layout using the method of Lukasczyk et al.<ref type="bibr" target="#b25">[26]</ref>.(b) Layout using our algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 .</head><label>9</label><figDesc>Layout of a nested tracking graph in the Cylinder data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>World population development according to the No Change model, where fertility and mortality remain on the levels recorded between 2010 -2015. World population development Medium model representing the median of several thousand projection models for fertility and mortality. Color coding in the first hierarchy level according to regions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 12 .</head><label>12</label><figDesc>Different types of data normalization can be used with our cushion rendering method. The data in the left figures is normalized per time step, whereas the right figures show the data in absolute terms. The plots show the development of the world population until the year 2100 according to a United Nations report<ref type="bibr" target="#b34">[35]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>.</figDesc><table><row><cell>Data Set</cell><cell cols="3">Aggregated Data Structure T</cell><cell cols="3">Non-Aggregated Data Structure G</cell></row><row><cell></cell><cell>|N |</cell><cell>|EN |</cell><cell>|ET | Memory</cell><cell>|N|</cell><cell>|EN |</cell><cell>|ET | Memory</cell></row><row><cell>Viscous Fingers</cell><cell>379</cell><cell>589</cell><cell>344 0.01 MB</cell><cell>919</cell><cell>918</cell><cell>884 0.03 MB</cell></row><row><cell>Cylinder</cell><cell cols="3">7094 10236 3923 0.24 MB</cell><cell>28904</cell><cell>31539</cell><cell>21810 0.92 MB</cell></row><row><cell>Python</cell><cell cols="2">11643 11642</cell><cell cols="4">0 0.22 MB 372127 372025 360484 12.6 MB</cell></row><row><cell cols="7">Table 1. The aggregated data structure introduced in Section 3 has a</cell></row><row><cell cols="7">significantly lower footprint, especially for filesystem data sets such as</cell></row><row><cell cols="2">the Python data set.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">t 0 t 1 t 2 time</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported through grants from the Swedish Foundation for Strategic Research (SSF) and the Swedish e-Science Research Centre (SeRC). The presented concepts have been implemented in the Inviwo framework.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Voronoi treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Deussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Symposium on Information Visualization</title>
		<meeting>IEEE Symposium on Information Visualization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">There is more to streamgraphs than movies: Better aesthetics via ordering and lassoing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Bartolomeo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Touchwave: Kinetic multi-touch manipulation for hierarchical stacked graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Baur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Carpendale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM International Conference on Interactive Tabletops and Surfaces</title>
		<meeting>ACM International Conference on Interactive Tabletops and Surfaces<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A taxonomy and survey of dynamic graph visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Diehl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="133" to="159" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Graph theory with applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Bondy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">S R</forename><surname>Murty</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976" />
			<publisher>Elsevier Science Publishing Co., Inc</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Testing for the consecutive ones property, interval graphs, and graph planarity using pq-tree algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Booth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Lueker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="335" to="379" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cynthia</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
		<ptr target="http://www.ColorBrewer.org" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Squarified treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bruls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Huizing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Joint Eurographics and IEEE TCVG Symposium on Visualization</title>
		<meeting>Joint Eurographics and IEEE TCVG Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On planar supports for hypergraphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Buchin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Speckmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Verbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="533" to="549" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Parallel edge splatting for scalable dynamic graph visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Vehlow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Diehl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2344" to="2353" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Stacked graphs -geometry &amp; aesthetics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Byron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1245" to="1252" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Simulation of the three-dimensional flow around a square cylinder between parallel walls at moderate reynolds numbers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Camarri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-V</forename><surname>Salvetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Buffoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Iollo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">XVII Congresso di Meccanica Teorica ed Applicata</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="https://github.com/python/cpython.9" />
		<title level="m">CPython repository</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multistream: A multiresolution streamgraph approach to explore hierarchical time series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cuenca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sallaberry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Poncelet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">How hierarchical topics evolve in large text corpora</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2281" to="2290" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fat polygonal partitions with applications to visualization and embeddings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Onak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sidiropoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="212" to="239" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">An open graph visualization system and its applications to software engineering. Software: Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bubble treemaps for uncertainty visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Görtler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Deussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="719" to="728" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Visualization of varying hierarchies by stable layout of voronoi treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Trümper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Döllner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Information Visualization Theory and Applications</title>
		<editor>R. S. Laramee, A. Kerren, and J. Braz</editor>
		<meeting>the 5th International Conference on Information Visualization Theory and Applications</meeting>
		<imprint>
			<publisher>SciTePress</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A note on the consecutive ones submatrix problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Hajiaghayi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ganjali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="163" to="166" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Themeriver: Visualizing thematic changes in large document collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Havre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G</forename><surname>Hetzler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Whitney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">T</forename><surname>Nowell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="20" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A simple test for the consecutive ones property</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-L</forename><surname>Hsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Symposium on Algorithms and Computation</title>
		<meeting>the Third International Symposium on Algorithms and Computation<address><addrLine>London, UK, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="459" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Tree maps: A space-filling approach to the visualization of hierarchical information structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<editor>G. M. Nielson and L. J. Rosenblum</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Gelatt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Vecchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">220</biblScope>
			<biblScope unit="issue">4598</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Storyflow: Tracking the evolution of stories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2436" to="2445" />
			<date type="published" when="2013-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Nested tracking graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lukasczyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Maciejewski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Garth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Leitte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Proceedings EuroVis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Arctrees: Visualizing relations in hierarchical data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schlechtweg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S T</forename><surname>Carpendale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Joint Eurographics -IEEE VGTC Symposium on Visualization</title>
		<meeting>Joint Eurographics -IEEE VGTC Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="53" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Tree visualization with tree-maps: 2-d space-filling approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="1992-01-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Ordered treemap layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Symposium on Information Visualization</title>
		<editor>K. Andrews, S. F. Roth, and P. C. Wong</editor>
		<meeting>IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="73" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Stable treemaps via local moves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sondag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Speckmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Verbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Fast dynamic voronoi treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Seventh International Symposium on Voronoi Diagrams in Science and Engineering</title>
		<editor>M. A. Mostafavi</editor>
		<meeting>Seventh International Symposium on Voronoi Diagrams in Science and Engineering</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Enhanced spatial stability with hilbert and moore treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cockburn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Visualizing changes of hierarchical data using treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">United Nations Demographic Yearbooks</title>
	</analytic>
	<monogr>
		<title level="j">United Nations</title>
		<imprint>
			<date type="published" when="1984" />
		</imprint>
	</monogr>
	<note>United Nations</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">World population prospects: The 2017 revision</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
	<note>United Nations</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Block crossings in storyline visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">C</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Markfelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ravsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wolff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing and Network Visualization</title>
		<editor>Y. Hu and M. Nöllenburg</editor>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="382" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Stable and predictable voronoi treemaps for software quality monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Hees</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2017-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Cushion treemaps: Visualization of hierarchical information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van De Wetering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Symposium on Information Visualization</title>
		<meeting>IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Smoke surfaces: An interactive flow visualization technique inspired by real-world flow experiments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Funck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Weinkauf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Theisel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proceedings Visualization</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1396" to="1403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Designing for social data analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kriss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2006-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
