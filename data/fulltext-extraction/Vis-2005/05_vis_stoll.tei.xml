<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visualization with stylized line primitives</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carsten</forename><surname>Stoll</surname></persName>
							<email>stoll@mpi-sb.mpg.de</email>
							<affiliation key="aff0">
								<orgName type="department">Max Planck Institut fuer Informatik Saarbruecken</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
							<email>sgumhold@mpi-sb.mpg.de</email>
							<affiliation key="aff0">
								<orgName type="department">Max Planck Institut fuer Informatik Saarbruecken</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-Peter</forename><surname>Seidel</surname></persName>
							<email>hpseidel@mpi-sb.mpg.de</email>
							<affiliation key="aff0">
								<orgName type="department">Max Planck Institut fuer Informatik Saarbruecken</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Visualization with stylized line primitives</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>rendering</term>
					<term>vector fields</term>
					<term>streamlines</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Line primitives are a very powerful visual attribute used for scientific visualization and in particular for 3D vector-field visualization. We extend the basic line primitives with additional visual attributes including color, line width, texture and orientation. To implement the visual attributes we represent the stylized line primitives as generalized cylinders. One important contribution of our work is an efficient rendering algorithm for stylized lines, which is hybrid in the sense that it uses both CPU and GPU based rendering. We improve the depth perception with a shadow algorithm. We present several applications for the visualization with stylized lines among which are the visualizations of 3D vector fields and molecular structures.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The visualization of dense 3D data sets such as 3D vector fields is one of the most difficult problems in scientific visualization. The central problem is occlusion, what rules out the use of a dense visual representation of the data set. Techniques like 3D LIC can only be used in conjunction with slicing techniques that restrict the visualized data again to a 2D subset. For an actual 3D visualization one therefore has to fall back to sparse visual representations. Among these are iconic representations and line primitives. The latter has the additional advantage that it not only shows local but also global features of the underlying data. Although these sparse representations allow a better view into the data, it is quite difficult to achieve</p><p>In this paper we extend line primitives, which are commonly used for visualization in 3D, by several additional visual attributes and a visual representation that improves the depth perception significantly. As geometric and visual representation we propose to actually blow up the line primitives to real 3D primitives, which we denote stylized line primitives. Similar to stream tubes we chose to use generalized cylinders with a circular profile. The illuminated rendering of generalized cylinders gives a very good depth perception as can be seen in <ref type="figure">Figure 1</ref>. Furthermore, it allows the use of additional visual attributes. Here we investigate radius, color as well as textures of colors and normals. Rotation of the textures along the line primitives gives another well perceivable visual attributethe orientation. Finally, we add a halo to improve depth perception even further.</p><p>A visualization technique is only valuable if it allows for realtime navigation in a potentially time-dependent data set. Therefore, the major contribution of this work is an efficient rendering algorithm for stylized line primitives. Although rendering algorithms exist for generalized cylinders, non of the existing algorithms allows for real-time navigation of large data sets with high image quality. Our new algorithm combines the speed of splatting based algorithms with high image quality, which is achieved by a hybrid approach that uses fast GPU supported splatting for most stylized line primitives and a CPU based tessellation in regions where the simple splatting approach leads to noticeable artifacts. We achieve a speed up of three in comparison to a purely tessellation based approach for static data sets and a speedup of a factor of up to 6 for time-dependent data sets. These speed ups are mainly due to the reduced amount of geometry data that has to be transfered to the GPU and processed there.</p><p>In the remainder of the paper we first discuss related work, introduce the stylized line primitive in section 3, detail the hybrid rendering approach in section 4, measure the performance and performance gains in 5 and apply the new visualization technique to several applications in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Visualization 2005</head><p>October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE.</p><p>The visualization of 3D flows using streamlines as a sparse and fast representation method has been researched for a long time now. An important factor here is a good distribution of samples across the flow and a good path-tracing algorithm to integrate streamlines in a vector-or tensor-field. A comprehensive overview of such techniques can be found in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Several methods have been introduced to visualize streamlines in the past years. Ueng et al. <ref type="bibr" target="#b14">[15]</ref> use stream-ribbons and streamtubes to visualize the flow, the first being a quad strip generated by the streamline and a normal vector extracted with it and the second being a generalized cylinder with a circular profile where the radius depends on the flow velocity. No efficient rendering algorithm for the stream-tubes was proposed though. Fuhrmann and Gröller <ref type="bibr" target="#b5">[6]</ref> use generalized cylinders with opacity textures to represent dashed stream-tubes. They propose a simple tessellation scheme with 6 to 8 subdivisions along the cylinder. Zöckler et al. <ref type="bibr" target="#b15">[16]</ref> introduced the simple to render illuminated streamlines, which is a lighting model for line primitives based on the Phong lighting. This enhances depth perception to some extent only and does not give a ductile impression of the stream-lines especially when using varying thickness. Mattausch et al. <ref type="bibr" target="#b10">[11]</ref> later presented a comprehensible overview of methods for visualizing flows using illuminated streamlines, including levels of detail, magic volumes and halos.</p><p>Schussman and Ma <ref type="bibr" target="#b13">[14]</ref> introduced a method for rendering huge amounts of streamlines using volume visualization, but their method aims for extremely dense fields and is not able to provide interactive frame-rates.</p><p>General cylinders where introduced by Agin and Bindford <ref type="bibr" target="#b0">[1]</ref> in 1976 as a method to describe and model curved objects. Different methods for visualizing these have been proposed later, including ray tracing ( <ref type="bibr" target="#b4">[5]</ref>) and different polygonalization methods <ref type="bibr">([4]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b6">[7]</ref>).</p><p>Some special attention has also been paid to the rendering of generalized cylinders with circular profile. Main contributions here are the Optimal Tubes <ref type="bibr" target="#b2">[3]</ref> by Blinn, who adaptively tessellates a tube at the silhouette edges and lighting dependent positions and Paintstrokes by Neulander and van de Panne <ref type="bibr" target="#b11">[12]</ref>, who present different tessellation methods for rendering circular generalized cylinders. All the tessellation methods lead either to a huge number of rendering primitives or a bad image quality with artifacts. Our approach on the other hand optimally combines GPU based rendering exploiting fragment shaders with CPU based adaptive tessellation. One very important design criterion for the fragment shaders was to keep them as simple as possible in order to achieve high fill rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">STYLIZED LINE PRIMITIVES</head><p>Stylized line primitives are defined as generalized cylinders. A generalized cylinder is composed of a continuous path P(τ) in 3d space and a closed two dimensional profile Π(φ ) = p x (φ ), p y (φ ) . We assume that the curve defining the path is regular, i.e. the path tangent T(τ) does not vanish:</p><formula xml:id="formula_0">T(t) = ∂ t P(t) = 0</formula><p>Furthermore, we restricted ourselves to circular profiles of radius R(τ), so</p><formula xml:id="formula_1">Π(φ ) = R(τ) • sin(φ ) cos(φ ) 0 ≤ φ &lt; 2π.<label>(1)</label></formula><p>The surface of the general cylinder can thus be described by  wherex(τ) andŷ(τ) are two orthonormal vectors that span the plane orthogonal to the tangent vector T(τ).</p><formula xml:id="formula_2">S(τ, φ ) = P(τ) + Π x (φ ) •x(τ) + Π y (φ ) •ŷ(τ)<label>(2)</label></formula><formula xml:id="formula_3">p i+1 r i+1 t i+1 p i r i t i x i+1 x i p i+1 t i+1 r i+1 r i p i ŷ iŷ i+1 t i</formula><p>Generalized cylinders can be visualized in different ways. As our goal is the interactive visualization of a large number of stylized lines ray tracing based approaches drop out. In order to be able to exploit modern graphics hardware we chose a splatting based approach. For this the continuous path of a generalized cylinder P(τ) is sampled at discrete path parameters τ i , resulting in a set of points p i = P(τ i ) with i = 0 . . . n. The discretization is done in advance or during construction of the path with a flow integration method. It is advantageous to adapt the sampling resolution to the curvature such that a higher resolution is chosen in high curvature regions and a smaller resolution in low curvature regions. In our work we followed the approach of Gumhold <ref type="bibr" target="#b8">[9]</ref> for adaptive subdivision, which is based on a maximal discretization error ε max .</p><p>To discretize the generalized cylinder each point p i is attributed with the circle describing the profile at path parameter τ i . The profile circle is uniquely defined by its radius r i = R(τ i ) and the tangent vector t i = T(τ i ) or its normalized versiont i , respectively. All the necessary information is gathered in a vertex</p><formula xml:id="formula_4">V i = (p i ,t i , r i , . . .)</formula><p>, which is later extended by color and texture coordinates.</p><p>In this way the discretization splits the stylized line primitive into segments, where each segment is defined by two consecutive vertices V i and V i+1 , i.e. profile circles. <ref type="figure" target="#fig_1">Figure 3</ref> a) illustrates the two circles defined by the vertex data. One way of defining the geometry of each segment from the vertex data is to use the convex hull of the two circles. This has the advantage that the convex hull of the 2d projection of the 3d segment could be computed from the 2d convex hull of the projected circles and that the hull is spanned by straight line segments. On the other hand is it quite complicated to find these line segments and to correctly illuminate the convex hull. Instead we define the geometry by using the φ -parameterization of the circular profiles. We simply connect points of equal φ on the two circles with straight line segments as illustrated for φ = α in <ref type="figure" target="#fig_1">Figure 3</ref> a). For this to work one has to synchronize the local frames {x(τ i ),ŷ(τ i )} and {x(τ i+1 ),ŷ(τ i+1 )} appropriately. The vectorsx(τ i /τ i+1 ) correspond to the φ = 0 angles and uniquely define the correspondence if we assume right handed coordinate systems {x,ŷ,t} i/i+1 . Furthermore it is not important to use a singlê x(τ i ) for the two segments</p><formula xml:id="formula_5">(V i−1 ,V i ) and (V i ,V i+1 )</formula><p>. Therefore we can define the correspondence for each segment independently in the following way. In the case when the two tangent vectors t i and t i+1 are parallel, the two circles lie in parallel planes and any choice of parallelx i/i+1 in this plane can be used. In the case of differing tangents, we chosex i/i+1 in the direction of the intersection line of the two circle planes, i.e. parallel to t i × t i+1 . The intersection line is drawn in dotted style in <ref type="figure" target="#fig_1">Figure 3 a)</ref>. <ref type="figure" target="#fig_1">Figure 3</ref> b) shows the situation in 2d, viewed along the direction of the intersection line, i.e. along the synchronized directionsx i/i+1 .</p><p>In order to illuminate the discretized stylized lines we interpolate the normal vectors along the connection lines of equal φ parameter values. At the end points on the two profile circles we chose the normal in the plane of the circle. This does not reflect the illumination of the actual geometry of each segment, what would lead to uncontinuous normals where two segments meet. Our choice on the other hand synchronizes the normals of adjacent segments at their common circle resulting in continuous normals and much better lighting results.</p><p>The brute force splatting approach simply tessellates each segment with a quad strip. For medium viewing distances a tessellation with eight quads per segment resulted in an acceptable quality. This approach is however extremely expensive since a large amount of geometry data is created and has to be transfered over the graphics card bus. A segment extended by per vertex color information polygonized into a quad strip of length eight results in 18 render vertices, each consisting of position, normal and color, summing up to 180 floats or 720 bytes of data per segment. While this is no problem for short stylized lines we quickly reach the transfer bandwidth or vertex processing limit even of modern graphics cards when rendering a large number of segments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">HYBRID RENDERING OF STYLIZED LINE PRIMITIVES</head><p>In this section we describe a hybrid rendering algorithm for stylized line primitives that exploits the CPU and GPU in an efficient way. There are four possible bottlenecks in the design of such hybrid algorithms: the CPU processing rate, the data transfer rate from CPU to GPU, the vertex processing rate and the fill rate, i.e. the fragment processing rate. The simple tesselation strategy stresses CPU processing, data transfer from CPU to GPU and vertex processing. On the otherhand it achieves very large fill rates. In applications like ours there are a huge number of render primitives that project to a very small area in the frame buffer, such that also relatively low fill rates do not lead to a bottleneck. In this way the simple strategy is quite bad for our application.</p><p>To better balance the different processing and transfer rates we propose a strategy with slightly more complicated fragment processing that allows to process coarser geometric approximations which can be achieved with a much lower count of to be rendered vertices. In this way the first three bottlenecks are significantly reduced. The next two sections describe the straight forward mostly GPU based implementation of this approach. In section 4.3 we discuss severe artifacts that arise where the segments become parallel to the viewing direction. We worked a lot on ways to avoid these artifacts in the primarily GPU based approach but did not find any approach with acceptably simple fragment processing, which is necessary to avoid a new bottleneck in the fill rate.</p><p>The main observation leading to the solution proposed in section 4.4 was that these artifacts arise only in a small number of seg- ments which can be efficiently sorted out. As the artifacts can be cleaned up afterwards, we extended the GPU based approach with a CPU stage that view-dependently detects the problematic segments and corrects the artifacts by overdrawing them with tesselated geometry. The additional geometry necessary per frame was small enough to not decrease the frame rates significantly. In this way we could very effenciently balance the work load on CPU and GPU exploiting the strengths of both architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Splatting the Geometry</head><p>The cannonic approach to splat a segment of the discretized generalized cylinder is to cover it completely with a render primitive, i.e. a quad, and then determine the actually covered fragments and their illumination in the fragment shader. The fragment shader would have to solve the ray-segment intersection incrementally. Especially complicated is the ray-segment intersection where the segment ends in the circles of the vertices. This makes the fragment shader far too complicated for an acceptable fill rate.</p><p>To simplify the splatting proceedure we exploit the fact that a sequence of segments is splatted and that both terminating circles of a segment are matched up with adjacent segments. At each circle in the discretization we approximate the generalized cylinder by an infinite cylinder, which results from extrusion of the circle along the tangent vector. From this approximation we compute two silhoutte points s 1 i and s 2 i for each vertex V i . Each segment is finally covered by a quad connecting the four silhoutte points of its two vertices. This approach is similar to Neulanders <ref type="bibr" target="#b11">[12]</ref> quality 0 paintstrokes and Blinns Optimal Tubes <ref type="bibr" target="#b2">[3]</ref> but gives much better result through the use of a better shading in the fragment shader.</p><p>On the left of <ref type="figure" target="#fig_2">Figure 4</ref> the perspective view of a half infinite cylinder is shown. The two silhouette lines are illustrated by the dashed bold lines. From these two lines we select the two silhouette points that lay in the same plane as the circle of the vertex. If C i denotes all points on the infinite cylinder and v the view point, the silhouette points for vertex V i = (p i ,t i , r i ) can be defined as:</p><formula xml:id="formula_6">s 1,2 i = {p ∈ C i |n T (p − v) = 0, p •t i = p i •t i },<label>(3)</label></formula><p>wheren is the normal vector of the cylinder at the point p.</p><p>The computation of s 1,2 i can be reduced to a simple two dimensional problem since the relative position of the silhouette points to the point of the main axis in the same perpendicular plane is the same for all points of this axis. This is true because all lines on the cylinder surface parallel tot i have the same vanishing point and therefore can never cross (see   Only if the angle between the tangentt i and the view vector u i = p i − v becomes too small (i.e. the viewpoint lies inside the infinite cylinder C i ), no reduction to 2D is possible and s <ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2</ref> i cannot be found, which leads to problems which we address in section 4.3.</p><formula xml:id="formula_7">u i v p i t i y i u ^^p u r i v m i s 1 s 2 y i s y 1</formula><p>This in turn means that, as long as s 1,2 i exist, we can determine the relative positions of the silhouette for the point p ⊥ on the main axis of the cylinder, which is closest to the view point v. See the left of <ref type="figure" target="#fig_5">Figure 5</ref> for an illustration. The view vector to p ⊥ is denoted by u ⊥ . At p ⊥ we define again a two dimensional local coordinate systemx i andŷ i that spans the plane of the circle. The local coordinate directionx i is chosen perpendicular to u ⊥ and the tangent direction</p><formula xml:id="formula_8">t i , i.e.ŷ i =t i × u ⊥ t i × u ⊥ .<label>(4)</label></formula><p>y i is computed orthogonal tox i andt i : <ref type="figure" target="#fig_5">Figure 5</ref> shows the problem reduced to 2D. To compute the local components s</p><formula xml:id="formula_9">x i =t i ×ŷ i t i ×ŷ i .<label>(5)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1|2</head><p>x|y of the silhouette points s 1|2 ⊥ at p ⊥ we can apply Pythagoras rule to find that the point m i is a distance of</p><formula xml:id="formula_10">s 1|2 x = r i r i | u ⊥</formula><p>away from p ⊥ and that the y−components result in</p><formula xml:id="formula_11">s 1|2 y = ±r i • f i , with f i = 1 − r i u ⊥ 2 .</formula><p>Using this we can define two extrusion vectors</p><formula xml:id="formula_12">e 1|2 i = s 1|2 ⊥ − p ⊥ = r i r i | u ⊥ x i ± f i •ŷ i ,<label>(6)</label></formula><p>with which we can compute the silhouette points s 1 i and s 2 i to</p><formula xml:id="formula_13">s 1|2 i = p i + e 1|2 i .<label>(7)</label></formula><p>In practice it can be observed that f i is usually near equal to one for all segments, except for the cases where we are very close to the surface or the angle betweent i and u i becomes very small ( u ⊥ becomes very small), which means that we are in an instable region. Due to this it is possible to ignore this term and estimate e 1|2 i as</p><formula xml:id="formula_14">e 1|2 i = ±r i •ŷ i<label>(8)</label></formula><p>without any noticeable visual impact on the result but saving several costly operations on the GPU. The cylinder normals can also be expressed in terms of the local coordinate axesx i andŷ i . The normals at the silhouette points s 1|2 i are given asn</p><formula xml:id="formula_15">1|2 i = 1 − f i 2 •x i ± f i •ŷ i .<label>(9)</label></formula><p>By transmitting the two basis vectorsx i andŷ i as well as all other vertex data necessary for lighting calculations to the fragment shader as texture coordinates, they will automatically be interpolated in a perspectively correct manner across the quad by the graphics hardware. In addition we will also transmit ± f i in one of the texture coordinates tex 0 and interpolate it along the segment. The tangent vectors are transfered as normals to the graphics card while the 2D texture coordinates are used to denote the sign of the silhouette point and the radius of the circle. If more information is needed for rendering it can be transfered using additional texture coordinates. It is possible to render longer streamlines as quadstrips and since all data is view independant we can store the whole model into acceleration structures, such as vertex buffer objects or display lists, which enables us to render the complete model with a single draw call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fragment processing, Halos, Texture Mapping and Shadows</head><p>The actual shading in the fragment program is similar to a standard Phong shader, except that we need to calculate the current normal from the two transfered vectors upfront. The per fragment normal n can be calculated similar to 9 by normalizing</p><formula xml:id="formula_16">n = 1 − tex 0 2 •x i ± tex 0 •ŷ i<label>(10)</label></formula><p>A simple extension to the proposed fragment processing is the support for a halo. A halo is similar to a single colored silhouette drawn around the stylized line (usually the background color) and is used to increase the depth perception of the rendering. By adding a second interpolation parameter tex 1 ranging from −1 − h size to 1 + h size and multiplying tex 0 by 1 + h size in the vertex shader we define a percentage of the radius of our stylized line to be a halo region. A fragment is in the halo region if tex 1 is smaller than −1 or larger than 1. This means that, unlike in methods like <ref type="bibr" target="#b10">[11]</ref> our halo is defined in object space and not in screen space, and therefore scales with its distance to the viewpoint.</p><p>In addition to this we can also texture the stylized lines by providing additional texture coordinates. While it would be too difficult to distort the texture in such a way that it fits the actual approximated geometry and is oriented correctly, we still can use this to map additional data to the GC segment, like for example torsion by translating the texture to the left or right at the sample points.</p><p>Another extension is to use the shader for shadow rendering. Shadow volumes as well as shadow maps can be implemented using a fragment shader which only writes depth values by not extruding the segments with respect to the viewpoint but with respect to the light source instead. Shadow maps are suited better for calculating shadows in most cases though, since with shadow volumes a huge amount of additional geometry is created (at least 2 shadow quads per segment) and the amount of overdraw is very excessive. Depending on the type of data visualized, shadows can add another layer of depth perception to the rendering as illustrated in <ref type="figure" target="#fig_12">Figure 10</ref> on the left.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Evaluation</head><p>While the previously proposed rendering method here is extremely fast since the segments can be rendered using quad strips and thus only a very small amount of data is needed, it suffers from large inaccuracies if the angle between tangent-and view vector becomes too small. This is due to the fact that in these areas the main visible part of a segment in the screen projection is provided by the profile area which is not covered by the silhouette quad we calculate (see <ref type="figure" target="#fig_2">Figure 4</ref> on the right).</p><p>The calculation of the extrusion vectorŷ i has a singularity oncet i andû i are parallel or anti-parallel. Near this singularity the resulting extrusion vector fluctuates strongly even when only changing one of the input vectors slightly. This manifests in a so called flipping artifact, which can be seen in <ref type="figure" target="#fig_6">figure 6</ref>. The changes in view direction are only minimal, but have a huge visual impact.</p><p>A second problem is that the depth values created by this algorithm only represent the flat quad stripes and not the geometry of a true cylinder. While this only becomes noticeable when a stylized line intersects another object it still is a detrimental effect.</p><p>The latter problem can be partially solved for near perpendicular areas by adjusting the depth value per fragment. It is possible to approximate a second depth value per vertex by determining the thickness of each segment in direction of the view vector and interpolating between the quad depth and this second depth value in the fragment shader using the same method used for determining the per-fragment normal.</p><p>Using the infinite cylinder C i we can determine the intersection point q i of u i with the cylinder as seen in figure 7. Using the sine rule we can determine that</p><formula xml:id="formula_17">r i sin(α) = d sin( π 2 ) =⇒ d = r i 1 − u i •t i u i •t i 2<label>(11)</label></formula><p>Therefore we can determine the front intersection point q i as</p><formula xml:id="formula_18">q i = p i − u i • d.<label>(12)</label></formula><p>Since the depth buffer is non-linear it is not sufficient to interpolate only between the two depth values in the fragment shader. We have to transfer the z and w values of both the transformed p i and q i  to the fragment shader and interpolate between them based on the same interpolation values used for the normals. After that we can calculate the depth value by dividing z by w and normalizing to [0, 1]. However, the smaller the angle betweent i and u i becomes, the more inaccurate this depth approximation becomes. Thus, a way to deal with the singularity situations has to be found.</p><formula xml:id="formula_19">t i u i d r i p i q i p i x i y îF</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Hybrid Rendering</head><p>Since all visual problems arise around the area of the singularity we need to find another method to display those problem zones.</p><p>A simple yet efficient way is to tessellate the segments as in the brute force method only in those areas. In most of the models and views only a small fraction of the segments lead to the problematic case, so we still gain a huge speed advantage over using the brute force method everywhere. This means we will render the accelerated quad stripes as before in a first pass and then check for problem areas and render tessellated geometry only there.</p><p>It is not yet possible in current state of the art graphics processors to generate additional geometry in a shader, and rendering the whole geometry and simply discarding unneeded segments by transforming them behind one of the clipping planes proved to be very inefficient, so we fell back on a software solution.</p><p>The problem areas are identified the same way as in the shader by calculating the dot product f i between view-vector and tangent. If | f i | &gt; 1 − ε we found a problem area and need to re-render the segments adjacent to p i . The selection of ε is dependent on the geometry and its sampling resolution, but we found values of about 0.02 − 0.03 (corresponding to an angle of about 12-14 degrees) to be good choices.</p><p>To make the tessellated geometry fit correctly to the segments splatted with one quad, it is required to blend the tessellated segment over into a quad before and after the problem area, else there might be irregularities in the shading. There are two main approaches we used here. In the first we render tessellated segments and alpha-blended them at the start and end. This has the advantage that the depth values of the completed picture is correct even around the problematic areas but the downside is that the lighting might look different on the cylinder due to different kind of shaders used. A second possibility is to create a tessellation shader, which is basically an extension of the simple rendering mentioned in the last section where we render not only one quad per segment but four, which is similar to Neulanders quality 2 Paintstrokes (see <ref type="bibr" target="#b11">[12]</ref>). The non-silhouette vertices are additionally extruded withx i to approximate the real geometry. The advantage here is that we can physically transform the vertices to meet up with the quad in the shader without a problem and can use exactly the same normal calculation method as before, but we loose continuity of the depth buffer where the patches meet when rendering with depth correction.</p><p>Since transmitting geometry of any kind from CPU to GPU is still a big bottleneck we can accelerate both methods by precalculating batches (for example using vertex buffer objects) of geometry segments which we can render with a single draw call when one of the segments of the batch is in a problem area instead of sending each segment separately. If we find one segment in a batch where |φ i | &gt; ε we can skip testing the other segments and draw the batch.</p><p>Important factors for performance here are the length of a batch and the maximal tangent deviation of a batch. The maximal angle between all tangents in a batch should be smaller than 10-15 degrees. This allows us to greatly reduce load on the bus between CPU and GPU and therefore accelerating calculations by quite a bit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS &amp; BENCHMARKS</head><p>We implemented our algorithm using OpenGL and GLSL-shader programs. Some benchmark results for our implementation can be found in table 1. On our GeForce FX5900 the fill rate of the shader is only 20 percent slower than a standard Phong shader, enabling halos takes up another portion of the fill rate. The fill rates have been measured using NVidias nvshaderperf <ref type="bibr" target="#b9">[10]</ref>. The static geometry used for comparison was tessellated with 8 quads per GC segment. Segment throughput was measured on a 2x2 pixel view port with the model shown in figure 1 in the center, which has 256 stylized lines and 145374 segments. Performance can vary depending on the ratio of segments per stylized line. In average it is about a factor of three higher for the accelerated methods than for the geometry. The measurements denoted as DL were performed using a display list/vertex buffer objects (the methods are equally fast), the rates denoted with IM were performed in immediate mode (with direct open gl draw calls for every primitive) and the rates denoted with VA were performed with vertex arrays (excluding the time for computing the vertex arrays).</p><p>When enabling the hybrid rendering algorithm the segment throughput drops only slightly and is still 2.5 times faster than the brute-force approach, while the resulting image is near indistinguishable from the geometry approach, and at certain places even looks smoother than the tessellation with eight quads per segment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type</head><p>Fill     <ref type="table">Table 2</ref> shows benchmark results in frames per second on a scene with the Toroid like model shown in figure 1 on the left, consisting of 65536 stylized line segments. The halo for the geometry approach was created by rendering the segments a second time with larger scale, inverted normals and disabled lighting.</p><p>It is interesting to note that even when rendering all segments in immediate mode (meaning we transfer the geometry from CPU to GPU every frame anew, enabling us to modify the geometry at will, for example for highly dynamic data sets) we still achieve a throughput of about 1.9 million segments per second with just the simple shader enabled. This means that it is possible to render a model consisting of up to about 60k streamline segments still in real time with 30 frames per second, so we can handle dynamic models a lot better than with pure geometry where we have to calculate a new tessellation for every frame.</p><p>If we take a look at the size of the geometry it can be noted that to draw a single shaded segment we need only 110 bytes of data (4 vertices, 2 tangents, 2 colors and radius/interpolator information) compared to the 720 bytes needed to render a stripped geometry cylinder segment. This value can be halved for most of the segments since it is possible to render them as a strip instead of single quads.</p><p>Using our rendering technique we have moved the main stress from CPU processing rate and data transfer between CPU and GPU to the vertex and fragment processing on the GPU.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">APPLICATIONS</head><p>Our algorithm has several interesting applications, of which the rendering of streamlines is one of the most important ones. Previously streamlines were mostly rendered with real geometry like streamtubes or -ribbons <ref type="bibr" target="#b14">[15]</ref>, or as illuminated lines <ref type="bibr" target="#b15">[16]</ref>.</p><p>Illuminated Streamlines have the disadvantage that they don't perform lighting across a line, so while providing an improvement to rendering simple lines without lighting they still tend to look somewhat flat. This can especially be noticed for the specular illumination component. Another aspect is that it is not possible to render lines of arbitrary radius, limiting the use to thin lines. If the visual quality of the result is important, our method provides better results, as we are approximating real cylindrical geometry. Our method trades rendering speed for better quality.</p><p>Our method also allows us to map more scalar values to visual components like color, radius and texture in a more intuitive way than it would have been possible using simple line primitives. Values like divergence or rotation of a vector field map very well to radius and texture (as demonstrated in <ref type="figure" target="#fig_11">figure 11</ref>). In the left two images we mapped the velocity to a color scale ranging from purple over red to yellow. The divergence of the vector-field was integrated along the stylized line primitives and the integral was mapped to the radius, such that the radius increases where divergence is positive and decreases where it is negative. The flow direction was visualized by a saturation modulation of the color from low saturation to high saturation. In the two images on the right of <ref type="figure" target="#fig_11">Figure 11</ref> we mapped the integrated rotation to the orientation of a tangential stripe texture. For this we integrated the projection of the 3d rotation vector onto the flow direction. If this component is zero, one can integrate surfaces that are orthogonal to the flow-field. If the component is not zero no surface can be integrated, which hints at a swirl. The mapping to a rotating texture as shown in the two images on the right of <ref type="figure" target="#fig_11">Figure 11</ref> yields an intuitive understanding of the tangential component of the rotation vector.</p><p>Another application of the fast rendering of stylized line primitives outside of flow visualization is the rendering of huge molecular structures. Molecules often consists of a huge amount of atoms visualized as spheres, which can be splatted as ellipsoids as proposed by Gumhold in <ref type="bibr" target="#b7">[8]</ref>, and interconnections which can be rendered using our method. With this it is possible to visualize huge molecules in real time with high visual quality. An example of this can be seen in figure 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>We presented a method to visualize stylized line primitives with generalized cylinders. Our fast rendering approach is visually near undistinguishable from a tessellation of the stylized lines. In some cases the proposed rendering approach even looks smoother. Our hybrid approach overcomes the problems which arise when only using flat quads to approximate the geometry. It optimizes rendering speed by on the one hand keeping the vertex data small and on the other hand the fragment shader simple. In this way we can achieve high fill rates and high segment counts.</p><p>With new, more powerful GPUs coming soon it will be possible to completely generate all needed data on the GPU, without having to rely on the CPU, which would greatly increase the effectiveness of our approach.</p><p>As a main application we had a look at the visualization of 3D flows from vector-or tensor-fields with streamlines. Compared to methods that tessellate the geometry our method is faster and more flexible, while even allowing to easily incorporate halos. Rendering streamlines as shaded line primitives is still faster than our method by the order of a magnitude but delivers visually less qualitative results, failing to provide the amount of depth perception created by splatting real geometry. Further useful applications, like rendering of molecular structures have been presented. <ref type="figure" target="#fig_0">Figure 12</ref>: Comparing a dataset rendered with illuminated streamlines <ref type="bibr" target="#b15">[16]</ref> on the left (flow velocity is mapped to color) to our rendering method in the center (flow velocity also mapped to streamline thickness) and enhanced even further with a texture marking flow direction on the right. <ref type="figure" target="#fig_1">Figure 13</ref>: A streamline with rotation mapped to a normal map texture.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Schematic of a continuous general cylinder with circular profile and a discretization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>One segment of the discretized stylized line is spanned by two tangential circles parameterized synchronously over φ . Left: 3d view, Right: viewed along them i =m i+1 direction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Left: Sketch of an infinite cylinder with silhouette lines dashed. Right: The simplified quad fails to cover the complete area of the GC segment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>figure 4 left), which means that if a point s is part of the silhouette, all points s t = s + t •t i are silhouette points of the infinite cylinder too.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>p</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Left: Reduction of silhouette point calculation to 2D. Right: Determining the silhouette points of a streamline segment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Flipping artifact on the simple shader. Also note the missing part of the silhouette on the center streamline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>igure 7 :</head><label>7</label><figDesc>Left: Calculating the depth value of a cylinder segment. Right: Extrusion scheme for tessellation shader.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Left: Streamlines rendered as simple quads. Center and Right: Hybrid rendering with method 1 and 2, colorized for better visibility.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>32768 Phong shaded streamline segments rendered as static geometry (23.4 fps), with our method (54.8 fps) and difference image.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>2 :</head><label>2</label><figDesc>Frames per second measurement of a 65536 segment toroid model as seen in figure figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Mapping several scalar values of a vector field to streamlines. The left picture shows streamlines with velocity encoded in color (purple to red to yellow), the integrated divergence is mapped to the radius and the flow direction is visualized by a saturation modulation (flow is from low saturation to high saturation). The two pictures on the right use a similar encoding except that the texture encodes the rotation in direction of the flow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>A basket with shadows enabled and a set of streamlines where direction of rotation compared to the tangent is mapped to an arrow texture with shorter arrows depicting areas of higher rotation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table><row><cell cols="2">Throughput measurements. Fill rate measured with NVidias</cell></row><row><cell cols="2">nvshaderperf [10] software. Segments per second measured with</cell></row><row><cell cols="2">display lists/vertex buffer objects, vertex arrays and immediate mode</cell></row><row><cell>respectively on a 2x2 view port.</cell><cell></cell></row><row><cell>Rendering Type</cell><cell>FPS</cell></row><row><cell>Geometry</cell><cell>11.4</cell></row><row><cell>Geometry + Halo</cell><cell>9.7</cell></row><row><cell>Shader</cell><cell>28.2</cell></row><row><cell cols="2">Shader with halo 23.4</cell></row><row><cell>Hybrid</cell><cell>27.0</cell></row><row><cell cols="2">Hybrid with halo 22.5</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table</head><label></label><figDesc></figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Computer descriptions of curved objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Agin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bindford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers, C</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="439" to="449" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Eugenia Montiel, and Ed Zaluska. Modeling generalized cylinders via fourier morphing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alberto</forename><forename type="middle">S</forename><surname>Aguado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="293" to="315" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Jim Blinn&apos;s corner -optimal tubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">F</forename><surname>Blinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="8" to="13" />
			<date type="published" when="1989-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Display of profiled sweep objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">F</forename><surname>Bronsvoort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">R</forename><surname>Van Nieuwenhuizen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="147" to="157" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ray tracing generalized cylinders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willem</forename><forename type="middle">F</forename><surname>Bronsvoort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fopke</forename><surname>Klok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="291" to="303" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Real-time techniques for 3d flow visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anton</forename><surname>Fuhrmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduard</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;98: Proceedings of the conference on Visualization &apos;98</title>
		<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="305" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">High performance generalized cylinders visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Grisoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damien</forename><surname>Marchal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SMI &apos;03: Proceedings of the Shape Modeling International</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page">257</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Splatting illuminated ellipsoids with depth correction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 8th International Fall Workshop on Vision, Modelling and Visualization</title>
		<meeting>8th International Fall Workshop on Vision, Modelling and Visualization</meeting>
		<imprint>
			<date type="published" when="2003-11" />
			<biblScope unit="page" from="245" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Designing optimal curves in 2d</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CEIG 2004</title>
		<meeting>CEIG 2004<address><addrLine>Sevilla, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-07" />
			<biblScope unit="page" from="61" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m">Nvidia developer pages</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Strategies for interactive exploration of 3d flow using evenlyspaced illuminated streamlines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oliver</forename><surname>Mattausch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Theussl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Helwig</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduard</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCCG &apos;03: Proceedings of the 19th spring conference on Computer graphics</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="213" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Rendering generalized cylinders with paintstrokes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivan</forename><surname>Neulander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Michiel Van De Panne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface</title>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="page" from="233" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Feature extraction and visualization of flow fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vrolijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Laramee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics 2002 State-of-the-Art Reports</title>
		<meeting><address><addrLine>Saarbrücken Germany, 2-6</addrLine></address></meeting>
		<imprint>
			<publisher>The Eurographics Association</publisher>
			<date type="published" when="2002-09" />
			<biblScope unit="page" from="69" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Anisotropic volume rendering for extremely dense, thin line data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Schussman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;04: Proceedings of the conference on Visualization &apos;04</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient streamline, streamribbon, and streamtube constructions on unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shyh-Kuang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Ueng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwan-Liu</forename><surname>Sikorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="100" to="110" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interactive visualiztion of 3d-vector fields using illuminated streamlines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malte</forename><surname>Zöckler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Detlev</forename><surname>Stalling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-Christian</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="107" to="113" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
