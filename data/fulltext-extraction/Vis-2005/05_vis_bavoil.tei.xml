<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">VisTrails: Enabling Interactive Multiple-View Visualizations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Louis</forename><surname>Bavoil</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><forename type="middle">J</forename><surname>Crossno</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Sandia National Laboratories</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juliana</forename><surname>Freire</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><forename type="middle">E</forename><surname>Scheidegger</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cláudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huy</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">VisTrails: Enabling Interactive Multiple-View Visualizations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.5.2 [User Interfaces]: Graphical user interfaces (GUI)</term>
					<term>I.3.4 [Graphics Utilities]</term>
					<term>I.3.8 [Applications]</term>
					<term>H.2.8 [Database Applications]: Scientific databases interrogative visualization, dataflow, caching, coordinated views</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: VisTrails Visualization Spreadsheet. This ensemble shows the surface salinity variation at the mouth of the Columbia River over the period of a day. The green regions represent the freshwater discharge of the river into the ocean. A single vistrail specification is used to construct this ensemble. Each cell corresponds to an instance of this specification executed using a different timestamp value.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>In recent years, with the explosion in the volume of scientific data, we have observed a paradigm shift in how scientists use visualization. Projects such as CORIE, an environmental observation and forecasting system for the Columbia River, generate and publish on the Web thousands of new images daily which depict river circulation forecasts and hindcasts, as well as real-time sensor data. <ref type="bibr" target="#b0">1</ref> The growing demand for visualization has led to the development of new and freely available systems <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b23">24]</ref>, which due to increased computational power, wide availability of inexpensive Graphics Processing Units (GPUs), and more efficient visualization algorithms, allow users to generate and interactively explore complex visualizations. Although these new systems represent a significant improvement in raw efficiency compared to first-generation tools <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b26">27]</ref>, they have important limitations. In particular, they lack the infrastructure to properly manage the pipelines, and they do not exploit optimization opportunities during pipeline execution. As a result, the creation, maintenance, and exploration of visualization data products are major bottlenecks in the scientific process, limiting the scientists' ability to fully exploit their data.</p><p>Exploring data through visualization requires scientists to assemble dataflows that apply sequences of operations over a set of data products. Often, insight comes from comparing the results of a variety of visualizations <ref type="bibr" target="#b22">[23]</ref>. For example, <ref type="figure">Figure 1</ref> shows a set of CORIE images used to study the salinity variation at the mouth of the Columbia river. Unfortunately, today the process to create these complex ensembles is cumbersome and time-consuming. Although individual dataflows can be constructed using point-and-click interfaces in systems such as IBM Data Explorer (DX) <ref type="bibr" target="#b10">[11]</ref>, Advanced Visual Systems AVS <ref type="bibr" target="#b26">[27]</ref>, SCIRun <ref type="bibr" target="#b19">[20]</ref> and ParaView <ref type="bibr" target="#b13">[14]</ref>, executing variations of a given pipeline with different parameters requires users to manually modify the parameters through the user interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Visualization 2005</head><p>October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE.</p><p>This mechanism is clearly not scalable for generating more than a few visualizations. Besides, as the parameters are modified, the previous values are forgotten. This places the burden on the scientist to first construct the visualizations and then to remember what values led to a particular image.</p><p>Another source of complexity in this process comes from the visualization operations themselves. These operations are often computationally and memory-intensive. As a result, visualization pipelines may comprise long sequences of expensive steps with large temporary results, limiting a user's ability to interactively explore their data. This problem is compounded in a multi-view scenario. Although current systems use dataflows to represent pipelines, they do not fully exploit key features of the dataflow model. Notably, they may recompute the same results over and over again if so defined in the dataflow.</p><p>VisTrails enables interactive multiple-view visualizations by simplifying the creation and maintenance of visualization pipelines, and by optimizing their execution. Our design goals included:</p><p>• creating an infrastructure that maintains the provenance of a large number of visualization data products;</p><p>• providing a general framework for efficiently executing a large number of potentially complex visualization pipelines;</p><p>• providing a user interface that simplifies multiple-view comparative visualization.</p><p>Instead of creating yet another visualization system, our goal was to build an extensible and flexible infrastructure that can leverage (and be combined with) existing systems (e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b26">27]</ref>). Here, we describe our initial prototype that was built on top of Kitware's Visualization Toolkit (VTK) <ref type="bibr" target="#b23">[24]</ref>.</p><p>In our system, the visualization trail (or vistrail) is a formal specification of a pipeline. It provides not only a record of the provenance for the generated image (or images), but it can also be automatically executed. Unlike existing dataflow-based systems, in VisTrails there is a clear separation between the specification of a pipeline and its execution instances. This separation enables powerful scripting capabilities and provides a scalable mechanism for generating a large number of visualizations -the specification serves as a template and users can execute it using different parameters. For example, <ref type="figure">Figure 1</ref> illustrates a multi-view visualization built using a single vistrail specification executed over distinct timestamp values. VisTrails also leverages the vistrail specification to identify and avoid redundant operations. This optimization is especially useful for multiple-view visualizations, where vistrails may contain overlapping subsequences (e.g., when variations of the same trail are executed). By reusing results computed for overlapping subsequences of different pipelines, VisTrails provides improved interactivity. We represent the vistrails specifications using XML. As we discuss in Section 3.1, this has many benefits. In particular, it allows users to query the specifications and their instances; and it greatly simplifies the sharing of visualization pipelines.</p><p>In Section 2 we review the related work. In Section 3, we describe the design and implementation of VisTrails. In Section 4, we illustrate the benefits and improved performance achieved by VisTrails in three different application scenarios. We close in Section 5, where we outline directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Several systems are available for creating and executing visualization pipelines <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b26">27]</ref>. Most of these systems use a dataflow model, where a visualization is produced by assembling visualization pipelines out of basic modules. They typically provide easy-to-use interfaces to create the pipelines. However, as discussed above, these systems lack the infrastructure to properly <ref type="figure">Figure 2</ref>: VisTrails Architecture. Users create and edit visualization pipelines using the Vistrail Builder user interface. The vistrail specifications are saved in the Vistrail Repository. Users may also interact with saved vistrails by importing them into the Visualization Spreadsheet. Each cell in the spreadsheet represents a view that corresponds to a vistrail instance; users can modify the parameters of a vistrail as well as synchronize parameters across different cells. Vistrail executions are controlled by the Vistrail Cache Manager, which keeps track of operations that are invoked and their respective parameters. Only new combinations of operations and parameters are requested from the Vistrail Player, which executes the operations.</p><p>manage a large number of pipelines; and often apply naïve execution models that do not exploit optimization opportunities.</p><p>A formal model for capturing the visualization exploration process was proposed by Jankun-Kelly et al. <ref type="bibr" target="#b12">[13]</ref>. The vistrail model shares many of the features and benefits of this model, including: the ability to record visualization sessions at a higher-level than simple logs; the use of an XML dialect to represent a pipeline, which enables easy sharing of results and process information; and the maintenance of visualization provenance. However, there are important differences between our approaches. Whereas the focus of Jankun-Kelly et al. was to design a model for the visualization process, the model is just one component of VisTrails (albeit a very important one). We instead focus on how to effectively use the model to both optimize pipeline execution and to simplify the creation of large visualization ensembles. Currently, in VisTrails, session history can be reconstructed from information stored in a set of vistrail instances.</p><p>In the recent literature, several works have addressed different aspects of the management of visualization processes, from maintaining detailed provenance of data exploration processes <ref type="bibr" target="#b14">[15]</ref> to grid-enabling visualization systems <ref type="bibr" target="#b2">[3]</ref>. These works are complementary and the ideas can be integrated into VisTrails. Kreuseler et al. <ref type="bibr" target="#b14">[15]</ref> proposed a history mechanism for exploratory data mining, but their ideas are also applicable to exploratory visualization. They use a tree structure to represent the change history, and describe how undo and redo operations can be calculated in this tree structure. This mechanism provides a detailed provenance of the exploratory process. We intend to add a more expressive history mechanism to VisTrails in future work. Since we store vistrail specifications in an XML format, an XML-specific versioning scheme such as the time-stamp-based approach proposed by Buneman et al <ref type="bibr" target="#b3">[4]</ref> is an attractive alternative.</p><p>Brodlie et al. <ref type="bibr" target="#b2">[3]</ref> describe sgViz, a system that extends IRIS Explorer. <ref type="bibr" target="#b1">2</ref> Their system allows the distributed execution of a visualization pipeline over a set of Grid resources. An important contribution is a layered architecture that allows different "bindings" for a given pipeline specification in each layer. With this architecture, different visualization systems can be easily integrated (in the logical layer) and different execution strategies can be implemented which bind individual operations to places in the grid (in the physical layer). Similar to sgViz, VisTrails can be used as a middleware over different visualization systems and it also uses an XML dialect to represent visualization pipelines. SgViz's dialect differs from ours in one significant aspect: the vistrail model clearly separates the visualization modules from the flow of operations (the topology of the dataflow network). By separating the connections from the modules we can more easily support different execution models, as well as new control constructs. In the current system,  our goal was to optimize the sequential execution of a pipeline (or set of pipelines) by avoiding unnecessary recomputations. Parallel execution and distribution of vistrail operations on the Grid are issues we intend to pursue in future work. It is worthy of note that our representation of the trails as a tabled logic program (see Section 3.2) lends itself naturally to automatic parallelization <ref type="bibr" target="#b8">[9]</ref>.</p><p>VisTrails provides an infrastructure that enables the effective use of several visualization techniques which aid users to explore and understand the underlying information. In particular, it supports the three primary techniques described by Roberts <ref type="bibr" target="#b21">[22]</ref>: Multiform visualization, the ability to display the same information in different ways, can be achieved by appropriately setting parameters or modifying a trail (e.g., the top row of <ref type="figure" target="#fig_4">Figure 8</ref> shows the Visible-Human dataset rendered using isosurfaces whereas the bottom row uses volume rendering); abstract views, which apply the same visualization algorithm using different simplification criteria, can be constructed by refining and modifying a trail specification; and direct manipulation, which allows objects to be directly interrogated, scaled and positioned, can be achieved both through the Vistrail Builder and through the Vistrail Spreadsheet, and in the latter, different views can be coordinated (see Section 3.4).</p><p>The use of spreadsheets for displaying multiple images was proposed in previous works. Levoy's Spreadsheet for Images (SI) <ref type="bibr" target="#b15">[16]</ref> is an alternative to the flow-chart-style layout employed by many earlier systems using the dataflow model. SI devotes its screen real estate to viewing data by using a tabular layout and hiding the specification of operations in interactively programmable cell formulas. The 2D nature of the spreadsheet encourages the application of multiple operations to multiple data sets through row or column-based operations. Chi <ref type="bibr" target="#b4">[5]</ref> applies the spreadsheet paradigm to information visualization in his Spreadsheet for Information Visualization (SIV). Linking between cells is done at multiple levels, ranging from object interactions at the geometric level to arithmetic operations at the pixel level. The difficulty with both SI and SIV is that they fail to capture the history of the exploration process, since the spreadsheet only represents the latest state in the system.</p><p>The Vistrail Spreadsheet supports concurrent exploration of multiple visualizations. The interface is similar to the one proposed by Jankun-Kelly and Ma <ref type="bibr" target="#b11">[12]</ref> and it provides a natural way to explore a multi-dimensional parameter space. The separation between parameters and the actual network makes the vistrail model especially suitable to be used in such an interface. Users can change any of the parameters present in a vistrail and create new vistrail instances; and they can also synchronize different views over a set of vistrail parameters -changes to this parameter set are reflected in related vistrails shown in different cells of the spreadsheet. In addition, other corresponding visualization mechanisms are possible using the spreadsheet, such as reflection or nested views. The management of scientific data and processes has attracted a lot of attention in the recent literature (see e.g., <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b24">25]</ref>). Although our effort was motivated by visualization, the VisTrails framework is extensible and can also be used for general scientific workflows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SYSTEM ARCHITECTURE AND IMPLEMENTATION</head><p>The high-level architecture of VisTrails is shown in <ref type="figure">Figure 2</ref>. The different components of the system are described in detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Vistrail Data Model</head><p>A vistrail specification consists of a sequence of operations used to generate a visualization. It records the visualization provenance and it can also be used to automatically re-generate the images. A vistrail is stored as an XML document. <ref type="figure" target="#fig_0">Figure 3</ref> shows an excerpt of the XML schema <ref type="bibr" target="#b25">[26]</ref> for a vistrail. <ref type="bibr" target="#b2">3</ref> A vistrail element contains of a set of modules, connections between these modules, and an optional annotation element. Each module may contain one or more functions. A function has a returnType and a set of parameters consisting of attribute-value pairs. The optional boolean attribute cacheable indicates whether the module is eligible for caching (see Section 3.2). An actual vistrail instance is depicted in <ref type="figure" target="#fig_1">Figure 4</ref>. Each node in the graph corresponds to a module element in the schema; and an edge between two nodes corresponds to a connect element. The connections capture the data dependencies among the different modules. The data generated by a module is output through its oport and can be connected to the iport of a different module. As we discuss below, these dependencies are used by the Cache Manager to avoid redundant computations, as well as to ensure that, when changes are made to a vistrail, only the steps affected by the change are re-executed.</p><p>The XML representation for vistrails allows the reuse of standard XML tools and technologies. In particular, we use Xerces  <ref type="figure">Figure 5</ref>: Pseudocode for the vistrail execution algorithm with cache management. When a module is to be executed, the VCM first checks its cache. If an entry is found for the module (with requested parameters), the cached result is returned. Otherwise, VCM invokes the Vistrail Player (line 11) which executes the appropriate API call and returns the results to the VCM.</p><p>parse and validate the vistrail specification; and XML query languages (e.g., XPath <ref type="bibr" target="#b28">[30]</ref> and XQuery <ref type="bibr" target="#b1">[2]</ref>) to query vistrail specifications and instances. Using an XML query language, a user can query a set of saved vistrails to locate a suitable one for the current task; query saved vistrail instances to locate anomalies documented in annotations of previously generated visualizations; locate data products and visualizations based on the operations applied in a pipeline; cluster vistrails based on different criteria; etc. For example, the XQuery query below lists all vistrails (together with their names, annotations and functions) that use an isosurface computation and that have been found to contain anomalies: for $vt in document("vt-repository.xml")/vistrail, $module in $vt/module/[contains(./name,"vtkContourFilter")] where $vt[contains(./annotation,"anomal")] return &lt;anomaly&gt; {$vt/name} {$vt/annotation} {$module/function} &lt;/anomaly&gt; Another important benefit of using an open, self-describing, specification is the ability to share (and publish) vistrails. For example, an image can be published together with its associated vistrail, allowing others to easily reproduce the results.</p><p>The module element in the vistrail schema is general and captures a wide range of applications, from simple scripts to VTK modules and Web services <ref type="bibr" target="#b27">[28]</ref>. Note that for applications that do not fit this structure, it is easy to add new kinds of module elements -as long as they fit the dataflow model and appropriate functions are provided to execute these modules (see Section 3.3). This makes our VisTrails extensible, and in particular, also suitable for executing general scientific workflows <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Vistrail Cache Manager</head><p>The Vistrail Cache Manager (VCM) schedules the execution of modules in vistrails. As vistrail steps are executed, the VCM stores their results, i.e., a signature for the module (which includes its name and parameter values) together with a handle to the output results. When the VCM identifies previously computed subnetworks in a vistrail, it locally transforms a possibly expensive computation into a constant-time cache lookup. To maximize the utility of the cache, the cached results are shared among vistrails. This allows  <ref type="figure">Figure 6</ref>: Generation of unique keys for subnetworks. The two sorts (lines 7 and 16) make sure that reordering in the module and connection specifications do not affect the unique ID. The procedures UNIQUE-ID-FROM-ATOM and UNIQUE-IF-FROM-CONN only use information that is necessary to distinguish between dataflows to create the IDs. Lines 10-14 make sure that the connections IDs are computed from the unique module IDs, and not from the specific IDs given in the vistrail. This guarantees that all networks with the same modules and connectivity get the same ID.</p><p>the transparent elimination of redundant computation in overlapping sequences of different vistrails. <ref type="figure" target="#fig_3">Figure 7</ref> illustrates the actions of the cache manager for two vistrails.</p><p>The VCM takes as input a vistrail instance (an XML file). To ensure that only new sub-sequences are executed, the cache manager analyzes the vistrail specification to identify data dependencies between cacheable modules -the dependency information is captured by the connect element in the specification (see <ref type="figure" target="#fig_0">Figure 3</ref>). Note that we distinguish between cacheable and non-cacheable modules. For some applications, it may not make sense to cache results from all of the modules. When new modules are added to VisTrails, an additional flag may be passed to indicate caching eligibility. For example, for VTK classes such as vtkProperty, which have no output, the entire object is passed to another class.</p><p>The dependency computation is done concurrently with the vistrail execution. The pseudocode for the execution procedure is given in <ref type="figure">Figure 5</ref>. When a vistrail is invoked (e.g., it is loaded in a cell of the Visualization Spreadsheet), a depth-first search (DFS) is started from the sinks of the vistrail graph, traversing the graph upstream (in the opposite direction of the connections). Each step of the DFS collects a subnetwork that is bounded by cacheable modules. The algorithm then calls itself on these modules to ensure their results are in the cache. If values are already present in the cache, their results are immediately returned. When the recursive calls return, the entries list will contain a set of objects from the cache. The function TRANSFORM-NETWORK replaces the entire subnetwork that ends at a cacheable module with a special module that looks up the result in the cache. This result will always be in the cache, since TRANSFORM-NETWORK is always called after the appropriate EXEC-SUBNETWORK-UP-TO calls are issued. This algorithm finds all the needed dependencies and only computes the needed modules. (This can be proven by structural induction on the topological sort of the network.).</p><p>An important issue is how to identify entries in the cache. We associate each entry with a key that encodes all the information necessary to compute the associated cached result. If we store too much information (like node identifiers particular to a certain vistrail), we will unnecessarily restrict data sharing and substantially reduce the utility of the cache. On the other hand, if we fail to store information that influences the computation result, the cache lookup may return incorrect results. We use a hashing scheme that strips unnecessary information from objects and generates unique keys for subnetworks. The pseudocode for the key generation algorithm is shown in <ref type="figure">Figure 6</ref>. Note that this scheme also ensures that when changes are applied to a vistrail, only steps that are affected by the changes are re-executed.</p><p>The unique ID is structural in a very specific sense: all subnetworks sharing the same modules, parameters and connectivity will have the same ID. It encodes all the structural information required to identify redundant operations. Note that there may be structurally different subnetworks that produce the same result. We do not attempt to identify these for two reasons. First, this requires knowledge of the internals of the modules. Second, and most importantly, if we assume that the modules are sufficiently general, the problem becomes undecidable <ref type="bibr" target="#b6">[7]</ref>. In fact, treating modules as black boxes is essential to the extensibility of VisTrails. The only requirement is that each module must be stateless: its behavior must be fully captured by its name, input parameters, and description of the upstream modules. (This is precisely what the UNIQUE-ID algorithm captures). We believe such an assumption is reasonable: mutable state inside modules destroys any guarantees of reproducibility, which are essential for scientific tasks.</p><p>The dataflow-oriented execution model of a vistrail can be naturally represented as a Datalog program <ref type="bibr" target="#b18">[19]</ref>. In our prototype, vistrails are translated into equivalent Datalog programs which are evaluated by the XSB Prolog/deductive database system <ref type="bibr" target="#b20">[21]</ref>. The algorithms described in <ref type="figure">Figures 5 and 6</ref> were implemented in Prolog; and we use XSB's foreign language interface to invoke the Vistrail Player.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Vistrail Player</head><p>The Vistrail Player (VP) receives as input an XML file for a vistrail instance and executes it using the underlying visualization API. Currently, the VP supports VTK classes. It is a very simple interpreter. First, it directly translates the vistrail modules into VTK classes and sets their connections. Then, it sets the correct parameters for the modules according to the parameter values in the vistrail instance. Finally, the resulting network is executed by calling update methods on the sink nodes. The semantics of each particular execution are defined by the underlying API.</p><p>The VP is unaware of caching. To accommodate caching in the player, we added a new vtkDataObjectPipe class to VTK that pipes data from the cache to the rest of the network. The VCM is responsible for replacing a complex subnetwork that has been previously executed with an appropriate vtkDataObjectPipe (the red Cache Lookup modules in <ref type="figure" target="#fig_3">Figure 7)</ref>. After a vistrail instance is executed, its outputs are stored in new cache entries.</p><p>The VP needs the ability to create and execute arbitrary VTK modules from a vistrail. This requires mapping VTK descriptions, such as class and method names, to the appropriate module elements in the vistrail schema. Instead of manually constructing a complex mapping table, we use the VTK automatic wrapping mechanism. An automated program generates all required bindings directly from the VTK headers. This allows our system to expose the functionality of any VTK-compliant class without any additional coding, including user-contributed classes. The special vtkDataObjectPipe class itself was introduced in this fashion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Creating and Interacting with Vistrails</head><p>The Vistrail Builder (VB) provides a graphical user interface for creating and editing vistrails. It writes (and also reads) vistrails in the same XML format as the rest of the system. It shares the familiar modules-and-connections paradigm with dataflow systems. In order to generate the visual representation of the modules, it reads the same data structure generated by the VP VTK wrapping process (Section 3.3). Like the VP, the VB requires no change to support additional modules. The VB is implemented in lefty, as an extension to dotty, a graph editor that is part of the graphviz software package <ref type="bibr" target="#b7">[8]</ref>. We made several modifications to both lefty and dotty, such as adding the ability to read and write XML. <ref type="figure" target="#fig_1">Figure 4</ref> shows a vistrail built using the VB.</p><p>To allow users to compare the results of multiple vistrails, we built a Visualization Spreadsheet (VS). The VS provides the user a set of separate visualization windows arranged in a tabular view. This layout makes efficient use of screen space, and the row/column groupings can conceptually help the user explore the visualization parameter space. The cells may execute different vistrails and they may also use different parameters for the same vistrail specification (see <ref type="figure" target="#fig_4">Figure 8</ref>). To ensure efficient execution, all views share the same cache. Users can also synchronize different views through the vistrails' parameters. For example, a set of cells in the VS can be set to share the same camera, while varying the other vistrail parameters. The user interface actions have been kept as simple as possible. For instance, to change a parameter, the user selects the desired views and clicks on "Set Parameters". Then, they can double-click on a function in the tree view, and set the parameters of the function in the dialog window.</p><p>The contents of a spreadsheet can be saved as an XML file that has sections for describing the GUI layout as well as the vistrail instances in each cell -the instances saved in a spreadsheet conform with the vistrail schema (Section 3.1). The spreadsheet was implemented using vtkQt. <ref type="bibr" target="#b3">4</ref> Because it uses Qt, the VS runs on multiple architectures. We have tested it on Mac, Linux and Windows. The top row shows the rendering of two iso values, whereas in the second row, images are created using volume rendering. The cameras for the cells in the rightmost column in the spreadsheet above are synchronized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CASE STUDIES</head><p>VisTrails is useful for a variety of visualization applications. It can be used as the means to explore the parameters in a visualization, repeat visualizations across different data, and to compare different visualization techniques. We have selected a few case studies which show different applications of VisTrails and the advantages to using the system over traditional approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Time-Varying Visualization</head><p>The CORIE project described in Section 1 generates enormous amounts of measurement and simulation data each day. Visualizing this data is critical to understand the environmental issues that the project targets. Due to the complexity and size of the data to be visualized, approaches for 3D visualization have not been automated like the 2D plots and images available from their Web site. And even for the 2D plots, the automation is done by handcoding scripts -new scripts need to be created any time a new visualization is required. Current workflows for 3D visualizations of salinity involve loading a data file from the filesystem that includes the time, temperature, and salinity for a number of time steps. This data is used on top of the existing geometry (i.e., the river bathymetry) to find an isosurface of interest, then animated using a subset of the time steps. Today, this task is completely manual and is repeated any time a new data set is visualized. VisTrails provides the necessary infrastructure to automate this process to a great extent.</p><p>We created a reader for the CORIE data and incorporated it as a vistrail module. The Vistrail Builder is used to create a vistrail that reads the CORIE data and applies transparent isosurfaces to the data. This vistrail is then loaded into the Visualization Spreadsheet where the isosurface parameters are easily manipulated until the desired image is achieved. As the user finds useful visualizations, the results are copied into the next window and the user continues to adjust parameters on one or more windows. In the example shown in <ref type="figure">Figure 1</ref>, multiple time steps are explored in the spreadsheet windows. Once suitable parameters are found, the user has the option of creating another row of windows in the spreadsheet and using the same parameters on another salinity data set. This allows the user to easily compare the results of a forecast at multiple time steps with the actual measured data for the same timesteps. Previously, this task would have been accomplished by manually adjusting parameters and saving images for each data set, which would then have been montaged using Microsoft Powerpoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Scalar Visualization</head><p>Visualizing scalar data that is generated from CT and MR devices has been the subject of much research in the volume visualization community. Two techniques that are common for visualizing this type of data are isosurfacing and direct volume rendering. Many existing tools provide interfaces to easily adjust the contour value needed to create an isosurface or to adjust the transfer function for volume rendering. However, to visualize multiple views of a dataset simultaneously, a user is required to save the images to separate files and view them together using an image processing tool. This prevents the user from directly manipulating the images, since they are static and need to be re-generated if parameters change.</p><p>With VisTrails, a user can easily visualize multiple views of the same dataset. By taking advantage of the caching capabilities in VisTrails, in many scenarios the exploration of multiple visualizations requires little more computation than visualizing a single image. Furthermore, the user has the ability to directly compare the results of different parameters or visualization methods. For example, <ref type="figure" target="#fig_4">Figure 8</ref> shows multiple views of a head scan using isosurfacing and volume rendering. A user could also reuse the results of previous computations simply by querying the VisTrail Repository. An example of this would be a user who is given a new scalar data set to visualize. Instead of using traditional tools to visualize the data from scratch, the scientist has the option to query previous visualizations to find vistrails that perform a similar task. After finding the desired vistrail in the Vistrail Repository, the user can easily visualize the new data using the same pipeline by simply modifying the data reader in the vistrail. Besides alleviating the amount of repetitious tasks the user has to perform, VisTrails also promotes knowledge sharing. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Diffusion Tensor Visualization</head><p>A final example of an application for the VisTrails system is in visualizing diffusion tensor data. A common task in visualization is to present the user with multiple, sometimes repetitive, visual queues that attempt to quantitatively describe an aspect of the data. One derived quantity of diffusion tensor data is anisotropy, which may help a scientist isolate areas of interest. In our example, we are visualizing the right half of a brain and use the anisotropy to encode information about the structure of the brain. Finding useful visualizations that show the data together with the derived quantity can be a difficult task. <ref type="figure" target="#fig_5">Figure 9</ref> shows the results of several visualizations of the brain using isosurfaces that are colormapped with anisotropy. To better visualize this data, we used several univariate colormaps to find one that best describes the data. Thus for a given isosurface, vistrails were modified to include univariate colormaps that vary in hue, saturation, and value. Once a variety of visualizations were created, we replicated these results using another isosurface and compared the results with the original. These operations take advantage of the caching capabilities of VisTrails because the isosurface is computed only once (for the first vistrail that is executed) and it is reused by all other cells -only the colormaps change across cells. This is done completely automatically even when using multiple different pipelines. Without VisTrails, this task would require opening several windows in a visualization tool and either recomputing the same isosurfaces for each of them or manually creating one pipeline that shares certain components. VisTrails provides the user with a fast and automated technique for comparatively building visualizations and saving workflows for future reuse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Performance Issues</head><p>An important consideration in any interactive visualization system is performance, in particular responsiveness to changes triggered by direct manipulation of images. Since visualization pipelines can be long and complex, achieving interactive speeds is a challenging problem, and becomes even more challenging in a multiple-view system. There are two broad classes of operations in a visualization pipeline: operations that perform data filtering (or preparation) and operations that perform real-time rendering. The VCM optimizes the data filtering operations. The performance gains obtained by caching are heavily dependent on the set of vistrails used in a given session. For instance, for both the brain and visible hu-man case studies, where there is substantial overlap, caching leads to speedups that vary between 2 and 2.5 times. For the CORIE case study, on the other hand, there is no overlap among the vistrails. In this case, the caching mechanism actually incurs overheads. However, the overheads are very small -under 1 percent.</p><p>By representing vistrails in XML, we incur a slight overhead for parsing. However, even a large vistrail is insignificant in comparison to the size of the data visualized. Therefore, the performance cost of parsing the XML is negligible in the overall visualization.</p><p>Changes to class design and algorithms have the potential to improve the efficiency of the VCM. In particular, some techniques require substantial preprocessing steps to enable faster update times, e.g., the out-of-core isosurface technique of Chiang et al. <ref type="bibr" target="#b5">[6]</ref>. In order to leverage these techniques with the conventional VTK pipeline, it is necessary to explicitly enforce the availability of the required index structures for subsequent operations -and this requires programming. In contrast, the VCM achieves the same behavior in a transparent (and automatic) fashion.</p><p>Increasing the number of synchronized views has direct effect on the rendering frame rate. The reason is obvious: all views share a single GPU and the overall frame rates depend highly on the combined complexity of the models being shown. In practice, if the frame rate is too slow to interact with a given group of views, we can disable synchronization and interact with a single view until the desired viewpoint and/or values are determined. At that time, we turn synchronization back on. A comprehensive solution to this problem requires the availability of time-critical dynamic level-ofdetail rendering algorithms for each of the types of data supported by the system. The development of these renderers is an active area of research <ref type="bibr" target="#b17">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION AND FUTURE WORK</head><p>VisTrails streamlines the creation and execution of complicated visualization pipelines. It provides infrastructure that gives users a dramatically improved and simplified process to analyze and visualize large ensembles of complex visualizations. Using a vistrail, users are able to resume their explorations where they left off; to easily apply identical operations to a new data set without having to redo a long sequence of operations; to share their findings with colleagues; to test new codes by comparing visualizations of the results generated by different versions of a simulation. The amount of data a user can explore depends on the time it takes until the analysis results can be viewed. By caching intermediate results and sharing computations, VisTrails greatly reduces the response time, allowing users to efficiently explore large volumes of data.</p><p>The separation of the pipeline specification from its instances has several benefits. The correspondence between parameter values and the resulting visualizations is naturally maintained in the system; and by combining this with a mechanism that controls the versions of the pipeline specifications (e.g., <ref type="bibr" target="#b3">[4]</ref>), a complete history of the pipelines can be maintained -a detailed (and persistent) record of the provenance of visualizations. This separation also enables powerful scripting capabilities. By viewing a pipeline specification as a template and allowing users to specify sets of inputs for a given pipeline, VisTrails provides a scalable mechanism for generating a large number of visualizations.</p><p>Pipeline specifications can be analyzed and optimized. VisTrails identifies and avoids redundant computation in or across pipelines (Section 3.2). This feature is especially useful for exploring multiple visualizations in a multi-view environment, where sharing computations and reusing results are key for achieving interactivity. As we discuss in Section 4, this optimization leads to substantial performance improvements, enabling interactive exploration of a large number of visualizations. As any caching system, VisTrails needs to apply some cache replacement policy. Since entries in the cache have different memory footprints and modules may have widely different execution times, simple techniques such as LRU are clearly suboptimal. We are currently investigating specialized policies that are more suitable for our problem.</p><p>Another direction we plan to follow in future work is to Gridenable vistrails, allowing them to be executed in a distributed fashion, over different processing nodes in the Grid. This will require more sophisticated evaluation algorithms (akin to adaptive query processing techniques, such as <ref type="bibr" target="#b0">[1]</ref>) that are able to adapt to variability in network delays and resource unavailability.</p><p>A vistrail instance stores information about provenance of derived images. This information includes the name and location of input (raw) data files. To ensure reproducibility of trail executions, our system can keep copies of the raw data. Although we use a database to store the meta-data (i.e., the trail specification and instances), the raw data is stored in the file system. One potential problem with this simple approach is that the raw data files can be moved, deleted, or modified. More sophisticated mechanisms can be used to maintain the raw data <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b24">25]</ref>. For example, the RHESSI Experimental Data Center <ref type="bibr" target="#b24">[25]</ref> uses a mapping scheme to locate and retrieve data items, and it ensures data consistency by only allowing raw data to be accessed through the meta-data available in the database.</p><p>The beta version of VisTrails (including the GUIs) runs on multiple platforms. It has been tested on Linux, Mac and Windows. Over the next year, we intend to start a beta testing program in preparation for a future public release.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Excerpt of the XML schema for vistrails. This schema captures all information required to re-execute a vistrail. The connect elements represent data dependencies among modules, which are key to automatic caching. The use of XML allows the reuse of standard XML technology, including validating parsers and query languages. It also simplifies the sharing of visualization pipelines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>A sample vistrail. This snapshot of the Vistrail Builder consists of a sequence of VTK steps that read a file, compute an isosurface and render the resulting image. Users create vistrails using the point-and-click interface of the Vistrail Builder -they can add modules, and connect the different modules and ports.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>UNIQUE-ID(subnetwork) 1 if IS-ATOMIC(subnetwork) 2 then return UNIQUE-ID-FROM-ATOM(subnetwork) 3 else module-ids ← {} 4 for module ∈ MODULES(subnetwork) 5 do id ← UNIQUE-ID-FROM-ATOM(module) 6 ADD-TO-LIST(module-ids, id) 7 SORT(module-ids) 8 conn-ids ← {} 9 for conn ∈ CONNECTIONS(subnetwork) 10 do omodule ← OUTPUT-PORT-ID(conn) 11 ufrom ← INDEX-OF-ID(module-ids, omodule) 12 imodule ← INPUT-PORT-ID(conn) 13 uto ← INDEX-OF-ID(module-ids, omodule) 14 id ← UNIQUE-ID-FROM-CONN(ufrom, uto) 15 ADD-TO-LIST(conn-ids, id) 16 SORT(conn-ids) 17 return (module-ids, conn-ids)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>In order to execute Vistrail 1, the cache manager first determines the data dependencies among its modules. It then computes a series of subnetworks that generate the intermediate results for this pipeline (steps 1-5). Each intermediate result is associated with a unique identifier in the cache. Gray nodes represent non-cacheable modules; yellow nodes indicate cacheable modules; and red nodes indicate vistrail modules that are replaced with cache lookups. Ghosted modules are not present in the subnetworks, but they contribute to the construction of subnetwork cache keys. When Vistrail 2 is scheduled for execution (step 6), the results for the Reader-Isosurface subnetwork previously computed for Vistrail 1 (in step 4) are reused. Thus, Vistrail 2 requires no expensive computations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Vistrail Spreadsheet. Parameters for a vistrail loaded in a spreadsheet cell can be interactively modified by clicking on the cell. Cameras as well as other vistrail parameters for different cells can be synchronized. This spreadsheet shows different visualizations of the Visible-Human dataset using different algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>VisTrails Spreadsheet showing the results of multiple visualizations of diffusion tensor data. The horizontal rows explore different colormapping schemes, while the vertical columns use different isosurfaces.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">http://www.ccalmr.ogi.edu/CORIE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">http://www.nag.co.uk/Welcome IEC.html</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">For simplicity, here we use the type syntax of the XML Query Algebra which is less verbose and more readable than XML Schema.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">http://www.matthias-koenig.net/vtkqt</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. VisTrails was originally motivated by the CORIE project. António Baptista has provided us valuable input for the system design as well as several CORIE data sets for our experiments. We thank Gordon Kindlmann for the brain data set and the Visible Human Project for the head. This work </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Eddies: Continuously adaptive query processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Avnur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="261" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">XQuery 1.0: An XML query language. W3C Working Draft</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Boag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Siméon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stefanescu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visualization in grid computing environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Brodlie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gallop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sagar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Walton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Archiving scientific data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tajima</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="42" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Principles for information visualization spreadsheets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">H</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Riedl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Konstan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="38" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Interactive out-of-core isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sigal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Weyuker</surname></persName>
		</author>
		<title level="m">Computability, Complexity, and Languages</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Graphviz -open source graph drawing tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ellson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Woodhull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="483" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Exploiting parallelism in tabled evaluations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLILP</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="115" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Earth system science workbench: A data management infrastructure for earth science products</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Frew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="180" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Opendx</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com/dx" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Visualization exploration and encapsulation via a spreadsheet-like interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jankun-Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="275" to="287" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A model for the visualization exploration process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jankun-Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gertz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kitware</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paraview</surname></persName>
		</author>
		<ptr target="http://www.paraview.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A history mechanism for visual data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kreuseler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nocke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Information Visualization Symposium</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Spreadsheet for images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="139" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scientific workflow management and the kepler system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ludäscher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Altintas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Berkley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Higgins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Jaeger-Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice &amp; Experience, Special Issue on Scientific Workflows</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Level of Detail for 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Morgan-Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Computing With Logic: Logic Programming With Prolog</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SCIRun: a scientific programming environment for computational steering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Xsb -a system for efficiently computing well founded semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sagonas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Warren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LPNMR</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Waltz -exploratory visualization tool for volume data, using multiform abstract displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIE</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">3298</biblScope>
			<biblScope unit="page" from="112" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Multiple-View and Multiform Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIE</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="176" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit An Object-Oriented Approach To 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Kitware</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Scientific data repositories: Designing for a moving target</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">R</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="349" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Thompson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Beech</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maloney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mendelsohn</surname></persName>
		</author>
		<title level="m">XML Schema Part 1: Structures. W3C Working Draft</title>
		<imprint>
			<date type="published" when="2000-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The application visualization system: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="http://www.w3.org/2002/ws" />
		<title level="m">W3C. Web services activity</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<ptr target="http://www.w3.org/TR/xpath20" />
		<title level="m">XML path language (XPath) 2.0</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
