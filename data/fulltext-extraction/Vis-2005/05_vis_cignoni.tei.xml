<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Batched Multi Triangulation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni -Isti -Cnr</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">ISTI-CNR</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabio</forename><surname>Ganovelli -Isti -Cnr</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Gobbetti -Crs4</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabio</forename><surname>Marton -Crs4</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Federico</forename><surname>Ponchio -Isti -Cnr</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Scopigno -Isti -Cnr</surname></persName>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">POLARIS</orgName>
								<address>
									<addrLine>Edificio 1</addrLine>
									<postCode>09010</postCode>
									<settlement>Pula</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Batched Multi Triangulation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The Multi Triangulation framework (MT) is a very general approach for managing adaptive resolution in triangle meshes. The key idea is arranging mesh fragments at different resolution in a Directed Acyclic Graph (DAG) which encodes the dependencies between fragments, thereby encompassing a wide class of multiresolution approaches that use hierarchies or DAGs with predefined topology. On current architectures, the classic MT is however unfit for real-time rendering, since DAG traversal costs vastly dominate raw rendering costs. In this paper, we redesign the MT framework in a GPU friendly fashion, moving its granularity from triangles to precomputed optimized triangle patches. The patches can be conveniently tri-stripped and stored in secondary memory to be loaded on demand, ready to be sent to the GPU using preferential paths. In this manner, central memory only contains the DAG structure and CPU workload becomes negligible. The major contributions of this work are: a new out-of-core multiresolution framework, that, just like the MT, encompasses a wide class of multiresolution structures; a robust and elegant way to build a well conditioned MT DAG by introducing the concept of V-partitions, that can encompass various state of the art multiresolution algorithms; an efficient multithreaded rendering engine and a general subsystem for the external memory processing and simplification of huge meshes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>In recent years, the large entertainment and gaming market has resulted in major investments in commodity graphics chip technology, leading to state-of-the-art programmable graphics units (GPUs) with greater complexity and computational density than current CPUs. Despite the already impressive performance of current graphics chips, both architectural considerations and the inherently parallel nature of graphics operations, suggest that this trend will not change, and GPU performance increase will continue to outpace CPU performance increase.</p><p>However, our ability to generate models that vastly exceed the peak memory and processing capabilities of even the most powerful hardware is a constant in a number of application domains (see, e.g., 3D scanning <ref type="bibr" target="#b13">[14]</ref>, geometric modeling <ref type="bibr" target="#b23">[24]</ref>, and numerical simulation <ref type="bibr" target="#b17">[18]</ref>), imposing the need for adaptive techniques.</p><p>An important class of large scale 3D models is characterized by an extremely dense sampling, with lots of fine geometric details, accompanied by a moderate depth complexity.</p><p>The amount of data contained in these models does not allow us neither to render them directly nor to keep them in the main memory. So we need both a level-of-detail strategy, to filter out as efficiently as possible the data that is not contributing to a particular image, and an out-of-core strategy, to supply efficiently to the insufficient amount of main memory.</p><p>These models require both multiresolution techniques, because the graphics architecture cannot sustain such amount of data, and out-of-core techniques, because the combination of out-of-core data management techniques, for handling datasets larger than main memory, with level-of-detail algorithms based on multiresolution structures, to filter out as efficiently as possible the data that is not contributing to a particular image.</p><p>Typical examples of these kind of datasets are terrains and scanned models.</p><p>Up until recently, the vast majority of view-dependent levelof-detail methods were based on multiresolution structures taking decisions at the triangle/vertex primitive level. This kind of approaches involves a constant CPU workload for each triangle that with current GPU evolution makes the CPU the bottleneck of the whole rendering process. In other words classical multiresolution approaches are not able to choose what has to be rendered fast enough. Given the current hardware trends, this performance bottleneck is doomed to become more and more evident.</p><p>To overcome this bottleneck and to fully exploit the capabilities of current graphics hardware is therefore necessary to select and send batches of geometric primitives to be rendered with just a few CPU instructions. Following this approach, various GPU oriented multiresolution structures have been recently proposed, based on the idea of moving the granularity of the representation from triangles to triangle patches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b24">25]</ref>. The benefit of these approaches is that the needed per-triangle workload to extract a multiresolution model reduces by orders of magnitude, the small patches can be preprocessed and optimized off line for a more efficient rendering and highly efficient retained mode graphics calls can be exploited for caching the current adaptive model in AGP or video memory. Recent work has shown that the vast performance increase in CPU/GPU communication results in greatly improved frame rates <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>It must be said that changing multiresolution granularity reduces the model flexibility: In general, more triangles than necessary will rendered to achieve a given accuracy. On the other hand, the rendering time does not depends linearly on the triangle count anymore. Instead, it is strongly influenced by how the triangles are organized in memory and sent to the graphics card.</p><p>With this paper we generalize previous recent approaches by proposing a batched multiresolution framework based on the Multi-Triangulation (MT) <ref type="bibr" target="#b21">[22]</ref>. The MT is a very general framework that encompasses a wide class of multiresolution algorithms, but, like the techniques proposed in the 90's, it was originally designed to minimize the number of triangles to be rendered, at the expense of CPU time.</p><p>In this paper, we redesign the MT in a GPU friendly fashion, by moving the granularity from triangles to optimized triangle patches, and by redefining the construction and rendering algorithm to work on external memory. As a result, we provide a new out-of-core multiresolution scheme that, just like the MT, encompasses a wide class of construction and view-dependent extraction algorithms and that enables the interactive rendering of massive meshes on commodity platforms. Moreover, we introduce a novel robust technique to build a well conditioned multiresolution data structure, based on V -Partitions sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>207</head><p>Please see supplementary material on conference DVD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Visualization 2005</head><p>October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE.</p><p>The original contribution of this is twofold: 1) a general multiresolution framework (Sec. 3 4) capable of rendering large meshes at interactive rate that fully exploit GPU capabilities and encompasses existing approaches (Section 5) 2) A general subsystem for handling and modifying massive meshes in external memory, (Section 6) the system can be used for the out-of-core construction of the MT, for the efficient rendering of our multiresolution model, but also usable for general purposes mesh healing and processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>In this section, we briefly survey some of the extensive previous work on the general subjects of mesh simplification, multiresolution models, and selective refinement; we focus mainly on the aspects most closely related to our work: being able to manage large meshes in external memory and trying to group primitives together.</p><p>A common characteristic of most adaptive mesh generation techniques is that they spend a great deal of the rendering time to compute the view-dependent triangulation and to communicate the updates to the graphics board. For this reason, many authors have proposed techniques to alleviate popping effects due to small triangle counts <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11]</ref> or to amortize construction costs over multiple frames <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b14">15]</ref>, improving feedback frequency at the expense of a (much) higher latency.</p><p>Our technique reduces instead the per-triangle workload by composing at run-time pre-assembled optimized surface patches, making it possible to employ the retained-mode rendering model instead of the less efficient direct rendering approach. The idea of grouping together sets of triangles in order to alleviate the CPU/GPU bottleneck has already been the focus of a number of approaches.</p><p>HLOD <ref type="bibr" target="#b6">[7]</ref> improves the classic LOD scene graph by providing multiple precomputed levels of details not only for each model but also for entire subtrees. In this approach, conformality of the triangulations between elements of the partition at different resolutions can be guaranteed only by leaving some of the boundaries unsimplified, with obvious scalability and quality problems. Some approaches simply avoid dealing with this kind of problem, limiting themselves to filling the resulting cracks between patches with ad hoc geometry <ref type="bibr" target="#b8">[9]</ref>, or moving to a complete mesh-less structure <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23]</ref> The first methods capable to producing adaptive conforming surfaces by composing precomputed patches were designed for terrain rendering. RUSTIC <ref type="bibr" target="#b20">[21]</ref> and CABTT <ref type="bibr" target="#b12">[13]</ref> are extensions of the ROAM <ref type="bibr" target="#b5">[6]</ref> algorithm, in which subtrees of the ROAM bintree are cached and reused during rendering. A similar technique is also presented in <ref type="bibr" target="#b4">[5]</ref> for generic meshes. BDAM <ref type="bibr" target="#b0">[1]</ref> constructs a forest of hierarchies of right triangles, in which each node is a general triangulation of a small surface region. These methods are efficient and crack-free, but are limited to 2.5D datasets.</p><p>The first approach able to guarantee an adaptive conforming surface for a massive mesh with an arbitrary topology has been presented in the Adaptive TetraPuzzles approach <ref type="bibr" target="#b2">[3]</ref> where, by exploiting a 3D tetrahedral embedding of the well-known right triangle hierarchy, the authors extend the results of the BDAM approach to general 3D meshes. A related approach has been presented in the QuickVDR system <ref type="bibr" target="#b24">[25]</ref>: the original massive model is partitioned in a hierarchical set of small patches (called clusters) that are independently converted into progressive meshes and merged bottom-up. Additional logic in the management of boundaries between clusters is used to allow the simplification of some cluster boundaries while enforcing the conformality of the resulting mesh. It should be noted that this approach generates a DAG of dependencies between clusters, and thus the whole structure can be considered a particular case of the our batched MT framework. Similarly, TetraPuzzles can also be considered a particular case of the MT <ref type="figure">Figure 1</ref>: An example of the MT DAG that shows the one-to-one correspondence between the valid subsequences and the valid cuts. Note that the cut C 2 (rendered in red) is not valid because two arc of the cut, a 01 and a 13 , are in the same path from the source to the sink.</p><p>framework, in which all dependencies are implicitly encoded in the tetrahedral hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RE-DESIGNING THE MT FOR MASSIVE MESHES</head><p>The Multi Triangulation framework (MT) <ref type="bibr" target="#b21">[22]</ref> was designed as a general way to formalize and implement multiresolution models based on simplicial complexes, but its basic concepts hold in a more general context. In the following description we summarize the MT framework abstracting from the way the domain is represented and we give conditions that should be satisfied for generating MT whose DAG is not ill-conditioned and can guarantee good performances and flexible adaptivity during extraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The MT Framework on general domains</head><p>Let us consider a domain Ω as the subset of R 3 corresponding to the surface to be represented. With the general term description we denote all the primitives that can be used to describe this domain, e.g. triangulated surfaces, point sets, parametric surface etc..</p><p>Let Ω be our domain and D a description of Ω. The operation of replacing a portion f of D with a new description g, provided that both f and g describe the same part of the domain, is called pasting and it is formally written as: D ⊕ g = D \ f ∪ g where f is called floor of g and g is called fragment.</p><p>A general simplification or refinement algorithm can be expressed as the iteration of the following steps, starting with D 0 = D and i = 0 :</p><formula xml:id="formula_0">• select a region f i+1 ⊆ D i ; • construct a new fragment g i+1 s.t. Ω( f i+1 ) = Ω(g i+1 );</formula><p>• update:</p><formula xml:id="formula_1">D i+1 = D i ⊕ g i+1</formula><p>If the fragment g i+1 is a description more accurate than its floor, then this is a refinement algorithm, otherwise it is a simplification algorithm.</p><p>When speaking about descriptions represented by a triangulation T we say that, after a pasting operation, T is conforming, or in other words correct, if for any pair of triangles in T their intersection is either empty or it is coincident with a vertex or an edge of both triangles.</p><p>Note that g i+1 replaces its floor, which in turn could have been introduced by previous pasting operations. Therefore the floor of g i+1 will be, in general, distributed among several fragments pasted before g i+1 . Referring to <ref type="figure">Figure 1</ref>, the floor of g 3 is distributed among D 0 , g 1 and g 2 while the floor of g 4 is all contained in g 1 . We will refer to this property saying that a fragment g i depends on the fragments intersecting its floor; e.g., referring to <ref type="figure">Fig. 1</ref>, g 4 depends on g 3 while g 3 depends on g 1 , D 0 and g 2 .</p><p>Now consider the whole sequence of pasting operations produced by the sequences of fragments S = (g 1 , . . . , g n ) and the corre-</p><formula xml:id="formula_2">sponding description D n = (((D 0 ⊕ g 1 ) ⊕ g 2 ) ⊕ . . .) ⊕ g n .</formula><p>Observe that a pasting D i ⊕ g i+1 can be done if and only if D i contains the floor of g i+1 , in other words if S contains all fragments on which g i+1 depends. This means that if we take a subsequence of S ⊆ S such that for each fragment in S all the fragments on which it depends are also in the subsequence (transitive closure of dependency), then S is also a sequence of valid pasting that will produce a new representation, possibly different from D i ∀i = 1..n. In the example D 0 ⊕g 2 , D 0 ⊕g 1 and (D 1 ⊕g 1 )⊕g 4 are all valid descriptions of the domain.</p><p>In the MT framework dependencies between fragments represent a partial ordering and can be encoded in a directed acyclic graph (DAG) where fragments are the nodes. A closed subset (with respect to transitive closure of dependency) of the nodes of the DAG, corresponds to a valid sequence, and it is conveniently encoded with a cut on the DAG, i.e. the set of arcs leaving the specified portion of the DAG.</p><p>Note that, for completeness, all the leaf nodes containing portions that are not floor of any fragments are connected through an arc to a dummy sink node, so there is no node without leaving arcs except the dummy node, which is never included in a cut.</p><p>Let a i j be the intersection between the floor of g j and g i (see <ref type="figure">Fig. 2</ref>). Then, for each arc (g i , g j ), a i j represents the part of the description that is replaced by pasting g j in a subsequence that contains g i . This means that, given a cut on the DAG, ∪ k∈cut a k corresponds to the result of pasting all the fragments in the corresponding subsequence. This is decisive in terms of efficiency because it means that we never need to actually compute all the pasting operations of a given subsequence, we can obtain the correct result by simply combining together all the descriptions associated with the arcs leaving the nodes included by the DAG.</p><p>Updating a Cut Once you have a valid cut, corresponding to a description that fits your multiresolution needs, it is possible to update the current representation by means of refinement/coarsening operations over the cut itself. A refinement consists of replacing an arc in the cut with the forward star of its head node. Consider the cut represented in <ref type="figure">Figure 1</ref> and suppose to execute Refine on the arc a 23 . It means to replace it with the arcs in the forward star of g 3 . Since g 3 depends on g 1 and g 1 is outside the current cut, we need to refine arc a 01 as well. In other words the nodes in the backward star of a newly inserted node are recursively visited to ensure that they enter the subsequence. Similarly, coarsening an arc means to replace the forward star of its tail node with its backward star. Note that this operation is legal only if all the arcs in the forward star of the tail node are also in the cut. Refinement/coarsening operations allow to continuously adapt the representation error to the current application needs.</p><p>In the original MT implementation, that uses edge contraction as primitive operations, to move the cut forward a node, which requires the execution of several instructions, merely means to replace 8-10 triangles, i.e., the region of influence of an edge. Our goal is to spend this time for replacing order of thousands triangles. This requires the definition of primitive operations that work on larger mesh regions. These operations cannot be arbitrary, but <ref type="figure">Figure 2</ref>: In a MT we associate to each arc (g i , g j ) of the DAG the description a i j replaced by pasting g j in a subsequence that contains g i .</p><p>have to fulfill a number of conditions in order to guarantee good performance and local adaptivity during extraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Well behaving DAG's</head><p>Selecting a new region f to be substituted in the MT building algorithm, means to create a new node of the DAG and the set of arcs corresponding to its backward star. So how we select such a region strongly affects the topology of the DAG that influences the efficiency of the process of extracting a description from the MT.</p><p>In the following we will show two worst case examples to explain the characteristic that the DAG should fulfill. In <ref type="figure" target="#fig_0">Figure 3</ref> top, a DAG is derived from a series of refinement steps where the floor of the fragment g i+1 overlaps the fragment g i . As a result, if the arc a 4 is refined, in order to provide more detail in the region g 4 , then all the other arcs have to be refined as well, even if they are related to distant regions of the domain. In other words, the error does not increase smoothly as the distance from g 4 increase, but the extracted representation is in fact all at the lowest error. A similar case happens if the floor of a fragment intersects too many other fragments, i.e. if the backward star of a node is too big (see <ref type="figure" target="#fig_0">Figure 3</ref> bottom).</p><p>The following two conditions ensure that a DAG is well conditioned:</p><p>1) the length of a path connecting the root to any leaf is logarithmic in the number of nodes and 2) the diameter of a fragment decreases geometrically with the distance of the corresponding node from the root of the DAG.</p><p>In the case of meshes the pasting operation implies that the old region f and the new g must have the same boundary, so in the simplification or refinement algorithm the boundary (closure(D − f ) ∩ f ) must be preserved. It is important to note that if many fragments share the same boundary, there will be no simplification along this border. We must then add a third condition:</p><p>3) a fragment should not share boundaries with all the fragments intersecting its floor.</p><p>Various multiresolution schemes have been presented in literature that fulfills the above requirements, like for example the right triangle hierarchies exploited in the BDAM approach <ref type="bibr" target="#b0">[1]</ref>. In the next section we propose a new general scheme for building MT with well behaving DAG's which satisfies the conditions stated above.   massive mesh that we will use to define sets of patches, that can be simplified and merged together to form a well-behaving MT DAG. Let Ψ be a partition of the space into k = |Ψ| disjoint regions Ψ = {ψ 1 , . . . , ψ k }. Given a rule that uniquely assigns a triangle t to a region of space, e.g. the one where the barycenter of t falls, it can be applied to a mesh T to subdivide it into a set of k conforming triangulations Ψ(T ) = {T Ψ 1 , . . . , T Ψ k }. Given two partitions Ψ = {ψ i }, Φ = {φ j }, we denote with Ψ Φ the partition resulting by the crossing of the two partitions, defined as:</p><formula xml:id="formula_3">V i V i+1 V i+2 V * i = V i V i+1 V * i+1 = V i+1 V i+2</formula><formula xml:id="formula_4">consecutive V -partitions V * i , V * i+1 Figure 5: Two consecutive V -partitions V * i , V</formula><formula xml:id="formula_5">Ψ Φ = i=0..|Ψ|, j=0..|Φ| {ψ i ∩ φ j }</formula><p>informally speaking Ψ Φ is the partition that you obtain by overlaying the two partitions. This property is the central point of our multiresolution approach: coarser partitions corresponds to coarser mesh resolutions and we use the elements of the various Ψ * i partitions to assemble conforming triangulations with varying resolution according to the MT rules explained in Sec. 3.</p><p>The key idea is that we perform the simplification process at discrete steps: one for each Ψ * i partition. To ensure that we obtain conforming triangulations we have to take some care: when simplifying from step i to step i + 1, first we assemble the patches of Ψ * i to build patches of Ψ i+1 , then we simplify them without touching the borders of Ψ i+1 patches and finally we split the result of simplification according to the Ψ * i+1 partition. Assuming that the partitions in the sequence are coarser and coarser, we exploit the simplification step to keep the density of triangles contained in each element of the partition as close to constant as possible.</p><p>This approach is illustrated in <ref type="figure" target="#fig_1">Figure 4</ref> top, that shows three consecutive partitions </p><formula xml:id="formula_6">V i , V i+1 , V</formula><formula xml:id="formula_7">V * i , V * i+1 resulting, respectively, from V * i = V i V i+1 and V * i+1 = V i+1 V i+2 .</formula><p>As an example let us describe the i-th simplification step according to figures 4: we start with our mesh that is partitioned according to V * i and we consider the all patches of V * i corresponding to a single region of V i+1 , i.e. the blue ones in <ref type="figure" target="#fig_1">Fig 4;</ref> this mesh portion is independently simplified, keeping the blue border unchanged. At the end of the simplification, we save this simplified mesh portion (that corresponds to a blue patch) split according to the patches of the new partition V * i+1 (the red lines of <ref type="figure" target="#fig_1">Fig. 4</ref>). Informally speaking patch borders with the same color always match. Once all the regions of V i have been processed, the mesh is partitioned according to V * i+1 , and we can thus start the next simplification step by processing all the V i+2 regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Partition Sequences and MT</head><p>The simplification process sketched above can be directly interpreted in terms of local operations and fragments. In a simplification step i we perform a set of |V i+1 | local actions substituting each V i+1 patch partitioned according to V * i with the a patch with the same border but a simplified interior and partitioned according to V * i+1 . In terms of MT the V i+1 patch, partitioned according V * i+1 , is a fragment whose floor is the same patch but partitioned according to V * i .</p><p>A DAG built using a partition sequence where the number of the elements in each partition decreases geometrically will satisfy condition 1. To satisfy condition 2 we need that the partition elements are distributed uniformly. In such a case the floor of each fragment of V i+1 intersects a roughly constant number of fragments of V i and therefore the size of the backward star of a node will be roughly constant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Building Partition Sequences using V -partitions</head><p>In practice we need to find an effective sequence of partitions that we can use to build our patch based MT. The sequence of partitions must be roughly uniform and coarser and coarser. It should be noted that the sequence of partitions does not need to adapt to the geometric characteristics of the mesh (like curvature or density). In this approach the adaptivity is handled during the MT traversal. If a portion of the mesh presents more feature its simplification will yield an higher error and therefore during the MT traversal that portion will be maintained at a finer resolution.</p><p>We propose to build the partitioning using a Voronoi like approach. Given a set of 3D points Q = {v 0 , . . . , v k }, called seed set, we define the V -partition of a mesh T into patches V Q = {Q T 0 , . . . , Q T k } by defining Q T i as the patch composed by the faces that are nearest to the seed point v i . Note that it is not required for these patches to be composed of a single connected component.</p><p>To build the multiresolution model, we need a sequence of seed sets Q 0 , . . . Q k , and the corresponding V -partitions V 0 . . . V k , of decreasing granularity.</p><p>We propose two approaches for building the sequence of seed sets, the first one generates a regular partitioning while the second one generates a sequence of irregular partitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Regular V -partitioning</head><p>A simple and effective method is to use a regular recursive seed distribution scheme. Consider the two dimensional case, illustrated in figure 6: we start by placing vertices on a regular grid, obtaining a partition in squares, then we continue placing seeds on the midpoint of the edges of these squares obtaining another finer partition in squares (tilted 45 degree), and so on. With this approach the V * i partitions forms the well known triangle bintree hierarchy, and the simplification strategy that we obtain is quite similar to the one used by the BDAM approach <ref type="bibr" target="#b0">[1]</ref>. This approach can directly be extended to the three-dimensional case by considering a regular grid and placing seeds onto a) cube centers, b) face centers, c) edge centers. The sequence of partitions V i that we obtain (where Voronoi regions are cubes and octahedra) forms the same patterns of the diamonds of the Slow Growing Subdivision scheme <ref type="bibr" target="#b19">[20]</ref> used also in the recent TetraPuzzle <ref type="bibr" target="#b2">[3]</ref> approach, but the sequence of crossed partitions V * i is not a simplicial complex, but it is formed by convex cells built by adjacent tetrahedra. Many other recursive 2D subdivision schemas can be obtained by regular seeds placement, like for example hexagonal subdivisions <ref type="bibr" target="#b11">[12]</ref> shown in <ref type="figure" target="#fig_4">Fig. 7</ref> (also described as dual √ 3 subdivisions in <ref type="bibr" target="#b18">[19]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Irregular V -partitioning</head><p>Beside the above technique here we present a simple approach for finding a sequence of seed sets by an I/O efficient sampling the original surface able to manage huge surfaces. We assume that the number of seeds is much smaller that the original surface and can reasonably be kept in core. Note that assuming patches of ≈ 1k triangles, this means that massive meshes of more than one giga triangles can reasonably be managed. We start by choosing a average radius of the patch r and then we sequentially scan the surface triangles, adding the barycenter of the triangle t to the seed set Q every time a triangle t of the stream is farther than r from all the other points of Q. Then, in a second <ref type="figure">Figure 6</ref>: The sequence of partions obtained placing seeds on centers and corners of a square grid generate the well known bintree hierarchy used for 2d terrain multiresolution models. sequential scan, we remove small patches and we apply a step of Lloyd's Voronoi relaxation <ref type="bibr" target="#b15">[16]</ref> by moving the seeds towards the barycenter of their region. A sequence of coarser and coarser partitions can be obtained by simply choosing a sequence of increasing radii r 0 , ...r i . Since the process of scanning the whole mesh is the dominant one the creation of all the various seed sets Q i can be done in parallel during the same mesh scan. At the end of this process we have a sequence of seed sets Q i that subdivide the original surface into coarser and coarser partitions V i where cells, within each partition, have approximatively the same number of triangles. This is done by decreasing the triangle count, from a level to the next, by the same ratio as the number of seeds. These partitions will be used, as described above, to build the V * i partitions that identify the patches at the basis of our multiresolution approach.</p><formula xml:id="formula_8">V i−1 V i V i+1 V * i V * i+1 composed</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">OUT OF CORE, TIME CRITICAL RENDERING</head><p>For the sake of interactivity the multiresolution extraction process should be able to support a constant frame rate, given the available time and memory resources. This means that the algorithm must be able to fulfill its task within a predetermined budget of time and memory resources, always ending with a consistent result, or in other words, it must be interruptible.</p><p>Our extraction algorithm uses two threads: ExtractRender and PatchServer. The ExtractRender thread is responsible for finding the correct cut in the DAG and for filling a OperationList; this list contains the needed coarsening/refinements of the cut, e.g. the patches that must be removed/inserted from the current description. The PatchServer thread is responsible for loading in main memory the needed patches without blocking the ExtractRender thread.</p><p>The Extraction thread keeps updated the current cut by means of refinement and coarsening operations; For this purpose we store the set of operations that are feasible given the available budget and compatible with the current cut, in two heaps: the CoarseningHeap The priority in the heaps is given by the screen space error associated with the operation: the first operation in the RefinementHeap is the feasible refinement with the largest screen space error, while the first in the CoarseningHeap is the coarsening with the smallest error that can be done on the current cut while maintaining the desired screen space error.</p><p>The algorithm performs refinement operations until possible, and coarsening operations otherwise. Whenever an operation is done, new operations will possibly be inserted in the heaps. <ref type="figure" target="#fig_5">Figure 8</ref> shows a cut example and the corresponding heaps. For example, if operation C 4 (move the cut before the node g 4 ) is performed C 1 is inserted in the RefinementHeap and R 8 is invalidated, since is no more feasible. Note that the inverse operation R 4 would now be feasible, but it would never been chosen and hence is not even inserted. <ref type="figure" target="#fig_7">Figure 9</ref> shows the the algorithm ExtractRender thread. The basic block of the algorithm is the estimation of the time needed to perform an operation, implemented in the function CheckBudget.</p><p>The time for the ExtractRender thread is the time for rendering, which is estimated as linearly proportional to the number of rendered triangles. Thus, for each operation (P out , P in ), we update the number of rendered triangles RT with RT = RT + |P in | − |P out | . If RT exceeds the maximum number of triangles the operation cannot be done.</p><p>Similarly, the PatchServer thread time is dominated by the time needed to load the patches from the disc. In the worst case, loading time is dominated by disk seek latency, that we assume bounded by a constant found by experiment.</p><p>The extraction algorithm always tries to apply the refinement with the lowest error within the current budget; when the budget does not allows it, it tries to apply the coarsening with the greatest error. The function AddToOperationsList inserts the operation passed as argument in OperationList, which will be read by the PatchServer. Once Extraction is ended, OperationsList contains the list of operations that can be done. The procedure Apply simply runs through this list and performs the operations. To perform an operation means to free the memory allocated for the patches to be removed and to have the patches to be sent to the GPU in main memory, which can require a loading from disk if they are not already present. If the budget time ends before the whole list is scanned, which may happen if the time estimation was optimistic, then the algorithm returns and is guaranteed that the representation is conformal even if not to the required accuracy.  If there is still time after the execution of Apply, the remaining time is used for pre-fetching the patches that will be probably used in the next frame. At this stage, the pre-fetching strategy is very simple and it consists of loading in memory the patches around the current cut, which is easily achieved by applying all the operations in the heaps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">View space and object space errors</head><p>In order to obtain a view-dependent multiresolution representation where the mesh resolution adapts with current viewing needs, we need a view-dependent measure of the error. The screen space error associated with a patch is derived at run time in a way similar to <ref type="bibr" target="#b0">[1]</ref> using an object-space view-independent error measure and the bounding sphere of each patch. This object-space viewindependent value is projected in screen space to obtain the error using the bounding sphere. The relation between the error of the arcs of the graph is preserved by imposing that each bounding sphere encloses the bounding sphere of all the arcs in the subgraph.</p><p>Common measures used to quantify the error of a single patch are based on the Hausdorff distance between simplified and original mesh <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b2">3]</ref>. We have chosen a simpler strategy: we just use the average edge length of the triangle of the patch. We made this choice on the basis of the following considerations: the initial meshes are dense and we use an highly accurate simplification algorithm which produce roughly uniform meshes; this means that the average edge length is monotonic along the levels of the DAG, as opposed to the Hausdorff distance based error which often needs to be corrected in order to respect the partial order among the node of the DAG: transform the average length of a triangle edge view space (in pixels units) and, given the fine tessellations created, the visual fidelity is no more dominate by the geometric error but by the surface shading, as observed in <ref type="bibr" target="#b16">[17]</ref>. These considerations were confirmed using the geometric error computed during simplification with no noticeable difference.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">A SUBSYSTEM TO HANDLE MASSIVE MESHES</head><p>Our framework requires an out-of-core mesh manager that allows us to handle massive meshes patch by patch, reflecting the MT concept of local modification in terms of patches instead of triangles. The steps for the construction of the MT are: select a set of patches (the floor of a local modification e.g. all the patches composing an element of the partition), load and modify the triangle mesh associated with the patches, change the patch structure defining a new set of patches, and then save them. Therefore we store the whole mesh as a collection of independent sub-meshes called patches. Each disk-stored patch contains an indexed representation of a small portion of the mesh with a copy of all the referenced vertices. Boundary vertices, that are shared between patches, are replicated but identified for easier patch processing. For each patch p we maintain the list L of all the vertices that have external dependencies. L entries are triplets (v p , q, v q ), denoting, for each vertex v p in p, the patch q that refers to it and its position v q inside q.</p><p>When a set of patches P is requested for being processed and modified in-core, we exploit these lists to efficiently unify vertex indexes and to mark the vertices that are referred by not loaded patches. When the in-core mesh portion has to be written back, the user can change the mesh partitioning scheme, defining a new set of patches that covers the same mesh portion. In this case, we also update the boundary lists of the patches that are not loaded but referring to vertices in the current portion P.</p><p>Once you have a partition sequence, starting from the finer partition we have to load patches in memory, to simplify them and effectively build the whole MT structure. Moreover with this scheme it is rather simple to perform out of core mesh healing processes like smoothing and small hole filling.</p><p>Note that this approach it is somewhat independent from how patches are actually stored. This allow to use the same structure also for rendering purposes, just changing the final format of stored patches. In this case for sake of rendering efficiency we can store patches as optimized triangle strips, with precomputed normals and then individually compressed using a quick decompression algorithm 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS AND DISCUSSION</head><p>The results presented in this section relate three dense meshes of increasing size: the Lucy (28M tri), the Michelangelo's David (56M tri) and Michelangelo's S.Matthew (370M tri), all of them coming from the Stanford repository.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Preprocessing</head><p>The preprocessing was done on a cluster of PC's on an Ethernet 10Mb and 100Mb moderately loaded. The network speed resulted unimportant since the computation is dominated by the CPU time to perform patch simplification, analogously to what reported by QDVR and Tetrapuzzles. <ref type="bibr" target="#b0">1</ref> we used the minilzo compression library available at http://www.oberhumer.com/.</p><p>Since the number of triangles is halved at each iteration the number of triangles contained in the whole dataset is almost twice than the number of original triangles, while, as can be seen in <ref type="table" target="#tab_2">Table 1</ref>, the disk occupation of the MT is roughly 40% percent higher than the original dataset. This should not be surprising, since the original mesh is in a raw format while all the MT patches are stripified. These numbers are comparable to QVDR <ref type="bibr" target="#b24">[25]</ref> which requires 13.992GB for the same S.Matthew model, and Adaptive Tetrapuzzles <ref type="bibr" target="#b2">[3]</ref> (5.887 GB).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Rendering</head><p>The rendering performance was evaluated over several inspections, rotating and abruptly zooming in and out the model. All the tests were done with window size 800x600 on a Windows machine equipped with an AMD Athlon 64, 2 GHz, 512 MB Ram, SCSI hard disk, bus AGP 8x and graphics card GeForce 6800 GT. In all cases the in core memory limit to store all the patches was set to approx. 90 MB. In the case of the S.Matthew model, this is less that 1% of the total data size, showing the effectiveness of the out of core data management strategy.</p><p>Our algorithm is able to render around 4M triangles per frame at 35 fps with a pixel precision, computed as the average length of the triangles projected onto the screen. The Adaptive Tetrapuzzles approach sustains an average rendering rate of 70 millions of triangles per second on a Linux equipped pc with a GeForce FX 5800 Ultra Graphics, which should produce results comparable to our method on the same hardware setting. QVDR, instead, sustains 771k triangles per frame at 17fps on a GeForce Ultra FX 5950 GPU, but also implements occlusion culling which is not strictly necessary for the kind of meshes discussed in the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head><p>We have presented a GPU friendly multiresolution framework providing high visual quality as well as efficient rendering. The underlying idea of the proposed method is to depart from current point-or triangle-based multiresolution models and adopt a patch-based data structure, from which view-dependent conforming mesh representations are efficiently extracted and batched to the GPU by simply combining precomputed patches.</p><p>Our main contributions are: a general framework for building efficient out-of-core multiresolution models that fully exploit the capabilities of current consumer graphics hardware; a general outof-core patch-based mesh management system on which the framework can be efficiently implemented; a parallel out-of-core, high quality, simplification algorithm; a proof-of-concept implementations of novel multiresolution models that produce well conditioned multiresolution structures and fit in the above framework.</p><p>The implementation of the framework proves it comparable, in terms of speed and data preservation, to the ad-hoc state-of-the-art clustered multiresolution models it generalizes.  Although the current implementation gives satisfactory results, there are still issues that will require further work. The first is the incorporation of an ad-hoc speculative pre-fetching of patches, while at the present which patches are pre-fetched is not bound to the camera movement. A second, more intriguing, goal is to efficiently handle the color information. At the present state, color coordinates can be assigned per-vertex basis and of course any technique to preserve this information during the simplification process (for example <ref type="bibr" target="#b1">[2]</ref>) can be adopted. Nonetheless, it is foreseeable that an ad hoc solution complying the characteristics of our framework is needed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Two examples of malconditioned DAGs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Top: three consecutive partitions of a sequence, bottom: The two set of patches used for the simplification step obtained by intersection of two</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>* i+1 of the David mesh. The enhanced lines show some of the borders of the partition V i+1 that remains unchanged between the two steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>i+2 , and figure 4 bottom, that shows the two partitions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>The sequence of partitions obtained recursively placing seeds on vertexes of a hexagonal grid.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Example of cut and corresponding heaps. and the RefinementHeap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>if ( clock() &lt; endFrame ) { execute Perform on the operations in the heaps RefinementHeap and CoarseningHeap } }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Interruptible rendering cycle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>The Lucy model adaptively rendered with the batched MT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>The S. Matthew model adaptively rendered with the batched MT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Proposition 1 Consider a sequence of coarser and coarser partitions Ψ 0 , . . . , Ψ n and the sequence of partitions obtained by crossing them Ψ * i = Ψ i Ψ i+1 . You can assemble the elements of the Ψ k+1 partitions in two different ways by using either the elements of Ψ</figDesc><table /><note>* k or the elements of Ψ * k+1 .</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Numerical results for the construction of the MT (in minutes) the time are relative to a small cluster of 4 pc's.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">THE V -PARTITION MULTIRESOLUTION MODELThe techniques presented in the previous sections allow us to manage and simplify a massive mesh with a patch-wise approach. In this section we introduce V -Partitions, a general scheme for the definition of a sequence of coarser and coarser partitions over a</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">BDAM: Batched dynamic adaptive meshes for high performance terrain visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ganovelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Marton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ponchio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="505" to="514" />
			<date type="published" when="2003-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Preserving attribute values on simplified meshes by re-sampling detail textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tarini</surname></persName>
		</author>
		<idno>IEI-B4-37-12-98</idno>
	</analytic>
	<monogr>
		<title level="j">IEI -C.N.R</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Adaptive tetrapuzzles: efficient out-of-core construction and visualization of gigantic multiresolution polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabio</forename><surname>Ganovelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabio</forename><surname>Marton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="796" to="803" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>Federico Ponchio, and Roberto Scopigno</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Temporal continuity of levels of detail in delaunay triangulated terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-Or</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yishay</forename><surname>Levanoni</surname></persName>
		</author>
		<idno>0-89791-864-9</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96. IEEE</title>
		<imprint>
			<date type="published" when="1996-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Xfastmesh: fast viewdependent meshing from external memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Decoro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;02: Proceedings of the conference on Visualization &apos;02</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="363" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ROAMing terrain: Real-time optimally adapting meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;97</title>
		<meeting>IEEE Visualization &apos;97</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">HLODs for faster display of large static and dynamic environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Erikson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinesh</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">V</forename><surname>Baxter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH</title>
		<meeting>SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="111" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Layered point clouds -a simple and efficient multiresolution structure for distributing and rendering gigantic point-sampled models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Marton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2004-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Real-time appearance preserving out-of-core rendering with shadows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Á</forename><surname>Balázs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rendering Techniques 2004 (Proceedings of Eurographics Symposium on Rendering)</title>
		<editor>A. Keller and H. W. Jensen</editor>
		<imprint>
			<date type="published" when="2004-06" />
			<biblScope unit="volume">409</biblScope>
			<biblScope unit="page" from="69" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<idno>0-89791-896-7</idno>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings, Annual Conference Series</title>
		<editor>Turner Whitted</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Smooth view-dependent level-of-detail control and its aplications to terrain rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98 Conf</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the support of recursive subdivision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ioannis</forename><surname>Ivrissimtzis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malcolm</forename><surname>Sabin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neil</forename><surname>Dodgson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1043" to="1060" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast view-dependent level-of-detail rendering using cached geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Levenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;02</title>
		<meeting>IEEE Visualization &apos;02</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002-10" />
			<biblScope unit="page" from="259" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The digital michelangelo project: 3D scanning of large statues</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ginzton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ginsberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fulk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="131" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Out-of-core construction and visualization of multiresolution surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM 2003 Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="2003-04" />
			<biblScope unit="volume">239</biblScope>
			<biblScope unit="page" from="93" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Least squares quantization in pcm. Information Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="129" to="137" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Geometry clipmaps: terrain rendering using nested regular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Losasso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="769" to="776" />
			<date type="published" when="2004-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Very high resolution simulation of compressible turbulence on the IBM-SP system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Mirin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Dannevik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Dimits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Eliason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">R</forename><surname>Woodward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Shieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing &apos;99</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Composite primal/dual √ 3-subdivision schemes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Oswald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Aided Geom. Des</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="135" to="164" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Slow growing subdivision (sgs) in any dimension: Towards removing the curse of dimensionality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Valerio Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="451" to="460" />
			<date type="published" when="2002-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Roam using surface triangle clusters (rustic)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><forename type="middle">A</forename><surname>Pomeranz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
		<respStmt>
			<orgName>University of California at Davis</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Variable resolution terrain surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Eight Canadian Conference on Computational Geometry</title>
		<meeting>Eight Canadian Conference on Computational Geometry<address><addrLine>Ottawa, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="202" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">QSplat: A multiresolution point rendering system for large meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Comp. Graph. Proc., Annual Conf. Series (SIGGRAPH 00)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="343" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Out-of-Core rendering of massive geometric datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gokul</forename><surname>Varadhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinesh</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th IEEE Visualization 2002 Conference (VIS-02)</title>
		<editor>Robert Moorhead, Markus Gross, and Kenneth I. Joy</editor>
		<meeting>of the 13th IEEE Visualization 2002 Conference (VIS-02)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002-10" />
			<biblScope unit="page" from="69" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Quick-vdr: Interactive view-dependent rendering of massive models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sung-Eui</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Salomon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Russell</forename><surname>Gayle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinesh</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;04: Proceedings of the IEEE Visualization 2004 (VIS&apos;04)</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="131" to="138" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
