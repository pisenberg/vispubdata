<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Stream-Processing Points</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="laboratory">Visualization and MultiMedia Lab</orgName>
								<orgName type="institution">University of Zürich</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Stream-Processing Points</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3 Computer Graphics</term>
					<term>I.3.5 Comp. Geometry and Object Modeling</term>
					<term>I.3.6 Methodology and Techniques point processing</term>
					<term>sequential processing</term>
					<term>normal estimation</term>
					<term>curvature estimation</term>
					<term>fairing</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1. Simulated stream-processing stages with (r.t.l.): points to be read from input stream (black points), in nearest neighborhood evaluation (red points), during normal computation (yellow points), amid curvature estimation (shaded grey points) and fully processed and written to output stream (shaded color-coded splats). Note that the extent of the active point set is greatly exagerated in this illustration compared to the real data (see Figure 4).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">I NTRODUCTION</head><p>In any visualization context, ahead of any display the input data must be cleaned, filtered, modeled, or in short processed , before it can be rendered and manipulated. This processing, and not rendering itself, of large point sets is the main focus of this paper.</p><p>Point samples are the natural raw output data primitives of the geometry capturing stage in most 3D acquisition systems. In fact, points are the fundamental geometry-defining entities. Satisfying provably correct surface sampling criteria, a set of points fully defines the geometry as well as the topology of a surface. Here we assume that the input surface data is sufficiently densely sampled.</p><p>With the increasing use and precision of 3D acquisition systems it is critical to support raw point cloud data in a practical way in an acquisition and visualization context. The data processing and modeling stages of a visualization system, in particular, must support basic point processing operations such as surface normal estimation or fairing. These operators can be computed efficiently if the point data can be loaded into a main memory spatial indexing structure. However, while optimal up to some limit, this is main-memory inefficient and dramatically decreases in perfor-mance when the model exceeds available physical main memory. In the case of significant mismatch between model and physical main memory size it may nearly come to a halt due to memory thrashing <ref type="bibr" target="#b7">[8]</ref>. Moreover, combining multiple operations can generally not be done by merely concatenating operators.</p><p>In this paper we introduce and set the stage for a new stream-processing concept for processing points sequentially to improve memory access coherency and dramatically limit main memory cost. This sequential stream-processing allows us to process large models out-of-core , and is insensitive to available main memory. Supported operations include local operators Φ ( p ), called stream operators , that perform a function on a point p using only its local neighborhood. Many fundamental operations such as normal and curvature estimation as well as filter operations such as fairing on point data sets follow this principle. Indeed, surface parameter estimation and filter operations are among the most important tasks for (pre-)processing raw points. Our stream-processing concept supports non-recursive local operators Φ ( p ) that include nearby sample points within a well defined (spatially) local neighborhood.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">R ELATED W ORK</head><p>After some early work <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b12">13]</ref>, many point sample display techniques have recently been proposed <ref type="bibr">[33, 31, 32, 4, 20 , 3, 27, 35, 34</ref>]. An interesting way of treating points sequentially is presented in <ref type="bibr" target="#b5">[6]</ref>. In general most techniques address higher-level point processing tasks such as multiresolution rendering, given all point attributes. Lower-level point processing techniques as in <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b38">39]</ref>, however, are aimed at processing moderate point set sizes in main memory and assume that some basic attributes such as normal estimates have already been computed.</p><p>Estimation of vertex attributes such as normal orientation is a common data processing task in polygonal surface reconstruction methods <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b24">25]</ref>, as is fairing in surface modeling <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b17">18]</ref>. However, generally these approaches are not aimed at processing models consisting of tens of millions of vertices or more and do not scale well to out-of-core processing.</p><p>Work on processing triangle meshes sequentially can be found in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17]</ref>. These techniques sequentially grow mesh regions in a coherent way to limit main memory usage. However, no low-level operators are supported, and more importantly, the techniques do active point set input stream output stream not extend to raw point data processing. In <ref type="bibr" target="#b15">[16]</ref> a streaming format for rendering indexed meshes is proposed from which the spectral sequencing could be applicable to stream-ordering raw points in our context, and in <ref type="bibr" target="#b39">[40]</ref> a streaming mesh decimation is presented. None of the related work, however, provides streaming low-level operations and filter functions. Stream-based data handling is common in processing audio and video data which in contrast to 3D geometry is inherently sequential in time. In the context of geometry processing, however, sweep-line techniques in computational geometry <ref type="bibr" target="#b6">[7]</ref> are more closely related. Our basic stream-processing concept follows this idea of sweeping a plane through 3D space and considering events when data elements are passed by the sweep-plane.</p><formula xml:id="formula_0">sweep-direction x y z p 1 … p n , ,<label>R 3 ∈</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">S TREAMING C ONCEPT</head><p>The fundamental idea behind streaming is to process data sequentially with only a limited amount of data active at any time, resembling a sliding window over the data stream. This allows processing huge data sets very efficiently due to coherent memory-access. Moreover, at any given time it only requires a small fraction of the entire data set to reside in in-core main memory while the remainder rests out-of-core.</p><p>Figures 1 and 2 illustrate the basic concept of stream-processing points . Given an ordered set of points each point p i is read exactly once from the input-stream, kept in an active working set A (a FIFO queue) for some time, and then written to the output-stream. All processing is limited to points in the working set A . Conceptually we move a sweep-plane through space along an axis of spatial ordering. <ref type="bibr" target="#b0">1</ref> When a new point p j is passed, denoting an event in classical line-sweep algorithms <ref type="bibr" target="#b6">[7]</ref>, it is added to the working set A . The active set is monitored and local operators are applied to points in A as elaborated in the following sections. Furthermore, as soon as the smallest element cannot possibly contribute anymore to an operation on any subsequent point p i &gt; jm it can safely be written to the output stream (we will use small and large with respect to the sequential index i of the ordered points p i ). Note that all points <ref type="bibr">(or</ref> ) not yet read from the input stream, or already written to the output stream, can reside out-of-core (e.g. in a virtual-memory mapped file). Only points living in the working set A reside in main memory, and any of its temporary extra data such as neighborhood information and other attributes.</p><p>Since the active set A is orders-of-magnitude smaller than the entire data set, , it can be maintained efficiently in main-memory even for very large data sets. Moreover, because input and output are streams of points this directly leads to an out-of-core framework for stream-processing huge point set data.</p><p>In as much as raw point data sets rarely come with the necessary structure of being sequentially ordered in space, they must be ordered in a pre-process. This can efficiently be done for very large data sets by external sort techniques <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b37">38]</ref>, and in practice the rsort <ref type="bibr" target="#b22">[23]</ref> implementation has been used for similar tasks. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">S TREAM O PERATORS 4.1 Definitions</head><p>The class of functions supported by our stream-processing concept includes operations performing a computation on a point which only require a locally restricted set of neighbors. Or more formally: Definition 4.1 A local operator Φ ( p i ) performs a function on a point p i that computes or updates a subset of attributes A i associated with p i . As function parameters, Φ ( p i ) only accepts p i , A i and a set of points within close spatial proximity to p i (and all their associated attributes A j ).</p><p>The neighborhood set N i of points close to p i may be defined as the k -nearest neighbors, or points within a given distance d . The parameters k or d will usually be given by the user or application but could as well be derived for each point as suggested in <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b1">2]</ref>. The modifiable attributes A i can include a wide variety of parameters such as normal orientation or splat size. The above definition of a local operator Φ ( p i ) allows it to be applied to a point for which all elements of N i are also in the current working set,</p><p>. This formulation includes a wide range of operators for surface parameter estimation and filtering which are amongst the most important tasks in processing raw point cloud data.</p><p>In our stream-processing framework, a series of local operators Φ 1 , …, Φ p can be concatenated and applied in succession to a stream of points as for example illustrated in <ref type="figure">Figure 3</ref>. In this context, each operator Φ k also acts as a sequential FIFO queue buffer Q k on the point stream and satisfies the following: Definition 4.2 A local operator Φ k ( p i ) is streamable if it is computed in one single invocation on p i and not called recursively on points . Additionally, the FIFO semantic of its queue Q k ensures no interference between consecutive operators Φ k ±1 .</p><p>The second part of Definition 4.2 deserves further explanation, and is put in practical context in Section 5. It is clear from the above definitions that a stream operator Φ k ( p i ) postulates the proper existence of the local neighborhood N i and any required attributes of A i being part of the input data or computed by preceding stream operators Φ l &lt; k ( p i ) to work. Hence a compatible order of stream operators and attributes must be selected.</p><p>Moreover, each stream operator Φ k must assure that a point p i is passed to the next operator Φ k +1 only if p i is fully processed and all affected attributes are updated by Φ k . This is facilitated by the FIFO queue constraint on Q k of each operator Φ k . Note also that while (the buffer of operator Φ k ) it may be that its local neighbor points belong to buffers Q k ±1 of preceeding or succeeding operators Φ k ±1 . This overlap of neighborhood sets N i between consecutive stream operators is indicated in our figures (e.g. in <ref type="figure">Figure 3</ref>) by shingling boxes with cut-out lower-left and upper-right corners. Implementation issues of this dependency between subsequent operators and realization of correct buffer handling is addressed in Section 5.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fundamental Stream Operators</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">I/O Operators</head><p>The first and last stream operators in a stream-processing pipeline do the I/O from/to input/output streams. As depicted in <ref type="figure">Figure 3</ref> the read operator Φ R ( p j ) only reads and buffers one new point p j entering the active set A from the input stream. On demand it is passed to the following stream operator and the next point is read.</p><p>Note that any stream-processing stage following Φ(p i ) must make sure that no elements of N i are altered until Φ(p i ) has completed. In particular, point p j-m scheduled to leave the active set A must be handled with care. Hence we introduce the deferred-write operator Φ W (last in sequence of stream operators). This operator, as illustrated in <ref type="figure">Figure 3</ref>, assures that any point p j-m is removed from A and written to the output stream if and only if not used by any prior stream operator. That is if for all p i in prior 1. Without restricting the generality of the stream-processing concept we assume ordering along the z-axis throughout the paper.</p><formula xml:id="formula_1">p 1 … p n , , R 3 ∈ A p j m - … p j , , { } = p j m - A ∈ p i j m -j , [ ] ∉ p i A ∉ A m &lt;&lt; n = active set A x y z sweep-plane input stream output stream p 1 p n p j-m next point p j p j N i ∈ p i A ∈ N i A ⊆ p j N i ∈ p i Q k ∈ p j N i ∈ p j m - N i i ∪ ∉</formula><p>operator stages Φ k-1..1 . The deferred-write operator is implemented by a simple FIFO queue. As soon as a point p j-m can be removed from A, its attributes can be written to the output stream and its main memory can be freed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Neighborhood Operator</head><p>The neighborhood of a point p i can be defined in a number of ways. We outline the most important k-nearest neighbor (kNN) set here but others could also be supported (e.g. see <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b1">2]</ref>). The computation of N i is a special neighborhood operator Φ X (p i ) in our stream-processing framework and will generally be the second stream operator after Φ R as in <ref type="figure">Figure 3</ref>.</p><p>We must determine the kNN set N j of a point p j passed by the sweep-front just after insertion into the active point set A. To compute all kNNs efficiently, or any neighborhood for that matter, it is essential to use a spatial index S over the relevant point set for fast spatial (range-) queries. However, since we are processing a point stream and want the index to be as small as possible, we must remove elements from this index at the earliest possible time. Hence the index S must also incorporate a priority-queue over the stream indices i of points . For efficiency reasons we use a kD-heap, a dynamic semi-balanced kD-tree with integrated priority heap, as spatial index S. In fact, since points are streamed in one dimension we use a 2D kD-tree partitioning the sweep-plane. That is sensible because the streaming dimension of set A has generally a very small extent compared to the other two dimensions.</p><p>Two basic operations are supported: incremental insertion of a new element into the kD-heap, and removal of an arbitrary element while satisfying the kD-tree and priority-heap structure <ref type="bibr" target="#b6">[7]</ref>.</p><p>Our streaming kNN approach is summarized as follows (see also <ref type="figure">Figure 3</ref>): At insertion of p j into A a left-sided kNN set N j is initialized, a query on S finding the kNN set N j -with smaller indices i&lt;j since S only contains prior points in the sequential ordering. Additionally, during the insertion of p j into the spatial index S we also update the right-sided kNN sets N i of points p i&lt;j already in S, with respect to the new point p j .</p><p>Finally, as it is imperative to keep the size of S as small as possible we remove points with completed kNN sets as early as possible. Thus our kD-heap is queried to find the list L of points p i in S for which the sweep-plane has moved beyond the farthest kth-nearest neighbor in N i . The set L is then removed from S and passed to a sorting buffer B as depicted in <ref type="figure">Figure 3</ref> which re-establishes the global stream ordering. The smallest element p i of B is correctly stream-ordered if its index i is smaller than the smallest index in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Regular Stream Operators</head><p>Given the local neighborhood N i of points p i in the active set A, many stream operators Φ(p i ) are conceivable of which we outline a small set of meaningful operators that are currently implemented. This extensible list of important operators shows the power and applicability of the proposed stream-processing concept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Normal Estimation</head><p>To demonstrate a regular simple local operator we first introduce normal estimation Φ N (p i ) as a variation of plane fitting (see also <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref>). A normal estimation stream operator Φ N (p i ), together with the read, kNN and deferred-write fundamental operators, constitutes one of the most basic stream-processing pipeline configurations that performs a meaningful operation on a raw point set.</p><p>A local least squares (LLS) plane fit to a point p i and its kNN set is defined by the eigenvalue analysis and eigenvector decomposition of the covariance matrix M i over p i and N i . We express a moving least squares (MLS) representation of the covariance as weighted sum <ref type="bibr" target="#b0">[1]</ref>:</p><formula xml:id="formula_2">. (1)</formula><p>The weight θ(r) is a Gaussian function , with variance σ 2 adaptively defined as the local point density estimate as suggested in <ref type="bibr" target="#b24">[25]</ref>. Thus the normal n i of a point p i is computed as eigenvector M i corresponding to the smallest eigenvalue of M i (from singular value decomposition (SVD) of symmetric positive semidefinite matrices).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Curvature Estimation</head><p>Another simple operator is curvature estimation Φ C (p i ), which we implement based on the covariance of normals n j of points . Similar to Equation 1, we define a MLS of the normal covariance as:</p><formula xml:id="formula_3">. (2)</formula><p>The SVD of the covariance of normals of Equation 2 gives us an estimate of the curvatures and its principal directions. <ref type="figure" target="#fig_5">Figures 1  and 7</ref> illustrate the principal curvatures (root mean square (RMS), mean or absolute curvature).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Splat Size Estimation</head><p>High-quality point-based rendering (PRB) techniques display a surface from points by rendering and blending overlapping (elliptical) disks, see also overview <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b33">34]</ref>. The elliptical extent of a point p i could be derived from locally computed Voronoi cells as in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. However, given the local neighborhood N i , a covariance analysis <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b26">27]</ref> is more suitable for implementation as an elliptical splat-estimation stream operator Φ E (p i ).</p><p>We can determine the ellipse major and minor axis directions, major axis length and aspect ratio for a point p i efficiently from the analysis of the covariance matrix M i given in Equation 1. The eigenvectors of M i projected into the tangent plane given by the normal n i define the ellipse axis while the eigenvalues determine the aspect ratio. The so defined elliptical disk has then to be scaled to fit the neighbor set N i .</p><p>Alternatively, if we have a curvature operator Φ C preceding the splat estimation Φ E (p i ) then the ellipse axis directions and their aspect ratio can be inferred from the principal curvatures derived from Equation 2. This yields slightly different elliptical splats oriented along ridges and valleys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Fairing</head><p>To demonstrate the potential power and extensibility of the proposed stream-processing framework we introduce a smoothing operator Φ S . To filter noise artifacts many smoothing algorithms have been proposed for meshes (e.g. <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b4">[5]</ref> or <ref type="bibr" target="#b35">[36]</ref>). In <ref type="bibr" target="#b27">[28]</ref>, fairing of points has been proposed which requires a regular (re-) sampling pattern. Not unlike <ref type="bibr" target="#b18">[19]</ref> we adopt the non-iterative feature preserving fairing operator presented in <ref type="bibr" target="#b17">[18]</ref>. Its applicability to triangle soups makes it suitable for point sets as well.</p><p>Given a point p i and its neighbors N i , we directly extend the smoothing operation of <ref type="bibr" target="#b17">[18]</ref> to points as follows</p><formula xml:id="formula_4">, (3)</formula><p>with summation over all points . The operator denotes the projection of p i onto the tangent plane of point p j and the value a j corresponds to an area weight (i.e. the splat size). The term w i is , the sum of weights. The Gaussian weight function f(r) adjusts the influence based on spatial distance, while g(r) preserves sharp features by giving less weight to points with different normal orientations <ref type="bibr" target="#b17">[18]</ref>.</p><p>Note, however, that the fairing operator Φ S (p i ) must fit into a properly configured stream-processing pipeline as illustrated in <ref type="figure">Figure 3</ref>. In particular, applying the fairing operator Φ S (p i ) calls for recomputation of new normals n i , as well as (elliptical) splat parameters. Hence we apply normal and splat size estimation Φ N and Φ E also after the fairing operator Φ S as shown in <ref type="figure">Figure 3</ref>.</p><formula xml:id="formula_5">N i p i 1 … p i k , , { } = p i S ∈ N i p i 1 … p i k , , { } = M i N i 1 - p j p i - ( ) p j p i - ( ) T θ p j p i - ( ) ⋅ ⋅ p j N i ∈ ∑ ⋅ = θ r ( ) e r 2 - 2σ 2 ⁄ = σ 2 π MAX p j N i ∈ p j p i -2 N i ⁄ ⋅ = p j N i ∈ C i N i 1 - n j n j T θ p j p i - ( ) ⋅ ⋅ p j N i ∈ ∑ ⋅ = p i ' Φ S p i ( ) 1 w i ----- Π j p i ( )a j f p j p i - ( ) g Π j p i ( ) p i - ( ) ⋅ ⋅ ∑ ⋅ = = p j N i p i ∪ ∈ Π j p i ( ) a j f p j p i - ( ) g Π j p i ( ) p i - ( ) ⋅ ⋅ ∑ Figure 3.</formula><p>Stages of a complex stream-processing pipeline for fairing, with fundamental stream operators for reading Φ R (p), writing Φ W (p) and all k-nearest neighbors Φ X (p). The smoothing operator Φ S (p) is enclosed by a pair of normal and splat size operators Φ N (p) and Φ E (p). A point p i moves from right-to-left through the staged stream operators Φ j (p i ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION</head><p>A major challenge is the systematic definition and development of stream operators. In particular, this includes:</p><p>1. defining an implementation framework and interface such that local stream operators Φ k (p i ) can be concatenated and plugged into a stream-processing system like modules, and 2. concealing the dependencies between consecutively applied local stream operators Φ 1 , …, Φ p effectively within the stream-operator abstract data types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Attribute Handling</head><p>Different stream operators Φ k (p i ) add or modify different subsets of point attributes which may be in addition to the input data. Moreover, attributes may only be needed temporarily and not in the output. Therefore, we define the stream-point data type as an extensible set of attribute-fields (see also Appendix <ref type="figure">Figure 10)</ref>: InputFields Defines the initial point attributes given for each point p i in the input stream. &lt;name&gt;OpFields Specifies the temporary attributes computed by stream operator Φ k (p i ) for points p i in the active set A but not written to the output stream. &lt;name&gt;OpOutFields Lists the added attributes computed by stream operator Φ k (p i ) for each point p i which are passed along with the point p i to the output stream. AuxiliaryFields All auxiliary attributes computed and required by any stream operator Φ k (p i ) while a point p i is in the active set A and processed by operators Φ 1 , …, Φ p . OutputFields Includes all attributes of a point p i that have to be written to the output stream. AllFields All attributes that are ever referenced by any stream operator while processing point p i . This design of extensible per-point attribute fields supports varying configurations of stream operators in a stream-processing pipeline. As part of the auxiliary fields , the reader Φ R assigns an index i to each point p i in the order it is read from the input stream. The kNN operator Φ X (p i ) computes all auxiliary fields with respect to a point p i 's neighborhood information N i . This also includes the min and max of referenced indices j of the points which's use is further detailed below. The normal operator Φ N (p i ) computes the normal n i , which is usually part of the output , based on covariance information stored as part of . The splat estimator Φ E is based on existing normal and covariance information and outputs ellipse parameters as part of . For its calculation, the fairing operator Φ S (p i ) uses some temporary attributes but adds no output fields. (See also Appendix <ref type="figure">Figure 10</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Stream Operator Classes</head><p>Each stream operator Φ k behaves like a buffer Q k on the stream of points. After being released from the previous operator Φ k-1respectively its buffer Q k-1 -a point p i enters the next queue Q k . When all necessary neighborhood conditions are met, operator Φ k (p i ) is performed. The conditions when a point can be processed by Φ k (p i ) and released to the subsequent operator Φ k+1 and its queue Q k+1 depend on the type of the stream operator Φ k .</p><p>The semantic of the buffer Q k of a stream operator Φ k is equivalent to a FIFO queue (interface given in Appendix <ref type="figure">Figure 11</ref>) which includes the front() and pop_front() methods. However, instead of a push_back() interface we define the exchange of points between operators as a pull-push mechanism, see also Section 5.3. For this each operator Φ k keeps a reference to its previous operator Φ k-1 in the operator pipeline. Other stream-operator functions include queries on the smallest element -index i of a queued point -on which operator Φ k has not yet actually been computed; and the smallest referenced neighbor -index j of a -of any unprocessed points p i in Q k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Through-buffer Operators</head><p>All simple stream operators Φ k (p i ) that given a set of attributes compute additional new attributes for a point p i without affecting any kNN data in N i are called through-buffer operators. This arises from the fact that as soon as a point p i is released from a prior operator Φ k-1 it can be processed by Φ k and immediately released to Φ k+1 . In practice its FIFO queue Q k will generally be empty as the subsequent operator Φ k+1 consumes any released points immediately.</p><p>The standard FIFO queue front() and pop_front() methods are straightforward implementations for a through-buffer stream operator Φ k (given in Appendix <ref type="figure">Figure 13</ref>). The pull_push() method (given in Appendix <ref type="figure" target="#fig_0">Figure 12</ref>) basically grabs points from the prior operator Φ k-1 , processes and then releases them to the next operator Φ k+1 .</p><p>Normal computation as well as elliptical splat-estimation stream operators (Sections 4.3.1 and 4.3.3) belong to this category. The read operator (Section 4.2.1) is an even simpler through-buffer implementation as it reads and buffers one point at a time from the input stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Pre-and Post-buffer Operators</head><p>More complex are the FIFO queue implementations for stream operators Φ k (p i ) that either affect the use of in processing other nearest-neighbor related points p j by Φ k±1 (p j ), or that modify the neighbor data N i of the current point p i . We observe that:</p><p>1. Operator Φ k must defer processing p i until all its neighbors have been processed by the previous operator Φ k-1 . 2. In turn must not be accessed by any operator Φ k-1 (p j ), and point p i is only released to the subsequent stream operator Φ k+1 when it is safe to do so. Hence the pull_push() method (given in Appendix <ref type="figure" target="#fig_2">Figure 14)</ref> must pre-as well as post-buffer the processed points p i . Two queues are necessary to implement the stream operator's buffer Q k , one for buffering points p i before and one after applying Φ k . The pull_push() method first grabs all points p i released from the pre-</p><formula xml:id="formula_6">Φ R (p) x y z kD-heap active set A sorting buffer input stream output stream p n FIFO Φ E ( p ) Φ N ( p ) Φ S ( p ) deferred-write Φ E ( p ) Φ N ( p ) p j-m p j p 1 neighborhood Φ X ( p ) Φ W ( p ) read normal normal ellipse ellipse fairing a i k A i ⊆ a i in a i k aux a i k out a i aux a i k aux ∪ = a i out a i k out ∪ a i in ∪ = A i a i all a i out a i aux ∪ = = a i aux p j N i ∈ a i out a i aux a i out a i aux p i Q k ∈ p i Q k ∈ p j N i i ∪ ∈ A i \ a i k a i k p i N j ∈ p j N i ∈ p i N j ∈</formula><p>ceding operator Φ k-1 and queues them in FIFO1. Next, the queue FIFO1 is checked for available points p i that can now safely be processed by Φ k and queued in FIFO2. This requires testing for the smallest unprocessed and smallest referenced indices in the previous operators Φ k-1 . The pop_front() interface (given in Appendix <ref type="figure" target="#fig_3">Figure 15</ref>) pops points exclusively from FIFO2, the post-buffer, as only this queue maintains points already processed by Φ k Note that the top-most element p i of FIFO2 is only released by operator Φ k if it no more references any point which is still in the pre-buffer FIFO1 of Φ k ! This satisfies the constraints that when p i is released to the next operator Φ k+1 (p i ), Φ k+1 will not operate on a neighborhood N i of p i consisting of mixed points p j -with respect to being processed or not by the operator Φ k .</p><p>This category of stream operators Φ k (p i ) must carefully keep track of the smallest index i of any point , and the smallest referenced neighbor index j of any of any unprocessed point p i in Q k . This is achieved by maintaining a heap structure of indices for this purpose (see also Appendix <ref type="figure" target="#fig_2">Figure 14</ref> and Appendix <ref type="figure" target="#fig_3">Figure 15)</ref>.</p><p>The kNN and the fairing operators (Sections 4.2.2 and 4.3.4) are pre-and post-buffer stream operators. The fairing operator Φ S (p i ) changes the coordinates of a point p i and must avoid that any stream operators Φ S±1 (p j ) act on a mix of pre-and post-faired points . The kNN stream operator Φ X , however, exhibits a few notable differences. First, the queue FIFO1 is replaced by a kD-heap structure as explained in Section 4.2.2 and this kD-heap is queried and updated for the points pulled from the preceding read operator. Second, the FIFO2 queue is replaced by a sorting buffer queuing points with completed kNN sets and removed from the kD-heap.</p><p>The curvature operator Φ C (p i ) described in Section 4.3.2 is a simplified pre-and post-buffer stream operator in that it only exhibits a pre-buffer constraint to make sure that any point has been released from the prior stream operator Φ C-1 . That is because Φ C (p i ) depends on the normals n j of all k-nearest points which may still have to be computed in a prior normal operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Stream-Processing Pipeline</head><p>Setting up a stream-processing point pipeline is very simple given the outlined stream-operator framework. Some user-involvement is required to select a proper sequence of stream operators and matching attribute fields.</p><p>After setting up the input fields and initializing the stream operators the input and output point-streams can be set to memory-mapped file arrays of InputFields and OutputFields types. The main processing stage then merely consists of two very simple nested loops as shown below: The outer loop over all points consecutively read from the input stream. The inner loop iterating through the sequence of stream operators and invoking their pull-push methods to process and pass points from one to the next stream operator, with the last one writing the points to the output stream. (Appendix <ref type="figure" target="#fig_4">Figure 16</ref> gives the complete main routine corresponding to pipeline in <ref type="figure">Figure 3</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">ANALYSIS</head><p>In terms of memory requirements we note that the most critical part is a data structure that provides efficient access to all points and their nearest neighbors. In general, a balanced hierarchical spatial index structure requires O(n) space and allows processing all points and kNNs in O(k•n log n) time. While this is theoretically optimal it may nevertheless not be the fastest in practice and consume too much main memory for very large n.</p><p>Our stream-processing framework exhibits the extremely important property that only a small number of m&lt;&lt;n points are active at any time. The active set A = consists of points not fully processed for which a new point p i on the sweep plane may be necessary to complete all operator tasks. Thus in main memory only the m active points must be maintained and organized. Hence the expected main memory usage is only in the order of O(m), as only a sliding window of m elements is continuously held in the active set A. Moreover, as the processing performance is mainly determined by the kNN query, the expected running time is only O(k•n log m). This corresponds to a significantly reduced cost for the stream-processing approach.</p><p>As reported in the experimental results section below, the computation of all kNNs is dominating the overall workload. Therefore, the end-performance will strongly depend on the parameter k (proportionally) and the number s&lt;m (logarithmically) of points in the kD-heap of the nearest neighbor stream operator Φ X .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTAL RESULTS</head><p>All experiments were performed on a 1.8GHz PowerMac G5. Timing was performed using the Unix clock() function to measure individual functions within the code, and the /usr/bin/time Unix command line tool was used to measure the wall-clock time elapsed between invocation and termination of the executable. Hence the total timings even include any time a process spent waiting for events such as completion of I/O operations (and not only the consumed CPU cycles).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Preprocessing</head><p>Pre-process results for ordering some point data sets are given in <ref type="table" target="#tab_1">Table 1</ref>. All data sets are ordered for streaming along the dimension of largest extent. Besides St. Matthew, which was converted from a binary QSplat model <ref type="bibr" target="#b32">[33]</ref>, all models were converted from a plain ASCII PLY triangle mesh format. Any information besides the raw point coordinates and color was omitted in that process.</p><p>Generally the ordering and streaming of points is implemented using memory mapped arrays. After reading the raw point data from the input mesh, or QSplat file into a file-memory mapped point array, our current implementation of the sorting pre-process uses a quicksort algorithm to order the points along a given dimension. As shown in <ref type="table" target="#tab_1">Table 1</ref>, quicksort on a memory mapped array performs quite well as it accesses the data in a coherent linear way -doing log(n) passes. Improved pre-process sorting can be achieved by more sophisticated out-of-core techniques <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b37">38]</ref> such as the rsort <ref type="bibr" target="#b22">[23]</ref> tool that has been used in similar situations, however, this is not the main focus here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Stream Processing</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Overview</head><p>In our experiments we have tested various stream processing pipelines consisting of stream operators discussed in Section 4. The three different stream-processing pipelines and their sequence of applied stream operators are: </p><formula xml:id="formula_7">• Normal: Φ R (read), Φ X (k-nearest neighbors, k=8), Φ N (normal estimation) and Φ W (deferred-write). p j N i ∈ p i Q k ∈ p j N i ∪ ∈ p i N j ∈ p j N i ∈ p j N i ∈ p 1 … p n , ,</formula><formula xml:id="formula_8">p i 1 -… p i m - , ,</formula><p>• Curvature: Φ R , Φ X (k=8), Φ N , Φ C (curvature), Φ E (elliptical splat estimation) and Φ W .</p><formula xml:id="formula_9">• Fairing: Φ R , Φ X (k=64…384), Φ N , Φ E , Φ S (smoothing),</formula><p>Φ N , Φ E and Φ W . In <ref type="table" target="#tab_2">Table 2</ref> we give an overview of the time required to process large models with the Normal and Curvature stream-processing pipelines, as well as the per-point lifespan time. This indicates for how long on average a point remained in the active set A while being processed by the different stream operator stages. The table also includes the size of the generated output point streams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Streaming Working Set</head><p>As outlined in Sections 3 and 4, a major goal of the proposed stream-processing framework is to drastically reduce the number of points actively referenced at any time to perform a series of local operators on a point set. This limited working set (i.e. main-memory usage) and the coherent streaming access of points allows effective processing as demonstrated in our experiments.</p><p>The graphs in <ref type="figure" target="#fig_2">Figure 4</ref> show the sizes of the FIFO buffers corresponding to the different stream operators that together define the Curvature pipeline working set A of active points at any time during stream-processing. Note that the read, normal-and splat-estimation (operator) buffers are omitted as they only keep one point at a time (see also Section 5.2.1). As demonstrated impressively by these charts, the stream-operator buffers hardly ever maintain 0.5% of the large point sets in the active set A (i.e. in main memory). In fact, for the largest St. Matthew model the buffers rarely even reach a size of 2/1000 (or 0.2%) of the overall model size.</p><p>Lucy exhibits some strong growth of the active working set A up to 2% during the first few 100K points at a very early stage. However, it then dramatically drops to only maintain on average much less than 20K points dynamically during the remainder of the stream-processing. Peaks in the active working set A are due to peculiar data distributions in the point streams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Main Memory (In-)Dependence</head><p>To back the claim of effective stream-processing of large point sets we carried out two experiments with the Curvature stream-operator pipeline: (1) Having the test machine configured with 256MB, and (2) with 2GB of main memory. In (1), the Lucy, David 1mm and St. Matthew (output) data sets significantly exceeded the available physical memory, but in (2) only St. Matthew did.</p><p>As strongly supported by the chart in <ref type="figure" target="#fig_3">Figure 5</ref>, the experiments reveal that our stream-processing framework is virtually independent of the available main memory size (as long as it can hold the very limited active working set A). The size of main-memory is essentially irrelevant and has no effect on the overall point processing cost, because all the expensive computational work is limited to the small set of points in the active working set A which can easily be kept in main memory for huge data sets. Therefore, our stream-processing framework can handle exceedingly large data sets from out-of-core which is equally nicely demonstrated by that experiments. Moreover, as the streaming concept only relies on an ordered sequential access, the input and output streams can also be much larger than 32-bit virtual address space as demonstrated for the St. Matthew model (e.g. see its Curvature output size in <ref type="table" target="#tab_2">Table 2</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.4">Performance</head><p>While the current implementation is not optimized for performance, the experiments show that the major cost is the determina- tion of all kNN as shown in <ref type="figure" target="#fig_4">Figure 6</ref> for the Curvature stream-processing pipeline. The extra large kNN search cost for the David 1mm model stems from the fact that for this model the stream operator Φ X buffers noticeably more elements during the first 6M stream-processed points (see chart in <ref type="figure" target="#fig_2">Figure 4</ref>). As mentioned in Section 6, the average size m of the kNN buffer is the main performance factor as it contributes to an expected O(k log m) kNN search cost for each point. The other operators only add constant cost factors as they operate on the fixed kNN set. Moreover, disk read/write I/O overhead does not comprise any bottleneck of the proposed stream-processing framework and hence the concept is well suited for processing very large data sets (see also Section 7.2.3). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Versatility</head><p>To demonstrate the practical application of our stream-processing points framework we performed normal, splat-ellipse and curvature estimation, with results shown in <ref type="figure" target="#fig_5">Figure 7</ref>. The normal and splat estimation operators generate accurate point attributes that can be exploited in high-quality point-based visualization systems. Additionally, the curvature operator provides a robust estimate of the main curvature directions and their qualitative strengths which may be used as the basis for more complex operations such as feature extraction or surface segmentation. To further demonstrate the versatility of our modular stream-operator framework we also performed initial experiments with the proposed fairing operator described in Section 4.3.4. For this purpose we introduced random normal-distributed noise in the magnitude of 0.05% of the bounding-box diagonal to the David head model in <ref type="figure" target="#fig_6">Figure 8</ref>, and used the noisy Lion model in <ref type="figure" target="#fig_7">Figure 9</ref>. In both cases we set the variance of the Gaussian weight functions f(r) and g(r) in Equation 3 to 0.5% of the bounding-box diagonal. As demonstrated the results manifest excellent feature-preserving smoothing effects, and substantiate the flexibility of our stream-processing points approach to accommodate a wide range and complexity of different local operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">DISCUSSIONS</head><p>We have presented a novel point processing framework based on a linear streaming of points, a sweep-plane algorithm for k-nearest neighborhood determination and the definition of concatenable  local stream operators. To our knowledge this is the first method that can apply local operators such as normal estimation and fairing without a data structure holding the entire data set in in-core or virtual memory, and that is applicable to arbitrary large data sets out-of-core with only limited main memory usage. It is also the only approach processing points as streams and that is extensible in a modular way to apply multiple concatenated local operators consecutively on the point set.</p><p>Several performance details are not optimized in the current framework. Among the possible improvements is a much more aggressive balancing strategy to keep the k-nearest neighbor query cost low. Further work includes the development of a specialized sweep-plane spatial search structure for this purpose.</p><p>The k-nearest neighborhood sweep-plane algorithm described in Section 4.2.2 can under certain circumstances generate an approximate k-nearest neighbor set instead of the exact solution. However, in practice we observed no difference to the exact solution with several test models. Moreover, a good approximate k-nearest neighbor set may be sufficient for most local operators. Additionally, the framework can easily be modified to compute a fixed-range d neighborhood with variable k for each point, and then an exact distance-d k-nearest neighbor set can be computed. The major limitations include that extreme spatial outliers of disjoint point clusters with less than k elements may cause the active working set to grow unproportionally. Also significant manipulation of point coordinates in stream operators (i.e. beyond local smoothing) may cause the established stream-order and k-nearest neighbor sets to become intolerably incorrect. These problems may be addressed by new sort-update and k-nearest-update stream operators that are inserted after such coordinate-manipulating operations.</p><p>Future work will include the development of a wide variety of basic and also more complex point stream operators such as segmentation, simplification or compression. In particular, a multires-operator to generate a multiresolution output format for efficient level-of-detail visualization is of immediate interest.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Sweep-plane process overview: unprocessed points are read sequentially from the input stream, processed points are written to the output stream.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>/</head><label></label><figDesc>/ main loops for processing stream of points while (operators[0]-&gt;position() &lt; npoints) for (i = 0; i &lt; nops; i++) ops[i]-&gt;pull_push();</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Streaming total active working set and buffer sizes of corresponding stream operators plotted against the progress through the input point stream. (y-axis indicates size only up to 1% or 2% of the entire data set)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Dependency, or rather independency, of available main memory on total stream-processing cost for various models.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Percentage of time costs of the different stream-operator processing stages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Results of applying normal computation, splat estimation and curvature stream operators to raw point cloud data sets. The images show the high-quality normal estimation and the color coded qualitative (RMS) curvature strength.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Original smooth surface (top); random noise of 0.05% of diagonal length added to each coordinate (middle); and smoothened model using our stream-process fairing operator (bottom).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Original noisy input model (top); and smoothened model using our stream-process fairing operator (bottom).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Input test model and output point stream sizes. Preprocess timing includes converting and sorting point data.</figDesc><table><row><cell>Model</cell><cell>#Points</cell><cell>Mesh File Size</cell><cell>Point Stream File Size</cell><cell cols="2">Preprocess reading sorting</cell></row><row><cell cols="2">St. Matthew 102,965,801</cell><cell>N/A</cell><cell>1,571MB</cell><cell>35s</cell><cell>93s</cell></row><row><cell cols="3">David 1mm 28,168,109 2,288MB</cell><cell>430MB</cell><cell>125s</cell><cell>22s</cell></row><row><cell>Lucy</cell><cell cols="2">14,022,961 1,085MB</cell><cell>214MB</cell><cell>52s</cell><cell>11s</cell></row><row><cell>David 2mm</cell><cell>4,129,534</cell><cell>327MB</cell><cell>63MB</cell><cell>19s</cell><cell>3.4s</cell></row><row><cell>David head</cell><cell>2,000,646</cell><cell>165MB</cell><cell>30MB</cell><cell>12s</cell><cell>1.5s</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Overall timing results of stream-processing points, and average lifespans of points in active set A.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>David (2mm)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">k-Nearest</cell><cell>Curvature</cell><cell>Write</cell><cell>Total</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>80,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>2%)</cell><cell>70,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Buffer Size in Points (8 10 4</cell><cell>10,000 20,000 30,000 40,000 50,000 60,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">30,000</cell><cell>430,000</cell><cell cols="2">830,000</cell><cell cols="3">1,230,000 1,630,000 2,030,000 2,430,000 2,830,000 3,230,000 3,630,000 4,030,000</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Elements Processed</cell></row><row><cell>Model</cell><cell>Pipeline</cell><cell>Point Stream Output Size</cell><cell cols="2">Timing Process h:mm:ss Lifespan sec.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">k-Nearest</cell><cell>Lucy Curvature</cell><cell>Write</cell><cell>Total</cell></row><row><cell>St. Matthew David 1mm Lucy</cell><cell>Normal Curvature Normal Curvature Normal Curvature</cell><cell cols="3">3,142MB 5:02:25 6,284MB 7:51:14 859MB 2:33:56 23.62s 7.56s 1,719MB 2:52:45 29.27s 428MB 26:32 4.78s 856MB 33:25 6.17s 13.0s</cell><cell>Buffer Size in Points (3 10 5 2%)</cell><cell>300,000 50,000 100,000 150,000 200,000 250,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>David 2mm</cell><cell>Normal Curvature</cell><cell>126MB 252MB</cell><cell>6:02 7:50</cell><cell>0.62s 1.36s</cell><cell></cell><cell cols="2">0 30,000</cell><cell cols="2">1,630,000</cell><cell cols="2">3,230,000</cell><cell cols="2">4,830,000</cell><cell>6,430,000 Elements Processed 8,030,000</cell><cell>9,630,000</cell><cell>11,230,000</cell><cell>12,830,000</cell></row><row><cell>David head</cell><cell>Normal Curvature</cell><cell>61MB 122MB</cell><cell>2:53 3:43</cell><cell>0.66s 1.45s</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">David (1mm) k-Nearest Curvature</cell><cell>Write</cell><cell>Total</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>300,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1%)</cell><cell>250,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Buffer Size in Points (3 10 5</cell><cell>50,000 100,000 150,000 200,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">50000</cell><cell cols="3">2610000 5170000</cell><cell cols="3">7730000 10290000 12850000 15410000 17970000 20530000 23090000 25650000</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Elements Processed</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>St. Matthew</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>k-Nearest</cell><cell>Curvature</cell><cell>Write</cell><cell>Total</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1,000,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1%)</cell><cell>800,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Buffer Size in Points (10 6</cell><cell>200,000 400,000 600,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">50,000</cell><cell cols="6">11,570,000 23,090,000 34,610,000 46,130,000 57,650,000 69,170,000 80,690,000 92,210,000</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Elements Processed</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">100000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>10000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Processing Time in Seconds</cell><cell>100 1000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>256MB 2GB</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Balljoint</cell><cell></cell><cell>Female</cell><cell></cell><cell>Dragon</cell><cell>David Head</cell><cell>David 2mm</cell><cell>Lucy</cell><cell>David 1mm</cell><cell>St. Matthew</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We like to thank the Stanford 3D Scanning Repository, Digital Michelangelo project and Cyberware for providing models. This project was partly supported by a UCI SIIG-2003-2004-19 grant and a Ted &amp; Janice Smith Faculty Seed Funding Award. We also thank the reviewers for their helpful comments which, if not in this paper, will be certainly be addressed in follow up work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Point set surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Alexa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Behr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shackar</forename><surname>Fleishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="21" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Bounds on the k-neighborhood for locally uniformly sampled surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mattias</forename><surname>Andersson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joachim</forename><surname>Giesen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Pauly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bettina</forename><surname>Speckmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Symposium on Point-Based Graphics</title>
		<meeting>Symposium on Point-Based Graphics</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="167" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">High-quality point-based rendering on modern GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Pacific Graphics</title>
		<meeting>Pacific Graphics</meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="335" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient high quality rendering of point sampled geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Wiratanaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Eurographics Workshop on Rendering</title>
		<meeting>Eurographics Workshop on Rendering</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="53" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Anisotropic geometric diffusion in surface processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulrich</forename><surname>Clarenz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Udo</forename><surname>Diewald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rumpf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="397" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sequential point trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carsten</forename><surname>Dachsbacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Vogelgsang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Stamminger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="657" to="662" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Mark De Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Otfried</forename><surname>Overmars</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schwarzkopf</surname></persName>
		</author>
		<title level="m">Computational Geometry: Algorithms and Applications</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Virtual memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="153" to="189" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Implicit fairing of irregular meshes using diffusion and curvature flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Mathieu Desbrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">H</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="317" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A delaunay based shape reconstruction from larga data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tamal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joachim</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Giesen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hudson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Symposium in Parallel and Large Data Visualization and Graphics</title>
		<meeting>IEEE Symposium in Parallel and Large Data Visualization and Graphics</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="19" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">PMR: Point to mesh rendering, a feature-based approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tamal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hudson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Surface reconstruction based on lower dimensional localized delaunay triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gopi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings EUROGRAPHICS</title>
		<meeting>EUROGRAPHICS</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="467" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Point sample rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Eurographics Rendering Workshop</title>
		<meeting>Eurographics Rendering Workshop</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Surface reconstruction from unorganized points</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchampt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIG-GRAPH</title>
		<meeting>ACM SIG-GRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Compression for gigantic polygon meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Gumhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="935" to="942" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Streaming meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<idno>UCRL-CONF-201992</idno>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
		<respStmt>
			<orgName>Lawrence Livermore National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Large mesh simplification using processing sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jack</forename><surname>Snoeyink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="465" to="472" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Non-iterative, feature-preserving mesh smoothing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Thouis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fredo</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathieu</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Desbrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="943" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Normal improvement for point rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Thouis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fredo</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zwicker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="53" to="56" />
			<date type="published" when="2004-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Modeling and rendering points with local geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Kalaiah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="2003-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>3rd Edition</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The use of points as display primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Turner</forename><surname>Whitted</surname></persName>
		</author>
		<idno>TR 85-022</idno>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of North Carolina at Chapel Hill</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">rsort and fixcut. man pages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">P</forename><surname>Linderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Adaptive fairing of digitized point data with discrete curvature</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">S</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Loh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Design</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="320" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Estimating surface normals in noisy point cloud data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Niloy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">An</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Computational Geometry</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="322" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Efficient level-of-details for point based rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IASTED Invernational Conference on Computer Graphics and Imaging (CGIM)</title>
		<meeting>IASTED Invernational Conference on Computer Graphics and Imaging (CGIM)</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Confetti: Object-space point blending and splatting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Sainz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Guidotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="598" to="608" />
			<date type="published" when="2004-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Spectral processing of point-sampled geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Pauly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="379" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient simplification of point-sampled surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Pauly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><forename type="middle">P</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="163" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Shape modeling with point-sampled geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Pauly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Keiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIG-GRAPH</title>
		<meeting>ACM SIG-GRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="641" to="650" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Surfels: Surface elements as rendering primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanspeter</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Zwicker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeroen</forename><surname>Van Baar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIG-GRAPH</title>
		<meeting>SIG-GRAPH</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="335" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Object space EWA surface splatting: A hardware accelerated approach to high quality point rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanspeter</forename><surname>Liu Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zwicker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings EUROGRAPHICS</title>
		<meeting>EUROGRAPHICS</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="461" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">QSplat: A multiresolution point rendering system for large meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Szymon</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="343" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Point-based rendering techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Sainz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="869" to="879" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Points reloaded: Point-based rendering revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Sainz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Lario</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Symposium on Point-Based Graphics</title>
		<meeting>Symposium on Point-Based Graphics</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="121" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Geometric fairing of irregular meshes for free-form surface design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="359" to="379" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A signal processing approach to fair surface design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Taubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH</title>
		<meeting>SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="351" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">External memory algorithms and data structures: Dealing with massive data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="271" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Post-processing of scanned 3D surface data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Weyrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pauly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Keiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heinzle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Scandella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Symposium on Point-Based Graphics</title>
		<meeting>Symposium on Point-Based Graphics</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="85" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A stream algorithm for the decimation of massive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianhua</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Graphics Interface</title>
		<meeting>Graphics Interface</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="185" to="192" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
