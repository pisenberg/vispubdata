<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sort-Middle Multi-Projector Immediate-Mode Rendering in Chromium</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jorge</forename><forename type="middle">Luis</forename><surname>Williams</surname></persName>
							<email>jorgew@cs.uidaho.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Idaho</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Hiromoto</surname></persName>
							<email>hiromoto@cs.uidaho.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Idaho</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Sort-Middle Multi-Projector Immediate-Mode Rendering in Chromium</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.2 [Computer Graphics]: Graphics Systems-Distributed/network graphics</term>
					<term>I.3.4 [Computer Graphics]: Graphics Utilities-Software support, Virtual device interfaces</term>
					<term>C.2.2 [Computer-Communication Networks]: Network Protocols-Applications</term>
					<term>C.2.4 [Computer-Communication Networks]: Distributed Systems-Client/Server, Distributed Applications Cluster Rendering, Sort-Middle, Multi-Projector, Tile Displays, Immediate-Mode Rendering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Traditionally, sort-middle is a technique that has been difficult to attain on clusters because of the tight coupling of geometry and rasterization processes on commodity graphics hardware. In this paper, we describe the implementation of a new sort-middle approach for performing immediate-mode rendering in Chromium. The Chromium Rendering System is used extensively to drive multi-projector displays on PC clusters with inexpensive commodity graphics components. By default, Chromium uses a sort-first approach to distribute rendering work to individual nodes in a PC cluster. While this sort-first approach works effectively in retainedmode rendering, it suffers from various network bottlenecks when rendering in immediate-mode. Current techniques avoid these bottlenecks by sorting vertex data as a pre-processing step and grouping vertices into specific bounding boxes, using Chromium&apos;s bounding box extension. These steps may be expensive, especially if the dataset is dynamic. In our approach, we utilize standard programmable graphics hardware and extend standard APIs to achieve a separation in the rendering pipeline. The pre-processing of vertex data or the grouping of vertices into bounding boxes are not required. Additionally, the amount of OpenGL state commands transmitted through the network are reduced. Our results indicate that the approach can attain twice the frame rates as compared to Chromium&apos;s sort-first approach when rendering in immediatemode.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>High-resolution, multi-projector computer displays are increasingly used in areas such as scientific visualization, computer-aided design, and other demanding interactive graphics applications. The size of the images produced, and the resolution achieved (often in the millions of pixels) allows multiple users to interact with complex rendered objects in their natural size. Early multi-projector displays are driven by expensive high-end shared memory graphics machines such as SGI's InfiniteReality <ref type="bibr" target="#b11">[13]</ref>. Today, these highend machines are being replaced more and more by a cluster of inexpensive PCs each with a commodity graphics accelerator card. This trend is a result of the availability of fast and inexpensive PCs, graphics accelerator cards, memory, large hard drives, and local area networks. Besides cost, there are additional advantages in using PC clusters over high-end graphics systems. First, using a local area point-to-point network for interprocess communication allows heterogeneous PCs to be added and removed easily. Second, the use of commodity hardware and its access via standard APIs allows the system to better track technology; in the sense that, as new features and speed enhancements are added they can be incorporated easily into the display system. This is an important advantage since high-end graphics systems often contain custom built components that are expensive to replace or upgrade. Finally, since individual PCs do not share a local bus, a PC cluster system scales better than a tightly-integrated high-end graphics system as additional processors are added. There are major disadvantages, however, in using a PC-cluster system. First, a PC-cluster imposes design constraints on the underlying rendering system. For example, it is not possible to obtain rendering data efficiently from graphics accelerators through standard APIs. Additionally, a PC-cluster imposes a programming model in which the programmer must deal with the distribution of rendering data to individual PC nodes. These are issues not dealt with in a shared memory system. A more significant disadvantage, however, is that the bandwidth and latencies involved in communication between processors over a local area network are inferior to those on high-end graphics machines that typically employ a shared virtual address space, bus, and memory. The challenge in running a multi-projector display on a PC-cluster is to design an efficient rendering system that maintains load-balance, reduces network latency, and maximizes available bandwidth given the constraints imposed by the PC-cluster.</p><p>Multi-projector cluster systems are often configured in one of the arrangements shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Control PCs (red) handle geometry generation and load distribution (balancing), and Render PCs (blue) typically render an image and transmit it to a projector. A PC may double as both a Control and Render PC. There is typically one projector attached per Render PC. The projectors in the system each project a tile on a display wall and the tiles combine to form the high resolution display. In generates all 3D geometry. In (c) the 3D application is parallelized such that the generation of geometry can be distributed among all PCs. In (b) and (c) the Control PCs double as Render PCs. Other arrangements are possible.</p><p>The sorting and distribution of data to individual PCs is inherent in all parallel rendering algorithms. These rendering algorithms can be classified according to when data is sorted between the 3D object space and 2D image space <ref type="bibr" target="#b10">[12]</ref>. Three basic classifications exist: sort-first, sort-middle and sort-last. In sort-first, the geometry is sorted between the rendering tiles. In sort-middle, the geometry is distributed evenly among all processors and then sorted after the geometry stage of the rendering pipeline. Finally, in sort-last, the geometry is run through the full pipeline to generate images at every PC. These images are composited to form a final image.</p><p>While the sort-last rendering technique is effectively used in cluster rendering when the resolution of the rendered images is relatively small, the technique does not scale efficiently on a multiprojector system because the transmission of high-resolution images reduces the bandwidth imposed on the cluster network. For this reason, multi-projector systems (including high-end graphics machines) employ sort-first or sort-middle techniques as they do not suffer as much from this limitation. Sort-middle architectures are designed for use on dedicated shared memory graphics hardware where one can adjust the number of geometry or fragment processors to achieve required performance. For example, one can configure InfiniteReality based systems with additional Raster Managers to improve fill rate <ref type="bibr" target="#b7">[9]</ref>. In cluster systems, however, sort-first and sort-last are exclusively used. Currently, sortmiddle systems are less favored since the arrival of commodity high-performance GPUs, where the tight coupling of geometry and rasterization stages makes the sort-middle approach difficult to implement. In this paper, however, we propose a straight-forward technique to overcome this implementation difficulty. We uncouple the geometry and rasterization stages and find that taking a sortmiddle approach is advantageous for performing immediate-mode rendering in Chromium, a stream-based cluster rendering system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CHROMIUM AND STREAM-BASED RENDERING</head><p>Many cluster rendering systems have focused on stream-based rendering. In stream-based rendering a stream of graphics commands and associated graphic primitives are distributed through the network and interpreted in real-time by Render PCs. The graphics commands and primitives are generated either via a virtual display driver or by an OpenGL replacement library. The main advantage of this rendering method is that it enables any OpenGL application to run on a multi-projector system without modifying the application source. A secondary advantage is that, unlike other techniques, it easily supports immediate-mode rendering while still fully supporting retained-mode rendering. Retained-mode rendering is achieved in a stream-based system by transmitting and retaining display lists early in the run and transmitting a stream of glCallList commands as the run progresses.</p><p>The stream-based rendering technique of hijacking OpenGL commands has been used to achieve stylized drawing effects on unmodified 3D applications <ref type="bibr" target="#b9">[11]</ref>. In cluster-rendering systems, however, the captured commands are issued to Render PCs that project an image to their respective tiles. Additionally, some systems also provide an X11 proxy to handle input devices and capture rendering and windowing commands <ref type="bibr">[8,</ref><ref type="bibr" target="#b8">10]</ref>. These systems allow windows to be drawn across tile boundaries and the tile display to be treated as a single logical entity. Where as some systems simply broadcast all primitives and commands to all rendering nodes <ref type="bibr" target="#b2">[3]</ref>, most, sort primitives among the rendering tiles and utilize a sortfirst algorithm. <ref type="bibr" target="#b14">Samanta et al. [1998]</ref>   <ref type="bibr" target="#b5">[6]</ref> by adding support for stream processing units (SPUs). SPUs are configurable software libraries that can intercept a stream of OpenGL commands and optionally apply transformations on these commands in a manner similar to Mohr and Gleicher to achieve stylized effects. These modified command streams can then be sent to a vendor OpenGL library or another SPU. Additionally, a SPU may produce a serialized version of the API stream that can be sent to another PC via a point-to-point network. Because SPUs can be chained together to form topologies, they can be combined to create different stream-based rendering algorithms. Humphreys et al., for example, describe implementations of both a sort-first and sort-last renderer using Chromium, Figures 2 and 3 illustrate this. In the sort-first implementation the tilesort SPU directs the stream of graphics commands generated by the application to the Chromium server responsible for rendering a particular tile. A Chromium server is simply an application that reads a stream of GL commands from the network and passes them along to an SPU chain. The readback SPU performs the GL operations to generate an image in memory. The SPU then "reads back" the image and produces a stream of GL commands for drawing. Here, each Chromium server is responsible for generating an image-tile where these image-tiles are in-turn sent to the final Chromium server. The final server passes the image-tiles to the render SPU that combines them and draws the final image on the screen. These last two steps are omitted in multi-projector rendering where each tile is connected to an individual projector. The sort-last implementation works in a similar as sort-first, except that entire frames are combined rather than individual tiles making up a frame. Chromium has the flexibility to perform tasks other than cluster rendering. <ref type="bibr" target="#b12">Niederauer et al. [2003]</ref> uses Chromium to produce expanded views of architectural environments by processing OpenGL streams from existing applications without modifying the application's source. Instead of having each SPU export an entire OpenGL interface that contains hundreds of API calls, a SPU may inherit functions from a "parent" SPU. It is this combination of flexibility and usability that has made Chromium a popular choice for driving multi-projector displays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">IMMEDIATE-MODE RENDERING IN CHROMIUM</head><p>In immediate-mode rendering, primitives are sorted and transmitted to Render PCs at every frame. Thus, it is possible for substantial network traffic to be generated. In sort-first, the sorting of geometric primitives to tiles involves performing transformation of a primitive to determine into which tile each primitive falls. This process is known as the pre-transform of vertices <ref type="bibr" target="#b10">[12]</ref>, because it occurs before the geometric stage of the pipeline. The goals of any sort-first implementation should be to avoid redundant work (by limiting the vertices that must be pre-transformed) and to limit the traffic on the network.</p><p>Avoiding the redundancy of pre-transforming primitives can be achieved by spatially grouping primitives into bounding boxes. Then the sort-first sorting process (bucketization) can transform each bounding box (rather than each primitive within the bounding box) and intersect it against the rendering tiles. If the box intersects a rendering tile then all geometry contained within it is assumed to intersect that tile. In a general implementation, to create suitable bounding boxes, this technique assumes that some prior knowledge exists about which primitives lie together spatially. In Chromium, it is assumed that primitives that lie together temporally also lie together spatially. Although this assumption may be guaranteed when the creation of bounding boxes are performed sequentially, a parallel application where multiple Control PCs are assigned primitives in some distributed fashion makes this assumption difficult to realize. In order to understand the overhead associated with the transmission of primitives in bounding boxes, we define an overlap factor as the average number of tiles a bounding box intersects. This definition differs from <ref type="bibr" target="#b10">[12]</ref> in that these authors defined the overlap factor as the average number of tiles a primitive intersects. If the overlap factor is greater than one then primitives must be transmitted multiple times; once to each Render PC associated with the intersecting tiles. This can dramatically increase network traffic.</p><p>In general, it is difficult to reduce the primitives that must be transmitted per frame in immediate-mode; however, it is possible to reduce the amount of state change commands that must be transmitted if the OpenGL state is carefully tracked <ref type="bibr" target="#b0">[1]</ref>. Chromium's tilesort SPU combines this idea of carefully tracking state with the creation of bounding boxes. Primitives that share a particular state are combined together into a bounding box. The assumption is that these primitives lie close together spatially. By combining primitives with the same state it is assumed that both the overhead associated with the pre-transform of primitives and the retransmission of state can be controlled simultaneously. Since each bounding box contains primitives sharing a single state, these primitives can be encapsulated within their own glBegin and glEnd statements. Additionally, state commands are transmitted only once; before transmission of all the primitives in the bounding box.</p><p>In cases where primitives with the same state are not spatially close or where the variance in states is small, Chromium is shown to perform poorly <ref type="bibr" target="#b16">[18]</ref>. These cases produce bounding boxes with high overlap factors. In the worse case, the overlap factor equals the number of tiles in the rendering system and results in all primitives transmitted to all tiles. Chromium's GL_CR_bounding_box extension is designed to counter this problem by creating bounding boxes programmatically rather than relying solely on state. Gen-erating bounding boxes programmatically, however, is not trivial. For example, if the bounding boxes are large with respect to the size of the viewable screen, then the overlap factor is high and results in increasing network traffic. If the bounding boxes contain relatively few primitives then the redundancy of pre-transforming primitives is high. And finally, if there are too many bounding boxes then the overhead of transmitting glBegin and glEnd statements, and global state information for each bounding box may overload the network. As mentioned above, a parallel application (one that generates the scene via multiple Control PCs) adds additional complexities that can limit the effectiveness in using the GL_CR_bounding_box extension. In particular, as the data set of primitives becomes less localized spatially (either by scheduling or by its dynamic nature), organizing the primitives to create bounding boxes of optimal size may become difficult. In these cases, knowledge of the spatial organization of the data-set and the layout of the tiles is required to utilize the GL_CR_bounding_box extension effectively.</p><p>Additionally in Chromium, if an application's source code is unavailable, the GL_CR_bounding_box extension may not be used at all. This situation arises because Chromium supports application level replication <ref type="bibr" target="#b2">[3]</ref>, where the parallel coordination and the OpenGL extension calls are performed within the application itself. Without the application's source code, it would be difficult for modifications to be added; and thus, for bounding boxes to be introduced. This not to say that Chromium might not be used when the source code is unavailable; in these cases, however, the application is typically not extended, replicated to multiple Control PCs, or synchronized.</p><p>In a sort-middle approach applied to immediate-mode rendering in Chromium, the problems discussed above are less challenging. Geometric computations are computed by Control PCs before primitives are transmitted to Render PCs. The redundancy in pretransforming primitives is avoided. The creation of bounding boxes is unnecessary. By avoid bounding boxes, there is an automatic reduction in the overlap of primitives because primitives are sorted to tiles one at a time. Additionally, because geometric computations are executed locally, all state commands that affect the geometric portion of the graphics pipeline need not be transmitted to Render PCs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">OVERVIEW OF SORT-MIDDLE APPROACH</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">OpenGL Extensions</head><p>Sort-middle is a technique that has been difficult to attain on PC clusters. The main difficulty is related to the tight coupling of the geometry and rasterization rendering processes. The problem is twofold. The OpenGL graphics library does not return intermediate rendering results, and graphics accelerator cards do not provide the user easy access to intermediate rendering data. In our approach the OpenGL library is extended to return intermediate data, and our extension takes advantage of programmable graphics accelerators to achieve a separation between the geometry and rasterization pipelines with minimal loss in rendering speeds.</p><p>We modify the OpenGL library by introducing the GL_UID_sortmiddle extension.</p><p>The extension consists of two function calls as illustrated in <ref type="figure">Figure 4</ref>: triangle-feedback and triangle-rasterize. The triangle-feedback call allows the OpenGL implementation to pass all primitives through the geometric portion of the pipeline and return the results to a call-back function instead of rasterizing them. The use of this calling sequence logically uncouples the geometry pipeline from the rasterization pipeline. Calling glTriangleFeedbackUID with a valid call-back function puts the OpenGL implementation in a geometry-only state. In this state, the implementation computes only the geometry portion of void glTriangleFeedbackUID (freedback_func f) void glRasterTriangleUID (const SWvertex *v1, const SWvertex *v2, const SWvertex *v3)   <ref type="bibr" target="#b13">[15]</ref> software rasterizer and can be easily converted to other formats to allow hardware acceleration. By utilizing a compatible structure, we easily extend the Mesa library to add full support for the GL_UID_sortmiddle extension in software. To add hardware acceleration support for the trianglerasterize function, we utilize the GL_ARB_vertex_program extension to create a vertex program that passes the information from a software vertex structure into the hardware rasterizer on the accelerator card. Experiments with other approaches such as modifying open source GL drivers; however, dictates the use of a common extension as a back-end to our extension. This insures that our implementation is not tied to a particular platform or GL implementation.</p><p>Adding hardware support for triangle-freedback is more difficult. It would be possible to utilize the programmability of the graphics accelerator card (as is done for triangle-rasterize); however, such an approach would leave the geometric results in an image buffer with a need to read them back into the rasterization pipeline. Instead, for this initial implementation, we take the much simpler approach of utilizing Mesa for computing the geometric portion of the graphics pipeline. This produces acceptable results when a PC's processor is dedicated to geometric processing. Mesa is an optimized library with support for SSE and 3DNow! extensions for geometric processing. It is also portable. Tests verify our extension on x86, Spark, and PowerPC based systems. On the PowerPC, we extend Mesa with initial support for AltiVec extensions since AltiVec is not currently supported by the Mesa library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Chromium SPUs</head><p>We extend Chromium by adding support for two additional SPUs: the geometry SPU and the georender SPU. The geometry SPU is responsible for computing geometric data and is typically executed by a Control PC. The georender SPU is responsible for the rasterization process and is typically executed by Render PCs. The SPUs are illustrated in <ref type="figure">Figure 6</ref>. Both SPUs are derived from Chromium's render SPU that simply streams all rendering com-  <ref type="figure">Figure 6</ref>: Sort-Middle SPUs.</p><p>mands to a vendor OpenGL library. In the geometry SPU, we substitute a vendor's library with our modified version of Mesa that contains full support for the sort-middle extensions described in the previous section. This substitution enables us to take advantage of Mesa's optimized geometric stage with minimal effort. By utilizing Mesa for the geometry SPU, the SPU becomes intimately tied to the Mesa implementation. Thus while we gain a highly optimized geometric stage from Mesa, we also inherit Mesa's limitations. One example is in the use of vertex programs. Our initial implementation extended version 6.0.1 of the Mesa library. This version did not offer full support for the GL_ARB_vertex_program, as such our geometry SPU was incompatible with programs that depended on this functionality. Current versions of Mesa do not suffer from this lack of support and as a result neither do recent versions of our SPU.</p><p>In the georender SPU, we utilize the default OpenGL library available to the system. Although both SPUs link dynamically to separate OpenGL libraries, it is possible for them to run on the same cluster node.</p><p>The geometry SPU handles all incoming API calls according to the following 3 categories:</p><p>• Local Calls-Calls that affect only the geometric portion of the pipeline and are executed locally.</p><p>• Raster Calls-Calls that affect only the rasterization portion of the rendering pipeline and are transmitted to a proper georender SPU.</p><p>• Global Calls-Calls that affect both the rasterization and the geometric portions of the pipeline. The geometry SPU forwards these calls to its parent and transmits them to a proper georender SPU.</p><p>Some calls fall under more than one category and must be handled as special cases. An example is the glEnable call. When a capability such as GL_DEPTH_TEST is enabled, the call falls under the Global Calls category since depth testing affects both the geometric portion of the pipeline (that must now generate z-values) and the rasterization portion (that must now perform depth comparisons). However, a capability such as GL_AUTO_NORMAL affects only the geometric portion of the pipeline. Here glEnable falls under the Local Calls category and is handled locally. Another function of the geometry SPU is to utilize triangle feedback to capture the results of the geometric portion of the rasterization pipeline. The SPU then sorts these results according to their location in tile-space, and forwards a glTriangleRasterizeUID call to the proper rasterization server. A glTriangleRasterizeUID call is sent to all tiles that a triangle intersects even if the triangle may be completely or partially occluded based on z-tests. Although not currently implemented, it is possible to cull these triangles as a further optimization.</p><p>The main responsibility of the georender SPU is to add support for incoming glRasterTriangleUID calls if they are not supported by the local GL implementation.</p><p>The SPU does this by translating these calls to applicable calls for the GL_ARB_vertex_program extension. This insures the utilization of the hardware accelerator during the rasterization stage without direct vendor support for the GL_UID_sortmiddle extension. To do the translation, the SPU first loads a suitable vertex program. The program may vary depending on the format of the incoming glRasterTriangleUID call that may change according to the current rendering state (see section 4.3 below). For example, if we are performing smooth shading with no texture mapping an ideal vertex program should look like this: !!ARBvp1.0 MOV result.position, vertex.position; MOV result.color, vertex.color; END However since Mesa returns vertices in window coordinates, vertex positions need to be translated to the device independent local coordinate system of the tile: !!ARBvp1.0 PARAM tzlt = {0.000000, -1024.000000, 0.0, 0.0}; PARAM scale = {0.002933, 0.001953, 9.313e-10,0.0}; PARAM sub = {-1.0, -1.0, -1.0, 1.0}; TEMP tmp; ADD tmp, tzlt, vertex.position; MAD result.position, scale, tmp, sub; MOV result.color, vertex.color; END</p><p>The vertex program is adjusted dynamically according to the position of the tile and the rendering state. The smallest vertex program that supports the necessary elements of the software vertex structure is selected. Once a vertex program is selected, the SPU stores software vertices in a vertex buffer and renders them via a call to glDrawArrays at the end of each frame or when a state change is detected.</p><p>Note that it is not strictly necessary to use a vertex program to perform the functionality implemented by the glRasterTriangleUID call. The OpenGL library can be configured not to perform geometric transformations and lighting. Using a vertex program, however, is convenient in that a vertex program can easily be swapped for another as the state changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">State Tracking</head><p>Chromium performs state tracking as an optimization to reduce the number of state changes transmitted over the network. The state tracker available in Chromium assumes coupled geometry and rasterization pipelines; therefore, the tracker keeps track of rendering states irrespective of the pipeline stage a state change may affect. In sort-middle the geometry and rasterization stages are uncoupled, therefore, this state tracker is not optimal for our use. For this reason, we implement a new state tracking technique that tracks only state changes that affect the rasterization portion of the graphics pipeline. State tracking for the geometric portion of the pipeline is unnecessary because communication occurs after the geometric portion of the pipeline is complete. Our state tracking technique not only helps to reduce state changes transmitted through the network, but also helps identify which portions of the software vertex structure must be transmitted. This is illustrated in <ref type="table" target="#tab_4">Table 1</ref>. Here, the first column describes the state; the second column describes the portions of the software vertex structure that must be transmitted; and the third column describes the cost in bytes for transmitting the   data. Note that different states require different numbers of bytes per vertex to be transmitted to a Render PC. The best case is illustrated in <ref type="table" target="#tab_4">Table 1</ref> where simple smooth shading requires only 16 bytes of data per vertex. The worst case involves a combination of multi-texturing, fog, and other rendering capabilities that require a larger version of the vertex structure to be transmitted. The sort-middle state tracker (built into the geometry SPU) reduces the network load by determining the minimal amount of data that must be transmitted to the rasterization servers for any particular rendering state. A rendering application may aid the state tracker in achieving this goal by providing it with hints via the glHint call. These hints may suggest instances where image quality may be sacrificed or instances where work that would otherwise be computed at a rasterization server, should be computed locally. Perspective correction of texture coordinates is one such example. Perspective correction typically occurs during the rasterization process before the interpolation of colors and texture coordinates. OpenGL provides a hint (GL_PERSPECTIVE_CORRECTION_HINT) that lets the implementation know whether or not to perform this correction. We extend the hint to let the state tracker know that it should perform perspective correction of texture coordinates before transmitting them to a rasterization server. By doing this, we can avoid transmitting the w coordinates that are needed for the perspective correction process at a savings of 4 bytes per vertex.</p><p>When a state change affects only the rasterization portion of the pipeline, the state trackers for both sort-first and sort-middle are required to perform identical functions. An example of this occurs in state changes that affect texture mapping, since textures are utilized exclusively by the rasterization portion of the pipeline. In these cases, our state tracker makes calls to the sort-first state tracker instead of duplicating the same functionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTS AND RESULTS</head><p>We implement a parallel model viewer in C to view the test models illustrated in <ref type="figure" target="#fig_3">Figure 7</ref>. Our experimental cluster consists of four Apple PowerMac G5 computers. Two of the cluster nodes contain dual 2GHz CPUs with a 512KB L2 Cache per CPU, and 2.5 GB of main memory. The other two nodes contain a single 1.8GHz CPU that has a 512KB L2 Cache, and a 1.5 GB main memory. The systems use Mac OS X 10.3 and Chromium version 1.7. The ex-  periments use a gigabit ethernet network. The nodes are connected to a single gigabit switch that is in full-duplex mode. All experiments use a 2x2 tile arrangement with a total screen resolution of 2560x2048 (each tile is at a resolution of 1280x1024). The experiments compare the sort-middle approach to the sortfirst approach implemented via the tilesort SPU provided by the Chromium system. Each model illustrated in <ref type="figure" target="#fig_3">Figure 7</ref> is rendered using typical OpenGL commands in immediate-mode. For each of the models, the camera travels along a preset path in which the object is maintained in the center of the display.</p><p>The tilesort implementation allows the user a choice of several bucketing algorithms to determine how bounding boxes are sorted among Render PCs. To enhance the sort-first implementation the "Uniform Grid" algorithm is selected for the experiments. This algorithm is specially optimized for cases where the tiles form a regular grid with uniform column widths and row heights as is the case in our experimental system. As an additional enhancement, the vertex data in the models is preprocessed so that it is organized spatially and distributed evenly among the Control PCs.</p><p>In sort-middle, AltiVec is used to help optimize the geometric portion of the Mesa pipeline. We restrict all AltiVec optimizations to this pipeline and do not include any CPU specific optimizations in Chromium, the geometry SPU, or the georender SPU in order to insure a fair comparison with the tilesort SPU.</p><p>An overview of timing statistics generated by our experiments is illustrated in <ref type="table" target="#tab_5">Table 2</ref>. Here cluster arrangement (c) (see <ref type="figure" target="#fig_0">Figure 1</ref>) utilizes all four PCs in the cluster as both Render and Control PCs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Network Utilization</head><p>Efficient network utilization is extremely important in immediatemode cluster rendering since the network becomes the limiting bottleneck. <ref type="table" target="#tab_6">Table 3</ref> displays the total raw network utilization for different models using a single Control PC on a 2x2 tile arrangement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Network Utilization in Sort-First</head><p>As mentioned in section 3, the overlap factor is defined as a measure of the number of overlaps between bounding boxes as implemented in Chromium for sort-first. The consequence of this definition is that if the size of each bounding box is large (e.g., the size of the screen-space) then the number of possible overlaps between different bounding boxes is large. It is, therefore, evident that to reduce the overlap factor, the size of the bounding boxes must be minimized. To address this issue, we begin with a bounding box that encapsulates the entire object. Recursively a bounding box is subdivided into 8 smaller boxes. The process is illustrated in <ref type="figure" target="#fig_4">Figure  8</ref>; where, as the number of bounding boxes increase, their corresponding size decrease (this correlates directly to the overlap factor) <ref type="figure" target="#fig_6">Figure 9</ref> illustrates the effect on network utilization and frame rate as a function of number of bounding boxes. In one experiment, vertex data is organized spatially and distributed to Control PCs in sorted-segments to guarantee the spatial proximity of vertex data held in each Control PC. This increases the likelihood that a single Control PC communicates more often with a single Render PC. Note that the recursive bounding box algorithm does increase the frame rate for sort-first. On the other hand, as the number of bounding boxes increases beyond a certain limit the corresponding frame rate decreases. This can be explained from the data transfer overheads associated with each smaller bounding box. First as the bounding boxes become smaller, the number of glBegin and glEnd statements that encapsulates the primitives increases with increasing numbers of bounding boxes. Second with less primitives encapsulated within each bounding box, more global state information is duplicated across the bounding boxes. In a second experiments, the primitives are selected in a round-robin fashion. This selection process tends to randomize the primitives and increase the spatial distance between primitives. In order to encapsulate these primitives within the bounding box, the algorithm automatically increases the size of the bounding box to accommodate all primitives assigned to it. The effect of the round-robin scheduling is to counter act the benefits of creating smaller bounding boxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Network Utilization in Sort-Middle</head><p>In sort-middle, the determination of which primitive overlaps with which tile or tiles occurs for each triangle. Here, the overlap factor is a function of the size of individual primitives on the screen, Molnar et al. <ref type="bibr">[1994]</ref>. An important difference between sort-first in Chromium and the sort-middle approach is that sort-middle does not require the use of bounding boxes. For this reason <ref type="figure" target="#fig_6">Figure 9</ref> indicates a constant network utilization for sort-middle. Note that the sort-middle network utilization is drawn as a straight line for comparison purposes only with sort-first. In the sorted-segments experiment, organizing vertex data spatially does not affect the amount of network utilization in sort-middle when compared to the roundrobin approach. However, the sorted-segments scheduling does benefit the frame rate for sort-middle because data organization insures less network contention for individual tiles.</p><p>It is important to note that the sort-first technique compares favorably to sort-middle for a specific range of bounding boxes. In general it is difficult for a sort-first implementation to determine the    level of recursion required for the optimal bounding box size. For sort-middle this is not an issue.</p><p>Besides maintaining a low overlap factor there are two other reasons why sort-middle utilizes less network bandwidth. First, sortmiddle requires less data to be transmitted. This occurs because a large number of state changes affect only the geometric portion of the pipeline. For example, it is not necessary to transmit setup commands for the model/view matrix. It is also not necessary to transmit vertex normals. Second, calls to glRasterTriangleUID provide a level of compression for GL commands. First, because glRasterTriangleUID does not need to be surrounded between glBegin and glEnd statements and second because all data related to a triangle (i.e. vertex coordinates, texture coordinates, and colors) are transmitted within a single call. In contrast, sort-first transmits vertex data via individual calls to glVertex, glColor and so on.</p><p>As an example of these network savings, a comparison is made between sort-first and sort-middle for the transmission of a single triangle sent to a Render PC. If we assume that no vertex arrays are used, a triangle in OpenGL is typically generated via six (6) calls, three (3) to glVertex3f and three (3) to glNormal3f. In sortfirst, each call is packed using 13 bytes of data <ref type="bibr" target="#b3">[4]</ref> that includes one byte for each opcode (that identifies the call) and 12 bytes for the call's parameters. Thus, a total of 78 bytes are needed for the transmission.</p><p>In sort-middle, however, a single call to glRasterTriangleUID is packed. The call contains three (3) vertices each containing a vertex position (12 bytes) and a color (4 bytes). Additionally, we require a 5 byte opcode since glRasterTriangleUID is an extended call. Thus, a total of 53  bytes are needed to transmit the same triangle in the sort-middle as in sort-first at a savings of 25 bytes. An additional savings of 4 bytes can be gained if glRasterTriangleUID is made a standard call rather than an extended one, though this is not done in our experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Backfacing Polygons</head><p>Sort-middle can identify back-facing polygons before they are transmitted to a Render PC. In cases where back-facing primitives are not of interest, this feature provides an optimization for reducing network requirements. As illustrated in <ref type="table" target="#tab_8">Table 4</ref>, this optimization has the positive effect of reducing network traffic by about a half.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FUTURE WORK</head><p>In sort-middle we must perform triangulation of primitives such as GL_POLYGONs and GL_QUADS before we transmit them. Thus, from a network utilization standpoint, there is no benefit to uti-lize primitives other than GL_TRIANGLES in sort-middle. This is not the case in sort-first. By utilizing primitives such as GL_QUADS and GL_TRIANGLE_STRIPs, sort-first may reduce the total number of vertices that must be transmitted over the network. We define the triangulation ratio as the ratio of GL primitives to the triangles generated during the triangulation of those primitives. The triangulation ratio is similar to the tessellation ratio as defined by <ref type="bibr" target="#b10">Molnar et al. [1994]</ref>. When the triangulation ratio is greater than one, sortmiddle will transmit a greater number of vertices than sort-first. We plan to study the effects of the triangulation ratio on network utilization and frame rates in sort-middle. We further plan to study the impact of the triangulation ratio on the frame rates for both sort-first and sort-middle. In <ref type="figure" target="#fig_6">Figure 9</ref>, the level of bounding box recursion for sort-first achieved comparable frame rate performance as sort-middle. However, as the cluster size and the resolution of the image increases, the optimum level of recursion for sort-first may not be reached before the network is overwhelmed and drastically degrades in performance. For this reason, we plan to provide a more thorough analysis of sort-middle and sort-first on a larger multi-projector system in order to provide a comparative study of their scalability properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">SUMMARY AND CONCLUSION</head><p>We describe an alternative method of performing immediate-mode rendering in the Chromium system. The method utilizes a sortmiddle approach rather than the sort-first approach currently implemented as a default in Chromium. A major problem with performing immediate-mode rendering in Chromium (and stream based systems in general) is that primitives must be transmitted at every frame, thus, the network requirements for immediate-mode rendering are very high. The main advantage of sort-middle approach is that it requires significantly less data to be transmitted per frame. Though it is possible in sort-first to reduce network usage (via Chromium's bounding box extension) and achieve frame rates comparable to those attained by our approach, doing so is not trivial. Nominally this would involve modification of the application source to organize vertex data in a spatially contiguous way to reduce the overlap factor. Unlike sort-first, our approach achieve fast rates without source modification. In such cases, twice the frame rates are observed even if the source to the application is not available.</p><p>Finally, an additional advantage sort-middle provides over sortfirst is the need to track only those state changes that affect the rasterization portion of the rendering pipeline. This results in a further reduction in complexity over sort-first.</p><p>In this paper, we demonstrated the feasibility of implementing a sort-middle approach on a cluster of PCs. The sort-middle approach provides load balancing at the geometry level and consequently a reduction in network traffic over sort-first in immediate-mode. In addition the splitting of the geometry/rasterization pipelines introduces the potential for a more scalable graphic rendering system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Typical cluster arrangements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(a) and (b) a single Control PC IEEE Visualization 2005 October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Sort-Middle Software Vertex the pipeline for most rendering calls. Calls that do not directly interact with the geometry stage such as glClear are not affected. The triangle-rasterize call takes the results of the geometric portion and allows the data to be rasterized. The results of the geometric portion of the pipeline are returned as a series of software vertex structures as defined in Figure 5. Three software vertices are returned for every triangle in the scene. The software vertex structure is compatible with the internal structure utilized by Mesa's</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Test Models. (a) Low Resolution Bunny (944 Triangles), (b) High Resolution Bunny (69, 451 Triangles), (c) Low Resolution Dragon (11,102 Triangles), (d) High Resolution Dragon (871, 414 Triangles). Mod el Sor t -Fir s t Sor t -Mid d le Low Res Bu n n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Bounding boxes created at at 1-6 levels of recursion running under the tilesort SPU.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Total network utilization and time statistics at various bounding box recursion levels for the model inFigure 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>describe the implementation of such a system and analyze its performance under various tiling</figDesc><table><row><cell>Application</cell><cell></cell><cell></cell></row><row><cell>Tilesort</cell><cell>Chromium Server Readback Send</cell><cell></cell></row><row><cell>Tilesort Tilesort Application Application Application</cell><cell>Readback Send Chromium Server Readback Send Chromium Server</cell><cell>Chromium Server Render</cell></row><row><cell>Tilesort</cell><cell></cell><cell></cell></row><row><cell cols="3">Figure 2: Chromium Sort-First example setup.</cell></row><row><cell></cell><cell>Application Readback Send</cell><cell></cell></row><row><cell></cell><cell></cell><cell>Chromium Server Render</cell></row><row><cell></cell><cell>Application Readback Send</cell><cell></cell></row><row><cell></cell><cell>Application Readback Send</cell><cell></cell></row><row><cell cols="3">Figure 3: Chromium Sort-Last example setup.</cell></row><row><cell cols="3">algorithms. WireGL [5] is a similar system with additional support</cell></row><row><cell cols="3">for retained-mode rendering that is achieved by distributing display</cell></row><row><cell cols="3">lists as described above. It also provides an implementation of the</cell></row><row><cell cols="3">OpenGL extensions proposed by Igehy et al. [1998] that add syn-</cell></row><row><cell cols="3">chronization primitives such as semaphores and barriers to insure</cell></row><row><cell cols="3">the correct executing order of graphics commands at their destina-</cell></row><row><cell cols="3">tion PC. WireGL also introduces an optimization (state tracking) to</cell></row><row><cell cols="3">reduce OpenGL state changes transmitted over the network. This is</cell></row><row><cell cols="3">done by utilizing a protocol similar to the one proposed by Buck et</cell></row><row><cell cols="3">al. [2000]. WireGL is extended to form Chromium</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Examples of raw data transmission sizes per rendering state in bytes.</figDesc><table><row><cell></cell><cell>Pa ra llel</cell><cell></cell><cell></cell></row><row><cell>Mod el</cell><cell>Algorit h m</cell><cell>FPS</cell><cell>Sp eed u p</cell></row><row><cell>Low Res Bu n n y</cell><cell>Sort -Fir s t</cell><cell>1 4 0 .8 6</cell><cell></cell></row><row><cell></cell><cell>Sort -Mid d le</cell><cell>2 3 3 .9 7</cell><cell>1 .6 6</cell></row><row><cell>High Res Bu n n y</cell><cell>Sort -Fir s t</cell><cell>6 .6 7</cell><cell></cell></row><row><cell></cell><cell>Sort -Mid d le</cell><cell>1 3 .8 3</cell><cell>2 .0 7</cell></row><row><cell>Low Res Dr a gon</cell><cell>Sort -Fir s t</cell><cell>3 5 .2</cell><cell></cell></row><row><cell></cell><cell>Sort -Mid d le</cell><cell>7 6 .7 9</cell><cell>2 .1 8</cell></row><row><cell>High Res Dra gon</cell><cell>Sort -Fir s t</cell><cell>0 .5 8</cell><cell></cell></row><row><cell></cell><cell>Sort -Mid d le</cell><cell>1 .5</cell><cell>2 .5 9</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Timing statistics in frames per second and speedup.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 :</head><label>3</label><figDesc>Total network utilization for a single frame in kilobytes.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Effects of removing back-facing triangles on total network utilization for a single frame in sort-middle. Utilization in kilobytes.</figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tracking graphics state for network rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIG-GRAPH/Eurographics Workshop on Graphics Hardware</title>
		<meeting>SIG-GRAPH/Eurographics Workshop on Graphics Hardware</meeting>
		<imprint>
			<date type="published" when="2000-08" />
			<biblScope unit="page" from="87" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Data distribution strategies for high-resolution displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuqun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiyan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudrajit</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grant</forename><surname>Wallace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="811" to="818" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Software environments for cluster-based display systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuqun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Douglas</forename><forename type="middle">W</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiyan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grant</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First IEEE/ACM International Symposium on Cluster Computing and the Grid</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A Stream Processing Approach to Interactive Graphics on Clusters of Workstations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Humphreys</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Wiregl: A scalable graphics system for clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gordon</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Everett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 2001</title>
		<meeting>SIGGRAPH 2001</meeting>
		<imprint>
			<date type="published" when="2001-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Chromium: A stream processing framework for interactive graphics on clusters of workstations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ren</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Ahern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randall</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 2002)</title>
		<meeting>SIGGRAPH 2002)</meeting>
		<imprint>
			<date type="published" when="2002-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="693" to="702" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The design of a parallel graphics interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Igehy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">Silicon Graphics Inc. Onyx2 reality, onyx2 infinitereality and onyx2 infinitereality2 technical report</title>
		<imprint>
			<date type="published" when="1998-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Distributed multihead x design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">E</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">H</forename><surname>Dawes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rickard</forename><forename type="middle">E</forename><surname>Faith</surname></persName>
		</author>
		<ptr target="http://dmx.sourceforge.net/dmx.html" />
		<imprint>
			<date type="published" when="2003-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Non-invasive, interactive, stylized rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Mohr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Gleicher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="2001-03" />
			<biblScope unit="page" from="175" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A sorting classification of parallel rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Ellsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Algorithms</title>
		<imprint>
			<biblScope unit="page" from="23" to="32" />
			<date type="published" when="1994-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Infinitereality: A real-time graphics system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">S</forename><surname>Montrym</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">R</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">J</forename><surname>Migdal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIG-GRAPH 1997</title>
		<meeting>SIG-GRAPH 1997</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Non-invasive interactive visualization of dynamic architectural environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Niederauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maneesh</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Humphreys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 Symposium on Interactive 3D Graphics</title>
		<meeting>the 2003 Symposium on Interactive 3D Graphics</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="55" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The mesa 3d graphics library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Biran</forename><surname>Paul</surname></persName>
		</author>
		<ptr target="http://www.mesa3d.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Dynamic algorithms for sorting primitives among screen-space tiles in a parallel rendering system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudrajit</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Funkhouser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<pubPlace>Princeton University</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Load balancing for multi-projector rendering systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudrajit</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiannan</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaswinder Pal</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/SIGGRAPH Workshop on Graphics Hardware</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A survey and performance analysis of software platforms for interactive cluster-based multi-screen rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">G</forename><surname>Staadt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Justin</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chhristof</forename><surname>Nuber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IPT/EGVE 2003</title>
		<meeting>IPT/EGVE 2003</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-05" />
			<biblScope unit="page" from="261" to="270" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
