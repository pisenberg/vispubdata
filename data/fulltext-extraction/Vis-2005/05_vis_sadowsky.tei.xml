<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rendering Tetrahedral Meshes with Higher-Order Attenuation Functions for Digital Radiograph Reconstruction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ofri</forename><surname>Sadowsky</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Russell</forename><forename type="middle">H</forename><surname>Taylor</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Rendering Tetrahedral Meshes with Higher-Order Attenuation Functions for Digital Radiograph Reconstruction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>volume rendering</term>
					<term>unstructured grids</term>
					<term>projected tetrahedra</term>
					<term>DRR</term>
					<term>higher-order volumetric functions</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents a novel method for computing simulated x-ray images, or DRRs (digitally reconstructed radiographs), of tetrahedral meshes with higher-order attenuation functions. DRRs are commonly used in computer assisted surgery (CAS), with the attenuation function consisting of a voxelized CT study, which is viewed from different directions. Our application of DRRs is in intra-operative &quot;2D-3D&quot; registration, i.e., finding the pose of the CT dataset given a small number of patient radiographs. We register 2D patient images with a statistical tetrahedral model, which encodes the CT intensity numbers as Bernstein polynomials, and includes knowledge about typical shape variation modes. The unstructured grid is more suitable for applying deformations than a rectilinear grid, and the higher-order polynomials provide a better approximation of the actual density than constant or linear models. The intra-operative environment demands a fast method for creating the DRRs, which we present here. We demonstrate this application through the creation and use of a deformable atlas of human pelvis bones. Compared with other works on rendering unstructured grids, the main contributions of this work are: 1) Simple and perspectivecorrect interpolation of the thickness of a tetrahedral cell. 2) Simple and perspective-correct interpolation of front and back barycentric coordinates with respect to the cell. 3) Computing line integrals of higher-order functions. 4) Capability of applying shape deformations and variations in the attenuation function without significant performance loss. The method does not depend on for preintegration, and does not require depth-sorting of the visualized cells. We present imaging and timing results of implementing the algorithm, and discuss the impact of using higher-order functions on the quality of the result and the performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>DRR (digitally reconstructed radiograph) generation is a volume rendering technique that simulates the x-ray imaging process by computing integrals of a volumetric attenuation function along the lines of sight. DRRs are commonly used in computer assisted surgery (CAS), with the attenuation function consisting of a voxelized CT study, which is viewed from different directions. An example application of DRRs is intra-operative "2D-3D" registration, i.e., finding the pose of the preoperative CT dataset given a small number of patient radiographs (target images), each with a known projection model, by maximizing the similarity between the target * e-mail: ofri,cohen,rht@cs.jhu.edu images and DRRs generated dynamically from the CT study. In the surgical setup, a fast registration method is critical.</p><p>This paper presents a novel algorithm for generating DRRs of a tetrahedral mesh. Each cell contains a representation of the local values of the attenuation function as a higher-order Bernstein polynomial in barycentric coordinates. This algebraic representation yields a closed formula for computing the line integrals of the function. Our algorithm, based on the Projected Tetrahedra (PT) algorithm by Shirley and Tuchman <ref type="bibr" target="#b12">[13]</ref>, correctly interpolates the parameters of the integral formula, and uses the GPU fragment processors to compute it for each fragment.</p><p>The paper is organized as follows. Section 2 presents the context of this work in the frame of CAS and compares our work with related works on rendering unstructured grids. Section 3 presents the mathematical formulation of our algorithm, and explains the details of its implementation. Section 4 shows results of rendering experiments using the algorithm. We discuss the meaning of the results and potentials for future work on the algorithm in Section 5, and conclude in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>This work was developed in the context of a statistical atlas of bone anatomy, continuing the work of Yao <ref type="bibr" target="#b17">[18]</ref>. In his work, Yao represented the shape of the bone as a tetrahedral mesh, and the attenuation function as barycentric Bernstein polynomials for each cell of the mesh. We follow this representation in the current work.</p><p>One goal of the statistical atlas was to provide a model for deformable 2D-3D registration between actual x-ray images of a patient and dynamic DRRs of the statistical atlas. Yao implemented a DRR generator which used a numerical approximation of the integrals as sums of discrete samples of the attenuation function along the line of sight, in a manner similar to ray tracing. However, the use of polynomials provides a closed formula for the line integrals over the line segment that intersects a tetrahedron. Our work uses this formula for a more efficient and accurate computation of the DRR images.</p><p>The Projected Tetrahedra (PT) algorithm, presented by Shirley and Tuchman <ref type="bibr" target="#b12">[13]</ref>, is the basis to many works on rendering unstructured grids. The paper starts with a method to decompose a rectilinear voxel grid to a tetrahedral mesh. The rendering of individual tetrahedra is done by breaking them further into three or four triangular facets (tessellation), which are sent to the rendering pipeline. The integrand function is constant per cell (piecewise constant), and the thickness interpolation is linear, which is correct only under orthographic projection. Depth sorting is required as well. These weaknesses in the original PT algorithm call for the improvements that followed.</p><p>Wylie et al. <ref type="bibr" target="#b16">[17]</ref> implemented the PT tessellation algorithm using a GPU vertex shader. They report that their performance results were limited by the capacities of the graphics hardware at the time. They still use linear interpolation of the thickness property, which assumes an orthographic projection model.</p><p>A number of volume rendering methods use precomputed line integrals to accelerate the rendering. So-called "light field" meth-Please see supplementary material on conference DVD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Visualization 2005</head><p>October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE. ods <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref> are one set of examples. In the particular context of DRRbased registration, LaRose <ref type="bibr" target="#b5">[6]</ref>  <ref type="table">presented a rendering method that  uses a 4-dimensional array, indexed by pairs of planar coordinates,  as a lookup table for fetching integral values. The method renders  a full voxelized dataset by using the intersections of lines of sight  with the volume boundary as the lookup table indexes. Röttger et</ref> al. <ref type="bibr" target="#b10">[11]</ref> use precomputed integrals to render a tetrahedral mesh. The rendered function is piecewise linear, and includes color, attenuation, and emission. Under an orthographic projection model, they interpolate the intersection points of each tetrahedron with the lines of sight, and use a resulting triad of coordinates as an index to a 3D texture, i.e., a lookup table, to fetch the precomputed integral.</p><p>Weiler, Kraus, and Ertl <ref type="bibr" target="#b14">[15]</ref> compute the entry and exit point of the ray to and from the cell under perspective projection by solving line-plane-intersection equations, a method also adopted by Moreland and Angel <ref type="bibr" target="#b8">[9]</ref>. The main drawback of this method was that it was too complex to implement on a GPU fragment unit. Kraus et al. <ref type="bibr" target="#b4">[5]</ref> followed by presenting a method to interpolate the thickness and intersection points under a perspective projection model, still using pre-integration. Their per-vertex data includes two sets of coordinates, for the front and back sides of the facet, which are interpolated on the GPU.</p><p>Many of the works cited above require depth sorting of the cells, using methods such as <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b1">2]</ref>, because the volumetric function includes emission, which is attenuated only by cells lying in front of the current cell. The model of the rendered function in our paper is simpler than in some of these works, as it includes only attenuation and no emission or color. This is because we model x-ray imaging. However, the function is piecewise polynomial, which generalizes the linear model to a higher degree, and allows a compact approximated representation of complicated structures. Our algorithm is based on the PT tessellation, and improves the PT algorithm to interpolate the parameters required for evaluating the integral formula. The meshes we used were generated automatically from labeled images using an algorithm developed by Mohamed <ref type="bibr" target="#b7">[8]</ref>, yet our algorithm does not depend on the specific mesh generation method.</p><p>Compared to the works cited above on rendering unstructured grids, the main contributions and features of our algorithm are:</p><p>1. Simple and perspective-correct interpolation of the thickness of a tetrahedral cell (alternative to <ref type="bibr" target="#b4">[5]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Simple and perspective-correct interpolation of front and back</head><p>barycentric coordinates with respect to the cell (compared to actual position in <ref type="bibr" target="#b4">[5]</ref>). 3. Computing line integrals of higher-order functions. 4. Capability of applying shape deformations and variations in the attenuation function without significant performance loss. 5. No need for pre-integration. <ref type="bibr" target="#b5">6</ref>. No need for depth-sorting of the visualized cells.</p><p>These properties are especially important within the context of deformable "2D-3D" registration of x-rays to generic anatomical templates. The last property results from the cumulative nature of the attenuation model, which enables us to use OpenGL blending for summing up the results into a high-dynamic-range frame buffer. We currently implement the PT tessellation to run on the CPU, but the algorithm we propose may be usable in conjunction with a GPU vertex program such as Wylie's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Background</head><p>Our imaging model is based on the attenuation formulas known as Beer's law. For a point p in space, the x-ray flux I out leaving in a certain direction is equal to α(p) • I in for the same direction, with 0 ≤ α(p) ≤ 1. Along a parametric line p(t), the overall attenuation of energy is henceforth given by the formula</p><formula xml:id="formula_0">I out = I in • e − 1 0 µ(p(t))dt (1)</formula><p>where µ(p) = − ln α(p) is called the linear attenuation coefficient.</p><p>The volumetric attenuation function in our project is represented by a tetrahedral mesh with barycentric Bernstein polynomials encoding the local density in each cell. For a tetrahedral cell T j , the structure of the polynomial is</p><formula xml:id="formula_1">f j (u) = ∑ |k|=d β j k B d k = ∑ |k|=d β j k d k u k 0 0 u k 1 1 u k 2 2 u k 3 3<label>(2)</label></formula><p>where</p><formula xml:id="formula_2">u = (u 0 , u 1 , u 2 , u 3 ) T are barycentric coordinates (u 0 + u 1 + u 2 + u 3 = 1) with respect to T j ; k = (k 0 , k 1 , k 2 , k 3 )</formula><p>is the power index of a term, with d = |k| = k 0 + k 1 + k 2 + k 3 being the degree;</p><formula xml:id="formula_3">d k = d! k 0 !k 1 !k 2 !k 3 !</formula><p>is a multinomial factor, resulting from the development of the Bernstein basis; and β j k is a free coefficient. Since the collection of barycentric Bernstein basis functions {B d k } is fixed, and the degree of the function is equal in all the cells in our model, we only need to store the free coefficients for each cell to recover the values of the attenuation function everywhere.</p><p>The transformations between Cartesian coordinates and barycentric coordinates with respect to T j are linear, and given by</p><formula xml:id="formula_4">p (h) = M (h) (T j )u, u = M (h) (T j ) −1 p (h)<label>(3)</label></formula><p>We use the subscript (h) to denote the straightforward conversion to homogeneous coordinates by adding 1 as a fourth component. p and u are Cartesian and barycentric coordinates, respectively. M (h) (T j ) is a 4 × 4 matrix, whose columns contain the (homogeneous) Cartesian coordinates of the vertices of the tetrahedron.</p><p>The DRR image of one tetrahedron is computed by taking the exponential of line integrals of the attenuation function. The final DRR image is computed by adding together the line integrals from all the tetrahedra, and taking the exponential of the sum. In this paper, we will regard the exponential taking as a post-processing step, which can be applied immediately before displaying or saving the image, and focus on computing and summing the integrals. The line integral of a single Bernstein basis function B d k (u) between the Cartesian points p 0 and p 1 , with corresponding barycentric coordinates u 0 , u 1 , is given by the formula</p><formula xml:id="formula_5">p 1 p 0 B d k (u)du = p 1 − p 0 1 0 B d k (u(t))dt = p 1 − p 0 d + 1 ∑ q k B |q| q (u 0 )B |k−q| k−q (u 1 ) (4)</formula><p>where u(t) = u 0 + t(u 1 − u 0 ). We use the notation q k to denote that q i ≤ k i for all i. Note that the integral is computed from the barycentric coordinates u 0 , u 1 , the degree d, and the length of the line segment p 1 − p 0 . These parameters will be required in our fragment program. We will refer to the product B</p><formula xml:id="formula_6">|q| q (u 0 )B |k−q| k−q (u 1 )</formula><p>as the inner low-order term product in the integration formula. The actual development of this formula is beyond the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Classifying and tessellating projected tetrahedra</head><p>As described in <ref type="bibr" target="#b12">[13]</ref>, the silhouettes of projected tetrahedra can be classified in four classes. Each class defines a tessellation of the silhouette into smaller facets, whose number is one to four. To simplify the analysis and the implementation (cf. <ref type="bibr" target="#b16">[17]</ref>), we use only two of these classes: three and four facets, as illustrated in <ref type="figure">Figure 1</ref>, and gather the degenerate cases into the three-facet class (a).</p><formula xml:id="formula_7">v 0 2 v 2 v 2 v v 1 3 v v 0 3 v v 1 3 v v 1 v 0 (b) 1 2<label>(</label></formula><p>The tessellation procedure involves the following steps:</p><p>1. Determine the class of the silhouette: triangle or quadrilateral.</p><p>2. Find the thick point, which will be a vertex shared among all the facets.</p><p>3. Compute the vertex attributes for the vertices of the facets.</p><p>To determine the class, we project all the vertices of the tetrahedron to the imaging plane, and then compute line intersections between three pairs of projected non-adjacent edges. The intersection may not exist if the shape happens to be a quadrilateral with parallel edges, but in the other cases it may occur inside or outside of an edge. We currently implement these tests in a CPU module, which allows for optimizations such as early exit. For example, if we find an intersection that is inside both edge projections, we determine that it's a quadrilateral, and skip the other tests.</p><p>After the case is determined, we reorder the vertices as in <ref type="figure">Figure  1</ref>. This simplifies the following steps in the algorithm, as we can apply a predefined set of operations on the vertices, and retain numerically consistent results. However, it is essential to keep track of the vertex permutation, since the barycentric coordinates and the polynomial terms are ordered based on the vertex order given originally in the mesh. For the simplicity of the discussion that follows, we will assume that no reordering is necessary.</p><p>For the thick point, we need to determine a front point f and a back point b (see <ref type="figure" target="#fig_1">Figure 2</ref>), which are both projected to the same point c on the image plane. In the triangle case, c coincides with the projection of v 0 , and f and b are either equal to v 0 or to a point on the opposite face F 0 , found by intersecting the line of sight of v 0 with the face F 0 . In the quadrilateral case, c is found by intersecting the edges between the projections of (</p><formula xml:id="formula_8">v 0 , v 2 ) and (v 3 , v 1 )</formula><p>, and then back-projected to a line of sight l c . The intersection of l c with (v 0 , v 2 ) in eye-space is the point f, and the intersection with</p><formula xml:id="formula_9">(v 3 , v 1 ) is the point b.</formula><p>Finally, we define the facets using the front thick vertex f and the outer vertices of the tetrahedron. In a triangle silhouette, the facets are: </p><formula xml:id="formula_10">(f, v 1 , v 2 ), (f, v 2 , v 3 ), (f, v 3 , v 1 ). In a quadrilateral, they are:(f, v 0 , v 1 ), (f, v 1 , v 2 ), (f, v 2 , v 3 ), (f, v 3 , v 0 ). F 0 v 0 b = f (a1) v 0 F 0 f b= (a2) v 0 v 2 (b) f b</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Vertex attributes, fragment attributes, and their interpolation</head><p>As noted in Equation <ref type="formula">4</ref>, computing the line integral for a given fragment, covered by a facet F j i of the tetrahedron T j , requires obtaining the barycentric coordinates u f and u b of the intersections between the line of sight and the front and back faces of T j , and the distance between these two intersection points. In this part, we derive formulas for simple per-fragment interpolation of these attributes from vertex attributes which are assigned to the facet. The final computation of the integral parameters is done in the fragment program.</p><p>We start by noting that as a by-product of computing the lineplane or line-line intersections for the points f and b we obtain the components of their barycentric coordinates: u(f) and u(b). They are included in the unknown variables of the intersection equations. We also use the fact that at the tetrahedral vertex v i the barycentric coordinate u i is 1, and the other three are zero, and that if a point is on the face F k , its barycentric coordinate u k is zero. Therefore, the tessellation algorithm already gives all the attributes needed to interpolate the barycentric coordinates. Next, we show how these are interpolated per fragment.</p><p>Front barycentric coordinates u f . Given the front barycentric coordinates at the vertices of the facet, the coordinates at the fragment are obtained by a simple linear interpolation. Therefore, just by passing values of u f at the vertices as texture coordinates, we guarantee perspective-correct interpolation per fragment.</p><p>Back barycentric coordinates u b . Fragment attributes are interpolated based on the eye-space coordinates on the front side of the facet. Therefore, we have to base the interpolation of the back side barycentric coordinates on an attribute of the front side. Let F b be the back side of F j i , defined by the vertices (b 1 , b 2 , b 3 ). Let F f be the front side for the same facet. A point x ∈ F b can be expressed using the convex combination of the vertices:</p><formula xml:id="formula_11">x = b 1 b 2 b 3 (w 1 , w 2 , w 3 ) T = M F b w F b (x) w F b (x) = M −1 F b x<label>(5)</label></formula><p>with |w F b (x)| = w 1 + w 2 + w 3 = 1. Note that w F b (x) contains the nontrivial barycentric coordinates of x on the face F b , i.e., those components which are not trivially zero.</p><p>If y ∈ F f is given in eye-space coordinates, the point on F b which is projected on y is x = sy for some s &gt; 1. The nontrivial barycentric coordinates of x are: The last equality uses the notation y = M F f w F f (y), following similar convention as in <ref type="bibr" target="#b4">(5)</ref>.</p><formula xml:id="formula_12">w F b (x) = M −1 F b x = sM −1 F b y = sM −1 F b M F f w F f (y) (6) d n d y n b 1 v p θ<label>(</label></formula><p>Let w = M −1 F b y. We know that w F b (x) = sw , and that |w F b (x)| = 1. Therefore, w F b (x) = w /|w |, and s = |w| −1 .</p><p>We now observe that M F b and M F f are constant per facet, and that w is a linear transformation of w F f (y), which in turn contains the nontrivial elements of u f . Therefore, if we determine the values of w at the vertices of the facet, we can interpolate it linearly in the same fashion as u f . We already know that all the coordinates but one vanish at the outer vertices of the facet. All that is left for our vertex processing algorithm is to find u , obtained from w by adding the trivial barycentric coordinate u b = 0, at the thick vertex and pass it as a second texture coordinate vertex attribute. The fragment program code only needs to normalize it. <ref type="bibr" target="#b0">1</ref> Thickness interpolation. From the above discussion, we can derive directly a simple expression for the thickness of the tetrahedron at the fragment, or the distance between front and back intersection points. Let us send y, the eye-space position, as a vertex attribute that is interpolated for the fragment. We already obtained the interpolated u , and computed s = |u | −1 . Following this, we can find x = sy, and the thickness is</p><formula xml:id="formula_13">d y = x − y<label>(7)</label></formula><p>Figure 3 illustrates a second method of interpolating the thickness, which does not depend on the barycentric coordinates, and is currently used in our program. It uses the position y and the unitlength normal n b of the back face. For any set of parallel lines (such as the lines of sight in an orthographic projection), the distance between the front and back intersection points is interpolated linearly on the facet. Therefore, we can compute the distance d n along n b from the thick vertex f to F b , send it as a vertex attribute, and linearly interpolate it between f and the outer vertices, where it is zero. The line-of-sight distance is now</p><formula xml:id="formula_14">d y = d n (y) cos θ<label>(8)</label></formula><p>where θ is the angle between the line of sight and n b . In practice, we don't need to compute θ directly, as we observe that cos θ = −y•n b y .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The final integral formula</head><p>The final line-integral formula, developed from (2), must include the coefficients of all the terms:</p><formula xml:id="formula_15">1 0 f j (u(t))dt = ∑ |k|=d β j k 1 0 B d k (u(t))dt (9)</formula><p>Our implementation of the fragment program uses texture memory to store the coefficients. We send the index j of the current cell along with the facet data, and the fragment program uses it to determine the coordinates of the texels that contain the coefficients. We use 32-bit floating point numbers for the coefficients, and we can store up to four coefficients in each texel (using the color channels). The total number of coefficients for a barycentric Bernstein polynomial f of degree d with n variables is n f = n+d−1 n−1 . In our case, n = 4 and so n f = d+3</p><p>3 . For d = 0, 1, 2, 3, we have n f = 1, 4, 10, 20 respectively. We map j to a consecutive set of texels, and the fragment program makes n t = n f 4 texture-read operations. Polynomials of different degrees have different integral formulas, and require a different number of coefficients. To accomplish this, we generate the code of the fragment program on the fly, during the initialization of the application after the mesh data has been read. Our algorithm enumerates all the basis functions {B d k }, and for each one expands the expression for the low-order term product in (4), then multiplying the sum of products by the corresponding coefficients, line length, and (d + 1) −1 (which is a hard-coded constant in the fragment program). The final fragment program evaluates the integral as an expression without any looping, branching, or conditional evaluation.</p><p>Advanced graphics hardware features. The input CT data is given in CT numbers, which are integers between 0 and 4095. The coefficients of the polynomials, which approximate these numbers, are on a similar scale. Therefore, we need more than 8 bits for each coefficient in the texture. We are currently using 32-bit floats as texture elements. In addition, the final output has a dynamic range on the order of 10 5 , which again requires a high-dynamic-range frame buffer. Currently, we are using 16-bit floating point pbuffer as the rendering context. This does not capture the full dynamic range of the output, since a 16-bit float uses 5 bits for the exponent, which can encode values up to the order of 2 <ref type="bibr" target="#b15">16</ref> . 32-bit pbuffers, on the other hand, do not support OpenGL blending operations. Blending is essential for fast accumulation of the integral values from different tetrahedra. We tried other methods for accumulating the results, such reading the old value at the pixel to the fragment program, adding the new integral and writing the result back to the pixel, but this slows down the program significantly.</p><p>To answer the dynamic range problem, we scale the model to a bounding box whose maximal edge length is 2 (from -1 to 1), and scale and biasing the coefficients to a range between 0 and 1, before the rendering begins. The effect of the geometry and coefficient scaling is a linearly proportionate scaling in the magnitude of the integrals. The effect of the coefficient bias is adding the bias multiplied by the thickness of the mesh along the line of sight to the final integral. This means that we have to accumulate the thickness d y in addition to the integral values. We do this by outputting d y through the alpha component.</p><p>After reading the pbuffer content, we re-adjust the numbers for the scale and bias that we had performed to get the actual integral values back. The scale and bias technique can also assist in displaying the image on a limited-dynamic-range monitor.</p><p>For fast data exchange between the main program and the GPU, we are using a vertex-buffer object (VBO) to write the vertex attribute to the GPU, and a pixel-buffer object to read back the results.  <ref type="table">Table 1</ref>: Dynamic ranges in <ref type="figure" target="#fig_4">Figure 4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Algorithm summary</head><p>To summarize this section, let us review the inputs and outputs of the fragment program. x − y .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTS AND RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Comparison with a voxelized dataset</head><p>Our mesh structure is generated from a segmented CT dataset, using an algorithm developed by Mohamed <ref type="bibr" target="#b7">[8]</ref>. The density functions are obtained by fitting polynomials to the CT intensity numbers in the space of each cell. Naturally, one wishes to compare images rendered from our mesh with images rendered from the voxelized CT dataset. However, a meaningful numerical comparison of the methods is difficult to achieve. The reasons are, first, that the topology and geometry of the two data sources are different. Specifically, the shape of the boundary of the object is different when the object is discretized as a tetrahedral mesh and as a rectilinear grid. Therefore, we should expect larger-scale differences near the object boundary when we compare the two representations. Second, the quality of approximation in the mesh representation of the CT study depends highly on the resolution (cell size) of the mesh and on the complexity (i.e., degree) of our density functions. Before comparing DRR results, we should ask how close our model is to the "ground-truth" CT, and this is beyond the scope of this paper. In spite of these issues, we can provide a qualitative idea of the similarity between images of our mesh and DRRs projected from a CT study. To do this, we first use the geometry of the mesh as a binary mask to filter out all the CT voxels that are not covered by the mesh. This approximates the object shape as equally as we can in the two representations. We create DRRs of the segmented CT using the Take package <ref type="bibr" target="#b9">[10]</ref>, and images of the mesh in equivalent camera poses. We can then compare these image sets.  <ref type="figure" target="#fig_4">Figure 4</ref> shows an example of such a comparison. We used a model of the pelvis bone, with 14,375 vertices and 52,837 tetrahedra, and 3 rd order density polynomials, shown as (b), and compare it with the segmentation of the CT study that produced the mesh (a). The visual differences between the two DRRs are small. A difference image (c) shows that the main differences lie near the object boundaries. Details about the dynamic range of these images are summarized in <ref type="table">Table 1</ref>.</p><p>We are using a pixelwise relative error measure, defined as E(p) =</p><formula xml:id="formula_16">I Model (p)−I CT (p) I Model (p)+1</formula><p>(we add 1 at the denominator to prevent division by zero). Image (d) shows as black pixels the locations where |E(p)| ≥ 0.05. As we can see, the relative error in most of the image area is less than 5%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Performance analysis and degree comparisons</head><p>To evaluate the performance of the algorithm, we tested the pelvis mesh with different density function degrees. We fit polynomials of degrees 0 to 4 to the cells of the mesh. The model was imaged twice over a camera trajectory of 25 frames in 9 • increments (a 216 • arc). The image size was 512 2 pixels. The performance results are summarized in <ref type="table" target="#tab_2">Table 2</ref>. All the timing experiments were performed on a dual Xeon PC, 2.80GHz CPU speed, with NVidia GeForce 6800 GT graphics card, and under Windows XP.</p><p>To understand the contribution of using higher-order polynomials to the DRR, we subtracted images of the mesh with degree d − 1 from images of degree d = 1, 2, 3, 4. An example of the difference images for the anterior-posterior (AP) view is in <ref type="figure" target="#fig_5">Figure 5</ref>. For a numerical comparison, we summarize the dynamic range of the 25 projections, the dynamic range of the difference I d − I d−1 , and the root of mean square difference (RMS) for all 25 projections as a single of pixels in <ref type="table" target="#tab_4">Table 3</ref>. As we can see visually and numerically, the differences are diminishing when the degree is increased. However, the dynamic range of the images increases with the degree, and begins to include negative values. These are likely to be the result of polynomial over-fitting.      </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Mesh deformations</head><p>The work presented in this paper is part of a project of creating a statistical atlas of bone anatomy. The atlas contains information about the typical (average) shape of a specific anatomy, and about typical variations in the shape. An important component in the statistical atlas project is the ability to use it in a 2D-3D registration framework, that is, match an observed set of 2D patient x-ray images with a pose and a shape of the statistical model. For this, we need an efficient tool for creating images of the deformed atlas, and comparing them with the patient images. We created a statistical atlas of the pelvis bone, which consists of a "master mesh" M 0 , created from a "master dataset" CT 0 . CT 0 is elastically registered to instance datasets {CT i } <ref type="bibr" target="#b11">[12]</ref>, and an equivalent deformation is applied to the vertices of M 0 to generate instance meshes {M i }. The final atlas is determined by the average vertex positions in the instance meshes, and by extracting deformation modes using PCA (cf. <ref type="bibr" target="#b0">[1]</ref>). In addition, we refitted the density polynomials for each instance dataset, and computed the average density function for the atlas. This process generally follows the atlas creation process described by Yao in <ref type="bibr" target="#b17">[18]</ref>.</p><p>The deformation modes resulting from the PCA are used as displacements that are applied in a linear combination to the vertices in the mean shape. If v j is the position of the j-th vertex in the mean shape, the deformed position is</p><formula xml:id="formula_17">p j (γ) = v j + n m ∑ k=1 γ k m k j</formula><p>where n m is the number of deformation modes; m k j is the displacement for the vertex v j given by the k-th mode; andγ = (γ 1 , . . . , γ n m ) are scalar weights of the deformation.</p><p>Our population currently consists of 6 subject datasets. The mesh includes 12,203 vertices and 44,151 tetrahedra, with 3 rd order density functions. The mean shape and some typical variations are shown in <ref type="figure" target="#fig_6">Figure 6</ref>.</p><p>The attached video shows an interactive interface for deforming the mesh. The user can select which deformation mode to activate, then drag the mouse up and down to apply a different magnitude of this mode. The atlas in the video includes two deformation modes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Usage in 2D-3D deformable registration</head><p>We have implemented a framework for 2D-3D registration between static target images and dynamic DRRs created from the atlas (model images). The registration algorithm searches for the maximum of a mutual information (MI) similarity measure between target and model images. The transformation parameters include translation, rotation, and shape deformation, which is implemented as a linear combination of displacements, as described above.</p><p>We ran a series of control experiments, with synthetic deformation modes and known transformations. In these, our registration framework recovered the parameters to a precision of about 0.01 millimeters in the translation, 0.01 • in the orientation, and 0.01 in the values of the displacement coefficients. In one example, we used two orthogonal views of size 256 2 , and a Downhill Simplex optimizer (taken from the vnl library <ref type="bibr" target="#b3">[4]</ref>). In each iteration, the optimizer generates two DRRs (which is the number of target images), reads back the data, and computes the MI similarity. The number of iterations was 328, and total time for registration was 233.219 seconds, or 355.5 ms/frame (with two frames rendered per iteration).</p><p>In another registration experiment, the atlas was created from a five-subject population, and the target images were generated from a sixth subject dataset, not included in the atlas. Our framework recovered a good approximation of the pose of the target dataset, but a less satisfying shape matching. A five-subject database is likely too small to cover the possible variability in human anatomy. Nevertheless, our 2D-3D registration framework, which uses the DRR algorithm seems to recover pose and shape to the best extent covered by the training data. Results of these studies will be published separately.</p><p>An example of the registration progress is shown in the attached video. The static target image is on the left in cyan, and the dynamic deformable model image is in red, shown overlaid on the target image and isolated on the right. The optimization first searches for a translation, then for a rotation, and then for a shape deformation. Then this sequence is repeated for fine tuning. A final part searches through all the parameters. A good registration is indicated by blending equal intensities of red and cyan into a gray result. The image on the right is shown for better tracking of the changes in the pose and shape of the model. It can be observed that after the first round of optimizations, we already have a fairly good registration, and the improvements of the second round are barely visible (see the acetabulum on the right side, and the top of the sacrum). Note that the video shows a time-compressed process, by a factor of about 15. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance and quality of the rendering</head><p>To analyze the results of the rendering algorithm, we need to consider both the execution time of the algorithm and the quality of the result. Observing the results in <ref type="table" target="#tab_2">Tables 2 and 3</ref>, we can draw the following notions.</p><p>• The computation time for the tessellation algorithm and vertex attributes is practically the same, regardless of the degree, as one may expect. • The size of the integral expression (9), which is proportional to the number of instructions in the fragment program (n i (d)), increases rapidly with the degree of the polynomial. We do not have yet an expression for the size of the formula, but at least in this data, it shows a trend of exponential growth: log(n i (d)) is approximately linear with respect to d. • The computation time on the GPU increases even more rapidly than the size of the fragment program. Note that this time includes access to texture memory, and the number of texture operations seems to have a significant impact on the performance. Between d = 0 and d = 1, there is hardly an increase in the GPU time, although the size of the program increases about 1.5 times. We believe this is affected by the single texture access, compared with the cubically increasing number of texture accesses required in higher degrees. An increased number of texture accesses creates potential for cache misses and for blocking between concurrent fragment programs trying to access the limited texture resource, both of which can slow down the process significantly. • The relative contribution of increasing the degree of the polynomial to the detail of the image diminishes, as can be seen in <ref type="figure" target="#fig_5">Figure 5</ref> and <ref type="table" target="#tab_4">Table 3</ref>.</p><p>These results suggest that we may need to modify our method if we want to develop an efficient rendering method for higher polynomial degrees. Several possible improvements are:</p><p>• Try to simplify and optimize the integral formula, for example by caching values of low-order terms from Equation (4). This requires a more sophisticated generator of the fragment program source code, and a better understanding of the structure of the formula. • Try other methods of passing the density coefficients, for example by using shared registers (Cg keyword uniform). Although loading the registers for every cell may take some time, this time may be saved when it comes to reading texture memory. Another option is to pass the coefficients through the vertex attributes, but then the number of coefficients and the degree of the polynomial are bounded by the number of available attribute registers, more memory is required per vertex, and more data needs to be sent to the rendering pipeline. We can also reduce the number of texels required for the coefficients by using fewer bits per coefficient. This is likely to reduce the problem of many texture reads, but is still a limited solution.</p><p>• Use more efficient per-vertex parameter passing, avoiding replications such as the back-face normal. It appears that these should have a minor effect compared to optimizations in the integral expression and texture access. • Encode the tessellation algorithm in a vertex program, following, for example, <ref type="bibr" target="#b16">[17]</ref>. If done properly, this can contribute to the speedup of the algorithm, but eventually the performance bottleneck of the integration should override the tessellation time.</p><p>• Balance the computational load between CPU and GPU. Currently, the CPU tessellation and the GPU rendering are done serially, but they may be done concurrently by proper adjustment and synchronization of the algorithm steps. With the current implementation of the integral formula, we can still parallelize these parts up to 3 rd order functions without an increase in processing time.</p><p>Our results suggest that in terms of precision, 3 rd order functions are probably sufficient for the models we tested, while not adding a heavy performance cost. However, the relation between the geometrical level of detail (that is, the number and size of the cells in the mesh), the degree of the polynomials, and the functional approximation level, which can be expressed as the difference between the intensity values in a CT study and the values predicted by our model, requires further study. Other uses of the statistical atlas, such as approximated tomographic reconstruction, may dictate more constraints on the level of detail we can use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Deformations, intensity variations, and registration</head><p>In the current implementation of our algorithm, applying a deformation to the mesh takes practically no toll on the performance, as can be seen in the results. However, if we choose to implement the tessellation algorithm as a vertex program, we should adopt a new strategy in applying the deformation. For example, we may store all the deformation modes on GPU buffers, and have a two-pass vertex processing method: The first pass computes a linear combination and outputs deformed vertex positions. The second pass performs the tessellation.</p><p>Applying variations in the density properties of the mesh, requires reloading the texture memory with the changed coefficients. This may slow down the performance, and needs to be tested. A possible optimization is to store the density variation modes as separate textures, and apply them by running a fragment program that takes weights as inputs, and outputs the linear combination of the variations using these weights.</p><p>We have a working 2D-3D registration framework, yet the optimization algorithm, Downhill Simplex, seems to be less efficient than what we desire. We have examined several gradient-based methods, with no better answer yet, and we will continue looking at this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We have presented a novel algorithm for computing DRR images of an unstructured grid, with higher-order attenuation functions. Our method uses a closed formula for integrating the function along the line of sight. The algorithmic focus of this paper is on obtaining the correct values of the parameters used in the integral formula through interpolation and texture lookup.</p><p>The experimental results presented here show that using higherorder attenuation functions contributes to the quality of the final image, but this contribution comes with a price: The size of the current formulation of the integral shows a trend of exponential growth with the degree, and the multiple texture access operations, required for fetching the function coefficients, seem to impact the performance quite badly. These problems should be addressed in future research.</p><p>In spite of these issues, we believe that the other contributions of this work outweigh the drawbacks. We present elegant geometric solutions for interpolation of thickness and barycentric coordinates. Even though we haven't fully optimized the GPU programs, their performance is at least 10 times faster than the older method we used, which rasterized the tetrahedra and computed the integrals on the CPU. The ability to include shape and density variations in the rendered image is a key element in studying and using generic anatomical model, created from a population study. We consider this a leap forward in the application environment of computer assisted surgery.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>a) c Figure 1 :</head><label>c1</label><figDesc>Classification of projected tetrahedra. (a) A three-facet projection. (b) A four-facet projection. The two (a) images indicate: (1) v 0 is pointing towards the observer; (2) v 0 is pointing away from the observer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Side view of projected tetrahedra, indicating the near thick point f and the far thick point b, which are projected along the same line of sight. The labels (a1), (a2), and (b) correspond to the labels in Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Interpolating the thickness along the line of sight. Here, p is the eye position; y a point on the front face, and x is the corresponding point on the back face; point; v 1 is a boundary vertex of the facet, where the thickness is zero; d n is the distance from y to the back face along the back-face normal n b ; and d y is the distance along the line of sight (shown as a dashed line). (a) shows the result when v 1 is in front of x. (b) shows the result when x is in front of v 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Inputs•</head><label></label><figDesc>The barycentric coordinates on the front face, u f , are interpolated linearly over the facet.• The eye-space position on the front face, y, is interpolated linearly over the facet.• The barycentric coordinates on the back face, u b , are interpolated through w = M −1 F b y, which in turn is interpolated linearly over the facet. • The back-face normal, n b , is constant per facet. • The thickness along the back-face normal, d n , is interpolated linearly for the facet. • The cell index j is constant per facet (and per cell). • The density coefficients for the cell, {β j k }, are read from texture memory indexed as a function of j. Outputs • The final integral value 1 0 f j (u(t))dt. • The Cartesian distance between the intersection points: d y =</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Comparing DRRs from a segmented pelvis CT and a tetrahedral mesh. (a) Anterior-posterior (AP) view of CT DRR. (b) AP view of mesh DRR with 3 rd order density functions. (c) Difference image (b)-(a). (d) Locations of relative difference |E(p)| ≥ 0.05.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Difference between images of the pelvis mesh with polynomials of degree d and degree d − 1. The images show signed differences, with negative values in black, zeros in gray, and positive differences in white. The values of the differences are scaled equally in all four images. d goes from 1 to 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Examples of shape variations in a pelvis model. The mean shape of a 6-subject population is shown on the left. Some typical shape variations are in the middle and on the right. The top row shows AP projections, and the bottom shows lateral projections of the same shape, that is, the model is rotated 90 • around the vertical axis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>DRR images of a tetrahedral model of bones segmented from a knee phantom CT scan, including: femur, patella, tibia, and fibula. Two views are shown. The images were created using our algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Comparing the performance of rendering 50 frames of the pelvis mesh, with different polynomial degrees.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table /><note>Numerical values in DRR images of pelvis mesh with dif- ferent degrees. d is the degree of the density functions. The table shows the maximum and minimum intensity values over a trajectory of 25 images, and the maximum and minimum pixel differences be- tween the images of degree d and the images of degree d − 1, and the root of the mean square (RMS) difference.</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Note for clarification that except for the outer edge of the facet, u = u b , and that normally u does not hold true barycentric coordinates.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGMENTS</head><p>We would like to thank the following people for their help in creating the statistical pelvis atlas: Gouthami Chintalapani, Lotta Ellingsen, Ashraf Mohamed, Anna (Na) Song. The pelvis CT datasets were given to us by Drs. Ted DeWeese and Lee Myers. This work was supported in part by NSF ERC Grant EEC9731478, by NIH/NIBIB research grant R21-EB003616, and by NSF ITR Grant AST-0313031.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Active shape models -their training and application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C J</forename><surname>T F Cootes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D H</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Vision and Image Understanding</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="38" to="59" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Zsweep: An efficient and exact projection algorithm for unstructured volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Farias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2000 ACM/IEEE Volume Visualization and Graphics Symposium</title>
		<meeting>2000 ACM/IEEE Volume Visualization and Graphics Symposium</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="91" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The lumigraph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Radek</forename><surname>Gortler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Grzeszczuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">F</forename><surname>Szeliski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;96: Proceedings of the 23rd annual conference on Computer graphics and interactive techniques</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="43" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The vxl library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vxl</forename><surname>The</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Group</surname></persName>
		</author>
		<ptr target="http://vxl.sourceforge.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Projecting tetrahedra without rendering artifacts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Qiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">S</forename><surname>Ebert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<editor>Holly Rushmeier, Greg Turk, and Jarke J. van Wijk</editor>
		<meeting><address><addrLine>Oc</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="27" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Iterative X-ray/CT registration Using Accelerated Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Larose</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Light field rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;96: Proceedings of the 23rd annual conference on Computer graphics and interactive techniques</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An approach to 3d finite element mesh generation from segmented medical images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashraf</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Davatzikos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Biomedical Imaging (ISBI)</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A fast high accuracy volume renderer for unstructured data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><surname>Moreland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Angel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Volume Visualization and Graphics</title>
		<imprint>
			<date type="published" when="2004-10" />
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Simulation of x-ray projections for experimental 3d tomography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Muller-Merbach</surname></persName>
		</author>
		<idno>SE-581 83</idno>
		<imprint>
			<date type="published" when="1996" />
			<pubPlace>Sweden</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Image Processing Laboratory Department of Electrical Engineering Linkoping University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hardware-accelerated volume and isosurface rendering based on cell-projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hammer: Hierarchical attribute matching mechanism for elastic registration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Davatzikos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. On Medical Imaging</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1421" to="1439" />
			<date type="published" when="2002-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1990 workshop on Volume visualization</title>
		<meeting>the 1990 workshop on Volume visualization<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An exact interactive time visibility ordering algorithm for polyhedral cell complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cláudio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">S B</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">L</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Volume Visualization</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="87" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Hardware-based view-independent cell projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manfred</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Volume Visualization and Graphics Symposium</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Visibility ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1992-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Tetrahedral projection using vertex shaders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Wylie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><surname>Moreland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename><forename type="middle">Ann</forename><surname>Fisk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><surname>Crossno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE symposium on Volume visualization and graphics</title>
		<meeting>the 2002 IEEE symposium on Volume visualization and graphics<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A statistical bone density atlas and deformable medical image registration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianhua</forename><surname>Yao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Johns Hopkins University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
