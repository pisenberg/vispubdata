<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Reconstructing Manifold and Non-Manifold Surfaces from Point Clouds</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianning</forename><surname>Wang</surname></persName>
							<email>jianning@cs.sunysb.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><forename type="middle">M</forename><surname>Oliveira</surname></persName>
							<email>oliveira@inf.ufrgs.br</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution" key="instit1">CVC</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Instituto de Informática UFRGS</orgName>
								<address>
									<country key="BR">Brazil</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">CVC,Computer Science Stony Brook University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Reconstructing Manifold and Non-Manifold Surfaces from Point Clouds</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Virtual reality surface reconstruction</term>
					<term>non-manifold surfaces</term>
					<term>topological thinning</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Examples of surfaces reconstructed with our algorithm. A single framework handles all cases. (a) A view of the Stanford bunny. (b) Surface reconstruction with hole filling. (c) Surface reconstruction with boundary preservation. (d) Non-orientable surface. (e) Non-manifold surface.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Surface reconstruction from unorganized points has many practical applications ranging from reverse engineering <ref type="bibr" target="#b23">[24]</ref>, entertainment, and analysis of forensic records, to digitization of cultural heritage <ref type="bibr" target="#b14">[15]</ref> and creation of virtual museums. This subject has gotten considerable attention in recent years due to the increasing availability of 3D scanning devices, which are capable of sampling complex geometric objects at very high resolutions. Surface reconstruction from unorganized point clouds is, however, a challenging and ill-posed problem and although much progress has been made in the last few years <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18]</ref>, currently no single approach can consistently handle all possible surface configurations. Moreover, essentially all approaches seem to assume that point clouds represent the surfaces of solids, and very little attention has been given to reconstructing surfaces with boundaries or non-orientable surfaces <ref type="bibr" target="#b0">[1]</ref>.</p><p>In this paper, we present a novel approach for surface reconstruction from unorganized point clouds. Our approach is general in the sense that it naturally handles manifold and non-manifold surfaces, surfaces with boundaries, as well as non-orientable surfaces, all in a consistent way. It does not require any extra geometric information other than the positions of the samples. Depending on no extra information makes this algorithm suitable for a broader range of applications. Our method is robust to irregular sampling and surface gaps, and relatively robust to the presence of noise. Furthermore, it is fast, parallelizable and easy to implement because it is based on simple local operations.</p><p>In addition to its central contribution, the new reconstruction algorithm, this paper also introduces three other original results:</p><p>• An extension to Tsao and Fu's algorithm <ref type="bibr" target="#b21">[22]</ref> to perform thinning while preserving surface boundaries (Section 3.2);</p><p>• An extension to Azernikov's meshing algorithm <ref type="bibr" target="#b3">[4]</ref> to support the creation of polygonal meshes for non-manifold surfaces represented as point clouds (Section 3.3);</p><p>• A new algorithm for smoothing surface boundaries that significantly improves the quality of the meshes reconstructed for surfaces with boundaries (Section 3.3.1).</p><p>In our approach, surface reconstruction is performed using a three-step process. First, the space containing the point cloud is subdivided, creating a voxel representation. Gap filling is performed at this stage (Section 3.1). Then, a voxel surface with the same topology of the sampled surface is computed using topological thinning operations based on Tsao and Fu's algorithm <ref type="bibr" target="#b21">[22]</ref> (Section 3.2). Finally, a polygonal mesh is extracted using a modified version of Azernikov's algorithm (Section 3.3). the versatility of our technique to reconstruct surfaces with different topologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PREVIOUS AND RELATED WORK</head><p>There are many algorithms for surface reconstruction from unorganized points. They can be generally classified as computational geometry, algebraic and implicit methods. Computational geometry methods use mechanisms such as Delaunay triangulation <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10]</ref> and region growing <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11]</ref> to build a set of simplices whose vertices are the original points. These methods tend to perform well on dense and clean datasets and are capable of reconstructing surfaces with boundaries. They are, however, sensitive to noise and tend to leave holes in undersampled regions. Algebraic methods (e.g., <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b20">21]</ref>) fit a smooth function to the set of input points thus recovering smooth surfaces. Most of these methods cannot handle arbitrary topology, nor reconstruct complex geometry.</p><p>The use of implicit functions is the most popular approach for surface reconstruction from sets of unorganized points <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b22">23]</ref>. These methods are based on the use of a signed distance function, which allows the representation of different topologies. Surface reconstruction is quite straightforward, usually performed using a variation of the Marching Cubes algorithm <ref type="bibr" target="#b15">[16]</ref>. The primary limitation of these methods is their inability to reconstruct non-manifold surfaces. According to Bloomenthal et al. <ref type="bibr" target="#b6">[7]</ref>, boundaries are usually specified via additional functions that are required to have all the same sign. Bloomenthal and Ferguson <ref type="bibr" target="#b7">[8]</ref> describe an algorithm for polygonizing non-manifold implicit surfaces defined by multiple regions of space. The algorithm can handle surfaces with boundaries and intersections, but the existence of multiple regions significantly adds to the complexity of the polygonizer.</p><p>Ohtake and collaborators <ref type="bibr" target="#b17">[18]</ref> have demonstrated a very interesting and flexible hierarchical surface reconstruction method based on the blending of local implicit functions. Their approach handles very large datasets, can reconstruct sharp features and provides support for CSG and morphing operations. However, it cannot be used to reconstruct non-manifold surfaces.</p><p>Adamson and Alexa <ref type="bibr" target="#b0">[1]</ref> presented a point-based algorithm for rendering (not reconstructing) surfaces with boundaries and nonorientable surfaces. In their approach, a dense set of points defines an implicit surface, which is identical to a moving least squares (MLS) surface approximation <ref type="bibr" target="#b1">[2]</ref>. The technique can only be used for rendering manifold surfaces and is based on ray casting. A surface with boundary is then locally defined as the set of points x (on the implicit surface), whose distances to a weighted average position in a neighborhood Ω that contains x is less than a userspecified threshold. Thus, sparsely sampled regions are rendered as holes. Unlike <ref type="bibr" target="#b0">[1]</ref>, our technique actually reconstructs a polygonal representation for these surfaces.</p><p>Azernikov's approach <ref type="bibr" target="#b3">[4]</ref> constructs a connectivity graph and then creates facets by traversing the graph and finding minimal loops. In the resulting mesh, each voxel yields one vertex, computed as the centroid of input points inside the associated voxel. The algorithm cannot guarantee that the voxel surface has a welldefined local topology. Therefore, a number of heuristics are used to assure the correctness of the resulting mesh. It also assumes that its input consists of a densely sampled point cloud and does not fill gaps. There are three major differences between our modified meshing strategy and Azernikov's algorithm: (1) we only find a connectivity graph for surface and border voxels (see Section 3.2 for a definition of these terms); (2) our approach handles nonmanifold surfaces; and (3) because some empty octree voxels corresponding to holes need to be incorporated in the voxel surface (in order to automatically fill them), we employ a new way to identify such voxels and assign vertices to them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE SURFACE RECONSTRUCTION ALGORITHM</head><p>Our surface reconstruction algorithm constructs a polygonal mesh from a point cloud using voxels as an intermediate representation.</p><p>The steps of the algorithm are shown in Algorithm 1. First, the point cloud is turned into a voxel representation. At this stage, gaps are filled using a new gap-filling algorithm. Then, topological thinning is used to create a voxel surface representation. Finally, a polygonal mesh is extracted from the voxel surface.</p><p>1. voxelization and gap filling; 2. topological thinning; 3. meshing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1: Surface reconstruction algorithm</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Voxelization and Gap Filling</head><p>The algorithm starts by computing a tight bounding box for the point cloud, which is then subdivided into voxels. The voxel size should be small enough to avoid merging distinct surface features, but large enough to avoid unnecessary computations. Currently, the voxelization process is performed based on a user-specified voxel size. Voxels containing original points are called p-voxels. Some empty voxels (i.e., not containing points) falling in between p-voxels and representing non-sampled surface patches are called g-voxels. g-voxels will later be used for gap filling (Section 3.1.2 explains how to identify g-voxels). We call foreground voxels the set defined by the union of p-voxels and g-voxels. Foreground voxels are used for topological thinning (Section 3.2). Because they only occupy a small portion of the space, we use a dexel data structure <ref type="bibr" target="#b11">[12]</ref> to store them. The complement of the foreground voxels with respect to the bounding box is called background voxels. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Topological Classification of Voxels</head><p>We are interested in reconstructing surfaces and surface junctions, while preserving surface boundaries. The local topological type of a voxel is determined by the number of foreground and background connected components in its neighborhood. A voxel is called a junction voxel if it is at the junction of two or more surfaces. Likewise, a voxel is called a boundary voxel if it is at the boundary of some surface, along some curve, or just an isolated voxel. Half surface voxels are on one side of a thick voxel surface and are the only ones to be deleted during topological thinning. The existence of thick voxel surfaces is usually associated with the presence of noise in the dataset. <ref type="figure" target="#fig_1">Figure 2</ref> illustrates the different topological types of a voxel. To compute the local topological type of a voxel v, one needs to compute NFC and NBC, the number of connected components formed exclusively by foreground (18-connected) and background (6-connected) voxels, respectively, in the neighborhood of v. Before computing NFC, v should be deleted from its neighborhood. The appropriate size for the neighborhood depends on the level of noise in the point cloud and on the surface features to be reconstructed. According to our experience, a maximum neighborhood size of 5 × 5 × 5 voxels seems to work well in practice for most situations. All examples shown in the paper were reconstructed using a 5 × 5 × 5 voxel neighborhood.</p><p>The topological type of a voxel v is determined by looking up <ref type="table" target="#tab_0">Table 1</ref> using the values of NFC and NBC. The subscripts of NFC and NBC in <ref type="table" target="#tab_0">Table 1</ref> represent the size of a neighborhood (e.g., a subscript value k indicates a k × k × k neighborhood). For efficiency reasons, we first search the 3 × 3 × 3 neighborhood of v. If the NBC 3 = 0, we have an interior voxel, and the classification process stops. If, on the other hand, NFC 3 &gt; 1 or NFC 3 = 0, v is a boundary voxel. Although <ref type="table" target="#tab_0">Table 1</ref> shows the necessary conditions for identifying v's topological type on a 3 × 3 × 3 neighborhood, such a small neighborhood size can only be safely used with clean datasets. Noise tends to cause voxel surfaces to appear thicker. In this case, the use of a 3 × 3 × 3 neighborhood is often insufficient to correctly characterize the different components in v's neighborhood, thus leading to a incorrect topological classification. If v's topological type cannot be safely identified based on the values of NFC 3 and NBC 3 , we increase the neighborhood size to 5 × 5 × 5 and recompute NBC. In this case, if NFC 3 = 1 and NBC 3 = 1 and NBC 5 = 1 then v is a boundary voxel. If NFC 3 = 1 and NBC 3 = 1 and NBC 5 = 2 then v is a half surface voxel. Otherwise, if  </p><formula xml:id="formula_0">NBC 5 = 2, v is a surface voxel. If NBC 5 &gt; 2, v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Identifying g-voxels and Filling Gaps</head><p>The voxel surface defined by the set of p-voxels may contain holes and/or gaps due to insufficient sampling, as illustrated in <ref type="figure" target="#fig_2">Figure 3</ref>(a) and (c). We will not make a distinction between a hole ( <ref type="figure" target="#fig_2">Figure 3a</ref>) and a gap ( <ref type="figure" target="#fig_2">Figure 3c</ref>). For simplicity, we use the term "gap" to refer to hole and gap. Because we adopt a more general definition of "gap", the classical hole-filling schemes (i.e., finding hole boundary before filling the hole <ref type="bibr" target="#b13">[14]</ref>) cannot be applied here. Algorithm 3 fills gaps before a polygonal mesh is extracted from the voxel surface. The algorithm uses two dexel data structures D pg and D b , which are both initialized with all p-voxels. At the end of the procedure, D pg will contain the set of foreground voxels (p-voxels and g-voxels) and will be used as input for the topological thinning procedure; D b , on the other hand, will contain the set of boundary voxels, and will be used to prevent boundary voxels in D pg from being eroded during topological thinning (Section 3.2). The idea behind Algorithm 3 is straightforward: after initializing D pg and D b with p-voxels, the algorithm tries to fill gaps by filling voxel line segments with increasing lengths ranging from 1 to L (a maximum user-specified value). Each segment should connect a pair &lt; v 0 , v 1 &gt; of boundary voxels (classified using Algorithm 2). Before a voxel line segment is filled, the segment has to pass a validation test. store all p-voxels in both D pg and D b ; for d=1 to hole size L;</p><p>for</p><formula xml:id="formula_1">each voxel v in D b ; check the topological type of v in D pg ; if v is not a boundary voxel; delete v from D b ; for each voxel v 0 in D b ; for each v 1 in D b with v 1 − v 0 ≤ d; if voxel line segment &lt; v 0 , v 1 &gt; is valid; create g-voxels connecting v 0 to v 1 ;</formula><p>add these g-voxels to D pg and D b ;</p><p>Algorithm 3: Gap filling in voxel space Gap refers to the background voxels between adjacent patches of the same surface component. And we call the background voxels separating two different surface components separation. In Algorithm 3, we first fill gaps with small width. When the length of voxel line segments become larger, we need to test whether they are connecting already connected patches.</p><p>The validity tests of voxel line segment &lt; v 0 , v 1 &gt; include the following: (1) except the two end boundary voxels, the voxel line segment should be solely composed of background voxels; (2) v 0 and v 1 do not come from the same outmost boundary (e.g., v 0 and v 1 in <ref type="figure" target="#fig_2">Figure 3(a)</ref>). If the voxel line segment passes the tests, all (empty) voxels along the segment are turned into g-voxels, and used to fill gaps. g-voxels are automatically incorporated into the set of foreground voxels.</p><p>A boundary is a closed voxel curve. We start from an arbitrary voxel and propagate it via adjacency along the curve until all voxels along the curve have been reached. The number of propagation becomes then the length of the curve. If we propagate a boundary towards adjacent non-boundary regions, we obtain a new voxel curve. If the boundary is longer than the new curve, it is considered to be an outmost one. In practice, however, this criterion could fail and users might want to preserve some hole boundaries (e.g., the holes in the bottom of the bunny in <ref type="figure">Figure 1(b)</ref>). For these reasons, the user is allowed to mark any boundary as outmost later. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Topological Thinning</head><p>Before converting the voxel representation into a polygonal mesh, we should remove all voxels that cause the "surface" to be unnecessarily thicker than one voxel deep. Such voxels are called halfsurface voxels (see <ref type="figure" target="#fig_1">Figure 2</ref>) and usually result from the existence of noise in the point cloud or inappropriately large voxel size. In order to create a thin voxel shell, we perform a topological thinning operation. By iteratively removing boundary voxels and reclassifying the remaining voxels, Tsao and Fu <ref type="bibr" target="#b21">[22]</ref> find the skeleton (medial axis or medial surface) from voxel representations. However, their algorithm erodes surface boundaries as well, which we want to preserve. Therefore, we have extended Tsao's and Fu's original algorithm to preserve boundaries. In the extended algorithm, thinning is applied to the set of foreground voxels D pg , while D b (the set of boundary voxels) is checked to avoid improper removal of boundary voxels. Both D pg and D b are computed using Algorithm 3. At the end of the thinning process, D pg contains a voxel surface (more precisely, D pg will contain a set of connected components representing the surface). <ref type="figure" target="#fig_3">Figure 4</ref> illustrates the process of gap filling and topological thinning. The red voxels represent a surface boundary and the result of gap filling is shown in <ref type="figure" target="#fig_3">Figure 4(b)</ref>. Note the existence of some extra voxels. <ref type="figure" target="#fig_3">Figure 4(c)</ref> shows the output produced by our topological thinning algorithm, which will be used as input for the meshing stage (last step of our surface-reconstruction algorithm).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Meshing</head><p>Meshing is performed using a variation of the algorithm presented by Azernikov et al. <ref type="bibr" target="#b3">[4]</ref>. Since the local topological type of all voxels in D pg is known, the step in Azernikov's algorithm required to eliminate "false facets" (i.e., facets that might appear in the connectivity graph but do not belong to the original surface) can be safely skipped. For the case of manifold surfaces, this simpler version of the algorithm can be used. Since Azernikov's algorithm does not handle non-manifold surfaces, we modified the original algorithm by allowing one surface to be composed of several sub-surfaces connected at junction voxels. Given two surface patches P i and P j , their intersection defines a set of junction voxels. <ref type="figure" target="#fig_4">Figure 5</ref> illustrates this situation in 2D showing a slice (side view) through two interpenetrating surface patches. In <ref type="figure" target="#fig_4">Figure 5</ref>, blue squares represent junction voxels. Red squares represent surface voxels. Surface voxels touching junction voxels are called border voxels. A set of border voxels of a given patch defines a border curve for the patch. We call intersection curve the curve defined by the set of junction voxels.</p><p>Given an intersection between two patches P i and P j , there are three possible types of border curves for one participating patch, as illustrated in <ref type="figure" target="#fig_5">Figure 6</ref> for the case of patch I: two disconnected border curves <ref type="figure" target="#fig_5">(Figure 6a</ref>), one open border curve <ref type="figure" target="#fig_5">(Figure 6b)</ref>, and one closed border curve ( <ref type="figure" target="#fig_5">(Figure 6c)</ref>. For the cases (b) and (c), each patch still consists of a single connected component. Meshing can then be performed after junction voxels are connected to voxels of the border curve, and the resulting set of voxels is submitted to a thinning operation.</p><p>If the intersection causes a patch to be split into two disjoint connected components <ref type="figure" target="#fig_5">(Figure 6a</ref>), the algorithm needs to regroup all components into a single mesh. <ref type="figure" target="#fig_4">Figure 5</ref> illustrates this situation for a pair of intersecting patches P i and P j , resulting in four disjoint connected components S 0 , S 1 , S 2 and S 3 , shown in red in <ref type="figure" target="#fig_4">Figure 5</ref>(a).</p><p>The process of regrouping starts by identifying all components and, for each one, creating a mesh using the simplified version of Azernikov's algorithm. After these meshes have been created, a normal vector is computed for each border voxel by averaging the normals of all faces sharing that particular voxel <ref type="figure" target="#fig_4">(Figure 5a</ref>). We start with a voxel in the intersection curve and walk along this curve. Let v j be the current junction voxel in the intersection curve. Also, let v a and v b be any two border voxels adjacent to v j and belonging to different border curves C p and C q . We compute m a,b = |n a • n b |, where n a and n b are the normals of border voxels v a and v b , respectively. We use a triangular matrix M to store in element M p,q the average of all values m a,b such that v a is in border curve C p and v b is in border curve C q . In this case, averaging is used to compensate for the fact that different border curves may have different numbers of border voxels.</p><p>After the walk through all junction voxels in the intersection curve is over, let M p,q be the element of matrix M with the biggest value. Then, we connect the components associated with border curves C p and C q and set M p,q to zero. The rationale here is that the orientation of border voxels belonging to these two components correlate the most. This is interpreted as a strong indication that the two components belong to the same surface. Then, we identify the element in M with the next biggest value, connect their corresponding components and set the matrix cell to zero. This process is repeated until M contains no non-zero elements. The entire process is illustrated in <ref type="figure" target="#fig_4">Figure 5</ref>. First, components S 1 and S 2 are connected <ref type="figure" target="#fig_4">(Figure 5b</ref>), then S 0 and S 3 are also connected <ref type="figure" target="#fig_4">(Figure 5c</ref>). Connecting two components amounts to computing the union between the voxels belonging to the components themselves and the associated junction voxels, performing a thinning operation, and finally using the simplified version of Azernikov's algorithm to create a mesh. <ref type="figure" target="#fig_4">Figure 5(c)</ref> shows the final result after the algorithm is applied to the four components shown in <ref type="figure" target="#fig_4">Figure 5(a)</ref>. The position of the vertex associated with a junction voxel is given by the average position of all points falling inside the corresponding voxel. On the other hand, the vertex position inside a g-voxel is initially at the center of the voxel. In order to produce smoother meshes, these positions can be relaxed using any active contour techniques <ref type="bibr" target="#b5">[6]</ref>. Currently, we minimize the following energy with a simplistic massspring system:</p><formula xml:id="formula_2">E = ∑ i∈G ( ∑ k∈M(vi) (v k − v i ) ) 2</formula><p>(1)  where G is the set of junction voxels and g-voxels, and M(v) is the set of voxels which are directly connected to v in the resulting mesh. In order to accelerate the convergence, we solve the system iteratively until E becomes negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Smoothing Boundaries</head><p>The representation of boundaries of surfaces is usually affected by under-sampling and noise. Also, the spatial discretization imposed by the voxelization process tends to worsen the problem. As a result, the meshing procedure described in section 3.3 tends to reconstruct ragged boundaries. This situation is illustrated in <ref type="figure" target="#fig_6">Figure 7</ref>(a) for the case of a mesh fragment showing a surface boundary. In order to improve the appearance of boundaries, we take groups of three consecutive boundary vertices and set the position of the middle one as a weighted average of the other two. Thus, let c be the vertex position associated with a voxel v at the boundary of a given surface S, and let c l and c r be the positions of the vertices associated with v l and v r , the left and right neighbors, respectively, of v at the same boundary. We then make c be collinear with c l and c r . As we proceed to the next group of three neighbor boundary voxels, the collinearity among c l , c and c r is lost, but the boundary smoothing effect is preserved. Using this simple procedure, the resulting boundary <ref type="figure" target="#fig_6">(Figure 7b</ref>) becomes much smoother, leading to more pleasing results. <ref type="figure" target="#fig_10">Figure 10</ref> compares the results produced by mesh extraction (a) without and (b) with boundary smoothing and illustrates the significant improvement obtained with this technique. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Cost of the Algorithm</head><p>Let n be the number of samples in the point cloud and let m be the number of voxels used to discretize its bounding box. The cost of assigning a given input point to a voxel is O(1), adding up to O(n) for the entire input data. The topological classification of one voxel is done by analyzing a finite neighborhood and, thus is O(1). Therefore, the classification of all voxels is performed in O(m). During gap filling, we have at most (2L + 1) 3 voxel line segments and may have up to L(2L + 1) 4 m voxel operations, where L the maximum length allowed for a segment. Gap filling is then performed in O(m). Thus, the first step of the surface reconstruction algorithm has cost O(n + m). Topological thinning is performed in O(m), since each voxel is visited and either deleted, if it is a half surface voxel, or kept, otherwise. Finally, for meshing, we need to process all foreground voxels (i.e., p-and g-voxels) in order to compute the average position of the sets of points inside each voxel. Since the cost of creating the mesh itself is O(m), the cost of the entire meshing stage is O(n + m). Therefore, the total cost of our surface reconstruction algorithm is O(m + n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>We have implemented the described algorithm and used it to reconstruct manifold and non-manifold surfaces with different topologies. The point clouds used as input for the reconstruction process were obtained from actual range scans as well as from synthetic datasets. <ref type="figure">Figure 1</ref> illustrates the versatility of our approach showing reconstruction results for different kinds of topologies. Our algorithm can be used to reconstruct closed surfaces <ref type="figure">(Figure 1b)</ref>, surfaces with boundaries <ref type="figure">(Figure 1c</ref>), non-orientable surfaces <ref type="figure">(Figure 1d)</ref> and non-manifold surfaces <ref type="figure">(Figure 1e</ref>), all using a single framework. For rendering, the meshes were obtained using the procedure described in section 3.3 and were then triangulated. Vertex normals were approximated by averaging the normals of all faces sharing the given vertex.</p><p>Relying on the voxelization, topological classification and gap filling procedures, our algorithm is robust to the presence of noise and irregular sampling. <ref type="figure" target="#fig_8">Figures 8 and 9</ref> illustrate the results of the proposed algorithm applied to actual range scans.  We also added Gaussian noise with magnitude of 1% of the size of the original bounding box to the point cloud. The resulting reconstructed model is shown in <ref type="figure" target="#fig_8">Figure 8(d)</ref>. The large number of g-voxels in the noisy bunny model (see <ref type="table" target="#tab_2">Table 2</ref>) results from the existence of many small holes due to the added noise. <ref type="figure" target="#fig_9">Figure 9</ref> shows the Stanford dragon reconstructed with our algorithm after merging 60 range scans containing noise and registration errors. The merged dataset for this genus-2 model has about 1.7 million points and includes a number of noticeable outliers. Using our approach, the global topology is correctly reconstructed and delicate surface details are nicely preserved. No pre-or postprocessing step is required for removing the outliers. <ref type="figure" target="#fig_10">Figure 10</ref> shows the reconstruction of a Möbius strip model (a non-manifold) and illustrates the ability of our approach to handle non-orientable surfaces with boundaries. On the left, we show the reconstructed model before boundary smoothing. Notice the ragged edges. On the right, one sees the result after our smoothing boundary algorithm has been used. The new boundaries are significantly smoother, resulting in a more pleasant model. <ref type="figure" target="#fig_6">Figure 7</ref> shows closeup views of the two meshes for comparison. One should note that the ability to reconstruct non-manifold and non-orientable surfaces has more than just theoretical importance. For example, these surfaces have been represented using points <ref type="bibr" target="#b0">[1]</ref>, which one may want to visualize using polygonal models. <ref type="figure" target="#fig_11">Figure 11</ref> shows another view of the non-manifold model shown in <ref type="figure">Figure 1</ref>(e), which consists of two intersecting surfaces. This is a particularly challenging test and has been perfectly reconstructed by our approach. To the best of our knowledge, no other contempo-  rary surface-reconstruction algorithm is capable of reconstructing such a model. <ref type="figure" target="#fig_1">Figure 12</ref> shows reconstruction results for a vase model with varying sampling rates and illustrates the ability of our approach to work with sparse datasets. <ref type="figure" target="#fig_1">Figure 12</ref>(a) shows a point cloud obtained by randomly selecting only 20% of the points (13,619 points) from a digitized vase model. The small square highlights the irregular sampling in the resulting point cloud. Undersampling can also be observed by comparing the number of g-voxels in <ref type="table" target="#tab_2">Table 2</ref>. The number of such voxels for the reduced model is considerably bigger, thus implying severe undersampling. <ref type="figure" target="#fig_1">Figure 12(b)</ref> shows the reconstructed model obtained from the point cloud shown in (a). For comparison, <ref type="figure" target="#fig_1">Figure 12</ref>(c) shows the reconstructed vase using the full dataset (68,097 points). Although it is possible to observe differences on the vase's relief and at the boundary of its base, all major features were faithfully reconstructed from a much smaller dataset. <ref type="table" target="#tab_2">Table 2</ref> presents some statistics associated with the models shown in the paper. Measurements were performed on a Pentium 4, 2 GHz PC with 1GB of memory. The last three columns of the table show the running times, in seconds, of the three steps of our surface reconstruction algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Discussion and Limitations</head><p>For models with dense and regular samples, we obtain voxel surfaces with correct local topological types for each voxel. In the  presence of noise, sample positions tend to be shifted, creating "inflated" voxel surfaces and possibly introducing small gaps in the surface. In most cases, the level of noise in the dataset is smaller than the voxel size. Thus the introduced gaps are at most one voxel wide and can be filled with ease using Algorithm 3 with L = 2.</p><p>Our approach subdivides the bounding box of the point cloud into voxels with uniform sizes. While the use of an adaptive data structure, such as an octree, has advantages in terms of memory requirements, the topological thinning algorithm requires a constant voxel size. Note that using small voxels impacts the running time of the algorithm. Thus, the most suitable voxel size can be understood as the biggest one that still allows the reconstruction of the intended surface details. Such a value can be obtained based on the user experience or using a binary-search-based trial and error process.</p><p>Our approach does not require point normals. However, if the dataset contains normals, they can be used to help thinning and meshing. For instance, the sub-directions for thinning could be reduced from 6 to 2 and one could further optimize the obtained mesh by applying the constraints on surface normals.</p><p>The major limitation of the proposed approach is that the hole filling algorithm relies on the assumption that the size of gaps to be filled is smaller than the size of separation between surface components, which should not be filled. In the case of increased noise level or missing samples, the assumption might be broken and the proposed algorithm will not work. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSIONS AND FUTURE WORK</head><p>We have presented a new approach for surface reconstruction from unorganized points. Our approach can naturally handle both manifold and non-manifold surfaces, surfaces with boundaries and nonorientable surfaces using a single framework. Our method is robust to irregular and sparse sampling, and to surface gaps. By not relying on normals, it is relatively robust to the presence of noise.</p><p>We have demonstrated the effectiveness of the proposed approach by reconstructing geometric models directly from range scans of real objects containing noise and registration errors. The user can decide whether gaps and holes should be filled or not. The approach is based on simple local operations, resulting in a fast, parallelizable and easy to implement procedure. We have shown that the cost of the algorithm varies linearly with the size of the point cloud and with the number of voxels used to discretize the space.</p><p>Along with the surface-reconstruction method, we presented an extension to Tsao's and Fu's thinning algorithm <ref type="bibr" target="#b21">[22]</ref> that preserves surface boundaries. This new algorithm might be useful for other applications that require non-essential geometric data to be discarded, while preserving boundaries. We have also extended Azernikov's meshing algorithm <ref type="bibr" target="#b3">[4]</ref> to support non-manifold surfaces and introduced a new smoothing boundary algorithm that significantly improves the quality of the reconstructed surface boundaries.</p><p>The use of a fixed voxel size leads to unnecessary processing on locally flat regions without holes. The use of an adaptive framework (octree-like) based on the local geometry and topology of the surface patch inside a voxel could be used to skip this processing. Recently, Tchon et al. <ref type="bibr" target="#b19">[20]</ref> report an approach for thinning on octrees. Also, the topological thinning approach may smooth some sharp features. For really curved regions, the reconstructed surface may be shifted from the real one. Currently, the voxel size is a user-specified parameter. We would like to devise a mechanism for easily detecting different surface features inside voxels. Such a mechanism should help to guide an octree subdivision process, lending to an adaptive version of our surface-reconstruction algorithm. This is conceptually similar to what has been recently described by Ohtake and collaborators <ref type="bibr" target="#b17">[18]</ref>. We also want to use graphics hardware to accelerate our method. Developing post-processing methods for the resulting mesh to handle sharp features is another important avenue for future exploration. The use of non-manifold subdivision <ref type="bibr" target="#b24">[25]</ref> may help to improve the quality of the resulting mesh.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 1 illustrates 415 Please see supplementary material on conference DVD. IEEE Visualization 2005 October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Topological classification of voxels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Possible situations in gap filling: (a) a surface with an inner hole. Here&lt; v 2 , v 3 &gt; is a valid voxel line segment, but &lt; v 0 , v1 &gt; is not. (b) the surface reconstructed from (a) with hole filled. (c) several surface patches with in-between gaps, and (d) the surface reconstructed from (c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Gap filling and topological thinning. (a) Fragment of a voxel surface with a boundary highlighted in red. (b) Result of the gap filling procedure. (c) Resulting voxel surface after topological thinning.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Creating non-manifold surfaces. (a) Individual surfaces are reconstructed. s 1 and s 2 are part of the same surface intersected by the surface defined by s 0 and s 3 . (b) Surface (s 1 , s 2 ) is reconnected. (c) Surface (s 0 , s 3 ) is reconnected, thus reconstructing the non-manifold surface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Three types of border curves in surface intersections (considered with respect to patch I): (a) two border curves; (b) a single non-closed border curve (c) a single closed border curve.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>(a) Low sampling, noise, and spatial discretization imposed by the voxels can lead to the reconstruction of ragged boundaries. (b) New mesh obtained after boundary smoothing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>(a) Stanford bunny reconstructed from 10 range scans using the proposed algorithm. (b) Reconstruction of the bunny as a closed surface. (c) Reconstruction of the bunny preserving the holes (boundaries). (d) Noisy bunny. several reconstructions of the Stanford bunny obtained from a point cloud created after merging 10 range scans (containing noise and registration errors), with a total of 362,272 points. The bunny model (Figure 8a) is well known to have holes at the bottom. Figure 8(b) shows the reconstructed bunny with the holes filled, whereas in Figure 8(c) the boundaries were preserved.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>The reconstruction of the dragon model obtained from 60 range scans (containing registration errors, noise and outliers) using our algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Reconstruction results of a non-orientable surface (Möbius strip) (a) before and (b) after smoothing of boundaries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Non-manifold surface reconstructed with our algorithm. The surface consists of two intersecting patches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Reconstruction of sparsely and unevenly sampled objects: (a) A point cloud obtained by randomly selecting 20% of the points (13,619 points) of a digitized vase model. The small square highlights the irregular sampling. (b) Vase model reconstructed from the point cloud in (a). (c) Vase reconstructed from the full point cloud (68,097 points). Notice that all important features were appropriately reconstructed in (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Voxel topological types</figDesc><table><row><cell>Topological type</cell><cell>NFC 3</cell><cell cols="2">NBC 3 NBC &gt;3</cell></row><row><cell>interior</cell><cell>1</cell><cell>0</cell><cell>any</cell></row><row><cell>boundary</cell><cell>&gt;1 or 0</cell><cell>any</cell><cell>any</cell></row><row><cell>boundary</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell>surface</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell>junction</cell><cell>1</cell><cell>≥2</cell><cell>&gt; 2</cell></row><row><cell>half surface</cell><cell>1</cell><cell>1</cell><cell>2</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>is a junction voxel. These conditions are summarized inTable 1 and in Algorithm 2. compute NFC 3 and NBC 3 for v; if (NBC 3 = 0) return interior voxel; if (NFC 3 &gt; 1 or NFC 3 = 0) return boundary voxel; else compute NBC</figDesc><table /><note>5 for v; if (NBC 3 = 1) if (NBC 5 = 1) return boundary voxel; else return half surface voxel; else if (NBC 5 &gt; 2) return junction voxel; else return surface voxel; Algorithm 2: Topological classification (v: voxel)</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Statistics of some reconstruction results (time in seconds)</figDesc><table><row><cell>Model</cell><cell cols="2"># of input voxel</cell><cell># of</cell><cell># of</cell><cell># of</cell><cell>time of</cell><cell>time of</cell><cell>time of</cell></row><row><cell></cell><cell>points</cell><cell>grid</cell><cell cols="2">p-voxels g-voxels</cell><cell>facets</cell><cell cols="3">gap filling thinning meshing</cell></row><row><cell>Merged Bunny</cell><cell>362,272</cell><cell>128 3</cell><cell>25,751</cell><cell>419</cell><cell>27,953</cell><cell>5.64</cell><cell>11.00</cell><cell>0.56</cell></row><row><cell>Merged Dragon</cell><cell cols="2">1,769,513 256 3</cell><cell>41,243</cell><cell>662</cell><cell>101,997</cell><cell>20.80</cell><cell>28.60</cell><cell>3.79</cell></row><row><cell>Möbius Strip</cell><cell>7,560</cell><cell>64 3</cell><cell>2,912</cell><cell>0</cell><cell>2,838</cell><cell>0.89</cell><cell>1.23</cell><cell>0.11</cell></row><row><cell>Intersected surfaces</cell><cell>20,402</cell><cell>32 3</cell><cell>2,171</cell><cell>0</cell><cell>2,021</cell><cell>0.43</cell><cell>0.00</cell><cell>0.11</cell></row><row><cell>Noisy bunny (with 1% noise)</cell><cell>34,834</cell><cell>128 3</cell><cell>19,122</cell><cell>13,917</cell><cell>35,531</cell><cell>75.61</cell><cell>29.23</cell><cell>1.32</cell></row><row><cell>Vase</cell><cell>68,097</cell><cell>64 3</cell><cell>11,830</cell><cell>459</cell><cell>13,654</cell><cell>1.40</cell><cell>2.78</cell><cell>0.35</cell></row><row><cell>Undersampled Vase</cell><cell>13,619</cell><cell>64 3</cell><cell>6,413</cell><cell>6,092</cell><cell>13,855</cell><cell>7.50</cell><cell>4.20</cell><cell>0.37</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work is partially supported by NSF grant CCR-0306438 and FAPERGS (Brazil) Processo No 03/51060.8. The bunny and dragon datasets are courtesy of the Stanford 3D scanning repository. The vase model was provided by Cyberware.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Approximating bounded, nonorientable surfaces from points. Shape Modeling International</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Adamson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Alexa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Point set surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Alexa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Behr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shachar</forename><surname>Fleishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="21" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A new voronoi-based surface reconstruction algorithm. SIGGRAPH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nina</forename><surname>Amenta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marshall</forename><surname>Bern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manolis</forename><surname>Kamvysselis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="415" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Surface reconstruction of freeform objects based on multiresolution volumetric method. the 8th ACM symposium on Solid modeling and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergei</forename><surname>Azernikov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Miropolsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anath</forename><surname>Fischer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="115" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The ball-pivoting algorithm for surface reconstruction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fausto</forename><surname>Bernardini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Mittleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holly</forename><surname>Rushmeier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Taubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="349" to="359" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Active Contours</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Blake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Isard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Introduction to Implicit Surfaces</title>
		<editor>Jules Bloomenthal</editor>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Polygonization of nonmanifold implicit surfaces. SIGGRAPH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jules</forename><surname>Bloomenthal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keith</forename><surname>Ferguson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="309" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Beatson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Cherrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Fright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">R</forename><surname>Evans</surname></persName>
		</author>
		<title level="m">Reconstruction and representation of 3D objects with radial basis functions. SIGGRAPH</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="67" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Three-dimensional alpha shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernst</forename><forename type="middle">P</forename><surname>Mucke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="43" to="72" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A fast and efficient projection based approach for surface reconstruction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gopi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of High Performance Computer Graphics, Multimedia and Visualisation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Van Hook</surname></persName>
		</author>
		<title level="m">Real-time shaded NC milling display. SIGGRAPH</title>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Stuetzle</surname></persName>
		</author>
		<title level="m">Surface reconstruction from unorganized points. SIGGRAPH</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Ju</surname></persName>
		</author>
		<title level="m">Robust repair of polygonal models. SIGGRAPH</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="888" to="895" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kari</forename><surname>Pulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Szymon</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucas</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matt</forename><surname>Ginzton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Ginsberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duane</forename><surname>Fulk</surname></persName>
		</author>
		<title level="m">The digital michelangelo project: 3D scanning of large statues. SIGGRAPH</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="131" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Marching cubes: A high resolution 3D surface construction algorithm. SIGGRAPH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Interpolating implicit surfaces from scattered surface data using compactly supported radial basis functions. Shape Modeling International</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><forename type="middle">S</forename><surname>Morse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><forename type="middle">S</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Penny</forename><surname>Rheingans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Multi-level partition of unity implicits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yutaka</forename><surname>Ohtake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Belyaev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Alexa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-Peter</forename><surname>Seidel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>SIG-GRAPH</publisher>
			<biblScope unit="page" from="463" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Generalized implicit functions for computer graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stan</forename><surname>Sclaroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Pentland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="247" to="250" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Constructing anisotropic geometric metrics using octrees and skeletons</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammed</forename><surname>Ko-Foa Tchon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francois</forename><surname>Khachan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ricardo</forename><surname>Guibault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Camarero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th International Meshing Rountable</title>
		<imprint>
			<date type="published" when="2003-09" />
			<biblScope unit="page" from="293" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Dynamic 3d models with local and global deformations: Deformable superquadrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Terzopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Metaxas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="703" to="714" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A parallel thinning algorithm for 3D pictures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">F</forename><surname>Tsao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Image Processing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="315" to="331" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Variational implicit surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James O'</forename><surname>Brien</surname></persName>
		</author>
		<idno>GIT-GVU-99-15</idno>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Reverse engineering of geometric models -an introduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tamás</forename><surname>Várady</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralph</forename><forename type="middle">R</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jordan</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Design</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="255" to="268" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Nonmanifold subdivision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lexing</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Zorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="325" to="332" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
