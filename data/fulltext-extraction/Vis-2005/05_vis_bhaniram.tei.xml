<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">OpenGL Multipipe SDK: A Toolkit for Scalable Parallel Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Praveen</forename><surname>Bhaniramka</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philippe</forename><forename type="middle">C D</forename><surname>Robert</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Eilemann</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Silicon Graphics</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Bern</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">OpenGL Multipipe SDK: A Toolkit for Scalable Parallel Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.2 [Computer Graphics]: Graphics Systems -Distributed Graphics; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism -Virtual Reality Scalable Rendering</term>
					<term>Parallel Rendering</term>
					<term>Immersive Environments</term>
					<term>Scalable Graphics Hardware</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We describe OpenGL Multipipe SDK (MPK), a toolkit for scalable parallel rendering based on OpenGL. MPK provides a uniform application programming interface (API) to manage scalable graphics applications across many different graphics subsystems. MPKbased applications run seamlessly from single-processor, singlepipe desktop systems to large multi-processor, multipipe scalable graphics systems. The application is oblivious of the system configuration, which can be specified through a configuration file at run time. To scale application performance, MPK uses a decomposition system that supports different modes for task partitioning and implements optimized GPU-based composition algorithms. MPK also provides a customizable image composition interface, which can be used to apply post-processing algorithms on raw pixel data obtained from executing sub-tasks on multiple graphics pipes in parallel. This can be used to implement parallel versions of any GPUbased algorithm, not necessarily used for rendering. In this paper, we motivate the need for a scalable graphics API and discuss the architecture of MPK. We present MPK&apos;s graphics configuration interface, introduce the notion of compound-based decomposition schemes and describe our implementation. We present some results from our work on a couple of target system architectures and conclude with future directions of research in this area.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The need for interactive visualization systems continues to increase constantly. Large amounts of data have to be processed when visualizing complex simulations, rendering large 3D models or scientific data sets <ref type="bibr" target="#b20">[22]</ref>. Data sizes in the magnitude of terabytes are not uncommon. In addition, there is a growing need for display technologies, such as CAVEs <ref type="bibr" target="#b11">[13]</ref>, PowerWalls, domes and other immersive environments. This imposes high requirements on the development and deployment of interactive graphics applications, which have to render at high frame rates and achieve high visual realism. It is desirable that the same application be used in many different environments, ranging from common graphics workstations to high-end visualization systems with multiple graphics pipes and specialized scalable graphics hardware.</p><p>Multiple graphics pipes can be used to allow graphics-intensive applications to achieve the desired rendering performance and im-age quality by executing sub-tasks in parallel and combining partial results generated by individual pipes. Traditionally, proprietary high-end graphics vendors, like SGI and SUN, supported hosting multiple graphics accelerators on one system. With the advent of PCI Express <ref type="bibr" target="#b18">[20]</ref>, motivated by the needs of the booming video gaming market, this technology can be expected to be more widely available in the future. The advent of modern graphics architectures <ref type="bibr" target="#b35">[37]</ref> <ref type="bibr" target="#b17">[19]</ref>, where commodity components are used to build powerful multi-processor, multi-GPU systems, adds to the complexity of modern visualization systems. There is need for a scalable rendering system which enables applications to utilize all available processing and rendering power and reach optimal performance by taking advantage of multiple graphics pipes and other specialized hardware.</p><p>OpenGL Multipipe SDK (MPK) is a scalable rendering toolkit, which facilitates the development and deployment of parallel, OpenGL-based multipipe applications. MPK-based applications can be configured at run time either via a configuration file or programmatically. By separating the system's resource management and physical environment from the application, MPK is able to provide applications with run time configurability and scalability. MPK implements compound algorithms based on various decomposition modes and provides a parallel rendering API. Being able to choose and adapt the decomposition strategy for a given problem domain and graphics environment at run time leads to a great amount of flexibility and guarantees that the applications be deployable in a variety of environments.</p><p>In addition to scalability, MPK allows controlling stereo features of the display environment. It is possible to switch between mono and stereo rendering at run-time allowing MPK applications to run in complex environments and support various input peripherals and projection systems, such as HMDs <ref type="bibr" target="#b37">[39]</ref> or BOOMs <ref type="bibr" target="#b23">[25]</ref>. MPK is also capable of providing transparent scalability in multi-head X11 environments.</p><p>We present the architecture of OpenGL Multipipe SDK, and show how it can be used for parallel rendering for a variety of target applications. By separating scene database management from rendering and resource management, we provide run-time configurability and run-time scalability for graphics applications. We introduce a novel way of describing and implementing scalability schemes for parallel graphics applications. Based on that, we design and implement a scalable graphics API. Finally, we show results for GPU-based composition algorithms and extensions to these algorithms to improve scalability and overall rendering performance. MPK currently runs on IRIX, 32-bit Linux and 64-bit Linux platforms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND AND RELATED WORK</head><p>The field of parallel graphics abounds with literature on attempts to facilitate the development of large-scale visualization and virtual reality applications. Molnar et al. <ref type="bibr" target="#b25">[27]</ref> identify three classes of parallel rendering paradigms based on the stage in the rendering pipeline where the sort from object space to screen space occurs: sort-first, sort-middle and sort-last. In the sort-first approach, the screen-space is divided into a number of disjoint display regions which are rendered in parallel and later assembled in the output</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Visualization 2005</head><p>October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 ©2005 IEEE. frame buffer. In sort-middle, primitives are redistributed between geometry processing and rasterization stages. This straightforward model has been used in many hardware architectures, including InfiniteReality <ref type="bibr" target="#b27">[29]</ref>, which uses a vertex-data broadcast bus, and Pixel-Planes 5 <ref type="bibr" target="#b13">[15]</ref>, which uses a ring network to distribute primitives. In sort-last, each graphics pipe renders only a subset of the scene database, preventing any primitive from being rendered more than once. However, image compositing is required to combine the partial results into a single output.</p><p>Humphrey and Hanrahan <ref type="bibr" target="#b16">[18]</ref> describe a virtual graphics system, WireGL, designed to support multiple simultaneous rendering streams to drive large tiled displays. This system was later ported to run on a cluster <ref type="bibr" target="#b14">[16]</ref> using traditional sort-first rendering. Humphreys et al. <ref type="bibr" target="#b15">[17]</ref> later integrated a parallel rendering interface in WireGL to achieve data scalability. They introduced Chromium <ref type="bibr" target="#b17">[19</ref>], a generic system for manipulating streams of graphics commands on clusters of workstations, making it possible to build sortfirst as well as sort-last architectures. Samanta et al. describe a costbased model for load-balancing the rendering tasks among cluster nodes <ref type="bibr" target="#b32">[34]</ref>. Later they extend their technique to allow for tile overlap, creating a hybrid sort-first and sort-last algorithm <ref type="bibr" target="#b30">[32]</ref>. Since these approaches require full database replication on each cluster node, Samanta et al. compared various data management strategies for clustered environments <ref type="bibr" target="#b31">[33]</ref>.</p><p>CAVELib by Cruz et al. <ref type="bibr" target="#b11">[13]</ref> is an API designed for creating interactive multi-screen applications for immersive environments. In 1999, CAVELib was enhanced to support PC-based visualization clusters. VR Juggler <ref type="bibr" target="#b19">[21]</ref> [10] is a development and deployment environment for virtual reality applications. Introducing the notion of a virtual platform for VR, Bierbaum et al. implement an operating environment that shields developers from specific details of the underlying hardware architecture and operating system. VR Juggler has also been designed to facilitate run-time reconfigurability <ref type="bibr" target="#b7">[9]</ref>. Another toolkit, which supports the development of multipipe applications, is SUN's multi-display utility MDU <ref type="bibr">[4]</ref>.</p><p>Aside from these highly specialized solutions, high-level toolkits exist which provide at least some support for scalable rendering. OpenGL Performer <ref type="bibr" target="#b29">[31]</ref> provides an API for managing multiple graphics pipes, but it does not virtualize the configuration of a multipipe system. Applications have to be aware of the available system resources and use them explicitly in order to take advantage of them. Likewise, Open Inventor applications can make use of immersive environments using TGS' MultiPipe extension <ref type="bibr" target="#b1">[2]</ref>. Head and hand tracking is thereby provided through the Trackd library <ref type="bibr" target="#b3">[5]</ref>. Paraview <ref type="bibr" target="#b2">[3]</ref>, on the other hand, is an application based on VTK <ref type="bibr" target="#b4">[6]</ref> which uses a sort-last parallel implementation for scalable visualization of large data sets.</p><p>Numerous hardware architectures have been proposed for accelerating image composition using specialized hardware. PixelFlow <ref type="bibr" target="#b26">[28]</ref> is a proprietary rendering system for real-time image generation, designed to scale linearly with it's Image Composition Network composed of multiple compositors. Stoll et al. describe Lightning-2 <ref type="bibr" target="#b36">[38]</ref>, a system to perform composition on a cluster of commercial of-the-shelf (COTS) PCs using the DVI digital video output of commodity GPUs. Similarly, the Metabuffer <ref type="bibr" target="#b9">[11]</ref> is a scalable multi-display system for COTS clusters, which includes novel multi-resolution capabilities. The Sepia system from Compaq <ref type="bibr" target="#b24">[26]</ref> is a flexible architecture based on programmable FPGA devices to achieve real-time frame rates when rendering partitioned data sets on a cluster of PCs. Similar compositors are available for SGI Onyx and Prism high-performance visualization systems <ref type="bibr" target="#b34">[36]</ref>.</p><p>To leverage the adoption of hardware-based, image-composition solutions using COTS clusters, Alcorn and Frank introduced the Parallel Image Compositing API, called PICA <ref type="bibr" target="#b5">[7]</ref>. PICA provides a complete abstraction layer for distributed image composition, independent of the graphics API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">GRAPHICS CONFIGURATION</head><p>MPK provides the application a high-level view of the underlying system by hiding the details of low-level systemic issues like graphics resource management and parallel rendering. <ref type="figure" target="#fig_0">Figure 1</ref> outlines the architecture of a scalable graphics system as viewed by an MPK application. The system consists of a host subsystem and a pool of GPUs connected via a high-bandwidth interconnect. The results generated by the GPUs in the graphics subsystem are distributed across an image composition network, which, after some processing, routes it to the display subsystem. The host is responsible for running the application and controlling other components of the system. The composition network can consist of general-purpose CPUs, GPUs or dedicated composition devices. The architecture does not make any assumptions on the type or topology of the interconnect between the host and the graphics subsystems. Similarly, no restrictions are imposed on the display subsystem, which can either be a set of projectors used to drive a CAVE or a single screen displaying the composited output from the multiple graphics pipes.  MPK isolates the application from details of the underlying hardware by separating these details from other aspects of the application, like scene database management. The graphics configuration is abstracted using the MPK configuration. Based on this abstraction, MPK implements multiple parallel rendering paradigms using compounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The MPK Configuration</head><p>The MPK configuration is a tree-like data structure used to describe the graphics resources on the system, along with information on using these resources to generate the final output image. The run-time execution environment provided by MPK uses the configuration to determine which physical pipes to initialize and manage, what parallel tasks to create and synchronize, and where to send the final rendered image for display. This simple scheme is extremely powerful since it isolates the application from the details of the system architecture on which it is running. Additionally, this high-level abstraction allows MPK to optimize the rendering process for specific target architectures in an application-transparent manner. <ref type="figure">Figure 2</ref> shows an example of a configuration hierarchy and its various components. Each of these components has a unique identifier, a character string. At the top level, the configuration contains a list of pipes. Each pipe corresponds to a physical rendering engine and is characterized by the name of its display -e.g., the X11 display identifier. Each pipe consists of a set of windows, each representing a single graphics context. A window retains attributes like geometry, display visuals and context handles and also provides the abstraction for a task to be created for parallel rendering. Each window further consists of a set of channels, which provide a view definition of the scene. Each channel defines a viewport in the window where the scene, or a part thereof, will be drawn, including the various projection and display parameters. Channels defined in the Channel "channel0" Channel "channel1" Window "window" Pipe ":0.0" config { pipe { display ":0.0" window { name "window" viewport [ 0.25 0.25 0.5 0.5] channel { name "channel0" } channel { name "channel1" } } } } <ref type="figure">Figure 2</ref>: A sample configuration hierarchy same window render to the same graphics context and use the same rendering thread.</p><p>The configuration can be loaded at run time using an ASCII configuration file ( <ref type="figure">Figure 2</ref>) or created programmatically using the MPK API. The former scheme is more commonly used requiring users to only change the MPK configurations during application development and deployment. Multiple windows per pipe are handy for developing, testing and debugging multi-threaded multi-context applications on single-pipe desktop systems while different multipipe configurations will be used when deploying the application in an immersive environment or parallel rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Compounds</head><p>Compounds describe how the rendering resources are combined to produce the final views. MPK allows decomposing the global rendering task into smaller tasks and assigns these tasks to individual channels for parallel rendering. This task division requires a decomposition scheme to send a subset of the rendering primitives to each channel, get back rendered images from each channel and then composite these to get the final image ( <ref type="figure" target="#fig_1">Figure 3</ref>). The decomposition scheme is abstracted using compounds, which are specified as part of the MPK configuration and hence can be configured using the same ASCII file. Compounds form a tree-like structure which provides an abstraction for the decomposition of the rendering. Multiple compounds can be configured as multi-level compound trees. A compound tree specifies the topology of the (de)composition network as well as the operations to be applied during rendering and image composition. Multiple disjoint compound trees may be used to drive multiple displays. <ref type="figure" target="#fig_1">Figure 3</ref> outlines the elements of a compound. The destination channel is the root node of the compound tree where the composed result will be displayed. The composition units -CPUs, GPUs or dedicated composition hardware -combine partial images and route the output image to the destination channel. Source channels represent the leaf nodes and perform the actual rendering. The compound mode specifies the decomposition scheme for the immediate children and the composition operator to be applied to the com-pound. The compound format controls the pixel data to be transported from the source channel; e.g., some composition schemes need both depth and color data to be transported, while others do not.</p><p>The compound traversal algorithm allows application-specific load balancing and facilitates task-partitioning algorithms to achieve optimal rendering performances with minimal run-time overhead (Section 6.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SCALABLE RENDERING</head><p>As explained in 3.2, scalability in MPK is achieved through task decomposition and recomposition algorithms implemented as compounds. MPK supports various parallel rendering modes and by default uses optimized GPU-based composition algorithms.</p><p>Factors affecting the performance of the application include: scalability of the decomposition algorithm, load balancing between source pipes, latency incurred during composition and the graphics IO overhead. The various factors can sometimes be mutually conflicting. To trade-off these factors to achieve the optimal performance for a given configuration, various heterogenous compounds can be combined to create multi-tier (de)composition trees. This also allows parallel composition algorithms to be implemented since individual compounds typically run in parallel. Multi-level compounds are also necessary to support multi-tier hardware compositors when the number of pipes on the system exceeds the number of inputs allowed by a single device <ref type="bibr" target="#b28">[30]</ref>.</p><p>Below we describe the currently available decomposition modes of MPK.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Frame Decomposition</head><p>In frame decomposition, a frame or view is divided into regions, each of which is assigned a different source pipe for rendering. The following compounds fall in this category:</p><p>Screen Decomposition In screen decomposition (2D), each pipe renders a smaller part of the screen area. Copying the source images and pasting them side-to-side in the destination channel generates the final image. This operation is easily implemented using dedicated hardware (see 5.4). 2D compounds scale pixel-filllimited applications trivially and can also be used to scale generalpurpose computations using graphics hardware (GPGPU) <ref type="bibr" target="#b0">[1]</ref>, preventing expensive network communication as on GPU clusters <ref type="bibr" target="#b12">[14]</ref>. The graphics I/O requirements of 2D are low, because the source images are small. However, as in <ref type="bibr" target="#b25">[27]</ref>, the technique has issues with load balancing as the number of pipes increases.</p><p>Database Decomposition In database decomposition (DB), the scene is rendered in parallel by dividing the rendered data across different graphics pipes. Each pipe renders a subset of the data to generate partial images, which are then composited to generate the final image using depth testing and/or alpha blending; e.g., for volume rendering, the application can partition the volume data into equal bricks, each of which is rendered on a different graphics pipe <ref type="bibr" target="#b6">[8]</ref>. The system's pixel-fill performance, texture download bandwidth, as well as texture memory size scale linearly with this technique.</p><p>Sub-Pixel Decomposition MPK can be used to parallelize operations at the fragment level by using multi-pass rendering algorithms executed in parallel on different pipes and then combining these partial results in the final composition step. Such a scheme can be used to implement full-scene antialiasing (FSAA) by rendering the scene from slightly different viewpoints and applying a filtering kernel during composition. The number of passes is thereby determined by the number of source channels. MPK allows every channel to be used multiple times to allow higher-order filtering algorithms to be implemented.</p><p>Eye Decomposition Eye decomposition (EYE) is useful for stereo rendering only, where each pipe renders a particular view (left or right) of the scene. If stereo is active, then each pipe view fills in the right or left buffer of the final rendering. This provides excellent load balancing and scalability for stereo-view rendering, because the scene content is similar for each eye.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Temporal Decomposition</head><p>In contrast to frame decomposition, temporal decomposition balances the workload by scheduling the work on each pipe in sync with that of the other pipes to produce a steady stream of rendered frames. Time scheduling rather than the frame division is the focus here. MPK provide two temporal decomposition algorithms:</p><p>Frame Multiplexing Frame multiplexing (DPLEX) distributes entire frames to the source pipes over time for parallel processing. It uses pipelining of successive frames by introducing latency in the rendering pipeline. DPLEX scales geometry, pixel-fill performance and host-to-graphics bandwidth, as the workload balance between pipes is intrinsically maintained. However, it has an increased transport delay inherent to frame synchronization required across the pipes and produces a latency of (pipes − 1) frames; i.e., there will be a (pipes − 1) frames delay between a user input and the corresponding output frame. Data Streaming Data streaming (3D) is similar to database decomposition in that it divides the scene among multiple pipes. The rendering of the final view is streamed through the available channels, using a series of successive compositions and readbacks for each frame, as shown in <ref type="figure" target="#fig_2">Figure 4</ref>. Like DPLEX, 3D compounds have a latency of (pipes − 1) frames, but they have low graphics I/O overhead, since each compound needs to read and assemble only one source image at a time. Hence, it is a good replacement of DB decomposition if the increased latency is acceptable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Operational Decomposition</head><p>MPK can decompose operational parts of the application's pipeline similar to the rendering process itself. This scheme is used to parallelize the draw and cull operations by using one or more culling threads, in addition to the per-window rendering threads. It is used when the cull operation takes a significant amount of time and additional compute resources are available. This flexible scheme allows multiple cull threads per draw operation, multiple draw threads per compound, as well as hierarchical culling for 2D decompositions ( <ref type="figure" target="#fig_4">Figure 5</ref>). Multiple draw threads per compound are implicitly load balanced: Each draw operation pulls the next data to be rendered from the cull queue and renders it. This is repeated by each draw  thread until everything is rendered, implicitly load-balancing the rendering. The source channel images are then recomposed in the same way as in a DB compound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">COMPOUND OPTIMIZATIONS</head><p>In this section, we discuss various optimizations introduced in MPK that provide a significant performance increase and help to achieve better scalability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Asynchronous Compositions</head><p>As the number of pipes increase, the composition overhead soon becomes an issue since the destination channel needs to composite the source images sequentially at the end of the frame. MPK provides an asynchronous composition mode (ASYNC) for minimizing this overhead by pipelining the rendering and composition operations. The composition occurs asynchronously with the frame rendering in individual source channels at the beginning of the next frame, allowing the source channels to render the next frame, while the destination channel is compositing the current one. This process also distributes the frame transport evenly, reducing the impact on the I/O subsystem. For the CULL compound, draw operations occur asynchronously from the cull operations; e.g., if the draw threads render frame N-1, the cull threads work on culling for frame N. Hence, the draw never stalls on the cull operation. This scheme improves performance by introducing an additional frame of latency to the pipeline. <ref type="figure">Figure 6</ref> compares the execution pipeline without and with this mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Dynamic Load Balancing</head><p>MPK provides a dynamic load balancing mode for 2D, DB and 3D compounds. This mode automatically computes the viewport or range of the compound's children based on the rendering time of each compound child of the last finished frame. This results in good load balancing for low-latency compounds, provided that the workload is relatively evenly distributed within the child viewport or range. To have a more precise knowledge about the workload distribution, MPK utilizes the region defined for adaptive readback (see 5.5). Moreover, the tiling scheme for 2D compounds can be configured to adapt to the nature of the data being rendered.</p><p>It is possible to create load-balanced 2D compounds that use channels on other windows also used for the final display. This cross-usage of rendering resources enables scalability on tiled displays by distributing the rendering uniformly across all rendering resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Pbuffer Rendering</head><p>MPK uses pbuffer rendering to provide better resource utilization when scaling graphics applications. For example, typical implementations of DPLEX composition do not allow the destination channel to contribute to the final rendering, limiting the scalability of an N-pipe system to N-1 times a single pipe's performance. MPK  <ref type="figure">Figure 6</ref>: DB decomposition, without and with asynchronous compositions prevents this by using a separate pbuffer with the same OpenGL context on the destination window as the visible window. The draw thread renders to the pbuffer while the application calls MPK from the draw callback to render the other channels' output frames. On the availability of a frame, MPK makes the drawable of the visible window current and assembles the frame. Before returning to the application's draw callback, the OpenGL state is restored and the pbuffer drawable is made current again. This approach gives maximum scalability with DPLEX and has minimal overhead since it does not require an OpenGL context switch. This is depicted in <ref type="figure" target="#fig_7">Figure 7</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Hardware Composition</head><p>Several composition schemes mentioned in the previous section can be accelerated using special-purpose hardware. These devices prevent the overhead in the image acquisition and composition stages by ingesting the output video signal directly from the source graphics pipes and providing the composited video signal as output. 2D, DPLEX, EYE and FSAA decomposition modes are currently implemented in MPK using the SGI Graphics Compositor <ref type="bibr" target="#b34">[36]</ref> or DPLEX option board <ref type="bibr" target="#b33">[35]</ref>. Hardware compositors also help in reducing the rendering latency in some composition schemes. The use of this hardware is transparent to the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Adaptive Image Pipeline</head><p>At the end of the draw operation, the application can specify the image-space bounding box within the framebuffer that was modified during the draw. MPK uses this information to minimize the pixel transfer overhead for the current frame by only processing this region. MPK further optimizes the image acquisition and composition steps for different graphics hardware using 4-pixelaligned transfers, for example. The bounding box is also used to tune the load balancing algorithm since it provides the load balancer more concrete information about the workload distribution in screen space, leading to better prediction for the subsequent frames.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">PROGRAMMING AND EXECUTION MODEL</head><p>MPK's programming model reflects the natural application framework of OpenGL and isolates the rendering task from resource management by using a callback-based interface. This interface is similar to the popular OpenGL Utility Toolkit (GLUT). The application provides function callbacks for specific tasks while the core of MPK handles the multi-processing aspects of the application. For a number of tasks, such as window creation, frame readback and compound assembly, MPK provides default implementations, which can be replaced by the application. A typical example could be to use compound assembly for GPGPU applications <ref type="bibr" target="#b0">[1]</ref>, where the final composition step would be used to combine the partial computation results instead of the default assembly.</p><p>Initialization and exit callbacks are invoked for creating and destroying components (pipes, windows, channels, and compounds) and setting of initial parameter values, like display windows, graphics contexts, etc.. Update callbacks are used for actions to execute during each frame refresh, including the per-channel rendering as well as the updates done on the global context handled by each window. Event callbacks process user input and execute actions for a given input event (mouse, keyboard, etc) for each window. <ref type="figure" target="#fig_8">Figure 8</ref> shows the execution model for a typical MPK application. The execution begins by loading the MPK configuration and initializing the application data. MPK allocates and initializes the various components of the configuration. MPK makes data management easier by allowing applications to store and access data in respective containers for each node in the configuration hierarchy. For example, identifiers like texture objects, display list identifiers, etc., which correspond to a given OpenGL context, can be created and stored using per-window containers and later retrieved in the update callbacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Initialization</head><p>MPK uses a multi-threaded execution model for parallelizing the rendering process and feeding the multiple graphics pipes in parallel. During configuration initialization, MPK creates threads for each window and manages their synchronization during each frame. Event interception and processing in MPK is centralized in the main application thread and allows event-driven execution or continuous rendering. Event handling can be configured and disabled on a perwindow basis to allow custom event processing for different application scenarios. Applications can select from fork, sproc, and pthread multi-tasking schemes at run time. On NUMA systems, pipe-and window-specific data can be allocated on the same node in the system to prevent unnecessary inter-node communication. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Frame Generation</head><p>MPK uses a frame-driven rendering pipeline ( <ref type="figure" target="#fig_8">Figure 8)</ref>; i.e. the application tells MPK to produce a new frame and MPK invokes all the callbacks on the configuration's resources required to produce that frame. Therefore, the rendering is always frame-synchronized. An exception to this rule is the DPLEX compound, where individual rendering threads run unsynchronized for multiple frames to allow overlapped time-multiplexed rendering.</p><p>At the beginning of a frame, MPK performs several steps to prepare the compound trees for the rendering. First, each tree is traversed to update the contextual data -like viewport (2D) or range (DB/3D) for the current frame. The next traversal prepares empty input and output frames as well as cull queues as specified by the compound flags and the rendering operations. In the last traversal, the appropriate rendering tasks (like pre-and post-assemble, clear, cull and draw) are assigned to each compound. Now the frame is ready to be rendered. By unlocking the window threads, each rendering channel traverses the compound tree and executes the tasks which are assigned to it by its referencing compounds. When this is done, each window notifies the application thread, so that MPK can synchronize the swapbuffer for all the contributing windows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Frame Data</head><p>While rendering a frame, the correct contextual data has to be passed to the application callbacks, depending on latency of the compounds. This is done by maintaining a unique data pointer (referred to as frame data), which is allocated and passed to MPK at the beginning of each frame. Once the data is no longer needed, MPK notifies the application to delete it. Likewise, applications can use a culling infrastructure, where the data describing the frame is produced by the application thread. The frame data is always passed latency-correct to the update callbacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>In the previous sections, we described the design and optimizations of MPK aimed at maximum scalability and flexibility. Now we demonstrate that MPK-based applications indeed meet these requirements. Using a typical, MPK-based volume rendering application, we present results for a few commonly used compounds. All the results have been generated by using different configuration files with the same unmodified application. We compare these results with the theorical performance numbers and show how optimizations built into MPK help achieve better scalability. The results collected in this paper come from two systems running Linux: an SGI Prism system with 10 Intel Itanium2 processors, 8 ATI FireGL X3 graphics pipes (AGP 8x) and 9.35 GB memory, and a COTS workstation with 1 AMD Opteron 3000+ processor, 2 NVidia GeForce 6600 graphics pipes (PCIe x16) and 2 GB memory.</p><p>The achieved performance depends on the single-pipe rendering time t 1 , readback rate R r , draw rate R d and the number of pixels in the destination channel nPixels. Please note that the source channel readbacks are executed in parallel whereas the destination draws are done sequentially. Also note that for asynchronous compounds, the readback and draws are executed in parallel, whereas, for synchronous compounds, they are executed serially (see <ref type="figure">Figure  6</ref>). Hence, for np pipes, assuming linear scalability, perfect load balancing and using the destination channel as a source as well, the theoretical achievable performance for ASYNC and NO ASYNC is given by the following:</p><formula xml:id="formula_0">t async total = t 1 np + max (t read ,t draw ) (1) t noasync total = t 1 np + t read + t draw<label>(2)</label></formula><p>For 2D compounds, t read and t draw are given by the following:</p><formula xml:id="formula_1">t read = nPixels np • R r , t draw = (np − 1) • nPixels np • R d<label>(3)</label></formula><p>whereas, for DB compounds, assuming full-screen reads and draws, the corresponding values are the following:</p><formula xml:id="formula_2">t read = nPixels R r , t draw = (np − 1) • nPixels R d<label>(4)</label></formula><p>For the tests on the SGI Prism, we have the following characteristics: t 1 = 603ms, nPixels = 1280 • 1024, R r = 68MPixels/s and R d = 148MPixels/s. <ref type="figure" target="#fig_9">Figures 9(a)</ref> and 9(b) show the theoretical and measured numbers for 2D and DB compounds, respectively. The NOCOPY graph shows the performance if no software readback or compositing is done, i.e., without the composition overhead. Typically, this is the case when using a hardware compositing device. 2D compounds provide better scalability than DB compounds, if there is perfect load-balancing and the data fits into GPU memory, which is unfortunately not true for most real-world applications. MPK's timing-based load-balancer provides a better decomposition for such applications, provided they maintain a reasonable    <ref type="figure" target="#fig_0">Figure 10</ref> compares only the measured overhead incurred by various compounds using ASYNC mode, i.e., t 1 = 0. It can be seen that for 2D and DPLEX, the overhead remains almost constant as np increases, whereas for DB, the overhead increases almost linearly (extreme case since the complete viewports are being read and composited). Using a hybrid 2D/DB (similar to Binary Swap <ref type="bibr" target="#b21">[23]</ref>) or a multi-stage hierarchical DB composition scheme reduces the overhead considerably by distributing the pixel transfer overhead as well as parallelizing the compositions. Please note that compounds like 2D, EYE and DPLEX require minimal programming effort and have smaller composition overhead. However, these compounds are limited when handling large data sets. DB and 3D compounds remove these limitations, but they require more application awareness in partitioning the data set across source channels and compositing the partial results. Depending on the problem, data size and system configuration, different compounds might be more applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS</head><p>In this paper, we have presented OpenGL Multipipe SDK, a toolkit for parallel scalable rendering. MPK provides applications with a high-level abstraction to the system's graphics resources while making low-level optimizations behind the scenes. Unlike application-transparent systems like ATI's CrossFire, Nvidia's SLI or Chromium, MPK requires parts of an application to be rewritten to take advantage of MPK's advanced scalability features. This application-aware approach prevents the overhead incurred by application-transparent approaches to get better scalability.</p><p>At the most generic level, an application only needs to deal with OpenGL rendering areas -i.e., channels -by providing the drawing code to handle a channel of arbitrary configuration (frustum, location in larger display setup, etc.). Everything else is handled by MPK: the type of windowing system, the system architecture, the type and topology of the interconnect. The architecture as such does not depend on the use of OpenGL.</p><p>MPK's flexible compound-based decomposition system can be configured to scale any kind of target applications. The compound traversal scheme implements new techniques to provide better scalability for applications. The callback-driven programming model coupled with the frame-driven execution model of MPK is extremely easy to use and intuitive for OpenGL application developers. We have presented scalability results for a few commonly used compounds and shown how asynchronous composition and multilevel compound heirarchies can be configured to scale applications by removing limitations inherent with certain compounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">FUTURE WORK</head><p>Our experiments with the dual-PCI Express system were limited by the availability of only 2 PCIe x16 slots on the system. We are currently investigating several approaches to enable distributed rendering using MPK on a cluster of PCs -e.g., using MPI or TCP/IP for distributing the rendering pipeline over the network. Additionally, using modified Chromium SPUs, we envision an integration where MPK can be used to configure and drive unmodified applications using the Chromium framework.</p><p>We are also looking into new, more optimal algorithms for DB compositing to reduce the composition overhead and provide better scalability. Fragment shaders and highly tuned, parallel software implementations are approaches that we are currently investigating.</p><p>Sub-pixel decomposition is a relatively new addition to MPK and we are investigating ways to make it more accessible to end users. Using this approach, applications can provide scalable visual effects like a large number of light sources by rendering a subset of light sources on each source channel or scalable fragment shaders by splitting the shading passes across source channels.</p><p>While MPK is able to scale GPGPU applications using 2D and DB compounds and custom composition implementations, it does not yet automate scalability for GPGPU applications. This could be addressed by implementing specialized compounds for processing multiple data streams in parallel, eventually using tools like BrookGPU <ref type="bibr" target="#b10">[12]</ref> or Sh <ref type="bibr" target="#b22">[24]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A scalable graphics system</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>A compound with 3 channels</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Data streaming using 3 channels</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Hierarchical culling using multiple cull threads</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Full-scale DPLEX rendering using 2 channels</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Execution model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Performance results using 2D decompositions (top) and DB decompositions (bottom) frame consistency, both spatially and time-wise. Applications can provide their own load balancing scheme based on their extended knowledge about the rendered data.The performance drop inFigure 9(b) for the NO ASYNC case is an application-specific anomality caused by a suboptimal implementation of the test application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Composition overhead for different compounds</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 Table 1 :</head><label>11</label><figDesc>shows the results obtained on the Dual PCIe system with t 1 = 1021ms and R r = R d = 190MPixel/s. The advantage of using ASYNC composition is clear, specially for DB compounds where the overhead of composition is higher. Achieved frames per second on the dual PCI Express system.</figDesc><table><row><cell></cell><cell cols="4">NO ASYNC ASYNC NOCOPY LINEAR</cell></row><row><cell>1-pipe</cell><cell>0.979</cell><cell>0.979</cell><cell>0.979</cell><cell>0.979</cell></row><row><cell>2-pipe 2D</cell><cell>1.785</cell><cell>1.860</cell><cell>1.951</cell><cell>1.958</cell></row><row><cell>2-pipe DB</cell><cell>0.962</cell><cell>1.764</cell><cell>1.949</cell><cell>1.958</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">ACKNOWLEDGEMENTS</head><p>The authors would like to thank Patrick Bouchaud for his efforts he put into MPK. We would also like to thank Vaibhav Saxena, Marc Romankewicz, Ken Jones, Bruno Stefanizzi (all SGI), Hanspeter Bieri (University of Bern, Switzerland), Mike Houston (Stanford University) and other reviewers for their valuable assistance and discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">General-Purpose Computation using Graphics Hardware</title>
		<ptr target="http://www.gpgpu.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Multi-Pipe Extension for Open Inventor</title>
		<ptr target="http://www.tgs.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paraview</surname></persName>
		</author>
		<ptr target="http://www.paraview.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Api</forename><surname>Trackd</surname></persName>
		</author>
		<ptr target="http://www.vrco.com/trackd/Overviewtrackd.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A Parallel Approach for Efficiently Visualizing Extremely Large, Time-Varying Datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Papka</surname></persName>
		</author>
		<idno>LAUR-00-1620</idno>
		<imprint>
			<date type="published" when="2000" />
			<pubPlace>Los Alamos National Laboratory</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Alcorn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
		<title level="m">Parallel Image Compositing API. Workshop on Commodity-Based Visualization Clusters</title>
		<imprint>
			<date type="published" when="2002-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">OpenGL Volumizer: A Toolkit for High Quality Volume Rendering of Large Data Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bhaniramka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Demange</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE Symposium on Volume Visualization and Graphics</title>
		<meeting>the 2002 IEEE Symposium on Volume Visualization and Graphics</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="45" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bierbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cruz-Neira</surname></persName>
		</author>
		<title level="m">Run-Time Reconfiguration in VR Juggler. 4th Immersive Projection Technology Workshop</title>
		<imprint>
			<date type="published" when="2000-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">VR Juggler: A Virtual Platform for Virtual Reality Application Development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bierbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Just</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hartling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Meinert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cruz-Neira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Virtual Reality</title>
		<meeting>IEEE Virtual Reality</meeting>
		<imprint>
			<date type="published" when="2001-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Metabuffer: A Scalable Multi-Resolution 3-D Graphics System Using Commodity Rendering Engines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Blanke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fussel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<idno>TR2000-16</idno>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
		<respStmt>
			<orgName>University of Texas at Austin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Brook for GPUs: Stream Computing on Graphics Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sugerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fatahalian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH</title>
		<meeting>SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="777" to="786" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Surround-Screen Projection-Based Virtual Reality: The Design and Implementation of the CAVE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cruz-Neira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sandin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Defanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 93</title>
		<meeting>SIGGRAPH 93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">GPU Cluster for High Performance Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Yoakum-Stover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/IEEE SC2004 Conference</title>
		<meeting>the ACM/IEEE SC2004 Conference</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page">47</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Pixel-Planes 5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Oulton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eyles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Greer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Goldfeather</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Tebbs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Israel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 89</title>
		<meeting>SIGGRAPH 89</meeting>
		<imprint>
			<date type="published" when="1989-07" />
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distributed Rendering for Scalable Displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Supercomputing</title>
		<imprint>
			<date type="published" when="2000-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Everett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<title level="m">WireGL: A Scalable Graphics System for Clusters. Proceedings of SIGGRAPH</title>
		<imprint>
			<date type="published" when="2001-08" />
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Distributed Graphics System for Large Tiled Displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Visualization</title>
		<imprint>
			<biblScope unit="page" from="215" to="224" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Chromium: A Stream-Processing Framework for Interactive Rendering on Clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ahern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Kirchner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="693" to="702" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Intel Corporation. The PCI Express Architecture and Advanced Switching</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Just</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bierbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cruz-Neira</surname></persName>
		</author>
		<title level="m">VR Juggler: A Framework for Virtual Reality Development. 2nd Immersive Projection Technology Workshop</title>
		<imprint>
			<date type="published" when="1998-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ginzton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ginsberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fulk</surname></persName>
		</author>
		<title level="m">The Digital Michelangelo Project: 3D Scanning of Large Statues. Proceedings of SIGGRAPH 2000</title>
		<imprint>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="131" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Parallel Volume Rendering Using Binary-Swap Image Composition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Painter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Krogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Algorithms</title>
		<imprint>
			<date type="published" when="1994-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Mccool</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Popa</surname></persName>
		</author>
		<title level="m">Shader Metaprogramming. Proceedings of the ACM SIGGRAPH/Eurographics Conference on Graphics Hardware</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="57" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Implementation and Integration of a Counterbalanced CRT-based Stereoscopic Display for Interactive Viewpoint Control in Virtual-Environment Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">E</forename><surname>Mcdowall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Bolas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Pieper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Humphries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPIE</title>
		<meeting>SPIE</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page">1256</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Moll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Heirich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shand</surname></persName>
		</author>
		<title level="m">Sepia: Scalable 3D Compositing using PCI Pamette. Proceedings of the Seventh Annual IEEE Symposium on Field-Programmable Custom Computing Machines</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page">146</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A Sorting Classification of Parallel Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Algorithms</title>
		<imprint>
			<biblScope unit="page" from="23" to="32" />
			<date type="published" when="1994-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">PixelFlow: High-Speed Rendering Using Image Composition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eyles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Poulton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 92</title>
		<meeting>SIGGRAPH 92</meeting>
		<imprint>
			<date type="published" when="1992-08" />
			<biblScope unit="page" from="231" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Infinite-Reality: A Real-Time Graphics System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Montrym</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dignam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 97</title>
		<meeting>SIGGRAPH 97</meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="293" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nonaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kukimoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sakamoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hazama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Watashiba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ogata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kanazawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
		<title level="m">Hybrid Hardware-Accelerated Image Composition for Sort-Last Parallel Rendering on Graphics Clusters with Commodity Image Compositor. IEEE Volume Visualization Symposium</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">IRIS Performer: A High Performance Multiprocessing Toolkit for Real-Time 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Helman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIG-GRAPH 94</title>
		<meeting>SIG-GRAPH 94</meeting>
		<imprint>
			<date type="published" when="1994-07" />
			<biblScope unit="page" from="381" to="395" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hybrid Sort-First and Sort-Last Parallel Rendering with a Cluster of PCs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Eurographics Workshop on Graphics Hardware</title>
		<meeting>Eurographics Workshop on Graphics Hardware</meeting>
		<imprint>
			<publisher>August</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="97" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Sort-First Parallel Rendering with a Cluster of PCs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technical Sketch</title>
		<imprint>
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Load Balancing for Multi-Projector Rendering Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Eurographics Workshop on Graphics Hardware</title>
		<meeting>Eurographics Workshop on Graphics Hardware</meeting>
		<imprint>
			<date type="published" when="1999-08" />
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Silicon Graphics, Inc. Onyx2 DPLEX Option Hardware User&apos;s Guide</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Silicon Graphics</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Inc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Infiniteperformance</surname></persName>
		</author>
		<title level="m">Scalable Graphics Compositor User&apos;s Guide</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Silicon Graphics, Inc. Silicon Graphics Prism Family of Visualization Systems</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Lightning-2: A High-Performance Display Subsystem for PC Clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Webb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Berman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Caywood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Taveira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 2001</title>
		<meeting>SIGGRAPH 2001</meeting>
		<imprint>
			<date type="published" when="2001-08" />
			<biblScope unit="page" from="141" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The Eyephone: A Head Mounted Stereo Display</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Teitel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPIE</title>
		<meeting>SPIE</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">1256</biblScope>
			<biblScope unit="page" from="168" to="172" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
