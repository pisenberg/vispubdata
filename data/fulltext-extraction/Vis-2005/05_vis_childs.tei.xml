<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Contract Based System For Large Data Visualization *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hank</forename><surname>Childs</surname></persName>
							<email>childs3@llnl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Brugger</surname></persName>
							<email>brugger1@llnl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kathleen</forename><surname>Bonnell</surname></persName>
							<email>bonnell2@llnl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Meredith</surname></persName>
							<email>meredith6@llnl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Miller</surname></persName>
							<email>miller86@llnl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Whitlock</surname></persName>
							<email>whitlock2@llnl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
							<email>max@cs.ucdavis.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Contract Based System For Large Data Visualization *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>large data set visualization</term>
					<term>data flow networks</term>
					<term>contract-based system</term>
				</keywords>
			</textClass>
			<abstract>
				<p>VisIt is a richly featured visualization tool that is used to visualize some of the largest simulations ever run. The scale of these simulations requires that optimizations are incorporated into every operation VisIt performs. But the set of applicable optimizations that VisIt can perform is dependent on the types of operations being done. Complicating the issue, VisIt has a plugin capability that allows new, unforeseen components to be added, making it even harder to determine which optimizations can be applied. We introduce the concept of a contract to the standard data flow network design. This contract enables each component of the data flow network to modify the set of optimizations used. In addition, the contract allows for new components to be accommodated gracefully within VisIt&apos;s data flow network system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>VisIt is an end-user visualization and data analysis tool for diverse data sets, designed to handle data sets from thousands to millions to billions of elements in a single time step. The tool has a rich feature set; there are many options to subset, transform, render, and query data. VisIt has a distributed design. A server utilizes parallel compute resources for data reduction, while a client runs on a local desktop machine to maintain interactivity. The rendering primitives resulting from the data reduction phase are typically transferred to the client and rendered using graphics hardware. When the number of primitives overwhelms the client, the geometry is kept on the server and rendered using a sort-last rendering technique <ref type="bibr" target="#b7">[9]</ref>. VisIt's rendering phase is outside the scope of this paper. Instead, we will focus on the data reduction phase and the optimizations necessary to handle large data sets.</p><p>VisIt employs a modified data flow network design <ref type="bibr" target="#b11">[13]</ref> [1] <ref type="bibr" target="#b9">[11]</ref>. Its base types are data objects and components (sometimes called process objects). The components can be filters, sources, or sinks. Filters have an input and an output, both of which are data objects. Sources have only data object outputs and sinks have only data object inputs. A pipeline is a collection of components. It has a source (typically a file reader) followed by many filters followed by a sink (typically a rendering engine). Pipeline execution is demand driven, meaning that data flow starts with a pull operation. This begins at the sink, which generates an update request that propagates up the pipeline through the filters, ultimately going to a load balancer (needed to divide the work on the server) and then to the source.</p><p>The source generates the requested data which becomes input to the first filter. Then execute phases propagate down the pipeline. Each component takes the data arriving at its input, performs some operation and creates new data at its output until the sink is reached. These operations are typical of data flow networks. VisIt's data flow network design, is unique, however, in that it also includes a contract which travels up the pipeline along with update requests (see <ref type="figure" target="#fig_0">Figure 1</ref>). During the update phase (denoted by thin arrows), Contract Version 0 (V0), comes from the sink. V0 is then an input to the contour filter, which modifies the contract to make Contract Version 1 (V1). This continues up the pipeline, until an executive that contains a load balancer (denoted by LB) is reached. This executive decides the details of the execution phase and passes those details to the source, which begins the execute phase (denoted by thick arrows).</p><p>VisIt is a large and complex system. It contains over 400 different types of components and data objects. It has over one million lines of source code and depends on many third party libraries. In addition, VisIt has a plugin capability that allows users to extend the tool with their own sources, sinks, filters, and even data objects.</p><p>The scale of the data sets processed by VisIt mandates that optimizations are incorporated into every pipeline execution. These optimizations vary from minimizing the data read in off disk to the treatment of that data to the way that data moves through a pipeline. The set of applicable optimizations is dependent on the properties of the pipeline components. This requires a dynamic system that determines which optimizations can be applied. Further, because of VisIt's plugin architecture, this system must be able to handle the addition of new, unforeseen components. VisIt's strategy is to have all of a pipeline's components modify a contract and have optimizations adaptively employed based on the specifications of this contract.</p><p>The heart of VisIt's contract-based system is an interface that allows pipeline components to communicate with other filters and describe their impact on a pipeline. Focusing on the more abstract notion of impact rather than the specifics of individual components allows VisIt to be a highly extensible architecture, because new components simply must be able to describe what impacts they will have. This abstraction also allows for effective management of the large number of existing components.</p><p>Because the contract is coupled with update requests, the information in the contract travels from the bottom of the pipeline to the top. When visiting each component in the pipeline, the contract</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Visualization 2005</head><p>October 23-28, Minneapolis, MN, USA 0-7803-9462-3/05/$20.00 Â©2005 IEEE.</p><p>is able to inform that component of the downstream components' requirements, as well as being able to guarantee that the components upstream will receive the current component's requirements. Further, the contract-based system enables all components to participate in the process of adaptively selecting and employing appropriate optimizations. Finally, combining the contract with update requests has allowed for seamless integration into VisIt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Description of Input Data</head><p>Most of the data sets processed by VisIt come from parallelized simulation codes. In order to run in parallel, these codes decompose their data into pieces, called domains. The domain decomposition is chosen so that the total surface area of the boundaries between domains is minimized, and there is typically one domain for each processor. Also, when these codes write their data to disk, it is typically written in its domain decomposed form. Reading in one domain from these files is usually an atomic operation; the data is laid out such that either it is not possible or it is not advantageous to read in a portion of the domain.</p><p>Some data sets provide meta-data to VisIt, allowing VisIt to speed up their processing. We define meta-data to be data about the data set that is much smaller in size than the whole data set. Examples of meta-data are spatial extents for each domain of the simulation or variable extents for each domain for a specific variable of the simulation.</p><p>VisIt leverages the domain decomposition of the simulation for its own parallelization model. The number of processors that VisIt's parallel server is run on is typically much less than the number of domains the simulation code produced. So VisIt must support domain overloading, where multiple domains are processed on each processor of VisIt's server. Note that it is not sufficient to simply combine unrelated domains into one larger domain. This is not even possible for some grid types, like rectilinear grids where two grids are likely not neighboring and cannot be combined. And for situations where grids can be combined, like with unstructured grids, additional overhead would be incurred to distinguish which domains the elements in the combined grid originated from, which is important for operations where users want to refer to their elements in their original form (for example, picking elements).</p><p>The simulation data VisIt handles is some of the biggest ever produced. For example, VisIt was recently used to interactively visualize a data set comprised of 12.7 billion elements per time step using only eighty processors. In addition, there are typically on the order of one thousand time steps for each simulation. The grids are unstructured, structured, or rectilinear. There are also scattered data and structured Adaptive Mesh Refinement (AMR) grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Related Work</head><p>VisIt's base data flow network system is similar to those implemented in many other systems, for example VTK <ref type="bibr" target="#b9">[11]</ref>, OpenDX <ref type="bibr" target="#b0">[1]</ref>, and AVS <ref type="bibr" target="#b11">[13]</ref>. The distinguishing feature of VisIt's data flow networks is the contract that enables optimizations to be applied adaptively. It should be noted that VisIt makes heavy use of VTK <ref type="bibr" target="#b4">[6]</ref> modules to perform certain operations. Many of VisIt's data flow network components satisfy their execute phase by offloading work to VTK modules. But VisIt's abstract data flow network components remain distinct from VTK and, moreover, have no knowledge of VTK.</p><p>There are several other richly-featured parallel visualization tools that perform data reduction in parallel followed by a combined rendering stage, although these tools frequently do not support operating on the data in its original form (including domain overload-ing) in conjunction with collective communication. Examples of these are EnSight [4], ParaView <ref type="bibr" target="#b5">[7]</ref>, PV3 <ref type="bibr" target="#b3">[5]</ref> and FieldView <ref type="bibr" target="#b6">[8]</ref>.</p><p>The concept of reading in only chunks of a larger data set (See Section 3.1) has been well discussed, for example by Chiang, et al. <ref type="bibr" target="#b2">[3]</ref> and Pascucci et al. <ref type="bibr" target="#b8">[10]</ref>. But these approaches typically do not support operating on the data in its native, domain decomposed form nor operating at the granularity of its atomic read operations (i.e. domains).</p><p>One of VisIt's execution models, called streaming (See Section 3.2), maps well to out-of-core processing. Many out-of-core algorithms are summarized by Silva et al. <ref type="bibr" target="#b10">[12]</ref>. In addition, Ahrens et al. <ref type="bibr" target="#b1">[2]</ref> gives an overview of a parallel streaming architecture. It should be noted that VisIt's streaming is restricted to domain granularity, while the system described by Ahrens allows for finer granularity. In this paper, the discussion will be limited to deciding when streaming is a viable technique and how the contract-based system enables VisIt to automatically choose the best execution model for a given pipeline.</p><p>Ghost elements are typically created by the simulation code and stored with the rest of the data. The advantages of utilizing ghost elements to avoid artifacts at domain boundaries (See Section 3.3) were discussed in <ref type="bibr" target="#b1">[2]</ref>. In this paper, we propose that the postprocessing tool (e.g. VisIt) be used to generate ghost data when ghost data is not available in the input data. Further, we discuss the factors that require when and what type of ghost data should be generated, as well as a system that can incorporate these factors (i.e. contracts).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OPTIMIZATIONS</head><p>In the following sections, some of the optimizations employed by VisIt will be described. The potential application of these optimizations is dependent on the properties of a pipeline's components. VisIt's contract-based system is necessary to facilitate these optimizations being applied adaptively.</p><p>After the optimizations are described, a complete description of VisIt's contract-based system will be presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Reading the Optimal Subset of Data</head><p>I/O is the most expensive portion of a pipeline execution for almost every operation VisIt performs. VisIt is able to reduce the amount of time spent in I/O to a minimum by reading only the domains that are relevant to any given pipeline. This performance gain propagates through the pipeline, since the domains not read in do not have to be processed downstream. Mesh lines for the elements are also shown. To create the data set sliced by the transparent grey plane, only the red domains need to be processed. The green domains can be eliminated before ever being read in.</p><p>Consider the example of slicing a three-dimensional data set by a plane (see <ref type="figure" target="#fig_1">Figure 2</ref>). Many of the domains will not intersect the plane and reading them in will be wasted effort. In fact, the number of domains (D) that are intersected by the slice is typically O(D 2/3 ).</p><p>With the presence of meta-data, it is possible to eliminate domains from processing before ever reading them. For example, if the slice filter had access to the spatial extents for each domain, it could calculate the list of domains whose bounding boxes intersects the slice and only process that list (note that false positives can potentially be generated by considering only the bounding box).</p><p>VisIt's contract methodology enables this. During the update phase, every filter is given an opportunity to modify the contract, which contains the list of domains to be processed. A filter can check to see if some piece of meta-data is available (for example, spatial extents), and, if so, cross-reference the list of domains to be processed with the meta-data. The modified contract will then contain only those domains indicated by the filter.</p><p>It is important to note that every filter in the pipeline has a chance to modify the contract. If a pipeline had a slice filter and a contour filter (to generate isolines), the slice filter could use a spatial extents meta-data object to get exactly the set of domains that intersected the slice, while the contour filter could use a data extents meta-data object to get exactly the set of domains that could possibly produce contours. The resulting contract would contain the intersection of their two domain lists.</p><p>Further, since the infrastructure for subsetting the data is encapsulated in the contract, plugin filters can leverage this optimization. For example, a plugin spherical-slice filter can be added afterwards and it can also make use of the spatial extents meta-data, or a plugin filter that thresholds the data to produce only the elements that meet a certain criteria (elements with density between 2 g/cc and 5 g/cc, for example) can use the data extents meta-data. Also, the types of meta-data incorporated are not limited to spatial and data extents. They can take any form and can be arbitrarily added by new plugin developers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Execution Model</head><p>VisIt has two techniques to do domain overloading. One approach, called streaming, will process domains one at a time. In this approach, there is one pipeline execution for each domain. Another approach, called grouping, is to execute the pipeline only once and to have each component process all of the domains before proceeding to the next one.</p><p>VisIt can employ either streaming or grouping when doing its load balancing. With static load balancing, domains are assigned to the processors at the beginning of the pipeline execution and a grouping strategy is applied. Because all of the data is available at every stage of the pipeline, collective communication can take place, enabling algorithms that cannot be efficiently implemented in an out-of-core setting. With dynamic load balancing, domains are assigned dynamically and a streaming strategy is applied. Not all domains take the same amount of time to process; dynamic load balancing efficiently (and dynamically) schedules these domains, creating an evenly distributed load. In addition, this strategy will process one domain in entirety before moving on to the next one, increasing cache coherency. However, because the data streams through the pipeline, it is not all available at one time and collective communication cannot take place with dynamic load balancing.</p><p>So how does VisIt decide which load balancing method to use? Dynamic load balancing is more efficient when the amount of work per domain varies greatly, but the technique does not support all algorithms. Static load balancing is usually less efficient, but does support all algorithms. The best solution is to use dynamic load balancing when possible, but fall back on static load balancing when an algorithm can not be implemented in a streaming setting. VisIt's contract system is again used to solve this problem. When each pipeline component gets the opportunity to modify the contract, it can specify whether or not it will use collective communication. When the load balancer executes, it will consult the contract and then use that information to adaptively choose between dynamic and static load balancing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Generation of Ghost Data</head><p>Although handling the data set as individual domains is a good strategy, problems can arise along the exterior layer of elements of a domain that would not occur if the data set was processed as a single, monolithic domain.</p><p>One common operation is to remove a portion of a data set (for example, clipping a wedge out of a sphere) and then look at only the external faces of what remains. This can be done by finding the external faces of each of the data set's domains. But faces that are external to a domain can be internal to the whole data set. These extra faces can have multiple negative impacts. One impact is that the number of triangles being drawn can go up by an order of magnitude. Another impact occurs when the external faces are rendered transparently. Then the extra faces are visible and result in an incorrect image (See <ref type="figure" target="#fig_2">Figure 3</ref>). Now consider the case where interpolation is needed to perform a visualization operation. For example, consider the case where a contour is to be calculated on a data set that has an element-centered scalar quantity defined on it. Since contouring is typically done with an algorithm that requires node-centered data, the first step of this process is to interpolate the data to be a node-centered quantity from an element-centered quantity. Along the domain boundaries, the interpolation will be incorrect, because the elements from neighboring domains are not available. Ultimately, this will lead to a cracked contour surface (See <ref type="figure" target="#fig_3">Figure 4</ref>). On the left is a contour plot of an element-centered quantity where ghost elements were not generated. Cracks in the contour surface occur along domain boundaries. On the right, ghost elements were generated and the correct picture was generated.</p><p>Both of the above problems require ghost data. For the first case, it is sufficient to mark the exterior faces of a domain that are internal to the whole data set as ghost faces. Then these ghost faces can be discarded when an external face list is generated. The second case requires a redundant layer of ghost elements around the exterior of each domain. This allows interpolation to be done correctly.</p><p>Generation of ghost data is typically possible given some description of the input data set. This input can take several forms. One form can be a description of how the domain boundaries of structured meshes overlap ("faces I=0-5, J=0, K=8-12 of domain 5 are the same as faces I=12-17, J=17, K=10-14 of domain 12"). Another form utilizes global node identifiers assigned by the simulation code for each node in the problem. The visualization tool can then use these identifiers to determine which nodes are duplicated on multiple domains and thus identify shared boundaries between domains, which is the key step for creating ghost data. A third form uses the spatial coordinates of each node as a surrogate for global node identifiers. For each of these forms, the salient issue is that a module can be written where VisIt can give the module the input data and request it to create ghost faces or ghost elements. The details of such a module are not important to this paper.</p><p>There are costs associated with ghost data. Routines to generate ghost elements are typically implemented with collective communication, which precludes dynamic load balancing. In addition, ghost elements require a separate copy of the data set (see <ref type="figure" target="#fig_4">Figure  5</ref>), increasing memory costs. Ghost faces are less costly, but still require arrays of problem size data to track which faces are ghost and which are not. To this end, it is important to determine the exact type of ghost data needed, if any. VisIt's contract system ensures that the minimum calculation is performed. If a filter, such as the contour filter, needs to do interpolation, it will mark the contract with this information on the update phase. As a result, ghost elements will be created at the top of the pipeline, allowing correct interpolation to occur. If the filter believes it will have to calculate external face lists, the case with the external face list filter, then it will mark the contract with this information on the update phase, and ghost faces will be created. Most importantly, in cases that do not require ghost data, such as the case when a data set is being sliced or volume rendered, no ghost data will be created.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Subgrid Generation</head><p>Before discussing subgrid generation, first consider VisIt's Clip and Threshold filters. Clipping allows a user to remove portions of a data set based on standard geometric primitives, such as planes or spheres. Thresholding allows the user to generate a data set where every element meets a certain criteria -the elements where density is greater than 2 g/cc and the temperature is between six hundred and eight hundred degrees Celsius. Both of these filters produce unstructured grid outputs even if the input grid is structured.</p><p>Our experience has been that most simulations with the largest number of elements are performed on rectilinear grids. Rectilinear grids have an implicit representation that minimizes the mem-ory footprint of a data set. Many filters in VisIt, such as Clip and Threshold, take in rectilinear grid inputs and create unstructured grid outputs. One issue with the unstructured grid outputs is that many components have optimized routines for dealing with rectilinear grids. A bigger issue is that of memory footprint. The representation of an unstructured grid is explicit, and the additional memory required to store them can be more than what is available on the machine.</p><p>To further motivate this problem, consider the following example of a ten billion element rectilinear grid with a scalar, floatingpoint precision variable. The variable will occupy forty gigabytes (40GB) of memory. The representation of the grid itself takes only a few thousand bytes. But representing the same data set as an unstructured grid is much more costly. Again, the scalar variable will take forty gigabytes. Each element of the grid will now take eight integers to store the indices of the element's points in a point list, and each point in the point list will now take three floatingpoint precision numbers, leading the total memory footprint to be approximately four hundred eighty gigabytes (480GB). Of course, some operations dramatically reduce the total element count -a threshold filter applied to a ten billion element rectilinear grid may result in an unstructured grid consisting of just a few elements. In this case, the storage cost for an unstructured grid representation of the filter's output is insignificant when compared to the cost of the filter's input. However, the opposite can also happen: a threshold filter might remove only a few elements, creating an unstructured grid that is too large to store in memory.</p><p>VisIt addresses this problem by identifying complete rectilinear grids in the filter's output. These grids are then separated from the remainder of the output and remain as rectilinear grids. Accompanying this grid is one unstructured grid that contains all of the elements that could not be placed in the output rectilinear grids. Of course, proper ghost data is put in place to prevent artificial boundary artifacts from appearing (which type of ghost data is created is determined in the same way as described in Section 3.3). This process is referred to as subgrid generation (See <ref type="figure" target="#fig_5">Figure 6</ref>). In the middle, we see a covering with a large minimum grid size, which results in four grids. On the right, we see a covering with a smaller minimum grid size, which results in nine grids. The elements not covered in the output grids are placed in an unstructured grid.</p><p>There are many different configurations where rectilinear grids can be overlaid onto the "surviving elements" in the unstructured grid. The best configuration would maximize the number of elements covered by the rectilinear grids and minimize the total number of rectilinear grids. These are often opposing goals. Each element could be covered by simply devoting its own rectilinear grid to it. Since each grid has overhead, that would actually have a higher memory footprint than storing them in the original unstructured grid, defeating the purpose.</p><p>Although our two goals are opposing, we are typically more interested in one goal than another. For example, if we are trying to volume render the data set, then the performance of the algorithm is far superior on rectilinear grids than on unstructured grids. In this case, we would want to make sure the maximum number of elements was covered by the rectilinear grids. But the performance of many operations is indifferent to grid type, making memory foot-print the only advantage for those operations.</p><p>VisIt uses its contract-based system to guide the placement of the rectilinear grids. Each component can modify the contract to say which goal it values -solely minimizing memory footprint versus keeping as many elements as possible in a native rectilinear representation for further processing.</p><p>As previously mentioned, some complete rectilinear grids contain so few elements that leaving them in an implicit form does not provide a favorable memory tradeoff, because there is overhead associated with each rectilinear grid. As such, VisIt has a minimum grid size of 2048 elements when overlaying complete rectilinear grids on the output. However, if the contract reports that filters down stream can take advantage of rectilinear representations, then the minimum grid size drops to 256 elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DESCRIPTION OF CONTRACT</head><p>The contract is simply a data structure. An initial version is created at the sink with all default values. As each component of the pipeline is visited during the update phase, it can modify the contract by changing members of this data structure. <ref type="table" target="#tab_1">Table 1</ref>   Each filter in VisIt inherits from a base class, called avtFilter. This class has a virtual function that allows the filter to modify the contract. Below is pseudocode for how to modify a contract. The contract allows for each component to describe the impact it will have on the total pipeline execution in a general way that does not require knowledge of the component itself. By enumerating the impacts that components can have on a pipeline, VisIt delivers a system that can be easily extended with new components. In addition, by using inheritance, the burden to implement a new component and utilize the contract-based system is very low.</p><p>The ghostType data member is set to None by default, because ghost data should not be generated when it is not required. The contour filter modifies the contract to have Element when it is going to contour element-based data, whereas the external face list filter modifies the contract to have Face. It should be noted that all of the components that modify this field do not blindly assign their desired value to it. If the face list filter were to overwrite a value of Element with its desired Face, then the filters downstream would not get the ghost data it needs. In this case, there is an ordering between the types. If Element was requested, then it should be obtained, regardless of requests for Face data. Similarly, Face data should be obtained even if other filters need None. And those that request None should gracefully accept and pass through ghost data.</p><p>Furthermore, those that request Face data should be able to accept and deal gracefully with Element data in its place. The external face list filter, then, is able to accommodate Element data, even when it simply needs Face data. Although it would be possible to eliminate this complexity (by having separate entries in the contract for ghost faces and ghost elements), the field is maintained as one entry because it is more efficient to only calculate one set of ghost data.</p><p>optimizedForRectilinear is set to false by default, since only certain filters are specialized for operating on rectilinear grids. If the field is false, then the grids are placed to minimize memory footprint, rather than maximizing the number of elements covered by the rectilinear grids. canDoDynamic is set to true because it assumed that most filters do not require collective communication. If they do require collective communication, it is their responsibility to set that canDoDynamic to false when it has a chance to modify the contract in the update phase. Finally all of the domains are assumed to be used at the beginning of the update. If filters are able to access meta-data and determine that some domains will not affect the final picture, then they may modify the Boolean values for those domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>The contract-based system described in this paper has been fully implemented in VisIt. This includes of all of VisIt's components, which modify the contract as appropriate on update requests.</p><p>The results presented in this section demonstrate the benefit of the example optimizations discussed. We believe that this motivates the importance of using these optimizations and, by extension, motivates the importance of a contract-based system that enables these specialized optimizations to be adaptively employed.</p><p>We will present results in the context of a Rayleigh-Taylor Instability simulation, which models fluid instability between heavy fluid and light fluid. The simulation was performed on a 1152x1152x1152 rectilinear grid, for a total of more than one and a half billion elements. The data was decomposed into 729 domains, with each domain containing more than two million elements.</p><p>All timings were taken on Lawrence Livermore National Laboratory's Thunder machine, which was ranked seventh on the Top 500 list released in June 2005. The machine is comprised of 4096 1.4GHz Intel Itanium2 processors, each with access to two gigabytes of memory. The machine is divided into 1024 nodes, where each node contains four processors. The processor's memory can only be shared with other processors in its node.</p><p>Pictures of the operations described below are located at the end of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Reading the optimal subset of data</head><p>We will present two algorithms where the optimal subset of data was read -slicing, which makes use of spatial meta-data, and contouring, which makes use of variable meta-data. It should be noted that use of spatial meta-data typically yields a consistent performance improvement, but performance improvement from variable meta-data can be highly problem specific. To illustrate this, results from early in the simulation and late in the simulation are shown (See <ref type="table" target="#tab_3">Table 2</ref>). The processing time includes the time to read in a data set from disk, perform operations to it, and prepare it for rendering. Rendering was not included because it can be highly dependent on screen size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Comparison of execution models</head><p>Since not all pipelines can successfully execute with dynamic load balancing, we can only compare execution time for those pipelines  that can use dynamic load balancing. Again using the Rayleigh-Taylor Instability simulation, we study the performance of slicing, contouring, thresholding, and clipping. Note that other optimizations were used in this study -slicing and contouring were using spatial and variable meta-data respectively, while thresholding and clipping used subgrid generation for its outputs (See <ref type="table" target="#tab_5">Table 3</ref>). Again, the processing time includes the time to read in a data set from disk, perform operations to it, and prepare it for rendering.  Slicing did not receive large performance improvements from dynamic load balancing, because our use of spatial meta-data eliminated those domains not intersecting the slice, and the amount of work performed per processor was relatively even. We believe that the higher dynamic load balancing time is due to the overhead in multiple pipeline executions. Contouring, thresholding, and clipping, on the other hand, did receive substantial speedups, since the time to execute each of these algorithms was highly dependent on its input domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Generation of ghost data</head><p>This optimization is not a performance optimization; it is necessary to create the correct picture. Hence, no performance comparisons are presented here. Refer back to <ref type="figure" target="#fig_2">Figures 3 and 4</ref> in Section 3.3 to see the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Subgrid Generation</head><p>VisIt's volume renderer processes data in three phases. The first phase samples the data along rays. The input data can be heterogeneous, made up of both rectilinear and unstructured grids. The rectilinear grids will be sampled quickly using specialized algorithms, while the unstructured grids will be sampled slowly using generalized algorithms. The sampling done on each processor uses the data assigned to that processor by the load balancer. Once the sampling has been completed, the second phase, a communication phase, begins. During this phase, samples are re-distributed among processors, to prepare for the third phase, a compositing phase. The compositing is done on a per-pixel basis. Each processor is responsible for compositing some portion of the screen, and the second, communication phase, brings the samples necessary to perform this operation.</p><p>The volume renderer uses the contract to indicate that it has rectilinear optimizations. This will cause the subgrid generation module to create more rectilinear grids, many of them smaller in size than what is typically generated. This then allows the sampling phase to use the specialized, efficient algorithms and finish much more quickly.</p><p>In the results below, we list the time to create one volume rendered image. Before volume rendering, we have clipped the data set or thresholded the data set and used subgrid generation to create the output. <ref type="table" target="#tab_7">Table 4</ref> measures the effectiveness of allowing for control of the minimum grid size (2048 versus 256) with subgrid generation. When subgrid generation was not used, only unstructured grids were created, and these algorithms exhausted available memory, leading to failure with this number of processors.</p><p>It should be noted that the rendering time is dominated by sampling the unstructured grids. This data set can be volume rendered in 0.25 seconds when no operations (such as clipping or thresholding) are applied to it.  The thresholded volume rendering produces only marginal gains, since the fluids have become so mixed that even rectilinear grids as small as 256 elements cannot be placed over much of the mixing region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subgrid Generation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>The scale of the data being processed by VisIt requires that as many optimizations as possible be included in each pipeline execution. Yet the tool's large number of components, including the addition of new plugin components, makes it difficult to determine which optimizations can be applied. VisIt's contract-based system solves this problem, allowing all possible optimizations to be applied to each pipeline execution. The contract is a data structure that extends the standard data flow network design. It provides a prescribed interface that every pipeline component can modify. Furthermore, the system is extensible, allowing for further optimizations to be added and supported by the contract system.</p><p>This system has been fully implemented and deployed to users. VisIt is used hundreds of times daily and has a user base of hundreds of people.       </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>An example pipeline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Shown is a 36 domain data set. The domains have thick black lines and are colored red or green.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>On the left is an opaque picture of the data set. In the middle, the opacity has been lowered. Faces external to a domain (yet internal to the data set) are being rendered. On the right, the faces have been removed. There are 902,134 triangles for the middle surface and only 277,796 for the right surface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: On the left is a contour plot of an element-centered quantity where ghost elements were not generated. Cracks in the contour surface occur along domain boundaries. On the right, ghost elements were generated and the correct picture was generated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>On the left is a domain without ghost elements. On the right is the same domain with ghost elements added (drawn in yellow). VisIt combines the ghost elements with the domain's real elements into one large domain for efficiency purposes for the filters downstream as well as simplicity of coding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>On the left, there is rectilinear grid with portions removed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>void avtXYZFilter::ModifyContact(avtContract *c) { c-&gt;SetCanDoDynamic(false); c-&gt;SetGhostType(Element); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>This is a slice of the simulation at late time. Light fluid is colored blue, heavy fluid is colored red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>A contour at early simulation time. This contour separates the light and dense fluids.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>A contour at late simulation time. This contour separates the light and dense fluids.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Pictured here is the simulation with one portion clipped away. Light fluid is colored blue, heavy fluid is colored red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Pictured here is the simulation with the light fluid removed using the threshold operation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Pictured here is a volume rendering of the simulation after being clipped by a plane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 :</head><label>13</label><figDesc>This is a volume rendering of the simulation after thresholding by a distance variable to remove elements outside a cylinder.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>The members of VisIt's contract data structure described in previous sections.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Measuring effectiveness of reading the optimal subset of data</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Measuring performance differences between static and dynamic load balancing</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 4 :</head><label>4</label><figDesc>Measuring effectiveness of grid size control with subgrid generation</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGEMENTS</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">An extended data-flow architecture for data analysis and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lloyd</forename><forename type="middle">A</forename><surname>Treinish</surname></persName>
		</author>
		<idno>RC 20001</idno>
		<editor>IBM T. J. Watson Research Center</editor>
		<imprint>
			<date type="published" when="1995-02" />
			<pubPlace>Yorktown Heights, NY, USA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Research report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Large-scale data visualization using parallel data streaming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kristi</forename><surname>Brislawn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Geveci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">Charles</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Papka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Graph. Appl</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="34" to="41" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">I/o optimal isosurface extraction (extended abstract)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi-Jen</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;97: Proceedings of the 8th conference on Visualization &apos;97</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page">293</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Visualization in a parallel processing environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Edwards</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit User&apos;s Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Inc</forename><surname>Kitware</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An application architecture for large data visualization: a case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amy</forename><surname>Henderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Ahrens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVG &apos;01: Proceedings of the IEEE 2001 symposium on parallel and large-data visualization and graphics</title>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="125" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Interactive investigation of fluid mechanics data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><forename type="middle">M</forename><surname>Legensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;90: Proceedings of the 1st conference on Visualization &apos;90</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="435" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A sorting classification of parallel rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Ellsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Graph. Appl</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="23" to="32" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Global static indexing for realtime exploration of very large regular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randall</forename><forename type="middle">J</forename><surname>Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing &apos;01: Proceedings of the 2001 ACM/IEEE conference on Supercomputing (CDROM)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="2" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The design and implementation of an object-oriented toolkit for 3d graphics and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;96: Proceedings of the 7th conference on Visualization &apos;96</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page">93</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Out-of-core algorithms for scientific visualization and computer graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization 2002 Course Notes</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The application visualization system: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Faulhaber</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">H</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andries</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
