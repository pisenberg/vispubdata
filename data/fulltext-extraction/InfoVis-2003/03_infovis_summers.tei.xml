<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Experimental Evaluation of Continuous Semantic Zooming in Program Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">L</forename><surname>Summers</surname></persName>
							<email>summers@hpc.unm.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><forename type="middle">E</forename><surname>Goldsmith</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">P</forename><surname>Caudell</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Center for High Performance Computing</orgName>
								<orgName type="institution">The University of New</orgName>
								<address>
									<country key="MX">Mexico</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Psychology The University of New Mexico Steve Kubica ‡ Khoral, Inc</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">The University of New</orgName>
								<address>
									<country key="MX">Mexico</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">IEEE Symposium on Information Visualization</orgName>
								<address>
									<addrLine>October 19-21</addrLine>
									<postCode>2003, 2003</postCode>
									<settlement>Seattle</settlement>
									<region>Washington</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Experimental Evaluation of Continuous Semantic Zooming in Program Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.1.2 [User/Machine Systems]: User/Machine Systems-[H.5.2]: User Interfaces-Graphical user interfaces (GUI)</term>
					<term>Theory and methods D.2.6 [Programming Environments]: Graphical environments-[D.1.7]: Visual Programming Program visualization</term>
					<term>Human subjects testing</term>
					<term>Visual program languages</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents the results of an experiment aimed at investigating how different methods of viewing visual programs affect users&apos; understanding. The first two methods used traditional flat and semantic zooming models of program representation; the third is a new representation that uses semantic zooming combined with blending and proximity. The results of several search tasks performed by approximately 80 participants showed that the new method resulted in both faster and more accurate searches than the other methods.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Programs are complex and often difficult to understand. This difficulty hinders the creation of complex programs, as well as the understanding of existing programs, as defined by speed and accuracy on a visual search test. Although professional programmers might be able to examine raw code and decipher its essence, inexperienced programmers such as scientists and engineers, who only program to better understand their area of interest, have a need for tools to clarify the meaning of code.</p><p>In this study, we examined how three different methods of visualizing programs affected users' understanding of the programs. As a first step in exploring new visual representations for programs, this study started with an already available abstraction of standard computer code: visual programs. <ref type="bibr">Traditionally</ref>  quires space for its visual representation, real estate is at a premium. Thus large and complex visual programs can take up a large amount of space. Traversing the components and understanding the relationships among program elements is difficult for large visual programs.</p><p>To alleviate this problem, some visual programming environments have implemented procedural programming, a multiresolution technique. Similar to their use in textual programming languages, procedures allow program elements to be grouped by function, increasing readability and encapsulating complex sections of a program. <ref type="figure" target="#fig_1">Figure 2</ref> shows the same visual program as <ref type="figure">Figure 1</ref> with a procedure and its contents. This method, defined by Bederson and Hollan as semantic zooming <ref type="bibr" target="#b0">[Bederson et al. 1996;</ref><ref type="bibr" target="#b8">Muthukumarasamy and Stasko 1995]</ref>, improves functional grouping and saves real estate. By encapsulating related program elements this method can reasonably be expected to improve overall program understanding.</p><p>The principle behind semantic zooming (SZ) is that, as the viewpoint zooms on an area the details not only become more distinct, as would be expected by virtue of being "closer," but the representation changes as well. For example the procedure shown in the upper left window of <ref type="figure" target="#fig_1">Figure 2</ref>, has been opened, or zoomed in the lower right picture. Although this example was arranged carefully so as not to obscure any of the top level program by the contents of  <ref type="figure">Figure 1</ref> with some of the program elements encapsulated into a procedure. Bottom: The contents of the procedure. the procedure, it is evident that more encapsulated elements in the procedure, or more open procedures would obscure representation.</p><p>In textual programs, procedures often completely obscure the calling code, by virtue of being large and usually in different areas of the program or in another file altogether. Once again, while splitting the editor window may allow viewing of multiple levels simultaneously, this is severely limited by available screen area.</p><p>The principal drawback, therefore, with this method is that, when viewing the top level program, the contents of the procedure are hidden. Likewise, when viewing the contents of the procedure, the top level structure is hidden.</p><p>Many methods have been applied to solve this problem. Examples include SHriMP <ref type="bibr" target="#b14">[Storey et al. 1997]</ref> and Continuous Zoom <ref type="bibr" target="#b4">[Dill et al. 1994]</ref>. SHriMP is a system integrating pan+zoom and fisheye-view visualization approaches to explore nested graphs. Continuous Zoom incorporates a fisheye-view method with multiple focus points and a smooth transitions.</p><p>This paper introduces the method called continuous semantic zooming (CSZ) <ref type="bibr" target="#b16">[Summers 2002]</ref>, which differs from these approaches in that it is a technique for viewing hierarchical data which could, but is not required (and as presented here, does not) use distortion techniques. CSZ could be used as an ancillary method to other systems, or can be integrated into new, stand-alone systems.</p><p>The remainder of this paper describes the method, and reports the results of a study with human subjects comparing CSZ to both traditional semantic zooming representations and flat representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Continuous Semantic Zooming</head><p>The main drawback of traditional multiresolution techniques for grouping, such as procedures, both in visual programs and text programs, is that the different level representations are distinct and separate. Text programs, such as those written in C, often use procedures and subroutines to group and encapsulate functionally related code. In these programs the procedure definition and the procedure call are in different places in the file or in separate files altogether. Visual programs also encapsulate procedures in ways that obscure other levels of detail, such as having to open another window to dis-play procedure details, often hiding the original program structure. In this traditional form of semantic zooming the transition between views of the program is typically abrupt and often disorienting to the user <ref type="bibr" target="#b13">[Sindre et al. 1993]</ref>.</p><p>In contrast, continuous semantic zooming combines semantic zooming and blending or morphing to allow the user to view the details of a procedure while still viewing the surrounding higher level constructs. This combination also allows a smooth transition between view levels, helping the user maintain the mental model of the relationships between the different representations. CSZ uses viewpoint proximity to trigger a viewing mechanism, such as transparency <ref type="bibr" target="#b11">[Rekimoto and Green 1993]</ref>, lenses <ref type="bibr" target="#b12">[Robertson and Mackinlay 1993;</ref><ref type="bibr" target="#b10">Rao and Card 1994;</ref><ref type="bibr" target="#b5">Fishkin and Stone 1995]</ref>, or environment distortion <ref type="bibr" target="#b7">[Leung and Apperley 1994;</ref><ref type="bibr" target="#b1">Carpendale et al. 1997]</ref>, which exposes the details encapsulated in a procedure while allowing the higher level constructs to remain visible in the viewing area. <ref type="figure" target="#fig_2">Figure 3</ref> shows an example of the progression of continuous se- mantic zooming using transparency. As the user comes closer to the procedure object, the contents of the procedure appear. As the user moves closer still, the procedure object fades even further, while the lower level contents become even more visible.</p><p>Contrast this example with an illustration of the same program in <ref type="figure" target="#fig_3">Figure 4</ref>. To assist the overall comprehension of programs, a method is needed for simultaneous viewing both a procedure definition and the context in which it is called. CSZ allows a gradual transition between resolutions of the procedure, thus minimizing user disorientation and confusion. Additionally CSZ allows the user to view both the procedure and the context in which it is called with minimal obscuration. The primary mechanism used by CSZ to trigger this transition is proximity. The closer one comes to an encapsulated object the more detailed it becomes. Since closer also implies larger (due to perspective) the details of the proximate object are visible, while the distance to other objects remains approximately the same and hence so does their relative detail. This multilevel view allows the user to see some details while viewing higher level structure, and to see some of the higher level structure while viewing procedure details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Evaluating CSZ</head><p>We compared CSZ with two other methods of program representation: flat and semantic zooming (SZ).</p><p>The flat program representation contained no procedures. It represented the same program as the other two but with all procedures exploded into their constituent program elements. The logical grouping of the program was maintained, i.e., sections of related code, that might have been in a procedure, were grouped together in the flat program. See <ref type="figure" target="#fig_4">Figure 5</ref>. Three empirical studies were run, two of which were pilot studies. In each study, subjects were asked to find program elements that were responsible for creating specific output results. Time to find the element and accuracy were the primary measures of performance. We assumed that these performance measures would be related to program understandability. We argue that, in studies of this type, improved performance is most directly related to speed and accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">SGPL</head><p>For these experiments a simple graphics programming language (SGPL), inspired by the Logo <ref type="bibr" target="#b9">[Papert 1980</ref>] graphics language, was developed. See <ref type="figure">Figure 6</ref>. In this language each program element is <ref type="figure">Figure 6</ref>: Picture of an animal and the program that produced it. capable of drawing one polygon. The available polygons are lines, triangles, rectangles, and ovals. The orientation, size, and aspect ratio of each polygon is adjustable. The polygon's relationships to one another are determined by the connections between program elements. The polygons produced by any two connected program elements must, by definition, touch each other. So the leg of the animal in <ref type="figure">Figure 6</ref> touches the ground, the body the leg, and the head the body. Note that this property is not commutative. The animal's other leg touches the ground, but the program element that draws it is not connected to the program element that draws the ground, only to the body.</p><p>The program designer has control of the position, orientation, size, aspect ratio, and type of the polygon. The representation on the face of each program element, however, only displays the type, orientation, and aspect ratio of the polygon, as seen in <ref type="figure">Figure 6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Pilot Studies</head><p>Two pilot studies were run to calibrate the methods. The studies compared traditional SZ and a flat representation of an SGPL program. We hypothesized that hierarchical representation of data, especially programs, would lead to increased understanding of those data, as represented by decreased time and increased accuracy in finding specific data. The pilot studies were, therefore, designed to compare time to target and accuracy of traditional SZ and flat representations of an SGPL program. The pilot studies were used to calibrate the methods for future studies. An informal sample of 16 subjects was drawn from friends and colleagues.</p><p>A static, 2D representation of an SGPL program was presented to subjects using Microsoft PowerPoint. In the flat version all program elements were at the same level, spread across several pages. Different pages could be accessed by clicking on arrow icons in the corners of each page, thereby simulating scrolling the screen. The SZ representation allowed users to click on procedures, replacing the page with a new page containing the procedure program elements. A "back" button allowed the user to back out of procedures.</p><p>One polygon would be highlighted on a paper copy of the picture "produced" by the program on-screen, and the subject asked to find the program element that drew the highlighted polygon. The sub-jects' response time from when the picture was revealed to calling out a program element number was measured. The test consisted of ten iterations of this procedure, each time asking the subject to locate a different highlighted polygon.</p><p>One observation made during the first pilot study was that subjects would often fall back on pure pattern matching by simply looking for a polygon that matched the target polygon and ignore the structure of the program. While this is a useful method to find objects, it is seldom useful for examining program code because text representation is quite uniform. The program structure is usually the main clue as to what a particular code fragment does.</p><p>Building on these experiences, the second pilot study increased overall complexity and avoided easily recognizable features. The second pilot study was run with the same parameters and a revised, more complex picture. A more complex picture, consequently, was produced by a more complex program. The new program/picture combination relied more on similar objects to better simulate the uniform nature of a program (many similar code fragments with slightly differing functionality) and no "unique" elements as were present in the first pilot picture.</p><p>Observation of the second pilot study showed an increased reliance on program structure for element identification, and increased search time that helped minimize the effect of administrator, instrumentation, and subject delays. This pilot study also showed that subjects were capable of dealing with significantly more complex programs without becoming confused. It was determined, therefore, that the main study should consist of an even more complex program, with more self-similar features to reduce even further the reliance on visual pattern matching.</p><p>The main result of these pilot studies was to show that the experimental methods were sensitive enough to detect significant differences in time and accuracy, and that time and accuracy were valid measures of performance. They both showed that SZ was significantly faster and more accurate than flat. These pilots also pointed out the areas where proper design of the target picture would result in more accurate and representative results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Main Study</head><p>The study extended the pilot studies by adding a third dimension, and a third representation: CSZ. While the two pilot studies used static, 2D representations of a program, constructed in Microsoft PowerPoint, the study used a fully functional program displayed in a 3D virtual environment (VE). This allowed a natural introduction of the concept of proximity.</p><p>The program was an adaptation of the visual programming language Khoros Cantata, by Khoral, Inc. Cantata was modified to export representation and control of the visual program workspace to the VE. The VE could load, start, stop, clear, etc., the workspace, and all images and program element placements were transmitted back to the VE. This allowed the VE to act as an alternate display, alongside Cantata's internally generated X window display.</p><p>The SGPL program elements were made with customized Cantata program elements designed to show orientation and aspect ratio of the polygon on the face of the program element. Additional "screen" program elements were created that showed the aggregate contents of either a procedure or the entire program, depending on placement. In this way the finished picture, as well as sub-pictures consisting of the polygons drawn by a procedure were also transmitted to the VE. <ref type="figure">Figure 6</ref> shows an example of this 3D interface.</p><p>The VE used was Flatland <ref type="bibr" target="#b3">[Caudell 2000;</ref><ref type="bibr" target="#b2">Caudell and Summers 2003</ref>], a development of the University of New Mexico Department of Electrical and Computer Engineering and the UNM Center for High Performance Computing Visualization Laboratory. Flatland is a general purpose, highly configurable virtual environment which allows run-time loading of user generated objects into a centrally managed scene graph. The Cantata interface is one such object.</p><p>The study used a between-subjects design, with each subject tested under only one representation. A total of 60 subjects were randomly assigned to three methods, 20 per method.</p><p>The experiment was divided into 14 tasks, similar to the pilot tasks. The subject was shown the output of the program (a completed picture) with one highlighted polygon and asked to find the program element that drew that polygon. <ref type="figure" target="#fig_5">Figure 7</ref> shows the picture used for the study. This picture contained 164 polygons, and the Each procedure element consisted of between two and eleven subelements, and the maximum procedure depth was three.</p><p>Two new features were added to the study picture design.</p><p>• Multiple identical objects were included to help eliminate simple pattern matching. Subjects were forced to follow the program structure to pick the correct element.</p><p>• Even more complicated picture designs were created, with an emphasis on elements that were self similar. This required that the subject examine the program structure in detail to differentiate between two similar, but not identical, structural elements.</p><p>Because the entire program was never completely visible, a method for moving the viewpoint around the program was required. In the 2D case used in the pilot studies this was accomplished by "paging" between different sections of the program using buttons. In the 3D environment of the main study the viewpoint change was continuous, with the viewpoint position controllable from the keyboard.</p><p>The flat method was restricted to movement in a plane parallel to the the program layout. Thus the viewpoint was always held a fixed distance from the program elements. With the SZ and CSZ methods movement was allowed perpendicular to the plane of the program. All movement was controlled using the keyboard arrow keys, with the shift key as a modifier. To move in the plane parallel to the program, the four arrow keys caused movement of the viewpoint in the appropriate direction. For movement perpendicular to the plane of the program the shift key was used to modify the up and down arrow keys into in and out functions, respectively. In all cases the speed of movement was subject controlled by repeated use of the appropriate key. A "stop" key (in this case, the Home key) was available to recover from runaway movement.</p><p>To "open" a procedure the subject would move closer to the plane of the program. Using the SZ method this was an abrupt transition to view the contents of a procedure, with all further movement restricted to the interior of the procedure (until the user backed out of the procedure again). This restriction emulated the all-ornothing nature of standard semantic zooming.</p><p>Using the CSZ method the transition was continuous, with a procedure gradually fading to transparency the closer the viewpoint came. No restrictions on in-plane movement were used, allowing the user to view the procedure and its neighbors from any position. This animation of continuous motion, with blending effects, meant that more time was required to move into and out of procedures when using CSZ than when using SZ, with the anticipated benefit that the relationships between the different level views would be better understood by the subject. This time difference lies at the crux of the experimental objectives: would the CSZ method increase subject performance sufficiently to offset the extra time required to transition between program levels. <ref type="figure" target="#fig_8">Figure 10</ref> shows a screen capture from the study using the CSZ method. Notice that the central program element is nearly transparent. This allows the user to see the procedure's component parts. At the same time some of the surrounding procedures are slightly transparent, and their component parts can be indistinctly seen.</p><p>In all three methods the mouse was used to point at the desired program element and select it, once it was on the screen. Upon selection the time and the selected program element were automatically recorded, and the next task loaded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The Experiment</head><p>Sixty five subjects participated in the study. Subjects were recruited from second semester programming classes, thereby fulfilling the inexperienced user requirement.</p><p>To speed the data collection process, four machines were used. Subjects were randomly assigned to the three conditions, and were assigned to machines in order of appearance.</p><p>The subjects were given five practice tasks, detailed written instructions, five more practice tasks, then performed the 14 tasks of the study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>Of the 65 participating subjects, the results from three subjects were dropped from the study, because of incomplete runs (two) and because of outliers (one). Two more subjects were randomly selected and dropped to equalize the number of subjects used for each method. <ref type="figure" target="#fig_6">Figure 8</ref> shows the mean response times and the number of correct answers for each method. The times for CSZ and SZ were essentially the same, with the flat method taking a little over 40% longer. The flat and CSZ methods, however, were more accurate than SZ. <ref type="figure" target="#fig_7">Figure 9</ref> shows a scatter plot of time vs. number correct. Each point shows the mean time and number correct for each subject. The method is represented by point shape and color. As can be seen, the CSZ points tend to group in the low time, high accuracy corner of the graph, with one outlier. The SZ points are well grouped in the low time, low to middle accuracy section of the graph. The flat  points tend to group at the high accuracy end, with large variations in time and several outliers. <ref type="figure">Figure 11</ref> abstracts the data one step further by depicting the mean time and accuracy of all subjects shown in <ref type="figure" target="#fig_7">Figure 9</ref>. This figure clearly illustrates that the CSZ method has the speed of the SZ method and the accuracy of the flat method.</p><p>A one-way analysis of variance (ANOVA) was conducted to evaluate differences in time to respond among the three conditions. The ANOVA was significant, F(2, 57) = 20.43, p &lt; .001. Followup tests were conducted to evaluate pairwise differences among the means. A Tukey's adjustment for post hoc comparisons showed that CSZ was significantly faster than flat (p &lt; .05) and hierarchical was significantly faster than flat (p &lt; .05), but no differences between CSZ and hierarchical.</p><p>A one-way ANOVA performed on accuracy showed a significant effect, F(2, 57) = 9.88, p &lt; .001. Follow-up tests using Tukey's adjustment showed that CSZ was significantly more accurate than hierarchical (p &lt; .05) and flat was significantly more accurate than hierarchical (p &lt; .05); no difference was found between CSZ and flat.</p><p>In order to consolidate time and accuracy onto a single measurement, Z-scores <ref type="bibr" target="#b6">[Hays 1988</ref>] of both time and inaccuracy (to make both measures more desirable as the value decreases), were averaged together. <ref type="figure" target="#fig_1">Figure 12</ref> shows a plot of these mean Z-scores. Note that the more negative the score, the higher the value, since the goal is a short time to completion and a small inaccuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion</head><p>This section will discuss both the experiment and the results of the experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Methods</head><p>The task environment constructed appeared to be appropriate for comparing subjects' performance across the three methods. The complexity, repeated objects, and self similarity forced subjects to use the structure of the program to determine the correct answer, rather than just scrolling through the workspace, pattern matching the desired polygon. This more closely matches the behavior of a programmer looking at text code, or a complex visual program, where pattern matching is of limited usefulness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Results</head><p>The results clearly show that the CSZ method is more accurate than than the SZ method, while being faster than the flat method, which would seem to be an excellent indication that the subject's understanding of the program was better using the CSZ method. This is <ref type="figure">Figure 11</ref>: Scatter plot of mean time to completion and mean number correct for each method. This shows a summary of information presented in <ref type="figure" target="#fig_7">Figure 9</ref> Figure 12: Mean of time and inaccuracy Z-scores. Note that the goal is a short time to completion and a small inaccuracy, therefore the more negative the score, the higher the value. clearly shown by the plots in <ref type="figure" target="#fig_6">Figures 8 and 11</ref>, and supported by the statistical analysis of means shown in Subsection 6. Subsequent analysis of the path-to-target data collected during the study shows the reason for the time and accuracy differences.</p><p>Subjects using the Flat method were extremely slow in the first few tasks, then their speed picked up as they progressed to the later tasks. This pronounced learning curve dramatically increased the time for subjects using the Flat method. They were still, however, slower than the other two methods, even on the later tasks.</p><p>Subjects using the SZ method showed comparable accuracy results to those using the CSZ method for simple drill-down tasks. The accuracy difference between them appeared when information was required from multiple sources in the program to select the correct target. The subjects using the SZ method rarely even looked at these required data, while those using CSZ evidently used it in their assessments.</p><p>The Z-scores shown in <ref type="figure" target="#fig_1">Figure 12</ref> are weighted evenly between accuracy and time. Since comprehension is the overall goal, accuracy would seem to be more important than speed, and a different weighting might deliver a more meaningful result. Given enough weight on accuracy, the Flat method will even be shown as preferable to the SZ method, in this case. The question becomes how to distribute the weighting.</p><p>Although the present study used a simple visual programming paradigm, we believe the results will generalize to more traditional imperative programs. The hierarchical structure designed into the study is commonly used in C programming, for example, and the structure is easily extended to cover objects for object oriented paradigms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Future Work</head><p>Several directions are available for future work. First, it would be interesting to further test the key difference between SZ and CSZ to ascertain why the subjects using SZ did not make use of all the required information. These investigations can take the form of making the remote required information more obvious while using the SZ method, or making it less obvious when using the CSZ method. Such test would undoubtedly suggest other directions as well.</p><p>The CSZ method also needs to be investigated with dynamic, rather than static programs, to see how it might help increase understanding of executing programs. This could be easily done with the current test setup, as the capability is already there and was merely hidden from the subjects of this study.</p><p>Another direction is to attempt similar tests using representations of textual programs. Since a great deal of programming is done using textually based programming languages, defining how the CSZ technique can be used and its efficacy with such programs is essential.</p><p>Finally, we would like to expand the CSZ technique to work with more real-world type problems. Visualizations of parallel programs <ref type="bibr" target="#b15">[Summers et al. 2000]</ref> should benefit greatly from this method, and integration with those visualization systems is imminent.</p><p>This work should provide a base from which to extend experimental procedures with the goal of creating a test bed for performing empirical research on methods of representation. Now that CSZ has been shown to be a viable method for viewing hierarchical data further experiments can be conducted with more specialized program environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>Understanding programs is difficult, especially for inexperienced users, and particularly if they have not written the code. A traditional approach to facilitating understanding has been to encapsulate functionality inside procedures and subroutines. This approach draws boundaries between functional elements and avoids distractions from unrelated pieces of code.</p><p>One drawback, however, with partitioning programs in this way is that those same boundaries make it difficult to see the overall context of the procedure while examining it's details. Likewise, the boundaries tend to lock out the details when viewing the overall structure. The transition between overview and detail level is also quite abrupt.</p><p>Continuous semantic zooming allows a continuous change between these levels which helps the user retain contextual relationships, and allows a limited amount of crossover.</p><p>We have presented an empirical study framework, as well as the first set of studies for exploring problems of this type. These studies supported the thesis that CSZ uses the attributes discussed above to provide an opportunity for greater understanding of programs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>visual programs have been represented as large, flat layouts of program elements, which consist of functional icons and program flow connections. See Figure 1. Because each component in the visual program re-Figure 1: A crowded, difficult to understand visual program workspace. Screen real estate is very valuable in a visual program, prompting the use of methods to compress programs into less space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Top: The same program as shown in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Three successive views illustrating the concept of continuous semantic zooming: (a) shows a top level view; (b) shows a top level view, when CSZ has been triggered and details of the procedure are visible; (c) shows a detailed view of the procedure, with other, higher level program elements still visible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Two successive views illustrating the concept of semantic zooming: (a) shows a top level view; (b) shows the detailed view of the procedure. Notice that, unlike CSZ, SZ does not permit intermediate views. Likewise, the second, encapsulated procedure's contents remain hidden.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Two views, using the hierarchical representation presented inFigures 3 and 4, showing, in (a), the hierarchical view with procedures and, in (b), the corresponding flat view where the procedures have all been "expanded" in place.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Picture used for the study. Note the large amount of selfsymmetry and the multiple identical objects. corresponding program consisted of approximately 200 elements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Mean time to completion and number correct for each method. The vertical axis represents time or number correct for each set of bars, appropriately.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Scatter plot of mean time to completion and number correct for each subject. The method used by each subject is indicated by bullet type and color.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Screen capture from a run of the study. The central program element is almost completely transparent and it's component parts can be seen, while surrounding program elements are just beginning to fade.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Acknowledgements</head><p>James Lin designed and conducted the second pilot study. Mark Young of Khoral, Inc., designed and implemented a large portion of the Cantata-Flatland interface. The University of New Mexico Center for High Performance Computing contributed valuable resources toward this research.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The studies were designed to compare three methods of viewing the same basic program. The experimental results suggest that CSZ is indeed an improved method for looking at these types of programs, and these results should be extensible to more generalized programming languages. At the same time, the experimental procedures themselves have been shown, through experience, observation, and internal consistency, to be useful for comparisons of these types of paradigms.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Pad++: A zoomable graphical sketchpad for exploring alternate interface physics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Hollan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Perlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Furnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of visual languages and computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1045" to="926" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Extending distortion viewing from 2D to 3D</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S T</forename><surname>Carpendale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Cowperthwaite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">D</forename><surname>Fracchia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="42" to="51" />
			<date type="published" when="1997-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Homunculus project home page</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">P</forename><surname>Caudell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Summers</surname></persName>
		</author>
		<ptr target="http://www.hpc.unm.edu/homunculus" />
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A guide to flatland</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">P</forename><surname>Caudell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
	<note>Unpublished Technical Document</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A continuously variable zoom for navigating large hierarchical networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bartram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Henigman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Systems, Man, and Cybernetics</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="386" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Enhanced dynamic queries via movable filters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fishkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Stone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI&apos;95, ACM Conference on Human Factors in Computing Systems</title>
		<meeting>CHI&apos;95, ACM Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="415" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">L</forename><surname>Hays</surname></persName>
		</author>
		<title level="m">Statistics for psychologists</title>
		<editor>Holt, Rienhart and Winston</editor>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
	<note>4th ed.</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A review and taxonomy of distortion-oriented presentation techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">K</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Apperley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="126" to="160" />
			<date type="published" when="1994-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Visualizing program executions on large data sets using semantic zooming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Muthukumarasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
		<idno>GIT- GVU-95-02</idno>
		<imprint>
			<date type="published" when="1995-01" />
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Mindstorms: children, computers, and powerful ideas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Papert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980" />
			<publisher>Basic Books</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>ISBN 0465046274</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The table lens: Merging graphical and symbolic representations in an interactive focus+context visualization for tabular information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI&apos;94, ACM Conference on Human Factors in Computing Systems</title>
		<meeting>CHI&apos;94, ACM Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="318" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The information cube: Using transparency in 3d information visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rekimoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Annual Workshop Information Technologies and Systmes (WITS &apos;93)</title>
		<meeting>the Third Annual Workshop Information Technologies and Systmes (WITS &apos;93)</meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The document lens</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of UIST&apos;93, ACM Symposium on User Interface Software and Technology</title>
		<meeting>UIST&apos;93, ACM Symposium on User Interface Software and Technology</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="101" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Onion graphs: Aesthetics and layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sindre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">G</forename><surname>Jokstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding, IEEE/CS Symposium on Visual Languages (VL &apos;93)</title>
		<meeting>eeding, IEEE/CS Symposium on Visual Languages (VL &apos;93)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="287" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On integrating visualization techniques for effective software exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">D</forename><surname>Fracchia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Information Visualization</title>
		<meeting>IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="38" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A survey of parallel program performance evaluation techniques using visualization and virtual reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Summers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Greenfield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, IEEE Aerospace conference</title>
		<meeting>IEEE Aerospace conference</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Visualization of Programs Using Proximity to Trigger Continuous Semantic Zooming: An Experimental Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Summers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>The University of New Mexico</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
