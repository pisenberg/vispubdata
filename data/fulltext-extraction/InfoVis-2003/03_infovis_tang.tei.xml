<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Design Choices when Architecting Visualizations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Diane</forename><surname>Tang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Stolte</surname></persName>
							<email>cstolte@cs.stanford.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Bosch</surname></persName>
							<email>rbosch@vmware.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Design Choices when Architecting Visualizations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.1.m [Information Systems]: Models and Principles-Miscellaneous information visualization</term>
					<term>system architecture</term>
					<term>semantic meta-data</term>
					<term>data transformations</term>
					<term>design tradeoffs</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper, we focus on some of the key design decisions we faced during the process of architecting a visualization system and present some possible choices, with their associated advantages and disadvantages. We frame this discussion within the context of Rivet, our general visualization environment designed for rapidly prototyping interactive, exploratory visualization tools for analysis. As we designed increasingly sophisticated visualizations, we needed to refine Rivet in order to be able to create these richer displays for larger and more complex data sets. The design decisions we discuss in this paper include: the internal data model, data access, semantic meta-data information the visualization can use to create effective visual encodings, the need for data transformations in a visualization tool, modular objects for flexibility, and the tradeoff between simplicity and expressiveness when providing methods for creating visualizations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the past five years, we have tackled many real-world analysis problems using visualizations built within the Rivet visualization environment <ref type="bibr" target="#b2">[3]</ref>, including the Polaris user interface <ref type="bibr" target="#b23">[24]</ref> <ref type="bibr" target="#b24">[25]</ref> and several multiscale visualizations <ref type="bibr" target="#b25">[26]</ref>. Over this period, as we have gained experience and tackled successively more complex and difficult problems, we have needed to revisit certain design issues.</p><p>The design choices we faced as we refined Rivet ran the gamut from architecture refinements for handling more sophisticated data sets and visualizations to implementation issues. This paper discusses the following major design issues:</p><p>1. Data Model: a data model can simplify the user's task by providing an easily understood abstraction and flexibility in the analyses that can be performed on the data.</p><p>2. Simplification of Data Access: the visualization tool should adapt to the user and make data access easy, rather than making the user adapt to the tool.</p><p>3. Sophisticated Meta-data: to create effective visualizations and support the analysis process, visualizations can take advantage of more semantic information than is usually provided. <ref type="bibr" target="#b3">4</ref>. Data Transformation: because users want to be able to transform data during the process of analysis, visualizations need to provide transformation capabilities. 5. Separation of Data, Visualization, and Interaction: finding the right granularity and API of objects allows us to combinatorially interchange and combine objects for maximal flexibility and extensibility. 6. Specification and Scripting: rather than providing only a procedural or only a declarative interface, we gain power and simplicity by using specification and scripting together. In addressing these issues, we faced a tradeoff not only between performance and flexibility, but also between the amount of user expertise required and the range of expressibility. We discuss these tradeoffs throughout the paper.</p><p>In designing a visualization, there is a spectrum ranging from custom visualizations to general visualization environments. While the design issues presented in this paper are relevant to the entire spectrum, the final choice of how to handle the issues may differ depending on where in the spectrum the target lies. Our goal in this paper is not only to share our design decisions, but also to discuss alternative choices, thus reducing the duplication of effort and the time needed to create visualizations by researchers in the future.</p><p>The layout of the rest of this paper is as follows. We first present a review of the original architecture of Rivet <ref type="bibr" target="#b2">[3]</ref>. We then visit each design decision in turn, presenting the problems we faced, the possible choices and their ramifications, and the decision we made and the associated advantages and disadvantages. Related work will be presented throughout these sections. We conclude and present directions for future work in Sections 9 and 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background: Rivet</head><p>The original architecture for Rivet consisted of four basic portions: the data model, the visual objects, the mapping from data values to visual representations, and the user interaction components <ref type="bibr" target="#b2">[3]</ref> <ref type="bibr" target="#b3">[4]</ref>. The key design decisions in Rivet focused on modularity: choosing the right granularity for objects in order to maximize flexibility.</p><p>Originally, Rivet used only basic meta-data consisting of field names and types and a simple relational data model consisting of the standard tuples and tables. Because of the focus on computer systems data, which often lives in log files, the only data import functionality was regular expression parsing of flat text files. Rivet also provided internal transformations, which, because they took tables as input and output, could be composed into an arbitrary transformation network, with every intermediate result visualizable.</p><p>Visually, Rivet used the notion of metaphors and primitives: Metaphors draw tables by laying out tuples spatially within the display, and primitives generate a visual mark for each individual tuple. Selectors identify data subsets and can be used to determine which tuples to highlight or elide.</p><p>While the issues we discuss in this paper impact the above design choices, other portions of Rivet remained the same. Rivet still uses encodings to map data values to visual representations, with metaphors using spatial encodings to determine the position and bounding box of tuples, and primitives using retinal encodings to determine the visual properties, such as color and size, when rendering a particular tuple.</p><p>Rivet uses an event model, with objects raising events in response to user actions such as mouse clicks. To build visualizations, IEEE Symposium on Information Visualization 2003, <ref type="bibr">October 19-21, 2003</ref>, Seattle, Washington, USA 0-7803-8154-8/03/$17.00 Â©2003 IEEE users write scripts that determine how data is imported, link data to visual objects, and bind actions to these events to create the effects of the user interaction. These actions can consist of an arbitrary sequence of operations, as created by the script-writer. For example, the script-writer chooses whether a mouse event that leads to a zoom corresponds to a semantic or optical zoom. Rivet also uses the listener model to propagate updates, so that if the user changes a filter, all associated data transformations are updated, which then updates the associated visual representations.</p><p>This architecture allowed us to create many interactive visualizations for exploratory data analysis. However, as our visualizations became more sophisticated, we needed to revisit our design decisions in order to provide increased functionality and generate more effective visualizations. The rest of the paper discusses these design decisions both in general and within the context of Rivet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Data Model and Representation</head><p>The first design decision is what data model to use internally within the visualization system. This decision impacts many later design decisions.</p><p>One common data model used in visualization systems, especially general visualization tools, is the relational model. In the database community, the term "relational model" encompasses several concepts: the actual data structure (tuples and relations), the data organization (normalized versus de-normalized schemas 1 ), and the relational algebra and query language for data manipulation. In this section, we focus on the first two concepts of the relational model and the associated advantages and disadvantages, as well as other possible data model choices. Data query and analysis are discussed further in Section 6. The standard relational model structures data using unordered sets of tuples (e.g., facts or rows in a table), and tables consisting of homogeneous tuples. This structure is insufficient for visualizations because orderings are often needed for drawing purposes: tuples are drawn in back-to-front order, and nominal domains, which are traditionally un-ordered, must sometimes be ordered for display, such as when drawing axis labels. Thus, in Rivet, we enhance the relational model with these orderings.</p><p>Beyond just the basic objects in the data model, there is also how the data is organized, i.e., the data schema. In addressing this issue, lessons from the database community are applicable. Transaction processing (OLTP) was one of the first database applications. Because OLTP requires quick update capabilities, normalized data schemas are optimal: usually only one table needs to be updated. In contrast, analytical processing (OLAP) often consists of retrieving many tuples across many relations, which requires many expensive joins when using a normalized schema. Thus, a de-normalized organization is often more optimal. Given our focus on analytical systems, from here on out we assume that the data is de-normalized and discuss the advantages and disadvantages given this assumption. We made this choice consciously, since the data used for analysis purposes are often stored in this format (e.g., datacubes that are regularly computed from historical OLTP databases), and analysts can create de-normalized views of databases as needed.</p><p>One advantage to using the relational model is that it provides access to many existing datasets, from computer systems logs to biological data to corporate data warehouses, that are already stored in databases without needing any additional translation. Another related advantage is that because the relational model is so prevalent, transferring data between tools also becomes easier.</p><p>Conversely, one disadvantage to this model is that it assumes some homogeneity to the data. Some types of data, such as graphs or ragged trees, are difficult to represent using the relational model. This limitation is especially problematic since this type of data is some of the richest and most interesting data to visualize. For these data structures, having a custom data model may be a solution that is both easier to design and likely to yield better performance than the more general relational model. Another advantage, discussed in detail in subsequent sections, is that this general model provides an abstraction that allows us to decouple the visualization tool from the data source (Section 4) and to generate and compose data transformations regardless of their actual implementation (Section 6).</p><p>The final disadvantage that we discuss here is that certain data analyses are difficult to perform using the relational model. While some queries, such as spatial queries or dynamic queries (e.g., fast computation of filters), can be done using specialized indices or data structures, one type of query that is inherently difficult to perform in the relational model is data reshaping, such as transposing a relation representing a correlation matrix <ref type="bibr" target="#b28">[29]</ref>. For example, suppose the data set contains microarray data, with each microarray having an expression level for a set of genes. One way to structure the data is to have each tuple (row) represent a microarray and each column represent a gene, so that each tuple contains all the expression levels for the genes. This structuring of the data is compact, but limits the analyses; for example, while we can group and filter by the microarrays, we can only filter the genes. We cannot group by the genes since they are in the columns rather than the rows. Another way to structure the data is to have three columns in each tuple, with one column for the gene name, another column for the microarray data, and a third column for the expression level. This structuring is less compact but more flexible. This example illustrates that the data organization, beyond just normalized versus de-normalized schemas, impacts which analyses can be performed, therefore impacting the flexibility of the visualization tool as well. Related Work: Many existing general-purpose visualization tools (Snap-Together Visualizations <ref type="bibr" target="#b18">[19]</ref>, DEVise <ref type="bibr" target="#b14">[15]</ref> <ref type="bibr" target="#b15">[16]</ref>, Tioga-2 / DataSplash <ref type="bibr" target="#b0">[1]</ref> <ref type="bibr" target="#b29">[30]</ref>, Sage / Visage <ref type="bibr" target="#b19">[20]</ref>, VisDB <ref type="bibr" target="#b12">[13]</ref>) use the relational data model. These tools also primarily use normalized relational data, since they focus some effort on how to let the user easily perform joins. There is no discussion of the pros and cons of the relational model, or other choices. Wilkinson <ref type="bibr" target="#b28">[29]</ref> discusses many of the disadvantages of the OLAP model with regards to needing access to the raw data in order to properly compute common statistical measures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Generalized Interface for Data Access</head><p>Data access is a key issue in visualization since users often want to simultaneously visualize data from many sources and the data from each source may change. The cycle of data exploration is one of hypothesis, experiment, and analysis, with each analysis either producing a result or suggesting a new hypothesis. With every iteration through the analysis cycle, new data may be collected, the format of the data being collected may change, and so on. Users do not care about tradeoffs or where their data or meta-data is stored; they only want to be able to import all of the data into the visualization system and then proceed with their exploration and analysis. Thus, making data access easy is important for making a visualization a commonly used analysis tool.</p><p>One might think that providing access to a database would be sufficient. Often, however, users need to combine data from multiple sources. Hierarchical relationships may be stored in a flat file, historical data may be stored in a SQL database, commonly used aggregates of the historical data may be in a datacube, while other data may be stored in a text log file.</p><p>One advantage of using a relational model is that we can decouple the actual data source from the visualization tool and provide a general, easy-to-use interface for importing data. Users can easily specify the different data sources, and once in the visualization tool all data sources should appear equivalent. To achieve this decou-pling, Rivet uses three concepts:</p><p>â¢ The "ordered" relational data model (Section 3): all data sources are represented using this abstraction, and thus appear equivalent to the user. â¢ Named data sources and a "data repository": data access is easy for users since they can use the name to query the repository to retrieve the data. â¢ An easy to read, and therefore easy to change, XML file specifying the provenance information about a data source. Thus, rather than writing a script to connect to a database or to parse a CSV file, the information can be quickly specified in this file. Note that more work, such as writing a script or writing a specialized translation module, is required to parse more complex text files using regular expressions or to transform other types of data to the relational model. Because having easy data access is so important, we put the time into implementing a regular expression parser, CSV parser, and OLE DB drivers to connect to SQL databases and MDX datacubes to ensure that Rivet users could easily import their data.</p><p>Note that in order to achieve a full decoupling of the data sources from the visualization tool, users must also be able to perform analyses on the data without caring about the implementation of the transformations and whether they are done within the visualization tool itself or pushed to the data source (e.g., a SQL query performed on the database). In other words, the visualization tool must make all data sources appear equally expressive to users. Related Work: Existing visualization systems, such as Snap-Together Visualizations <ref type="bibr" target="#b18">[19]</ref>, and Tioga-2 / DataSplash [1] <ref type="bibr" target="#b29">[30]</ref>, rely on data stored in databases. DEVise supports accessing large data sets that do not fit in memory and connect to both databases and alternative data sources, as long as the user has programmed a converter / extractor for the source.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Sophisticated Meta-Data</head><p>While visualization is used for presenting, exploring, and analyzing data, the resulting displays are meaningless without also presenting the underlying semantic information -the meta-data. This metadata is just as important as the data itself since it provides the context. After all, how can a user interpret a graph without the axes and the axis labels?</p><p>While meta-data has long been recognized as providing context, previous work has only hinted at its importance for building effective visualizations, specifically with regards to choosing effective visual encodings [2] <ref type="bibr" target="#b4">[5]</ref>. One famous example, first brought up by Huff <ref type="bibr" target="#b11">[12]</ref>, is whether to include zero in an axis. For percentages, not including zero can greatly distort the user's perception of the graph; similarly, reducing the range may emphasize the slope, leading the user to perceive a greater change than might actually exist. This example can be generalized: choosing the range of values to display (e.g., the spatial encoding on an axis) affects the user's perception of the data display.</p><p>For ease of use, the user should be able to just specify what data he wants to see. However, to derive effective visual encodings automatically, the visualization benefits from having well-modeled data, i.e., the semantic information associated with the data.</p><p>While one customary goal when designing systems is to generalize as much as possible to find the minimal set of information common to most data sets (typically the name and storage type of the field), visualizations can take advantage of additional details to create effective displays. To continue the example above, it is not enough to know that the data field is a quantitative field since not all quantitative fields should include zero on their axes. For example, geographical fields (e.g., latitude and longitude) would be greatly distorted if zero were always included.</p><p>Given this insight, what meta-data information can a visualization use? First, visualizations can take advantage of type information for a field, consisting of several characteristics:</p><p>â¢ The canonical "storage" type: real, integer, string, date / time, and so on. While this information is obviously used in the implementation, it is also used in visualizations since there are clearly known and expected ways to draw, for example, time axes. â¢ Discrete versus continuous: real data is continuous, integer and nominal data are discrete. This type information can be used to determine chart type; for example, line charts should not be used with discrete data since interpolation does not make sense. â¢ Ordered versus unordered: real and integer data are ordered, nominal data is unordered. When choosing retinal encodings, shape encodings are effective for unordered data while size encodings would be more effective for ordered data <ref type="bibr" target="#b7">[8]</ref>. â¢ Scales <ref type="bibr" target="#b22">[23]</ref>: continuous data may be intervals, ratios, geographic data, etc. Ratios should include zero when displayed spatially, while intervals and geographic fields may not. The aspect ratio for geographic data depends on the projection. â¢ Units: for example, dollars or currency are units. Units are useful for determining which fields can share an axis. A good example is the Gantt chart: knowing that the beginning time and the event duration use the same units allows the visualization to use the duration to encode the length of the bar on an axis displaying time. Choosing effective visual encodings depends on having all of this type information.</p><p>The absolute domain of a field, i.e., the domain of all possible values for a field, is another type of meta-data that information visualizations can use. Often, only the actual domain (the values present in a data set) of a field is available or easily calculated, but for a visualization, displaying which values are missing is just as important as displaying which values are present. Domains can also be used in visualizations to provide an ordering for unordered fields -when displaying a nominal field on an axis, for example, the labels should be drawn in some semantically meaningful order.</p><p>Visualizations can also take advantage of hierarchical relationships that define meaningful levels of detail; for example, location might have the levels City, State, and Country, while time may have levels Day, Month, Quarter, and Year. Displaying these hierarchical relationships provides context to the user.</p><p>One key insight, especially when looking at the hierarchical information, is that meta-data can be used not only for annotating the display but also for driving the data transformations. For example, these hierarchies provide meaningful levels of aggregation so that the user can quickly roll up and drill down into the data.</p><p>Given the usefulness of meta-data, the final question is how to import and model the information within a visualization. Note that a database does not typically contain all of this meta-data information, so querying a database will not provide a complete solution. While there are many possible solutions to this problem, we briefly outline the approach we chose for Rivet.</p><p>To import the meta-data, we augment the same XML file used for specifying the provenance information for a data source (Section 4) with the additional meta-data information, such as the type information, absolute domains, hierarchies, derived field information, ad hoc groupings, and so on.</p><p>The other main change is to promote meta-data objects to firstclass citizens rather than as add-ons to data objects. For example, not only are fields separate objects with the type information, but domains and hierarchies are also separate objects. Some domains are static while other domains change depending on the data or user interaction (e.g., a domain containing a user-specified filter); domains may also be shared by different tables. Similarly, some hierarchies are known in advance, while other hierarchies, such as ad hoc groupings, may change as the user interacts with the visualization.</p><p>Related Work: Many existing systems, such as Snap-Together Visualizations <ref type="bibr" target="#b18">[19]</ref>, DEVise <ref type="bibr" target="#b14">[15]</ref> <ref type="bibr" target="#b15">[16]</ref>, and Tioga-2 / DataSplash <ref type="bibr" target="#b0">[1]</ref> <ref type="bibr" target="#b29">[30]</ref>, only use the meta-data information provided in the database schema, which typically consists of the field name, storage type, actual domains, and hierarchical relationships. Exbase <ref type="bibr" target="#b13">[14]</ref> discusses the need for additional meta-data information, but only focuses on information that can be automatically inferred from the database or the query.</p><p>Both APT <ref type="bibr" target="#b17">[18]</ref> and Sage <ref type="bibr" target="#b20">[21]</ref> discuss how meta-data information can be used to generate appropriate visual encodings automatically, with the extended type information being the primary overlap. Sage uses additional meta-data describing the relationships between database tables in order to support joins.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Data Transformations</head><p>During the course of analysis, users will want to see different views and transformations of the data, such as aggregates, drill downs and roll ups, filters, and so on. In this section, we discuss several design decisions involved in providing this functionality within the context of a visualization tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Do visualizations need to provide transformation capabilities (independent of implementation)?</head><p>Having as tight of a loop as possible between performing these analyses and seeing the resulting visualizations will encourage more analysts to use visualization. There is a quite a spectrum of options in creating this loop for visualization designers. One extreme is to require users to leave the visualization environment to do data transformations, followed by either re-importing the data or creating a new visualization; this option creates a high barrier between analysis and visualization that hampers many users. A middle choice is to have a single tool with methods for analyzing the data and methods for displaying the data; Excel is an example of this type of tool. At the other end of the spectrum is a tool like Polaris <ref type="bibr" target="#b23">[24]</ref>, in which users create specifications (Section 8) that the system uses to generate both the requisite transformations and the visual display.</p><p>We believe that users want to focus on the data and its analysis, rather than on the details of data manipulation. Thus, to create as tight of a loop between analysis and visualization as possible, the user needs to be able to perform analyses within the context of the visualization tool. How do users specify which analyses they want to see?</p><p>If a visualization provides transformation capabilities, the next question is how do users specify which analyses they want to see? One option is to have the user learn a query language such as SQL or MDX. This option requires a great deal of user expertise and limits the user to the associated data sources. Another choice is to create an abstraction layer and provide transformation primitives that the user can link together, or compose, to get the desired result; this can be done by visual programming (Tioga-2 <ref type="bibr" target="#b0">[1]</ref> or VQE <ref type="bibr" target="#b8">[9]</ref>), writing scripts (Rivet) or macros (Excel), or some other method. Rather than having the user explicitly specify the data transformations, another option is to generate the needed transformations (or series of transformations) automatically from some description, as is done in Polaris <ref type="bibr" target="#b23">[24]</ref>. Note that these options illustrate a tradeoff between expressibility and the level of user expertise needed: Polaris is perhaps the most intuitive, but the most limited in terms of the queries that can be generated. While query languages provide the most general set of analysis operations, both query languages and transformation primitives require more sophistication than Polaris, since the user must determine not only how to express the analysis to perform but also how to specify the data display. We consider this latter question in more detail in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>How and where does the visualization perform the analysis?</head><p>Given the query specified by the user (directly or indirectly), the next question is how and where the visualization performs the query. Because the goal (Section 4) is to decouple the data sources from the visualization tool, the visualization tool now needs to make all data sources appear equally expressive to the users. The ease of achieving this goal depends on the data source, and one way to simplify this problem is to restrict the space of possible analyses the user can perform within the visualization tool, thus potentially impacting the answer to the previous question.</p><p>To achieve this decoupling, the visualization tool must be able to translate user-specified queries into the appropriate query language, set of internal transformations, or even some combination. Combining transformations from different tools can be especially powerful, and is possible when using the relational model, since input and output data have the same basic structure.</p><p>Giving the responsibility of deciding where to perform the transformations to the visualization can be used to achieve greater flexibility and performance when analyzing data. For example, while databases incur a latency for transferring data to the visualization tool, using a heavily-tuned database provides the capability to scale to very large data sets. Thus, by being the intermediary between the user-specified query and the actual query implementation, the visualization can leverage the database scalability and offset the latency issues by choosing, for example, when to query the database and when to filter cached data. Beyond caching, the visualization could also implement prefetching and other visualization-specific performance optimizations.</p><p>In general, however, we recommend pushing as many operations to the tools already designed and optimized for performing such transformations. Having the database do as much analysis as possible, especially to reduce the data set size, will help mitigate the latency issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Which transformations should a visualization provide?</head><p>If the visualization tool needs to restrict the space of possible analyses, the question now becomes which data transformations are common enough that the visualization needs to provide them to the user. This question is independent of whether the transformations are translated into database queries, internal transformations, some combination, etc.</p><p>Our suggested list of transformations include:</p><p>â¢ Group by: Any visualization with multiple (potentially linked) views needs to know what data to draw where. This data might be on a per table basis, but a user might also want to split the views by the values in a field, such as sending all tuples for California to one view and all tuples for Florida to another view. Having this transformation also allows subsequent aggregations to be performed (e.g., the average profit in California). â¢ Sort: Tuples need to be drawn in some order, so that "more important" tuples are drawn on top. Sorting is one way to get this order. Sorting can also be used to order tuples when drawing non-point primitives such as lines or polygons. Also, sorting followed by filtering is one way (not necessarily the fastest) of computing ranking transformations, e.g., the top ten tuples according to a particular metric. â¢ Filter: Especially for large data sets, filtering to display only the "interesting" range of the data, e.g., only the Western states or only the top ten percent, is one of the most useful transformations for reducing clutter in the display.  This list contains the transformations we have needed consistently in the many visualizations we have built using Rivet. This list is not complete, because more specialized transformations are sometimes needed, either for performance reasons or for unique analyses, such as the k-means clustering algorithm. Also note that if the visualization is a custom rather than general tool, custom transformations will likely yield better performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Do visualizations need internal data transformations?</head><p>The next question is whether visualizations need internal data transformation capabilities. While, as we point out above, there can be performance (caching and filtering) and flexibility gains, there are more compelling reasons for providing this capability. First, not all data sources provide data transformation capabilities; flat files, for example, cannot transform themselves. Second, visualizations need internal transformations for drawing purposes. Polaris, for example, has multiple panes in its table-based visualizations. Rather than performing a query for every pane, we perform the minimal set of queries to minimize latency and then use an internal grouping and sorting network to send data to the appropriate panes for drawing in the needed sorted order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>What issues are involved when implementing data transformations?</head><p>Finally, if the choice is indeed to implement transformations internally within the visualization, some of the issues encountered are:</p><p>â¢ Multiple quick passes versus a single pass: Within a transformation, there is the question of whether it is faster to have multiple quick passes over the data or a single, potentially much slower, pass through the data.</p><p>â¢ Transformation and data granularity: Another question is whether it is faster to have each transformation perform a single operation or a combination of operations. For example, we have found that group by and aggregate are often performed in conjunction. One optimization is to combine these operations into a single transformation that the user can customize by choosing which fields to group by and then how to aggregate each group. In some sense, rather than looking at transformation granularity, we are looking at data granularity since the customization is being done at the tuple level rather than the table level. Some transformations, such as sorting and ranking, are more easily calculated at the table level.</p><p>â¢ Flexibility: Once the decision to implement data transformations internally is made, the temptation is to make them as flexible as possible. There are several degrees of flexibility that can be achieved, some of which are both unnecessary and expensive, performance-wise. The first choice is whether to have composable transformations, where any transformation input can be the input to any other transformation, thus allowing a wide range of analyses to be performed. While composability has several benefits, designers often take the next step that, while independent, takes advantage of composability by providing the capability to form a general network of transformations, in which every intermediate result is kept and is visualizable. Rivet, like other systems such as Tioga-2 <ref type="bibr" target="#b0">[1]</ref> and VTK <ref type="bibr" target="#b16">[17]</ref>, provides this capability. While we originally thought this flexibility would be a great advantage, not only is there a large performance cost, but we also never needed this level of generality and flexibility -we never visualized the intermediate results. This performance penalty can be mitigated by using customizable transformations such as the group by and aggregate example discussed above.</p><p>Related Work: Both VQE <ref type="bibr" target="#b8">[9]</ref> and Snap-Together Visualization <ref type="bibr" target="#b18">[19]</ref> focus primarily on letting the user specify which join(s) to perform and then pushing the actual transformations to the database. DEVise <ref type="bibr" target="#b14">[15]</ref> <ref type="bibr" target="#b15">[16]</ref> does provide specialized queries depending on the data source, such as queries for searching for particular company stock information, but this specialization is not hidden from the user. They also discuss some performance optimizations, particularly with regards to whether certain transformations, such as filters, should be performed on tuple (TData) or graphical primitives (GData).</p><p>Both Sage <ref type="bibr" target="#b19">[20]</ref> and Tioga-2 / DataSplash [1] <ref type="bibr" target="#b29">[30]</ref> argue for composable transformations. There is not much discussion of which transformations are needed for visualization in particular, saying only that analysts need the ability to transform the data in the exploration process. Tioga-2 does allow all intermediate results to be visualized; however, this functionality is provided primarily for debugging purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Modularizing Data, Visualization, and Interaction Objects</head><p>The high-level architecture of a visualization system is often drawn as a pipeline <ref type="figure" target="#fig_1">(Figure 1</ref>). The goal is to modularize each box in the pipeline and then define the objects and API's for the arrows connecting the boxes. By performing this encapsulation, we gain flexibility, since we can combinatorially compose objects to create a wide variety of visualizations and analyses. We also gain extensibility, since new functionality can be incorporated by implementing additional box and arrow instances within the existing system. The previous sections have focused on using the relational data model, generalized API for data access, and data transformations to abstract the raw data and data tables boxes and the arrow connecting those two. We have also discussed how we can use meta-data information to choose which visual mappings might be most effective. In this section, we discuss the other portions of the visualization pipeline and some issues with modular architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Visual Encodings</head><p>In Rivet, we initially created an architecture for the visual mappings and the visual display with four basic types of objects:</p><p>â¢ Mappings that map values from one type to another, e.g., from quantitative values to size or from a nominal value to color. â¢ Encodings that use mappings to explicitly map a particular data field to a particular visual variable (e.g., Profit to the xaxis or Product Type to color). â¢ Metaphors that lay out tuples spatially.</p><p>â¢ Primitives that use retinal encodings (e.g., shape, color) to render a tuple in the space allocated by the metaphor. This architecture has several advantages, as we have discussed above: it maximizes code re-use, is easily extensible since only the new mapping or layout algorithm needs to be added, and is highly flexible since multiple visual representations can be applied to the same data set, and conversely, the same visual representation can be used by many different data sets.</p><p>However, there are also several disadvantages. One issue that we have mentioned before is that while increased generalization may lead to increased flexibility, we cannot hide too many of the details since visualization is about displaying data in context, and that context is needed even in the code. One example of where our generalization led to difficulties is in the separation of the visual into spatial layout and retinal encodings. Because we need to handle both line and polygon primitives, those primitives need some spatial knowledge in addition to needing the data to be sorted and drawn in a certain order (connected lines). Additionally, retinal encodings have slightly different meanings depending on the primitive type <ref type="bibr" target="#b26">[27]</ref>.</p><p>The other primary disadvantage is that this architecture is sometimes over-generalized, thus requiring additional work to generate the proper mappings and encodings. For example, to find the proper range in a stacked bar chart, we need to determine the maximum value for any particular stack. However, in order to determine this value, needed by the mapping, we need to know not only the numeric field being stacked (known by the encoding), but also which ordinal/nominal field is used to for creating the stacks (known by the metaphor).</p><p>One area for future work is to examine whether our initial choices in determining the set of object primitives and interfaces lead to these difficulties, and whether different modularizations solve these problems, and at what expense, since a different choice may lead to a different set of issues. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Interaction</head><p>While we would like to encapsulate interaction much as we encapsulate the data to visual mappings in order to realize the same benefits, it is more difficult since there are at least three different axes along which to encapsulate interactions:</p><p>1. Outputs: The first axis to look at is the end effects of the interaction. For example, an interaction can affect the raw data, the data transformations, the visual mappings, or the view itself (e.g., rotation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Inputs:</head><p>The second axis to look at is the inputs. For example, some interactions require the mapping between data and visual so that when given a selected area in visual space, which data tuples correspond to the selected area can be determined, such as is needed for brushing or tooltips.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Triggers:</head><p>The final axis to look at is how the interactions are triggered. For example, panning can be triggered by a trackball interface, a scrollbar, arrow keys, etc. Looking at the visualization pipeline, what we chose to do is provide interfaces on the boxes (the data and visual objects), which correspond to the outputs axis. These interfaces correspond to highlevel actions, such as pan and zoom. Note that with Rivet scripting (Section 2), we can build even higher-level actions in the script. Alternatively, the script-writer can choose whether an action (however triggered) corresponds to an optical zoom on the visual object or a semantic zoom on the data object.</p><p>To abstract the triggers axis, Rivet takes advantage of its event callback methodology to build interactions (Section 2): the objects themselves do not care who calls their interfaces or how. Like Java, the interfaces can be triggered by any mouse interaction, any key press, etc., all depending on how the script is built.</p><p>The inputs axis only needs to be abstracted when the user actions need additional translation to determine other inputs to the object interfaces. For example, in the simple panning case, the object just needs to know whether to move up or down (or left or right). A more complex interface would need to know how far to move -an additional input is needed, and is based on translating the actual triggers, such as amount of mouse movement or speed of key presses. To abstract the inputs axis, Rivet uses the notion of a transparent overlay to translate mouse events into higher-level interaction events. Different overlays implement different translations; one overlay translates mouse events according to a trackball interface for panning and rotation, while another overlay translates mouse events into input for selection (e.g., rubberbanding). Essentially, these overlays use the triggers to aid in translation when the interactions need to know about spatial encodings.</p><p>Because selection is such a prevalent and complex operation, we use two additional abstractions. The first abstraction takes advantage of our modular (and inheritance-based) model for visual objects. Specifically, we have a base metaphor class that implements techniques common to all metaphors, including whether tuples are being rendered or just laid out for selection (picking) purposes. Thus, individual metaphor classes only need to implement the actual layout. The second abstraction is to modularize the notion of selection itself. Selection may mean choosing a single range of values, choosing multiple ranges (e.g., selection on multiple axes), choosing distinct values, choosing distinct tuples, etc. Thus, we also have a general selection API, with individual selection classes implementing the specific type of selection desired. Related Work: Snap-Together Visualizations <ref type="bibr" target="#b18">[19]</ref> focus on how to layer user interaction on top of visualizations for coordination. They do not provide visualization capabilities (leaving that to the individual visualization tools snapped together using their interface), and therefore they do encapsulate interaction. However, because they view user interactions as joins used for performing selection or navigation, they are tackling only a subset of the problem.</p><p>Chi et al. <ref type="bibr" target="#b5">[6]</ref> and Chuah et al. <ref type="bibr" target="#b6">[7]</ref> present frameworks for organizing the different types of interactions within a visualization. They both organize the interactions by their end effects (e.g., whether the value (data), view (graphics), or some combination is affected). Chi discusses implementation only briefly, pointing out that where the operator would be optimally placed (within the visualization, the database, or in a specialized tool) depends on where in the visualization pipeline the interaction falls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Modularity Issues</head><p>While we have mentioned the many advantages of modularity, there are several issues that arise with a modular architecture as well.</p><p>One issue with modularity is that if the objects and API's are not designed with all cases in mind from the beginning, making changes later can be very difficult. We pointed out one example above with the point primitives, but meta-data information is another even more important example. We originally designed Rivet using the pipeline model and focused on modularizing data and its display. As we realized the importance of meta-data and its display and interaction, we created separate meta-data objects for use in creating effective visualizations of data, as discussed in Section 5. However, rather than modularizing meta-data displays (e.g., axes, label, legends) and interaction separately, a more accurate pipeline would recognize that meta-data should be treated like data and design accordingly.</p><p>Another issue is the listener model commonly used in modular code. In this model, objects "listen" to one another, and when an object changes, it notifies all of its listeners so that they can update themselves. For example, if the user changes the color mapping, the mapping informs the encoding, which then notifies all of the objects that use that encoding for drawing, so that they then will redraw. While the listener model simplifies the implementation for the designer since the coder does not need to determine exactly what needs to be updated on every change, getting the implementation of the listener model correct is tricky, since the propagation of change events may easily lead to over-updating of objects, resulting in a performance loss. The key is that each event needs to say not just that something changed, but to say what changed so that only the minimal set of updates and propagations happen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Specification and Scripting</head><p>The final design decision we discuss is how to create visualizations given the infrastructure discussed in the previous sections. There is a spectrum of choices here as well, again with a tradeoff between simplicity and expressibility.</p><p>One extreme is to use scripting (a procedural approach) to create the visualization. Scripting requires the most expertise and takes the most time, but has the most expressibility and flexibility: users can explicitly create the views of the data they want, the layout of those views, the exact interactions and results of those interactions, and so on.</p><p>The other is to use a tool like the Polaris user interface <ref type="bibr" target="#b1">2</ref> , where the user interactively drags-and-drops field names to create a visualization. While this interface is intuitive to use, the user is constrained to table-based visualizations and to the interactions and data analysis capabilities exposed by the user interface.</p><p>As we created more interactive exploratory visualization tools, such as the Polaris user interface and tools for exploring computer systems data, we found that table-based visualizations were predominant and highly useful. We created the Polaris formalism <ref type="bibr" target="#b23">[24]</ref> describing this class of visualizations, which then formed the basis for our specification language. Writing a specification (a declarative approach) is like filling out a template containing the specific fields the user wants to visualize, and the specification can be used to generate both the data queries needed to retrieve the data being visualized and the visual encodings needed to create the display itself.</p><p>This specification language is a middle ground, in that the user can create static table-based visualizations simply by filling out a template (implemented using XML). In fact, the user can create more sophisticated visualizations using the specification language than is possible in the Polaris user interface 3 , since creating intuitive affordances corresponding to some more advanced features, such as the nest operator, is quite difficult <ref type="bibr" target="#b26">[27]</ref>. When comparing filling out specifications to writing scripts, specifications are easier but more restrictive. In this case, the user can only create tablebased visualizations without interaction, while scripts require more expertise but are much more powerful.</p><p>Rather than choosing either specification or scripting, yet another option is to combine the two to gain expressibility without requiring too much more expertise. The specifications define both the visual and the data abstraction (i.e., the visual representation and the data transformations) <ref type="bibr" target="#b25">[26]</ref>; a sample specification is shown in <ref type="figure" target="#fig_3">Figure 2</ref>. By pushing the repetitive definitions to the specifications, the scripts are simpler, since they only need to define the interaction and the transitions between specifications. The scripts are simplified even further since we have XML files for specifying the data (including the data import). We retain all the power of Rivet, since scripts can be used to create any visualizations beyond the scope of the specification language.</p><p>While specifications can be used to create static visualizations, one area of future work is to explore how to specify interactive visualizations. One approach is to research transitions and interactions further to see if we can find a parameterization or formal structure to use in a specification. Related Work: Snap-together Visualizations <ref type="bibr" target="#b18">[19]</ref> do not provide scripting functionality, saying it is too difficult for users. Since they only layer interaction on top of existing visualizations, however, and further limit that interaction to the interactions that coordinate visualizations (e.g., joins), they are attacking a significantly different problem.</p><p>Sage and Visage <ref type="bibr" target="#b19">[20]</ref> provide several different interfaces. While they also use scripting for interaction, designing the visualization itself is done automatically using Sage, by visual specification using <ref type="bibr" target="#b1">2</ref> The Polaris user interface is built using Rivet scripting and illustrates a third option, which is to bootstrap one extreme to reach the other. <ref type="bibr" target="#b2">3</ref> Creating visualizations using the Polaris user interface is equivalent to creating a specification visually. However, there are valid specifications that cannot be created using the Polaris user interface. SageBrush, or by searching for similar examples using SageBook. Thus, even though they do use both scripting and specification, the two are not well-integrated.</p><p>Tioga-2 and DataSplash <ref type="bibr" target="#b0">[1]</ref>[30] use another approach, similar to visual programming, where the user can link together icons representing actions and both data and graphical transformations.</p><p>Wilkinson <ref type="bibr" target="#b28">[29]</ref> also has a concise language for specifying visualizations that is quite powerful and descriptive. However, this language is used only for creating static displays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Future Work</head><p>While we have pointed out various directions for future work within the various sections, graphics and database performance are a specific area of concern for visualization that bears further exploration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Graphics Performance</head><p>Graphics hardware is getting faster at the pace suggested by Moore's law, yet most visualizations do not take advantage of the graphics hardware, even when displaying large data sets. One issue is that graphics hardware designers are optimizing for 3D graphics, in part because of the high performance demands from the lucrative gaming industry, but also because visualization designers have not pushed the limits of graphics hardware and come up with a list of needs. For example, while we initially chose OpenGL for its portability, it is designed for monolithic 3D graphics applications such as games. As a result, Rivet, with its modular architecture and 2D graphics, needs to do additional work for performance, such as maintaining its own state and using different contexts for different windows (different frames within the same window share the same context) to minimize context-switching, an expensive operation in OpenGL. Other interfaces such as DirectDraw may be a better fit for this type of visualization system. Thus, one area for future work is to examine the limits of current graphics API'ss and hardware for visualization. A few visualization applications do push the limits of graphics hardware, such as Fekete et al.'s work on large data sets <ref type="bibr" target="#b9">[10]</ref> and Solomon's work on CAD layout <ref type="bibr" target="#b21">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Database Performance</head><p>Visualization can be seen as the intersection of user interface design, graphics, and databases, and as a result, visualization needs OLVP (Online Visualization Processing) since it has different needs from both OLAP and OLTP.</p><p>While database researchers have done a lot of work on optimizing databases, these optimizations are for typical database usage: multiple users, each submitting unrelated queries simultaneously, with subsequent queries likely unrelated. In other words, there is little locality to exploit. Database researchers have also recognized the difference between OLAP and OLTP databases and created different database organizations and optimizations for each.</p><p>However, visualization systems require both more information and different optimizations than existing databases provide. One issue is to determine whether these optimizations belong in the database or in the visualization tool. For example, if the visualization wants to display sampled data or streamed data from a large database, that sampling or streaming functionality belongs in the database. On the other hand, prefetching belongs in the visualization, since the visualization tool has two advantages a general database does not. First, a single analysis session within a visualization is likely to have more locality. Second, visualizations can exploit this locality by providing interaction paths that make traversing the likely course of analysis easier, e.g., drill downs and roll ups, changing the filter, etc. While predicting the likely course of analysis is more difficult in tool like the Polaris user interface, the task is significantly easier to predict the user's path in the multiscale visualizations <ref type="bibr" target="#b25">[26]</ref> and prefetch accordingly. Other display-specific choices that affect the data abstraction, such as importance ordering, also belong in the visualization tool.</p><p>Finally, latency is the big issue with regards to integrating visualization tools with databases. Prefetching can help alleviate this problem, but the latency of bringing data into the visualization is still a fundamental bottleneck. Some other ways to address the latency issue include sampling the data set and estimating and bounding the uncertainty of the data <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusion</head><p>In this paper, we discuss the design decisions we needed to revisit as we refined Rivet to create more sophisticated interactive visualizations for exploration and analysis of large data sets. Specifically, for each design choice, we discuss its importance, implications, some possible approaches and the associated advantages and disadvantages, as well as some implementation challenges. The issues we discuss include:</p><p>â¢ Internal Data Model: the ordered relational model provides flexibility and a layer of abstraction that makes the generalized data interface, data transformations, and separation of data, visual, and interaction objects possible. â¢ Generalized Data Interface: users will use visualization tools regularly when it is easy to import their data. â¢ Sophisticated Meta-data: with additional meta-data, visualizations can choose encodings more effectively. â¢ Data Transformations: a tight loop between analysis and visualization allows the user to perform analyses more quickly and easily. â¢ Separation of Data, Visual, and Interaction: while modularization gains flexibility and extensibility, there can be dangers to over-generalization. â¢ Specification and Scripting: choosing how to create visualizations involves a tradeoff between expertise and expressibility.</p><p>We present this discussion so that designers need not go through the same discovery process that we went through and can thus architect visualizations quickly and effectively.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>â¢</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>A pipeline showing the flow through a visualization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Related Work: Many systems, including Sage [20], DE-Vise [15][16], and Tioga-2 / DataSplash [1][30], use the idea of visual encodings to create an abstraction between the data and the corresponding visual representations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>An XML specification and the generated visualization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Aggregate: Computing average, sum, min, max, count, median, etc. are basic statistical operations that are frequently used.</figDesc><table /><note>â¢ Merge: One example of a common operation is to display the average profit per state in a single pane. If internal transfor- mations are used, one convenient way to compute this data is to group by state, compute the average profit, and then finally, merge the results back into a single table for display.</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">A normalized schema divides the data into multiple tables to minimize duplication of data, both within a single table and between tables.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0" />
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Tioga-2 Database Visualization Environment. Lecture Notes in Computer Science: Database Issues for Data Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spalding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page">1183</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Semiology of Graphics: Diagrams, Networks, Maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bertin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<publisher>Univ. Wisconsin Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Rivet: A Flexible Environment for Computer Systems Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gerth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Using Visualization to Understand the Behavior of</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bosch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Computer Systems. Stanford University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Readings in Information Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Operator Interaction Framework for Visualization Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposium on Information Visualization</title>
		<meeting>of IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the Semantics of Interactive Visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chuah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposium on Information Visualization</title>
		<meeting>of IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Elements of Graphing Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cleveland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Wadsworth Advanced Books and Software</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Interactive Visual Query Environment for Exploring Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Derthick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kolojejchick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGKDD</title>
		<meeting>of ACM SIGKDD</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interactive Information Visualization of a Million Items</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposium on Information Visualization</title>
		<meeting>of IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Interactive Data Analysis: The Control Project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Avnur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hidber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="1999-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">How to Lie with Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Huff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1954" />
			<publisher>WW</publisher>
			<pubPlace>Norton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">VisDB: Database Exploration using Multidimensional Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">P</forename><surname>Kriegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications, v</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="40" to="49" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An Architecture for Retaining and Analyzing Visual Explorations of Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Grinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">DEVise: Integrated Querying and Visual Exploration of Large Datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Donjerkovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lawande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Myllymaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
		<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Visual Exploration of Large Data Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Myllymaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SPIE, v. 2657</title>
		<meeting>of SPIE, v. 2657</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An Architecture for a Scientific Visualization System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Greesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcauliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automating the Design of Graphical Presentations of Relational Information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="page" from="110" to="141" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Visualization Schemas and a Web-based Architecture for Custom Multiple-View Visualization of Multiple-Table Databases. Information Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Conklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Indukuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Saini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Palgrave-Macmillan</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards an Information Visualization Workspace: Combining Multiple Means of Expression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chuah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kerpedijiev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kolojejchick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Human-Computer Interaction Journal, v</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="131" to="185" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Data Characterization for Intelligent Graphics Presentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mattis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCHI</title>
		<meeting>of SIGCHI</meeting>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The ChipMap: Visualizing Large VLSI Physical Design Datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Solomon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">On the theory of scales of measurement. Science, v.103:2684</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Stevens</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1946" />
			<biblScope unit="page" from="677" to="680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Polaris: A System for Query, Analysis, and Visualization of Multi-dimensional Relational Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="52" to="65" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Query, Analysis, and Visualization of Hierarchically Structured Data using Polaris</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGKDD</title>
		<meeting>of ACM SIGKDD</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Multiscale Visualization Using Data Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposium on Information Visualization</title>
		<meeting>of IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Query, Analysis, and Visualization of Multidimensional Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">OLAP Solutions: Building Multidimensional Information Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Thomsen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Wiley Computer Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The Grammar of Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wilkinson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">DataSplash: A Direct Manipulation Environment for Programming Semantic Zoom Visualizations of Tabular Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ercegovac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spalding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing, v</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="551" to="571" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
