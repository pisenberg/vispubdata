<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Visual Workspace for Hybrid Multidimensional Scaling Algorithms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Ross</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">University of Glasgow</orgName>
								<address>
									<settlement>Glasgow</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Chalmers</surname></persName>
							<email>matthew@dcs.gla.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">University of Glasgow</orgName>
								<address>
									<settlement>Glasgow</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Visual Workspace for Hybrid Multidimensional Scaling Algorithms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.5.3 [Pattern recognition]: Clustering -Algorithms</term>
					<term>E.1 [Data Structures]: Graphs and networks</term>
					<term>D.1.7 [Programming Techniques]: Visual Programming</term>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques -Interaction techniques</term>
					<term>Data-flow, visual programming, multidimensional scaling, multiple views, hybrid algorithms, complexity</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In visualising multidimensional data, it is well known that different types of data require different types of algorithms to process them. Data sets might be distinguished according to volume, variable types and distribution, and each of these characteristics imposes constraints upon the choice of applicable algorithms for their visualisation. Previous work has shown that a hybrid algorithmic approach can be successful in addressing the impact of data volume on the feasibility of multidimensional scaling (MDS). This suggests that hybrid combinations of appropriate algorithms might also successfully address other characteristics of data. This paper presents a system and framework in which a user can easily explore hybrid algorithms and the data flowing through them. Visual programming and a novel algorithmic architecture let the user semi-automatically define data flows and the coordination of multiple views.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>There is a multitude of algorithms available for clustering and laying out abstract data. The different algorithmic approaches seem to be tailored to specific types of data. Some algorithms perform well with data sets of low cardinality and dimensionality, such as the basic spring model <ref type="bibr" target="#b4">[Eades 1984]</ref>. Other algorithms work best with high cardinality data, an example of which is the self-organising map or SOM <ref type="bibr" target="#b9">[Kohonen et al. 2000]</ref>. In training, a substantial training set allows the SOM to reveal complex nonlinear structure in a very large body of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>----------------------------------------------</head><p>Other features of the data set also affect the applicability of algorithms, such as data distribution. For example, K-means clustering <ref type="bibr" target="#b10">[MacQueen 1967</ref>] is most effective when the data is distributed in spherical Gaussian clusters <ref type="bibr" target="#b0">[Bradley and Fayyad 1998</ref>].</p><p>In a working environment, corporate memory and project-specific databases tend to start off small and gradually evolve into large information repositories. While it would be feasible to visualise the inter-object relationships with a force-directed layout algorithm in the infancy of such a database, it would become less and less effective as the database matures and demands a more computationally feasible solution. Previous work has shown that hybrid algorithmic approaches to visualisation scale up to relatively high-volume data sets, even though some of the constituent algorithms would be too costly on their own if applied to the entire set <ref type="bibr" target="#b12">[Morrison et al. 2002]</ref>. This would suggest that when applied to a growing database, algorithmic steps could be bypassed in the repository's infancy and incorporated as it approaches maturity. Or, in the case that volume fluctuates, the hybrid algorithm could fluctuate and adapt with it.</p><p>We present an implemented system and framework called HIVE (Hybrid Information Visualisation Environment) that utilises direct manipulation to allow users to interactively create and explore hybrid MDS algorithms. <ref type="figure">Figure 1</ref> shows screen-shots of the system. Visual programming and a novel algorithmic architecture are proposed as a means to let the user semiautomatically co-ordinate multiple views and define data flows. This paper is organised into seven sections. Section two describes related work including the data-flow model and visual programming. Section three illustrates the hybrid algorithmic framework, upon which the system is built. Section four describes the HIVE architecture and implementation. Early experience of using HIVE is discussed in section five. Finally, sections six and seven present future work and conclusions respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>The HIVE system permits users to easily create and experiment with hybrid algorithms for generating visualisations of their data. This process is a visual one in that algorithms and visualisations are represented by visual components that afford direct manipulation. The following sub-sections describe topics in the literature that have influenced HIVE's development. <ref type="bibr">IEEE Symposium on Information Visualization 2003</ref><ref type="bibr">, October 19-21, 2003</ref>, Seattle, Washington, USA 0-7803-8154-8/03/$17.00 Â©2003 IEEE</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Visual programming</head><p>At around the time when scientific visualisation was being established, the concept of visual programming was also becoming prominent <ref type="bibr" target="#b6">[Haeberli 1988;</ref><ref type="bibr" target="#b17">Upson et al. 1989]</ref>. Conventional programming languages, whether high level or low level, tend to be built around a vocabulary where the 'words' consist of primitives (characters). Visual programming languages are at a higher level of abstraction than conventional languages. <ref type="bibr" target="#b6">Haeberli [1988]</ref> states that a visual programming environment is any system that has adopted a graphical 2D notation for the creation of programs. The visual primitives that make up the vocabulary of these programs are essentially representations of well-defined aggregates and the (direct) manipulation of these aggregates means that complex programs can be produced more easily than with conventional languages. This is because the abstraction allows a greater degree of code or function reuse and the workings of the programs themselves are more readily understood and communicated due to their visual and spatial properties. It can also be argued that if the manipulation of the visual constructs is flexible enough-for example, the user may wish to place them arbitrarily on the display surface-then this allows greater freedom for externalising the plans and thoughts of the user <ref type="bibr" target="#b7">[Hendry and Harper 1999]</ref>.</p><p>Using visual programming for constructing InfoVis algorithms reinforces our commitment to and interest in graphical interaction in computing. With regard to the means-end relationship, the means are a visual process and the end result is a tool that produces the visual information originally sought aftervisualisations are useful for producing other visualisations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data-flow model</head><p>Before visual programming was available in scientific visualisation tools, the functional components of the tools were hidden from the users and they had no control of the flow of data between them. The stream of data from input through calculation functions to mapping, filtering and rendering graphics and their control was pre-set and the scientists and engineers had to make do as best as they could for their tasks. In the words of Haeberli, "Instead of the user driving an application, the user is often driven and constrained by the application."</p><p>Visual programming addressed a number of these problems, moving away from these monolithic and static applications and providing integrated environments where a user without programming expertise could customise his or her applications. Visual programming in the application design cycle takes the form of a data-flow architecture. In this architecture, users are presented with a library of modules-application componentswith specific functions. The users can select which modules will be useful in their application and draw, via direct manipulation of graphical representations, a block diagram and create connections between modules for the data to flow through. This quick and easy process meant that scientists and engineers could concentrate on the problems being studied instead of dealing with the overhead of re-coding and configuring monolithic applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Multiple-view co-ordination</head><p>Multiple view co-ordination allows two or more related views of data to run concurrently, with views evolving as data flows into them from some common ancestor in the data flow graph, or as the user interacts with one of them. A well-known example of this is brushing and linking <ref type="bibr" target="#b2">[Becker and Cleveland 1987]</ref>. By coordinating multiple views so that changes made in one view are reflected in other views, interaction can be said to flow between them. This lets the user focus on specific parts of the data set, and see them within the context of other views.</p><p>In evaluating their snap-together visualisation system, North and Shneiderman have found that this enhances user-performance in data analysis tasks <ref type="bibr" target="#b15">[North and Shneiderman 2000]</ref>. Co-ordination of activity across multiple views gives the user greater control over the visual representations of the data. This ultimately nurtures discovery. In <ref type="bibr" target="#b1">[Buja and Swayne 1996]</ref> it is described as linking "â¦a graphical query to a graphical response", and in <ref type="figure">Figure 1</ref>. Two screen-shots of the HIVE interface. The image on the left illustrates interconnected components that import, transform and render multidimensional data. The algorithmic components collectively represent the O(NâN) hybrid MDS algorithm of <ref type="bibr" target="#b12">[Morrison et al. 2002]</ref>. Thick lines that link modules represent data-flows while thin ones, connecting scatterplots and other visualisations, represent the connections between interlinked interactive views. The image on the right shows the same scatterplots enlarged and supplemented with a fisheye table component. The data consists of 5000 points sampled from a 3D 'S' shaped distribution.</p><p>[ <ref type="bibr" target="#b5">Eick and Wills 1995]</ref> it is stated that it gives users the impression that they are touching the data. HIVE takes advantage of the data-flow model and visual programming. To create a hybrid algorithm, a user drags components from the system's tool bar into the drawing region (see figure 1) and then interconnects them by dragging links between ports on the components. Not only is the data-flow set up in this manner, but the view co-ordination can also be defined this way. After connecting visualisation tools such as scatterplots to the output ports of algorithmic components, 'Select' ports can be linked between view components to establish 'brush and link' functionality.</p><p>Hybrid algorithms can exhibit a lower run-time than spring models run upon the whole data set, as discussed in ], but they also lend themselves to the production of intermediate visualisations. The benefits of this hybrid approach are two-fold: efficiency is enhanced and intermediate views provide more insight into the data. For example, the hybrid algorithm depicted in <ref type="figure">Figure 1</ref> (left) uses a spring model of a sample of the full data set, to gain an initial small-scale 2D layout. In the left frame of <ref type="figure">Figure 1</ref>, the sample and the remainder have both been fed into spring models, to allow for comparison. The two layouts have been positioned by the user on the right hand side of the frame. The sample layout is also fed into another module, which interpolates the remainder of the set to produce a third and final scatterplot, shown in the middle of the frame. In the right hand frame in the figure, the fisheye table shows the layout points sorted on the y dimension. If we then use brushing to select a range of rows in the table, we highlight the corresponding points in the scatterplot and reveal more of the structure of the data.</p><p>3 Hybrid algorithmic architecture HIVE has been inspired by some of the existing data-flow and visual programming systems that are prominent in the literature and common in the marketplace. Upson et al's Application Visualisation System (AVS) <ref type="bibr" target="#b17">[Upson et al. 1989</ref>] and North and Shneiderman's snap-together system <ref type="bibr" target="#b15">[North and Shneiderman 2000]</ref> are two good examples. AVS is predominantly aimed at scientific visualisation, for modelling or simulating physical processes such as fluid dynamics, and concentrates on channelling data through algorithmic processes for transformation and rendering. The emphasis here is on the data-flow. North and Shneiderman's snap-together system, on the other hand, is concerned with information visualisation. In this system there is less emphasis upon the algorithmic processes for transforming data and more on the transformation of graphical representations by way of multiple interconnected views. Here the flow of interaction takes precedence. HIVE borrows from the data-flow model of AVS to be flexible in creating efficient algorithms for the visualisations. However, to be in line with the goal of information visualisation, it concentrates on exploration rather than simulation. This is achieved by supplementing the data-flow with interaction flow across multiple views, rather like the snap-together system. It must be said, however, that this approach does not come without drawbacks. It is important to note that if the level of abstraction used in the visual programming language is too low then there might be too many visual modules, in that programming would become complicated and the flow networks too large and hard to manage in the available screen space. One solution being considered is to allow the user to dynamically increase the level of abstraction by aggregating groups of modules, simplifying the graph of interconnected modules and the programming task.</p><p>As well as implementing visual programming to steer data-flow and co-ordinate multiple views, HIVE has at its core a novel hybrid algorithmic framework, exploring a general approach to the composition of efficient and flexible hybrid algorithms. The choice of each algorithmic component is influenced by many characteristics including computational cost, the cardinality, dimensionality and distribution of the data, and the other interaction components that might be used within a larger workspace, such as scatterplots and fisheye tables. We suggest that these choices can be made incrementally, so that the user employs intermediate representations as they work with and explore their data. We also suggest that the system can assist the user by using a pre-authored classification of data-based on, initially, cardinality and dimensionality of data sets-and a corresponding classification of available algorithmic components based on the classes of data each is suited for. This offers us an incremental and combinatorial approach to the creation of efficient and informative hybrid visualisations.</p><p>Our work has focused on data set cardinality, N, and the dimensionality or number of variables associated with each object: D. We roughly categorise D and N using an ordinal range (high, medium and low), and then we can categorise an algorithmic component with values of D and N for 'good' inputs and for the component's outputs, effectively stating our opinion that the component is best suited to such combinations of D and N. For example, we consider that the input to K-means clustering should be medium to high in D and N, whereas a canonical O(N 2 ) spring model algorithm can only handle low N and low to medium D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cardinality (N)</head><formula xml:id="formula_0">H, H H, M H, L M, H M, M M, L L, H L, M L, L</formula><p>Dimensionality (D) <ref type="figure">Figure 2</ref>. Data input to components in a hybrid algorithmic architecture can be categorised by the ranges of dimensionality and cardinality they are best suited forhigh, medium or low. Each component transforms the data, effectively moving across the 3x3 grid. Our hybrid layout algorithm produces a low-dimensional layout of a large high-dimensional data set i.e. a move from (H,H) to (L,H) that involves several steps shown as dotted lines in the figure: sampling, which reduces N, then a spring model of the sample, which reduces D, and then interpolation, which increases N.</p><p>As shown in <ref type="figure">Figure 2</ref>, the choice of components and how they are connected allows one to solve familiar problems in new ways. The hybrid algorithm of ] transforms a large set of data of high D to low D. It can be thought of as a move across the grid of combinations of D and N, stepping from (H, H) to (L, H)-but taking an indirect route via (H, L) and (L, L) that involves sampling, spring model layout of the sample, and interpolation based on that intermediate representation.</p><p>Tentative default values for these ordinal categories of data are as follows. We derived these values from our own experience of constructing hybrid algorithms, however, HIVE allows the user to tailor them: High N &gt; 25000</p><formula xml:id="formula_1">Low D &lt;</formula><p>The HIVE system has been designed and implemented with this hybrid algorithmic approach in mind, and serves to provide a workspace for experimental algorithm design and exploratory data analysis. The visual modules that have been implemented so far include a CSV data-importer, Chalmers' 1996 spring model <ref type="bibr" target="#b3">[Chalmers 1996</ref>], radial interpolation <ref type="bibr" target="#b12">[Morrison et al. 2002]</ref>, Kmeans <ref type="bibr" target="#b10">[MacQueen 1967]</ref>, neural PCA <ref type="bibr" target="#b16">[Oja 1982</ref>], stochastic sampling, scatterplot, histogram and fisheye table. These components are the ingredients used in an algorithmic 'cookbook', in which components deemed to suit particular data characteristics can be automatically connected to form hybrid algorithmic paths that span the grid of <ref type="figure">Figure 2</ref>. Examples are discussed in Section 5, following the next section's discussion of HIVE's internal structure and component composition model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation</head><p>The software has been implemented in Java SDK 1.4. The system architecture has been designed to let users compose visualisation tools using modular components for importing data, algorithmic processing and graphical rendering. In general terms, the architecture involves a graph manager that supports the user's composition of a flow of data through components such as scatterplots, K-means clustering, spring model layouts, table views and so forth. A view manager handles linked user interaction with these components.</p><p>The graph manager allows the user to incrementally create executable networks of components. It employs a scripting/composition model <ref type="bibr" target="#b14">[Nierstrasz et al. 1991</ref>] to impose constraints upon which modules can be connected and through which 'ports', depending upon factors such as the categorisation of data type mentioned in Section 3, as well as graph structure and port polarity (input only, output only, two-way). A user can manually connect together components, but be warned of potentially unsuitable or inefficient connections. Another mode offers an automatically generated default path through the grid of <ref type="figure">Figure 2</ref>, instantiating components based on the system's classification of the input data set.</p><p>The graph manager defines three types of components to support the construction of hybrid visualisations. These are (1) data source components to allow the import of disparate data sets and perform the required variable type transformations;</p><p>(2) algorithmic components to transform data into metadata and intermediate representations; and finally, (3) visualisation components for rendering. It should be noted that this system is not strictly a dataflow model since it is not the original data that is passed between components through links and ports, but references to the data and any transformations that are applied. The primary benefit of this is the more efficient support for tightly coupled interaction, e.g. brushing.</p><p>To facilitate extensibility, the visual modules that represent algorithmic processes and visualisations are all derived from a common Java class. This means that to accommodate new algorithms and visualisations, the programmer need only extend the base class and implement his/her own specific methods.</p><p>Visual components 'listen' to each other by way of their ports. When a programmer writes a component, he or she must declare the ports that are necessary for the functioning and communication of the component. Ports operate by extending the Java 'Observable' class and implementing the 'Observer' interface [http://java.sun.com/api/], so that when a link is made between two components, the ports at each end of the link register with each other. This simple approach means that a component can send a message to another connected component by sending data through one of its (observable) output ports to the (observer) input port of the other component.</p><p>There are five types of port that a visual component can implement. These consist of the one-way data-in, data-out, trigger-in and trigger-out ports, as well as the two-way 'select' port. When declaring ports, this type must be defined. However, data-in and data-out ports may also define the structure of the data that will pass through them as well as the variable types comprising those data. Two forms of data structure that the ports cater for are high-dimensional feature vectors that can consist of real, integer, string and date variables, and 2D real-valued coordinate vectors.</p><p>The system's composition model is responsible for laying down the rules for which ports can be connected, based upon these port types. These rules comprise the default composition model, however visual component implementations can override them to tighten or loosen connection constraints when required. An overview of these rules is as follows:</p><p>â¢ polarity -one-way ports can only be connected to their complement.</p><p>â¢ self-connection -ports on the same component cannot be connected</p><p>â¢ fan-in -one input port can only be linked to one output port</p><p>â¢ fan-out -one output port can be linked to many input ports</p><p>â¢ data-structure compatibility -data-in and data-out ports can only be connected when they are declared to handle the same data structure.</p><p>â¢ data-variable compatibility -data-in and data-out ports can only be connected when they are declared to handle the same variable types.</p><p>There is one exception to the data-structure compatibility rule above. This is to facilitate the semi-automatic generation of hybrid algorithms and occurs when the user connects a high dimensional output port such as the output of a data source component, to a 2D input port such as the input to a scatterplot. In this case HIVE classifies the data on the output port according to the ordinal ranges of dimensionality and cardinality as described in Section 3. Once this is complete, HIVE loads the appropriate algorithm from a default set of hybrid algorithms -the algorithmic 'cookbook'. These algorithms have been preclassified in their applicability in spanning the grid of <ref type="figure">Figure 2</ref>, and are inserted between the two components that the user had originally connected, thus restoring adherence to the datastructure compatibility rule described above.</p><p>When HIVE has finished this process the user can run or modify the algorithm and visualise his/her data. It is suggested that this functionality might aid inexperienced users of the system, as well as encourage experimentation with hybrid algorithmic conjunctions. If the user modifies the HIVE-generated algorithm, he/she can save it and specify that this should be used the next time HIVE is prompted to generate an algorithm under the same circumstances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Preliminary experience using HIVE</head><p>Early experience of the HIVE system was gained when exploring a data set gathered from an eScience project within the Equator Interdisciplinary Research Collaboration (www.equator.ac.uk). The eScience team has set up a remote sensing probe at a frozen lake in the Antarctic, which transmits data including ice thickness, water temperature, UV radiation levels etc. to environmental scientists at the University of Nottingham. The aim of this is to learn about carbon cycling processes. The data set was composed of 2202 probe measurements, each consisting of 16 variables measured at five-minute intervals between 17 th January 2003 and 31 st January 2003. This was converted into CSV format before importing it into HIVE.</p><p>Two algorithms were set up in parallel in HIVE and used to perform dimensional reduction of the data so that they could be rendered as a point distribution in scatterplots. One algorithm consisted of a neural PCA component and the other was generated automatically after the user specified the data set and visualisation tool, in this case a scatterplot. This latter algorithm was similar to the hybrid algorithm illustrated in <ref type="figure">Figure 1</ref> with the exception that it used K-means instead of stochastic sampling in initially reducing the representative cardinality. Both algorithms took less than five seconds to run. By setting up these two algorithmic paths in parallel, it was possible to directly compare the visualisations produced <ref type="figure">(Figure 3</ref>).</p><p>One notable difference between the visualisations was a small cluster made prominent by the hybrid spring model, especially in the intermediate view after the interpolation phase, which was not apparent in the PCA output. By linking a histogram to the scatterplots it was found that this cluster of points represented data where the photosynthetically active radiation (PAR) measurements at a depth of 10 metres were invalid. It turned out that these erroneous measurements were caused by the light level exceeding the sensor's maximum input threshold.</p><p>The two algorithms used here are examples of 'recipes' that are in the algorithmic cookbook mentioned in Section 3. Since the data set used here is deemed to be of moderate cardinality and dimensionality, K-means is applicable in reducing the representative cardinality (centroids) to make it low enough for Chalmers' spring model to converge very quickly and reduce the dimensionality to 2 dimensions. From here, the rest of the data set is interpolated onto the layout to restore the representative cardinality. A final spring model step is added to run for a small constant number of iterations to refine the final layout. This algorithm was generated by HIVE to span the grid in <ref type="figure">Figure 2</ref> from (M, M) to (L, M). If however, the cardinality of the data set was high, the algorithm would have had to span from (M, H) to (L, H), in which case HIVE would have generated a variant of the hybrid algorithm. In this case stochastic sampling would be employed instead of K-means in the initial phase, to speed things up. The other algorithm used in the exercise, neural PCA, was composed manually and can be regarded as a direct jump from (M, M) to (L, M) with respect to the algorithmic space in <ref type="figure">Figure 2</ref>.</p><p>This exercise demonstrated the fact that some algorithms can be more effective than others when employed in MDS. If PCA had been used alone, the anomalous data might have been overlooked, whereas the hybrid spring model made the cluster immediately apparent. Also, the value of the intermediate view after interpolation boosted the cluster's separation and made it more visible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Ongoing and Future Work</head><p>Our ongoing work is focused on implementing further visual modules to be included in the cookbook of hybrid algorithms that will span the simple 3x3 space represented in <ref type="figure">Figure 2</ref>. Algorithms to be considered include SOMs <ref type="bibr" target="#b9">[Kohonen et al. 2000</ref>] <ref type="figure">Figure 3</ref>. The leftmost scatterplot shows the output of neural PCA. The middle scatterplot shows the data after interpolation around the K-means centroids while the right scatterplot illustrates the output of the final spring model component. The highlighted cluster is a small subset of erroneous PAR measurements. These clusters are much clearer in the hybrid algorithm's plots than with PCA. The histogram shows the PAR distribution at a depth of 10 metres. The outlying peak (far-left) has been selected and this highlights the clusters in the scatterplots.</p><p>and Random Mapping <ref type="bibr" target="#b8">[Kaski 1998</ref>]. We are also experimenting with new algorithmic components such as <ref type="bibr">Morrison and Chalmers' O(N 5/4</ref> ) hybrid algorithm ]. These algorithms are being analysed with respect to the data types they can handle, their complexity in time and space, whether or not they produce visualisations as useful intermediate representations, and the order in which they should be applied in a hybrid conjunction. We will also investigate aggregation of visual modules, as described in Section 3, as a means of increasing abstraction and therefore simplifying visual programming. Given a larger 'palette' of components, we will then carry out user trials of the workspace and the framework.</p><p>One boundary issue that could impact on the implementation and usage of the proposed HIVE framework relates to applicable data formats. There are several well-established standards for encoding and handling data including the hierarchical data format (HDF) and others such as the common data format (CDF). For the HIVE framework to be adopted as a feasible information visualisation workspace in a non-experimental setting, the formats of data that it should be capable of importing, modifying, and possibly exporting, should employ these standards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>A framework for hybrid algorithmic development has been described and a system, HIVE, embodying the framework has been implemented. From our early experience with our prototype, we suggest that the hybrid approach has two-fold benefits: significant improvements in run times of MDS algorithms can be achieved, and intermediate views of the data and the visualisation program structure can provide greater insight and control over the visualisation process. In the near future, we intend to carry out user trials to test this opinion, and to derive system improvements and new design ideas.</p><p>Overall, we suggest that the growth in the number, variety and internal complexity of visualisation algorithms is a similar situation to the growth in the size and complexity of the data we visualise. While we are not yet at the stage of having hundreds or thousands of components to visualise, we feel that the task of constructing, adapting and using information visualisation tools is becoming a user activity that may benefit from system assistance. Visual programming is a promising first step in this direction, as we hoped to demonstrate in this paper, but there may be rich and useful work to do in using InfoVis techniques to support the understanding and use of InfoVis systems.</p></div>		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Luc Girardin and Dominique Brodbeck (Macrofocus) for the 'S' data set used in <ref type="figure">Figure 1</ref>, Alistair Morrison (U. Glasgow) for earlier work on the hybrid algorithms in <ref type="figure">Figures 1  and 3</ref>, and Stefan Rennick Egglestone and Chris Greenhalgh (U. Nottingham) for the Antarctic data.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Refining Initial Points for K-Means Clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">M</forename><surname>Fayyad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth International Conference on Machine Learning</title>
		<meeting>the Fifteenth International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="91" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interactive high-dimensional data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Buja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Swayne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational and Graphical Statistics</title>
		<imprint>
			<biblScope unit="page" from="78" to="99" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Brushing scatterplots</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cleveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technometrics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="127" to="142" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Linear Iteration Time Layout Algorithm for Visualising High-Dimensional Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chalmers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="127" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A heuristic for graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Congressus Numerantium</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">High Interaction Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Wills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="445" to="459" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ConMan: a visual programming language or interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Haeberli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="103" to="111" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An informal information--seeking environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Hendry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Harper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Society for Information Science</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="1036" to="1048" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dimensionality reduction by random mapping: Fast similarity computation for clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kaski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings International Joint Conference on Neural Networks</title>
		<meeting>International Joint Conference on Neural Networks</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="413" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Self Organization of a massive document collection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kohonen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kaski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lagus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Salojrvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Paatero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Saarela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transaction Neural Networks</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="574" to="585" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Some methods for classification and analysis of multivariate observations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Macqueen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 5th Berkeley Symposium</title>
		<meeting>5th Berkeley Symposium</meeting>
		<imprint>
			<date type="published" when="1967" />
			<biblScope unit="page" from="281" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Improving Hybrid MDS with Pivot-Based Searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chalmers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualisation</title>
		<meeting>the IEEE Symposium on Information Visualisation</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Achieving Sub-quadratic Multidimensional Scaling through the Combination of Sampling, Clustering and Layout Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chalmers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualisation</title>
		<meeting>the IEEE Symposium on Information Visualisation</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="152" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast Multidimensional Scaling through Sampling, Springs and Interpolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chalmers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Visualisation</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="68" to="77" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Objects + Scripts = Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tsichritzis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vicki De Mey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stadelmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ESPRIT Conference</title>
		<meeting>ESPRIT Conference</meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="534" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Snap-together visualization: can users construct and operate coordinated visualizations?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Human-Computer Studies</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="715" to="739" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Simplified Neuron Model as a Principal Component Analyzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Oja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical Biology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="267" to="273" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The application visualization system: a computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
