<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Visualization of Genealogical Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Mcguffin</surname></persName>
							<email>mjmcguff@cs.toronto.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravin</forename><surname>Balakrishnan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive Visualization of Genealogical Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques-interaction techniques; G.2.2 [Discrete Mathematics]: graph theory genealogy</term>
					<term>genealogies</term>
					<term>family trees</term>
					<term>kinship</term>
					<term>multitrees</term>
					<term>graph drawing</term>
					<term>graph theory</term>
					<term>graph browsing and navigation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>The general problem of visualizing &quot;family trees&quot;, or genealogical graphs, in 2D, is considered. A graph theoretic analysis is given, which identifies why genealogical graphs can be difficult to draw. This motivates some novel graphical representations, including one based on a dual-tree, a subgraph formed by the union of two trees. Dual-trees can be drawn in various styles, including an indented outline style, and allow users to browse general multitrees in addition to genealogical graphs, by transitioning between different dual-tree views. A software prototype for such browsing is described, that supports smoothly animated transitions, automatic camera framing, rotation of subtrees, and a novel interaction technique for expanding or collapsing subtrees to any depth with a single mouse drag.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Genealogy, the study of "family trees", plays a significant role in history (e.g. of royal families, and of human migration), genetics, evolutionary biology, and in some cases, religion. It also shows no sign of waning as a hobby of the public, especially given new software tools, databases, and means of communication and sharing made available by the internet.</p><p>Unfortunately, the depiction of relationships in a large family is challenging, as is generally the case with large graphs. The diagram in <ref type="figure">Figure 1</ref>, for example, contains many long edges, and doesn't clearly show which nodes are all in the same generation. Although there are a few hundred nodes in the diagram, these are organized around just a few lineages and nuclear families -many lines of ancestry and descent have been omitted. In addition, family trees (or genealogical graphs, as we will call them) are not arbitrary or unconstrained graphs -they have special structural properties that can be exploited for the purposes of drawing and interactive visualization. Interestingly, other than Furnas and Zacks <ref type="bibr" target="#b4">[5]</ref>, we have been unable to find previous work in the mathematical, graph theory, or graph drawing communities that analyzes the graph theoretic properties of genealogical graphs.</p><p>Although genealogical graphs are often referred to as family trees, this is misleading. Every individual has a tree of ancestors (sometimes called a pedigree), as well as a tree of descendants <ref type="figure" target="#fig_0">(Figure 2, left)</ref>, each of which can be drawn in familiar and easily understood ways. A drawing of both of these trees is sometimes called an hourglass chart in the genealogical community, and has been called <ref type="figure">Figure 1</ref>: Portion of a genealogical graph for an actual family, laid out manually, containing well over 600 individuals and spanning almost 400 years. (Sample data set supplied with GenoPro <ref type="bibr" target="#b6">[7]</ref>). a centrifugal view <ref type="bibr" target="#b4">[5]</ref> in the literature. (It is also similar to <ref type="bibr" target="#b20">[21]</ref>.) Hourglass charts only show some information, however. Each ancestor has themself a tree of descendants, and each descendant has a tree of ancestors (each of whom has a tree of descendants, etc.). It is not uncommon for users to experience frustration with diagramming software, where the user must repeatedly and manually move increasingly large subsets of nodes to create room for new data. It is also not obvious that the underlying structure is best described as a topological tree. Finally, trying to automatically draw such graphs leads to problems and design tradeoffs. : Left: Node x has a tree of ancestors (parents, grandparents, etc.) and a tree of descendants (children, grandchildren, etc.), both of which may be drawn with conventional tree-drawing techniques. Right: It is more challenging, however, to also show the descendants of y, or worse still, to show the descendants of every ancestor of x, and the ancestors of every descendant of x. Note: in this and other figures, squares represent males, circles females.</p><p>We present a brief analysis of genealogical graphs and identify how and why it is difficult to draw them. This motivates an investigation of alternative graphical depictions, leading to the development of a dual-tree scheme that generalizes hourglass charts, and that may be used for visualizing any multitree <ref type="bibr" target="#b4">[5]</ref>. We describe a software prototype that implements this scheme, that supports smoothly-animated rotations and transitions between dualtrees, and that uses a novel interaction technique for expanding or collapsing subtrees to any depth with a single mouse drag. Although this work is geared toward genealogy, some of the design principles and techniques used are also applicable in other domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Symposium on Information Visualization 2005</head><p>October 23-25, Minneapolis, MN, USA 0-7803-9464-X/05/$20.00 Â©2005 IEEE.</p><p>Genealogical relationships have been recorded and depicted for centuries, however the traditional charts appearing in books tend to be simple, usually showing at most a few dozen individuals, and are often organized around simple patterns such as lineages (e.g. one's father, paternal grandfather, etc.), or a single tree of ancestors, or a single tree of descendants. Commercial software packages enable the compilation of datasets with hundreds to thousands of individuals, but are not designed to automatically visualize such large data sets. They either require the user to arrange data manually, or have automatic layout algorithms that only operate on a subset of the data or that don't work well in all cases.</p><p>Yet, there is a significant demand for automatic visualization of data. The documentation for <ref type="bibr" target="#b6">[7]</ref> states "GenoPro wrote the AutoArrange routine to import Gedcom files, but noticed many are using the AutoArrange to layout their genealogy tree. This routine took several months to write, debug and test, yet generated more emails than all the other features combined. About 95% of all the genealogy trees GenoPro received by email were AutoArranged."</p><p>In addition, whether automatically generated or not, conventional charts of large, extended families inevitably contain at least some long edges or nodes displaced far away from their close relatives, to make room for other nodes (e.g. <ref type="figure" target="#fig_1">Figures 1 and 5</ref>). Thus, even given a robust automatic layout algorithm, it is not clear that displaying entire genealogical graphs of thousands of nodes would be ideal, since numerous long edges or edge crossings would make navigation and interpretation difficult. <ref type="bibr" target="#b0">1</ref> A better solution may be to display subgraphs that are automatically laid out, and allow the user to flexibly transition between subgraphs.</p><p>Bertin <ref type="bibr" target="#b1">[2]</ref> mentions an elegant way of drawing genealogical graphs, where each individual is a single line segment (thick for men, thin for women) and where nuclear families are points. Each line segment may connect two nuclear families: one in which the individual is a parent, and one in which they are a child (this is similar to p-graphs <ref type="bibr" target="#b21">[22]</ref>). Although such diagrams are much simpler looking than traditional ones, they ultimately suffer from the same exponential crowding (see Â§ 3.4).</p><p>Ted Nelson has proposed zzstructures (the generic name for ZigZag R ) as a general structure for storing information. It has been shown <ref type="bibr" target="#b11">[12]</ref> that zzstructures are equivalent to a kind of directed graph. Nelson has demonstrated that genealogical graphs can be encoded within zzstructures, using the scheme in <ref type="figure">Figure 4</ref>, D. The choice of this scheme, however, is due more to its compatibility with typical zzstructure visualizations, rather than due to an inherent appropriateness for genealogical graphs. For example, many visualizations of zzstructures are based on a 2D cursor centric view (described in <ref type="bibr" target="#b11">[12]</ref>), which can show one nuclear family at a focal point (parents and children arranged along perpendicular directions), surrounded by some extended family nodes. Unfortunately, such visualizations make it difficult to see which nodes are all within the same generation.</p><p>Multitrees <ref type="bibr" target="#b4">[5]</ref> are a kind of directed acyclic graph (DAG) where any two nodes are either connected by zero or 1 directed paths. In other words, multitrees are diamond-free DAGs, where a diamond is a pair of distinct directed paths from one node to another node. As a consequence, every node x in a multitree has a tree D(x) of descendants and a tree A(x) of ancestors ( <ref type="figure">Figure 3</ref>). Furthermore, the trees in a multitree can overlap: given nodes x and y in a multitree, D(x) and D(y) may share one or more subtrees, and if not, then A(x) and A(y) may share one or more subtrees. Furnas and Zacks <ref type="bibr" target="#b4">[5]</ref> explain how genealogical graphs constructed according to <ref type="figure">Fig-1</ref> One anecdote concerning a family reunion recounts how participants exceeded the area of four picnic tables in trying to layout their genealogical information. Another story reports the existence of a single data set containing 30000 interconnected individuals. ure 4, C can correspond to multitrees, if there is no intermarriage (i.e. diamonds). They also propose two visualization techniques for multitrees: a centrifugal view (essentially <ref type="figure" target="#fig_0">Figure 2</ref>, left) and a view of a directed path ("lineage") between two nodes along with children and parents of the path <ref type="bibr" target="#b4">[5]</ref>. <ref type="figure">Figure 3</ref>: Left: an example multitree. Observe that the two trees of descendants rooted at nodes A and C, respectively, share two subtrees, rooted at nodes F and P, respectively. Right: Node M is highlighted, along with its tree of ancestors and tree of descendants.</p><p>Anthropologists have studied systems of kinship, examining, for example, how family structures and terminology for describing one's kin vary across cultures, and how these relate to genealogy (e.g. <ref type="bibr" target="#b14">[15]</ref>). The current work focuses instead on issues relevant to graph drawing and visualization.</p><p>Our research differs from the previous work by analyzing in more detail some of the properties specific to genealogical graphs, and by proposing some novel graphical depictions of them. In particular, our dual-tree scheme generalizes the Furnas-Zacks centrifugal view/hourglass chart, and also generalizes the "lineage" view of the same authors <ref type="bibr" target="#b4">[5]</ref>. We investigate novel ways of displaying and interacting with dual-trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ANALYSIS OF GENEALOGICAL GRAPHS</head><p>In the following, some of the observations and concepts generalize to various non-traditional family arrangements, such as individuals having multiple spouses, or having more than two parents (e.g. adoptive in addition to biological). However, a traditional family model is a useful one to keep in mind, at least initially. Also, for convenience, the word "marriage" is used in a loose sense, to refer to the relationship between the parents of one or more children.</p><p>Some in the genealogical community <ref type="bibr" target="#b5">[6]</ref> have called for the ability to encode richer information and more kinds of relationships, e.g. foster children, family friends, etc. Increased freedom in a genealogical system would make it approach a general hypermedia system, with a correspondingly general interface. However, we have found that the constraints imposed by first following a traditional family model inspire interesting design and visualization possibilities. Future work may possibly extend or adapt our designs to include more kinds of family relationships.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preliminaries</head><p>We first establish some terminology to describe relationships between individuals. Beyond the familiar relationships of parent, child, ancestor, and descendant, we also consider consanguine relatives, i.e. individuals with a common ancestor (also called "blood relatives") such as siblings and cousins. In addition, we define conjugal relatives as individuals connected by an undirected path through one or more marriages. For example, brothers-in-law are conjugal relatives, as would be x and any of x's spouse's consanguine relatives.</p><p>Cousins are consanguine relatives whose most recent common ancestor occurs at n generations prior to the cousins, and in which case the cousins are (n â 1)th cousins (i.e. 1st cousins if they share a grandparent, 2nd cousins if they share a great-grandparent, etc.). Note that the cousin relationship is not transitive: individual x may have a cousin y on x's maternal side, and another cousin z on x's paternal side, however y and z are not, generally, cousins, though they are related conjugally through the marriage of x's parents. More generally, consanguine relationships are not transitive, but conjugal relationships are, since our definition allows them to pass through multiple marriages.</p><p>Finally, we use the term nuclear family to refer to (noramlly two) parents and their children.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Intermarriage and Pedigree Collapse</head><p>Intermarriage corresponds to an undirected cycle (i.e. a cycle in the underlying undirected graph) in a genealogical graph. We distinguish between two kinds of intermarriage: Type 1 intermarriage is between consanguine spouses, e.g. spouses who are also (possibly distant) cousins. Type 2 intermarriage is between spouses who are conjugal relatives via a path going through one or more marriages other than their own marriage. Examples of type 2 intermarriage include two sisters (or cousins) from one family marrying two brothers (or cousins) from another family not initially related to the first family. In the graphs we consider, all marriages are modelled -even those that are eventually dissolved. Thus, if a woman divorces a man x and marries his brother y, this constitutes type 2 intermarriage, because the woman was already conjugally related to y through her first marriage to x.</p><p>Assuming that the ancestry of an individual x is free of type 1 intermarriage, then x has 2 n ancestors at the nth generation prior to x. At a conservative 30 years per generation, this exponential number of ancestors exceeds the physical capacity of the earth at less than 2000 years into the past. We can therefore conclude that the ancestry of x must contain type 1 intermarriage. The phenomenon of encountering type 1 intermarriage in every individual's ancestry, when traced back far enough, is called pedigree collapse <ref type="bibr" target="#b17">[18]</ref>.</p><p>In addition, statistical modelling suggests that all humans alive today share a (not necessarily unique) common ancestor who lived just a few thousand years ago <ref type="bibr" target="#b16">[17]</ref>, implying that all living humans are "blood relatives".</p><p>Pedigree collapse guarantees that type 1 intermarriage occurs in every real-life genealogical graph, if extended back far enough in time. The presence of such diamonds in one's "tree" of ancestors obviously creates problems for drawing such a graph. Fortunately, many genealogical data sets are free of intermarriage because they do not extend back far enough in time, and in any case are usually locally free of intermarriage. Furthermore, algorithms and visualization techniques designed for acyclic graphs may be adapted to genealogical graphs containing intermarriage, by creating virtual duplicates of individuals to "hide" the cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Conditions Resulting in Trees, Multitrees, and DAGs</head><p>When are genealogical graphs really trees, or multitrees, or neither? This depends on the presence of type 1 and type 2 intermarriage, and on which scheme is used to construct the genealogical graph.</p><p>Let G be a genealogical directed graph (digraph) constructed according to one of the schemes B-E in <ref type="figure">Figure 4</ref>. If scheme B or C or E is used, then edges are always incident from younger to older nodes, thus G is a DAG. If scheme B or C or E is used, and there is no type 1 intermarriage (which would correspond to a diamond in G), then G is a multitree. If scheme B or D or E is used, and there is no type 1 or type 2 intermarriage, then the underlying undirected graph G is a free tree (also called a topological tree).</p><p>In many cases, then, a genealogical graph may be a free tree, or at least a DAG. Trees are planar, and many techniques exist for drawing them with no edge crossings. However, it is often desirable to see the nodes in a genealogical graph ordered by time, to <ref type="figure">Figure 4</ref>: A: conventional notation for a nuclear family: squares are male, circles female, and children extend downward from an edge connecting the parents. B-E show different ways of modelling such a family within a directed graph. B: the â symbol denotes a "spousal union" node. C: alternative scheme that avoids any special, intermediate node, but requires more edges when there are 3 or more children. D: Nelson's scheme for encoding families within zzstructures. Each child links to its next older sibling, and the eldest child links to the "spousal union" node. E: a variation on D that prevents cycles in the directed graph. make the generations in the graph apparent. Such an ordering is impossible to achieve in general without edge crossings. Partially relaxing the ordering by generation, so that each node is only "locally ordered" 2 with respect to its parents and children, allows edge crossings to be eliminated in a free tree. However, long edges are still generally unavoidable ( <ref type="figure" target="#fig_1">Figure 5</ref>). : Example situation where a long edge cannot be avoided, even if some branches are rotated. Also, the vertical ordering of nodes by generation is broken: it is not immediately apparent that nodes x and y are of the same generation -they are 3rd cousins. The ordering by generation could be restored by introducing edgecrossings, but at least one edge would still be long.</p><p>DAGs can be drawn automatically using standard algorithms, such as Sugiyama et al.'s <ref type="bibr" target="#b18">[19]</ref>. In this case, however, edge crossings and long edges are both unavoidable, and as with any automated graph drawing technique, the output from a 2D DAG embedder is increasingly difficult to use and understand as the size of the graph becomes very large. It is also possible that new algorithms designed with the specific properties of genealogical graphs in mind may scale better than generic DAG embedders.</p><p>The "bushiness" apparent in <ref type="figure" target="#fig_1">Figure 5</ref> illustrates a core problem in genealogical graphs, of nodes quickly becoming crowded as the graph is extended in various directions. The next section examines and quantifies this problem in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Crowding Within Genealogical Graphs</head><p>We now consider an idealized, simplified genealogical graph G * , and show that problems arise in trying to draw even this idealized graph. This motivates some non-traditional visual representations.</p><p>Let G * be a genealogical graph, constructed according to <ref type="figure">Figure 4</ref>, B, where every node has two parents, one sibling of the opposite gender, one spouse of the opposite gender, and where every marriage produces one child of each gender. Also assume that generations are well-defined, e.g. births are synchronized within each generation. Furthermore, G * contains no intermarriage, hence the underlying undirected graph is a free tree, and thus G * is planar.</p><p>Assume we want to draw a connected subset of G * such that nodes are all allocated the same size, and nodes in the same generation have the same vertical coordinate, so that each generation corresponds to a single row of nodes. <ref type="figure" target="#fig_2">Figure 6</ref> shows such a drawing, for 9 nuclear families spanning 4 generations. Ellipses indicate the directions in which G * extends. Intuitively, extending the portion of G * shown in all directions would require not only crossing edges (to maintain alignment of generations), but also lengthening certain edges to make room for expansion, causing certain spouses and/or siblings to become distant from each other. Ellipses indicate the many directions in which this diagram could be extended, suggesting that nodes would rapidly become crowded.</p><p>To reinforce this intuition, consider the set S of nuclear families at the same generational level as n 0 . <ref type="figure" target="#fig_2">Figure 6</ref> shows S = {n 0 , n 5 , n 6 , n 7 , n 8 , . . .}. Notice that n 0 is connected (via the intermediary families n 1 , n 2 , n 3 , n 4 ) to 4 other families n 5 , n 6 , n 7 , n 8 in S. Following the ellipses, each of n 5 , n 6 , n 7 , n 8 is connected (again through intermediaries) to 3 other nuclear families in S, each of which is in turn connected to another 3, etc. Even though S corresponds to a single generation of nuclear families, the paths connecting families in S correspond to a free tree, and the number of nuclear families in S that are r edges away from n 0 grows exponentially with r. Similarly, if we consider connections through increasingly distant ancestors, each node has 1 sibling, 4 first cousins, 16 second cousins, and 4 n nth cousins. Unfortunately, these nodes must be fit within a 1-dimensional row, where the space available only grows linearly with the geometric distance from the centre of the diagram. The consequence is that the edge-length-to-node-size ratio becomes arbitrarily high. This is reminiscent of Munzner's observation <ref type="bibr" target="#b12">[13]</ref> that, when embedding a tree in a Euclidean space of any dimensionality, the number of nodes grows exponentially with the level, but the space available only grows geometrically. The case in <ref type="figure" target="#fig_2">Figure 6</ref> is qualitatively worse, however, because the "exponential crowding" occurs within each and every generation as more and more of G * is displayed, rather than worsening progressively with deeper levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SOME ALTERNATIVE GRAPHICAL REPRESENTATIONS</head><p>The rapid crowding of nodes that occurs in genealogical graphs inspired us to explore graphical depictions that show different parts of the graph at different scales. By allocating progressively smaller areas to nodes, we might usefully pack more information into a single representation. <ref type="figure">Figure 7</ref> shows a fractal layout for G * . (More generally, such a fractal layout could also be used to depict any free tree.) There is no limit to the extent of the graph that could be drawn this way, however nodes eventually become imperceptibly small. Also notice that this depiction trades away an ordering of nodes by generation to gain non-crossing edges of bounded length. <ref type="figure">Figure 7</ref>: A fractal layout for G * , showing the same 9 nuclear families as in <ref type="figure" target="#fig_2">Figure 6</ref>, along with some additional nodes in grey.</p><p>Interactive browsing of the tree in <ref type="figure">Figure 7</ref> could be done by zooming and panning, or by having the user dynamically select the "focal" region that is shown largest in the centre. In the latter case, the resulting interactive visualization might be similar to fisheye graph browsers (e.g. <ref type="bibr" target="#b12">[13]</ref>), though it would differ in the details of how nodes surrounding the focal region are shifted and scaled.</p><p>In the process of exploring graphical depictions for genealogical graphs, we found it useful to consider the different ways in which rooted trees are represented. <ref type="figure" target="#fig_3">Figure 8</ref> shows what we consider to be the most basic styles for drawing rooted trees, 3 of which are identified in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9]</ref>. A familiar example of nested containment <ref type="figure" target="#fig_3">(Figure 8, B)</ref> are treemaps <ref type="bibr" target="#b7">[8]</ref>. The indented outline <ref type="figure" target="#fig_3">(Figure 8, D)</ref> representation may appear to simply be a variation on the node-link <ref type="figure" target="#fig_3">(Figure 8, A)</ref> representation, but in fact the indented outline style would still be unambiguous without any edges drawn: its essential feature is the use of indentation to imply structure. Many variations on the styles in <ref type="figure" target="#fig_3">Figure 8</ref> have been described in the literature, based, for example, on polar coordinate systems, or on embeddings in 3D rather than 2D, or on combinations of existing styles. The majority of new tree representations, however, have been applied to rooted trees, whereas free trees are drawn almost exclusively using the node-link style <ref type="figure" target="#fig_3">(Figure 8, A)</ref>. Nevertheless, representations based on rooted trees could be applied to free trees, if the user had a way of dynamically choosing a node to serve as a temporary "visual" root. The user would then be able to see the tree from different perspectives, by transitioning from using one node as a root to another. Such interaction might be useful for temporarily and visually highlighting various regions of the free tree.</p><p>This idea allowed us to adapt the nested containment style <ref type="figure" target="#fig_3">(Figure 8, B)</ref> to genealogical free trees resulting in a novel representation ( <ref type="figure">Figure 9</ref>). In general, nested containment representations could be used with any free tree, and thus with any genealogical graph where there is no intermarriage of type 1 or type 2. However, the representation can be simplified if we assume that, in addition to there being no intermarriage, every node participates in at most two nuclear families: one in which they are a child, and one in which they are a parent (in other words, nodes cannot have multiple spouses in different nuclear families). This assumption allows us to omit the "spousal union" â nodes <ref type="figure">(Figure 4, B)</ref> and leave these implicit, as we have done in <ref type="figure">Figure 9</ref>. In <ref type="figure">Figure 9</ref>, lower left and lower right, each individual corresponds to a rectangle, and each rectangle may have one nuclear family nested within it, and also be part of another nuclear family containing the rectangle. Parents appear in the upper half of a rectangle, and children in the lower half. Note that this representation would easily accommodate the case of nuclear families containing more than 2 parents, by simply subdividing the upper half of rectangles into more than 2 sub-rectangles. <ref type="figure">Figure 9</ref>: A free tree can be drawn using the nested containment style of <ref type="figure" target="#fig_3">Figure 8</ref>, B, if the user's current "focus" is used as a temporary root. Top: a genealogical graph, drawn using conventional notation. For simplicity, squares are used for all individuals, not just males. Lower left: the same graph, drawn using nested containment, with the nuclear family {F, I, O, P} as the root. This is analogous to the representation in <ref type="figure">Figure 7</ref>, with larger nodes containing smaller nodes rather than being connected to them with line segments. Lower right: now, the nuclear family {P, R,U,V,W } is the root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DUAL-TREES</head><p>Although the novel representations in <ref type="figure">Figures 7 and 9</ref> are interesting, they do not order nodes by generation. Their unfamiliarity might also make them difficult to interpret for many users. We now describe a scheme that is closer to traditional diagrams.</p><p>The general problem of scaling a visualization to graphs of thousands of nodes, and the added problem of dense crowding in genealogical graphs, convinced us to focus on visualizing only a subset of the graph at a time, and therefore to identify which subset might be best. Some general questions to ask in such a situation are: What are the canonical, or standard, subsets of the data that would be familiar to users? Which of these canonical subsets, or combinations of them, can be shown at once in a manner than is easy to interpret and that scales well?</p><p>In the case of genealogical graphs, two obvious canonical subsets are trees of descendants and trees of ancestors. As already mentioned, showing both of these at once <ref type="figure" target="#fig_0">(Figure 2, left; Figure 10</ref>, A) results in an hourglass chart. To show more information, we propose offsetting the roots of the trees with respect to each other, as in <ref type="figure" target="#fig_4">Figure 10</ref>, B. The result, which we call a dual-tree, is a more general kind of union of two rooted trees. (The result can also be thought of as a single free tree, or a "doubly rooted tree", following the observation in <ref type="bibr" target="#b4">[5]</ref> that the ancestors and descendants of a directed path in a multitree form a free tree.) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The dual-tree A(x) âª D(y) contains a superset of the information in an hourglass chart, because A(x) â A(y) and D(y) â D(x). In an hourglass diagram of A(x) âª D(x)</head><p>, the choice of x is a tradeoff between the number of ancestors and number of descendants revealed: choosing x in an older generation reveals a larger tree of descendants, but reduces the number of ancestors shown. In contrast, with dual-trees, we can always choose x and y to be in the most recent and oldest generations, respectively, to maximize the coverage of the subset displayed.</p><p>Because a dual-tree diagram consists of only 2 trees, it can be drawn in a straight-forward manner, and may prove to be easy to understand and interpret. It can be drawn with no edge crossings, with nodes ordered by generation, and it scales relatively well, since the crowding of nodes within it is no worse than the crowding that occurs in individual trees.</p><p>To combine two trees in the style of <ref type="figure" target="#fig_4">Figure 10</ref>, B and C, the root y of the tree of descendants must be a right-most node in the tree A(x) of ancestors. Likewise, x must be a left-most node of D(y). Thus, changing x or y generally requires rotating subtrees to make the new roots right-and left-most. One scenario in which the dualtree might be particularly useful is in families where surnames are passed down from the paternal side. In such a family, if y is chosen to be the oldest paternal ancestor of x, then the dual-tree would simultaneously contain every ancestor of x (in A(x)), as well as every individual having the same surname as x (in D(y)), or alternatively every individual having the same surname as any chosen ancestor of x. We are not aware of any other traditional and scalable depiction of families that can show this. For example, <ref type="figure" target="#fig_7">Figure 13</ref> shows Tom Smith, his ancestors, and other Smiths in single dual-tree. <ref type="figure" target="#fig_4">Figure 10</ref>, C is based on the node-link style of drawing trees <ref type="figure" target="#fig_3">(Figure 8, A)</ref>. The indented outline style <ref type="figure" target="#fig_3">(Figure 8, D)</ref>, however, is often more space-efficient, especially when nodes have long text labels, so we tried to adapt it to dual-trees. <ref type="figure" target="#fig_5">Figure 11</ref> shows the steps involved in this. The key to combine the two trees was to use an alternative convention for drawing edges taken from Venolia and Neustaedter <ref type="bibr" target="#b19">[20]</ref>, and analogous to the left-child, right-sibling pointer implementation of tree data structures <ref type="bibr" target="#b3">[4]</ref>. The result in <ref type="figure" target="#fig_5">Figure 11</ref>, C accommodates long text labels to the right or left of nodes without requiring new whitespace to be introduced between nodes, as would be the case in <ref type="figure" target="#fig_4">Figure 10</ref>, C. Note that dual-trees can be used to browse and visualize any multitree, even if some nodes have multiple spouses, or there is type 2 intermarriage, or some nodes have more than 2 parents. Note also that, in <ref type="figure" target="#fig_4">Figures 10, C and 11</ref>, C, nodes in the same generation are clearly shown as such, as they correspond to a single row or column, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">SOFTWARE PROTOTYPE FOR DUAL-TREES</head><p>To experiment with browsing based on dual-trees, a software prototype was developed, written in C++ using OpenGL and GLUT. The prototype reads in a GEDCOM file as input, from which a directed graph is constructed according to <ref type="figure">Figure 4</ref>, C.</p><p>The digraph is then pre-processed to remove directed cycles and diamonds to obtain a valid multitree. To do this, a breadth-first traversal identifies all undirected cycles in the underlying undirected graph. For each cycle, we count the number of times the edges change direction along the cycle, yielding a non-negative even integer. If the result is zero, we have a directed cycle in the digraph; if the result is 2, we have a diamond; if the result is 4 or more, this may or may not correspond to type 2 intermarriage but in any case is allowed in a multitree. So, if the result is zero or 2, we mark one of the edges involved to be skipped in the embedding algorithm. The display routine, however, can draw these special edges in an alternative colour, to highlight them.</p><p>The prototype only displays one dual-tree subset of the graph at a time, but allows the user to interactively transition from subset to subset and browse the entire graph, which might be very large. Each time a new dual-tree subset is chosen, the embedding routine is invoked to determine its layout. Two styles of layout are supported: classical node-link style, and indented outline style. Regardless of the style used, the embedding involves two stages: first, computing two preliminary embeddings E A and E D of the tree of ancestors and the tree of descendants, respectively, and second, combining E A and E D into a final embedding E F of the dual-tree.</p><p>In the case of classical node-link layout, E A and E D are computed with an adaptation of the Reingold-Tilford algorithm <ref type="bibr" target="#b15">[16]</ref>, though a slightly better implementation would use Buchheim et al.'s improvements <ref type="bibr" target="#b2">[3]</ref>. To combine E A and E D and produce E F , the embedding routine shifts E D so that it is beside E A , such that nodes in the same generation are aligned. Next, consider the set of nodes that appear in both trees, which we call the axis of the dual-tree, i.e. the path between the two roots. Each node n in the axis has a position p A given by E A and a position p D given by E D . The final position of n is computed as the weighted average p F = (ap A + d p D )/(a + d) where a and d are the number of ancestors and descendants, respectively, of n. Our rationale for this weighting is that we don't want the change in n's position to result in many edges having an extreme slope; thus, the more edges n has in one of the trees, the closer its final position should be to its position in the preliminary embedding of that tree.</p><p>In the case of the indented outline layout, E A and E D are computed in a simple recursive bottom-up pass. Next, pairs of consecutive nodes on the axis are "stretched out" so that E A and E D match up along the axis, and finally E F is produced (cf. <ref type="figure" target="#fig_5">Figure 11, B, C)</ref>.</p><p>In both cases, the time required for the entire embedding process is linear in the number of nodes embedded. <ref type="figure" target="#fig_0">Figure 12</ref> shows screenshots of output. The classical node-link layout can be done along two different orientations <ref type="figure" target="#fig_0">(Figure 12</ref>, top left and bottom left) yielding different total areas and aspect ratios. The area of the bounding rectangle for the indented outline layout <ref type="figure" target="#fig_0">(Figure 12</ref>, right) tends to be smaller than that of the other two layout styles, however its aspect ratio also tends to be far from 1. Such an aspect ratio could be an advantage, however, as it could simplify navigation, requiring the user to scroll mainly along just one direction in a zoomed-in 2D view. <ref type="figure" target="#fig_7">Figure 13</ref> shows the visual design of nodes in more detail. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Interaction Techniques</head><p>To transition between different dual-tree subsets, the basic operations performed by the user are: expanding/collapsing parents of a given node, and expanding/collapsing children of a node. These actions can be invoked through a 2-item marking menu <ref type="bibr" target="#b9">[10]</ref> affording ballistic "flick" gestures, in the direction of parents or children, to toggle their expansion state. Expanding a node can also cause automatic rotation. For example, if node n is in the tree of descendants, expanding upwards toward its parents requires that n first be . Black edges are part of the dual-tree, and nodes with bold borders lie on the axis, or path between the two roots. Additional edges from children to parents are shown in grey, to make nuclear families more apparent. For example, Rick and Susan are siblings, sharing the same parents Irene and Edgar, however Janet is a half-sibling with a different mother, as shown by the lack of a grey edge from her to Irene. Grey dots on either side of a node provide previews of the number of parents or children that the node has. Preview dots that are too numerous are collapsed into oblong shapes (e.g. under Saul and Mary), and shown in full when the cursor rolls over the node, as shown under Ethel (Top). Once over a node, the user can reveal hidden parents and children by flicking in the appropriate direction to expand the node.</p><p>rotated onto the axis. Such rotations generally require that certain other nodes be collapsed, to maintain the dual-tree scheme.</p><p>Expansion, collapsing, and rotation of nodes is shown with smooth, 1-second animations to help the user maintain context <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">23]</ref>. As in <ref type="bibr" target="#b13">[14]</ref>, our animation has 3 stages: fading out nodes which need to be hidden, moving nodes to their new positions, and fading in newly visible nodes. Although many nodes may need to move in different directions during a transition, the user may benefit from tracking even just a few nodes that serve as visual anchors or landmarks. We feel that even a complicated animation is better than no animation at all, and could always be slowed down if the user wishes with a technique such as the dial widget in <ref type="bibr" target="#b10">[11]</ref>.</p><p>The user may zoom and pan the 2D view of the graph with the mouse, and optionally activate automatic camera framing that is animated during transitions.</p><p>In browsing genealogical graphs, we have found it is often desirable to expand downward from an individual to their most recent descendants, or to expand upward to their oldest ancestors. This can be done with the marking menus using a sequence of flicks, with one or more flicks for each generation. However, an even faster method is available through a subtree-drag-out widget for "dragging out" subtrees to any depth. To use this widget, the user first clicks down (with a secondary mouse button) on a node <ref type="figure">(Figure 14,  A)</ref>, and then drags either up or down (i.e., toward ancestors or descendants) to select the subtree on which they want the widget to operate. After this initial drag, the length and colouring of the widget <ref type="figure">(Figure 14, B)</ref> indicate both the maximum depth of the subtree, and also the depth to which the subtree is currently expanded. The user may drag towards the subtree, to expand it further one level at a time, or away from the subtree, to collapse it one level at a time. In keeping with a metaphor of relative adjustment, the user may also release over the centre of the widget, to dismiss it with no effect, which is useful for cancelling. <ref type="figure">Figure 14</ref>: A semi-transparent popup widget for expanding or collapsing subtrees in a single drag. The user pops up the widget over a node (A), and may now drag up or down to select whether to operate on the tree of ancestors or descendants. After dragging down slightly, the tree of descendants has been selected (B), and now the widget displays the number of levels the user could drag to change this tree: at most 4 levels down to expand to the full depth, or at most 2 levels up to collapse. Furthermore, the first 2 levels down are shaded in to indicate that they are already partially expanded. C and D show the subsequent feedback after dragging down almost 3 levels, or up 1 level, respectively. Releasing the mouse button completes the operation. The node's tree of ancestors could similarly be expanded or collapsed in a separate invocation of the widget.</p><p>After popping up this widget and performing the initial drag to select the subtree to operate on, the user may then drag ballistically to quickly open or close the entire subtree. Although in general subtrees may be quite large after just a few levels, the trees of descendants and ancestors in typical genealogical data tend to be fairly shallow, seldom spanning more than a few hundred years. Furthermore, even though the user may ballistically expand multiple subtrees upward and downward in quick succession, the automatic rotations that result from expansion often cause other nodes to disappear, thus the user is much less likely to experience an "explosion" in the number of expanded nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">INITIAL USER FEEDBACK</head><p>As a first step toward evaluating our prototype and informing design changes, an informal session was held to solicit feedback from a practicing genealogist who has also lectured on genealogy. The user reported using computers an average of 2 hours/day, and is familiar with two common genealogy software packages. The session lasted 1 hour, and consisted of a mixture of free-form exploration by the user, demonstration and explanation by the first author, and semistructured navigation tasks given to and performed by the user.</p><p>After some time interacting with the prototype, the user reported finding it "very clear" and "very easy", and was "impressed with its manoeuvrability". (Note that, at the time the session was held, the subtree-drag-out widget had not yet been implemented. The user did, however, discover and successfully operate the marking menus with no help.)</p><p>The user also commented that the "unfamiliarity" of the depiction of family relationships "takes getting used to". The user mentioned the lack of a symbol explicitly linking spouses, which is shown in conventional diagrams.</p><p>The user successfully completed all navigation tasks, even though these required expanding upward and downward multiple times, and even when using the indented outline style dual-tree. The user was also able to correctly interpret indented outline depictions, pointing out the parents and children in nuclear families.</p><p>The user was also shown printouts of sample output from a commercial genealogy software package, and asked for opinions, comments, or personal preferences in comparing the different diagrams and the output of the prototype. The user seemed rather neutral, and so was given an explanation of some potential positive and negative differences between the dual-tree scheme and other representations. The user remained neutral, however, saying "I can understand [each of the depictions]. [...] I don't know that there are any pros or cons."</p><p>Of course, more sessions with other users would be necessary to gain a fuller comparative picture, however we are encouraged by the fact that the user was able to interact with and interpret the output of our prototype.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS AND FUTURE DIRECTIONS</head><p>We have analyzed the nature of genealogical graphs, characterized how they are difficult to draw, and presented novel graphical representations for them. In particular, our dual-tree scheme scales as well as a single tree, orders nodes by generation with no edge crossings, is easy to interpret, can be used for browsing any multitree, and generalizes both the hourglass chart/centrifugal view of Furnas and Zacks and the "lineage" view of the same authors <ref type="bibr" target="#b4">[5]</ref>. Furthermore, our interaction technique for expanding or collapsing subtrees to any depth with a single mouse drag could be used in other domains for general tree browsing, and might possibly be adapted for general graph browsing.</p><p>Dual-trees can show many generations vertically, but have a horizontal extent limited to ancestors or descendants of 2 root nodes. Although these roots can be changed interactively to traverse a data set, only a fraction of a large data set may be visible at any given time. To increase the horizontal extent of nodes shown, without introducing long or crossed edges, the dual-tree scheme could be generalized to a sequence of N trees, laid out left-to-right and alternating between ancestor and descendant trees, all shown at once. Another possibility is to embed combinations of ancestor and descendant trees in 3D, e.g. by arranging intersecting trees on perpendicular planes. Use of 3D could eliminate the need to rotate subtrees, possibly giving the user a more consistent view of the data.</p><p>It would also be useful to have graphical representations that are oriented toward higher-level groupings of individuals, such as family units. For example, a viewer for a dual-tree A(x) âª D(y) could be augmented to also show siblings of nodes in A(x), and spouses of nodes in D(y). This would increase the crowding of nodes somewhat, but would make complete nuclear families visible.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2</head><label>2</label><figDesc>Figure 2: Left: Node x has a tree of ancestors (parents, grandparents, etc.) and a tree of descendants (children, grandchildren, etc.), both of which may be drawn with conventional tree-drawing techniques. Right: It is more challenging, however, to also show the descendants of y, or worse still, to show the descendants of every ancestor of x, and the ancestors of every descendant of x. Note: in this and other figures, squares represent males, circles females.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5</head><label>5</label><figDesc>Figure 5: Example situation where a long edge cannot be avoided, even if some branches are rotated. Also, the vertical ordering of nodes by generation is broken: it is not immediately apparent that nodes x and y are of the same generation -they are 3rd cousins. The ordering by generation could be restored by introducing edgecrossings, but at least one edge would still be long.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 :</head><label>6</label><figDesc>A portion of an idealized genealogical graph, G * . Nine nuclear families are shown (each outlined in pink), labelled n 0 , . . . , n 8 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 :</head><label>8</label><figDesc>Different graphical representations of the same rooted tree. A: node-link. B: nested containment, or enclosure. C: a layered "icicle" diagram, that uses adjacency and alignment to imply the tree structure. D: an indented outline view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 10 :</head><label>10</label><figDesc>Combinations of canonical subsets of genealogical graphs. A: The tree A(x) of ancestors and tree D(x) of descendants of x form an hourglass diagram. B: This dual-tree scheme shows more information, by showing D(y) â D(x). C: An example dual-tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 11 :</head><label>11</label><figDesc>Three stages in adapting the indented outline style to dual-trees. The nodes and labels are the same as inFigure 10, C. A: Each tree is drawn in indented outline style. B: Edges are drawn in an alternative way, to clear the space between the trees. Arrows show matching nodes in both trees. C: The two trees combined.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 12 :</head><label>12</label><figDesc>A dual-tree laid out 3 different ways by the prototype. Nodes are coloured by gender. Upper Left: Classical node-link, similar to Figure 10, C, with generations progressing top-to-bottom. Lower Left: Classical node-link, with generations progressing left-toright. Right: Indented outline style, similar to Figure 11, C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 13 :</head><label>13</label><figDesc>Another dual-tree under 3 layouts: classical node-link top-to-bottom (Top) and left-to-right (Lower Left), and indented outline style (Lower Right)</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">In graph drawing terminology, locally ordered means upward, and (globally) ordered by generation means upward and layered by generation.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">ACKNOWLEDGEMENTS</head><p>Many thanks to Derek G. Corneil, Shigeru Owada, Alicia Servera, June E. McGuffin, Daniel Morin, Dallan Quass, Jean Bryan, our anonymous reviewers, and the user who gave us feedback on our prototype, for their valuable support, help, suggestions, and time.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Can motion increase user interface bandwidth?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bartram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Systems, Man and Cybernetics</title>
		<meeting>IEEE Conf. Systems, Man and Cybernetics</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="1686" to="1692" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bertin</surname></persName>
		</author>
		<title level="m">SÃ©miologie graphique: Les diagrammes, Les rÃ©seaux, Les cartes.Ãditions Gauthier-Villars</title>
		<meeting><address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1967" />
		</imprint>
	</monogr>
	<note>2nd edition 1973</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Improving Walker&apos;s algorithm to run in linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Buchheim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>JÃ¼nger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Leipert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD)</title>
		<meeting>Graph Drawing (GD)</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multitrees: Enriching and reusing hierarchical structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Furnas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zacks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conference on Human Factors in Computing Systems (CHI)</title>
		<meeting>ACM Conference on Human Factors in Computing Systems (CHI)</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="330" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Genealogy in the new times</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">B</forename><surname>Hoffman</surname></persName>
		</author>
		<ptr target="http://www.genealogy.com/genealogy/61gary.html" />
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Genopro</forename><surname>Inc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Genopro</surname></persName>
		</author>
		<ptr target="http://www.genopro.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Tree-maps: A space-filling approach to the visualization of hierarchical information structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization (VIS)</title>
		<meeting>IEEE Visualization (VIS)</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming, Volume I: Fundamental Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="page" from="309" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The limits of expert performance using hierarchic marking menus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kurtenbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conference on Human Factors in Computing Systems (CHI)</title>
		<meeting>ACM Conference on Human Factors in Computing Systems (CHI)</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="482" to="487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Expand-Ahead: A space-filling strategy for browsing trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Mcguffin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Davison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization (InfoVis)</title>
		<meeting>IEEE Symp. Information Visualization (InfoVis)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="119" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">McGuffin and m. c. schraefel. A comparison of hyperstructures: Zzstructures, mSpaces, and polyarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th ACM Conference on Hypertext and Hypermedia (HT)</title>
		<meeting>15th ACM Conference on Hypertext and Hypermedia (HT)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="153" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">H3: Laying out large directed graphs in 3D hyperbolic space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization (InfoVis)</title>
		<meeting>IEEE Symp. Information Visualization (InfoVis)</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SpaceTree: Supporting exploration in large node link tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Grosjean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Information Visualization (InfoVis)</title>
		<meeting>IEEE Symp. Information Visualization (InfoVis)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Formal analysis of kinship terminologies and its relationship to what constitutes kinship</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Read</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Anthropology and Cultural Theory</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2000-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Tidier drawings of trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Tilford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Engineering, SE</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="223" to="228" />
			<date type="published" when="1981-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Modelling the recent common ancestry of all living humans</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L T</forename><surname>Rohde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Olson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="issue">7008</biblScope>
			<biblScope unit="page">431</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The Mountain of Names: A History of the Human Family</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shoumatoff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Simon &amp; Schuster, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Methods for visual understanding of hierarchical system structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="109" to="125" />
			<date type="published" when="1981-02" />
		</imprint>
	</monogr>
	<note>SMC-</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Understanding sequence and reply relationships within email conversations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Venolia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Neustaedter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conference on Human Factors in Computing Systems (CHI)</title>
		<meeting>ACM Conference on Human Factors in Computing Systems (CHI)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="361" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A ZoomTree interface for searching genealogical information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wesson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mc Du Plessis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Oosthuizen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM AFRIGRAPH &apos;04</title>
		<meeting>ACM AFRIGRAPH &apos;04</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="131" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Representing and computing kinship: A new approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Jorion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Current Anthropology</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="454" to="463" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Visual momentum: a concept to improve the cognitive coupling of person and computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Woods</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Man-Machine Studies</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="229" to="244" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
