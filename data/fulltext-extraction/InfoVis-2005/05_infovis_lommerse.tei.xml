<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Visual Code Navigator: An Interactive Toolset for Source Code Investigation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerard</forename><surname>Lommerse</surname></persName>
							<email>g.l.p.m.lommerse@student.tue.nl</email>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universiteit Eindhoven</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Freek</forename><surname>Nossin</surname></persName>
							<email>f.nossin@student.tue.nl</email>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universiteit Eindhoven</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucian</forename><surname>Voinea</surname></persName>
							<email>lvoinea@win.tue.nl</email>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universiteit Eindhoven</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandru</forename><surname>Telea</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universiteit Eindhoven</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">The Visual Code Navigator: An Interactive Toolset for Source Code Investigation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR categories: H.5.2[User interfaces]: evaluation/methodology</term>
					<term>I.3.2 [Graphic systems]: stand-alone systems</term>
					<term>J.7 [Computers in other systems]: command and control source code visualization, multiple views, treemaps, pixel-filling displays, source code analysis</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present the Visual Code Navigator, a set of three interrelated visual tools that we developed for exploring large source code software projects from three different perspectives, or views: The syntactic view shows the syntactic constructs in the source code. The symbol view shows the objects a file makes available after compilation, such as function signatures, variables, and namespaces. The evolution view looks at different versions in a project lifetime of a number of selected source files. The views share one code model, which combines hierarchical syntaxbased and line-based information from multiple source files versions. We render this code model using a visual model that extends the pixel-filling, space partitioning properties of shaded cushion treemaps with novel techniques. We discuss how our views allow users to interactively answer complex questions on various code elements by simple mouse clicks. We validate the efficiency and effectiveness of our toolset by an informal user study on the source code of VTK, a large, industry-size C++ code base.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Program understanding is an important aspect of software maintenance. Current industrial projects are often based on collaborative development of millions of code lines. Industry practice studies have shown that maintainers spend 50% of their time on understanding this code <ref type="bibr" target="#b15">[16]</ref>. In this context, software visualization addresses several facets of program and process understanding, such as reverse engineering and process recovery and execution and algorithm animation.</p><p>In this paper, we focus on the first goal. We introduce the Visual Code Navigator (VCN), a toolset that provide three different, but strongly interconnected views on software source code. VCN aims to help the developer understand the structure, and its changes, of large software systems.</p><p>We start solely from the code base, i.e. a set of source code files, since this is often the only up-to-date, reliable source of information on a software project, and also the main material involved in the maintenance phase. Moreover, we believe that visualization tools must be tightly and non-disruptively integrated with the programmers' accepted way of working, i.e. directly reflect, and make use of, the source code itself.</p><p>VCN consists of three interrelated tools, or views, on the code base. The syntactic view shows the code syntactic constructs, such as classes, functions, statements, identifiers, and so on. The symbol view lets one see the symbols the code base makes available after compilation, e.g. functions, variables, and namespaces. Finally, the evolution view shows several versions of several source files during a project lifetime. Each view visualizes a different hierarchical aspect of the code base: text lines in file versions in the evolution view, syntactic structures in the syntactic view, and data/code symbols in the symbol view. The views use the same visual model to show hierarchical containment, based on the space partitioning properties of shaded cushion treemaps. For this, we extend the shaded cushions, as introduced in <ref type="bibr" target="#b25">[26]</ref>, with several new techniques. The three views are dense pixel displays that map up to thousands of source code artifacts on a single screen, allowing efficient zoom and pan techniques to quickly get overviews of large code bases and also details on demand.</p><p>The structure of this paper is as follows. In Section 2, we review related work on source code visualization. Section 3 outlines the code data model, i.e. how we acquire and represent source code information. Section 4 presents the three different, but correlated, views that visualize source code in VCN, and discusses several design and implementation techniques. In section 5, we illustrate our tools and techniques with the analysis of the source code of VTK, a large and complex C++ class library. Finally, section 6 discusses the contribution we bring to source code visualization and outlines future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>We define the goal of source code visualization using the five dimensions model of Maletic et al <ref type="bibr" target="#b11">[12]</ref>: task, audience, target, medium, and representation. The main task is to gain insight in the structure and semantics of a given code base. Specifically, we focus here on detailed, code-level understanding, as compared e.g. to getting architectural overviews of a code base <ref type="bibr" target="#b18">[19]</ref>. The intended audience is mainly composed of code developers and maintainers, i.e. persons directly interested and involved in writing and manipulating source code as such, as opposed to e.g. system architects, who often manipulate code in terms of black-box components or packages rather than textual source. However, given the overview capabilities provided by the nested cushion techniques we use, our audience includes also system architects who need to quickly get condensed snapshots of a whole subsystem, and, from there, drill down to specific code details. The target of visualizations is the code base, i.e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Symposium on Information Visualization 2005</head><p>October 23-25, Minneapolis, MN, USA 0-7803-9464-X/05/$20.00 ©2005 IEEE.</p><p>the set of source code files involved in a project. We are also interested in grasping the source code evolution, so we assume the code is stored in a version control management system, such as CVS. We focus here on code written in C/C++, so our visualizations use, and reflect, language-specific syntactic information. The intended visualization medium is the standard PC graphics display used by most integrated development environments (IDEs). Finally, the representation is formed by dense-pixel displays that use shaded cushions to convey code hierarchy.</p><p>The challenge of source code visualization has been addressed by several tools. At one end of the granularity spectrum, tools such as Rigi <ref type="bibr" target="#b19">[20]</ref>, SHriMP <ref type="bibr" target="#b16">[17]</ref>, or SoftVision <ref type="bibr" target="#b17">[18]</ref> are used in reverse engineering to understand subsystem structure and dependencies. The code base is a hierarchy of functions, classes, components, or packages. Usually, these tools do not reflect the source code layout itself, but strive to optimize the spatial code graph layout. Moreover, such tools do not show low-level system details, such as the many, minute source code edits done during debugging or the inner control flow of modules.</p><p>At the other end of the spectrum, tools such as SeeSoft <ref type="bibr" target="#b3">[4]</ref> and Augur <ref type="bibr" target="#b6">[7]</ref> offer a line-oriented code representation colored by code attributes and metrics. These tools use the assumption that developers are comfortable with visualizations that present the code in the same spatial context in which it is constructed (i.e. written). While maintaining the 2D code line layout from a source file, they reduce a code line to a pixel line, thus condensing tens of thousands of lines on a single screen. This idea was first proposed by Eick et al. in SeeSoft <ref type="bibr" target="#b3">[4]</ref> and was further refined by several tools: Augur, Aspect Browser, GSee, sv3D, Tarantula, Gammatella, Almost and CVSscan. Augur <ref type="bibr" target="#b6">[7]</ref> combines information about artifacts and activities of a software project at a given moment. Aspect Browser <ref type="bibr" target="#b8">[9]</ref> uses regular expressions to locate specific artifacts (e.g. keywords) and visualizes their distribution. GSee <ref type="bibr" target="#b5">[6]</ref> tries to bridge the gap between fine and coarse-grained visualization tools, combining both elements in an orchestrated environment. sv3D <ref type="bibr" target="#b12">[13]</ref> uses a 3D line-based code representation to compact the space needed for display. Tarantula <ref type="bibr" target="#b10">[11]</ref> is the first tool to use color and a lineoriented display to present test line coverage overviews. A similar approach is proposed by Almost <ref type="bibr" target="#b14">[15]</ref>, a program trace visualization tool. This idea is further developed by Gammatella <ref type="bibr" target="#b13">[14]</ref>, which uses treemaps to show system-level test file coverage overviews. CVSscan <ref type="bibr" target="#b22">[23]</ref> is the first to visualize by a line-based display the entire evolution of a file.</p><p>However, these tools mostly fall at one or the other end of the granularity spectrum, and only a few try to bridge the gap. Moose <ref type="bibr" target="#b2">[3]</ref> and Concept <ref type="bibr" target="#b1">[2]</ref>, for example, focus on exposing a comprehensive model of software, with different granularity levels, that can be further visualized. However, they currently lack the supporting visualization palette. GSee <ref type="bibr" target="#b5">[6]</ref> and Gammatella <ref type="bibr" target="#b13">[14]</ref>, on the other hand, bring only fine (code lines) and coarse grained (files) elements together, and bind them through correlations. In this paper, we attempt a finer sampling of the granularity scale, supported by a rich set of visualization tools. We use line based displays and treemaps to depict also middle-sized artifacts such as syntactic constructs (e.g. function and class bodies) as well as artifacts resulting from compilation (e.g. namespaces and variables). We combine our multi-scale visualizations in an orchestrated environment that offers details on demand and enables code correlations across multiple versions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CODE DATA MODEL</head><p>Our data source is the information stored in the CVS version control management system. This consists of several versions V ij of several source files F j , as well as, for every version, its commitment date (time when it was added to the CVS repository), and author (who committed it). To decouple CVS from the visualization itself, data extraction is done by a separate tool. Our main visualization focus is a set of related source files F j , called a project. Once all versions V ij of all files in a project are extracted, we pass them to a syntax fact extractor built by us. This is a modified GNU C/C++ compiler, with no code generation, which extracts the annotated syntax tree from the source code. This contains elements such as classes, data members, function signatures, macros, templates, for-loops, etc. <ref type="bibr" target="#b4">[5]</ref>. Our data model contains thus, for every project P, the source code of all P's files and, for every file F j , an annotated syntax tree with all constructs in F j . Essentially, our code data model captures the whole information range from local details, such as the contents of every single code line, to global structure, such as the global syntactic constructs in files and files in project structuring. Essentially, the above resembles the DATRIX code model extracted by the CPPX C++ source code analyzer <ref type="bibr" target="#b9">[10]</ref>.</p><p>The code data model is thus a set of related hierarchies, visualized by our three views, as follows. The evolution view shows the file versions in a project's evolution, the files in a project, and the text lines in a file. The syntactic view shows all syntax constructs in a file's syntax tree, i.e. reflects an implementation perspective. The symbol view shows the nesting of symbols in a compiled (object code) project, e.g. function signatures, classes, and data objects in namespaces, i.e. uses an interface perspective. Given that the hierarchical code relations are closely interrelated, our three views also have tightly coupled functionality. This is presented next.</p><p>Throughout the presentation, we use code examples from the VTK code base. More details about our visualization case study are given in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">VISUALIZATION MODEL</head><p>We have chosen to use shaded cushions to represent the various hierarchies present in our data model (Section 3), for several reasons. First, shaded cushions can show up to thousands of elements in tree-like hierarchies on a single screen, as shown by various applications <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>. This is essential, since we want to visualize large, real-world code bases. Second, cushions combine best with two-dimensional spatial layouts. This serves us well, as we believe our target developer user group is most confident and comfortable with 2D layouts. Moreover, if we do not impose specific constraints on the layout to use, cushions can be combined with treemaps to make the most of the available screen space for displaying hierarchies. We use this cushion treemap combination in our symbol view (Section 4.2).</p><p>In the syntactic and evolution views, we choose to use a different, code-oriented layout: the x axis maps the files visualized together, and the y axis maps the lines in a file. Here, we give up the treemap layout, but can still use cushions to effectively convey the hierarchy, by using a new cushion shape and shading (Section 4.1). Third, we implement several efficient cushion rendering methods, which allow us to perform interactive zoom and pan in our views, an essential aspect from a usability perspective. Finally, we use color encoding to display code attributes via the cushions.</p><p>We detail next the design and implementation of our three views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Syntactic view</head><p>The syntactic view shows the syntactic constructs in a given file. For every construct, we render a cushion whose geometric outline encompasses the construct's text extent. Given the way constructs nest in source code, a cushion has the dotted line shape sketched in <ref type="figure" target="#fig_0">Figure 1a</ref>, consisting of one 'body' rectangle of size (w, h-2h l ) and two 'indent' rectangles of sizes (w s , h l ) and (w e , h l ), where w s and w e are the start and end indents respectively and h l the font height. Note, however, that this is the most complex shape cushions may have, and occurs only in presence of extreme code indentation. Usually, code cushions consist of a body rectangle and, optionally, the lower indent rectangle (see <ref type="figure" target="#fig_2">Figure 3</ref>). The code cushion we propose is shown rendered in <ref type="figure" target="#fig_0">Figure 1b</ref>. To create this rendering, we extend the rectangular cushions <ref type="bibr" target="#b25">[26]</ref>, as follows. First, we define a 1D height profile f. This is a function with range [0..1] that consists of a bevel of width w f followed by a plateau region <ref type="figure" target="#fig_0">(Figure 1d</ref>). For the bevel, we used various monotonically increasing functions with the conditions f (0) = 0, f (w f ) = 1, f '(w f ) = 0. In practice, we found an elliptic sector for f and a value w f of 0.3 to give the most aesthetically pleasing results. Next, we construct a 2D profile T(x,y) = g(x) g(y), where</p><formula xml:id="formula_0">   ∈ − ∈ = ] 1 , 2 / 1 [ ), 1 ( ] 2 / 1 , 0 [ ), ( ) ( x x f x x f x g</formula><p>This profile is essentially similar to the parabolic one used by the original cushion treemaps <ref type="bibr" target="#b25">[26]</ref>, with the difference that it has a plateau (flat) region in the middle of width 1 -2w f , as sketched by the dotted profiles in <ref type="figure" target="#fig_1">Figure 2</ref>. However, if we directly use T as height profile scaled over the rectangle [0..w,0..h] for our code cushion, we do not get the result in <ref type="figure" target="#fig_0">Figure 1b</ref>. Indeed, T does not have zero values on the concave indent borders (left, top, bottom, and right borders of rectangles A, B, B', and A' respectively in <ref type="figure" target="#fig_0">Figure 1c</ref>). To achieve this, we use a cushion height profile H (x,y) defined as follows:</p><formula xml:id="formula_1">H (x,y) = T T T x T T -y T T x T -y T T -x T T y T T -x T y , x ∉ A∪B∪C∪A'∪B'∪C' , x ∈ A , x ∈ B , x ∈ C , x ∈ A' , x ∈ B' , x ∈ C' A B C C B' A' C' C'</formula><p>To explain the above, consider the subdivision of the cushion shape sketched in <ref type="figure" target="#fig_0">Figure 1c</ref>. Outside the six border rectangles A, B, C, A', B', and C', the profile H coincides with the rectangular profile T. Inside these rectangles, we multiply T with four bias functions T x , T -x , T y , and T -y , in order to obtain a profile H that is zero at the outer cushion border and increases towards the inside as specified by the 1D profile f depicted in <ref type="figure" target="#fig_0">Figure 1d</ref>. The bias functions T x , T -x , T y , and T -y are simply translated, scaled, and rotated copies of f. If we think of them being luminance textures, then, given a rectangle R with origin (R x ,R y ) and sizes (R w ,R h ),  <ref type="figure" target="#fig_0">Figure 1b</ref> shows the final result.</p><formula xml:id="formula_2">then R x T (x,y) = f(x-R x )R w , R y T (x,y) = f(y-R y )R h , R x T − (x,y) = f(R x -x)R h , and R y T − (x,y) = f(R y -y)R h . Practically, we construct H w e a) b) w s h l w h c) d) f(x) x w f 1 0 1 x y w s /2 w e /2 A B C C' B' A' h/2</formula><p>To render a nested code structure, we must now combine the cushion height profiles H defined above. The original solution for this <ref type="bibr" target="#b25">[26]</ref> was to sum up parabolic height profiles and illuminate the result <ref type="figure" target="#fig_1">(Figure 2a</ref>). In our case, since w f &lt; 1 (in practice, w f = 0.3), the profiles of the deeper nested cushions <ref type="figure" target="#fig_1">(Figure 2b</ref>, continuous line) fall within the plateau (flat) region of the enclosing cushions ( <ref type="figure" target="#fig_1">Figure 2b</ref>, dotted line). We can thus obtain the same result as <ref type="bibr" target="#b25">[26]</ref> by simply rendering the cushions in nesting order. This has the advantage that it does not require high precision height profile summing, so can be cheaply implemented using standard fixed-point OpenGL. Summarizing, our rendering runs over all syntax constructs, in nesting order, and renders their cushions using polygons textured with the cushion profile, stored as luminance OpenGL textures. A chief advantage of this efficient rendering is that users can interactively zoom and pan tens of files of thousands of lines of code in total (see e.g. <ref type="figure">Figure 6</ref>).  <ref type="figure" target="#fig_2">Figure 3</ref> shows our method for a code fragment of nesting depth 5. The eye perceives the height of the cushions to be proportional with the nesting depth. This result, known as the Cornsweet effect, was previously used to similar ends in visualizing nested height contours <ref type="bibr" target="#b24">[25]</ref>. This works if the nested structures do not completely overlap, as they would in case of a treemap where parents are completely covered by their children.</p><p>In the syntactic view, complete overlaps never happen. We prevent this by extending the right cushion margin with a small border. This is the reason why the cushions in <ref type="figure" target="#fig_2">Figure 3</ref> visibly extend past the text's right border. In the other three directions, cushion margins exactly match the text, a constraint imposed by the text layout itself. The next step in the syntactic view design is to combine the cushion hierarchy with the code text itself. Our goal is to have a tool in which programmers can smoothly and easily navigate between the familiar, trusted text view a standard editor would offer and the syntactic cushion enhancement. We achieve this by blending the text graphics atop of the cushions. Users can control both text (α t ) and cushions (α c ) transparency via two sliders to instantly change the visualization focus from text to syntax.  Finally, we color cushions to show the type of syntax construct they display. Users can browse all C/C++ syntax constructs in a tree view widget and change their color and visibility. For example, in <ref type="figure" target="#fig_2">Figure 3</ref> we used yellow for for loops, green for comments, gray for functions, light blue for if statements, white for declarations and conditions, and red for macros. Visibility is turned off for many constructs, such as the finer-grained declarators and expression terms, to avoid noninformative cluttering. In this way, we focus on the larger extent constructs, such as scopes, which help us grasp the overall program structure. By manually changing the colors, or choosing from predefined color schemes, we can quickly focus on various code aspects and answer queries such as "show all iterations (for, while, do)", "is the code heavily using macros?", "is the code deeply nested?" or "is the code richly commented?". More examples hereof are presented in Section 5.  <ref type="figure" target="#fig_4">(Figure 4d, f=0)</ref>, we can obtain effects ranging from classical 'syntax highlighting' <ref type="figure" target="#fig_4">(Figure 4 left)</ref> to a soft 3D shaded bevel effect <ref type="figure" target="#fig_4">(Figure 4</ref> right, f∈[0..0.5]), or a high-contrast effect <ref type="figure" target="#fig_2">(Figure 3</ref> right, f∈[0..1]). The combination of cushion display and text graphics allows a smooth level-of-detail control. By changing the font height h l , which implicitly changes the cushion sizes, one can change the amount of code visualized on a single screen. In the extreme case when h l =1 pixel, the syntactic view becomes very similar to a line-based source code visualization such as SeeSoft <ref type="bibr" target="#b3">[4]</ref>. <ref type="figure">Figure 6</ref> shows 11 files visualized in this way in the syntactic view. The largest file is a C++ implementation file of 635 lines, the other 10 ones are header files. In total, this screen shows over 3400 code lines. Via the color coding (same as in <ref type="figure" target="#fig_2">Figure 3</ref>), we quickly see several things, as follows. The implementation file (leftmost) contains heavy iterations (yellow), but no deep nesting. The header files are clearly much richer commented (green) than the implementation. All files share the same initial comment block, i.e. the first green block at the top. Every header contains one large class (cyan). This class is almost the first thing declared in the headers, as there is not much else atop the cyan block. Some of the headers contain also inline functions (the white blocks below the cyan class block). There is no heavy use of macros, except in one file, as shown by the immediately salient red spot (A). For comparison purposes, the same code is shown in <ref type="figure">Figure  6</ref> (right), without the shaded syntax cushions. Obviously, it is almost impossible to grasp the code structure from this image.</p><p>Another important issue is navigation in the syntactic view. As described above, code overviews can be generated by zooming out (decreasing the font size), fading out (decreasing the text opacity), and marking certain syntactic elements as invisible. Users can navigate this code overview by scrolling the rendered code columns. Why would navigating this overview be better than scrolling text in a classical editor? First, our experience is that, when looking at some code detail, programmers often have requests such as "I want to go to the start of the third previous function in this file", "go to that deeply nested for loop somewhere below this point", or "go to that code fragment somewhere in the beginning of the file, below that richly commented code". Scrolling the syntax-colored, cushioned code overview serves exactly these requests, as one quickly sees the size, nesting, type, and distribution in file of the source code. However, often one needs details on demand as well. We provide these by displaying, at any time, the detailed code under the mouse position in a separate classical text editor view under the cushion view ( <ref type="figure">Figure 6</ref> left). However, this can disrupt the navigation process, as the user must continuously change focus between the cushion and detailed view. We address this problem by providing two details-on-demand cursor modes: the spotlight cursor ( <ref type="figure">Figure 5</ref> left) and the syntax cursor ( <ref type="figure">Figure 5 right)</ref>. Following the model of Furnas <ref type="bibr" target="#b7">[8]</ref>, both cursors modulate the text and cushion opacity based on the degree of interest (DoI), which is a function f(d) of the geometric distance d from the point of interest located at the mouse cursor (depicted as a cross in <ref type="figure">Figure  5</ref>). Summarizing, a typical use scenario for the syntactic view is as follows. First, the user opens the files of interest, selects a small font height (e.g. one pixel), and chooses a predefined cushion color scheme for the types of syntax structures he wants to see <ref type="figure">(Figure 6</ref> left). If some area of interest pops up, e.g. a particular cushion color, size, and nesting mix, the user zooms on it increasing the font height. Next, the spotlight cursor is activated, and the area is brushed to see the concrete code at hand. Typically, an interesting area of the size of a function or class, of about 100 lines of code, gets now in focus ( <ref type="figure">Figure 5  left)</ref>. Next, the syntax cursor is activated to further zoom on a substructure of interest, such as the for loop in focus in <ref type="figure">Figure  5</ref> right. At this point, the cushion opacity is typically decreased in favor of the text, and the user can further inquire the code using context-specific queries. Queries usually move the point of interest to some other part of the code base, where the process starts again anew.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Symbol view</head><p>The second tool in the VCN system is the symbol view. This is a shaded cushion treemap that displays the symbols a project contains after compilation, i.e. the symbols a linker would see at that stage. In C/C++, these are all global scope objects: function signatures, class and namespace method and data members, templates, enumerations, typedefs, and global variables <ref type="bibr" target="#b4">[5]</ref>. The symbol view is correlated with the syntactic view: One can select a hierarchical code element (file, scope, variable, declaration and so on) in one view and see it depicted in the other too. Note, however, that the symbol view does not show any data inside function bodies. This information is inexistent from a linker perspective. The symbol view treemap shows the C++ scope containment, as extracted by our code analyzer (Section 3). Treemap nodes are colored by their type: green for functions and methods, red for variables and data members, cyan for typedefs, and yellow for function arguments <ref type="figure" target="#fig_6">(Figure 7)</ref>. Less saturated colors indicate symbols in the global scope, more saturated ones symbols in class or namespace scope. We also visualize the (included) files the symbols come from, as a separate subtree, colored orange. The size of terminal (leaf) symbols is equal to their byte count, or sizeof C operator, except for function bodies. Since the symbol view has no information over these, we set their size to be the number of code lines of the function signature (declaration). Non-leaf symbol sizes are the sum of their children's sizes. The above metric allows comparing objects to answer questions like "which are the 'heaviest' variables or types in a scope?" or "which are costly functions from a parameter passing perspective?" The latter is easily answered, since function arguments are children of function declaration nodes. Other questions the symbol view can answer are "where are the inlines or template declarations?", "which file contains just function prototypes?", "which classes have the largest interface (most methods)", or "which declarations are heavily commented?" The last is easily visible, since richly commented declarations have more code lines than their 'bare', code only counterparts. <ref type="figure" target="#fig_6">Figure 7</ref> shows the symbol view for the standard C/C++ headers (e.g. stdio.h, iostream.h, etc) included by a VTK file. The space is partitioned in three: the files (orange, below), the global C namespace (treemap left half), and the C++ std namespace (treemap right half). Further partitioning of the std namespace indicates its various classes, e.g. iostream, vector, list, etc. We see that the headers are dominated by function prototypes (small green and yellow cushions). There are just a few functions having more than one code line (the few larger green cushions). The global C scope has overall functions with the same argument list size (uniform distribution of small yellow cushions in the left treemap half). In contrast, the std namespace has much more variation in function argument size (varying-size yellow cushions, right treemap half). This is so since std template methods often use relatively large iterator types as arguments. There are just a few variables (red) in the headers, which matches expected good programming rules. A relative surprise is the small number of typedef declarations (cyan). We expected these would be more numerous in standard headers. We tested two variations of the symbol view: a classical borderless cushion treemap <ref type="figure" target="#fig_6">(Figure 7</ref> top left) and one with onepixel borders <ref type="figure" target="#fig_6">(Figure 7 top right)</ref>. Remarkably, all our users found the bordered treemap easier to understand, as the nesting is clearer. Moreover, scopes (class, structure, and namespace) appear here explicitly as thin, dark blue borders.</p><p>The symbol view offers several interactive queries. Brushing over a file <ref type="figure" target="#fig_6">(Figure 7</ref> bottom left, red rectangle) shows all symbols defined in that file as highlighted cushions (same <ref type="figure">figure, orange rectangles)</ref>. Brushing a function <ref type="figure" target="#fig_6">(Figure 7</ref> bottom right, red rectangle) shows the file is declared in and the types of its arguments and return (same <ref type="figure">figure, orange rectangles)</ref>. Finally, <ref type="figure" target="#fig_6">Figure 7</ref> (bottom right) illustrates another cushion treemap feature. By tuning the cushion height profile, deeper nested structures become more visible, as compared e.g. to the other three images in <ref type="figure" target="#fig_6">Figure 7</ref>, which better convey the scope (shallow) nesting of code symbols.</p><p>We implemented the symbol view's shaded cushion treemap using the ARB_fragment_program OpenGL extension. Compared to the software rendering used in <ref type="bibr" target="#b25">[26]</ref>, this allows us to zoom and pan the view in real time, as well as quickly change the light direction to better grasp the structure nesting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Evolution view</head><p>The evolution view is the last source code view in the VCN. As its name says, it displays the evolution, or change, in the source code of several files in a project's lifetime. Compared to previous work in this direction (i.e. Evolution Spectrograph <ref type="bibr" target="#b26">[27]</ref>), the evolution view offers more detailed images of files, enabling cross file correlations at line level. This view uses a 2D pixel-filling display based on the file layout, similar to the syntactic view. For a file, the x axis maps the version number and the y axis maps the line number. In the data model from Section 3, the evolution view shows, for a file F j , all its versions V ij stacked along the x axis. A version V ij is drawn as a vertical pixel stripe, every horizontal pixel line representing one or more source code lines in V ij , colored by the line type or the line author, as described below. To separate between versions, we blend a vertical cylinder-like shaded cushion profile over each version colored stripe. In detail, the evolution view uses the pixel-filling code display technique described by Voinea et al. in <ref type="bibr" target="#b22">[23]</ref> for a single file evolution. While similar to the technique proposed by Viégas et al. in <ref type="bibr" target="#b20">[21]</ref>, the former scales better when the number of versions becomes larger the 100. Here, as a new element, we correlate the evolution of several files F j from a project, by displaying the visualizations of all F j in a matrix: Every row displays a file, every column displays an attribute type (line type, author, etc), aligned on version number. <ref type="figure" target="#fig_7">Figure 8</ref> shows an evolution view of three files F 1 , F 2 , and F 3 from the VTK code base. For every file (matrix row), 110 versions V j , j= <ref type="bibr">[1..110]</ref> are shown. The largest versions in this picture have about 650 lines. The left matrix column shows the source code colored by line type: green = comments, black (dark) = function declarations, pink = strings, and blue = C/C++ code, shaded by the nesting level (darker = deeper nested). The right matrix column shows the lines' authors, i.e. the persons who committed the respective lines in the CVS repository (see Section 3). The evolution view allows us to see several facts in the source code. First, we quickly get an overview of the file size evolution in time. Large changes between consecutive versions, denoting major code rewriting, are easy to spot, such as version 50 for F 3 (bottom row) and version 77 for both F 1 and F 2 . Moreover, sharing the same time axis allows quickly correlating whether changes in different files happen at or around the same version. If so, this is a sign an important change occurred which influenced more than just one file. We noticed this sign several (about 10) times in our VTK case study. Second, we get an overview of the impact every developer (author) had on the source code. For example, the red author is obviously the main responsible for F 1 , the orange one for F 2 . The green one has done most work on F 2 , but also starts contributing from around version 50 to F 1 . The black author worked a little bit in all three files. Besides author impact, the right column shows also how persistent was someone's work, i.e., whether it survived to the last (rightmost) version or was deleted by someone else. For example, the top-right image in <ref type="figure" target="#fig_7">Figure 8</ref> shows that much of the black author's work in the middle of the evolution of F j (versions 50 to 77) is actually thrown away by the major rewriting at version 77. Code persistence can be detected by looking after continuous 'wavy' stripes having the same color in the author view, which span several contiguous versions. If the same stripe pattern is visible also in the line type view, the probability we have a persistent code fragment is strengthened even more. By correlating mousebased brushing in the evolution view with detailed code display in the syntactic view, one can examine the actual facts to validate, or infirm, the formed hypotheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CASE STUDY: THE VTK SYSTEM</head><p>We have used VCN's three views in a study to understand VTK <ref type="bibr" target="#b23">[24]</ref>. VTK is a complex C++ library of hundreds of classes in over 2000 files, spanning over 100 versions, developed by tens of programmers over a 10 year period. Our three users, who were experienced with C++ but never used VTK, acquired 100 versions of several VTK files with CVSgrab, analyzed them using VCN, and addressed several questions: (Q1) Are VTK files fine-grained (many small functions) or coarse-grained (few large functions)? (Q2) What is the typical structure of a public VTK class? (Q3) Can you locate and describe a few large structural changes in the VTK evolution? (Q4) What is the typical frequency and usage of macros in VTK? (Q5) Is VTK code richly commented? A fourth user, with over seven years of VTK programming experience, specified the VTK files to analyze and assessed the answers delivered by the former users after about two hours of investigation. Several snapshots reflecting the typical use of VCN during our study have already been shown in the previous sections. Overall, our users had similar observations at the end of the study, as follows. Q1 and Q2 were quickly answered by both the syntactic view (e.g. <ref type="figure">Figure 6a</ref>) and the line metric symbol view (Section 4.2). The studied files had functions of 30..100 lines of code, except some small inlines in the headers. The VTK classes have a rich public interface and relatively fewer protected and private members. Here, the symbol view performed better than the syntactic view, as it shows classes and their members as a simple treemap, compared to the more complex shaped code cushions. The evolution view was used for Q3, the structural changes found are discussed in Section 4.3. Q4 was answered by the syntactic view by using red as macro color <ref type="figure">(Figure 6</ref> left, third file-column from right). Finally, Q5 was answered equally well by the syntactic and line-type colored evolution views.</p><p>A prototype of the VCN including a pre-parsed VTK code base is available at www.win.tue.nl/~lvoinea/VCN.html</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION AND FUTURE WORK</head><p>We have presented VCN, a toolset that offers three views, at different level of detail, on source code structure and evolution: The syntactic view shows code structure, the symbol view shows code from a linker's perspective, and the evolution view shows code changes during a project's lifetime. Both the syntactic and symbol view visualize C++ syntax construct nesting. The syntactic view shows all constructs, including e.g. the function body implementations, and targets the code writing and debugging phase. In contrast, the symbol view shows only constructs a linker would see after compilation, so it offers a coarser view on the software.</p><p>The evolution view and (zoomed out) syntactic view share basically the same 2D pixel-filling, file-based layout. One may wonder whether to merge the two in one view, capable of rendering code at several levels of detail. From fine to coarse, these would be: text (classical editor), syntax cushions over variable-height font text (syntactic view), one pixel per character rendering (as in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b3">[4]</ref>), and several code lines per fixedwidth pixel stripes (the evolution view and <ref type="bibr" target="#b22">[23]</ref>). Conceptually, we see no problem with this. However, having already implemented all the above, we see several technical problems in crafting one single, efficient implementation that would address all above visualizations and their underlying code data models. Another interesting note from our case studies is that code perception varies discontinuously when we continuously vary the text scale (font size). The evolution view targets a perception scale at which individual code structures (loops, declarations, etc) become unimportant, and only the file size and overall code change patterns throughout the file are relevant. The next discrete perceptual scale is the syntactic view, where code structure itself becomes relevant. The next scale is the usual text editor view where one focuses on the meaning of individual words. Hence, users like to have these views separate, next to each other, rather than combined in one.</p><p>Apparently similar, the syntactic view fundamentally differs from the so-called 'syntax highlighting' built in many code editors. The latter only emphasizes individual lexical tokens and, at most, comment blocks. Our syntactic view visualizes the full syntax construct range present in the language, so it generalizes syntax highlighting, which, thus, would better deserve the name 'lexical highlighting'.</p><p>Our tools and techniques are immediately applicable to other programming languages besides C/C++, if appropriate syntax extractors (parsers) are available. Our choice for C/C++ was motivated by their widespread use in industry-size projects. Moreover, C++ code is well known for its complexity, so visualization tools have here their best chance to prove themselves.</p><p>We plan to extend VCN to explore new dimensions of source code, such as visualizing change at file group (directory) and project level, and computing and visualizing structural, instead of line-based, code change. Our goal is to smoothly integrate VCN in the code development and maintenance cycle to validate and promote the use of visualization in software engineering.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Code cushion design by first rendering the code cushion textured with a luminance texture T stretched over the rectangle [0..w,0..h]. Next, we render the rectangles A, B, C, A', B', and C' textured with the 1D texture f, scaled, translated, and rotated as described above, using multiplicative blending.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>parabolic cushions (a) and plateau cushions (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 (</head><label>3</label><figDesc>left) depicts this by showing clear text (α t =1) over a faint syntactic background (α c =0.2), and a faint text (α t =0.3) over a strong syntactic background (α c =0.6).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Cushion and text blending</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Cushion profile choicesBy tuning the range of the profile function f</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>K gives the spotlight width, which is efficiently implemented by using an alpha texture. For the syntax cursor, we simply set f(d) = 1 for the cushion right under the mouse. a) spotlight cursor (left) and syntax cursor (right) Syntactic view of 11 files with cushions (left) and without (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Symbol view. Borderless (top left) and bordered treemap (top right) and visual brushing for queries (bottom row)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Evolution view of three files, one on each row</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Software visualization in the large</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="33" to="43" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.cs.concordia.ca/CONCEPT/" />
		<title level="m">CONCEPT project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Moose: a Collaborative and Extensible Reengineering Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gîrba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lanza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools for Software Maintenance and Reengineering</title>
		<imprint>
			<publisher>Franco Angeli</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">SeeSoft --A Tool for Visualizing Line Oriented Software Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">E</forename><surname>Sumner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="957" to="968" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Annotated C++ Reference Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Stroustrup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">GSEE: A Generic Software Exploration Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Favre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IWPC&apos;01</title>
		<meeting>IWPC&apos;01</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page">233</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Unifying Artifacts and Activities in a Visual Tool for Distributed Software Development Teams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Froehlich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Dourish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICSE &apos;04</title>
		<meeting>ICSE &apos;04</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="387" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generalized Fisheye Views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Furnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHI &apos;96</title>
		<meeting>CHI &apos;96</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="16" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Exploiting the Map Metaphor in a Tool for Software Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICSE &apos;01</title>
		<meeting>ICSE &apos;01</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="265" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">E/R Schema for the Datrix C/C++/Java Exchange Format</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Laguë</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lapierre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Leduc</surname></persName>
		</author>
		<ptr target="swag.uwaterloo.ca/~cppx" />
	</analytic>
	<monogr>
		<title level="m">Proc. WCRE &apos;00</title>
		<meeting>WCRE &apos;00<address><addrLine>See</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="284" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Visualization of Test Information to Assist Fault Localization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Harrold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICSE &apos;02</title>
		<meeting>ICSE &apos;02</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="467" to="477" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Task Oriented View of Software Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Collard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VISSOFT &apos;02</title>
		<meeting>VISSOFT &apos;02</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="32" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
		<title level="m">3D Representations for Software Visualization</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="27" to="36" />
		</imprint>
	</monogr>
	<note>Proc. ACM SoftVis &apos;03</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Gammatella: Visualization of program-Execution data for deployed software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Harrold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SoftVis &apos;03</title>
		<meeting>ACM SoftVis &apos;03</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="173" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">ALMOST: exploring program traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Renieris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Reiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NPIVM&apos;99</title>
		<meeting>NPIVM&apos;99</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="70" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Essay on Software Reuse</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Standish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="494" to="497" />
			<date type="published" when="1984-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">SHriMP Views: an Interactive Environment for Information Visualization and Navigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Best</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rayside</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Litoiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CHI &apos;02</title>
		<meeting>CHI &apos;02</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="520" to="521" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An Open Toolkit for Prototyping Reverse Engineering Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Telea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Maccari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riva</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE VisSym &apos;02, The Eurographics Association</title>
		<meeting>IEEE VisSym &apos;02, The Eurographics Association</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="241" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Programmable Reverse Engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Tilley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. Journal of Software Engineering and Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="501" to="520" />
			<date type="published" when="1994" />
			<publisher>World Scientific</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Rigi: A visual tool for understanding legacy systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Tilley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Software Engineering and Knowledge Engineering</title>
		<imprint>
			<date type="published" when="1994-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Viégas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dave</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studying Cooperation and Conflict between Authors with history flow Visualizations</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="575" to="582" />
		</imprint>
	</monogr>
	<note>ACM Pres</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Visual Assessment Tool for P2P File Sharing Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Voinea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Telea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc InfoVis&apos;04</title>
		<meeting>InfoVis&apos;04</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">CVSscan: Visualization of Code Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Voinea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Telea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc SoftVis &apos;05</title>
		<meeting>SoftVis &apos;05</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page">209</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vtk Web Repository</surname></persName>
		</author>
		<ptr target="http://www.vtk.org/get-software.php#cvs" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Enridged Contour Maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Telea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;01</title>
		<meeting>IEEE Visualization &apos;01</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="69" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Cushion treemaps: visualization of hierarchical information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van De Wetering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. InfoVis &apos;99</title>
		<meeting>InfoVis &apos;99</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="73" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Evolution Spectrographs: Visualizing Punctuated Change in Software Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Spitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Holt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IWPSE &apos;04</title>
		<meeting>IWPSE &apos;04</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
