<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DIG-COLA: Directed Graph Layout through Constrained Energy Minimization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Dwyer</surname></persName>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yehuda</forename><surname>Koren</surname></persName>
							<email>yehuda@research.att.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Software Engineering</orgName>
								<orgName type="institution">Monash University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">AT&amp;T Labs -Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">IEEE Symposium on Information Visualization</orgName>
								<address>
									<addrLine>2005 October 23-25</addrLine>
									<settlement>Minneapolis</settlement>
									<region>MN</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">DIG-COLA: Directed Graph Layout through Constrained Energy Minimization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G</term>
					<term>1</term>
					<term>6 [Numerical analysis]: Optimization-Constrained optimization; H</term>
					<term>5</term>
					<term>0 [Information interfaces and presentation]: General</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We describe a new method for visualization of directed graphs. The method combines constraint programming techniques with a high performance force-directed placement (FDP) algorithm so that the directed nature of the graph is highlighted while useful properties of FDP-such as emphasis of symmetries and preservation of proximity relations-are retained. Our algorithm automatically identifies those parts of the digraph that contain hierarchical information and draws them accordingly. Additionally, those parts that do not contain hierarchy are drawn at the same quality expected from a non-hierarchical, undirected layout algorithm. An interesting application of our algorithm is directional multidimensional scaling (DMDS). DMDS deals with low-dimensional embedding of multivariate data where we want to emphasize the overall flow in the data (e.g. chronological progress) along one of the axes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graph drawing algorithms convert the relational structure of a graph (or network) to a diagram. Many approaches to graph drawing have been developed for different types of graphs and different application domains <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12]</ref>. In this paper, we consider the problem of drawing directed graphs (digraphs).</p><p>Drawing digraphs is a challenging task, requiring algorithms that faithfully represent the relative connectivity of the nodes as well as giving some sense of the overall directionality of the connections (edges). The latter requirement renders algorithms designed for undirected graph drawing inappropriate for digraphs. The dominant digraph-drawing strategy, rooted in the work of Sugiyama et al. <ref type="bibr" target="#b20">[21]</ref> involves assigning x and y coordinates in separate stages with different objectives. Thus, the y-axis represents the directional information, or hierarchy, and the x-axis placement is adjusted for additional aesthetic considerations such as minimizing edge crossings. The special attributes of digraph layouts are demonstrated in <ref type="figure">Fig. 1</ref> with two different layouts of the structure of a small geneexpression network. Each node in the network represents a gene and a directed edge indicates that the source gene affects the expression of the target gene (i.e. by binding the product of one gene to the promoter region of another gene). Undirected (or bidirected) edges (i.e. edges for which no preferred directionality should be shown) are colored blue. Otherwise, edge direction is shown with an arrow. Hierarchical layout places the genes from top to bottom in activation order. The undirected layout could be considered clearer (with fewer edge crossings, more consistent edge length and arguably better representation of cycles, clusters and symmetry) but it gives no indication of the chronological order of interactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hierarchical layout (all directed edges point downwards)</head><p>Undirected layout (red edges point upwards) <ref type="figure">Figure 1</ref>: Two layouts of a gene network using standard layout algorithms from the GRAPHVIZ toolkit <ref type="bibr" target="#b14">[15]</ref>, blue edges are undirected</p><p>In this work we present a new approach to drawing digraphs. Following the common convention, we also dedicate one of the axes to conveying hierarchical information. However, we will not pursue the usual axis separation approach. Separate computation of different axes can be algorithmically appealing as it allows a convenient divide-and-conquer strategy. However, such a separation can make it difficult to control common aesthetic properties in the resulting drawing. Prime examples are uniformity of edge lengths (preventing very long edges) or balancing aspect ratio (equal spread along all axes). Hence, we propose a method for constrained layout of digraphs (DIG-COLA) where all axes of the layout are computed simultaneously as in standard undirected approaches. This process is made feasible by combining two optimization techniques: majorization <ref type="bibr" target="#b13">[14]</ref> and quadratic programming <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PREVIOUS WORK</head><p>The predominant approach to drawing digraphs is based on Sugiyama et al. <ref type="bibr" target="#b20">[21]</ref>, which has evolved into many successful algorithms. <ref type="figure">Fig. 1</ref> gives an example of a graph drawn with such an algorithm. In these Sugiyama-style algorithms, the y-coordinates are computed by dividing the y-axis into a finite number of layers and associating each node with exactly one layer. Edges between nodes on the same layer are not allowed and edges spanning multiple layers are split into chains of dummy nodes. Layer assignment is usually computed with the goal of minimizing edge-length (and hence the number of dummy nodes). The layer assignment methods used are generally incapable of handling cyclic-digraphs and so preprocessing is required to make the graph acyclic by reversing a minimal number of edges. Assigning the x-coordinates is normally done in two stages: first ordering nodes within layers to minimize crossings and then exact placement subject to the computed ordering to optimize aesthetic criteria such as minimizing edge bends. Each of the optimization problems outlined above has been shown to be NP-hard so heuristic approaches have been designed that offer reasonable results in most cases. For more details see <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>Carmel et al. <ref type="bibr" target="#b4">[5]</ref> use an alternative approach to drawing digraphs. The nodes are associated with continuous y-coordinates, in a way that can be applied to any kind of digraph, whether cyclic or acyclic, and which requires no graph modification or preprocessing. These y-coordinates are the unique minimizer of the hierarchy energy, which strongly reflects the directional information of the digraph. The x-coordinates are the minimizer of another energy function that disregards all directional information. The main characteristics of this method are its ability to deal with cyclic graphs, the fact that nodes are not partitioned into horizontal layers and the very fast execution. Unfortunately however, although solutions are defined for graphs with cycles, so-called symmetric nodes within cycles are by definition considered to be at the same hierarchy level and are thus assigned the same y-coordinate. The resulting drawings make such cycles difficult to see; see, e.g., <ref type="figure">Fig. 5(b)</ref>.</p><p>The new approach introduced in this paper is distinguished from those above by the fact that it does not separate the computation of the various axes, but computes all axes simultaneously using constrained energy minimization. In this sense, we are following the force-directed placement approach (FDP) to graph drawing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12]</ref>. These methods define a cost function (or a force model) whose minimization generally produces an acceptable node placement. In particular, we are aware of two other occasions where FDP was suggested for digraph drawing: Sugiyama and Misue <ref type="bibr" target="#b19">[20]</ref> and Kamps et al. <ref type="bibr" target="#b17">[18]</ref>. In both cases the force model was extended by 'angle forces' that encourage all directed edges to point in the same direction. However, this adds additional complexity to the force model and we are under the impression that the inferred energy function is complicated, prone to numerical stiffness and rich in local minima.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PRELIMINARY NOTIONS</head><p>A digraph G = (V, E) comprises a set V = {1, . . . , n} of n nodes, and a set E of directed edges where (i, j) ∈ E is an edge from node i to node j. We further associate with each edge (i, j) a number δ i j that expresses the relative hierarchy of the nodes. Usually, δ i j = 1 for a directed edge i → j, meaning that i precedes j by one unit. Similarly, δ i j = 0 for any undirected edge, meaning that there is no hierarchical precedence between i and j.</p><p>We denote a d-dimensional layout by an n × d matrix X. Thus, node i is located at X i ∈ R d and the axes of the layout are X <ref type="bibr" target="#b0">(1)</ref> , . . . ,</p><formula xml:id="formula_0">X (d) ∈ R n .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The stress function</head><p>The stress function is a traditional measure of drawing quality, based on the heuristic that a nice drawing relates to good isometry: i.e. it calls for placing the nodes so that the resulting pairwise Euclidean distances will approach the corresponding target distances (e.g., graph-theoretic distances). Drawing undirected graphs by minimizing a stress function was made popular by Kamada and Kawai <ref type="bibr" target="#b16">[17]</ref>. Specifically, we have an ideal distance d i j for every pair of nodes i and j, modeled as a spring. Given a d-D layout, where node i is placed at point X i , the energy of the system is</p><formula xml:id="formula_1">stress(X) = ∑ i&lt; j w i j X i − X j − d i j 2 .<label>(1)</label></formula><p>We desire a layout that minimizes this function, thereby best approximating the target distances. Here, the distance d i j is typically the graph-theoretical distance between nodes i and j (i.e. the length of the shortest path connecting i and j). The normalization constant w i j equals d −α i j . Kamada and Kawai <ref type="bibr" target="#b16">[17]</ref> chose α = 2, whereas Cohen <ref type="bibr" target="#b5">[6]</ref> also considered α = 0 and α = 1. Moreover, Cohen suggested setting d i j to the linear-network distance to better convey any clustered structure in the graph. All results reported in this paper are based on graph-theoretical target distances and α = 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Stress majorization</head><p>A recent report by Gansner et al. <ref type="bibr" target="#b13">[14]</ref> suggests computing a graph layout by minimizing the stress function through majorization, following works in the field of multidimensional scaling <ref type="bibr" target="#b3">[4]</ref>. Majorization is a rather global optimization process offering some distinct advantages over localized processes like gradient descentespecially guaranteed monotonic decrease of stress, improved robustness against local minima and shorter running times.</p><p>Majorization minimizes the stress function by iteratively minimizing quadratic forms that approximate and bound it from above. Due to its central role in this work, we provide the essential details of the method. Recall that w i j are the normalization constants in the stress function. We use the n × n matrix L w , defined by</p><formula xml:id="formula_2">L w i, j = −w i j i = j ∑ k =i w ik i = j .<label>(2)</label></formula><p>In addition, given an n × d coordinate matrix Z, we define the n × n matrix L Z by</p><formula xml:id="formula_3">L Z i, j = −w i j • d i j • inv( Z i − Z j ) i = j − ∑ k =i L Z i,k i = j ,<label>(3)</label></formula><p>where inv(x) = 1/x when x = 0 and 0 otherwise. It can be shown (see <ref type="bibr" target="#b13">[14]</ref>) that the stress function is bounded from above by the quadratic form F Z (X) defined as</p><formula xml:id="formula_4">F Z (X) = ∑ i&lt; j w i j d 2 i j + d ∑ a=1 X (a) T L w X (a) − 2 X (a) T L Z Z (a) . (4) Thus, we have stress(X) F Z (X)<label>(5)</label></formula><p>with equality when Z = X. We differentiate by X and find that the global minima of F Z (X) are given by solving</p><formula xml:id="formula_5">L w X (a) = L Z Z (a) , a = 1, . . . , d .<label>(6)</label></formula><p>This leads to the following iterative optimization process. Given some layout X(t), we compute a layout X(t +1) so that stress(X(t + 1)) &lt; stress(X(t)). We use the function F X(t) (X) which satisfies F X(t) (X(t)) = stress(X(t)).</p><p>We take X(t + 1) as the minimizer of F X(t) (X) by solving</p><formula xml:id="formula_6">L w X(t + 1) (a) = L X(t) X(t) (a) , a = 1, . . . , d .<label>(7)</label></formula><p>At this point, we terminate the process if</p><formula xml:id="formula_7">∆stress = stress(X(t)) − stress(X(t + 1)) stress(X(t)) &lt; ε,<label>(8)</label></formula><p>Otherwise, we set t ← t + 1 and continue lowering the stress.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Hierarchy energy</head><p>The hierarchy energy, introduced by Carmel et al. <ref type="bibr" target="#b4">[5]</ref>, strongly reflects the directional information of the digraph. Let G(V, E) be a digraph, and let y = (y 1 , . . . , y n ) T be any vector of coordinates. The hierarchy energy is</p><formula xml:id="formula_8">E H (y) = ∑ (i, j)∈E (y i − y j − δ i j ) 2 .<label>(9)</label></formula><p>The optimal arrangement of a digraph, y , is defined as a minimizer of the hierarchy energy. It will try to place the nodes such that the height difference y i − y j for any adjacent pair (i, j) will be close to (c) two levels <ref type="figure">Figure 2</ref>: Digraphs with various degrees of hierarchy δ i j , the relative hierarchy (i, j). This optimal arrangement is given by solving the linear equations</p><formula xml:id="formula_9">deg i • y i = ∑ j:(i, j)∈E (y j + δ i j ) + ∑ j:( j,i)∈E (y j − δ ji ), i = 1, . . . , n,</formula><p>where</p><formula xml:id="formula_10">deg i = | j : (i, j) ∈ E| + | j : ( j, i) ∈ E|.</formula><p>The optimal arrangement shows the height of each node in the hierarchy as induced by the digraph structure.</p><p>4 THE DIG-COLA ALGORITHM Our algorithm follows a long tradition of drawing undirected graphs by minimizing a stress (or energy) function. However, since we want to show the overall directionality of the graph, we impose constraints on the layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hierarchy as constraints</head><p>Generally, a digraph can be said to induce a hierarchical structure on its nodes based on the precedence relationships defined by its directed edges. Consequently, an appropriate depiction of a digraph allocates one of the axes to showing this hierarchy. Henceforth, the y-axis will serve for this purpose. Thus, if node i precedes node j in the hierarchy, then i will be drawn above j on the y-axis. This usually leads to the majority of directed edges pointing downwards, thereby showing a clear flow from top to bottom.</p><p>Accordingly, our first step is to compute the hierarchy induced by the digraph. This hierarchy is expressed by partitioning the node set into k disjoint sets:</p><formula xml:id="formula_11">V = L 1 ∪ L 2 ∪ • • • ∪ L k ,</formula><p>so that if i &lt; j then the nodes in L i precede those in L j in the hierarchy. Here 1 k n is a value depending on the graph properties. Henceforth, we will call these sets "hierarchical levels" or just "levels". Consequently, the directional properties of the digraph are expressed by imposing hierarchy constraints: for all 1 i &lt; j k place all nodes of L i higher than those of L j in the y-axis.</p><p>Note that the hierarchical levels strongly depend on the digraph structure. For example, consider <ref type="figure">Fig. 2</ref>. In (a), we would like to say that node 1 precedes node 2, which precedes node 3 and so on. Hence, a reasonable partition would be into 5 levels where</p><formula xml:id="formula_12">L 1 = {1}, L 2 = {2}, L 3 = {3}, L 4 = {4}, L 5 = {5}.</formula><p>If we add only a single edge, from node 5 to node 1 we get the graph in (b). For this graph, all nodes are symmetric, and none precedes any other in the hierarchy. Hence, unless we have some external information, it would be safe to assume that no hierarchy exists here and we must assign all nodes to a single level L 1 = {1, 2, 3, 4, 5}. A third case with one additional node is shown in (c). In this case, an agreeable partitioning is L 1 = {6} and L 2 = {1, 2, 3, 4, 5}.</p><p>How do we get such a partitioning? Sometimes we have external information regarding the hierarchical order of the nodes. For example, if the nodes are associated with chronological data, we can partition them by years. If we know that one special node is the "root", then distance from it might dictate the hierarchical levels. Another possibility is to use the layering phase of Sugiyama-based methods <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b20">21]</ref>, for partitioning the nodes into different levels.</p><p>Our default choice is to base the partition on the optimal arrangement y , which was defined in Section 3.3. This allows us to deal with all digraphs, including those that are cyclic or those that also Function PartitionToLevels {G(V = {1, . . . , n}, E)} % Partition the nodes into levels reflecting hierarchy % Constants controlling number of levels: α ← 0.1, β ← 0.01 % lower values encourage more levels Compute the optimal arrangement y ∈ R n % Sort according to y : include undirected edges. An advantageous property of the optimal arrangement is that it will not introduce hierarchy that is not induced by the graph structure 1 ; see <ref type="bibr" target="#b4">[5]</ref>. This is very important, as we don't want to impose any unjustified constraint on the layout. For example, for the digraph in <ref type="figure">Fig. 2(b)</ref>, all nodes will be assigned the same position in y meaning that there are no hierarchical constraints; whereas for the digraph in <ref type="figure">Fig. 2</ref>(c) all nodes except node 6 will be assigned the same y position, yielding a constraint stating that node 6 should be placed above all other nodes.</p><formula xml:id="formula_13">Compute a permutation 1 v 1 , . . . , v n n, so that y v i y v i+1 ε ← Max α 1 n−1 ∑ n−1 i=1 (y v i − y v i+1 ), β k ← 1 for i = 1 to n − 1 do L k ← L k ∪ {v i } if y v i − y v i+1 &gt; ε then % A new level based on a significant gap in y : k ← k + 1 end if end for L k ← L k ∪ {v n } return L 1 , L 2 , . . . , L k</formula><p>In principle, we could sort nodes by their positions in y and place each node in a separate level. However, this might produce an excessive number of levels and therefore excessive constraints. Hence, we compute the hierarchical levels by clustering nodes according to their positions in y so that all nodes within the same cluster are at the same level of hierarchy. This is a one-dimensional clustering problem that we solve using the Single Link approach. We sort y and split it where we observe significant gaps, i.e. if y i is significantly larger than y i+1 , then nodes i and j are assigned to different levels. Detailed pseudocode for this is given in <ref type="figure" target="#fig_1">Fig. 3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Iterative quadratic programming</head><p>We want to find a layout minimizing the stress function subject to the hierarchy constraints. He and Marriott <ref type="bibr" target="#b15">[16]</ref> considered the addition of general linear constraints to FDP based on the localized Kamada-Kawai approach. However, we have found that constraints can be better integrated into the more global majorization optimization process described in Section 3.2. This smooth integration is made possible by using quadratic programming.</p><p>Recall that stress majorization involves minimizing a series of quadratic forms in a way that guarantees a monotonic decrease of stress. To address the directional information, we must also consider the hierarchy constraints, which are certainly linear. Hence, in each iteration we are minimizing a quadratic function subject to linear constraints. It can be shown that the quadratic functions that we minimize are positive definite (see next subsection). Such a constrained optimization is called convex quadratic programming; see, e.g., <ref type="bibr" target="#b7">[8]</ref>. It is well known that the global minimizer of a convex quadratic program can be computed efficiently.</p><p>To summarize, when integrating stress majorization with level constraints, for each iteration we are solving a convex quadratic program, instead of minimizing a quadratic function. While solving convex quadratic programs is more involved than just minimizing quadratic functions, we can still efficiently obtain optimal solutions using a variety of available solvers. Notably, the majorization process, which must obey all constraints, still monotonically decreases the stress function and hence is convergent.</p><p>In more detail, suppose we are given some initial layout X(0) ∈ R n×d . Then in the t-th iteration we compute layout X(t) as the solution of the quadratic program:</p><formula xml:id="formula_14">min X d ∑ a=1 X (a) T L w X (a) − 2 X (a) T L X(t−1) X(t − 1) (a) subject to : ∀ j ∈ L i : X (1) j l i , i = 1, . . . , k − 1 ∀ j ∈ L i+1 : X (1) j + G l i , i = 1, . . . , k − 1<label>(10)</label></formula><p>Note that the target function is the same as in the usual majorization process defined in <ref type="bibr" target="#b3">(4)</ref>. The sets L 1 , . . . , L k are the hierarchical levels that were defined in the previous subsection. The column X (1) ∈ R n , is the axis that represents the hierarchical information (the y-coordinates in our examples). We use k − 1 auxiliary variables l 1 , l 2 , . . . , l k−1 for expressing the constraints succinctly: l i must be below the nodes in L i but above the nodes of L i+1 . The matrices L w and L X(t−1) were defined in <ref type="bibr" target="#b1">(2)</ref> and <ref type="formula" target="#formula_3">3</ref>, respectively. Note that L w and the constraints are fixed during the entire process. The constant G is the minimum gap between consecutive hierarchical levels. In our implementation the default value is G = 0.1. We terminate the process when the stress level stabilizes, i.e. when ∆stress &lt; ε, as defined in Eq. <ref type="bibr" target="#b7">(8)</ref>. A typical value for ε is 0.01.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Visual conventions</head><p>A layout produced by our algorithm can be partitioned into horizontal bands, each band contains all nodes belonging to a single hierarchy level. These bands decompose the X <ref type="bibr" target="#b0">(1)</ref> -axis (usually the y-axis) into the intervals</p><formula xml:id="formula_15">[−∞, l 1 ], [l 1 , l 2 ], [l 2 , l 3 ], . . . , [l k−1 , ∞].</formula><p>The sizes of the bands are non-uniform and depend on the computed layout, which reflects the graph structure. Why do these bands interest us? The reason is that all nodes in the same band are considered to have the same level in the hierarchy. Thus, some layouts are comprised of many narrow bands and hence contain much hierarchy, whereas some other graphs do not contain much hierarchy so their layouts are composed of a very few bands. In satisfying the quadratic program, the algorithm will usually create broader bands for levels containing larger portions of the graph. In order to show this information, we let the user see the underlying bands in the form of a narrow vertical bar that is placed to the left of the graph drawing. This bar contains a sequence of colored blocks corresponding to the bands. The colors gradually change from red to green from top to bottom. To allow users to easily differentiate between consecutive bands, we alternate between saturated and unsaturated colors. Note that we do not use node colors so they can be exploited to display other attributes.</p><p>An example showing bands for a few small graphs is given in <ref type="figure" target="#fig_2">Fig. 4</ref>. In 4(a) we show a directed circle. Such a digraph contains no hierarchy and hence all layout is within a single band. In fact, when drawing such a graph DIG-COLA generates no constraints and so it becomes equivalent to undirected stress minimization algorithms. In 4(b) we show a directed tree. Each level of the tree is placed within a separate band yielding six bands. Another "tree" with the root replaced by a directed cycle is shown in 4(c). The cycle is contained within the top band, while the remaining nodes are partitioned into bands according to their distance from the root cycle. The last example 4(d) is a directed cycle with an extra node pointing to it. Naturally, the whole cycle is contained within one band, while the extra node is shown in a separate, higher band.</p><p>(a) Sugiyama-style layout by DOT <ref type="bibr" target="#b14">[15]</ref> (b) Layout of Carmel et al. <ref type="bibr" target="#b4">[5]</ref> (c) DIG-COLA layout <ref type="figure">Figure 5</ref>: Three drawings of the same directed graph containing a cycle. DIG-COLA puts all vertices of the cycle in the same level of hierarchy, while not squeezing this cycle.</p><p>In conclusion, explicit drawing of bands may provide useful information regarding the hierarchical relations between nodes and the amount of hierarchy contained in the graph.</p><p>We would like to further emphasize the ability of our method to show hierarchy only where it exists, and to produce quality drawings also for non-hierarchical portions of the graph. This is nicely demonstrated in <ref type="figure">Fig. 5</ref>, where we show three drawings of a digraph containing a directed cycle. The Sugiyama-style layout <ref type="figure">(Fig. 5(a)</ref>) partitions the digraph into four hierarchical levels with the nodes involved in the cycle spread across all levels. However, based on the connectivity, there is no reason to put any one of the cycle nodes above any other. Therefore, the result of Carmel et al. <ref type="bibr" target="#b4">[5]</ref> ( <ref type="figure">Fig. 5(b)</ref>), which assigns y-coordinates directly from hierarchy energy, gives all nodes in the cycle the same y-coordinate. While this is true from the hierarchical standpoint, it is clearly undesirable in terms of readability. Hence, DIG-COLA ( <ref type="figure">Fig. 5(c)</ref>) also places the cycle in a single top band, but adjusts this band so the cycle becomes clear.</p><p>Another visual issue concerns indicating the direction of an edge. The usual convention is by drawing an arrowhead at the end of the edge. In some cases this approach won't be efficient. When the drawing contains dense regions the arrowheads become very obscure. Moreover, these arrowheads may occupy precious real estate in the drawing area, thus impairing readability. Luckily, by the nature of the drawing algorithm the vast majority of edges follow a single trend, namely, pointing downwards. Hence, we can draw these edges without arrowheads, only using arrowheads for those edges that point upwards. An even clearer solution is to use edge coloring when colors are available. Therefore, all edges pointing downwards are colored gray/black, whereas those pointing upward are colored red. If the graph also contains undirected edges, which are permitted by our algorithm, they will be colored blue. For example, consider the graph DG 3692 from the AT&amp;T digraph collection <ref type="bibr">[23]</ref>. The layout of the digraph (|V | = 559, |E| = 1035) is quite dense; see <ref type="figure" target="#fig_4">Fig. 6(a)</ref>. Removing arrowheads for all but the five edges that point upwards (and are colored red) improves readability while presenting the same information. In addition, since by definition the optimization task seeks to preserve edge lengths, we can assume with reasonable confidence that the neighbors of any particular node are within a relatively small radius of that node. Hence, in larger graphs, drawing edges is probably less useful than simply drawing the nodes and allowing viewers to assume that proximity implies connectedness. Sugiyama-based algorithms cannot make this guarantee, as shown in <ref type="figure" target="#fig_4">Fig. 6(b)</ref>. We discuss the importance of proximity between connected nodes further in Section 6.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Extensions and additional details</head><p>Quadratic programming solvers Many quadratic solvers are available employing a number of different optimization methods. All of them can serve for solving problem <ref type="bibr" target="#b9">(10)</ref>. They include, MOSEK [22], CPLEX [24], and OOQP <ref type="bibr" target="#b8">[9]</ref>. The results reported in this paper were carried out using the MOSEK package which is based on the general purpose interior-point non-linear optimization method. However, several properties of the DIG-COLA method mean that there are many possibilities for designing a faster solver. Specifically, the quadratic program described above has very simple constraints and the set of constraints does not change between iterations. Also, the solution to one iteration is a good approximation to the solution of the next. Full details of a solver which takes advantage of these attributes are to appear in <ref type="bibr" target="#b0">[1]</ref>.</p><p>Fixing a single node The convexity of the quadratic program is thanks to the fact that the matrix L w is positive semi-definite. This means that every x ∈ R n satisfies x T L w x 0. This inequality can be validated by using the fact that for all i = j, w i j &gt; 0 and noting that x T L w x = ∑ i&lt; j w i j (x i − x j ) 2 0. Consequently, the quadratic form has only global minima. However, many solvers prefer dealing with strict positive definite matrices, ensuring the uniqueness of the global minimum. We can easily transform L w into a positive definite matrix without affecting the majorization process. Observe that problem (10) has a translation degree of freedom, which is the source of multiple minima. Hence, we can fix node 1 at the origin without loss of generality, i.e. we set X 1 = (0, 0, . . . , 0). In the constraints we should replace all occurrences of X 1 with zeros. More-over, we can safely remove the first row and column of L w without affecting the value of the function. It can be shown that the resulting matrix is positive definite, and now we always have a unique global minimum, thus eliminating all degrees of freedom.</p><p>Reducing the quadratic program Note that the constraints involve only the y-axis, X <ref type="bibr" target="#b0">(1)</ref> and that the target function is a sum of terms, each of which includes only a single axis. Thus, we can safely decompose problem <ref type="bibr" target="#b9">(10)</ref> into two problems, one constrained and one unconstrained. The first problem yields X(t + 1) <ref type="bibr" target="#b0">(1)</ref> min</p><formula xml:id="formula_16">X (1) X (1) T L w X (1) − 2 X (1) T L X(t) X(t) (1) subject to : ∀ j ∈ L i : X (1) j l i , i = 1, . . . , k − 1 ∀ j ∈ L i+1 : X (1) j + G l i , i = 1, . . . , k − 1 .<label>(11)</label></formula><p>And the second problem yields the rest axes X <ref type="bibr" target="#b1">(2)</ref> , . . . ,</p><formula xml:id="formula_17">X (d) min X d ∑ a=2 X (a) T L w X (a) − 2 X (a) T L X(t) X(t) (a) .<label>(12)</label></formula><p>Solving problems (11), <ref type="bibr" target="#b11">(12)</ref> will reproduce the solution of the original problem <ref type="bibr" target="#b9">(10)</ref>. However, solving two separate problems is much more efficient. The constrained problem (11) involves much fewer variables than the original (10) and hence is faster to solve. Regarding the unconstrained problem <ref type="bibr" target="#b11">(12)</ref>, its solution takes a relatively negligible time and is given by solving the equation systems</p><formula xml:id="formula_18">L w X (a) = L Z Z (a) , a = 2, . . . , d.</formula><p>When negative is a plus Interestingly, one can set a negative value for G (the minimum gap between levels). This permits slightly breaking the constraints by a quantity limited by |G|. Put differently, a negative G allows a limited "local" deviation of nodes from their designated bands. To make sure that these deviations are local and cannot change the global nature of the layout, we add the constraint:</p><formula xml:id="formula_19">l 1 l 2 • • • l k−1 .</formula><p>We have found that allowing small deviation sometimes gives us the necessary freedom for overcoming local inefficiencies in the layout, without affecting visualization of the overall directionality. This is a unique feature of our method that becomes possible by the clear separation between constraints and cost function.</p><p>We provide here two examples where negative gap was advantageous. Both examples are taken from the Matrix Market collection <ref type="bibr" target="#b2">[3]</ref>. The first graph, Nos4, in <ref type="figure">Fig. 7</ref>, is based on a finite element approximation to a beam structure. Here, setting G = −1 improves layout quality while still being very similar to the layout that was achieved with G = 0. The second graph, Plat362, in <ref type="figure" target="#fig_6">Fig. 8</ref>, is based on a finite-difference model for the shallow wave equations for the Atlantic ocean. Here, we found G = −2 to provide better quality, while overall hierarchy depiction is not significantly affected.</p><p>Min. Levels Gap (G) = 0 Min. Levels Gap (G) = -1 <ref type="figure">Figure 7</ref>: Two similar layouts of the Nos4 graph. In the drawing on the left all edges point downwards, whereas in the version on the right crossings are reduced by allowing some edges to point up (the red edges) without affecting overall directionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTAL STUDY</head><p>In Section 4 we hinted that the DIG-COLA method seems more suitable for larger digraphs than the popular Sugiyama-style layout since there should be less variance in edge length. On the other hand, Sugiyama style layout includes an edge crossing minimization heuristic not found in DIG-COLA. So it would seem that there is some trade off between edge crossing reduction and consistent edge length. To see how these algorithms perform in practice we have completed an experimental study on a large collection of graphs from various application domains, comparing the performance of both the DIG-COLA and Sugiyama methods. In this section we briefly present the results of this study.</p><p>The three datasets used in the following quantitative analysis were compiled from different repositories with the aim of capturing a variety of graph types and application domains. Our first class of graphs is a set of 258 gene-activation networks. The graphs are of varying sizes (up to |V | = 95, |E| = 110), generally quite sparse (|E| ≤ 2|N|) and frequently contain directed cycles. The second set comes from the AT&amp;T Graphs [23]. This latter repository contains over 5000 directed graphs. Of these, we extracted the largest connected component from each graph and filtered out very large and very small graphs (leaving 2464 graphs of 10 ≤ |V | ≤ 200). Using random selection we further reduced this number to a more manageable sample of 100 graphs. We obtained a third set of 34 graphs with 200 ≤ |V | ≤ 1919 from the larger graphs of the AT&amp;T collection and the Matrix Market.</p><p>Our test systems were our own implementation of the DIG-COLA algorithm and the freely available program DOT: an implementation of a Sugiyama-style layout distributed as part of GRAPHVIZ <ref type="bibr" target="#b14">[15]</ref>. Both of these programs were run against each of the graphs in our test data sets and running time, edge lengths and count of crossings were recorded. We ran DIG-COLA with G = 0.1 and G = −1.</p><p>The following results for edge length are based on normalized edge lengths l for each graph layout. That is, l = L/L where L is raw edge lengths for each layout andL is the average value of L. Thus, for each graph layoutl = 1. The results concerning l are summarized graphically in <ref type="figure" target="#fig_8">Fig. 9</ref>. With both layout styles the average sample standard deviationσ was smaller for the sparser geneactivation networks than the AT&amp;T graphs, however for all data sets the DOT layoutσ was at least double that of the DIG-COLA layouts, as shown in <ref type="figure" target="#fig_8">Fig. 9(a)</ref>. From the boxplots in <ref type="figure" target="#fig_8">Fig. 9(b)</ref> we can see that, while the edge-length distribution is narrow and even for DIG-COLA layouts, DOT layouts give a large difference between the upper quartile and maximum edge lengths. That is, DOT layouts tend to have a small number of very long edges. Note that, as per speculation in Section 4, setting a negative value for G gave a further decrease in edge-length variance at the expense of more up-  ward pointing edges. Note also, that edge lengths reported for DOT output are a conservative estimate based on Euclidean distance between start and end node positions (i.e. bends are not considered).</p><p>Regarding edge crossings, the expected trade-off described above was observed for the smaller graphs. That is, DIG-COLA tended to produce more crossings, particularly in the denser AT&amp;T Graphs (see <ref type="figure">Fig. 5</ref>). Again, however, we would argue that in dense graphs, drawing the edges is less important than maintaining relative proximity of nodes. Note that in the sparser gene networks Dig-CoLa with G = 0.1 gave an increase in crossings over DOT, while setting G = −1 gave fewer crossings than DOT. For the set of the larger graphs DOT gave more crossings than DIG-COLA even with positive G.</p><p>Finally, a note on running time of DIG-COLA. All tests were run on a 2GHz PENTIUM M machine. The results are shown in <ref type="figure">Fig. 11</ref>. The preprocessing step includes an O(n|E|) computation of the pairwise distances, but the overall running time is significantly dominated by the iterative majorization process. Time per iteration ( <ref type="figure">Fig. 11(a)</ref>) clearly increases polynomially with number of vertices and must be at least O(n 2 ) per iteration since we are dealing with the dense n × n matrix L w . However, the number of iterations required to satisfy ∆stress &lt; ε = 0.01 ( <ref type="figure">Fig. 11(b)</ref>) is less easy to predict. In our tests graphs with |V | &lt; 100 were arranged in under a second; those with |V | &lt; 600 took less than 10 seconds and a matrix market graph    we have been exploring alternative solvers that take advantage of the properties of the DIG-COLA quadratic program as discussed in Section 4.4. Initial results, as discussed in <ref type="bibr" target="#b0">[1]</ref>, indicate that the running time is greatly improved by employing such a solver -to the point where DIG-COLA is not significantly slower than unconstrained stress minimization and in most cases out-performs DOT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">VARIABLE EDGE LENGTH AND DIRECTIONAL MDS</head><p>The capability for conservation of default edge length that we have demonstrated in DIG-COLA, can be very useful in applications where relative edge weights need to be studied. For example, Bayesian networks are directed acyclic graphs where nodes represent variables and edges represent causality relationships between pairs of variables. The edges can be weighted to indicate the strength of these relationships. In <ref type="figure" target="#fig_10">Fig. 12</ref> we give a small example of a Bayesian network drawn with DIG-COLA such that edge lengths correspond to the inverse of these weights. That is, the shorter the edge between a pair of nodes, the stronger the causality relationship between the corresponding variables. As usual, all edges point down. Based on the results of our quantitative analysis we would argue that such a close correlation between edge weight and length would be very difficult to achieve with Sugiyama layout.</p><p>We have discussed generating hierarchy constraints based on the hierarchical structure of a digraph, but the constraints could just as easily be based on another, domain specific, parameter. An example is Directional MDS to which we turn now.</p><p>The fact that the general stress majorization method described in Section 3 has its roots in the field of multidimensional scaling (MDS) leads us to wonder whether some MDS applications could also utilize the type of hierarchy constraints used in DIG-COLA. In general, graph visualization and MDS are closely related. MDS can be thought of as the visualization of the weighted, complete graph defined by the dissimilarity matrix of a set of high-dimensional data. The DIG-COLA algorithm can be applied to such a complete graph to perform MDS and we can map an additional data dimension to hierarchy constraints. We call this Directional MDS, or DMDS. For example, given high-dimensional time-series data we can produce an MDS plot separating the points corresponding to various time periods into different bands.</p><p>A practical example of DMDS is shown in <ref type="figure" target="#fig_1">Fig. 13</ref>. Here, a multivariate data set of nutritional information for popular breakfast cereals from <ref type="bibr" target="#b21">[25]</ref> has been used to construct a dissimilarity matrix. Eight variables (fiber, starch, sodium etc.) were used. Hence, a traditional MDS algorithm would produce a 2D map of the cereals so that their relative positions correspond to their nutritional similarity. Using DMDS we can clearly show a 9 th variable of the dataset, a dietitian's "health rating" of each cereal. By partitioning the cereals based on this health rating we introduce hierarchy to the layout such that the healthiest cereals appear at the top and the   <ref type="figure" target="#fig_1">Figure 13</ref>: Directional MDS for breakfast cereal nutritional data. Cereals are arranged into bands reflecting their "health rating" and those with similar nutritional values are placed in proximity.</p><p>least healthy are constrained to the bottom. The result achieves two goals. Not only do we show similarities between the cereals based on their nutritional value, but we also allow easy recognition of the relative health rating of the cereals. Note that high-fiber cereals are generally to the top left of the figure and a cluster of starchier riceand wheat-based cereals is visible on the upper right.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>Force-directed placement (FDP) is the most popular approach to drawing undirected graphs. However, despite a few attempts, FDP is not commonly employed for drawing digraphs. We believe that an important contribution of this work is in reducing this distinction between undirected and directed graph drawing methods. For the first time, we show that the same stress function can also serve for hierarchical drawing of a digraph. Moreover, the same majorization optimization method can still be used, without affecting its convergence properties.</p><p>As a consequence, the virtues of FDP that made it very popular for drawing undirected graphs, are now available in a wellbehaved force-directed method for drawing directed graphs. These virtues include an ability to preserve proximity relations (as reflected by conservation of default edge length), clear decomposition to clusters when they naturally exist (especially when using linearnetwork distance <ref type="bibr" target="#b5">[6]</ref>), reliable display of graph symmetries (see <ref type="bibr" target="#b6">[7]</ref>) and a natural capability to handle multidimensional layouts.</p><p>However, FDP does possess a few shortcomings, and our method is not an exception. A notable shortcoming is handling of edge crossings. While shortening edge lengths tends to significantly decrease crossings (especially, as we have shown, for larger graphs), FDP does not consider them directly. Moreover, FDP produces "organic-looking" layouts, while sometimes more restricted, or rigid layouts are preferred, e.g. layouts where vertices are assigned to grid points or to horizontal lines. Therefore, although we have compared DIG-COLA to Sugiyama-style layout we do not argue that this type of method should replace Sugiyama algorithms, except possibly for large or dense graphs or graphs where edge weights must be represented by relative lengths. Countless papers have been written about fine tuning every aspect of Sugiyama lay-out. As a result implementations such as DOT offer very stable and mature solutions to layout of relatively small digraphs. However, we hope that we have demonstrated enough potential for DIG-COLA that it will become a viable alternative for other classes of directed graphs.</p><p>Finally, we would like to mention that DIG-COLA is available in the Neato program in the Graphviz open source package <ref type="bibr" target="#b14">[15]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Pseudocode for the level partitioning algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Hierarchy reflected as bands: each band is a horizontal slice containing nodes at equal level in the hierarchy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(a) DIG-COLA drawing. Only five edges are pointed upwards and are colored red. Layout complexity is lessened by hiding arrow heads.(b) Sugiyama-style drawing (produced with DOT). The occurrence of some very long edges (sometimes spanning most of the width or height of the drawing area) makes it difficult to study connectedness.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Two renderings of the dg 3692 digraph from the AT&amp;T graphs repository.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Min. Levels Gap (G) = 0Min. Levels Gap (G) = -2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Two layouts the Plat362 graph. The two layouts agree on the overall structure of the graph. However, in the upper image all edges point downwards, while in the lower we allow some edges to point up (the red edges) thus achieving a clearer picture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(plat1919) with |V | = 1919 took 7 minutes. On average 98% of the running time is spent inside the Mosek quadratic program solver. Since completing this experiment Boxplots showing distribution of average quartiles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Edge length statistics by layout type and dataset. Lengths normalized such that their average is 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Average crossing counts for the different data sets and layout styles. Iterations before ∆stress &lt; εFigure 11: Results of performance testing on graphs of various sizes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>A small Bayesian network drawn such that edge lengths are inversely proportional to weights (probabilities).</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Unlike the layering methods used in Sugiyama methods, which, combined with cycle removal, would force any pair of connected nodes onto different levels even if they are symmetric in the original graph structure.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank Emden Gansner for integrating DIG-COLA with the Graphviz package.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Stress Majorization with Orthogonal Ordering Constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD&apos;05)</title>
		<meeting>Graph Drawing (GD&apos;05)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Graph Drawing: Algorithms for the Visualization of Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Di</forename><surname>Battista</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Matrix Market: A web resource for test matrix collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Boisvert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pozo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Remington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dongarra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quality of Numerical Software</title>
		<imprint>
			<publisher>Chapman Hall</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="125" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Borg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Groenen</surname></persName>
		</author>
		<title level="m">Modern Multidimensional Scaling: Theory and Applications</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Combining Hierarchy and Energy for Drawing Directed Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="46" to="57" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Drawing Graphs to Convey Proximity: an Incremental Arrangement Method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="197" to="229" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Spring algorithms and symmetry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">240</biblScope>
			<biblScope unit="page" from="379" to="405" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fletcher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Practical Methods of Optimization</title>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Object-Oriented Software for Quadratic Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gertz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="58" to="81" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Wright</surname></persName>
		</author>
		<title level="m">Practical Optimization</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exact and Heuristic Algorithms for 2-Layer Straight line Crossing Minimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mutzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graph Drawing (GD&apos;95)</title>
		<meeting>Graph Drawing (GD&apos;95)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995" />
			<biblScope unit="volume">1027</biblScope>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Drawing Graphs: Methods and Models</title>
		<editor>M. Kaufmann and D. Wagner</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">2025</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Technique for Drawing Directed Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-P</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="214" to="230" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graph Drawing by Stress Majorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int. Symp. Graph Drawing (GD&apos;04)</title>
		<meeting>12th Int. Symp. Graph Drawing (GD&apos;04)</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">3383</biblScope>
			<biblScope unit="page" from="239" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">An Open Graph Visualization system and its Applications to Software Engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
		<ptr target="Also,www.graphviz.org" />
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1203" to="1233" />
		</imprint>
	</monogr>
	<note>Software Practice &amp; Experience</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Constrained Graph Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Constraints</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="289" to="314" />
			<date type="published" when="1998" />
			<publisher>Kluwer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An Algorithm for Drawing General Undirected Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kawai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="7" to="15" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Constraint-Based Spring-Model Algorithm for Graph Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamps</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kleinz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Read</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Symp. Graph Drawing (GD&apos;95)</title>
		<meeting>3rd Int. Symp. Graph Drawing (GD&apos;95)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995" />
			<biblScope unit="volume">1027</biblScope>
			<biblScope unit="page" from="349" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Layout of Bayesian networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Moulder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hope</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Twardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th Australasian Computer Science Conference (ACSC2005)</title>
		<meeting>28th Australasian Computer Science Conference (ACSC2005)</meeting>
		<imprint>
			<publisher>ACS</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="97" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Simple and Unified Method for Drawing Graphs: Magnetic-Spring Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Misue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Int. Symp. Graph Drawing (GD&apos;94)</title>
		<meeting>2nd Int. Symp. Graph Drawing (GD&apos;94)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995" />
			<biblScope unit="volume">894</biblScope>
			<biblScope unit="page" from="364" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Methods for Visual Understanding of Hierarchical Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="109" to="125" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Cereals data lib</title>
		<imprint/>
	</monogr>
	<note>stat.cmu.edu/DASL/Datafiles/Cereals.html</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
