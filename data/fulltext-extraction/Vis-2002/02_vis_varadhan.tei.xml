<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Out-of-Core Rendering of Massive Geometric Environments</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gokul</forename><surname>Varadhan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinesh</forename><surname>Manocha</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Out-of-Core Rendering of Massive Geometric Environments</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling -Curve</term>
					<term>surface</term>
					<term>solid</term>
					<term>and object representations External memory</term>
					<term>large datasets</term>
					<term>walkthroughs</term>
					<term>visibility</term>
					<term>LODs</term>
					<term>prefetching</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present an external memory algorithm for fast display of very large and complex geometric environments. We represent the model using a scene graph and employ different culling techniques for rendering acceleration. Our algorithm uses a parallel approach to render the scene as well as fetch objects from the disk in a synchronous manner. We present a novel prioritized prefetching technique that takes into account LOD-switching and visibility-based events between successive frames. We have applied our algorithm to large gigabyte sized environments that are composed of thousands of objects and tens of millions of polygons. The memory overhead of our algorithm is output sensitive and is typically tens of megabytes. In practice, our approach scales with the model sizes, and its rendering performance is comparable to that of an in-core algorithm.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Recent advances in acquisition and computed-aided design technologies have resulted in large databases of complex geometric models. These datasets are represented using polygons or higher order surfaces. Large gigabyte sized models composed of millions of primitives are commonly used to represent architectural buildings, urban datasets, complex CAD structures or real-world environments. The enormous size of these environments poses a number of challenges in terms of storage overhead, interactive display and manipulation on current graphics systems.</p><p>Given the complexity of these massive models, a number of acceleration techniques that limit the number of primitives rendered at runtime have been proposed. These include visibility culling, model simplification and use of sample-based representations. Many of the resulting algorithms compute additional data structures for faster rendering like levels-of-detail or multi-resolution representations, image or sample-based approximations or a separate occluder database. All these additional information results in a much higher storage complexity for these environments. Any in-core algorithm for interactive display of such datasets needs many gigabytes of main memory.</p><p>Given the size of these environments, many out-of-core algorithms have been proposed that limit the runtime memory footprint. Typically these algorithms load only a portion of the environment into the main memory that is needed for the current frame and use prefetching techniques to load portions of the model that may be rendered during subsequent frames. They have been used for environments that can be partitioned into cells or utilize view-dependent simplification algorithms. However, these approaches are not directly applicable to very large, general and complex environments that are composed of tens of millions of primitives. Main Results: We present an external memory algorithm for fast display of massive geometric environments. We represent the model using a scene graph and precompute bounding boxes, levels-ofdetail (LODs) along with error metrics for each node in the scene graph. At runtime the algorithm traverses the scene graph and performs different culling techniques, including visibility culling {varadhan,dm}@cs.unc.edu http://gamma.cs.unc.edu/ooc/ and simplification culling, to compute the front in the scene graph. Our algorithm uses a combination of parallel fetching and prefetching techniques to load the visible objects or their LODs from secondary storage. The prefetching algorithm takes into account LODswitching and visibility events that change the front between successive frames. Moreover, it employs a prioritized scheme to handle very large datasets and front sizes at interactive rates. The runtime memory overhead of our algorithm is output sensitive and varies as a function of the front size. Some of the key features of our approach include:</p><p>• An out-of-core algorithm for rendering massive environments, whose performance is comparable to that of an in-core algorithm. • A data representation that decouples the representation of the scene graph from the actual primitives corresponding to each node's LOD. • A prioritized prefetching algorithm that takes into account LOD-switching and visibility events and scales with the model size. • A replacement policy that reduces the number of misses. We have applied our algorithm to large environments composed of thousands of objects and tens of millions of polygons. The resulting scene graph sizes vary from hundreds of megabytes to a few gigabytes. Our out-of-core rendering algorithm typically uses a memory footprint of tens of megabytes and can render the models with very little or no loss in the frame rate, as compared to an in-core rendering algorithm. Organization: The rest of the paper is organized in the following manner. We give a brief survey of previous work on interactive display of large datasets and out-of-core rendering algorithms in Section 2. We present our scene graph representation in Section 3 along with different culling algorithms used for faster display. Section 4 describes the out-of-core rendering algorithm, including a prioritized prefetching scheme. We highlight its performance on complex datasets in Section 5. In Section 6, we conclude and outline areas for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>In this section, we give a brief overview of previous work on interactive display of large models and out-of-core algorithms in computer graphics, GIS and computational geometry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Interactive display of large models</head><p>Different approaches have been proposed to accelerate the rendering of large datasets. These are based on model simplification, visibility culling, and using image-based representations. Image-based impostors are typically used to replace geometry distant from the viewpoint and thereby speed up the frame rate <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b28">26,</ref><ref type="bibr" target="#b32">30,</ref><ref type="bibr" target="#b34">32]</ref>. Impostors can be combined with levels-of-detail (LODs) and occlusion culling using a cell based decomposition of the model <ref type="bibr" target="#b0">[1]</ref>.</p><p>The UC Berkeley Architecture Walkthrough system <ref type="bibr" target="#b21">[19]</ref> combined hierarchical algorithms with visibility computations and LODs for architectural models. The BRUSH system <ref type="bibr" target="#b33">[31]</ref> used LODs with hierarchical representation for large mechanical and architectural models. The QSplat system <ref type="bibr" target="#b31">[29]</ref> uses a single data structure that combines view frustum culling, backface culling and LOD selection with point rendering for progressive display of large meshes at interactive rates. The IRIS Performer <ref type="bibr" target="#b30">[28]</ref>, a high performance library, used a hierarchical representation to organize the model into smaller parts, each of which had an associated bounding volume. Erikson et al. <ref type="bibr" target="#b18">[16]</ref> used a hierarchy of levels-of-detail to accelerate the rendering of large geometric datasets. The Gi-gaWalk system used a parallel rendering algorithm that combines occlusion culling with hierarchical levels-of-detail <ref type="bibr" target="#b4">[5]</ref>. Govindraju IEEE Visualization 2002 Oct. 27 -Nov. 1, 2002, Boston, MA, USA 0-7803-7498-3/02/$17.00 © 2002 IEEE et al. <ref type="bibr" target="#b23">[21]</ref> have presented an improved occlusion algorithm that uses three graphics pipelines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Out-of-Core Algorithms</head><p>There has been lot of work on out-of-core or external-memory algorithms in computational geometry and related areas <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b38">36]</ref>. Nodine et al. <ref type="bibr" target="#b29">[27]</ref> presented an algorithm for efficient use of disk blocks to perform graph searching on graphs that are too large to fit in internal memory.</p><p>Funkhouser et al. <ref type="bibr" target="#b22">[20,</ref><ref type="bibr" target="#b20">18]</ref> described techniques for managing large amounts of data in the context of an adaptive display algorithm used to maintain interactive frame rates. They employed a real-time memory management algorithm for swapping objects in and out of memory, based on a spatial subdivision of architectural models, as the observer moves through the model. Aliaga et al.</p><p>[1] presented a system for interactive rendering of complex models that can be easily partitioned into virtual cells. It included prefetching and data management schemes for models that are larger than available memory. However, no good algorithms are known for automatic decomposition of a large model into cells. Furthermore, the use of image-based representations can lead to popping and disocclusion artifacts. <ref type="bibr" target="#b25">[23,</ref><ref type="bibr" target="#b26">24,</ref><ref type="bibr" target="#b35">33,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b9">10]</ref> have presented out-of-core algorithms for simplification of large models. Their focus is on offline simplification of very large scanned or related datasets. We could use these simplification algorithms to precompute levels-of-detail (LODs) &amp; hierarchical levels-of-detail (HLODs) of objects in our model.</p><p>El-Sana and Chiang <ref type="bibr" target="#b14">[13]</ref> presented an external-memory algorithm to support view-dependent simplification of datasets that do not fit in main memory. They have demonstrated its performance on models consisting of a few hundreds of thousand triangles that take tens of megabytes of storage. Although view-dependent simplification algorithms <ref type="bibr" target="#b24">[22,</ref><ref type="bibr" target="#b27">25,</ref><ref type="bibr" target="#b39">37,</ref><ref type="bibr" target="#b15">14]</ref> are elegant and work well for spatially large objects, they may impose significant overhead during visualization especially for scenes composed of tens of thousands of objects. Instead of choosing an LOD per visible object, view-dependent algorithms may query every active vertex or edge of every visible object. In contrast with these approaches, our algorithm uses static LODs because of simplicity and low runtime overhead, and accepts their limitations in terms of potential "popping" artifacts that can occur as we switch between different LODs at runtime.</p><p>A number of methods for out-of-core visualization including isosurface extraction, and rendering of large unstructured grids have been proposed <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">17]</ref>. <ref type="bibr" target="#b37">[35,</ref><ref type="bibr" target="#b13">12]</ref> presented application-controlled segmentation &amp; paging methods for out-of-core visualization of computational fluid dynamics (CFD) data.</p><p>[34] presented a number of techniques such as indexing, caching, and prefetching to improve the performance of walkthrough of a very large virtual environment. Their system supports view frustum culling, but does not support levels-of-detail. <ref type="bibr" target="#b2">[3]</ref> presented a system for interactive visualization of aircraft and power generation engines. Their system supports LOD and dynamic loading.</p><p>[11] present a system for interactive out-of-core rendering of large models. <ref type="bibr" target="#b8">[9]</ref> proposed multi-resolution caching and prefetching mechanisms to support virtual walkthrough applications in the distributed environment. Our rendering algorithm in addition to supporting multi-resolution object models also employs view frustum culling and simplification culling <ref type="bibr" target="#b18">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SCENE REPRESENTATION</head><p>In this section, we describe our scene representation. Our rendering algorithm uses a scene graph based representation along with static, precomputed LODs. We also discuss different culling techniques used to limit the number of primitives that are rendered at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Scene Representation</head><p>Given a large environment composed of a number of objects, we represent it using a scene graph. We assume that the scene graph has been constructed using space partitioning or clustering-based approaches. The leaf nodes in the scene graph represent original <ref type="figure">Figure 1</ref>: Scene Graph Representation: A, B, C are nodes of the scene graph. Each node is associated with an HLOD which is a set of approximations for the node as well as its descendants. We use the term, object-rep to refer to each individual approximation (e.g A[0], B <ref type="bibr" target="#b1">[2]</ref>, C <ref type="bibr" target="#b0">[1]</ref>). objects in the scene. The algorithm also precomputes static levelsof-detail (LODs) for each object and associates them with the leaf nodes. In addition to the LODs, the algorithm precomputes drastic approximations of portions of the environments and associates them with the intermediate nodes in the scene graph. In this paper, we restrict ourselves to hierarchical levels-of-detail (HLODs) <ref type="bibr" target="#b18">[16]</ref>, though our out-of-core algorithm is also directly applicable to image-based impostors <ref type="bibr" target="#b28">[26,</ref><ref type="bibr" target="#b0">1]</ref>. An HLOD of a node in the scene graph is an approximation of that node as well as its descendants. In the rest of the paper, we use the term object-rep, to refer to the set of approximations associated with each node in the scene graph, including different LODs, HLODs or impostors. Different objectreps associated with a node are represented as a linear array from the coarsest object-rep to the finest object-rep, including the original object-rep. They are primarily used for rendering acceleration. In addition to the object-reps, the algorithm also stores additional data structures like bounding boxes that are used by visibility culling algorithms. Moreover, it associates error metrics with each object-rep that are precomputed by the simplification algorithm. Notation: We use the following notation in the rest of the paper. Let </p><formula xml:id="formula_0">PAR(N [i]) = N [i − 1] i &gt; 0 P [N um(P ) − 1] i = 0 where P = PAR(N ) CHD(N [i]) = {N [i + 1]} i &lt; (N um(N ) − 1) ∪ {C[0] | C ∈ CHD(N )} i = (N um(N ) − 1) ASC(N [i], k) = PAR(N [i]) k = 1 ASC(PAR(N [i]), k − 1) k &gt; 1 DSC(N [i], k) = CHD(N [i]) k = 1 ∪{DSC(C, k − 1)| C ∈ CHD(N )} k &gt; 1</formula><p>This is illustrated in <ref type="figure">Fig 1.</ref> A is a node of the scene graph. We have PAR(A <ref type="bibr" target="#b0">[1]</ref> </p><formula xml:id="formula_1">) = A[0], CHD(A[0]) = {A[1]}, PAR(B[0]) = A[2], CHD(A[2]) = {B[0], C[0]}, ASC(B[1], 2) = A[2], DSC(A[2], 2) = {B[1], C[1]}. Each object-rep A[i] is</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Scene Graph Traversal</head><p>Given a scene graph representation, the rendering algorithm traverses the scene graph from the root node during each frame. When it reaches a node N , it performs any subset of culling techniques and based on their outcome traverses the scene graph recursively. These include: •  <ref type="bibr" target="#b18">[16]</ref>.</p><p>• Occlusion Culling: Check whether the node is occluded by other objects. Our current implementation does not perform occlusion culling, though the out-of-core rendering algorithm can be easily extended to handle it. At the end of the traversal, the algorithm computes a list of objectreps that need to be rendered during the current frame. We refer to the resulting set of object-reps as the front. The front represents the working set of object-reps for the current frame and corresponds to a subset of a cut of the scene graph (as shown in <ref type="figure" target="#fig_2">Fig 2)</ref>. Some nodes in a cut of the scene graph may not be visible from the current viewpoint, and are therefore, not part of the front. The front is not merely a collection of nodes in the scene graph, but includes only one of the object-reps associated with each node. The index of the object-rep selected for each node represents an additional LOD dimension. As the viewpoint moves, the front changes in many ways. These include different events:</p><p>1. LOD Switching Events:</p><p>• An object-rep that was in the front may be replaced by a coarser or finer object-rep associated with the same node.</p><p>• An object-rep that was in the front may get replaced either by an object-rep belonging to an ascendant node or by a set of object-reps from the descendant nodes in the scene graph. Formally, an object-rep O can get replaced either by ASC(O, k) or DSC(O, k) for some k. These events occur when the user zooms in or out of the scene.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Visibility Events:</head><p>• An object-rep that was in the front may disappear because the corresponding node is no longer visible. • An object-rep that wasn't present earlier may appear because the corresponding node has become visible. These events occur when the user pans across the scene or because of occlusion events. Our algorithm takes advantage of the fact that the relative changes in the front between successive frames are typically small, and therefore utilizes spatial and temporal coherence in designing an out-ofcore rendering algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Scene Graph Skeleton &amp; Out-of-Core Representation</head><p>In order to traverse the scene graph and compute the front, our rendering algorithm only needs the scene graph skeleton.  This division of the model into in-core and out-of-core representations ensures that the main memory overhead is almost equal to the size of the skeleton. The rendering algorithm accepts a memory footprint size as input and we ensure that its memory usage cannot exceed this limit. Moreover, we assume that the given memory footprint is large enough to hold the skeleton.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">OUT-OF-CORE RENDERING ALGO-RITHM</head><p>In this section, we present our out-of-core rendering algorithm. It uses two synchronous processes, one for rendering and the second one manages the disk I/O. Each of them use the scene representation described in Section 3. We also present a novel prefetching algorithm that takes into account changes in the front between successive frames and uses a prioritized scheme to handle very large datasets. We use terms like "hit" or "miss" to refer to the fact that a particular object-rep is present in the main memory or not, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Parallel Rendering &amp; I/O Management</head><p>Our algorithm uses two main processes: one for scene graph traversal and rendering (PR), and the second one for I/O management and prefetching (PI). Both of them run in parallel and operate synchronously (see <ref type="figure" target="#fig_4">Fig 3)</ref>. PR traverses the scene graph and computes the front based on the current viewpoint and scene graph skeleton. During this time, PI continues to perform prefetching for the the previous frame (Stage I). Once PR finishes the front computation, it sends a fetch command to PI. On receiving a fetch command, PI gets synchronized with PR and fetches object-reps for the current frame. The fetch command has information about the set of object-reps in the current front. PI divides this set into two lists:</p><p>• LI: It is the list of all object-reps that are currently in main memory. • LO: It is the list of all object-reps that are not in the main memory and need to be loaded from the disk. PI starts loading the object-reps belonging to LO (Stage II in <ref type="figure" target="#fig_4">Fig  3)</ref>. Different object-reps that constitute the front can be rendered in any order. As a result, PR starts rendering the object-reps that belong to LI and not wait till all the object-reps in LO are loaded in the main memory. The rendering and the loading of out-of-core object-reps proceeds in parallel. If PR has rendered all the objectreps belonging to LI, it has to wait till new object-reps are loaded. Whenever PI loads an object-rep, it removes it from LO and appends it to LI. Once PI has fetched all the object-reps belonging to LO, it spends the remainder of the frame time prefetching other object-reps that may be needed for subsequent frames (Stage III).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Prefetching</head><p>In an interactive application, there is considerable coherence between successive frames. Our algorithm uses prefetching techniques to improve the hit rate.  <ref type="figure" target="#fig_4">Fig. 3</ref>. The goal of prefetching is to load most of the object-reps that the algorithm needs to render during subsequent frames. The prefetching is performed in parallel by PI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">LOD Switching Events</head><p>As the user traverses through the scene, it typically moves closer to some portions of the scene and away from the other. Objects that are closer to the user need to be rendered at a finer resolution. The object-reps (O) representing these objects are replaced by their descendants (DSC(O, k) for some k) in the scene graph. Similarly, objects that move farther from the viewer get replaced by their ascendants (ASC(O, k) for some k). Moreover, the object-rep may switch between different LODs or HLODs of the same node. We avoid misses due to LOD switching events by prefetching multiple levels of ascendants and descendants of object-reps in the front.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Visibility Events</head><p>When the user pans across the scene, objects that were not visible earlier may become visible. In case of view frustum culling, typically these objects are outside the view frustum but close to the edge of the view frustum. We avoid such misses by letting PI use an expanded view frustum for prefetching (FI) that bounds the view frustum used for rendering (FR) (see <ref type="figure">Fig 4)</ref>. The size of FI can be adapted based on the rate at which the user pans across the scene.</p><p>We also prioritize object-reps outside of FR that lie within FI depending on the angle they make with the line-of-sight. In particular, we assign a higher priority to object-reps that make a smaller angle. Let θ0, θ1 be the angles associated with the two view frustums. For an object-rep O that makes an angle θ with line of sight, we associate an angle-priority function AngP r(O) as follows:</p><formula xml:id="formula_2">AngP r(O) = 1 1 + θ ∼ θ0 θ1</formula><p>where θ ∼ θ0 = θ − θ0 θ &gt; θ0 0 otherwise</p><p>We prioritize prefetching of object-reps based on the AngP r() function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Priority-based prefetching</head><p>One of our goals is to handle very large datasets at interactive rates. For large models, the number of object-reps in a front can be very large. For example, there are more than 6, 500 object-reps in the front corresponding to the Double Eagle model in one of the sample paths. As a result, we want to use a prefetching strategy that can handle large front sizes at interactive rates. Typically, the user's motion governs the rate at which an object-rep switches between different LODs between successive frames. To improve the hit rate, we prefetch multiple levels of ascendants and descendants of the node. Given a very large environment, whose front may consist of thousands of nodes and object-reps, it may not be possible to prefetch multiple levels of ascendants and descendants of all the object-reps in the front in the given frame time. As a result, we prioritize different object-reps in the front and the prefetching algorithm selects them based on their priority. An object-rep that is more likely to switch between the LODs is assigned a higher priority. The key issue is to predict which object-reps in the front are going to switch between different LODs. The switching takes place when the projected screen-space error for an object-rep exceeds the user-specified error tolerance ( ). Initially, we assign a priority to an object-rep O depending on how close its projected screen-space error, O , is to the error tolerance . We compute the absolute difference, | O -|, and the priority value varies as an inverse function of this difference. Moreover, we use a simple bucketing strategy, similar to bucket sort, to classify different object-reps. The classification of an object-rep O, is based on computing its projected screen-space error O and placing it in the bin whose interval contains O . We use a limited number of priority levels or bins, each representing a range of projected screen-space errors as shown in <ref type="figure" target="#fig_5">Fig 5.</ref> Let us assume that δ &gt; . We divide the range [0, δ) into B intervals and assign each of the intervals to one of the B bins. Bins whose intervals are closer to have a higher priority. For example, in <ref type="figure" target="#fig_5">Fig 5,</ref> bin Bi is associated with the interval [i, i + 1). The bin B10, whose interval contains has the highest priority and the bins B9, B11, B8, B12, B7, B6, B5,. . . , B0 represent an ordering based on decreasing priorities. Unlike bucket sort, we do not sort the items within a bin. Each bin is associated with a queue. When an item is placed in a bin, it is appended to the end of the queue associated with that bin.</p><p>During each frame, we start by classifying each object-rep in the front. After the classification step, we start processing items from the bins. We select an item from the highest priority bin whose queue is non-empty. When we select an object-rep O from a bin, our goal is to ensure that when O switches between the LODs, the new LOD is in the memory. The PI process loads PAR(O) and CHD(O) and classifies them into appropriate bins. The algorithm prefetches multiple levels of ascendants and descendants. We continue to process different object-reps in this manner until the end of the frame. The pseudo-code corresponding to the classification (CLASSIFY) and prefetching (PREFETCH) steps is given below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CLASSIFY(O)</head><p>1 for each object-rep X ∈ P AR(O) ∪ CHD(O) do 4.</p><p>Load X into main memory 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CLASSIFY (X)</head><p>Ultimately we combine the priority values based on projected screen-space error metric along with the angle-priority function to obtain an integrated priority function, P riority(O), for an objectrep O:</p><formula xml:id="formula_3">P riority(O) = O * AngP r(O) O &lt; O /AngP r(O)</formula><p>O &gt; We perform the classification procedure mentioned above based on the integrated priority function. Ascendants of an object-rep in the front can have projected screen-space errors greater than and so we use δ &gt; . By varying δ, we can vary the number of ascendants that are prefetched.</p><p>PI flushes the bins and classifies the front only when the viewpoint changes. Another issue is that object-rep sizes can vary a lot for e.g from 50 B to 20 MB in our models. Therefore, we cannot allow loading of an object-rep to be a non-preemptible operation as that can stall PR. As a result, PI loads an object-rep in terms of blocks, and checks with PR after it has loaded each block.  <ref type="table" target="#tab_4">Table 1</ref>). Our out-of-core system can render this model on a machine with 128 MB memory using a memory footprint of 15 MB and the resulting frame rate is comparable to an in-core rendering algorithm that needs over 0.6 GB of main memory. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Replacement Policy</head><p>The prefetching and fetching algorithms load object-reps into the main memory from the disk. Given an upper bound on the size of main memory, any out-of-core rendering algorithm needs a mechanism to remove or replace some of the object-reps from the main memory. We use a variation of the standard LRU (least recently used) policy. It ensures that we do not remove the object-reps that belong to the front or object-reps that were recently fetched from the disk.</p><p>PI maintains the set of in-core object-reps in the memory in a doubly linked list, InMemoryList. It performs a number of operations on this list. These include:</p><p>1. At the beginning of Stage II (see <ref type="figure" target="#fig_4">Fig 3)</ref>, PI stores a pointer StartTail to the tail of InMemoryList. 2. In course of subsequent fetching and prefetching, when PI accesses an object-rep, it performs the following updates:</p><p>• If the object-rep is already in memory, it moves it from its existing position in InMemoryList to the new position immediately after StartTail. • If the object-rep is not already in memory, it loads it and inserts it after StartTail. 3. When PI needs to select replacement candidates, it chooses the object-rep from the InMemoryList, starting at the head of the list. However, if the particular object-rep is currently being rendered, it skips it and moves to the next object-rep in the linked list. In course of fetching and prefetching operations, each time PI accesses an object-rep, it positions it to lie immediately after Start-Tail. As a result, the object-reps that are accessed lie beyond Start-Tail in an order which is reverse of the order in which they were accessed.</p><p>Let OF be the set of object-reps that correspond to the front and OP be the set of object-reps that have been prefetched. PI accesses the object-reps in OF during Stage II before it accesses the object-reps in OP during Stage III of the current frame or Stage I of next frame. Consequently, the object-reps in OF lie beyond the object-reps in OP (see <ref type="figure" target="#fig_7">Fig 7)</ref>. Moreover, it accesses the objectreps in OP in a decreasing order of priority. As a result, all the  <ref type="table" target="#tab_4">Table 1</ref>). Our out-of-core system renders this model on a machine with 128 MB memory using a memory footprint of 35 MB and the frame rate is comparable to an in-core rendering system which requires over 3 GB of main memory.</p><p>object-reps in OP are located beyond StartTail and are arranged in an increasing order of priority (see <ref type="figure" target="#fig_7">Fig 7)</ref>. This ensures that when replacement object-reps are chosen from the head of InMemoryList, the object-reps "closest" to the front are the least likely candidates for replacement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION AND RESULTS</head><p>We have implemented the out-of-core rendering algorithm described above and used it to render complex environments. Our current implementation uses view frustum culling and simplification culling on a scene graph that consists of LODs and HLODs. It uses two CPUs for each of the two processes, PR &amp; PI and a single graphics pipeline. Our system uses C++, GLUT, and OpenGL. We performed tests on two machines: an SGI workstation with two 195 MHZ R10000 MIPS processors, MXI graphics board, 128 MB of main memory (Machine 1) and an SGI Onyx with multiple 500 MHZ R14000 MIPS processors, Infinite Reality3 graphics pipelines and 16 GB of main memory (Machine 2). We performed tests on Machine 1 in order to show that our out-of-core algorithms require a limited memory footprint and on Machine 2 to compare the performance of our out-of-core rendering algorithm with that of an in-core rendering algorithm.  We have tested our algorithm on two large environments, a Powerplant model (PP) ( <ref type="figure" target="#fig_6">Fig 6)</ref> and Double Eagle Tanker model (DE) <ref type="figure" target="#fig_8">(Fig 8)</ref>. The size of PP and DE models is about 600 MB and 3 GB, respectively. The scene graphs and the LODs and HLODs associated with each node were computed using the algorithm presented in <ref type="bibr" target="#b18">[16]</ref>. <ref type="table" target="#tab_4">Table 1</ref> tabulates the polygon count, number of objects, number of scene graph nodes, scene graph height, size of the scene graph skeleton, and size of scene graph data for the two models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Env Poly Objects Nodes Height Skeleton Data</head><p>We generated different paths in these environments to test the performance of our algorithms. The user's motion in these paths had a lot of pan, and sudden motion. Moreover, the front size in these paths varies considerably. Typically, the front size is large when the viewer is inside an environment. We recorded multiple paths, with the same number of frames in each path, and the image quality is governed by the user-specified error tolerance. As a result, it is sufficient to measure the frame rate in order to test the performance of our algorithm for a given memory footprint. In the rest of this section, we compare the performance of three different algorithms and systems:</p><p>• Incore: It is the in-core system that loads the entire scene graph and all the object-reps in the main memory.   <ref type="figure">Figure 9</ref> shows the relative performance of different systems for PP &amp; DE models, respectively. We imposed a memory footprint of 15 MB and 35 MB for PP and DE respectively. The memory footprint holds the object-reps loaded by the PI and does not account for the size of the scene graph skeleton, which is constant for each model. <ref type="figure" target="#fig_10">Fig 10</ref> shows the front size in each frame for the two models. Front size is calculated by summing up the sizes of the object-reps in the front. We observe that the maximum front size is about 7 MB &amp; 8 MB for PP &amp; DE respectively. <ref type="figure">Fig 11(b)</ref> shows the front size for DE for a sample path that uses a lower error tolerance and a much higher image fidelity. In this case, the maximum front size is about 35 MB. The maximum number of object-reps in the front is about 300 for the PP &amp; varies in the range 2300-6500 for the DE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Parallel Rendering &amp; I/O Management</head><p>The overall performance of the OOCNoPre system matches with that of the OOCPre system at many places in the sample paths. However, the frame time plot of OOCNoPre system has several spikes, which typically correspond to relatively large changes in the viewpoint. Such motions are not uncommon in a walkthrough experience, when a user is exploring new parts of the environment. It can lead to drastic changes in the front. The object-reps in the new front may not have been in the main memory and this can result in more misses, which increases the fetching time. The overall rendering or frame time doesn't get affected as long as the time to fetch object-reps in LO is less than the time to render object-reps in LI. This is the main benefit of performing rendering &amp; I/O management in parallel. However, a large number of misses can cause the fetching time to dominate the rendering time and this results in spikes in the frame time plot. <ref type="figure" target="#fig_10">Fig 10 shows</ref> the amount of data that is fetched from a disk in each frame and compares it with the front size for those paths. The OOCNoPre system fetches a large amount of data from the disk and this results in the slowdown or a break in the system's performance. The memory usage is equal to the amount of data stored in main memory at any given time. The memory usage of OOCNoPre does not exceed the memory footprint limit. <ref type="figure" target="#fig_9">Fig 9 compares</ref> the performance of OOCPre with OOCNoPre and Incore for the two models. They highlight the benefits of prioritized prefetching. We see that the frame time plot for OOCPre does not have any spikes. Moreover, the OOCPre system does not need to fetch a large amount of data from the disk <ref type="figure" target="#fig_10">(Fig 10)</ref> and its frame does not have major variations due to the I/O bottleneck. Moreover, the performance of OOCPre matches that of the in-core system, Incore. Also the memory usage of OOCPre does not exceed the memory footprint limit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Prioritized Prefetching</head><p>We tested the performance of our prefetching scheme for the Double Eagle model with a sample path and a smaller user-specified tolerance. <ref type="figure">Fig 11(b)</ref> shows the front size for this scenario and the fetch size for the OOCPre system. We notice that the maximum front size can be 35 MB and the maximum number of object-reps in the front can be 6500. For a 100 MB footprint, the resulting system fetches only a small amount of data from disk.</p><p>Inspite of large changes in the viewpoint, our out-of-core system, OOCPre resulted in very few misses on the sample paths in these complex environments <ref type="figure">(Fig 11(b)</ref>). Although the front can have up to 6500 object-reps, our priority-based prefetching scheme was able to accurately predict the object-reps that were likely to be used during subsequent frames. As a result, our system is able to handle very large front sizes. <ref type="figure">Fig 11 highlights</ref> the size of data that is fetched from the disk for OOCPre as we vary the memory footprint. Notice that as we increase the memory footprint, the amount of data that is fetched from the disk during Stage II of the I/O process, decreases substantially for OOCPre. As a result, there are very little or no spikes in the frame rate for the OOCPre system, as compared to the OOCNoPre system. Moreover, the OOCPre system matches the peak performance of the Incore system. We achieve this performance with a relatively small memory footprint, typically of the order of few tens of megabytes. For example, for the Double Eagle model, we achieve peak performance using a 35 MB footprint <ref type="figure">(Fig 9(b)</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Size of Memory footprint</head><p>The prioritized prefetching is very useful even when the system For the Double eagle model the OOCNoPre system needed to fetch about 2 MB from disk whereas the OOCPre system had to fetch less than 0.1 MB for the same frame. is using a small memory footprint, say 8MB <ref type="figure" target="#fig_9">(Fig 11(a)</ref>). However, in such a case the frame time plot for OOCPre has spikes. These spikes correspond to the case when front size is close to 8 MB. Since the memory footprint was 8 MB, this implies that PI can only prefetch relatively small amount of data. In such cases, the performance of OOCPre is only slightly better than that of OOCNoPre. However when the front size is smaller than 8 MB, PI is able to prefetch sufficient number of object-reps and thereby result in few misses. This benchmark also demonstrates the effectiveness of our replacement policy which ensures that object-reps in the front and those which have been prefetched are not removed from the main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FUTURE WORK</head><p>In this paper, we have presented an algorithm for out-of-core rendering of massive geometric environments. We represent the model using a scene graph and precompute levels-of-detail for different nodes. We use a parallel approach to render the scene as well as fetch objects from the disk in a synchronous manner. We have presented a novel prefetching technique that takes into account the LOD-based and visibility-based events, which can cause changes in the front between successive frames. The resulting algorithm has been applied to two complex environments whose size varies from few hundreds MBs to a few GBs. It scales with the model sizes and the memory requirements of the algorithm are output sensitive, typically few tens of MBs for our sample paths. There are many avenues for future work. We would like to combine our out-of-core scheme with occlusion culling <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">21]</ref>, in addition to view frustum culling and simplification culling. Our current implementation uses pre-computed static LODs and it may be worthwhile to explore hybrid schemes that combine static LODs for small objects in the scene with view-dependent simplification of large objects. It may be useful to incorporate external-memory techniques such as blocking for efficient I/O. We would like to investigate motion prediction schemes to further improve the performance of our prefetching algorithm. We would also like to develop target-frame rate schemes that use a bounded memory footprint.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>N um(N ) be the number of object-reps associated with a node N . Let PAR(N ) be its parent node and CHD(N ) represent its children nodes. Moreover, we use N [i] to represent the ith object-rep of node N . For an object-rep O = N [i] and an integer k &gt; 0, we can define its parent PAR(O), children CHD(O), k-th level ascendant ASC(O, k) and descendants DSC(O, k) in the scene graph as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>associated with an object-space error metric, E A[i] , computed by the simplification algorithm. For example, A[0], A[2] are the coarsest and finest objectreps of node A, respectively. Moreover, E A[0] &gt; E A[1] &gt; E A[2] . To obtain a finer representation, as compared to A[2], we descend to A's children, B and C. Based on our representation, {B[j], C[k]} j, k ∈ {0, 1, 2} is a finer representation than A[i] i ∈ {0, 1, 2}. At runtime, the object-space error metric E A[i] of node A[i] is projected to the view plane and the screen-space error bound A[i] is computed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Front: The exterior black triangle represents the scene graph. Front (in red) is a subset of the cut of the scene graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>The skeleton includes the nodes and connectivity information like parent-child relationships, as well as additional data structures including bounding boxes and error metrics associated with object-reps used by different culling algorithms. It stores all the object-reps on the disk and loads them on the fly based on front computation and the fetching algorithm, as described in Section 4. The resulting skeleton typically takes only a small fraction of the overall model representation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Parallel Processes: Our algorithm uses two processes, one for rendering and one for I/O. The figure shows the tasks performed by each of the two processes in a given frame time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Binning: The range [0, δ) is divided into B intervals, each interval corresponding to a bin as labeled in the figure. is the user-specified error tolerance. In this fig, = 10, δ = 12, B = 13</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Powerplant model (PP) is a 0.6 gigabyte model consisting of over 13 million triangles and 1, 200 objects (see</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Object-reps for replacement are chosen from the head of the InMemoryList. Object-reps in the front (in red) and those that have been prefetched (in green) lie beyond StartTail in the InMem-oryList in an increasing order of priority. As a result they are less likely to be evicted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Double Eagle tanker model (DE) is a 3 gigabyte environment consisting of over 82 million triangles and 127, 000 objects (see</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>( a )</head><label>a</label><figDesc>Powerplant (PP) (b) DoubleEagle (DE)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Fetch size: The black graph shows the half the front size. The blue &amp; red plots show the fetch sizes (in Stage II) for OOCNoPre &amp; OOCPre systems on Machine 1, respectively. The OOCNoPre &amp; OOCPre systems used a memory footprint of 15 and 35 MB for PP &amp; DE respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Check whether the node's bounding box lies in the viewing frustum. • Simplification Culling: Check whether any object-rep associated with that node satisfies the user-specified error bound. Among all object-reps associated with the node, the algorithm chooses the coarsest object-rep that meets the screen-space error criteria. Of all object-reps N [i] that satisfy N [i] &lt; it chooses the one with smallest i. Here is the user-specified error tolerance. If such an object-rep N [i] exists, the algorithm renders it and terminates the traversal</figDesc><table /><note>View-Frustum culling:</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>During each frame, PI performs prefetching during two stages of that frame, Stage I &amp; Stage III asFigure 4: Visibility Prefetching: Each of the two processes, PR &amp; PI use two separate view frustums, FR &amp; FI respectively. FR is in black while FI is the larger view frustum in red shown in</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Benchmark</figDesc><table><row><cell>Models: Statistics for the Powerplant model</cell></row><row><cell>(PP) &amp; Double Eagle Tanker model (DE).</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>OOCPre &amp; the in-core system (Incore) respectively on Machine 2 that has 16 GB of main memory. The Incore system needed more than 0.6 and 3 giga-bytes of main memory for rendering the PP &amp; DE models respectively. The OOCNoPre &amp; OOCPre systems used a memory footprint of 15 MB and 35 MB for PP &amp; DE respectively. We see that the OOCPre system matches the performance of the Incore system.</figDesc><table><row><cell>Figure 9: Frame time: Plots in blue &amp; red show the frame times for the out-of-core system without prefetching (OOCNoPre), &amp; out-of-core</cell></row><row><cell>system with prefetching (OOCPre), respectively on Machine 1 that has 128 MB of main memory. Plots in green &amp; black show two times the</cell></row><row><cell>frame times for • OOCNoPre: It initially loads the scene graph skeleton and</cell></row><row><cell>performs parallel rendering &amp; I/O management without any</cell></row><row><cell>prefetching. It fetches data from the disk in Stage II, but is</cell></row><row><cell>idle during Stages I &amp; III (see Fig 3).</cell></row><row><cell>• OOCPre: It initially loads the skeleton and performs both</cell></row><row><cell>parallel rendering &amp; I/O management as well as prioritized</cell></row><row><cell>prefetching (OOCPre).</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>This work has been supported in part by ARO Contract DAAD19-99-1-0162, NSF awards ACI 9876914 and ACI 0118743, ONR Young Investigator Award (N00014-01-1-0067), a DOE ASCI grant, and by Intel Corporation. The Double Eagle model is cour-tesy of Rob Lisle, Bryan Marz, and Jack Kanakaris at Newport News Shipbuilding. The Power Plant model is courtesy of an anonymous donor. We would like to thank the members of UNC Walkthrough group for useful discussions and support. Special thanks to Shankar Krishnan and Claudio Silva for their help.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">MMR: An integrated massive model rendering system using geometric and image-based acceleration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Aliaga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hoff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuerzlinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bastos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Whitton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatic image placement to provide a guaranteed frame rate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Aliaga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lastra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactive visualization of aircraft and power generation engines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lisa</forename><forename type="middle">Sobierajski</forename><surname>Avila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="483" to="486" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parallel accelerated isocontouring for out-of-core visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Parallel Visualization and Graphics Symposium</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="87" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Gigawalk: Interactive walkthrough of complex environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">V</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">K</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Rendering Workshop</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Case study: Scanning michelangelo&apos; florentine pieta</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bernadini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mittleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Rushmeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 99 Course Notes Course 8</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">External-memory graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM-SIAM Symposium on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">External memory techniques for isosurface extraction in scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AMS/DIMACS Workshop on External Memory Algorithms and Visualization</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On caching and prefetching of virtual objects in distributed virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H P</forename><surname>Chim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W H</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Leong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Si</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Multimedia</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">External memory simplification of huge meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
		<idno>IEI:B4-02-00</idno>
		<imprint>
			<date type="published" when="2000" />
			<pubPlace>IEI, CNR, Pisa, Italy</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Double Eagle -small front (b) Double Eagle -large front</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">In the two figures, the black plot shows half and one-eighth of the front size respectively. The green, blue &amp; red plots show the fetch sizes corresponding to different memory footprints. We varied the front sizes and the frame rate by varying the paths and the user-specified error thresholds. The figure on the left (test performed on Machine 1) has a maximum front size of 8 MB and shows fetch sizes for different memory footprints of 8 MB, 25 MB &amp; 35 MB. The figure on the right (test performed on Machine 2) has a maximum front size of 35 MB and shows</title>
	</analytic>
	<monogr>
		<title level="m">These graphs highlight the fetch sizes (in Stage II of the I/O process) used by the OOCPre system based on different memory footprints</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
	<note>fetch sizes corresponding to memory footprints of 35 MB, 50 MB &amp; 100 MB</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">iwalk: Interactive outof-core rendering of large models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Correa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Klosowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<idno>TR- 653-02</idno>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>Princeton University</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Application-controlled demand paging for out-of-core visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">External memory view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Generalized view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="page" from="83" to="94" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Gaps: General and automatic polygon simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graphics</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hlods for fast display of large static and dynmaic environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Baxter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Out-of-core rendering of large unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Farias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Graphics and Applications</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Database management for interactive display of large architectural models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The ucb system for interactive visualization of large architectural models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Khorramabadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Sequin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Presence</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="44" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlo</forename><forename type="middle">H</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Séquin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;93 Proceedings)</title>
		<editor>James T. Kajiya, editor</editor>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Parallel occlusion culling for interactive walkthroughs using multiple gpus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">K</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sung-Eui</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<idno>TR02-027</idno>
	</analytic>
	<monogr>
		<title level="m">UNC Technical report</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">View dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH Conference Proceedings</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Out-of-core simplification of large polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A memory insensitive technique for large model simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;97</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Visual navigation of large environments using textured clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Blocking for external graph searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Nodine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">IRIS performer: A high performance multiprocessing toolkit for real-Time 3D graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Helman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;94</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Qsplat: A multiresolution point rendering system for large meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>ACM SIGGRAPH</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A three dimensional image cache for virtual reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schaufler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sturzlinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="227" to="235" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Brush as a walkthrough system for architectural models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mittleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifth Eurographics Workshop on Rendering</title>
		<imprint>
			<date type="published" when="1994-07" />
			<biblScope unit="page" from="389" to="399" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Hierarchical image caching for accelerated walkthroughs of complex environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lischinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Effient adaptive simplification of massive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Walking through a very large virtual environment in real-time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Shou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chionh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ruan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Very Large Data Bases</title>
		<meeting>International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="401" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Out-of-core streamline visualization on large unstructured meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-K</forename><surname>Ueng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sikorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="370" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">External memory algorithms and data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">External Memory Algorithms and Visualization</title>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Adaptive real-time level-of-detail based rendering for polygonal meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Visualizat. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="183" />
			<date type="published" when="1997-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
