<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Optimized View-Dependent Rendering for Large Polygonal Datasets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jihad</forename><surname>El-Sana</surname></persName>
							<email>el-sana@cs.bgu.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Ben-Gurion University of the Negev</orgName>
								<address>
									<postCode>84105</postCode>
									<settlement>Beer-Sheva</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eitan</forename><surname>Bachmat</surname></persName>
							<email>ebachmat@cs.bgu.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Ben-Gurion University of the Negev</orgName>
								<address>
									<postCode>84105</postCode>
									<settlement>Beer-Sheva</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Optimized View-Dependent Rendering for Large Polygonal Datasets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-Surface and object representations Surface Simplification</term>
					<term>Level of Detail</term>
					<term>Multiresolution Hierarchies</term>
					<term>View-Dependent Rendering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper we are presenting a novel approach for rendering large datasets in a view-dependent manner. In a typical view-dependent rendering framework, an appropriate level of detail is selected and sent to the graphics hardware for rendering at each frame. In our approach, we have successfully managed to speed up the selection of the level of detail as well as the rendering of the selected levels. We have accelerated the selection of the appropriate level of detail by not scanning active nodes that do not contribute to the incremental update of the selected level of detail. Our idea is based on imposing a spatial subdivision over the view-dependence trees data-structure, which allows spatial tree cells to refine and merge in real-time rendering to comply with the changes in the active nodes list. The rendering of the selected level of detail is accelerated by using vertex arrays. To overcome the dynamic changes in the selected levels of detail we use multiple small vertex arrays whose sizes depend on the memory on the graphics hardware. These multiple vertex arrays are attached to the active cells of the spatial tree and represent the active nodes of these cells. These vertex arrays, which are sent to the graphics hardware at each frame, merge and split with respect to the changes in the cells of the spatial tree.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The simple mathematical representation of three-dimensional polygonal models has led to the development of algorithms and hardware that can render these models rapidly. In addition, the advances in three-dimensional shape acquisition, simulation, and design technologies have led to the generation of large polygonal datasets. However, the increased size of generated polygonal datasets has outpaced the advances in the rendering capabilities of the graphics hardware.</p><p>To bridge the increasing gap between hardware capabilities and graphics dataset size, the complexity of the graphics dataset is reduced without a noticeable change in the visual appearance. This reduction is achieved through several algorithms and techniques such as level-of-detail (LOD) rendering with multi-resolution hierarchies, occlusion culling, and image-based rendering.</p><p>View-dependent rendering frameworks enable various levels of detail to seamlessly co-exist over different regions of the same surface. These levels of detail depend on various parameters such as view location, illumination, and speed of motion. In the current view-dependent rendering schemes an appropriate level-of-detail mesh is selected and sent to the graphics hardware for rendering at each frame. In addition, view-dependent rendering utilizes temporal coherence among consecutive frames by constructing each frame from its predecessor based on the view-dependence trees and the changes in the view-parameters. It has been shown that these view-dependent rendering algorithms have dramatically improved the rendering frame rates of polygonal datasets. However, the rendering of large polygonal models in a view-dependent manner using decent graphics hardware does not seem to produce the expected frame rates. This serious drawback results from the time spent in scanning the selected level of detail (to construct the appropriate level of detail for the next frame), which tends to be quite large in such cases. In addition, the current view-dependent rendering schemes do not utilize available efficient data representations such as vertex arrays.</p><p>In this paper we are presenting a novel approach for rapid rendering of very large datasets in a view-dependent manner. Our approach has managed to accelerate the selection of the appropriate level-of-detail mesh as well as the rendering of the selected mesh. We have found that scanning such large levels of detail and updating the resolution of each node consume a large fraction of the time spent in rendering one frame. For that reason, our approach accelerates the selection of the appropriate level of detail by only scanning active nodes that do contribute to the changes toward the next frame. Our idea is based on imposing a spatial subdivision over the view-dependence trees, and in real-time the cells of the spatial subdivision refine and merge to comply with the changes in the active nodes.</p><p>One could accelerate the rendering of a selected level-of-detail mesh by using retained-mode representations. However, the dynamic changes of the selected levels of detail overturn the benefit of using such representations. Vertex arrays, which are supported by OpenGL and various graphics hardware, form another (somewhat limited) mechanism to accelerate the rendering of polygonal datasets. In our approach, we speed up the rendering of the selected level-of-detail mesh by using multiple small vertex arrays. The size of each array depends on the memory of the graphics hardware. These vertex arrays are attached to the active cells of the spatial subdivision and represent the active nodes at these cells. The vertex arrays, which are sent to the graphics hardware at each frame, merge and split with respect to the changes in the cells they belong to.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>In this section we shall overview related work in the fields of simplification and view-dependent rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">View-Dependent Rendering</head><p>The vast majority of work on generating multiresolution hierarchies for level-of-detail-based rendering has concentrated on computing a fixed set of view-independent levels of detail. At runtime an appropriate level of detail is selected based on viewing parameters. Such methods are overly restrictive and do not take into account finer image-space feedback such as light position, visual acuity, silhouettes, and view direction. Recent advances to address some of these issues in a view-dependent manner take advantage of temporal coherence to adaptively refine or simplify the polygonal environment from one frame to the next. In particular, adaptive levels of detail have been used in terrains by Gross et al <ref type="bibr" target="#b5">[6]</ref>, Lindstrom et al <ref type="bibr" target="#b11">[12]</ref>, and Duchaineau et al <ref type="bibr" target="#b2">[3]</ref>. A number of techniques for conducting view-dependent rendering of generalized polygonal meshes rely on the primitive operations of vertex-split and edge collapse as shown in <ref type="figure" target="#fig_1">Figure 1</ref>. The edge Na, N b in the mesh on the left collapses to the vertex Np and the resulting mesh is shown on the right. Conversely, the vertex Np in the mesh on the right can split into the edge Na, N b to generate the mesh on the left. We refer to vertex Np as the parent of the vertices Na and N b . Progressive meshes have been introduced by Hoppe <ref type="bibr" target="#b7">[8]</ref> to provide a continuous resolution representation of polygonal meshes. Progressive meshes are based upon two fundamental operatorsedge collapse and its dual, the vertex split, as shown in <ref type="figure" target="#fig_1">Figure 1</ref>. Merge trees have been introduced by Xia et al <ref type="bibr" target="#b14">[15]</ref> as a data structure built upon progressive meshes to enable real-time viewdependent rendering of an object. Hoppe <ref type="bibr" target="#b8">[9]</ref> has developed a view-dependent simplification algorithm that works with progressive meshes. This algorithm uses the screen-space projection and orientation of the polygons to guide the run-time view-dependent simplifications. Luebke and Erikson <ref type="bibr" target="#b12">[13]</ref> define a tight octree over the vertices of the given model to generate hierarchical viewdependent simplifications. De Floriani et al. <ref type="bibr" target="#b1">[2]</ref> have introduced multi-triangulation (MT). Decimation and refinement in MT are achieved through a set of local operators that affect fragments of the mesh. Gueziec et al <ref type="bibr" target="#b6">[7]</ref> demonstrate a surface partition scheme for a progressive encoding scheme for surfaces in the form of a directed acyclic graph (DAG). Klein et al <ref type="bibr" target="#b10">[11]</ref> have developed an illumination-dependent refinement algorithm for multiresolution meshes. Kim and Lee <ref type="bibr" target="#b9">[10]</ref> managed to remove the dependency limitation of the split and merge operation. In their refinement scheme each vertex split or edge collapse can be performed without incurring additional vertex split and/or edge collapse transformations. El-Sana et al <ref type="bibr" target="#b3">[4]</ref> have developed Skip Strip: a data-structure that efficiently maintains triangle strips during view-dependent rendering. View-dependent rendering schemes require the existence of the entire dataset in main memory. To overcome the memory size drawback El-Sana and Chiang <ref type="bibr" target="#b0">[1]</ref> have developed an external memory view-dependent simplification.</p><p>View-dependent simplifications using the edge-collapse/vertexsplit primitives include work by Xia et al <ref type="bibr" target="#b14">[15]</ref>, Hoppe <ref type="bibr" target="#b8">[9]</ref>, Guéziec et al <ref type="bibr" target="#b6">[7]</ref>, and El-Sana and Varshney <ref type="bibr" target="#b4">[5]</ref>. View-dependent simplifications by Luebke and Erikson <ref type="bibr" target="#b12">[13]</ref>, and De Floriani et al <ref type="bibr" target="#b1">[2]</ref> do not rely on the edge-collapse primitive. Our work is most directly applicable to view-dependent simplifications that are based upon the vertex-split/edge-collapse primitive.</p><p>Shamir et al <ref type="bibr" target="#b13">[14]</ref> have developed a view-dependent approach that handles dynamic environments with arbitrary internal deformation. They have also introduced the T-DAG data structure to support their algorithm. However, it seems that their algorithm is too complicated to support large datasets at interactive rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">View-Dependence Tree</head><p>Since our technique is based on the view-dependence trees, we review this data structure here in more detail. View-dependence trees were introduced by El-Sana and Varshney <ref type="bibr" target="#b4">[5]</ref> as a compact multiresolution hierarchy that supports view-dependent rendering. In fact, for a given input dataset the view-dependence tree construction often leads to a forest (set of trees) since not all of the nodes can be merged together to form one tree. View-dependence trees are constructed bottom-up by recursively applying the vertex-pair collapse operation (see <ref type="figure" target="#fig_1">Figure 1</ref>). The order of the collapses is determined by the simplification metric. This tree differs from other previous work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b8">9]</ref> in that it enables topology simplification, does not store explicit dependencies, and handles non-manifold cases. At run-time the view-dependence tree is used to guide the selection of the appropriate level of detail based on factors such as view and illumination parameters.</p><p>To enable topology simplification, pairs of vertices that are not connected by an edge are allowed to collapse. Such vertex-pair collapse allows merging of unconnected components. A vertex pair which is not connected by an edge in the original dataset is said to be connected by a virtual edge, while the edges of the original model are referred to as real edges. To generate the virtual edges, the algorithm computes the 3D Voronoi diagram whose sites are the dataset vertices, and connects every pair of vertices by a virtual edge if they are not connected via a real edge and their corresponding Voronoi cells share a Voronoi face.</p><p>To be able to handle non-manifold cases, a more general scheme is used so that when a vertex split occurs, more than two new adjacent triangles can be added that share the newly created edge (in the case of a manifold each edge is shared by no more than two triangles). In addition, view-dependence trees make use of implicit dependencies to prevent undesirable foldovers in real-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OVERVIEW</head><p>View-dependent rendering algorithms have been introduced to enable various levels of detail to seamlessly co-exist over different regions of the same surface. These algorithms are based on multiresolution hierarchies that encode the various levels of detail and usually are constructed off-line. Once the multi-resolution hierarchies have been constructed it is possible to extract an adaptive level-of-detail mesh representation at run-time. The extracted levelof-detail mesh is then sent to the graphics hardware for rendering. In this work we use the view-dependence trees as the multiresolution hierarchy data-structure.</p><p>The selection of an adaptive level-of-detail mesh requires the determination of the set of vertices and triangulation that form the mesh. These vertices correspond to nodes on the multi-resolution hierarchies. We shall refer to these nodes as the active nodes. The selection of the level-of-detail mesh is based on various parameters such as view-position, illumination, and speed of motion. Since view-parameters usually change at each frame during interactive visualization, the selected level-of-detail mesh has to be updated at the same rate to match the new parameters. The update of the adaptive level of detail is performed by scanning the active nodes of the current level of detail and for each visited node the algorithm tests whether the resolution at the node needs to be updated -increased or reduced.</p><p>View-dependent rendering algorithms have managed to reduce the number of triangles sent to the graphics hardware often by one order of magnitude while keeping their visual appearance. However, rendering very large polygonal dataset in a view-dependent manner using good graphics hardware such as GeForce does not result in the expected frame rates.</p><p>After analyzing the work-flow of the view-dependent rendering for large datasets, we have found that a large fraction of the rendering time is spent on extracting the appropriate level-of-detail mesh. The size of the selected level-of-detail mesh usually depends on the rendering capability of the graphics hardware. In addition, the advances in graphics hardware have led to the generation of graphics engines that can render large meshes at interactive rates. Consequently, for large datasets and good graphics hardware the selected level of detail tends to be very large and their scanning time forms the main cause of the deterioration in the frame rates.</p><p>To overcome this serious drawback we have developed a new scheme that performs a prioritized and selective scanning of the active nodes and reduces the time required to select an appropriate level-of-detail mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">TERMINOLOGY</head><p>For a given set of view-parameters vp and a view-dependence tree vdt, we define an active node of vdt as stable if it does not need any change in its current resolution in order to match the viewparameters vp. We also say that a selected level of detail is appropriate with respect to a given set of view-parameters vp if all its nodes are stable. Notice that the traversal of stable active nodes does not contribute to the selected level-of-detail mesh. We define the energy of a set of active nodes s (of the view-dependence tree) as the ratio of the number of unstable nodes to the total number of nodes in the set s. We shall refer to a set of active nodes as stable if its energy is 0 (all its active nodes are stable).</p><p>If the selection of the level-of-detail mesh does not react quickly to the change in the view-parameters, the resulting mesh may include regions with low resolution that could have higher resolution otherwise. In such cases we say that the selected level-of-detail mesh is lagging behind the given view-parameters and we shall refer to this phenomenon as the lagging effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ACCELERATING LEVEL OF DETAIL SELECTION</head><p>One could accelerate the selection of the level of detail by optimizing the update operations and/or speeding up the scanning of the active nodes. However, it is important to notice that the heavy computations of the update operation are performed in the off-line preprocessing stage and the run-time update operation usually involves only a small number of pointer and integer instructions. The scanning of the active nodes list is usually performed by traversing a linked list which involves a very small number of simple instructions.</p><p>The scan of the active nodes at each frame involves testing the visual fidelity of each active node with respect to the given viewparameters. Such an assessment usually includes challenging computations such as distance from the view position and difference between the normal of the active node and the view-direction. In addition, if illumination is taken into account we need to compute the orientation of the node's normal with respect to each light source. These computations are performed independently of the fact that this node may or may not need any change in its current resolution. For large datasets the number of active nodes could be very large and their scan time may reduce the frame rates. One could improve the frame rates by distributing the time for one complete scan over several frames. However, that could affect the visual appearance of the datasets, which may result in a noticeable lag.</p><p>Our approach is designed to accelerate the selection of an appropriate level of detail by reducing the time wasted in scanning stable active nodes and performing a prioritized scanning of the active nodes to adapt instantly to quick changes in the view-parameters (to reduce the lagging effect). We have successfully managed to achieve these goals by imposing a spatial subdivision over the viewdependence trees which we will discuss next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Spatial Subdivision</head><p>Our spatial subdivision forms an additional level of hierarchy, which is built on top of the view-dependence trees of the given mesh. The spatial subdivision is constructed by recursively dividing into two each cell that includes more than a pre-defined (upperbound) number of nodes. The subdivision of each cell is guided by the structure of the view-dependence trees and the spatial disparity of the nodes in the cell. The resulting data-structure is in the form of a binary tree that we shall refer to as the spatial tree. The nodes of the spatial tree correspond to cells on the spatial subdivision. The construction of the spatial tree is performed in two phases -initialization and real-time refinement. The initialization is carried out while loading the roots of the view-dependence trees by building a spatial tree for the roots (of the view-dependence trees) only. Upon the completion of the initialization phase we store only the leaves of the constructed spatial tree because these are the only cells that can be active at run time. These leaves form the roots of the spatial trees, which are constructed during the interactive navigation by the real-time refinements (which we shall explain next). <ref type="figure" target="#fig_2">Figure 2</ref> depicts the two phases of the construction of spatial trees. The left side <ref type="figure" target="#fig_2">(Figure 2(a)</ref>) shows the complete construction of the spatial tree built in the initialization phase. The leaves of the resulting spatial tree are then used as the roots for the real time construction (see <ref type="figure" target="#fig_2">Figure 2</ref>(b)). A construction of an additional level by using real-time refinements is shown in <ref type="figure" target="#fig_2">Figure 2</ref>(b).</p><p>Since each node of the view-dependence tree is contained within one cell of the spatial tree, the active nodes of the view-dependence trees define a set of active cells (of the spatial tree). These active cells refine and merge to comply with the changes in the active nodes of view-dependence trees as result of the changes in the view-parameters. It is important to notice that the frequency of the changes in the active cells (as result of refine or merge operations) is much smaller than that of the active nodes. The refinement and merging of active cells depend on the number of active nodes in the cell. We define the rank of a cell ci as the number of active nodes in the cell ci. At run time the rank of a cell may change as a result of the merge and split operations on the nodes of the view-dependence trees. If the rank of an active cell exceeds the upper-bound threshold it splits into two cells by moving down the spatial tree. If the refining cell ci is a leaf, the two newly generated cells become the children of the cell ci and are linked appropriately. Two sibling cells merge by moving up the spatial tree if the sum of their ranks drops below the lower-bound threshold.</p><p>The active spatial cells define a grouping on the active nodes, which imposes a spatial hierarchy on the active nodes. To utilize this hierarchy we break the one active nodes list into several small active node lists based on the grouping defined by the active cells.</p><p>These small lists are attached to the active cells of the spatial tree according to their inclusion property -the list of the active nodes in the cell ci will be attached to the cell ci.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Prioritized Traversal</head><p>To perform traditional view-dependent rendering we need to select an appropriate level-of-detail and send it to the graphics hardware. The appropriate level of detail is selected based on the changes in the view-parameters. At each frame we traverse the active cells of the spatial tree, and for each cell we scan the list of active nodes attached to this cell. For each active node we perform the traditional procedure to test if there is a need to change the resolution at that node. Note that we use the word "traversal" to denote the process of visiting the active cells and the word "scan" to refer to the process of visiting the active nodes and testing the appropriateness of the resolution at each node. We shall stick to this terminology for the rest of this paper.</p><p>It is clear that in such a view-dependent scheme there is no advantage in using the spatial hierarchy. However, it is easy to notice that the order of traversing the active spatial cells is very flexible. Such flexibility allows the traversal of the active spatial cells to be performed in a selective manner based on various criteria such as importance and stability of nodes in each cell.</p><p>We define the energy of a cell ci as the energy of the set of active nodes in ci and the cell ci is called stable if its energy is 0. Note that the energy of a cell could be estimated without scanning its active nodes by using parameters such as the cell's position and its update history. In the next section we shall explain our approach to estimate the energy of an active cell.</p><p>To reduce the lagging effect we traverse the cells of the spatial tree in decreasing order of their energy. In addition, the traversal of the active cells is performed within a time budget, which is determined (partially) by the time of one frame. We may stop the update of the selected level-of-detail when the time budget expires to launch the display process in order to avoid unacceptable frame rates. It turns out that such update peaks (an update that exceeds the time budget) do not last long and usually disappear after a small number of frames. That explains the dramatic reduction in the lagging effect as result of using this technique. <ref type="figure" target="#fig_4">Figure 3</ref> shows a selected level-of-detail of the Terrain model where the viewpoint is on the center and looking down (to the terrain). <ref type="figure" target="#fig_4">Figures 3(a)</ref> and (b) show the Terrain model without and with the wire-frame representation. <ref type="figure" target="#fig_4">Figure 3</ref>(c) shows the energy of the active nodes computed from the previous frame. As can be seen most of the energy (shown in black) is concentrated near the viewpoint. It is also important to notice that the energy of the active nodes has a bell-shape that is centered very close to the viewposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Selective Traversal</head><p>The traversal of stable cells does not result in any update operation, and consequently does not contribute to the selected level-of-detail mesh. Generally, stable cells form a considerable fraction of the active cells in large datasets. For that reason, not scanning these stable cells can significantly reduce the time required to select the next appropriate level of detail. We estimate the energy of active cells and determine stable cells based on the following observations:</p><p>• A change in the view-parameters usually affects differently the cells of the spatial tree. Moving the view position by a small value d may require the update of the close-to-viewer cells, but no changes in the far-from-viewer cells.</p><p>• Stable cells tend to maintain their stability for a few frames.</p><p>We have found that in practical navigation of large datasets, cells maintain their stability proportional to their distance from the view position. Consequently, one could use the energy of cells, which are computed in the previous frame, to maintain better estimation of their current stability.</p><p>• View-dependent rendering schemes usually generate a smooth transition of the levels of detail over the different regions of the selected mesh. For that reason, the energy of adjacent cells does not vary by large values and consequently the continuity in the energy of cells can be used to estimate the energy of nearby cells (see <ref type="figure" target="#fig_4">Figure 3(c)</ref>).</p><p>We have utilized the above observations to reduce the time spent in traversing and scanning the active spatial cells at each frame. Such reduction is achieved by avoiding unnecessary scanning of stable active cells. The main idea is not to scan the entire set of active cells within one frame but to cover all the active cells after n frames (n is a small number). After these n frames, the number of times we scan a cell ci is proportional to the accumulated energy of the cell ci during the n frames. For example, if all the active cells are visited after 10 frames, frequently changed cells are scanned 10 times while stable cells may be scanned only once. It is important to notice that the number of active cells is much smaller than the number of active nodes.</p><p>For each spatial cell we maintain a real positive variable to determine when a traversed cell will be scanned. We shall refer to this variable as the scan-flag. Our traversal algorithm starts from the cell cstart which has the highest energy, then it completes the traversal in a breadth first manner. The breadth traversal is based on the spatial connectivity and the estimated energy of the active cells. For each visited active cell the algorithm updates the scan-flag by adding a real positive value in the range [0 . . . 1.0]. We shall refer to the added value as the delta-scan which satisfies: (a) Its value is reverse proportional to the distance between the visited cell and the cell cstart; and (b) It should guarantee that after a small number of traversals each active cell is scanned at least once. After adding the delta-scan to the scanflag of the cell ci the algorithm tests if it needs to scan the nodes of the cell ci and update its scan-flag.</p><p>We have found that in practical navigation the cell with the highest energy is either the closest cell to the current viewpoint or the closest cell to the viewpoint of the previous frame. For this reason, in our current implementation we choose the largest (in terms of the active nodes) cell among these two cells as the starting cell.</p><p>Our algorithm accelerates the selection of an appropriate levelof-detail mesh without introducing any noticeable visual artifacts. The selective scan algorithm satisfies:</p><p>a) The number of times it scans a cell is proportional to its closeness to the view position. b) Two cells which are far-from-the viewer are scanned in an even manner, which means that the two cells will be scanned about the same number of times.</p><p>c) The scanned cells which are at a similar distance from the viewer are uniformly distributed within the active cells of similar distance from the view position; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RENDERING THE SELECTED LEVEL OF DETAIL</head><p>Vertex arrays form a compact and efficient mechanism to transfer data to the graphics hardware. Such a mechanism has been adopted by most graphics APIs such as OpenGL and supported by various graphics hardware. However, the limited size of the memory on the graphics hardware often restricts the acceleration gained by these arrays. In addition, the graphics data should be passed to the API in continuous memory blocks (arrays). Utilizing such a mechanism in dynamically changing polygonal meshes, such as the selected level of detail, requires smart techniques and meticulous data-structures. We have designed the spatial tree data-structure to accelerate the selection of levels of detail as well as the rendering of the selected levels of detail. For each active cell of the spatial tree we assign several vertex arrays, which correspond to the active nodes, active triangles, normals, and colors lists of the same cell. We have adopted the vertex arrays because they are more flexible than the display lists and faster than the immediate mode. To comply with the view-dependent strategy, we utilize coherence between consecutive frames for these vertex arrays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VA</head><p>VA VA VA 0 1 2 3 <ref type="figure">Figure 4</ref>: Four vertex arrays sharing the same buffer.</p><p>The execution of an update operation (vertex-pair collapse or vertex-split) performs several changes in the active nodes list (and active triangles list). The vertex arrays need to be modified accordingly to reflect the changes in the active nodes list (and other lists). In order to utilize these arrays efficiently we should avoid generating fragments and empty spaces inside any vertex array. An update operation could modify, delete, or insert items on any vertex array. Insertion is performed by adding the item to the end of the array and deletion is carried out by replacing the deleted item with the last item in the array.</p><p>When a split operation is performed on a cell of the spatial tree, its vertex arrays are split and distributed into the newly generated children cells. Similarly, when two cells merge to make their parent active, the vertex arrays merge accordingly. A naive implementation of the split and merge operations on the vertex arrays requires copy and move operations on the items of these arrays. To minimize the number of these operations we use one common buffer block for several vertex arrays as shown in <ref type="figure">Figure 4</ref>. As a result of performing merge operations on the active nodes, the vertex arrays gradually change and generate empty gaps between themselves. Note that in the absence of these gaps one could perform the merge of two vertex arrays only by considering the pointer to the first vertex array as the pointer to the merge result. To enable such a merge we are required to minimize the gap between two adjacent arrays such as V A0 and V A2 in <ref type="figure">Figure 4</ref>. Recall that merge operations delete items from vertex arrays, by replacing the last item with the deleted one. Let us consider two adjacent vertex arrays, and modify the deletion on the second vertex array such that the deleted item is replaced by the first instead of the last item. By using this technique we manage to eliminate the gap between these two vertex arrays and enable the use of the simple and fast merge operation. Note that such an approach can eliminate the gap for three levels and requires the rearrangement of the buffer block in the forth level. Consequently, this approach manages to reduce the merge/split of the vertex array by using copy and move operations to only one fourth of the height of the spatial tree. It is important to notice that the spatial trees usually tend to have small depth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">VIEW-DEPENDENT ON DUAL PRO-CESSOR MACHINE</head><p>The affordable prices of the processors of personal computers and the demand for powerful machines have dramatically increased the availability of personal computers with dual processors. In this section we present our dual processor view-dependent rendering which efficiently utilizes the two processors of the machine. The viewdependent rendering is naturally divided into two main tasks, adapt and display. The adapt process selects an appropriate level of detail and the display process sends the selected level of detail to the graphics hardware. However, allowing the two processes to run in two different processors requires a synchronization that should prevent sending an incorrect (incomplete) mesh to the graphics hardware. Such a case may occur when the display process sends a selected level of detail to the graphics hardware before the adapt process has completed an update operation. One could use locks (semaphores) to prevent such inconsistencies. However, if the display process places a lock on the entire active nodes list, it locks the adapt process during the display time, resulting in a sequential adapt-display processing. If the adapt process places a lock before performing an update operation, it may lock the display for most of the adapt time which again results in an inefficient utilization of the two processors. We have developed a lock-free synchronization approach, which is based on a shared auxiliary buffer(refer <ref type="figure" target="#fig_6">Figure 6</ref>). The adapt process performs the scan and the update of the active nodes lists (and active triangles lists), and the display process updates the vertex arrays and sends them to the graphics hardware. The buffer is a circular queue, which holds only the final result of the update operation in a form of compact commands to modify the vertex arrays. The adapt process writes to the head of the queue and the display reads from the tail of the queue. The two processors maintain a safe delta between the head and the tail of the queue to avoid reading incomplete update command set.</p><p>In our scheme the two processes run completely in parallel. In addition, the two processes run independent of each other -the adapt process updates the selected level of detail in its own time and the display process sends the vertex arrays to the graphics hardware and maintains interactive frame rates. The adapt process sends update operations to the auxiliary buffer in almost continuous manner while the display process updates its vertex array before each frame. At each frame, the display process reads the maximal possible fraction from the auxiliary buffer that does not ruin the frame rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RESULTS</head><p>We have implemented our approach in C++ on a Linux operating system. Then we have tested our algorithm on several datasets and have received encouraging results.</p><p>View-dependent rendering algorithms are known for their ability to take advantage of coherence between consecutive frames. Therefore, it makes more sense to compare its performance over a sequence of frames and not over one isolated frame. For that reason, all the results we are reporting in this paper were obtained using sequences of frames.</p><p>The performance of our algorithm is evaluated against a similar view-dependent algorithm that does not support the acceleration features. We consider two measures -lagging factor and frame rates. The lagging factor is measured by counting the number of update operations required to stabilize all active nodes. Notice that there are always unnoticed small lagging effects as a result of updating what could be updated in one scan; and not using a recursive update of the active nodes that prevent the update of other active nodes.</p><p>For each dataset we have recorded a path that includes the camera and illumination parameters. Then for each dataset, we compare the performance of the two algorithms over the same path. For each test, we compare the average frame rates and the average lagging effect of the two algorithms. <ref type="figure">Figure 7</ref> shows a scene of three Dragon models, most of the cells on the closest Dragon got scanned on almost every frame, while the cells of the head of the furthest Dragon were scanned about twice in every ten scans (1/5th of the scans). The lagging effect appears when the adapt process was not able to extract the appropriate level of detail within the limited time of one frame. <ref type="figure" target="#fig_7">Figure 8</ref> shows this effect using a top view of the visualized terrain. The image 8(a) shows a select view, 8(b) shows an appropriate level of detail for the selected view, and 8(c) shows how the newly selected view was not able to receive the appropriate level of detail. <ref type="figure">Figure 7</ref>: A scene of three Dragon models. Cells on the head of the far dragon were scanned about twice on every 10 scans. <ref type="table">Table 1</ref> shows the results of testing our algorithm on various large datasets. We have obtained these results using a machine with two PIII processors, 256 MB local memory, and a GeForce2 graphics accelerator. Each row of <ref type="table">Table 1</ref> summarizes the results of one path where Updated is the average number of update operations per frame, Scanned is the average number of active nodes the algorithm has scanned in each traversal, Lagging is the average percentage of update operations required to reach a stable state, and Time is the average time of one frame. As can be seen in this table we have successfully managed to achieve better frame rates and almost eliminate the lagging effects for large datasets.</p><p>There is one video segment (Terrain.mpg) accompanied with this paper. It shows a fly over a large terrain (1044 K triangles). The video segment was recorded in real-time using dual processors PIII machine with 256 MB and GeForce2 graphics accelerator. We have observed about 14-18 frames/second on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>In this paper we have presented a new approach to improve the frame rates of view-dependent rendering for large datasets. We have accelerated the selection of the appropriate level of detail by only scanning active nodes that do contribute to the selected level of detail. Our approach is based on imposing a spatial subdivision on top of the view-dependence trees. We have also used vertex arrays <ref type="table">Table 1</ref>: Run time over a sequence of frames for various datasets by different view-dependent rendering algorithms. to accelerate the rendering of the selected level of detail mesh. To overcome the dynamic changes of the selected levels of detail we have used multiple small vertex arrays. The sizes of these arrays depend on the memory available on the graphics hardware. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>IEEE</head><label></label><figDesc>Visualization 2002 Oct. 27 -Nov. 1, 2002, Boston, MA, USA 0-7803-7498-3/02/$17.00 © 2002 IEEE</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Edge collapse and vertex split</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>The two phases of building a spatial tree:(a) Initialization, (b) Real-time refinement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>The scan-flag is updated and tested at each visit, if the value of the scan-flag exceeds 1.0 our algorithm performs: a) scans the cell and updates all the active nodes (within the cell) to match the given view-parameters. b) subtracts 1.0 from scan-flag variable to bring it back to the range [0 . . . 1]. The scan-flag of a spatial cell is initialized to a random value in the range [0 . . . 1.0] each time the cell becomes active.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>(a) A selected view b) With wire-frame b) The energy of the active nodes d) The neighbors of unstable cells are included in the scanned cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>The changes and merge of vertex arrays. V A01 results of the merge of V A0 and V A1 (and the same for V A23)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>View-dependent rendering on dual processor machine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>(a) A selected view b) No lagging effect noticeable b) A lagging effect appears after the change of the the view parameters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Original and select view of the Power Plant model. (a) Selected View (b) Wire-frame representation of (a) Flying over the Medium Terrain, the cells in the top and bottom sides were visited about once in every 10 frames.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">ACKNOWLEDGEMENTS</head><p>This research we partially funded by Weiler Family, Toman, and Kahanov Funds. We would like to thank the reviewers for their insightful comments. The Power Plant dataset was provided by the University of North Carolina and the Dragon model was provided by Stanford Computer Graphics Laboratory.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dataset</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">External memory view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chiang</surname></persName>
		</author>
		<idno>C-139-C-150</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient implementation of multi-triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;98</title>
		<meeting>Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Roaming:real-time optimally adapting mesh</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97 Proceedings</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Skip strips: Maintaining triangle strips for view-dependent rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Azanli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99 Proceedings</title>
		<meeting><address><addrLine>October</addrLine></address></meeting>
		<imprint>
			<publisher>ACM/SIGGRAPH Press</publisher>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Generalized view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="83" to="94" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fast multiresolution surface meshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gatti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95 Proceedings</title>
		<editor>G. M. Nielson and D. Silver</editor>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A framework for streaming geometry in VRML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE CG&amp;A</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="68" to="78" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;96</title>
		<meeting>SIGGRAPH &apos;96</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;97</title>
		<meeting>SIGGRAPH &apos;97</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="189" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Truly selective refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Graphics Interface</title>
		<meeting>of Graphics Interface</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Illumination dependent refinement of multiresolution meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schilling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straßer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Intl</title>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="page" from="680" to="687" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Real-Time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIG-GRAPH &apos;97</title>
		<meeting>SIG-GRAPH &apos;97</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="198" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multi-resolution dynamic meshes with arbitrary deformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;2000 Proceedings</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="423" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Adaptive real-time levelof-detail-based rendering for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="183" />
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
