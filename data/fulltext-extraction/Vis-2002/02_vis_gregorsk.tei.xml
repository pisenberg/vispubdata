<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive View-Dependent Rendering Of Large Isosurfaces</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Gregorski</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Applied Scientific Computing</orgName>
								<orgName type="department" key="dep2">Center for Image Processing and Integrated Computing</orgName>
								<orgName type="institution" key="instit1">Lawrence Livermore National Laboratory</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Duchaineau</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Applied Scientific Computing</orgName>
								<orgName type="department" key="dep2">Center for Image Processing and Integrated Computing</orgName>
								<orgName type="institution" key="instit1">Lawrence Livermore National Laboratory</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Applied Scientific Computing</orgName>
								<orgName type="department" key="dep2">Center for Image Processing and Integrated Computing</orgName>
								<orgName type="institution" key="instit1">Lawrence Livermore National Laboratory</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Applied Scientific Computing</orgName>
								<orgName type="department" key="dep2">Center for Image Processing and Integrated Computing</orgName>
								<orgName type="institution" key="instit1">Lawrence Livermore National Laboratory</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Applied Scientific Computing</orgName>
								<orgName type="department" key="dep2">Center for Image Processing and Integrated Computing</orgName>
								<orgName type="institution" key="instit1">Lawrence Livermore National Laboratory</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>Davis</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive View-Dependent Rendering Of Large Isosurfaces</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.5 [Computing Methodologies]: Computer Graphics-Computational Geometry and Object Modeling Curve</term>
					<term>surface</term>
					<term>solid</term>
					<term>and object representations I.3.6 [Computing Methodologies]: Computer Graphics-Methodology and Techniques Graphics data structures and data types View-Dependent Rendering</term>
					<term>Isosurfaces</term>
					<term>Multiresolution Tetrahedral Meshes</term>
					<term>Multiresolution Techniques</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Closeup view of an isosurface feature in the mixing interface of two gases showing the texture mapped surface, underlying triangle mesh, and the adaptively refined tetrahedral mesh around the region of interest. Time step = 273, Isovalue = 206, Isosurface error = 1.5, 50K Triangles, rendered at 7 frames per second.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The advent of high-performance computing has completely transformed the nature of most scientific and engineering disciplines making the study of complex problems from experimental and theoretical disciplines computationally feasible. Traditionally, with smaller and simpler data sets, researchers have developed in-core visualization and data exploration methods that work well on small or medium-scale datasets. They can quickly generate isosurfaces, and treat each isosurface independently. However today's impact * {gregorski1,duchaine,pl,pascucci}@llnl.gov, † kijoy@ucdavis.edu problems of science and engineering require a different approach to address the increasingly difficult problems of organization, storage, transmission, visualization, exploration, and analysis associated with massive datasets.</p><p>We present a new algorithm for interactively extracting and rendering isosurfaces of large data sets in a view-dependent manner. Our algorithm generates isosurfaces "on-the-fly" using a viewdependent error measure, a recursive tetrahedral mesh refinement scheme, and a unique data layout scheme suitable for out-of-core visualization of large datasets.</p><p>Surface based level-of-detail techniques such as <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b20">[21]</ref> extract a coarse isosurface and iteratively build a multiresolution surface model. For large volume datasets that contain topologically complex isosurfaces with millions and millions of triangles, these techniques need to be combined with out-of-core simplification techniques such as those developed by Lindstrom <ref type="bibr" target="#b10">[11]</ref> and Lindstrom and Silva <ref type="bibr" target="#b12">[13]</ref> in order to operate. In some cases, the storage requirements needed to extract, simplify, and visualize these surfaces can actually exceed those of the volume data from which they are derived <ref type="bibr" target="#b1">[2]</ref>. Interactively visualizing these types of isosurfaces requires algorithms such as those developed by Duchaineau et al. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, that combine multiresolution representations, compression, and view-dependent optimizations. Surface based techniques are not suitable for visualizing volumes that contain a large number of isosurfaces that are important to the user because they must extract all of the interesting surfaces which would take far too much storage to be practical. On the other hand, volume based techniques, which extract and render the isosurfaces directly, do not require the precomputation of selected isosurfaces, and can easily switch between isovalues.</p><p>In this paper, we utilize the refinement of a tetrahedral mesh via longest-edge bisection to build a multiresolution hierarchy of a volume dataset. We combine coarse-to-fine and fine-to-coarse refinement schemes for this mesh to create an adaptively refinable tetrahedral mesh. This adaptive mesh supports a dual priority queue split/merge algorithm similar to the ROAM system <ref type="bibr" target="#b2">[3]</ref> for viewdependent terrain visualization. It has fast coarsening and refine-ment operations which allow for localized, incremental mesh updates, strict frame-to-frame triangle counts, progressive improvements of mesh quality, and guaranteed frame rates. The refinement scheme is coupled with a data storage scheme which aligns the data on disk and in main memory with the access pattern dictated by the mesh refinement. Sets of tetrahedra that share a common refinement edge are grouped into an aggregate structure called a diamond. Diamonds, as opposed to tetrahedra, function as the unit of operation in the mesh hierarchy and simplify the process of refining and coarsening the mesh.</p><p>At runtime, the split/merge refinement algorithm is used to create a lower resolution dataset that approximates the original dataset to within a given error tolerance. The error tolerance is a measure of how much an isosurface, extracted from the lower resolution dataset, deviates from the finest level isosurface. The error tolerance is measured in pixels on the view screen. The lower resolution dataset is a set of tetrahedra, possibly from different levels of the hierarchy, that approximates the volume dataset to within this isosurface error tolerance. This set of tetrahedra is free from cracks and T-intersections, and it defines a piecewise linear approximation of the original data. The isosurface is extracted from the tetrahedra in this lower resolution representation using linear interpolation.</p><p>In a preprocessing phase, we compute general information for each diamond that is used to drive the runtime mesh refinement. The following information is computed for the diamonds (</p><p>1. The isosurface approximation error of the region enclosed by the diamond. <ref type="table">(Section 5)</ref> 2. The min and max data values within the diamond including the diamond's boundary. The precomputed min/max ranges are used to quickly cull regions of the dataset that do not contain the isosurface.</p><p>3. The gradient vector at the center point of the diamond. The center point is also called the split vertex of the diamond. (Section 3.1) The precomputed gradient vectors are used to shade the isosurface using texture mapping.</p><p>The remainder of our paper is structured as follows: Section 2 reviews related work. Section 3 reviews longest edge bisection and introduces parent and child relationships for refining and coarsening the mesh. Section 4 describes the split/merge algorithm for refining and coarsening. Error metrics are described in Section 5. In Sections 6 and 7, we describe the data structures used to implement the split/merge refinement, and give an efficient, compact method to encode the mesh's structure. In Section 8, we discuss our data layout scheme. Our results are shown in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PREVIOUS WORK</head><p>The refinement of a tetrahedral mesh via longest edge bisection is described in detail in several papers. In Zhou et al. <ref type="bibr" target="#b22">[23]</ref>, a fine-tocoarse merging of groups of tetrahedra is used to construct a multilevel representation of a dataset. Their representation approximates the original dataset to within a specified tolerance and preserves the topology of the finest level mesh. For larger datasets, this fine-tocoarse strategy is not practical because storing the finest level mesh would require too much memory.</p><p>An improved algorithm for preserving the topology of an extracted isosurface is presented by Gerstner and Pajarola <ref type="bibr" target="#b7">[8]</ref>. This algorithm is combined with a coarse-to-fine splitting of tetrahedra to extract topology preserving isosurfaces or to perform controlled topology simplification. Rendering of multiple transparent isosurfaces and parallel extraction of isosurfaces are presented by Gerstner <ref type="bibr" target="#b5">[6]</ref> and by Gerstner and Rumpf <ref type="bibr" target="#b6">[7]</ref>. Both of these algorithms extract the isosurfaces from the mesh in a coarse-to-fine manner. In Roxborough and Nielson <ref type="bibr" target="#b19">[20]</ref>, the coarse-to-fine refinement algorithm is used to model 3-dimensional ultrasound data. The adaptivity of the mesh refinement is used to create a model of the volume that conforms to the complexity of the underlying data.</p><p>View-dependent extraction of isosurfaces utilizes multiresolution representations to extract surfaces that satisfy certain visual requirements. These requirements are usually based on the distance of the surface from the viewpoint, the position of the surface relative to the view-frustum, and the occlusion of the surface. Duchaineau et al. <ref type="bibr" target="#b2">[3]</ref> control refinement using the screen space projection error, view-frustum culling, and line of site corrections. Occlusion culling supplements view-frustum culling by finding areas within the visible region that cannot be seen. In Livnat and Hansen <ref type="bibr" target="#b14">[15]</ref>, a hierarchical visibility test is used to determine regions of the volume that are occluded. The volume is decomposed using an octree, and the visibility test is performed using hierarchical tiles based on coverage masks (see Greene <ref type="bibr" target="#b8">[9]</ref>). A shear warp transformation is used to perform the screen space projection. Their visibility algorithm requires that the octree be traversed from front to back. Zhang et al. <ref type="bibr" target="#b21">[22]</ref> divide a large dataset into a set of independent blocks. They use ray casting from the viewpoint into the volume to determine a subset of these blocks that are occluders. These initial occluding blocks are rendered to create an occlusion mask that shows which screen pixels are covered. The remaining blocks are traversed and rendered if they are not completely occluded. Unlike <ref type="bibr" target="#b14">[15]</ref>, this last rendering step does not traverse the blocks in a front-to-back order. This ray tracing approach is also used in <ref type="bibr" target="#b13">[14]</ref> to find an initial set of voxels from which to propagate the isosurface. The algorithm starts extracting the isosurface from these seed sets, and detects when the surface folds back on itself and becomes occluded. In our algorithm, we use the screen space projection error of the isosurface and view-frustum culling to control the view-dependent refinement.</p><p>In this work, we are focused on developing algorithms for levelof-detail based, interactive exploration of large, complex isosurfaces. Surface based methods such as <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b20">21]</ref> construct levelof-detail surface models that are suitable for interactive viewdependent rendering. Volume based techniques such as <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b21">22]</ref> speed up the search for cells that contain the isosurface and cells that do not need to be rendered, but they extract the isosurface from the finest level cells. Our algorithm differs from these approaches by utilizing a level-of-detail volumetric model which extracts the isosurface from coarser representations of the volume that meet certain requirements. Isosurface extraction techniques based upon level-of-detail allow the isosurface to be progressively refined over time, see for example <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b17">18]</ref>. Visualizing large, complex isosurfaces often requires the ability to fly through the dataset and closely inspect areas of interest. Level-of-detail methods that support strict triangle counts per frame for efficient rendering, progressive improvement of mesh quality to provide guaranteed frame rates, and coherent access to data to minimize memory faults are well suited to this task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LONGEST EDGE BISECTION</head><p>In this section we review longest edge bisection and establish terminology. In this scheme, a tetrahedron is described by a level and a phase, with 3 phases at each level. The bisection begins at level 0, phase 0 with an initial configuration of a cube divided into 6 tetrahedra around a major diagonal. <ref type="figure" target="#fig_2">Figure 2</ref> illustrates the three phases of the refinement process. After three refinements, the level is incremented by 1. After n refinements, the phase is n mod 3 and the level is n/3 . The split edge of a tetrahedron is its longest edge. In each phase, a tetrahedron is subdivided into two children at the midpoint of the split edge. This midpoint is called the split vertex.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Diamonds</head><p>Tetrahedra are grouped into diamonds to simplify the refinement process and to ensure continuity of isosurfaces generated from the mesh. When a tetrahedron is split, all the tetrahedra that share its split edge must also be split. A group of tetrahedra that share a split edge is called a diamond. The split edge and split vertex of a diamond are defined as the common split edge and split vertex of its tetrahedra. All diamonds in the mesh can be uniquely identified by their split edge or split vertex. Phase 0, phase 1, and phase 2 diamonds are shown in <ref type="figure" target="#fig_0">Figures 3 and 4</ref>. Each point in the dataset, <ref type="table">Table 1</ref>: Number, phase, and level of tetrahedra, parents, and children for the three different diamonds. L is the level of the diamond.</p><formula xml:id="formula_0">Phase Tets(Phase,Level) Parents(P,L) Children(P,L) 0 6(0,L) 3(2,L-1) 6(1,L) 1 4(1,L) 2(0,L) 4(2,L) 2 8(2,L) 4(1,L) 8(0,L+1)</formula><p>except for the corner points of the original cube, corresponds to the split vertex of one diamond because each point is introduced by the splitting of a diamond. By grouping tetrahedra into diamonds, we can easily locate all of the tetrahedra around a split edge. Splitting a diamond is equivalent to splitting all of the tetrahedra in the diamond. All tetrahedra within a diamond have the same level and phase. <ref type="table">Table 1</ref> lists the number of tetrahedra, their phase, and level for each diamond.</p><p>The type of a diamond is determined by its split edge (SV0, SV1), where SV0 and SV1 are the vertices on the split edge. Starting from the initial configuration of six tetrahedra in a cube, there are 26 different direction vectors (i.e. diamond types) for the split edge; there are 8 directions for the phase 0 diamonds, 12 for the phase 1 diamonds (4 each on the XY, XZ, and YZ planes), and 6 for the phase 2 diamonds. The type of a diamond is used to efficiently encode the structure of the mesh (Section 6) including the location of parent and child diamonds (Section 3.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Parent And Child Diamonds</head><p>Given a diamond D, the parents of D are the diamonds that must be split to create D's tetrahedra. <ref type="figure" target="#fig_0">Figure 3</ref> shows the parents for each diamond. The diamonds that are created when D is split are called D's children. <ref type="figure" target="#fig_1">Figure 4</ref> shows the children for each diamond. In these figures, a diamond is indicated by its split vertex. The parent and child information is summarized in <ref type="table">Table 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SPLIT/MERGE REFINEMENT</head><p>The tetrahedral mesh supports the dual queue split/merge refinement strategy similar to that described by Duchaineau et al. <ref type="bibr" target="#b2">[3]</ref>. This strategy provides more frame-to-frame coherence than a coarse-to-fine only algorithm. It allows us to control the triangle count per frame, and to effectively cache previously computed geometry to minimize expensive interpolation calculations. In most interactive applications, the viewing position does not change significantly between consecutive frames. In frame i + 1, many diamonds from frame i will have a view-dependent error that is still within the error tolerance. These diamonds can be reused in frame i + 1. A small fraction of the diamonds must be split or merged to satisfy the error tolerance. By starting the refinement process for frame i + 1 with the mesh from frame i instead of the base mesh, fewer splits and merges are performed.</p><p>The current mesh is a set of tetrahedra that approximates the volume dataset to within a certain view-dependent error bound. The mesh is generated using two priority queues. The split queue holds the diamonds containing the tetrahedra of the current mesh. The merge queue holds the diamonds that have been split and whose children have not been split (i.e. diamonds with children but no grandchildren).</p><p>At frame 0, the split queue is initialized with the base configuration of six tetrahedra (the root diamond), and the merge queue is empty. At each frame, given a view-dependent error tolerance E, the following steps are taken:</p><p>1. Diamonds not within the view frustum are marked as invisible and diamonds that do not contain the isosurface are marked as empty; they are assigned a view-dependent error of zero. View-dependent errors are recomputed for all other diamonds in the split and merge queues.</p><p>2. Diamonds in the split queue whose error is greater than E are split. Diamonds in the merge queue whose error is less than E are merged. Invisible and empty diamonds in the split queue are never split. In the merge queue, they are the first diamonds to be merged.</p><p>3. The refinement process is stopped when all diamonds in the split queue have an error below E and all diamonds in the merge queue have an error above E, or when the time allowed for processing the current frame has elapsed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>The isosurface is extracted from the tetrahedra that belong to the visible, non-empty diamonds in the split queue.</p><p>A diamond D is split by splitting all of its tetrahedra, and inserting the child tetrahedra into the split queue. A tetrahedron is placed into the split queue by creating an entry for its diamond and adding the tetrahedron to the diamond. There is only one entry for a diamond in the split queue. When some of the tetrahedra in a diamond do not exist (i.e. they are not in the current mesh), it is necessary to create them before the diamond can be split. This situation is shown in 2D in <ref type="figure">Figure 5</ref>  <ref type="figure">Figure 5</ref>: Diamond D0 has two triangles in the mesh. Diamond D1 has two triangles, one of which in the mesh. The triangle not in the mesh is shown with the dashed lines. This is a 2D analogy of the 3D tetrahedral mesh.</p><p>Merging a diamond is done by merging all of its tetrahedra, and adding them to the split queue. A tetrahedron is merged by removing its two children from the split queue. A tetrahedron is removed from the split queue by locating its diamond's entry in the split queue and removing it from the diamond. When a tetrahedron is removed from the mesh, its diamond is checked to see if all the tetrahedra of the diamond have been removed from the queue. If so, the diamond is removed from the split queue. Lastly, the diamond's parents are checked to see if they can be added to the merge queue. A diamond can be added to the merge queue only if all of its children are in the split queue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Modifying The Isovalue</head><p>When the isovalue is changed by the user, the new isosurface can be extracted by starting at the root diamond or starting from the current mesh. In the first case, the split and merge queues, hash tables, and isosurface are invalidated and initialized with the root diamond. The split/merge refinement is then started from this initial configuration. In the second case, the split queue, merge queue, and hash tables remain the same, and the old isosurface is thrown away. The diamonds in the split and merge queues are checked to determine if they contain the new isovalue. Diamonds that do not contain the isovalue are marked as empty and given an approximation error of zero. Isosurface errors are computed for those diamonds that contain the new isovalue. The split/merge refinement continues from this new configuration. Diamonds that contain the new isosurface will be refined if their error is too large and coarsened if their error is too small. Diamonds that contained the old isosurface, but do not contain the new isosurface, will be merged because they are no longer needed to represent the volume. The effectiveness of both of these methods depends on the locality of the old and new isosurfaces in the mesh hierarchy. Starting from the current configuration makes sense if they are close together, and starting from the top makes sense if they are far apart.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ERROR METRICS</head><p>Each diamond in the mesh has an associated approximation error, isosurface error, and view-dependent error. The approximation error ea for a tetrahedron T is the maximum difference between the linear approximation over T that interpolates the values at T s vertices and the actual data values for the points inside T and on its boundary (i.e. faces, edges, and vertices). The approximation error for a diamond D is the maximum of the approximation errors of its tetrahedra. Leaf tetrahedra and leaf diamonds have an approximation error of zero. The isosurface error of a tetrahedron T is the maximum deviation of an isosurface generated using the scalar values at the vertices of T from the true isosurface passing through T . This calculation is illustrated in <ref type="figure" target="#fig_4">Figure 6</ref> for the one-dimensional case. The original function is f (x) and it is approximated by L(x). The upper and lower bounds on the approximation, given by the approximation error ea, are a1(x) and a2(x). For a given function value y, the isocontour using L(x) occurs at point a where y = L(a), while the true isocontour using f (x) occurs at the point b where y = f (b). The error in the isocontour is given by:</p><formula xml:id="formula_1">eiso = |a − b|<label>(1)</label></formula><p>An upper bound u for the isosurface error can be computed by:</p><formula xml:id="formula_2">u = ea/k ≥ eiso,<label>(2)</label></formula><p>where k is slope of the linear approximation L. As f approaches a vertical line the slope of L increases, and f is approximated with increasing accuracy by L. As the slope of f decreases, the isocontour approximation a and the true isocontour b can be far apart even if ea is small. In higher dimensions, the slope of the approximation translates to the magnitude of the gradient. In three-dimensions, this is the gradient of the field through a tetrahedron as given by the linear function that interpolates the values at the tetrahedron's vertices. The isosurface error is clamped at the physical size of the tetrahedron because the isosurface drawn through a tetrahedron can never be outside the tetrahedron's boundaries. The isosurface error for a tetrahedron T is given by:</p><formula xml:id="formula_3">eiso(T ) = min(ea/ ∇f (T ) , diam(T )),<label>(3)</label></formula><p>The isosurface error eiso(D) for a diamond is:</p><formula xml:id="formula_4">eiso(D) = max(eiso(T ), ∀T ∈ D).<label>(4)</label></formula><p>The view-dependent error of a diamond is the projection of its isosurface error onto the view screen. This projection is done by creating a sphere at the diamond's split vertex of radius eiso(D) and projecting this sphere onto the view screen. The size of the projected sphere (i.e. width or height in pixels) is the view-dependent error. Details on view-dependent error metrics can be found in Hoppe <ref type="bibr" target="#b9">[10]</ref>, Lindstrom and Pascucci <ref type="bibr" target="#b11">[12]</ref>, and Luebke and Erikson <ref type="bibr" target="#b15">[16]</ref>. All of these error metrics are easily incorporated into our refinement strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">MESH ENCODING</head><p>The mesh structure can be encoded in a very compact manner assuming that the data points lie on a (2 n + 1) × (2 n + 1) × (2 n + 1) grid. In this case, the offsets, relative to the split vertex of the diamond, to compute the tetrahedron vertices, parents, and children of a diamond are all powers of two. Data that do not lie on such a grid can either be resampled to lie on a grid of the proper size or embedded in a virtual grid of the proper size.</p><p>Since each data point corresponds to a diamond, we represent a diamond using an (i, j, k) index. This index corresponds to the index used to access the precomputed diamond information and data values if they were stored in a C-style 3-dimensional array. The vertices defining the split edge of a diamond are encoded in a single byte as an offset vector from the split vertex. For example, the split edge with SV0 = (64, 64, 0) and SV1 = (64, 0, 64) has the vector (0, −64, 64) and split vertex (64, 32, 32). Dividing this vector by 64 yields <ref type="figure">(0, −1, 1)</ref>. These values are stored as 2 bit quantities in a single byte. SV0 and SV1 are computed by rescaling the vector and adding/subtracting it from the split vertex. In this example, (0, −1, 1) is rescaled to (0, −32, 32). The rescaling factor is easily determined from the level of the diamond. For a mesh with l levels, the scaling factor for a diamond at level j is given by 2 l−j−1 . The split edge encodings are stored in a lookup table and accessed at runtime based upon the type of the diamond. Since a diamond is identified by its split vertex, the vertices on the split edge can be computed by knowing the diamond's type and level. The parents, tetrahedra, and children of a diamond are encoded and stored in the same manner as the split edge. For any diamond, the (i, j, k) index for a parent, child or vertex of a tetrahedron can be computed from the diamond's split vertex and the proper encoding. There is one set of encodings for each of the 26 types of diamonds.</p><p>Encoding the mesh in this manner allows us to quickly compute the (i, j, k) index of a diamond's parents and children. Instead of storing pointers to the parents and children of a diamond, we store all of the diamonds in a hash table and use the (i, j, k) index of the split vertex to locate a diamond. In the case of a phase 2 diamond, this saves twelve pointers (4 parents, 8 children) or 48 bytes per diamond. Since each (i, j, k) index corresponds to a data point, we can quickly compute indices for the vertices of a tetrahedron and use them to get the data values needed to extract the isosurface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DATA STRUCTURES</head><p>We precompute the isosurface approximation error, min and max scalar field values, and gradient vector at the split vertex for each diamond in the hierarchy. Gradients can be computed at runtime and stored in a hash table; however, our data layout algorithm (Section 8) makes computing gradients via central differences expensive and so the gradients are precomputed. Assuming byte scalar field data, floating point errors and floating point gradient components, 18 additional bytes are required per input value. A 1024 3 (1 Gb) dataset would be inflated to an enormous 19 Gb dataset.</p><p>In order to reduce the size of the precomputed data, the isosurface errors are compressed on a logarithmic scale on a per-level basis and represented in six bits. The gradient vectors are quantized on a unit cube using fourteen bits. In addition, we use an iterative relaxation process to smooth the gradient vectors which are computed directly from the byte datasets we use. The min and max values for a diamond D are compressed in relation to a diamond S that completely contains D. A diamond S contains a diamond D if the polyhedron for D is completely enclosed by the polyhedron for S. The tetrahedra created by recursively refining D's tetrahedra are all contained within S's polyhedron. Either of the two diamonds whose split vertices are the vertices of D s split edge can be used for S. This is illustrated in <ref type="figure" target="#fig_6">Figure 7</ref>.  The split and merge queues are implemented as hash tables using a fixed number of buckets and chaining to handle collisions. Each bucket corresponds to a range of the projected screen space error as measured in pixels. Each entry in the bucket corresponds to a diamond whose screen space error falls within the bucket's range. The buckets are not sorted internally by error value. Hash tables can be used instead of priority queues because it is not necessary to split the diamond in the split queue with the highest error, or to merge the diamond in the merge queue with the lowest error. Instead it is sufficient to split a diamond whose error is greater than the current tolerance and to merge a diamond whose error is less than the current tolerance. Hash tables with O(1) operations provide better performance than a priority queue with O(log n) operations. A separate hash table, the queue hash table, is used to map diamond indices to their entries in the queue. There is one hash table for the split queue and one hash table for the merge queue. This second hash table is necessary because the split and merge queues are ordered by view-dependent error. In order to quickly locate a specific diamond in either queue, we need to be able to access the queue based upon the (i, j, k) index of the diamond. Accessing the diamonds in the queues based on view-dependent error would require computing the view-dependent error, locating the bucket that the diamond is in, and then traversing the bucket to get the appropriate entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Queue</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Precomputed Diamond Info</head><p>Hash <ref type="table">Table  Entry</ref> Diamond Index (i,j,k) The data structures are illustrated in <ref type="figure" target="#fig_7">Figure 8</ref>. The hash table maps a diamond index to an entry in the queue. The diamond index associated with the queue entry maps back to the precomputed diamond information and the same hash table entry. When a tetrahedron is added or removed from the mesh, its diamond's index is used to locate the corresponding entry in the split queue via the split queue's hash table. Each diamond in the split queue contains flags indicating which of its tetrahedra are actually in the current mesh. The reason for these flags is shown in <ref type="figure">Figure 5</ref>. Each bucket entry in the split and merge queues stores the diamond's level, (i, j, k) index, isosurface and view-dependent errors, and invisible and empty bits.</p><p>When a tetrahedron is added to the split queue, the isosurface passing through it is computed and stored in the geometry cache. The geometry is cached in an array so that it is in a contiguous region of memory. New geometry is appended to the end of the array. Geometry is removed from the cache by replacing the removed geometry with geometry at the end of the array. A hash table is used to map a diamond to the geometry cache entries associated with its tetrahedra. This caching method duplicates normals and vertices along edges. Its advantage is that it has better memory coherence than hash table based caches which store the vertices and normals on a per-edge basis (see Gerstner and Rumpf <ref type="bibr" target="#b6">[7]</ref>). On newer graphics hardware, storing the geometry in a contiguous region of memory allows one to stream the data from memory to the graphics card for improved rendering performance. The mesh is drawn by traversing the geometry cache. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">MEMORY LAYOUT</head><p>When visualizing very large datasets, memory performance is a key bottleneck that must be overcome to achieve interactivity. In order to improve cache performance and effectively utilize the available memory bandwidth, we arrange our data on disk and in memory in a hierarchical z-order layout which follows the data ordering indicated by the mesh refinement. <ref type="figure" target="#fig_8">Figure 9</ref> shows how the mesh refinement algorithm accesses the data. Starting with the root configuration in the upper left, the dots indicate which data points are introduced at each refinement step. The numbers indicate the order in which the points are stored in a one-dimensional array. The dataset is stored first by level-of-detail (i.e. quadtree or octree level) and then by geometric proximity within each level. This layout scheme assumes that the dataset ex-   hibits periodic boundary conditions which is a valid assumption for the datasets that we are working with (i.e. for a 129 3 dataset indices 0 and 128 map to the same location). This data layout scheme and its performance benefits are detailed in <ref type="bibr" target="#b11">[12]</ref> and <ref type="bibr" target="#b18">[19]</ref>. Storing the data in this manner improves the coherence of the data access which is essential when working with large datasets. The original dataset and the information computed in the preprocessing phase of our algorithm are stored on disk in this manner. The data is mapped from disk to main memory at runtime using the Unix mmap command.</p><p>The mmap command establishes a mapping between a process's address space and a virtual memory object represented as a disk file. It provides us with a basic out-of-core paging algorithm. This allows us to keep in memory the data that is currently being used by the split/merge process and the isosurface extraction process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">RESULTS</head><p>We have tested our methods on an SGI Onyx with 44 250 MHZ R10K processors and IR2 graphics boards. At runtime the algorithm uses one processor and one graphics pipe. The preprocessing was done in parallel on the same machine. Memory and processor usage for the preprocessing and runtime phases is shown in <ref type="table" target="#tab_2">Table  2</ref>. Resident memory refers to the actual physical memory used. It includes memory used by the data structures and by the regions of the dataset that have been paged in from disk. Total memory refers to the address space currently assigned to the program. Preprocessing a 512 3 dataset takes 3.1 hours, and the final dataset size is 537 Mb. Our test dataset is the Gordon Bell Prize winning simulation of a Richtmyer-Meshkov instability in a shock tube experiment <ref type="bibr" target="#b16">[17]</ref>. The full resolution dataset consists of 274 time steps with each time step divided into a grid of 8×8×15 bricks where each brick consists of 256×256×128 byte data values for a total time step resolution of 2048×2048×1920 byte data values. A full resolution isosurface of the mixing interface produces a mesh with 460 million triangles. In our examples, we are looking at isosurfaces of entropy values calculated as two fluids mix over time. Our examples are from 512 3 chunks cropped from the full resolution dataset. <ref type="figure" target="#fig_9">Figure 10</ref> shows how the isosurface refines around the viewpoint and coarsens away from the viewpoint. <ref type="figure">Figure 1</ref> shows a closeup view of a feature in the mixing interface at time step 273. The ability to zoom in on regions of the dataset and refine the isosurface allows one to closely inspect the features of the mixing process. These images show how the mesh adaptively refines around the viewpoint. <ref type="figure" target="#fig_10">Figure 11</ref> shows an isosurface similar to the one shown in <ref type="figure">Figure 1</ref> at different screen space errors. The isosurface representing the mixing interface contains a large number of topological components and small features. In the two lower resolution surfaces, the small feature in the top left is not preserved. <ref type="table" target="#tab_3">Table 3</ref> shows the performance measurements for the visibility culling and priority recomputation, split/merge refinement, and rendering sections of our algorithm. The time for culling and priority recomputation depends on the number of computations and the memory performance of the hash table. We can perform about 700K -1.1M computations a second. Rendering at 7 FPS (0.14s per frame) and allowing at most half of the frame time for culling and priority recomputation, we are allowed 49K -77K computations per frame. Limiting the triangle count in the extracted isosurface to around 50K triangles gives us roughly 65K -85K diamonds in the queues. We recompute the visibility information for all diamonds in the split and merge queues, and we recompute the priorities for all visible, non-empty diamonds in the queues. This is an expensive operation and can be improved using hierarchical, deferred priority recomputation. The split/merge performance is determined by the number of recursive splits and the coherency of the data access. Merges only have to look at children and parents and perform O(1) lookups to find them. Splits look at children and parents and may have to look at O(n) diamonds where n is the number of levels in the tree. To test the split/merge performance, we fixed the time for doing splits and merges to 0.01s. The algorithm performs around 1000 -4000 updates per second or 10 -40 updates per frame. The time for drawing depends on the number of elements drawn. In immediate mode, the SGI graphics system can draw 50K triangles at a rate of 1.05M triangles per second which is about 20 frames per second. At 7 FPS with 0.06s for drawing, this gives us at most 63K triangles per frame. These restrictions on the triangle count, queue sizes, and mesh updates per frame, allow us to render 5 -7 frames per second or about 250K -350K triangles per second. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">CONCLUSIONS</head><p>We have presented an algorithm for quickly extracting and rendering isosurfaces from large volume datasets. Our algorithm uses a multi-resolution tetrahedral mesh based on edge bisection, extending it to support adaptive refinement and coarsening. We have shown an efficient way to encode the tetrahedra, parents, and children of the mesh structure so that the mesh can be represented compactly and computed using efficient integer operations. The implementation of the dual queue split/merge algorithm utilizes this new encoding of the mesh through the addition of a queue hash table which enables the queues to be accessed by view-dependent error and diamond indices. Our algorithm is very extensible and easily integrates with other optimizations such as deferred priority recomputation, front-to-back traversal for transparent rendering and occlusion culling, topology preservation and simplification, and parallelization.</p><p>The size and complexity of datasets such as the Richtmyer-Meshkov simulation present great visualization challenges. Our future work is focused on extending our algorithms to be able to handle the full size datasets from these simulations in interactive applications. Runtime processing of these massive datasets requires parallelization of both the refinement process and the rendering process. This can either be done on large shared memory machines or large clusters of commodity workstations. Both techniques require efficient data paging schemes to move data between processors and machines. The visualization of time varying data presents an even bigger challenge for these large datasets. Extending our algorithms to time varying data requires time varying encoding and compression of the data as well as fast decoding and decompression to update the mesh as quickly as possible.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Parent diamonds: Phase 0 parents are phase 2 diamonds from the level L − 1, phase 1 parents are located at cube centers, and phase 2 parents are located at face centers. The split edge is (SV0, SV1) (shown in green), the split vertex is SV (blue), and the parents are shown as P0, P1, P2, and P3 (red). The magenta tetrahedron is a tetrahedron in diamond P0. The shaded triangle shows how it is split into two phase 0 tetrahedra.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Child diamonds: Phase 0 children are located on the faces of a cube, phase 1 children are located on the centers of the edges of the face containing the split edge, and phase 2 children are the phase 0 diamonds from level L + 1 that touch the diamond's split edge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Three phases of refinement for a single tetrahedron of the initial configuration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>. The tetrahedra are created by splitting the parents of D that have not been split. When all the parents and tetrahedra of D have been split, D is removed from the split queue and added to the merge queue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Isosurface error calculation in 1D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>The min/max values of a diamond are encoded relative to the min and max values of an enclosing diamond using 4 bits (2 each for min/max) to encode 0/8, 1/8, 1/4, or 1/2 of the enclosing interval. (The offset 3/8 is not encoded.) In this example min = 1/8, max = 1/4.Using these data structures, the precomputed information for each diamond is stored in three bytes. A 1 Gb dataset is inflated to 4 Gb instead of 19 Gb. Error values and gradients are found at runtime using lookup tables. Since the errors are encoded in 6 bits, the table for the error values contains 2 6 × n floating point values where n is the number of levels in the mesh. For a 512 3 dataset, n equals 9. The gradient table contains 3 × 2 14 floating point values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Relationship between precomputed data, queue entries, and queue hash table.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>New data points required at each refinement level in 2D. The arrows indicate the wrapping of data values assuming periodic boundary conditions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Closeup view of a mixing feature. Time Step = 273, Isovalue = 186, Isosurface error = 0.5. On the right, a zoomed out view shows the portion of the isosurface culled by the view frustum.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Isosurface with varying screen space error at Time Step = 273, Isovalue = 213. From left to right: Error = 0.56, 95K Triangles; Error = 1.7, 30K Triangles; Error = 2.7, 13K Triangles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Memory and processor usage for the preprocessing and runtime phases for a 512 3 dataset. Runtime measurements are taken for an isosurface with 70K triangles and an error of 1.5.</figDesc><table><row><cell>Time(s)</cell><cell>Operation</cell><cell># Elements</cell><cell>Elem/Sec</cell></row><row><cell>0.07</cell><cell>Cull/Priority</cell><cell>49K -77K</cell><cell>700K -1.1M</cell></row><row><cell>0.06</cell><cell>Drawing</cell><cell>63K</cell><cell>1.05M</cell></row><row><cell>0.01</cell><cell>Split/Merge</cell><cell>10-40</cell><cell>1000 -4000</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Timings results for algorithm sections.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">ACKNOWLEDGEMENTS</head><p>This work was performed under the auspices of the U.S. Department of Energy by University of California Lawrence Livermore National Laboratory under contract No. W-7405-Eng-48. We also thank the people at the Center for Image Processing and Integrated Computing (CIPIC) at the University of California Davis for all of their help and suggestions with this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Interactive Display Of Surfaces Using Subdivision Surfaces And Wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serban</forename><surname>Bertram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Porumbescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16th Spring Conference on Computer Graphics</title>
		<editor>T.L. Kunii</editor>
		<meeting>16th Spring Conference on Computer Graphics<address><addrLine>Bratislava, Slovak Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="22" to="34" />
		</imprint>
		<respStmt>
			<orgName>Comenius University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dataflow And Re-Mapping For Wavelet Compression And View-Dependent Optimization Of Billion-Triangle Isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serban</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Porumbescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Bertram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hierarchical Approximation and Geometrical Methods for Scientific Visualization</title>
		<editor>G. Farin, H. Hagen, and B. Hamann</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">ROAMing Terrain: Realtime Optimally Adapting Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Murray</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">E</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">C</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">B</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Isosurface Extraction Techniques For Web-Based Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rdiger</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization 1999</title>
		<meeting>IEEE Visualization 1999</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="139" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast Extraction Of Adaptive Multiresolution Meshes With Guaranteed Properties From Volumetric Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcel</forename><surname>Gavriliu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Carrance</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">E</forename><surname>Breen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization</title>
		<editor>T. Ertl, K. I. Joy, and A. Varshney</editor>
		<meeting>Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="295" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fast Multiresolution Extraction Of Multiple Transparent Isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gerstner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Visualization 2001 Proceedings of VisSim</title>
		<editor>Ronald Peikert David S. Ebert, Jean M. Favre</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multiresolution Parallel Isosurface Extraction Based On Tetrahedral Bisection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gerstner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Graphics</title>
		<editor>M. Chen, A. Kaufman, and R. Yagel</editor>
		<imprint>
			<biblScope unit="page" from="267" to="278" />
			<date type="published" when="2000" />
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Topology Preserving And Controlled Topology Simplifying Multiresolution Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Gerstner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>T. Ertl, B. Hamann, and A. Varshney</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="259" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hierarchical Polygon Tiling With Coverage Masks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ned</forename><surname>Greene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings, Annual Conference Series</title>
		<editor>Holly Rushmeier</editor>
		<meeting><address><addrLine>New Orleans, Louisiana</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="4" to="09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">View-Dependent Refinement Of Progressive Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings, Annual Conference Series</title>
		<editor>Turner Whitted</editor>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="3" to="08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Out-Of-Core Simplification Of Large Polygonal Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 2000 Conference Proceedings</title>
		<editor>Kurt Akeley</editor>
		<imprint>
			<publisher>ACM Press / Addison Wesley</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="259" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Visualization Of Large Terrains Made Easy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization 2001</title>
		<editor>T. Ertl, K. Joy, and A. Varshney</editor>
		<meeting>IEEE Visualization 2001</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="363" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Memory Insensitive Technique For Large Model Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>T. Ertl, K. I. Joy, and A. Varshney</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="121" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Progressive View-Dependent Isosurface Propagation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiyan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint Eurographics -IEEE TCVG Symposium on Visualizatation (VisSym-01)</title>
		<editor>D. Ebert, J. M. Favre, and R. Peikert</editor>
		<meeting>the Joint Eurographics -IEEE TCVG Symposium on Visualizatation (VisSym-01)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="223" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">View Dependent Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization 1998</title>
		<editor>David Ebert, Hans Hagen, and Holly Rushmeier</editor>
		<meeting>IEEE Visualization 1998</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="175" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">View-Dependent Simplification Of Arbitrary Polygonal Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings</title>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Very High Resolution Simulation Of Compressible Turbulence On The IBM-SP System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arthur</forename><forename type="middle">A</forename><surname>Mirin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><forename type="middle">H</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><forename type="middle">C</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">P</forename><surname>Dannevik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andris</forename><forename type="middle">M</forename><surname>Dimits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">A</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Eliason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">R</forename><surname>Woodward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SuperComputing 1999. (Also available as Lawrence Livermore National Laboratory technical report UCRL-MI-134237)</title>
		<meeting>SuperComputing 1999. (Also available as Lawrence Livermore National Laboratory technical report UCRL-MI-134237)</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Time Critical Isosurface Refinement And Smoothing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 IEEE symposium on Volume Visualization</title>
		<meeting>the 2000 IEEE symposium on Volume Visualization</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multi-Resolution Indexing For Out-Of-Core Adaptive Traversal Of Regular Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Valerio Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the NSF/DoE Lake Tahoe Workshop on Hierarchical Approximation and Geometric Methods for Scientific Visualization</title>
		<editor>G. Farin, H. Hagen, and B. Hamann</editor>
		<meeting>the NSF/DoE Lake Tahoe Workshop on Hierarchical Approximation and Geometric Methods for Scientific Visualization<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>to appear)., 2002. (Available as LLNL technical report UCRL-JC-140581</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tetrahedron Based, Least Squares, Progressive Volume Models With Application To Freehand Ultrasound Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Roxborough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization</title>
		<editor>T. Ertl, B. Hamann, and A. Varshney</editor>
		<meeting>Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="93" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Semi-Regular Mesh Extraction From Volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zoë</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathieu</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Desbrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Breen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>T. Ertl, B. Hamann, and A. Varshney</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="275" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Paralel And Out-Of-Core View-Dependent Isocontour Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vijaya Ramachandran Xiaoyu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandrajit</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bajaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint Eurographics -IEEE TCVG Symposium on Visualizatation (VisSym-02)</title>
		<editor>David Ebert, Pere Brunet, and Isabel Navaz</editor>
		<meeting>the Joint Eurographics -IEEE TCVG Symposium on Visualizatation (VisSym-02)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Multiresolution Tetrahedral Framework For Visualizing Regular Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baoquan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
