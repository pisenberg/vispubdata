<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">XFastMesh: Fast View-dependent Meshing from External Memory</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Decoro</surname></persName>
							<email>cdecoro@uci.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Computer Graphics Lab Information</orgName>
								<orgName type="institution">Computer Science University of California</orgName>
								<address>
									<settlement>Irvine</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
							<email>pajarola@acm.org</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Computer Graphics Lab Information</orgName>
								<orgName type="institution">Computer Science University of California</orgName>
								<address>
									<settlement>Irvine</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">XFastMesh: Fast View-dependent Meshing from External Memory</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: I.3.3 [Computer Graphics]: Image Generation-Display Algorithms I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-Surface and Object Representations E.5 [Files]: Organization/Structure-[H.3.2]: Information Storage and Retrieval-Information Storage level-of-detail</term>
					<term>multiresolution modeling</term>
					<term>out-of-core rendering</term>
					<term>interactive large-scale visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present a novel disk-based multiresolution triangle mesh data structure that supports paging and view-dependent rendering of very large meshes at interactive frame rates from external memory. Our approach, called XFastMesh, is based on a view-dependent mesh simplification framework that represents half-edge collapse operations in a binary hierarchy known as a merge-tree forest. The proposed technique partitions the merge-tree forest into so-called detail blocks, which consist of binary subtrees, that are stored on disk. We present an efficient external memory data structure and file format that stores all detail information of the multiresolution triangulation method using significantly less storage then previously reported approaches. Furthermore, we present a paging algorithm that provides efficient loading and interactive rendering of large meshes from external memory at varying and view-dependent level-of-detail. The presented approach is highly efficient both in terms of space cost and paging performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With the rapid advances in 3D scanning technology, it has become possible to generate geometric models much larger than the capacity of physical main memory (see <ref type="bibr" target="#b11">[12]</ref>). Therefore, rendering these models with standard level-of-detail (LOD) approaches and in-memory multiresolution frameworks causes uncontrolled paging of the operating system's virtual memory manager that negatively affects the interactive display. In order to use traditional polygonal methods to render such large objects and surfaces at interactive frame rates, we require:</p><p>1. an efficient view-dependent multiresolution triangulation and rendering framework that can be dynamically modified, and 2. support for rendering from external memory which includes paging of view-dependent LOD mesh data from disk.</p><p>External-memory algorithms and data structures <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> present a unique set of challenges not encountered in traditional mainmemory techniques. Some efforts have been made in scientific visualization to develop external-memory algorithms (see abstract million polygons. The model is shown as simplified with XFastMesh. The full-quality (within view frustum) smooth-shaded model is shown on the left, and the wire-framed, flat-shaded image on the right is shown to display the simplification. The view frustum is focused on the head and upper body. <ref type="bibr" target="#b17">[18]</ref>). In real-time LOD rendering of large polygonal meshes from external memory the main challenges are related to maintaining and synchronizing two separate datasets: the in-memory triangle mesh data structures, and the on-disk data.</p><p>In this paper we present XFastMesh, a system which allows efficient view-dependent rendering of very large triangle meshes from external memory, such as Michaelangelo's statue of David as shown in <ref type="figure" target="#fig_0">Figure 1</ref>, which consists of 8.25M polygons. The system's inmemory view-dependent rendering method is based on FastMesh <ref type="bibr" target="#b18">[19]</ref>, however, incorporates substantial changes to dynamically update the main memory mesh data structures. Additionally, the main contribution of XFastMesh is an external memory data structure (XFM file format) and paging algorithm that supports efficient loading of mesh data from disk at different LODs.</p><p>The remainder of the paper is organized as follows. In Section 2 we review closely related work and preliminary background. Section 3 describes the external memory data structures and file format, and Section 4 explains the in-memory data structures and rendering algorithm. Section 5 provides experimental results and Section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">View-dependent Meshing</head><p>Several view-dependent mesh simplification and rendering methods have been proposed in the literature so far. The approaches presented in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref> and <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref> are based on a binary vertex hierarchy derived from iteratively simplifying the input mesh by edge collapse operations <ref type="bibr" target="#b7">[8]</ref>. Nodes of this hierarchy are collapsed or refined for each rendered frame based on view-dependent error metrics such as projected edge length or approximation error. The triangle mesh is dynamically updated and rendered according to changes in the hierarchy.</p><p>Generalized view-dependent rendering frameworks based on arbitrary vertex hierarchies are presented in <ref type="bibr" target="#b15">[16]</ref> and <ref type="bibr" target="#b21">[22]</ref>. While not optimized for storage cost or rendering performance these generic approaches support a wide range of simplification operations. The method presented in <ref type="bibr" target="#b2">[3]</ref> is based on simple vertex insertion and removal operations and provides a compact representation, however, at the expense of mesh update and rendering performance.</p><p>Specialized view-dependent terrain triangulations based on height-field models are presented in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14]</ref> and <ref type="bibr" target="#b9">[10]</ref>. Besides <ref type="bibr" target="#b9">[10]</ref>, these approaches take advantage of the regular grid structure of elevation data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Out-of-core Mesh Simplification</head><p>Only recently, research in multiresolution modeling has concentrated on out-of-core mesh simplification. The methods presented in <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15]</ref> and <ref type="bibr" target="#b22">[23]</ref> provide efficient simplification of very large meshes on external memory using vertex clustering. However, these methods do not provide a multiresolution triangle mesh structure for efficient view-dependent rendering nor do they support paging from disk.</p><p>The approach presented in <ref type="bibr" target="#b4">[5]</ref> presents the first method for outof-core triangle mesh simplification and view-dependent rendering with different LODs from external memory. Additionally, this method provides an out-of-core preprocess that could also be used by our approach to generate an edge-collapse hierarchy. Compared to <ref type="bibr" target="#b4">[5]</ref> our approach is significantly better in terms of storage cost and rendering performance as shown in the experimental results section. In <ref type="bibr" target="#b19">[20]</ref> a progressive mesh approach is presented which is based on mapping a set of array ranges of the entire progressive mesh sequence into contiguous virtual memory. No rendering performance results are reported in <ref type="bibr" target="#b19">[20]</ref> and loading detail information from disk reportedly causes rendering pauses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">FastMesh</head><p>The concepts of view-dependent meshing and rendering of XFastMesh are based off the FastMesh method <ref type="bibr" target="#b18">[19]</ref>. FastMesh is a real-time view-dependent progressive meshing system based on a hierarchy of edge collapse operations similar to <ref type="bibr" target="#b25">[26]</ref> and <ref type="bibr" target="#b8">[9]</ref>. FastMesh is different from other approaches in its use of an efficient half-edge data structure to represent the triangle mesh and the simplification operations. This allows for compact representation and efficient mesh updates. An edge is represented by two reversely directed half-edges. Each triangle is represented by its three counter-clockwise oriented half-edges as shown in <ref type="figure" target="#fig_6">Figure 2</ref>. As shown in <ref type="bibr" target="#b23">[24]</ref>, a directed half-edge h contains a reference to its start vertex hvertex, information on its previous hprev and next hnext half-edges within the same triangle, and its reverse half-edge hrev in the adjacent triangle.</p><p>With merge tree forest we refer to the binary half-edge collapse hierarchy of FastMesh <ref type="bibr" target="#b18">[19]</ref>. As shown in <ref type="figure">Figure 3</ref>, a particular LOD triangulation is defined by an active front through the merge <ref type="figure" target="#fig_6">Figure 2</ref>: An edge collapse removes a vertex and two faces from the mesh, which are reintroduced by its dual vertex split. In this example, the halfedge A is collapsed, removing half-edges A through F. W, X, Y, Z are considered adjacent to the removed half-edges, and remain in the mesh after the collapse.</p><p>tree forest which represents all nodes that are subject to collapse or split operations. At run-time this front is traversed and updated according to view-dependent error metrics for each frame, and the corresponding triangle mesh is rendered. The view-dependent error metrics used in XFastMesh are largely identical to <ref type="bibr" target="#b18">[19]</ref> and require two parameters to be stored with each node in the merge tree forest, the bounding sphere radius and bounding normal cone opening angle. Given a collapsed half-edge h by its index i h , a vsplit operation must update the mesh connectivity to include the two triangles originally incident upon h. Note that the entries in the half-edge table for these two triangles have not been altered after collapsing h, and the incident faces A, B, C and D are valid faces in the current mesh as shown in <ref type="figure">Figure 3</ref> on the right (see also preconditions on ecol and vsplit operations in Section 3.3). Therefore, for triangles A and B the connectivity can be restored by reverse-edge reassignments:</p><p>Similarly triangles C and D can efficiently be updated. Furthermore, all half-edges incident on the split-vertex, and between and including triangles A and C that currently used h.n.v as a start vertex, now have to be reassigned to h.v. Note that h.v is indeed the correct start vertex because nothing has been changed for h since its collapse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Vertex hierarchy</head><p>Conceptually, a sequence of ecol operations computed during a preprocessing step defines a binary hierarchy as shown in [XV96] and [Hop97], and a view-dependent mesh is defined by a front through this hierarchy. However, the hierarchy in FastMesh differs significantly in implementation and semantics from these previous approaches.</p><p>To reduce storage cost, FastMesh defines the hierarchy H on halfedge collapses since the leaf nodes of a vertex hierarchy do not carry any information required for collapsing an edge or splitting a vertex. Thus H requires only half as many nodes as the vertex based representations. Furthermore, this half-edge collapse hierarchy as shown in <ref type="figure" target="#fig_1">Figure 4</ref> is implemented as a separate binary tree data structure, not merged with the vertex data, and only stores additional information per node that is required for the view-dependent error metrics. A node consists of pointers to a parent node t.p, left t.l and right t.r child nodes, and an index t.i h of a collapsed edge h, plus two scalar values to compute the view-dependent error metrics (see also Section 4). This definition of the binary half-edge collapse hierarchy H com-F 1 ), or that must be checked for mesh refinement (nodes of F 2 , and all child nodes of F 1 ,</p><p>). At run-time, for every change in view parameters the front F is traversed and updated. First, nodes F 1 are tested to be collapsed. Second, all nodes F 2 and children C F1 of F 1 are tested to be split. All simplification and refinement operations have to be tested at run-time first to be legal as described in the following section, since they are performed outof-order with respect to their global ordering at initialization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Preconditions</head><p>A set of consecutive ecol operations can collapse multiple vertices to one vertex. Such a set of ecol operations forms a subtree in our half-edge collapse hierarchy, and must be performed bottom-up in correct partial order. An ecol operation is uniquely defined by an index i h into the halfedge table, and any half-edge h that by collapsing may cause a topological singularity is not a legal half-edge collapse. A half-edge h is considered to be illegal if there exists a vertex V that is adjacent to both endpoints P and Q of h, and for which the three connected vertices P, Q, and V are not a triangle in the current mesh as shown in <ref type="figure" target="#fig_3">Figure 6</ref>. Therefore, the half-edge h referenced from a node t is a legal candidate for an ecol operation only if:</p><p>1. no descendants of t have to be collapsed first, 2. and h is a topologically correct half-edge collapse. Precondition 1 for ecol operations is satisfied by our definition of the front F of active nodes, and its subset F 1 that is tested for collapsing. Precondition 2 can be tested efficiently at run-time by examining the set of vertices V and edges e incident upon the endpoints of h. Condition 2 <ref type="figure">Figure 3</ref>: An example merge tree forest, with the current front represented by the dashed line. This active front represents the current level of detail, and can be moved up (lower detail) and down (higher detail) as the situation requires.</p><formula xml:id="formula_0">h. p.r .rh . p = h . n . r . rh . n = tH ∈ v 2 v 1 v 3 v 2 v 2 v 3 v 1 v 2 v 4 v 3 v 4 v 5 v 4 v 5 a) vertex hierarchy b) half-edge collapse hierarchy H h 1 h 2 h 3 h 4 h 1 h 2 h 3 h 4 C F 1 tp t . p ≡ pF 1 ∈ ∧ {} = h 9 h 5 h 10 h 11 h 13 h 8 h 7 not collapsed half-edges h 12 h 6 h 14 h 1 h 2 h 3 h 4 collapsed half-edges front F of active nodes F h P Q V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXTERNAL-MEMORY STRUCTURES</head><p>The external-memory layout of XFastMesh is designed to minimize space usage while attempting to store all related information together on disk, thereby minimizing the amount of disk accesses required to render a scene. Especially given that most external memory devices, such as hard disk drives, are block devices and read information in blocks of data, we break the XFastMesh data structures into logically-grouped blocks to take advantage of this fact. The XFastMesh file format (XFM) as shown in <ref type="figure" target="#fig_1">Figure 4</ref> contains the following data fields: 4. Block index table, which provides the offset and length of each detail block in the file. Because we use a variable length block size, we cannot determine detail block positions in the file implicitly from the block numbers, and use the block index for this purpose.</p><p>5. Detail blocks, which comprise the majority of the file, and contain information for LODs, including vertex coordinates and edge split/collapse information. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Initial faces and vertices</head><p>Detail information such as vertex and normal coordinates are generally stored on disk with the merge tree node that will introduce the corresponding vertex into the mesh by means of a vertex split.</p><p>Each vertex split inserts one vertex and two triangles into the mesh as shown in <ref type="figure" target="#fig_6">Figure 2</ref>. Because the faces and vertices in the coarsest mesh, referred to as initial faces and vertices, are not created by any vertex splits, they must be stored separately in the file. For these, the data file contains a list of vertex coordinates, their associated normal vectors, and triangle faces as specified in the file header. This information is used to generate the initial coarse mesh on system initialization. These initial faces and vertices will be kept in main memory during system run time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Root block list</head><p>On system initialization, the algorithm will load the blocks corresponding to the root nodes of the merge tree forest, in order to set up the initial active front. To identify these nodes and their corresponding detail blocks efficiently, the file stores a list of all root blocks, those blocks that contain the root nodes of the merge tree forest. The system reads this list on startup and loads the specified blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Block index</head><p>The primary purpose of the XFastMesh data file is to store a large number of detail blocks (see Section 3.4) which contain information for different LODs. Each detail block is identified by a numerical index, and the algorithm will use this index to locate blocks on disk. For space efficiency reasons, detail blocks do not have a fixed size and thus cannot be located on disk using implicit position information only. Instead we keep a fixed table, referred to as the block index I, that lists the on-disk location and the length of each block, which are represented with two scalars per block. This block index table is accessed by every block load operation to find the block location on external memory. Because this table is fixed in size, immutable, and usable directly in its on-disk storage format, we access the table by mapping the corresponding data of the file into virtual memory using the file memory-mapping capability (such as the mmap function under UNIX). Alternatively, since the block index is sufficiently small it can be loaded entirely into main memory without causing undue space overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Detail blocks</head><p>The primary units in the XFastMesh data file are referred to as detail blocks. Each detail block contains the information required to describe a complete subtree of the merge-tree forest. Thus the binary merge-tree hierarchy is regularly partitioned into binary subtrees as shown in <ref type="figure" target="#fig_2">Figure 5</ref>.</p><p>Within each detail block, explicit links between nodes are minimized using an array representation of the complete binary subtree. Tree nodes are numbered and stored in a breath-first ordering such that given the index i of a particular node, the parent node can be found at position (i − 1)/2, and the left and right child nodes at i • 2 + 1 and i • 2 + 2 respectively. This detail-block tree structure allows us to store 2 l − 1 tree nodes per block, where l is number of levels in the binary subtree.</p><p>Each detail block in the tree contains the same number of nodes. The value of l is user specified; in the current implementation, l = 4 has shown efficient results. Lower values for l allow for finer granularity in memory allocation, at the expense of more frequent loading of small detail blocks. The nodes in each block are numbered such that the block number is b = n/2 l for a given node n. Block 0 contains the root node of its tree and thus is a root block. Its index stored in the file's root list, as described in 4. An optional array C containing indices of child blocks (if not a leaf block).</p><p>XFastMesh can use the complete subtree structure of a block to implicitly represent intra-block links between nodes within the same detail block. However, the parent-child relationships between blocks, called inter-block links, must be explicitly stored in each block. Each detail block stores the index of its parent node, as well as the indices of each of its 2 l+1 child nodes.</p><p>In a simple implementation of detail blocks that consist of complete binary trees, significant storage space is wasted for leaf blocks that are not full (not all available nodes are used). To resolve this internal fragmentation, the nodes of each block are fully packed as shown in <ref type="figure" target="#fig_3">Figure 6</ref>. Each block contains a 8-16-or 32-bit flag (for l = 3, 4, 5, respectively) that indicates which nodes are present in this block. The loading algorithm uses this information to properly reconstruct the incomplete binary subtree in main memory. Additional efficiency issues are related to the fact that a block tree has a large fan-out (a block with l = 4 has 8 nodes in the lowest level, and thus 2 l = 16 child blocks). For shallow and unbalanced merge-tree hierarchies this results in a large ratio of leaf to nonleaf blocks. The space used to store the array of child pointers C is wasted in each leaf block since there are no child blocks to reference. Thus with a large percentage of leaf blocks, storing child pointers in every one of these would result in a significant amount of storage overhead. We avoid storing these child pointers by using the high-order bit of a block's flag-set to indicate whether or not that block is a leaf. Thus we store the array C of child block indices only for non-leaf blocks.</p><p>The most significant data field in a detail block is the array N of merge-tree nodes. For each particular node n ∈ N and its corresponding half-edge h, we store the following information: Each node in a detail block consumes 52 bytes. Potentially, this can be reduced to under 36 bytes by quantizing the normal, bounding cone, and bounding radius as in QSplat <ref type="bibr" target="#b20">[21]</ref>, and removing the global ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Data file construction</head><p>The XFastMesh data file is generated in a preprocess from a given set of half-edge collapse operations that define a binary merge-tree forest. The details of generating such a progressive mesh simplification are independent of XFastMesh which focuses on creating the out-of-core data structures. A progressive mesh simplification using edge collapses can be constructed in various ways (for references see <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17]</ref>). The procedure for creating the data file is as follows:</p><p>1. Create the merge tree hierarchy from the input data 2. Collapse mesh into the lowest resolution configuration <ref type="bibr" target="#b2">3</ref>. Write all present vertices and faces into the file as initial vertices and initial faces 4. Traverse the tree in depth-first order and renumber the halfedges corresponding to each node such that for a node numbered n, its corresponding block b = n/(2 l − 1) (further described in Section 4).</p><p>5. Again traverse the tree in depth-first order, writing each block out to the data file, and storing its block-index table entry.</p><p>6. Write the block-index table to the file 7. Determine the block numbers of each root block; write the root list into the file A key point is that the algorithm must traverse the tree twice: before writing the blocks to disk, it must renumber the nodes in the blocks so as to achieve an implicit relationship from a node to its corresponding block. Once the nodes have been renumbered, they can be written to the file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MAIN-MEMORY STRUCTURES</head><p>Previous mesh simplification systems assume that the dataset will fit entirely in memory, allowing all data structures to be allocated up-front and stored in arrays. This has the benefit of allowing constant time indexing and access to edges or tree nodes.</p><p>In order to avoid allocating all the required memory at once, but maintaining the ability to perform constant time indexing, we use a page-table-like structure to organize data as shown in <ref type="figure" target="#fig_10">Figure 7</ref>. This structure, known as the detail block directory D stores pointers to all loaded detail blocks. Furthermore, this indirect indexing structure allows us to easily add and delete blocks at run-time.</p><p>Constant-time indexing of nodes and half-edges is achieved by using a consistent numbering for the blocks and half-edges, as if each block were full. Therefore, for 2 l − 1 nodes per block, the global number of the first node in this block modulo 2 l − 1 is equal to 0, as was shown in <ref type="figure" target="#fig_2">Figures 5 and 6</ref>. Each vertex split operation creates two triangle faces, and so each node corresponds to six halfedges. Therefore, with m = 6 • (2 l − 1) of half-edges per block, the number of the first half-edge in this block modulo m is equal to 0. Given a half-edge number h, we can compute its block number b = h/m, and its offset as h modulo m. This numbering is consistent for all blocks, even for blocks that are not full.</p><p>During runtime, XFastMesh will need to access a particular node based only on its index n. To find this node, we need to compute the block number n block = n/(2 l − 1) of this node, and the offset n of f set = n modulo (2 l − 1) of the node within the block. The node n can then be accessed as D</p><formula xml:id="formula_1">[n block ][n of f set ].</formula><p>For faster implementation, we can number each block as if the number of tree nodes it contains is an even power of two. This allows us to use shifts and bitmasks to substitute the more expensive division and modulo operations. Essentially, we assign a certain number of bits to identify the block, and the remaining bits to identify the offset within the block. This technique is much faster than the hashing used in other external memory methods <ref type="bibr" target="#b4">[5]</ref>.</p><p>The choice of l, the number of levels per block, affects the size of the directory. Smaller values of l will result in more blocks, and require more entries in D; conversely, larger values of l will result in less blocks and a smaller memory footprint for D. Because the directory is always stored in main memory, a memory-limited system might choose a large value of l to reduce this fixed memory overhead.</p><p>Once a detail block has been loaded from disk, it is inflated into its full main-memory representation. We copy most of the basic fields from the on-disk representation. Additionally, we create a set of half-edges to represent the faces, with each half-edge containing a pointer to its corresponding start vertex, and the number of its reverse half-edge. In the on-disk representation we only store the four reverse half-edges w, x, y, z adjacent to the two faces of a node, as shown in <ref type="figure" target="#fig_6">Figure 2</ref>. In the main-memory representation, we use this information to re-create all six half-edges. While the disk representation uses the implicit complete tree representation to store node connectivity (intra-block links), we explicitly store parent, left and right pointers for each node in main memory, as well as left and right child block numbers for efficiency. <ref type="figure" target="#fig_10">Figure 7</ref> illustrates the structure of detail blocks as used in main memory. For each in-memory tree node n, and its associated halfedge h, XFastMesh contains the following information and uses a total of 108 bytes per node: As each node corresponds to a vertex, there are roughly as many nodes as there are vertices in the input mesh. Therefore, we can conclude that XFastMesh uses 108 bytes per vertex in main memory, plus some small overhead for the fixed directory structure. We use 4 bytes per block in the block index directory, to store a pointer to the particular detail block. We also store 4 bytes per block for a timestamp, which is used for block caching and removal as discussed in Section 4.2. As in the out-of-core data structure discussed in Section 3.4, we can encode certain values more efficiently through quantization if necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Block loading</head><p>For interactive rendering, the system requests blocks from disk in two different situations at run-time:</p><p>1. When the front of active nodes moves down the tree, requiring more detail.</p><p>2. When a split operation on a node causes a forced split of other nodes. For each frame, the algorithm will test each node in the active front, to determine if it should be split or collapsed. If it has to be split, the traversal will recursively descend the tree to test child nodes. As it descends, it will reach the frontier of the loaded blocks, the lowest blocks currently loaded into the tree, and will trigger the first case. The data structure indicates these frontier nodes by setting the n.lef t and n.right pointers of the node n to null, while setting the n.lblock and n.rblock values to the actual child block index. Once the algorithm detects this case, it will load both the left and right child blocks into memory, and continue.</p><p>Alternatively, a node split operation may cause a forced split, in which a node from another part of the merge-tree forest must be split first, and its information loaded from disk. A forced split is detected by the absence of any face referenced by the reverse halfedges of a, b, c, d in <ref type="figure" target="#fig_6">Figure 2</ref>, and it causes the insertion of this face into the triangle mesh by the corresponding node split. In this case, the algorithm will use the numerical index of the face to determine which block to load, and recursively load the ancestors of this block until that subtree can be connected to the existing hierarchy in main memory. This requires that for a given block b, we must determine the index of the node n that is the parent of b, such that n.lef t = b.root or n.right = b.root. We store this index of a block in b.parent, and we use the directory structure to access the node, and link the new block into the existing hierarchy. If the directory entry for the block containing n, D[n block ], is null, then we must recursively load this block and its ancestors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Block deletion</head><p>In order to avoid loading a block from disk every time it is used, XFastMesh caches blocks using a least-recently-used (LRU) strategy. Each currently loaded block is given a timestamp that indicates the last frame in which it was part of the active front as shown in <ref type="figure" target="#fig_10">Figure 7</ref>.</p><p>XFastMesh makes use of two quotas that determine its memory usage. The soft quota, qs is a suggestion to the system to remove the least recently used blocks once the total number of loaded blocks b loaded has exceeded qs. XFastMesh will begin removing blocks as soon as b loaded &gt; qs, but if the quota does not allow for enough blocks to achieve the specified view-dependent LOD threshold, it will load additional blocks as required and exceed the quota.</p><p>In contrast, the hard quota, q h is a set limit on the number of loaded blocks. Once XFastMesh has reached its hard quota, it will</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Storage Requirements</head><p>As shown in <ref type="table" target="#tab_1">Table 1</ref>, the XFastMesh data files are very efficient; the Stanford Bunny model represented in XFM format uses 2.04 MB, versus 3.03 MB for the original (ASCII) PLY file. Note that the indexed face representation of the PLY format does not include any multiresolution triangle mesh or view-dependent rendering information whatsoever. XFastMesh is approximately 350% more efficient than the implementation of external-memory rendering framework proposed in <ref type="bibr" target="#b4">[5]</ref> (VDT) which uses 7.1 MB for the same model. With only about 60 bytes per vertex, XFM is also more efficient than the file based FastMesh format (FM) <ref type="bibr" target="#b18">[19]</ref>, the view-dependent progressive meshes of <ref type="bibr" target="#b8">[9]</ref>, or the multitriangulation approach <ref type="bibr" target="#b2">[3]</ref>.</p><p>Much of this storage efficiency can be credited to packing incomplete blocks as described in Section 3.4. For the horse model, with 97K faces, XFastMesh generates 12231 blocks, with l = 4. Each block could potentially store 2 l − 1 = 15 nodes. If the blocks were completely filled, we would have about 6600 blocks. It follows that the 12231 blocks are only about half full, therefore, the packed storage scheme saves approximately 50% the storage cost of the unpacked scheme. Removing unnecessary child pointers also proved to save a significant amount of disk storage. From experimental results, the horse model, which uses 2.84 MB without unnecessary child pointers, previously used over 3.5 MB, an increase of about 25%. For that particular model, testing showed that out of 12231 total blocks 10358 were leaf blocks (or about 85%).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Runtime Costs</head><p>Before rendering a mesh, XFastMesh first must preprocess the input mesh in order to build the merge-tree forest similar to <ref type="bibr" target="#b18">[19]</ref> (FM), and then create the XFM file. Creating the XFM file adds only minor overhead to the preprocess, as seen in <ref type="table" target="#tab_3">Table 2</ref>.</p><p>Rather than use a greedy approach to selecting edge collapses, XFastMesh iteratively selects the largest independent sets of edge collapses. Because of that XFastMesh does not need to constantly re-sort the list of edge collapses, as other techniques do using a heap structure, which would result in an O(n lg n) running time for the preprocess. Instead, because XFastMesh only needs to sort the list some constant number of time, the number of iterations, and all of the keys, the approximation error values, are scalar numbers, XFastMesh can use a linear-time radix sort. Therefore, the running time of the preprocess is O(n), where n is the number of triangles in the input mesh. Note that the one exception to the linear time growth is the david model, in which case the system is forced to page in memory.  At rendering time, because of the use of external memory, XFastMesh is able to load into main memory only the data needed at any given time for a particular viewpoint and error tolerance. This also results in extremely quick start-up times for viewing an initial coarse representation of the displayed mesh. Even for the largest of our test meshes, the David statue, our application only requires a couple of seconds to load the coarsest mesh, initialize the merge tree forest and display the first frame.</p><p>To determine the runtime performance of XFastMesh, we rendered each of our models, with the viewpoint moving on a fixed path. The screen-error tolerance was set to 0.02. This tolerance controls the view-dependent mesh simplification according to the screen-space error metric as described in <ref type="bibr" target="#b18">[19]</ref>. The soft quota was set to qs = 10%.</p><p>In <ref type="table" target="#tab_5">Table 3</ref>, we display the per frame timing in milliseconds for each of the basic tasks performed by XFastMesh, as exhibited on our test models. We recorded the timing using the high-resolution timer functionality provided by the Solaris operating system. These tasks include:</p><p>• View tests, performed on each node to determine if it should be split or collapsed (column VT)</p><p>• Mesh updates, which reconfigure the mesh through either edge collapses or vertex splits (column U)</p><p>• Block loading, loading a block from disk and converting it to its main-memory representation (column BL)</p><p>• Rendering of the selected triangle mesh (R)</p><p>The <ref type="table" target="#tab_5">Table 3</ref> also displays the average number of triangles shown per frame (#Shown) and the average number of updates performed per frame (#U). The results show that XFastMesh is very efficient, and scales well to large meshes.   <ref type="figure" target="#fig_0">Figure 10</ref> provides several examples of a large model rendered at interactive frame rates with XFastMesh. The error tolerance was configured to adjust automatically to match a specific target frame rate; in this case, the target was set to 5 frames/second to achieve high-quality images while maintaining interactive rendering. The figure demonstrates the high-detail view from the user's perspective, as well as showing the entire mesh to demonstrate the effectiveness of the simplification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>In this paper we presented efficient algorithms and data structures for out-of-core multiresolution meshing and view-dependent rendering. Our approach called XFastMesh provides a very efficient representation of the multiresolution triangle mesh on external storage, requiring only about 60 bytes per vertex. This out-of-core data structure allows for efficient view-dependent retrieval and paging of triangle mesh data and supports interactive rendering of large-scale meshes. Our in-memory multiresolution mesh data structure allows for paging mesh update information from disk. This changes dynamically at run-time, and supports fast view-dependent mesh refinement and rendering. Experiments on a variety of triangle meshes have shown the efficiency of our approach in terms of space cost (size of data structure) and rendering performance (including paging from disk).</p><p>XFastMesh currently does not include an out-of-core preprocess to generate the XFM format but relies on doing that off-line for a particular data set on a machine with sufficient virtual memory. With the target of the XFM file format, future work will address the issue of efficient out-of-core generation of the multiresolution mesh simplification hierarchy. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A model of Michaelangelo's David statue, comprising over 8.25</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIGURE 4 .</head><label>4</label><figDesc>Binary half-edge collapse hierarchy H.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 5 .</head><label>5</label><figDesc>Front F of the current view-dependent mesh through the binary half-edge collapse hierarchy H.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIGURE 6 .</head><label>6</label><figDesc>Topological ecol constraint. Half-edge h cannot be collapsed because of P and Q being connected to V.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>XFastMesh external memory structure. The block number and offset of a node are determined from its index. The block index table is used to determine the offset of a block within the file. Note that the Block Index is stored as part of the file, but is accessed as a memory-mapped file, rather than with explicit I/O commands.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Detail block tree structure of a 4-level merge tree, with l = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Section 3. 2 A</head><label>2</label><figDesc>given detail block b consisting of l levels of a binary tree, contains the following fields:1. A set of flags to indicate if the block is a leaf block, and to indicate which nodes are present in this block. 2. Index of the parent block of b. 3. A variable-length array N of merge-tree nodes, with |N | ≥ 1 and |N | ≤ 2 l − 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>A partially filled detail block (unused nodes displayed in dashed outline) can be packed in order to use less space, using bitflags to identify which nodes are present.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>1 . 4 .</head><label>14</label><figDesc>Vertex coordinates for h.vertex (12 bytes) 2. Normal vector coordinates for h.vertex (12 bytes) 3. Bounding-sphere radius and sine of bounding normal cone angle (as described in [19]) (8 bytes) The indices w, x, y, z (from Figure 2) of the four half-edges adjacent to the two triangles introduced by expanding h (16 bytes) 5. (Optional) Index of n in the global ordering of edge collapses (used for fold-over prevention, 4 bytes)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1 .</head><label>1</label><figDesc>Pointers to the parent, left and right children of n in the merge tree (12 bytes) 2. Vertex coordinates for h.vertex (12 bytes) 3. Normal vector coordinates for h.vertex (12 bytes) 4. Bounding-sphere radius and sine of bounding normal cone angle (8 bytes) 5. Global index of h (4 bytes) 6. Left (lblock) and right (rblock) child block indices (8 bytes) 7. Six half-edges (including h) representing two faces; each half-edge contains a vertex pointer and the index of its reverse (8 bytes each; 48 bytes total) 8. (Optional) Index of n in the global ordering of collapses (used for fold-over prevention, 4 bytes)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Main memory structure of XFastMesh, for l = 4. Once block number and offset are determined from a node index, XFastMesh uses the Directory to find the individual detail block. Each directory entry may point to an individual detail block. Each detail block will have a corresponding entry in the time priority queue used for caching and paging.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 :</head><label>10</label><figDesc>Four renderings of Michaelangelo's David statue, taken at high-quality settings with the error tolerance set to achieve rendering times of approximately 5 frames/second. The top row shows the view from the user's perspective; the bottom row shows the same scene outside the user's view frustum, which is represented by a yellow pyramid. From left to right, the error tolerance τ and number of triangles ∆ are: (head) τ = .00728 ∆ = 67092, (chest) τ = .00260 ∆ = 69428, (legs) τ = .00559 ∆ = 50828, (back) τ = .00337 ∆ = 67356</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>File sizes in megabytes for various models. The table displays the number of faces in each model, and the size of file in megabytes for source ASCII format (PLY), FastMesh format (FM), XFastMesh format (XFM) and in the external-memory format as presented in<ref type="bibr" target="#b4">[5]</ref> (VDT).</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Preprocessing times in seconds for various models. The basic view-dependent simplification preprocess is shown as FM, the preprocess plus the external file creation step is shown as XFM</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Runtime performance measures for the basic operations in XFastMesh. The numbers shown are the average number of faces and updates per frame, and the time cost per frame of updates, view-tests, block loading and rendering in milliseconds.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">. Fixed-size file header, which describes the position and length of other data fields 2. Initial vertex coordinates and face information; those vertices and faces that are present in the coarsest mesh, and are not introduced by any vertex split operation.3. Root list, which lists the blocks containing the root nodes of the merge tree forest.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">EXPERIMENTAL RESULTSAll benchmark testing was performed on a Sun Microsystems Ul-tra60 workstation, with the Solaris 8 operating system, running at 450MHz. The amount of RAM usable to the application is set by the hard quota q h .</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">http://www-graphics.stanford.edu/data/3Dscanrep/ 2 http://cc.gatech.edu/projects/large models/ 3 http://www.cyberware.com</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We would like to thank the UC Irvine UROP program for providing funding for this research. We would also like to thank the Stanford Computer Graphics Lab 1 , the Georgia Tech Large Geometric Models Archive 2 and Cyberware 3 for providing freely-available highresolution geometric models.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="figure">Figure 8</ref><p>: XFastMesh update algorithm. We analyze each node in the active front, and test to see if the front should be moved up or down. We assume that view-test is a function that takes a merge-tree node as input, and returns as output whether or not that node should be split. split-node and collapse-node are functions that perform their respective split or collapse operations on their input node. not load additional blocks until more storage has been made available.</p><p>This design allows for flexibility in memory allocation. To force the system to always remove unused blocks, set qs = 0. To keep all blocks until a set limit is reached, set qs = q h . To always load blocks as needed, the hard quota can be disabled by setting q h = ∞. Note that qs cannot be set higher than q h .</p><p>Candidates for block removal are only detail blocks whose nodes are all below the active front (see also <ref type="figure">Figure 3</ref>). For these blocks, their root nodes are collapsed and the siblings of those nodes are also collapsed. The node m is a sibling of node n if m.parent = n.parent. At run-time, when a node is collapsed, the system checks to see if this condition is met. If so, its block is timestamped with the current time, based on the number of frames rendered, and placed in a minimum priority queue as shown in <ref type="figure">Figure 7</ref>. When nodes are split, their corresponding blocks and their siblings are removed from the priority queue since they are no longer candidates for removal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Mesh update</head><p>The mesh update operation consists of two steps, shown in <ref type="figure">Figure 8</ref>. First, the algorithm traverses the active front, performing a test on each node to determine if that node should be split or collapsed (see <ref type="bibr" target="#b18">[19]</ref> for details on that test operation). The algorithm will descend the tree recursively as needed. Secondly, once the algorithm has determined that a merge tree node should be modified, it will perform the split or collapse operation on that node. As the algorithm descends the tree, it will eventually reach the frontier of the loaded blocks. At this point, the algorithm will determine if the frontier nodes have additional child blocks, and if so, it will load those blocks into memory, connect them into the tree, and continue recursively testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Rendering</head><p>A given XFastMesh configuration has two types of triangle faces that it must render:</p><p>1. Initial faces, which are part of the coarsest mesh and never removed, are loaded at system start. All faces are stored as a sets of half-edges, with a face defined as a set of three consecutive half-edges. The half-edges of the initial faces are stored separately from those of the detail faces, in a fixed array. The rendering algorithm proceeds through this array, rendering each of the initial faces from their constituent half-edges.</p><p>In contrast, the detail faces are stored in the dynamic merge tree structure, with each node in the merge tree containing six halfedges, corresponding to two faces. Detail faces are rendered by recursively traversing the merge tree forest top-down, and drawing the two triangles that correspond to each node that is split. The rendering algorithm is shown in <ref type="figure">Figure 9</ref> </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">External Memory Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>American Mathematical Society</publisher>
			<pubPlace>Providence, R.I.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Efficient External-Memory Data Structures and Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Aarhus (Denmark</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient implementation of multitriangulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization 98</title>
		<meeting>IEEE Visualization 98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Roaming terrain: Real-time optimally adapting meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization 97</title>
		<meeting>IEEE Visualization 97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">External memory view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings EUROGRAPHICS 2000</title>
		<meeting>EUROGRAPHICS 2000</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="139" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generalized view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings EUROGRAPHICS 99</title>
		<meeting>EUROGRAPHICS 99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="83" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Survey of polygonal surface simplification algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Course Notes 25</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 97</title>
		<meeting>SIGGRAPH 97</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Smooth view-dependent level-of-detail control and its application to terrain rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization 98</title>
		<meeting>IEEE Visualization 98</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Incremental view-dependent multiresolution triangulation of terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Huttner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Pacific Graphics 97</title>
		<meeting>Pacific Graphics 97</meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="127" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The digital michelangelo project: 3d scanning of large statues</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ginzton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ginsberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fulk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 2000</title>
		<meeting>SIGGRAPH 2000</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="131" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Out-of-core simplification of large polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 2000</title>
		<meeting>SIGGRAPH 2000</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="259" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Real-time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">F</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A memory insensitive technique for large model simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="121" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 97</title>
		<meeting>SIGGRAPH 97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A developer&apos;s survey of polygonal simplification algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Luebke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="24" to="35" />
			<date type="published" when="2001-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Large-scale data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="22" to="23" />
			<date type="published" when="2001-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">FastMesh: Efficient view-dependent meshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Pacific Graphics</title>
		<meeting>Pacific Graphics</meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="22" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Progressive meshes for large models of arbitrary topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Prince</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
	<note type="report_type">M.S. Thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Qsplat: A multiresolution point rendering system for large meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 2000</title>
		<meeting>SIGGRAPH 2000</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="343" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Smooth levels of detail</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schmalstieg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schaufler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings VRAIS 97</title>
		<meeting>VRAIS 97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="12" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient adaptive simplification of massive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="127" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Edge-based data structures for solid modeling in curved-surface environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Weiler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="40" />
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Adaptive real-time level-of-detail-based rendering for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="183" />
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dynamic view-dependent simplification for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization 96</title>
		<meeting>IEEE Visualization 96</meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
