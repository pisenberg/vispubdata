<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Computation of the Topology of Level Sets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cole-Mclaughlin</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Center of Applied Scientific Computing</orgName>
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">U.S. Department of Energy by University of California</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Computation of the Topology of Level Sets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.2.1 [Combinatorics]: Combinatorial algorithms-</term>
					<term>F.2.2 [Nonnumerical Algorithms]: Geometrical computations-</term>
					<term>Isosurfaces, Level Set Topology, Betti Numbers</term>
				</keywords>
			</textClass>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>and its augmented version with the Betti numbers of each isosurface. The Contour Tree is a fundamental data structure in scientific visualization that is used to preprocess the domain mesh to allow optimal computation of isosurfaces with minimal overhead storage. The Contour Tree can also be used to build user interfaces reporting the complete topological characterization of a scalar field, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>.</p><p>The first part of the paper presents a new scheme that augments the Contour Tree with the Betti numbers of each isocontour in linear time. We show how to extend the scheme introduced in <ref type="bibr" target="#b2">[3]</ref> with the Betti number computation without increasing its complexity. Thus, we improve on the time complexity from our previous approach <ref type="bibr">[</ref> is the number of tetrahedra and @ is the number of vertices in the domain of improved efficiency. The central part of the scheme computes the output Contour Tree by merging two intermediate Contour Trees and is independent of the interpolant. In this way we confine any knowledge regarding a specific interpolant to an oracle that computes the tree for a single cell. We have implemented this oracle for the trilinear interpolant and plan to replace it with higher order interpolants when needed. The complexity of the scheme is ( 0 )</p><p>2 @ H C P I 3 # 5 © 6 Q @ R 8</p><p>, where I i s the number of critical points of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>. For the first time we can compute the Contour Tree in linear time in many practical cases when</p><formula xml:id="formula_0">I S ¢ % ( 0 ) 2 @ U T W V Y X 8</formula><p>. Lastly, we report the running times for a parallel implementation of our algorithm, showing good scalability with the number of processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Scalar fields are used to represent data in different application areas like geographic information systems, medical imaging or scientific visualization.</p><p>One fundamental visualization technique for scalar fields is the display of level sets, that is, sets of points of equal scalar value. For example, in terrain models isolines are used to highlight regions of equal elevation. In medical CT scans an isosurface can be used to show and reconstruct the separation between bones and soft tissues. The domain of a scalar field is typically a geometric mesh, and the field is provided by associating each vertex in the mesh with a sampled scalar value. If the mesh is a simplicial complex then a piecewise linear function is naturally defined by interpolating linearly, within each simplex, the scalar values at the vertices. If the mesh is a rectilinear grid then a piecewise trilinear function is naturally defined by interpolating, within each cell, the scalar values at the vertices.</p><p>The Contour Tree is a data structure that represents the relations between the connected components of the level sets in a scalar field. Two connected components that merge together (as one continuously changes the isovalue) are represented as two arcs that join at a node of the tree. The pre-computation of the Contour Tree allows one to collect structural information relative to the isocontours of the field. This can be used, for example, to speed up the computation of isosurfaces by computing seed sets over the Contour Tree data structure as in <ref type="bibr">[13]</ref>. The display <ref type="bibr" target="#b0">[1]</ref> of the Contour Tree provides the user with direct insight into the topology of the field and reduces the user interaction time necessary to "understand" the structure of the data. <ref type="figure" target="#fig_0">Figure 1</ref> shows an example of how information can be extracted from the Contour Tree display.</p><p>The first efficient technique for Contour Tree computation in 2D was introduced by de Berg and van Kreveld in <ref type="bibr" target="#b4">[5]</ref>. The algorithm proposed has ( 0 ) 2 @ 3 B 5 6 7 @ R 8</p><p>complexity. A simplified version, with the same complexity in 2D and</p><formula xml:id="formula_1">( 0 ) 2 1 ¡ 8</formula><p>c omplexity in higher dimensions, was proposed by van Kreveld et al. in <ref type="bibr">[13]</ref>. This new approach is also used as a preprocessing step for an optimal isocontouring algorithm. It computes a small seed set from which any contour can be tracked in optimal running time. The approach has been improved by Tarasov and Vyalyi [12] achieving</p><formula xml:id="formula_2">( 0 ) 2 1 4 3 # 5 © 6 Q 1 F 8</formula><p>complexity in the 3D case by a three-pass mechanism that allows one to resolve the different types of criticalities. Recently Carr, Snoeyink and Axen <ref type="bibr" target="#b2">[3]</ref> presented an elegant extension to any dimension based on a two-pass scheme that builds a Join Tree and a Split Tree that are merged into a unique Contour Tree. The approach achieves</p><formula xml:id="formula_3">( 0 )1 C E @ 3 # 5 6 7 @ R 8</formula><p>t ime complexity. One fundamental limitation of the basic Contour Tree is the lack of additional information regarding the topology of the contours. In high pressure chemical simulations <ref type="bibr">[11]</ref>, hydrogen bonds between the atoms cannot be represented in a traditional way but can be characterized by isosurfaces of potential fields. The Contour Tree pro-vides important information regarding the clustering of atoms into molecules but fails to discriminate between linear chains and closed rings (or more complex structures), which have different physical behaviors. In <ref type="bibr">[10]</ref> we introduced the first efficient algorithm for the computation of the Betti numbers of all the level sets of a scalar field in <ref type="table" target="#tab_6">(  0 )  2 1  3  # 5  6  7 1  F 8</ref> t ime. In this paper we introduce an extension of the algorithm in <ref type="bibr" target="#b2">[3]</ref> that allows one to add the Betti numbers of each contour while maintaining the simplicity of the scheme and the efficient</p><formula xml:id="formula_4">( 0 ) 2 1 £ C @ 3 # 5 © 6 Q @ R 8</formula><p>t ime complexity. We also introduce a new divide and conquer scheme for the computation of the Contour Tree. The basic idea is to compute Join/Split Trees by recursively combining the same trees computed for two halves of the mesh. This approach allows one to achieve better modularity by confining any knowledge of a specific interpolant to an oracle that computes the tree for a single cell (in the Appendix we report the oracle for the trilinear interpolant). In our analysis of the scheme we show a time complexity of ( 0 ) 2 @ C P I 3 # 5 © 6 7 @ R 8</p><p>, where I i s the number of critical points in the field.</p><p>The algorithm is also easy to parallelize. Running times from our parallel implementation specialized for rectilinear grids shows good scalability with the number of processors.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE CONTOUR TREE</head><formula xml:id="formula_5">¢ ! ¢ # " $ £ ¢ " &amp; % ' # ( , where ¢ " $ ¢ 0 ) 2 1 4 3 5 § ¢ T £ ¥ $ ¥¥£ ¢ and ¢ " &amp; % ' ¢ 6 ) 8 7 # 9 @ § ¢ T £ ¥ &amp; ¥ $ ¥£ A ¢ ¥ For simplicity of presentation, ¥</formula><p>is also assumed to be homeomorphic to a -ball. One fundamental way to study the field ' is to extract its level sets. For a given scalar</p><formula xml:id="formula_6">¡ the level set B ) 2 ¡ 8</formula><p>is defined as the inverse image of</p><formula xml:id="formula_7">¡ onto ¥ through ¢ : B ) 2 ¡ 8 ¢ ¢ V R T ) 2 ¡ 8 ¥</formula><p>We  <ref type="figure" target="#fig_1">Figure 2</ref> shows a 2D scalar field with the associated Contour Tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CONTOUR TREE COMPUTATION</head><p>This section summarizes the main result of <ref type="bibr" target="#b2">[3]</ref>, which is an elegant and efficient algorithm for the computation of the Contour Tree in any dimension. We refer to <ref type="bibr" target="#b2">[3]</ref> for a formal proof of the correctness of the scheme. The algorithm is divided into three stages: (i) sorting of the vertices in the field, <ref type="bibr">(</ref> </p><formula xml:id="formula_8">E ¤ F ! H " ) .The Boolean func- tion IsMin) ' £ © 8 r eturns true if © is a local minimum in ' . JoinTree) © $ # IE &amp; % ' # ) ( £ # 1 0 3 2 4 # 5 ( 8 1 ¢ ¡ = NewTree) 8 2 ¢ = NewUF) 8 3 for E ¢ ¤ to @ 7 6 do: 4 AddNode) ¢ ¡ £ E 8 5 if IsMin) ' £ © 8 t hen NewSet) £ E 8 6 for each edge © © T with H F E do: 7 E &amp; 8 ¢ 9 Find) @ £ E 8 8 H 8 9 Find) @ £ H 8 9 if H 8 B A ¢ 0 E8 then AddArc) ¢ ¡ £ E8 £ H 88 10 Union) @ £ E &amp; 8 £ H C 88 12 return ¢ ¡ Each vertex © is associated with two lists UpAdj, of incident edges ) © A £ © T 8 w ith H E D E</formula><p>, and DownAdj of incident edges</p><formula xml:id="formula_9">) © £ © T 8 w ith H F E . In this way IsMin) ' £ © 8 c an test in constant time if E</formula><p>is a minimum (DownAdj is empty) and the loop on line 6 directly scans the elements of DownAdj.</p><p>The routine SplitTree has the same structure as JoinTree. The only differences are as follows: (i) the main loop (line 3) would scan the vertices in reverse order, (ii) the if statement in line 5 would test IsMax instead of IsMin and (iii) the inner loop (line 6) would consider the edges</p><formula xml:id="formula_10">) © £ © T 8 w ith H F D S E ¥</formula><p>These routines are shown in <ref type="bibr" target="#b2">[3]</ref>   x=2.0</p><p>x=0.0</p><p>Topol. change  </p><formula xml:id="formula_11">(1,0,1) (1,2,1) (1,0,1) (1,0,1) (1,0,1) (1,0,1)</formula><formula xml:id="formula_12">S H T 5 0 $ # U S V 1 W # £ ¡ 5 # U # ) S H V ¦ 1 # (</formula><p>and is managed with the functions NewQ)</p><formula xml:id="formula_13">8 ( to create a queue), Get) &amp; X 8</formula><p>( to get a pair from the queue</p><formula xml:id="formula_14">X ) and Put) &amp; X £ E £ ¡ ( 8 ( to add a pair to X ). ContourTree) ¡ £ £ ¤ ¡ 8 1 X ! 9 NewQ) 8 2 ¥ ¦ ¡ R 9 NewTree) 8 3 for E ¢ ¤ to @ H 6 do: 4 AddNode) I ¥ ¦ ¡ £ E 8 5 if Leaf) ¡ £ E 8 t hen Put) &amp; X £ E £ ¢ ¡ ( 8 6 if Leaf) I £ ¤ ¡ £ E 8 t hen Put) &amp; X £ E £ £ ¤ ¡ ( 8 7 while E £ ¡ ( 9 Get) &amp; X 8 d o: 8 H 9 GetAdj) ¡ £ E 8 9 DelNode) I £ ¤ ¡ £ E 8 10 DelNode) ¢ ¡ £ E 8 11 AddArc) I ¥ ¦ ¡ £ EH 8 12 if Leaf) H ¡ £ H 8 t hen Put) &amp; X £ H £ ¡ ( 8 13 return ¥ ¦ ¡</formula><p>One can minimize the size of the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BETTI NUMBERS COMPUTATION</head><p>This section introduces a modification to the function ContourTree that provides a more detailed characterization of the contours of a scalar field. The output generated by the modified function is the  . The toroidal contour then splits into four components, each being a topological sphere.</p><p>In general the P @ ¥ ¦ ¡</p><p>has the same structure of the ¥ ¦ ¡ since it has the same number of non-degree-two nodes (extrema and merge/split points) and the same connectivity among them. The main difference is that the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¥ ¦ ¡</head><p>, in its minimal form, has no nodes of degree two. In contrast the P @ ¥ ¦ ¡ requires degree two nodes at the isovalues where a contour changes its topology without splitting or merging. Because of these added nodes, each arc of the </p><formula xml:id="formula_15">© $ # IE &amp; % ' # ) ( £ # 1 0 3 2 4 # ) ( £ IE &amp; V @ 2 # ) ( £ I# $ I ) V " # 1 0 5 V 8 1 for E ¢ ¤ to @ H 6 do: 2 B £ ¢ Q £ ¢ 3 ¥ ' # ¢ ¤ 4 for each edge ) © £ © T 8 w ith E F H do : 5 B £ T 9 B £ T 6 6 Q £ 9 Q £ 6 7 for each triangle ) © £ © T £ © 3 b 8 w ith E F H F do : 8 B £ b 9 B £ b C 9 Q £ 9 Q £ C 10 if ) © £ © T £ © C b © 8</formula><p>i s a boundary triangle then:</p><formula xml:id="formula_16">11 ¥# ) b Q 9 ¥# ) b ¦ 6 12 ¥# 9 ¥ ' # C 11 for each tetrahedron ) © £ © T £ © b £ © ! 8 w ith E F H 2 F 8 F " d o : 12 B £ 9 B £ 6 13 Q £ 9 Q £ 6 14 return) B £ £ Q £ £ ¥# 8</formula><p>From a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¥ ¦ ¡</head><p>that contains all the nodes we build the corresponding P Q ¥ ¦ ¡</p><p>. We call  </p><formula xml:id="formula_17">&amp; T ( ' ) 1 0 2 ¤ T C B £ ¢ &amp; T ( ' ) 1 3 2 ¤ T C Q £ ¥<label>(1)</label></formula><formula xml:id="formula_18">¤ C &amp; T ( ' ) 1 0 2 ¤ T C B £ ¢ &amp; T 4 ' ) 1 3 2 ¤ T C Q £ ¥<label>(2)</label></formula><p>A similar argument holds for the count of the boundary edges ¥ ' # T of each contour. We define an array of auxiliary variables ¥ ' # that are initially set to zero and satisfy the following equations:</p><formula xml:id="formula_19">¥# C &amp; T ( ' ) 1 0 2 ¥# T C 5 ¥# ¢ &amp; T ( ' ) 1 3 2 ¥ ' # T ¥<label>(3)</label></formula><p>We solve the systems of linear equations defined by <ref type="bibr" target="#b1">(2)</ref> and <ref type="formula" target="#formula_19">3</ref>  </p><formula xml:id="formula_20">AugmentedContourTree) I ¥ ¦ ¡ 6 A ¡ EI C 6 c V 6@ ¢ T ) 0 $ # 5 ( 8 1 X ! 9 NewQ) 8 2 P Q ¥ ¦ ¡ 9 NewTree) 8 3 for E ¢ ¤ to @ H 6 do: 4 ¤ 9 ¤ 5 ¥# 9 ¤ 6 AddNode) &amp; P Q ¥ ¦ ¡ £ E 8 7 if Degree) I ¥ ¦ ¡ £ E 8 U ¢ then Put) &amp; X £ E 8 8 while E 9 Get) &amp; X 8 d o: 9 H 9 GetAdj) I ¥ ¦ ¡ £ E 8 10 AddArc) &amp; P @ ¥ ¦ ¡ £ E £ H 8 11 if E F H then ¡ 9 C else ¡ 9 6 12 ¤ T 9 ¡ ) ¤ 6 Q £ T C B £ T 8 13 ¥# T 9 ¡ )¥# C ¥ ' # 8 14 ¤ T 9 ¤ T C ¡ £ ¢ ¤ T 15 ¥# T 9 ¥# T C ¡ £ ¢ ¥ ' # T 16</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>£ ¤ ¡</head><p>in the same loop. The Betti numbers can also be added at the same time. For completeness we report the function that computes the Betti numbers as a post-processing:</p><formula xml:id="formula_21">BettiNumbers) &amp; P @ ¥ ¦ ¡ 8 1 for each arc EH of P @ ¥ ¦ ¡ do: 2 Y " a ¥ ¤ T 9 Y ¡ ¤ T 9 3 if ¥ ' # T A ¢ ¤ then Y ¡ ¤ T 9 ¤ 4 Y T 9 Y a Q C F Y ¡ 6 ¤ T P Q ¥ ¦ ¡</formula><p>Reduction. The following function, Reduce, removes all of the non-critical points from the P Q ¥ ¦ ¡ in order to reduce it to its minimal form. The test is based on the critical point theorem in <ref type="bibr" target="#b1">[2]</ref> and can detect the critical points in constant time once the arrays B £ and Q £ have been computed. Note that this removal of noncritical points can be done during the computation of the P @ ¥ ¦ ¡ , reducing the necessary intermediate storage:</p><formula xml:id="formula_22">Reduce) &amp; P @ ¥ ¦ ¡ 8 1 for E ¢ ¤ to @ H 6 do: 2 if B £ ¢ Q £ ¢ ¤ 3 DelNode) &amp; P Q ¥ ¦ ¡ £ E 8</formula><p>Correctness. The correctness of the routines LUStars and Bet-tiNumbers derives directly from the definitions of the parameters computed. To prove the correctness of AugmentedContourTree we show that there are two invariants that remain true at each iteration. The invariants are the systems of equations (2) and (3   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8</head><p>. This dissection can be computed for unstructured finite element meshes <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref> </p><formula xml:id="formula_23">in ( 0 ) 2 @8</formula><p>time. For simplicity of presentation and implementation (straightforward computation of the dissection), we restrict our analysis to the case of scalar fields</p><formula xml:id="formula_24">' ¢ ) ¢ ¤ £ ¦ ¥ 8</formula><p>w here ¥ is a rectilinear mesh of dimensions @ ' £ @ @ . This is the type of mesh that typically has the largest number of vertices (i.e., the type used in the largest simulations or generated by high resolution MRI/CT scanning devices). In this case the function ¢ is defined within each cell as the trilinear interpolation of the field values at the eight vertices. In this framework we cannot use the algorithm ContourTree since it assumes properties that are specific to a piecewise linear interpolant. For example, the trilinear interpolant admits critical points in the interior of a cell, a condition not allowed by Con-tourTree. Triangulating the cells of the grid is usually not an option for large data-sets, especially because the same topology cannot be reproduced in general unless several more vertices are added to each cell of the mesh.</p><p>Our approach overcomes this problem by assuming an oracle Recursive algorithm. The recursive algorithm has the same structure of a merge sort scheme with the added feature that non-critical vertices are removed as soon as possible. This removal provides an output sensitive character to the algorithm and improves both its time complexity and its space complexity:</p><formula xml:id="formula_25">RecursiveJT) ' £ ¥ 8 1 if Dimensions) ¥ 8¢ ) §£ §£ § 8 t hen 2 return OracleJT) ' £ ¦ ¥ 8 3 ¥ T £ A ¥ ¡ ( 9 Split ) ¥ 8 4 ¢ ¡ T 9 RecursiveJT )' £ A ¥ T 8 5 ¢ ¡ ¡ 9 RecursiveJT )' £ A ¥ ¡ 8 6 ¢ ¡ R 9 ! " $ # &amp; % ) ¢ ¡ T £ ¡ ¡ 8 7 return Reduce) ¢ ¡ 8</formula><p>The function Split MergeNodesSorted) ¢ ¡ </p><formula xml:id="formula_26">&amp; P Q ¥ ¦ ¡ £ E 8</formula><p>Complexity. To determine the complexity of RecursiveJT we analyze separately the cost of dealing with the interior critical points and the cost of dealing with the boundaries that are artificially introduced by the subdivision process and removed by MergeJT.</p><p>We assume that As the sub-meshes are merged together boundary points become interior points. In particular, every point is processed by Reduce in constant time. Moreover, any point that fails the test IsRegular is also processed in constant time by MergeJT at every level of the recursion. If To analyze the cost of dealing with the boundaries we apply the master theorem of recursive functions reported on page 62 of <ref type="bibr" target="#b3">[4]</ref> i s the complexity of MergeJT with reference to the boundary points only (the other points have already been accounted for). As discussed earlier the highest cost in MergeJT is due to the Union-Find, which we have set conservatively to</p><formula xml:id="formula_27">( 0 ) 2 @ ¡ § ¦ © 3 # 5 © 6 7 @ R 8</formula><p>. , as shown in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">PRACTICAL RESULTS</head><p>This section reports some practical results from our implementation of the the two algorithms discussed in Sections 4 and 5. We first present an example of the Augmented Contour Tree of the scalar field obtained for a simple molecular data-set (methane) that shows surprisingly intricate topological structures. Next we compare the timings for the computation on data-sets of five different sizes. Methane. We consider the topological analysis of a small scalar field computed by ab initio simulation conditions for the methane molecule. We have computed the P Q ¥ ¦ ¡</p><p>and displayed it using the graph drawing tool graphviz <ref type="bibr" target="#b5">[6]</ref>. The top portion of this graph is shown in <ref type="figure" target="#fig_0">Figure 1</ref>, along with several isosurfaces, and their corresponding points in the P @ ¥ ¦ ¡</p><p>. We focus on this portion of the data-set since it is known that the simulation becomes less reliable at lower densities.</p><p>The Methane data-set, which is on a 32x32x32 rectilinear grid, is the simplest non-trivial data-set we explored. It is a nice example, since the visualization of the tree is possible by conventional means. This gives us a good way of exploring the possibilities of using the P Q ¥ ¦ ¡</p><p>as an interface for data understanding. We see from the isosurfaces (b), (c) and shows 2 distinct components. Only after adding a clipping plane the second component is shown to be enclosed within the first. Performance. We have implemented in parallel the divideand-conquer P Q ¥ ¦ ¡ algorithm on a shared memory platform. This is done by creating two processes at each recursion that compute Join and Split Trees for each half of the mesh. The recursion become sequential as soon as the desired number of processes is reached. <ref type="table" target="#tab_6">Table 1</ref> summarizes running times for four data-sets of sizes scaling from thousands to millions of vertices. The speedup relative to the sequential case is reported in <ref type="figure" target="#fig_16">Figure 5</ref>, compared to the ideal linear speedup (top line in the chart).</p><p>One can see that the speedup obtained in the parallel implementation scales nearly linearly. The coarse grained subdivision in our method is easily implemented in parallel. Each processor becomes responsible for a connected subregion of the mesh and works completely independently of the other processes. The only communication necessary is for a child process to return the ¢ ¡ and £ ¤ ¡ that it computed to its parent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>We have introduced two schemes for the computation of the P Q ¥ ¦ ¡</p><p>for scalar fields defined on simplicial meshes and on rectilinear grids. The first scheme is an extension of the algorithm proposed in <ref type="bibr" target="#b2">[3]</ref> with the computation of the Betti numbers. The second contribution is a divide-and-conquer scheme for rectilinear grid domains. The complexity of this second scheme is improved further to</p><formula xml:id="formula_28">( 0 ) 2 1 C E I 3 # 5 © 6 Q @8</formula><p>w here I i s the number of critical points in the mesh. Moreover, we demonstrate good practical scalability of a simple parallel implementation of this algorithm.</p><p>The comparison between the two schemes is interesting even if it applies to different classes of inputs. In particular, the divide-andconquer approach seems to present several advantages, especially for the processing of large data-sets. For instance, the auxiliary storage is kept as low as</p><formula xml:id="formula_29">( 0 ) 2 @ ¡ § ¦C E I W 8</formula><p>. In contrast the original scheme can have</p><formula xml:id="formula_30">( 0 ) 2 @ R 8</formula><p>auxiliary storage since the union find processing needs to maintain auxiliary information on a set of vertices as large as the largest isosurface in the mesh.</p><p>In principle there seem to be no major problems preventing the application of the divide-and-conquer scheme to unstructured meshes, but further investigation is necessary to verify if the same performance benefits can be guaranteed in general.</p><p>The simple task of drawing the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¥ ¦ ¡</head><p>has become a major problem. For data-sets that we have successfully processed we already obtain trees that current graph drawing tools cannot handle. Still we plan to work on data-sets that are orders of magnitude larger. In such cases the development of interfaces that display the ¥ ¦ ¡ will present a major challenge. [ </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>We consider the problem of computing the Merge and Split Trees for a cell with a trilinear interpolant. Our analysis is limited to the Split Tree since the Join Tree is computed symmetrically. We show that in the 2D case there are only two possible Split Trees and in 3D there are only four possible Split Trees. In both cases the topology of the Split Tree is completely determined by the number of maxima present in the cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bilinear Interpolant on a Rectangle</head><p>Consider a bilinear function</p><formula xml:id="formula_31">0 ) 1 ¡ 3 2 1 , defined analytically by 0 ) C £ 5 4 8 U ¢ V C 4 C ¥ D C C % 4 C 0 . The gradient 6</formula><p>is as follows:</p><formula xml:id="formula_32">6 ¢ 7 9 8 2 8 C 8 2 8 4 @ ¢ 7 V 4 C ¥ V C C % @ £ where V £ ¥ £ % £ 0</formula><p>are real numbers. Since      </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Trilinear Interpolant on a Parallelepiped</head><p>We extend our analysis to the trilinear case and show how to compute the shape of the split and merge trees for a cube on the basis of the orientation of its edges and the function value of the eventual body saddle points. The analytical formulation of the trilinear interpolant is</p><formula xml:id="formula_33">0 ) C £ Q 4 £ ¦ ¥ 8 U ¢ V C 4 § ¥ C ¥C 4 C % C ¥ C 0 4 § ¥ C # C S C 2 4 C ¥ C , with gradient: 6 ¢ © # Q C ¥ 4 C F % ¥ C V 4 § ¥ 2 C ¥C C 0 ¥ C V C ¥ C F % C C 0 4 C V C 4 ¥</formula><p>It is easy to see that restricting to any plane orthogonal to a coordinate axis yields the bilinear function discussed above. Therefore, there is no local minimum or maximum of . Solving 6 ¢ ¤ we find two critical points of coordinates:</p><formula xml:id="formula_34">C ¢ 0 Y ) V 4 # 6 ¥% $ 8 V )¥% 4 6 V 4 # 8 £ 4 ¢ % ) V 2 G 6 ¥0 ¦ 8 V )¥0 ¤ 6 V 2 8 £ ¥ ¢ ¥ ) V 6 % 0 ¦ 8 V ) % 0 ¤ 6 V Y 8 £</formula><p>where the term is either added in all expressions or subtracted in all expressions, and is four. <ref type="figure" target="#fig_21">Figure 7</ref> shows the five distinct types of Split Trees that can be built with up to four maxima. We show in the following that the last type is not consistent with the topology of the trilinear interpolant. The important practical consequence of this theorem is that we can precompute four templates of Split Trees, and for each element in the mesh we select the appropriate template from the orientation of the edges. Simple numerical computations allow one to determine the specific values of the saddles where the merge occurs.</p><formula xml:id="formula_35">¢ )¥% 6 F V 4 # 8)¥0 6 F V 2 8) % 0 6 F V Y 8 ¥</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(Figure 1 :</head><label>1</label><figDesc>to the number of intersections (a) The number of components of the isosurface of of the Contour Tree with the line w=const. (c) Isosurface of genus 9 The Contour Tree can reveal hidden information, such as enclosed components. (b) The Augmented Contour Tree reports the topology of the isosurface, here it has genus 3. w = 0.2453 Augmented Contour Tree (ACT) and four isosurfaces (level sets) of the electron density distribution of a methane molecule. Each arc of the ACT is marked by the second Betti number (equal to twice the number of handles of the surface) of the corresponding isosurface. The four isosurfaces are computed for isovalues '</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>(a) 2D scalar field (terrain) represented as a triangulation with elevation values associated with each vertex. The critical points are marked with colored disks: maxima in red, saddles in green and minima in purple. A set of representative level sets (isolines) are drawn in blue. (b) Corresponding Contour Tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>.</head><label></label><figDesc>In the following two sections of this paper the domain ¥ is assumed to be a simplicial complex with @ vertices and 1 cells. In Section 5 the domain ¥ is assumed for simplicity to be a rectilinear grid (the results presented generalize directly to unstructured meshes). Within each simplex of ¥ the function ¢ is the linear interpolation of its values at the vertices (trilinear for grid cells). In other words, the field</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>'</head><label></label><figDesc>processed one connected component at a time) the range of ¢ is a simple closed interval</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>(a) Information provided by the standard ¥ ¦ ¡ for a simple scalar field. (b) The added information provided by the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>8 of</head><label>8</label><figDesc>Betti numbers associated to each arc of the tree. The -th Betti number Y c b of a simplicial complex is the rank of its -dimensional homology group. We restrict our attention to level sets of 3D scalar fields, which are 2D complexes. In this case only the first three Betti numbers may be non-zero. Their intuitive interpretation is as follows: Y ¢ a is the number of connected components, Y T is the number of independent tunnels, and Y ¡ is the number of voids enclosed by the surface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 (Figure 4 :.</head><label>34</label><figDesc>a) shows the minimal ¥ ¦ ¡ for a simple scalar field that has one minimum at isovalue C ¢ ¤ . The level set ¢ VT) ¤ 8 i s a single contour coincident with the boundary of the mesh (on the bottom left). As the isovalue is continuously increased, the level Comparison between two level sets (isolines in blue) of a 2D scalar field. (a) shows an isoline of isovalue The difference between combinatorial structure of the two isolines is confined within the star of simplices incident to © . set splits into four contours at isovalue C ¢ § (on the middle left). Each contour shrinks to a single point and disappears at the maximum isovalue C ¢ (on the top left). Figure 3(b) shows the minimal P @ ¥ ¦ ¡for the same scalar field. The added information allows the user to observe that the level set at the minimum is topologically a sphere</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>.</head><label></label><figDesc>sum of the Euler numbers of the contours of numbers of the contours associated with the arcs incident toE. In particular, each edge, triangle and tetrahedron in the lower star of © produces one vertex, edge and face, respectively, in some contour of In the same way each edge, triangle and tetrahedron in the upper star of © produces one vertex, edge and face, respectively, in some contour of two terms are the only difference between the Euler numbers of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>H</head><label></label><figDesc>th equation of (2) since the term ¤ T is no longer present. We restore its correctness by adding the value of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>cell.We have implemented such an oracle for the trilinear interpolant on a cube (see Appendix). To extend the scheme to data-sets with other types of interpolants, for example a triquadratic interpolant, requires only to replace the function OracleJT. OracleST)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>) ¥ 8 d...</head><label>8</label><figDesc>ivides in constant time the domain of the mesh into two approximately equal meshes Tree merging. The routine MergeJT below combines the Join Trees of the two halves of the mesh using a UnionFind datastructure in the same way the routine JoinTree computes the global ¢ ¡ from the edges of the mesh. Two key differences need to be highlighted. First, MergeJT sorts the input nodes in linear time since already sorted. In particular one linear scan through the input trees sorts the nodes and at the same time merges the duplicate nodes, which correspond to vertices on the surface This task is performed by MergeNodesSorted, which also returns the total number of distinct nodes. Second, MergeJT copies verbatim into This is done in linear time. The UnionFind data-structure is used starting at the nodes that correspond to local minima of the scalar field restricted to test for minima is performed by IsMin in constant time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>@ 2 §</head><label>2</label><figDesc>is the number of cells of ¥ and that Split partitions ¥ into two equal halves of size @ . Therefore, the number of levels in the recursion tree of RecursiveJT is OracleJT, which takes constant time, is invoked exactly @ times (once per cell), accounting for a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>8 i</head><label>8</label><figDesc>. The theorem allows one to determine the complexity of a function s the complexity of our recursive algorithm and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>(d) that there is useful information summarized in the P @ ¥ ¦ ¡ that is not obvious from the visualization. The isosurfaces (b) and (c) can be seen immediately to have for closed surfaces. In the isosurface (d) the initial visualization shows a single surface, whereas the P Q ¥ ¦ ¡</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 5 :</head><label>5</label><figDesc>Practical speedups obtained in the parallel implementation for four data-sets of different sizes, compared with the ideal linear speedup.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 6 :</head><label>6</label><figDesc>(a) 2D bilinear function. The saddle point ( J. Milnor. Morse Theory, volume 51 of Annals of Mathematics Studies. Princeton University Press, 1963.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>it is not possible to have a local maximum or minimum for finite values of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>has upward gradient from those with downward gradient.Fact 1. There is exactly one saddle point ( of in the plane. Fact 2.The function is constant on the line ' orthogonal to the C and on the line orthogonal to the 4 axis, where ' intersects at the saddle point</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 7 :</head><label>7</label><figDesc>Possible configurations of split tree for a trilinear interpolant restricted to and axis aligned parallelepiped. One the left of each tree there are one or two examples of corresponding parallelepipeds. (a) One maximum. (b) Two maxima. (c) Three maxima. (d) Four maxima. (e) Split tree with four maxima that cannot be constructed.is linear along each line parallel to the coordinate axis, we can mark each edge of a square with respect to the direction of increasing values of .Figure 6(a)shows the three different types of squares that one can have with respect to the orientation of their edges. A square of type P has each pair of opposite edges with parallel orientation. Therefore P at the intersection between</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Fact 3 .</head><label>3</label><figDesc>two maxima and two minima) of £ . In the third type of square ¥ £ one pair of opposite edges are parallel while the other pair are anti-parallel. Thus, The bilinear function restricted to an axis aligned rectangle can have only one or two maxima. The maxima can be located only at non-adjacent vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 6 (</head><label>6</label><figDesc>b) shows how the split trees of ¢ and of ¤ are both single lines connecting the minimum to the maximum. The split tree of £ has one line that connects the lower minimum to the saddle ( . At ( the split tree of £ bifurcates into two lines connecting ( to the two maxima.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 8 :</head><label>8</label><figDesc>Impossible configurations that would be necessary to allow the construction of a Split Tree shown inFigure 7(e). (a) 3D view. (b) projection onto the C 4 plane. critical points are both saddles (of indices 1 and 2).Fact 4.There are at most two critical points (both saddles) in F. We next consider the restriction of to an axis aligned parallelepiped % and mark its edges with the direction of increasing . The restriction of to any face of % is the bilinear interpolant discussed in the previous section, therefore facts 3 and 4 imply that one can have maxima of &amp; only at its vertices. Moreover, each face of % can have only two maxima so that the greatest number of maxima of &amp;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>8 .0Theorem 1</head><label>81</label><figDesc>But in a trilinear function the value of must be monotonic along any line parallel to an orthogonal axis. Thus we have a contradiction, since we have shown that is not monotonic along , which is parallel to the ¥ axis. In conclusion we can state the following: The topology of the Split Tree of &amp; is completely determined by the count of its local maxima.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>call each connected component of the level set B ) C 8 a contour. One aspect that is well understood in Morse theory [9] is the evolution of the homology classes of the contours of ' while C</head><label></label><figDesc></figDesc><table><row><cell>changes continuously in</cell><cell>. The points at which the</cell></row><row><cell cols="2">topology of a contour changes are called critical points and the cor-</cell></row><row><cell cols="2">responding function values are called critical values. The critical</cell></row><row><cell cols="2">points are usually assumed to be isolated. This assumption can be</cell></row><row><cell cols="2">enforced by small (symbolic) perturbations of the function values  § ¢ T £ ¥ D ¢ as discussed in Section 3. $ ¥¥£ Here this perturbation procedure is weakened by simply assum-ing that the function values  § ¢ T £ ¥ $ ¥ $ ¥£ ¢ are sorted from the small-est to the largest so that E G F I H Q P ¢ G R S ¢ T This can be enforced ¥ with an ( 0 ) 2 @ A 3 # 5 © 6 p reprocessing step. In the following of this pa-per the order of the ¢ is used to resolve non-isolated criticalities. Q @8 An intuitive way to characterize the Contour Tree is given by the</cell></row><row><cell>following definition:</cell><cell></cell></row><row><cell cols="2">The Contour Tree of traction of each contour of is the graph obtained by continuous con-' to a single point. Adjacent contours are contracted to adjacent points. Distinct contours are contracted ' to distinct points.</cell></row><row><cell cols="2">Note that the Contour Tree is not a complete Morse graph of</cell></row></table><note>' since the topological changes of a single contour are not recorded.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>to have worst case time complexity of</figDesc><table><row><cell>( 0 ) 2 1 . In the last stage of the algorithm C I ¦ 3 B 5 6 Q I W 8 ¥ to build the ¥ . The upper leaves ¦ ¡ and the lower leaves of the Merging the ¢ ¡ with the £ ¤ ¡ the ¡ is merged with the £ G ¡ of the ¢ ¡ £ are successively removed ¤ ¡ from both trees and added to the ¥ . Consequently the data struc-¦ ¡ ture representing the ¢ ¡ and the £ ¤ ¡ has to support the additional operations DelNode) ¡ £ E 8 , and Leaf) H ¡ £ E 8 . DelNode) H ¡ £ E 8 removes the node E from while maintaining the consistency of ¡ ¡ by removing any arc EH and replacing any pair of arcs EH , E I with the arc H 3 . The Boolean function Leaf) ¡ £ E 8 t ests whether the node E is a leaf of ¡ . More specifically Leaf) ¢ ¡ £ E 8 i s true</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>. This makes the algorithm slightly more complicated but has the advantage of reducing the size of the intermediate storage.This last stage of the algorithm has</figDesc><table><row><cell cols="4">¥ ¦ ¡ exactly degree two with DelNode. This reduction to a minimal by deleting any node that has ¥ ¦ ¡ can be done directly during the construction of the and of the ¡ £ ¤ ¡</cell></row><row><cell>algorithm for constructing the since I i s never greater than</cell><cell>¥ ¦ ¡</cell><cell>( 0 ) 2 @ R 8 has ( 0 ) 2 1</cell><cell>c omplexity. Overall the C @ 3 B 5 6 7 @ c omplexity, R 8</cell></row></table><note>@ .</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 1 :</head><label>1</label><figDesc>family of contours that are homologically equivalent and hence qualified by the same set of Betti numbers. Moreover, the contours associated with an arc contain no critical points and the Betti numbers are restricted as follows: (i) Given a triangulated surface, the Euler number ¤ is defined as the number of vertices minus the number of edges plus the number of faces. In addition to computing the Euler number, for each contour we count the number of boundary edges (¥ Any simplex containing both vertices of type¨and type © give the same contribution to the Euler numbers of the two contours and hence are not considered. The only simplices that are relevant are those containing Performance results for four sample data-sets. The values given are the speedups achieved in computing the</figDesc><table><row><cell cols="2">P @ ¥ ¦ ¡ is always 1, (ii) is as-Y ¡ is 0 for surfaces with boundary (open) and is 1 for surfaces without sociated with a Y ¢ a</cell></row><row><cell cols="2">boundary (closed). Once the value of Y T using its relationship with the Euler characteristic Y a and Y are determined we can compute ¡ ¤ ¢ Y a 6 Y T C E Y</cell></row><row><cell cols="2">' # ). and then use . In a preliminary ' # ¥ D ¤ C ¡ Y by checking if the Euler formula to compute In this way we can determine Y T ¢ Y a F Y ¡ 6 ¤ stage we compute, for each vertex , the information necessary to © determine the difference between the Euler number of the level set B ) ¢ ) © ¦ 8 C ¦ ¡8 a nd the Euler number of the level set B ) ¢ ) © ¦ 8 ' 6  § ¡8 w here ¡ @ D ¤ is an arbitrarily small number (remember that ¢ ) © ¦ 8 ¢ ¢ ) 2 ¡ 8 implies © ¢ ¡ ). Figure 4 shows two such level sets for a 2D scalar field. The vertices with function value greater than ¢ ) © ¦ 8 a re marked and the vertices with function value smaller than ¢ ) © ¦ 8 a re marked © . © and only vertices of type or those containing © © and only vertices of type¨. We call the lower star of © the set of simplices of the first type ) © £ © £ ¥ &amp; ¥ $ ¥£© 8 a nd the upper star the set of simplices of the second type ) © £ £ ¥ $ ¥ $ ¥£8 . For both stars we com-pute the respective Euler numbers B £ and (number of vertices Q £ minus number of edges plus number of triangles minus number of</cell></row><row><cell>tetrahedra). We also count the difference ary edges of B ) ¢ ) © ¦ 8 G 6 ¡8 a nd B ) ¢ ) © ¦ 8C the following algorithm:</cell><cell>¥ ' # . This is summarized in between the bound-8 ¡</cell></row></table><note>¡ ¥</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>with the procedure AugmentedContourTree, which incrementally moves an arc</figDesc><table><row><cell>EH ¤ returns the degree of the node from the ¥ ¦ ¡ to the ing value of T can be determined (the function Degree) P Q ¥ ¦ ¡ each time the correspond-H ¡ £ © ¦ 8 © in ¡</cell></row></table><note>):</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>IsRegular performs the same combinatorial test modified for the interpolant used by OracleJT. Note that the last call to Reduce should be modified to not check IsInterior, so that all of the non-critical points are removed. Otherwise non-critical points on the boundary of the mesh would remain in</figDesc><table><row><cell cols="5">T £ ¢ ¡ do: t hen NewSet)  § 8 W 8 6 8 ¤ E ¢ to ¢ ¡ 4 for each node 5 AddNode) £ E 8 6 if IsMin) ' £ ¥ ¤ ¦ £ © £ E 7 for each edge © © T with H F E do: 8 E8 9 Find) @ £ E 8 9 H 8 9 Find) @ £ H 8 10 if H 8 B A ¢ 0 E8 then AddArc) ¢ ¡ £ E8 £ H 88 11 Union) @ £ E8 £ H 88 12 return ¢ ¡ Let @ be the number of vertices of ¥ T and ¢ ber of nodes of ¡ T £ ¡ ¡ and I be the number of the minima £ E 8 ¥ ¡ , be the num-of ' £ ¤  § ¦ £ © . The complexity of MergeJT is ( 0 ) 2 @ ¡  § ¦ © C F C I ¦ 3 # 5 © 6 Q I W 8 . Since I ¢ ( 0 ) 2 @ ¡  § ¦8 we can rewrite the complexity as ( 0 ) 2 @ ¡  § ¦ © 3 # 5 © 6 7 @ C . 8 P Q ¥ ¦ ¡ Reduction. As shown in Section 4, Reduce can test if a point E is non-critical simply by looking at B £ and . In this Q £ context P Q ¥ ¦ ¡ :</cell></row><row><cell>Reduce) &amp; P @ ¥ ¦ ¡ 1 for E ¢ ¤ to 8 @ 2 if IsInterior) 3 DelNode)</cell><cell>do: E 8</cell><cell>a nd IsRegular)</cell><cell>E</cell><cell>8</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>. For the case of large data-sets it is also crucial to minimize the cost of any auxiliary storage. Beyond linear storage in the size RecursiveJT keeps a storage proportional to the boundary of the mesh. Overall the auxiliary storage is</figDesc><table><row><cell>means that ¡ ) 2 @ R 8 ¢ ( 0 ) 2 @ C P I ¦ 3 B 5 have I S ¢ % ( ¢ ) 2 @8 ) 2 @ . In conclusion, the complexity of RecursiveJT is has complexity ( 0 ) 2 @T W VX8 for some and hence ¡ R 8 6 7 @ R 8 . For practical cases where I i s less than linear we 0 ) 2 @ U T W VX8 £ which means the overall complexity is ( 0 ) 2 @ R 8 o f I the output, ( 0 )I R C E @ ¡  § ¦ © . Note that the analysis above applies for general unstructured 8 meshes since it is possible to compute in ( 0 ) 2 @8 t ime a dissection of ¥ with boundary of size ( 0 ) 2 @ ¡  § ¦8</cell></row><row><cell>This</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>M. van Kreveld, R. van Oostrum, C.L. Bajaj, V. Pascucci, and D.R. Schikore. Contour trees and small seed sets for isosurface traversal. In Proceedings of the 13th Annual Symposium on Computational Geometry, pages 212-220, June 1997.</figDesc><table><row><cell cols="2">10] V. Pascucci. On the topology of the level sets of a scalar field. In 12th Canadian</cell></row><row><cell cols="2">Conference on Computational Geometry, pages 141-144, August 2001.</cell></row><row><cell cols="2">[11] E. Schwegler, G. Galli, and F. Gygi. Water under pressure. Physical Review</cell></row><row><cell cols="2">Letters, 84(11):2429-2432, 2000.</cell></row><row><cell cols="2">[12] S. P. Tarasov and M. N. Vyalyi. Construction of contour trees in 3d in</cell></row><row><cell>" ! # % $ &amp; ( '</cell><cell>steps. In Proceedings of the Fourteenth Annual Symposium on</cell></row><row><cell cols="2">Computational Geometry, pages 68-75, Minneapolis, June 1998. ACM.</cell></row><row><cell>[13]</cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The contour spectrum</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97</title>
		<imprint>
			<biblScope unit="page" from="167" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Critical points and curvature for emmbedded polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Banchoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Differential Geometery</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="245" to="256" />
			<date type="published" when="1967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Computing contour trees in all dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Axen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry Theory and Applications</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Trekking in the alps without freezing or getting tired</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Van Kreveld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="306" to="323" />
			<date type="published" when="1997-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ellson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mocenigo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Woodhull</surname></persName>
		</author>
		<ptr target="http://www.research.att.com/˜north/graphviz/" />
	</analytic>
	<monogr>
		<title level="j">Graphviz. AT&amp;T Research</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic mesh partitioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gary</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shang-Hua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">P</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Thurston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vavasis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Theory and Sparse Matrix Computation, number 56 in The IMA Volumes in Mathematics and its Applications</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="57" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Geometric separators for finite-element meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gary</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shang-Hua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">P</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Thurston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vavasis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Scientific Computing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="364" to="386" />
			<date type="published" when="1998-03" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
