<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Approximating Normals for Marching Cubes applied to Locally Supported Isosurfaces</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering</orgName>
								<orgName type="institution">Arizona State University</orgName>
								<address>
									<postCode>85287-5406</postCode>
									<settlement>Tempe</settlement>
									<region>AZ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering</orgName>
								<orgName type="institution">Arizona State University</orgName>
								<address>
									<postCode>85287-5406</postCode>
									<settlement>Tempe</settlement>
									<region>AZ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Sylvester</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering</orgName>
								<orgName type="institution">Arizona State University</orgName>
								<address>
									<postCode>85287-5406</postCode>
									<settlement>Tempe</settlement>
									<region>AZ</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Approximating Normals for Marching Cubes applied to Locally Supported Isosurfaces</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>isosurface</term>
					<term>normal vectors</term>
					<term>marching cubes</term>
					<term>triangular mesh</term>
					<term>topology</term>
					<term>Gouraud shading</term>
					<term>approximation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present some new methods for computing estimates of normal vectors at the vertices of a triangular mesh surface approximation to an isosurface which has been computed by the marching cube algorithm. These estimates are required for the smooth rendering of triangular mesh surfaces. The conventional method of computing estimates based upon divided difference approximations of the gradient can lead to poor estimates in some applications. This is particularly true for isosurfaces obtained from a field function, which is defined only for values near to the isosurface. We describe some efficient methods for computing the topology of the triangular mesh surface, which is used for obtaining local estimates of the normals. In addition, a new, one pass, approach for these types of applications is described and compared to existing methods.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION AND MOTIVATION</head><p>Isosurfaces are very useful and important tools for the visualization and analysis of volume data. Typically, samples or measurements over a regular 3D lattice of a field function, It is often the case that isosurfaces are approximated by a surface comprised of triangles. The Marching Cubes algorithm <ref type="bibr" target="#b5">[6]</ref> is a very popular and effective means to compute this type of approximation. In addition, many rendering and post processing techniques require estimates of the normal vector of the isosurface at the vertices of the triangulated surface approximation. In this paper we present some new methods for computing these estimates. In this present section, we cover some background material and motivate the new techniques presented in Section 2 and Section 3. Examples of our new methods are presented in Section 4.</p><p>In general, there are two approaches to computing estimates of the normal, N(x,y,z), of an isosurface.</p><p>1. The first is based upon the fact that the normal vector is the gradient of the field function. That is <ref type="bibr" target="#b0">(1)</ref> Numerical differentiation approximations are then used to approximate the partial derivatives of (1). The method suggested in <ref type="bibr" target="#b5">[6]</ref> is based upon a well known, second order, approximation of Zucker. First, the following approximation to the gradient is used to compute approximations to the normals at the lattice points: <ref type="bibr" target="#b1">(2)</ref> Next, linear interpolation along edges is used to obtain approximations to the normals at the vertices of the triangular mesh isosurface. We should point out that even though the approximation of (2) only involves two values of the field function, it is really a second order approximation. It is obtained by passing a quadratic function through three consecutive points and then taking the derivative of this quadratic at the center point. Due to the symmetry, the middle term drops out except on the boundaries. The appropriate formulas for the boundaries are easily obtained by the quadratic interpolation procedure:</p><p>Based upon the above ideas, it is very easy to implement a single pass marching cubes algorithm that produces or immediately renders a list of triple vertices with normal vectors. This is a standard simple approach, which avoids computation of the topology of the triangular mesh isosurface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>The second approach is more general and appeals more directly to the definition that a normal vector is perpendicular to the surface. Approximations are based upon the normal vectors of local planar surface approximations. This approach requires the topology of the triangular mesh surface. A triangular grid structure as defined in <ref type="figure">Fig. 1</ref> is a popular and convenient method for representing the topological information for a triangular mesh surface. An estimate of the normal at a vertex can be computed as a weighted average of the normals of all the triangles which involve this vertex. The weights may be chosen to be uniform or based upon the area of the associated triangle or even the subtended angle. <ref type="figure">Fig. 1</ref>. An example that serves to define a triangular grid structure for representing a triangular mesh surface. Now we proceed with the motivation for the new methods that we will eventually describe in Sections 2 and 3. When implementing a mc algorithm, it is a relatively easy matter to include normal estimates based upon the gradient approach and the divided difference approximations given in <ref type="bibr" target="#b1">(2)</ref>. This approach does not require computing the topology of the triangular grid structure.</p><formula xml:id="formula_0">              ∂ ∂ ∂ ∂ ∂ ∂ = ∇ = z y x z F z y x y F z y x x F z y x F z y x N , 2 ) 1 , , ( ) 1 , , ( 2 ) , 1 , ( ) , 1 , ( 2 ) , , 1 ( ) , , 1 ( ) , , (                 ∆ − − + ∆ − − + ∆ − − + = z k j i F k j i F y k j i F k j i F x k j i F k j i F k j i N ) , , ( ) , , ( ) , , ( k j i N k j i N k j i N =                 ∆ − − + ∆ + − − − ∆ − + − = z k n F k n F y k n F k n F k n F x k n F k n F k n F k n N 2 ) 1 , , 1 ( ) 1 , , 1 ( 2 ) , , 1 ( 3 ) , 1 , 1 ( 4 ) , 2 , 1<label>( 2 )</label></formula><p>But, in some applications, these types of approximations may be rather poor. The types of applications that have motivated the methods of this paper are those where the field function is only defined at the lattice points that are very close to the vertices of the isosurface. Here, the isosurface or points on or near the isosurface are given and the field function is determined so as to yield the isosurface. Some methods of point cloud fitting would fall into this category <ref type="bibr" target="#b3">[4]</ref>. Also applications that use a signed distance function (or modifications thereof) to represent surfaces have the potential of having this locally supported property. In these types of applications, it is possible for the gradient estimates to involve lattice points, which are not necessary to precisely define the isosurface, and so these values may not even be defined by the algorithm producing the field function. We illustrated this problem further in the twodimensional case with the diagram of <ref type="figure" target="#fig_0">Fig. 2</ref>. The values of the field function at the lattice points marked with white and black circles are selected so as to obtain an approximation to a given isocurve. The value of the field function at the lattice points marked with black and white squares are not necessarily specified and may simply take on some default value such as +1 or -1 or even zero in some applications. The labelled lattice points affect the approximation of the normal at the isocurve point between ( ) j i, and ( )</p><formula xml:id="formula_1">j i , 1 + :<label>(3)</label></formula><p>As can be observed from <ref type="bibr" target="#b2">(3)</ref>, the values of the field function at ( )</p><formula xml:id="formula_2">1 , 1 + + j i , ( ) j i , 2 + , ( ) j i , 1 − and ( ) 1 , − j i</formula><p>do not affect the isocurve, yet they would be used in the Zucker/gradient calculation of the normal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">COMPUTING THE TRIANGULAR GRID TOPOLOGY AS PART OF THE MARCHING CUBES ALGORITHM</head><p>We use the notation defined in <ref type="figure" target="#fig_1">Fig. 3</ref> where</p><formula xml:id="formula_3">) 0 , 0 , 0 ( 0 = V , ) 1 , 0 , 0 ( 4 = V , ) 0 , 0 , 1 ( 1 = V , ) 1 , 0 , 1 ( 5 = V , ) 0 , 1 , 0 ( 2 = V , ) 1 , 1 , 0 ( 6 = V , ) 0 , 1 , 1 ( 3 = V , ) 1 , 1 , 1 ( 7 = V</formula><p>. The general approach of the mc algorithm is to first characterize a collection of representative configurations to which all possible cases can be mapped. A fixed triangulation is determined for each unique representative configuration and this triangulation is inferred on an arbitrary case by the inverse mapping. A decision has to be made as to what type of maps are allowed and what properties are to be used for characterizing representatives. We use only rotation maps. In the interest of reducing the number of representatives, some authors have used a richer collection of maps including also mirroring maps and complementation (with respect to above or below the isosurface threshold). While this is possible, special caution must be used so as not to produce erroneous results as was the case for "hole" problem of the original mc method (see <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b6">[7]</ref>).</p><p>If the value at one vertex on an edge is above the threshold and the value the other endpoint of the edge is below the threshold, then we know by linear interpolation that there is a point on the isosurface on this edge. This leads to a total of 256 ( = 2^8) cases. Many of these cases are equivalent in the sense that one can be rotated to the other. Under the operation of rotation maps these 256 cases collect themselves into a much smaller set of equivalence classes. There are 23 distinct equivalence classes. A </p><formula xml:id="formula_4">k j i n n n Triangles (i, j) (i+1, j) (i, j-1) (i, j+1) (i-1, j) (i+1, j+1) (i+2,j) (i+1,j-1) ( )             − + − + + − + − +             − − + − − + − + ≅ 2 ) 1 , 1 ( ) 1 , 1 ( 2 ) , ( ) , 2 ( ) ( 2 ) 1 , ( ) 1 , ( 2 ) , 1 ( ) , 1 ( ) 1 ( , j i F j i F j i F j i F i x j i F j i F j i F j i F x i j x N +x +z +y V 0 V 2 V 7 V 5 V 1 V 3 V 4 V 6</formula><p>representative of an equivalence class is called a configuration. In <ref type="figure" target="#fig_3">Fig. 4</ref> we show triangulations of these 23 configurations. Here, we have arbitrarily taken all ambiguous faces to be separated <ref type="bibr" target="#b6">[7]</ref>. There are 24 distinct rotations of a cube that map the 8 corner vertices onto themselves. In the following table we give the vertex permutations for each of these 24 rotations. The vertex permutations denote which vertex gets mapped to which position. For example, with R6, V 0 maps to <ref type="bibr" target="#b5">6</ref> . These rotation maps form a group. Any composition (one rotation followed by another) of two of these rotations will result in one of the other rotations and any rotation has an inverse.</p><formula xml:id="formula_5">V 1 , V 1 maps to V 5 , … , V 7 maps to V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1</head><p>Rotation group for the cube Each entry into the case/configuration table consist of a configuration which serves as the representer of the equivalence class to which this case belongs along with the rotation which makes them equivalent. For example, the entry for case 68 (0100 0100) would consist of rotation R13 and configuration C2. This means that case 68 will be rotated to configuration C2 with rotation R13. The triangles produced by Case 68 would be the same as those produced by configuration C2 except that the indices are replaced by the vertex permutations. That is, rather than the two triangles (P 4-6 , P 0-4 , P 1-5 ) and (P 4-6 , P 1-5 , P 5-7 ) the triangles (P 6-4 , P 7-6 , P 3-2 ) and (P 6-4 , P 3-2 , P 2-0 ) are produced because of the vertex replacement rules given by the vertex permutations of Rotation R13. This is done in the following manner. When we see P 1-5 , for example, we ask what got mapped to V 1 (answer is V 3 ) and what got mapped to V 5 (answer is V 2 ) and so we replace P 1-5 with P 3-2 . Here is another example. If we apply R4 to case 148, we get configuration C7. Configuration C7 says to produce the triangles: (P 4-6 , P 6-7 , P 2-6 ), (P 4-5 , P 1-5 , P 5-7 ), and (P 1-3 , P 2-3 , P 3-7 ). But rather, we use the vertex permutation rules and produce the triangles: (P 0-2 , P 2-6 , P 3-2 ), (P 0-4 , P 5-4 , P 4-6 ), and (P 5-7 , P 3-7 , P 7-6 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2</head><p>Case/configuration table If we are planning to produce a triangular grid structure for the isosurface rather than simply a collection of triple vertices, then the notation used for labeling the edges shown in <ref type="figure">Fig. 5</ref> and <ref type="figure">Fig. 6</ref> is helpful. These unique labels serve as pointers to the vertices of the triangular mesh surface. In fact the actual vertices do not need to be computed during this phase of the algorithm. If we use this type of approach, then, rather than the vertex permutations of the rotations, we need the edge mappings as given in Tabel 3.</p><p>To see how this works, we look again at one of the previous examples. This is the example where R4 is applied to case 148 to yield configuration C7. Configuration C7 says to produce the triangles: (001Y, 011X, 010Z), (001X, 100Z, 101Y) and (100Y, 010X, 110Z). But rather, we use the edge mapping rules and produce the triangles: (000Y, 010Z, 010X), (000Z, 001X, 001Y) and (101Y, 110Z, 011X) which for an arbitrary voxel i,j,k we would get the triangles (i,j,k.Y, i,j+1,k.Z, i,j+1,k.X), (i,j,k.Z, i,j,k+1.X, i,j,k+1.Y), (i+1,j,k+1.Y, i+1,j+1,k.Z, i,j+1,k+1.X).</p><p>A portion of voxel grid is shown in <ref type="figure">Fig. 7</ref> and in <ref type="table" target="#tab_3">Table 4</ref> there is a fragment of the triangular grid for the resulting isosurface from the mc algorithm.</p><p>We note that the following triangulations were assumed in creating <ref type="table" target="#tab_3">Table 4</ref> and <ref type="figure">Fig. 7</ref>. C1: (001X, 001Y, 000Z); C5: (100Y, 101Y, 000Y), (101Y, 001X, 000Z), (101Y, 000Z, 000Y); C14: (100Y, 101Y, 001X), (100Y, 001X, 010Z), (001X, 000Z, 010Z), (100Y, 010Z, 010X); C3: (001Y, 000Z, 001X), (011X, 101Y, 110Z). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 3</head><p>Edge Mapping <ref type="table" target="#tab_3">Table   Edge Mappings  R0  000X  010X  001X  011X  000Y  100Y  001Y  101Y  000Z  100Z  010Z  110Z  R1  001X  000X  011X  010X  000Z  100Z  010Z  110Z  001Y  101Y  000Y  100Y  R2  011X  001X  010X  000X  001Y  101Y  000Y  100Y  010Z  110Z  000Z  100Z  R3  010X  011X  000X  001X  010Z  110Z  000Z  100Z  000Y  100Y  001Y  101Y  R4  100Z  110Z  000Z  010Z  100Y  101Y  000Y  001Y  000X  001X  010X  011X  R5  001X  011X  000X  010X  101Y  001Y  100Y  000Y  100Z  000Z  110Z  010Z  R6  000Z  010Z  100Z  110Z  001Y  000Y  101Y  100Y  001X  000X  011X  010X  R7  000Y  100Y  001Y  101Y  010X  000X  011X  001X  010Z  000Z  110Z  100Z  R8  010X  000X  011X  001X  100Y  000Y  101Y  001Y  110Z  010Z  100Z  000Z  R9  100Y  000Y  101Y  001Y  000X  010X  001X  011X  100Z  110Z  000Z  010Z  R10  101Y  100Y  001Y  000Y  100Z  110Z  000Z  010Z  001X  011X  000X  010X  R11  011X  010X  001X  000X  110Z  010Z  100Z  000Z  101Y  001Y  100Y  000Y  R12  001Y  000Y  101Y  100Y  010Z  000Z  110Z  100Z  011X  001X  010X  000X  R13  110Z  100Z  010Z  000Z  101Y  100Y  001Y  000Y  011X  010X  001X  000X  R14  010Z  000Z  110Z  100Z  000Y  001Y  100Y  101Y  010X  011X  000X  001X  R15  100Y  101Y  000Y  001Y  110Z  100Z  010Z  000Z  010X  000X  011X  001X  R16  000X  001X  010X  011X  100Z  000Z  110Z  010Z  100Y  000Y  101Y  001Y  R17  000Y  001Y  100Y  101Y  000Z  010Z  100Z  110Z  000X  010X  001X  011X  R18  000Z  100Z  010Z  110Z  000X  001X  010X  011X  000Y  001Y  100Y  101Y  R19  001Y  101Y  000Y  100Y  001X  011X  000X  010X  000Z  010Z  100Z  110Z  R20  010Z  110Z  000Z  100Z  011X  010X  001X  000X  001Y  000Y  101Y  100Y  R21  110Z  010Z  100Z  000Z  010X  011X  000X  001X  100Y  101Y  000Y  001Y  R22  101Y  001Y  100Y  000Y  011X  001X  010X  000X  110Z  100Z  010Z  000Z  R23  100Z  000Z  110Z  010Z  001X  000X  011X  010X  101Y  100Y  001Y  000Y</ref> +x +z  </p><formula xml:id="formula_6">+y i,j+1,k.Z i,j,k+1.X i+1,j,k.Z i+1,j,k.Y i+1,j+1,k.Z i,j+1,k.X i,j,k.Z i,j,k.X i,j,k.Y i+1,j,k+1.Y i,j,k+1.Y i,j+1,k+1.X +x +z +y 010Z 001X 100Z 100Y 110Z 010X 000Z 000X 000Y 101Y 001Y 011X i,j+1,k.X i+2,j,k+1.X i,j,k.Z i+1,j,k.Y i+1,j+1,k+1.Y i,j+2,k+1.X i,j,k.X i+2,j+1,k.Y i+2,j+1,k.X i+1,j+2,k+1.X i+1,j,k.X i+3,j,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">NON-GRADIENT NORMAL ESTIMATES WITHOUT TRIANGULAR GRID TOPOLOGY</head><p>The basic idea of this method is to compute an estimate using the vertices of the isosurface that are connected to P through an edge of the triangles of the isosurface, except that we ignore points such as the one of <ref type="figure">Fig. 8</ref>  since this join to P is arbitrary and depends upon the particular triangulation of the isosurface used for each configuration. Except on the boundary voxels, there will always be exactly four vertices that connect to P with an edge on a voxel face. We denote these points as Px-, Px+, Py-, Py+. The point Px+ is in the same X-Z plane as P ( i.e. has the same y coordinate) and has an x-coordinate that is greater than <ref type="figure">Fig. 8</ref>. Notation. that of P. The point Px-is also in the same X-Z plane as P and has an x-coordinate that is less than that of P. The point Py-has the same x-coordinate as P and a y-coordinate, which is less than P. The point Py+ has a y-coordinate greater than P. These five points are then used to compute estimates of the normal at P. There are several reasonable and viable possibilities. In order to focus the attention on the basic ideas of our new method, we will only include results for the following, which we have found to be a good overall approach: The vertices Px-and Px+ are computed by linear interpolation along the edge that contains them. The appropriate edge is determined as follows:</p><formula xml:id="formula_7">N ++ = Normal</formula><formula xml:id="formula_8">If F i-1,j,k &lt; α then Px-∈ [i,j,k to i-1,j,k] else ( if F i-1,j,k+1 &lt; α then Px-∈ [i-1,j,k+1 to i-1,j,k] else Px-∈ [i-1,j,k+1 to i,j,k+1])</formula><p>If F i+1,j,k &lt; α then Px+ ∈ [i,j,k to i+1,j,k] else ( if F i+1,j,k+1 &lt; α then Px+ ∈ [i+1,j,k+1 to i+1,j,k] else Px+ ∈ [i+1,j,k+1 to i,j,k+1] )</p><p>For the points Py-and Py+ the process is entirely similar except we work in the other plane containing the edge of P; namely the plane with the same y-coordinate as P. <ref type="figure">Fig. 10</ref>. An aid to the computation of Py+ and Py-.</p><formula xml:id="formula_9">i,j,k+1 i,j,k Px- P Py - Py + Px+ i,j,k Px- P Px + i+1,j,k i-1,j,k i+1,j,k+1 i-1,j,k+1 Px+ Px+ Px- Px- i,j,k+1 i,j,k Py - P Py + i,j+1,k i,j-1,k i,j+1,k+1 i,j-1,k+1 Py+ Py + Py - Py - i,j,k+1</formula><formula xml:id="formula_10">If F i,j-1,k &lt; α then Py-∈ [i,j,k to i,j-1,k] else ( if F i,j-1,k+1 &lt; α then Py-∈ [i,j-1,k to i,j-1,k+1] else Py-∈ [i,j-1,k+1 to i,j,k+1] ) If F i,j+1,k &lt; α then Py+ ∈ [i,j,k to i,j+1,k] else ( if F i,j+1,k+1 &lt; α then Py+ ∈ [i,j+1,k to i,j+1,k+1] else Py+ ∈ [i,j+1,k+1 to i,j,k+1] )</formula><p>In the above discussion we have assumed that F i,j,k &gt; α and F i,j,k+1 &lt; α . The other case, where F i,j,k &lt; α and F i,j,k+1 &gt; α , is similar but we simply reverse the role of "&gt;" and "&lt;".</p><p>The other two cases where P is on an edge from i,j,k to i+1,j,k and P is on an edge from i,j,k to i,j+1,k are completely analagous to the above. Both lead to four additional points, which along with P are used for the local estimation of the normal vector. The cases where P is on a boundary edge are exceptional and there will only be three or two additional points used for the approximation. With the use of a marking flag and/or more elaborate data structures or labelling (as in Section 2), it is possible to compute only once (or even delay the computation) of the neighboring vertices leading to a more efficient implementation. However, we have found that a naïve implementation that computes vertices on demand often runs sufficiently fast for real time application. We have found this to be the case for field function resolutions &lt; 200^3 on a gigahertz PC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXAMPLES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1.</head><p>Our first example is based upon a point cloud of data values. A surface is fit to this point cloud. In this approach a field function is found so that its zero level isosurface is the approximating surface. We do not describe the method of fitting as the details are not of interest here, but it is similar in spirit to the methods of <ref type="bibr" target="#b0">[1]</ref> but with different basis functions <ref type="bibr" target="#b3">[4]</ref>. So that we can test our new method, we choose the point cloud from a known surface. The surface is the graph of the function <ref type="bibr" target="#b3">(4)</ref> The data points and the true normals are shown in <ref type="figure" target="#fig_9">Fig. 11</ref>.a. In <ref type="figure" target="#fig_9">Fig.11</ref>.b and 11.c, we show the isosurface of a field function designed so as to yield the graph of (4) as an isosurface. The method is intended to only give an approximation, but in this case the results are quite good and it would be difficult to distinguish from the graph of (4). In <ref type="figure" target="#fig_9">Fig. 11.d, we</ref> show the results of the new method described in Section 3. The results of the method of Section 2 are indistinguishable from those of <ref type="figure" target="#fig_9">Fig. 11.d</ref>. In <ref type="figure" target="#fig_9">Fig.  11</ref>.e we have the results of the Zucker/gradient method described in the introductory section. These results are poor, particularly near the "neck" of the graph. The purpose of the image of <ref type="figure" target="#fig_9">Fig.  11</ref>.f is to show that the field function is locally supported. We change the threshold a little and the isosurface changes dramatically. The algorithm that produced this isosurface was only concerned with ensuring that the graph of (4) was the zero threshold isosurface and lattice values, which do not affect this, are not of much concern. Since we can compute the true value of the normals from the test function, we can compare the RMS error for the three methods: This example is similar to the previous one except that the point cloud is obtained by scanning an object. An LDI scanner was used. It works similar to a conventional digital camera except that we also get a pixel array of distance values. Various scans were taken and later registered. The data is rather noisy due somewhat to the method of registration. In <ref type="figure" target="#fig_0">Fig. 12a</ref>, a photo of the actual object is shown. In <ref type="figure" target="#fig_0">Fig. 12</ref>.b the data is shown overlaid on a surface so that it can be perceived better. <ref type="figure" target="#fig_0">Fig. 12</ref>.c shows a rendering based upon the Zucker/gradient approach to computing normals and in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.</head><p>For this example, a surface is given and the field function is determined so as to yield this specified surface as an isosurface. In this application, the field function is the signed distanced to the surface. The field function is only computed at lattice points close to the surface. Once the field function is determined, it is an easy matter to apply triple tensor product wavelet operators to obtain multiresolution approximations. Since it is not clear how to use wavelet approximations directly for general triangular mesh surfaces, this simple approach is rather appealing. Here the Daubechies wavelets, D 4 , are used (see <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b2">[3]</ref> ). We do not further explain these approximations because that is not the point of this example in this context. The point is to illustrate how the conventional Zurcker/gradient approach can give bad results for some applications and our new method gives much improved results at approximately the same computational cost. In <ref type="figure" target="#fig_1">Fig. 13</ref>, we show three levels of approximation to a given surface. The top images use the Zucker/gradient method for computing normals and the bottom images use our new method as described in Section 3. The difference and consequently the improvement is more pronounced at the higher resolution models, but there are significant improvements at all levels.</p><p>( ) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSIONS</head><p>We have presented new methods for computing the estimates of normal vectors for the vertices of a triangular mesh surface approximation to an isosurface computed by the mc algorithm. The methods are designed for applications where the conventional Zucker/gradient methods can give poor results such as the case where the field function is only defined at lattice points near to the isosurface. Our new methods are easy to implement, efficient and give good results. Our new methods only work in the context of the mc algorithm and therefore should not be confused with other methods for estimating normals, for example, methods that estimate the normals of point cloud data <ref type="bibr" target="#b4">[5]</ref>. In Section 2, we described a method for computing the triangular grid topology as part of the mc algorithm. In Section 3, we described a method with results similar to that of Section 2, but without the explicitly computing the triangular grid topology. In this paper, we have focused on estimating normals for Gouraud shading and our interest in the topology provided by the triangular grid structure of Section 2 is based upon this. But there is certainly independent interest in computing this topology and so the techniques of Section 2 should have much broader interests than the topic of focus for this paper.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Diagram showing problems with gradient estimate methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>The unit cube and notation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Triangulations of the configurations of the mc algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>11 13:17 12:14 9:17 23:16 14:20 12:12 1:15 19:16 18:19 3:16 12:19 3:18 811 11:12 2:16 2:9 23:17 2:15 6:19 2:14 6:16 15:16 2:18 0:17 6:20 3:19 6:21 10:5 10:12 10:14 16:16 2:11 22:16 20:16 0:18 11:9 11:15 7:17 10:19 6:17 20:19 4:20 0:21 1:8 3:17 17:17 2:20 15:17 17:20 19:19 14:21 16:17 2:19 15:20 2:21 3:20 5:21 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Edge labeling for voxel i,j,k. Edge labeling for generic voxel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>of triangle: (P, Py+, Px+) N -+ = Normal of triangle: (P, Px-, Py+) N --= Normal of Triangle: (P, Py-, Px-) N +-= Normal of Triangle: (P, Px+, Py-) N P = N ++ /||N ++ || + N -+ /||N -+ || + N --/||N --|| + N +-/||N +-|| N P = N P /||N P || Fig. 9. Illustrating the computation of Px-and Px+.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Fig. 12.d we have a rendering based upon the normals computed by the new method of Section 3. Again, we do not show the local average method of Section 2 as it is indistinguishable from the image of Fig. 12.d. As in Example 1, we see that the same dark flaws in the Zucker/gradient method, particularly behind the left ear and on the face of the left bust support. These artefacts are not present in the rendering based upon the new method of Section 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 .</head><label>11</label><figDesc>by New Method of Sec. 3 e. Zucker/Gradient Method f. Isosurface Threshold on 1.0 Example 1. An isosurface with local support showing the problems with the Zucker/gradient method and the improvements of the new method of Section 3. a. Actual Object b. Data Overlaid on Surface c. Zucker/Gradient Normals d. New Method for Normals Fig. 12. Example 2. a. 64X64X64, Zucker/Gradient c. 32X32X32, Zucker/Gradient e. 16X16X16, Zucker/Gradient b. 64X64X64, New Method d. 32X32X32, New Method f. 16X16X16, New Method Fig. 13. Example 3. Surface defined as isosurface of signed distance function and wavelet approximations applied to the field function and the subsequent isosurface extracted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 A</head><label>4</label><figDesc></figDesc><table><row><cell cols="4">fragment of the triangular grid representation of the</cell></row><row><cell></cell><cell cols="2">isosurface of fig. 7</cell><cell></cell></row><row><cell cols="3">List of triple pointers defining the</cell><cell>Notes</cell></row><row><cell cols="3">triangular grid structure</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell cols="2">i+1,j+1,k.Z i+1,j,k.Y</cell><cell>i,j+1,k.X</cell><cell>i,j,k; case 8, R14:C1</cell></row><row><cell>i+2,j+1,k.Z</cell><cell>i+2,j,k.Z</cell><cell>i+1,j+1,k.Z</cell><cell></cell></row><row><cell>i+2,j,k.Z i+2,j,k.Z</cell><cell>i+1,j,k.X i+1,j,k.Y</cell><cell>i+1,j,k.Y i+1,j+1,k.Z</cell><cell>i+1, j,k, case 14, R3:C5</cell></row><row><cell cols="3">i+3,j,k.Y i+3,j,k+1.Y i+2,j,k+1.X</cell><cell></cell></row><row><cell cols="3">i+3,j,k.Y i+2,j,k+1.X i+2,j+1,k.Z i+2,j,k+1.X i+2,j,k.Z i+2,j+1,k.Z</cell><cell>i+2, j, k case 39, R0:C14</cell></row><row><cell cols="3">i+3,j,k.Y i+2,j+1,k.Z i+2,j+1,k.X</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell cols="3">i+1,j+2,k.Z i,j+2,k+1.X i+1,j+1,k+1.Y</cell><cell>i, j+1, k case 130,</cell></row><row><cell cols="2">i+1,j+1,k.Y i+1,j+1,k.Z</cell><cell>i,j+1,k.X</cell><cell>R12:C3</cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row><row><cell>.</cell><cell>.</cell><cell>.</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5</head><label>5</label><figDesc></figDesc><table><row><cell cols="2">RMS Errors of true normal verses approximation</cell></row><row><cell>Zucker/gradient Method</cell><cell>0.043</cell></row><row><cell>Local average method of Section 2</cell><cell>0.009</cell></row><row><cell>New method of Section 3</cell><cell>0.013</cell></row><row><cell>Example 2.</cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We wish to acknowledge the support of the Office of Naval Research (N00014-97-1-0243 &amp; N00014-00-1-0281 &amp; N00014-02-1-0287), the National Science Foundation ( NSF IIS-9980166 &amp; ACI-0083609) and DARPA ( MDA972-00-1-0027). The bunny data is from Stanford.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Reconstruction and Representation of 3D Objects with Radial Basis Functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Beatson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Cherrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Fright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C R</forename><surname>Mccallum &amp; T</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Evans</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="67" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Orthonormal bases of compactly supported wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Daubechies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. Pure Appl. Math</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="909" to="996" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Integrated Volume Rendering and Data Analysis in Wavelet Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<editor>Scientific Visualization (Nielson, Hagen &amp;</editor>
		<imprint>
			<date type="published" when="1997" />
			<publisher>IEEE Computer Society Press</publisher>
			<biblScope unit="page" from="149" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Generating Triangular Surface Meshes from Large Sets of Unorganized 3D Points</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Th</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Brunnett</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<title level="m">Surface reconstruction from unorganized points, SIGGRAPH &apos;92</title>
		<imprint>
			<biblScope unit="page" from="123" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;87 Proceedings</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Asymptotic Decider: Resolving the Ambiguity in Marching Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="83" to="91" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
