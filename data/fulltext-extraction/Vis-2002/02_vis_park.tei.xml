<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Case Study: Interactive Rendering of Adaptive Mesh Refinement Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanghun</forename><surname>Park¡</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ccv</forename><surname>Ticam</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandrajit</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinay</forename><surname>Siddavanahalli</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Sciences</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Sciences</orgName>
								<orgName type="institution" key="instit1">CCV TICAM</orgName>
								<orgName type="institution" key="instit2">University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Case Study: Interactive Rendering of Adaptive Mesh Refinement Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques-Interactive Techniques</term>
					<term>Graphics Data Structures and Data Types; I.3.8 [Computer Graphics]: Applications AMR</term>
					<term>K-d trees</term>
					<term>Octree</term>
					<term>Hierarchical splatting</term>
					<term>Texture mapping</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Adaptive mesh refinement (AMR) is a popular computational simulation technique used in various scientific and engineering fields. Although AMR data is organized in a hierarchical multi-resolution data structure, the traditional volume visualization algorithms such as ray-casting and splatting cannot handle the form without converting it to a sophisticated data structure. In this paper, we present a hierarchical multi-resolution splatting technique using k-d trees and octrees for AMR data that is suitable for implementation on the latest consumer PC graphics hardware. We describe a graphical user interface to set transfer function and viewing / rendering parameters interactively. Experimental results obtained on a general purpose PC equipped with NVIDIA GeForce card are presented to demonstrate that the technique can interactively render AMR data (over 20 frames per second). Our scheme can easily be applied to parallel rendering of time-varying AMR data.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Adaptive mesh refinement (AMR) is a computational technique for improving the efficiency of numerical simulations of systems of partial differential equations. After Berger and Oliger <ref type="bibr" target="#b1">[2]</ref> developed AMR in 1980s to simulate gas dynamics, it has become a popular technique in computational physics and various engineering fields. The basic idea of AMR is to refine, both in space and in time, regions of the computational domain where high resolution is needed to resolve developing features, while leaving the less interesting parts of the domain at lower resolutions. AMR techniques have been shown to be very successful in reducing the computational and storage requirements for solving many partial differential equations and used in various engineering applications where there are regions of greater interest such as global atmospheric modeling and numerical cosmology. For example, Bryan <ref type="bibr" target="#b2">[3]</ref> shows how a hybrid approach of AMR can be applied to cosmological research.</p><p>Although AMR data has a hierarchical multi-resolution structure, it is impossible for traditional visualization techniques developed for simple mesh data to handle AMR data without any modification. Relatively few results have been presented on visualization of AMR data. Norman et al. <ref type="bibr" target="#b5">[6]</ref> presented problems and solutions ¢ e-mail:hun@ticam.utexas.edu † e-mail:bajaj@cs.utexas.edu ‡ e-mail:skvinay@cs.utexas.edu in storing, handling, visualizing, virtually navigating, and remoteserving data produced by large-scale AMR simulations. Weber et al. <ref type="bibr" target="#b7">[8]</ref> introduce crack-free isosurface extraction methods from AMR data. They also present a hardware-accelerated rendering interface for previewing and cell-projection based progressive refinement rendering scheme in <ref type="bibr" target="#b6">[7]</ref>. In another paper <ref type="bibr" target="#b8">[9]</ref>, they render AMR data using the progressive cell-projection approach and leveldependent transfer function. Even though their method can produce high quality images, it takes about 23£ 115 seconds to render one image from an AMR data with a 80 ¤ 32 ¤ 32 root-grid resolution and a three-level hierarchy.</p><p>In this paper, we describe a hierarchical multi-resolution splatting of AMR data. Our main contributions are the design and implementation of The rest of this paper is organized as follows. Section 2 presents the implementation details of our scheme. Section 3 contains the results of our techniques regarding rendering time, image quality, and graphical user interface. Finally this paper is concluded in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">IMPLEMENTATION DETAILS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">K-d Trees</head><p>A k-dimensional (k-d) tree is a data structure that splits multidimensional spaces. It is used in computer sciences during orthogonal range searching. It allows us to find the set of voxels that fall within a given block or brick in a space. Given a k-d tree of voxels, it is possible to find the resulting voxels in O¦ § n © k where n is the number of voxels and k is the number of voxels in the result. An AMR simulation algorithm generates a grid hierarchy data structure (a tree of arbitrary structure and depth) and every node and leaf of the tree is associated with a 3D grid. Since these have various shapes, sizes, and spatial resolutions, we need to convert this form to a sophisticated data structure.</p><p>AMR data is represented by</p><formula xml:id="formula_0">f t l v ¦ i j k</formula><p>where t is the timestep of time-varying AMR data, l is the refinement level and v is the index of function values. To convert the data to a k-d tree structure, the first step is to determine the minimum bounding boxes surrounding each group in the AMR data space. The voxels included in a group are connected in spatial resolution of the current level and each group may include several levels of AMR data. In the next stage, our scheme splits the bounding boxes into a set of bricks using a modified k-d tree algorithm. The generated bricks have pointers to actual function value sets in each level. As we mentioned, a k-d tree is not only useful for rendering, but also for storing AMR data hierarchically. In fact, the raw form of AMR data is a list of records that consist of a voxel index</p><formula xml:id="formula_1">¦ i j k , some function values f t l v</formula><p>, and a level l. Replacing the raw AMR data format with a k-d tree is very efficient in that it contains hierachical, multiresolution structures and we don't have to store the voxel indices any more. <ref type="figure" target="#fig_2">Figure 1</ref> shows the partition result of test AMR data using a k-d tree. To exploit spatial coherence, our scheme constructs an octree structure for relatively large bricks. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Hierarchical Splatting</head><p>Splatting is an object space direct volume rendering algorithm that generates high quality images <ref type="bibr" target="#b9">[10]</ref>. A voxel's contribution is mapped directly onto the image plane, eliminating the need for interpolation. Since only interesting voxels (weighted by the discrete voxel values) are required to be represented by a 3D kernel, it is possible to generate the final images at interactive speed. Splatting has been used in the past to handle hierarchical error and higher dimension rendering <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b0">1]</ref>. This techniques allow us to render different level data sets using footprints of various sizes. By projecting the footprint to a polygon, we can exploit OpenGL 2D texture mapping hardware. Crawfis et al. propose to render each splat using texture mapping hardware <ref type="bibr" target="#b3">[4]</ref>. This technique alleviates the CPU from the computational complexity incurred in resampling the footprint tables and compositing each splat into a frame buffer. In our algorithm, the rendering of a selected range of isovalues, together with a transfer function is performed through splatting. While the k-d tree data structure provides an accelerated search algorithm for bricks, we further optimize our algorithm through the use of octrees at each node of the k-d tree. Each brick is represented as an octree of voxels. Each voxel is then projected by transforming its position from world coordinates to screen coordinates.</p><p>In each brick and octree, we store an isovalue code to ensure that only relevant volumes are considered for the search algorithm. This isovalue code is implemented as a 32-bit number, each bit representing the presence or absence of a range of isovalues. As a preprocessing step, we compute and store the binary code. It is computed for each level of the octree. We traverse through all voxels contained in a leaf and determine the bits in the code to be turned on to indicate the presence of at least one voxel in that range. If there are n bits for the code, and we have a range of r for the voxels in the whole volume, then each bit covers a range of r n . Once we have obtained the code for each leaf, we recursively obtain the code for a node as the boolean OR of the codes of its children. The code of an octree's root is assigned to the brick containing the octree. This procedure is used for each function in the vector field. We do not perform weighting for this code. For example, we do not assign fewer bits to non-interesting regions, hence assuming the en- Splatting(Bi, lod) 7</p><p>Composite the current partial image 8 } 9 Display final image <ref type="figure">Figure 2</ref>: K-d tree based splatting algorithm tire range to be of equal interest to user. An OR operator is used to build a search code when the user changes the range of important isovalues. A simple AND operator is sufficient to eliminate those sub-volumes whose codes do not fall under the currently selected range of isovalues. This is implemented at both the brick level and the octree level. Within an octree, each child that is not NULL contains such a code to help its traversal. We found this method to be considerably faster than storing min-max values. A second useful feature of the octree is the fast and natural ordering of voxels that it provides to obtain high quality images quickly. We sort bricks for each view from the k-d tree.</p><p>We have implemented a color table to be used as lookup for the transfer function. An interactive selection of opacity values for different isovalues is used. This is also extended to handle vector valued data. <ref type="figure">Figure 2</ref> shows our rendering algorithm for splatting of AMR data. Since creating k-d trees and octrees of the given AMR data (line 2) can be done at the preprocessing stage, they don't affect the actual run-time rendering speed. Once a k-d tree is created, the brick list BL can be efficiently determined by traversing the k-d tree depending on the viewing direction (line 4). In this step, the bricks that don't contain any interesting voxels are not included in the brick list. A single bitwise AND operation is needed for checking whether the brick will be rendered or not. Then, splatting is applied to each brick B i in the sorted list of relevant bricks and the generated partial images are composited to form a final image (lines 6 and 7). Since the nodes in the brick list have pointers to function values corresponding to several levels, the rendering level of detail lod should be chosen and a proper transfer function and footprint size should be used according to the lod. As we mentioned, it is possible to accelerate the performance of the lines 6 and 7 by texture mapping hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Algorithm</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>Our splatting technique was implemented on a PC, equipped with a 800 MHz Intel Pentium III Processor, 256MB main memory and a graphics card with an NVIDIA GeForce3 processor and 64MB of memory. To test our proposed algorithm, we implemented a program in OpenGL with GLUT.</p><p>Our test data is the result from a simulation of a radiative jet colliding with a dense cloud. The simulation result is stored in AMR format with a 64 varying AMR data using our technique respectively. Using a k-d tree data structure, we are able to effectively limit the search space. As described before, the bricks have a code representing the range of isovalues contained in the brick. This helps us to achieve considerable performance. The octree structure at each brick of the k-d tree helps to further limit the search space. It was observed that a maximum octree width of 8 was quite efficient when the number of voxels was greater than 40,000 to 50,000. Less dense volumes performed well with an octree size of 4. We show the results comparing the performance due to addition of the octrees and also compare the performance using 4, 8, and 16 as the maximum octree width. <ref type="figure">Figure 5</ref> shows the ratios of searched voxels and search gains resulted from rendering the time-varying image sequence in <ref type="figure">Figure 3</ref>.</p><p>Nearly interactive frame rates were achieved using our implementation. Although considerable gains in limiting the search space was achieved with smaller octree width values, the search time became a bottleneck. We give both the gain in the search space limitation and the speed of rendering as comparison with different octree widths. <ref type="figure" target="#fig_4">Figure 6</ref> shows the resulting rendering speeds and gains from generating the images of <ref type="figure">Figure 3</ref>. We define search gain and rendering gain as follows:</p><formula xml:id="formula_2">search gain = η without " η with η without , rendering gain = τ without " τ with τ without</formula><p>where η without and η with are the number of voxels searched without and with octree, respectively, similarly, τ without and τ with are the rendering speeds without and with octree, respectively.</p><p>The data structure combination of k-d trees and octrees result in interactive rendering of data sets as large as 64 ¤ 64 ¤ 128 with highest resolutions. While we get very fast selection of regions in space where relevant voxels exists with our k-d trees, the octree further improves search time and gives a natural ordering of voxels for any view direction. Although the relevant bricks of the k-d tree are sorted for every viewing change, it does not prove to be a bottleneck due to the limited number of selected bricks. This is particularly true of volumetric data, where the region of interest is <ref type="figure">Figure 7</ref>: The graphical user interface for interactive rendering usually not dense throughout the object space. Hence we have partially solved the problem of quickly obtaining an ordering on the rendering primitives. This gives us significantly faster rendering speeds. <ref type="figure">Figure 7</ref> shows the graphical user interace desiged for interactive rendering. Users can set transfer function, rendering and viewing parameters through the interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSIONS AND FUTURE WORK</head><p>We presented a hierarchical multi-resolution splatting scheme to render AMR data interactively. Our technique constructs a k-d tree and octrees from AMR data during preprocessing. The data structures are used effectively for rendering and storing the data. Our technique takes advantage of hardware accelerated 2D texture mapping supported by NVIDIA GeForce card in implementing an interactive splatting algorithm. We designed a graphical user interface to allow users to select various viewing / rendering parameters  An important challenge is to apply our scheme to parallel rendering of AMR data. Our k-d tree based splatting scheme has a good structure to be extended to parallel rendering. The view dependent brick list can be considered as a task pool. Assume that there is a master processor and several slave processors for this parallel scheme. The master processor assigns a task to a proper slave processor and composites partial images from slave processors according to a sorted brick order. Each slave processor loads the assigned bricks, creates partial images using splatting, and then sends them to the master processor. Another challenge is to implement an encoding and rendering method exploiting temporal coherence for time-varying AMR data. If we develop lossless or lossy compression techniques, the data can be stored in compact forms and thus rendering speed to produce videos for analyzing time-varying data can be enhanced. Finally, we can consider combining images generated from simultaneously rendering AMR and geometric models. For example, we can create an animation such that a spaceship model navigates a cosmology AMR data space. Since AMR data space is partitioned by a k-d tree, the brick that includes the spaceship can be easily detected.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>¥ k-d tree and octree data structures for hierarchical storing and rendering of AMR data; ¥ a hardware accelerated splatting algorithm for interactive rendering of AMR data; ¥ a graphical user interface for determining transfer function and viewing / rendering parameters interactively;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>IEEE</head><label></label><figDesc>Visualization 2002 Oct. 27 -Nov. 1, 2002, Boston, MA, USA 0-7803-7498-3/02/$17.00 © 2002 IEEE</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Different views of splitting AMR data space into a set of bricks in k-d tree structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>¤ 64 ¤Figure 3 :Figure 4 :</head><label>6434</label><figDesc>128 finest-grid resolution and a four-level hierarchy (0l 3). Fifteen function values are given at the nodes of the mesh in floating point format (0 v 14). We scaled the values to range from 0 to 4095. Interesting values include energy density (v 0), mass density (v 4), electron density (v 6), and so on. The image sequences in Figure 3 and 4 were generated from (Images generated from mass density (v 4) of test time-varying data (a) t Images generated from electron density (v 6) of test time-varying data mass density and electron density function values of the test time-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Rendering speeds and rendering gains in the finest level as well as a transfer function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>1</head><label></label><figDesc>Load AMR data 2 Create k-d tree and octree data structure 3 Set current transfer function and viewing / rendering parameters 4 Determine brick list BL according to viewing direction 5 For (Bi in BL) { 6</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was supported in part by NSF grants ACI-9982297, CCR-9988357, a DOE-ASCI grant BD4485-MOID from LLNL/SNL and from grant UCSD 1018140 as part of NSF-NPACI, Interactive Environments Thrust, and a grant from Compaq for the 128 node PC cluster. We thank Marcelo Alvarez and Prof. Paul Shapiro of the Galaxy Formation and Intergalactic Medium Research Group, University of Texas at Austin for allowing us to use the AMR test data. The data was from a workshop hosted by Alejandro C. Raga in Mexico City in 2002.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Hypervolume visualization: A challenge in simplicity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Rabbiolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE/ACM 1998 Symposium on Volume Visualization</title>
		<meeting>IEEE/ACM 1998 Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Adaptive mesh refinement for hyperbolic partial differential equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Oliger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Physics</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="484" to="512" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fluids in the universe: adaptive mesh refinement in cosmology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Bryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing in Science &amp; Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="46" to="53" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Texture splats for 3D scalar and vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization&apos;93</title>
		<meeting>IEEE Visualization&apos;93</meeting>
		<imprint>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="261" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hierarchical splatting: a progressive refinement algorithm for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="285" to="288" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Diving deep: data-management and visualization strategies for adaptive mesh refinement simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Daues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing in Science &amp; Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="36" to="47" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Visualization of adaptive mesh refinement data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Ligocki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Shalf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SPIE (Visual Data Exploration and Analysis VIII)</title>
		<meeting>the SPIE (Visual Data Exploration and Analysis VIII)</meeting>
		<imprint>
			<date type="published" when="2001-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Extraction of crack-free isosurfaces from adaptive mesh refinement data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kreylos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Ligocki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint EUROGRAPHICS and IEEE TCVG Symposium on Visualization</title>
		<meeting>the Joint EUROGRAPHICS and IEEE TCVG Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2001-05" />
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">High-quality volume rendering of adaptive mesh refinement data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kreylos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Ligocki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Fall Workshop on Vision, Modeling, and Visualization</title>
		<meeting>the 6th International Fall Workshop on Vision, Modeling, and Visualization</meeting>
		<imprint>
			<date type="published" when="2001-11" />
			<biblScope unit="page" from="121" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Footprint evaluation for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="367" to="376" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
