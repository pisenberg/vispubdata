<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast View-Dependent Level-of-Detail Rendering Using Cached Geometry</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Levenberg</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California at Berkeley</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fast View-Dependent Level-of-Detail Rendering Using Cached Geometry</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation-Viewing Algorithms</term>
					<term>I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-Geometric Algorithms, Object Hierarchies</term>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Virtual Reality view-dependent mesh, level of detail, height fields, terrain, binary triangle trees, triangle bintree, multiresolution meshes, displacement maps, frame-to-frame coherence</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: (a) shows an example of a 2049 × 2049 height field rendered with aggregate triangles; (b) shows the triangles used to render (a); (c) is a top view of the view frustum with aggregate triangles in black. The same aggregate triangle is highlighted in (b) and (c).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The goal of geometric level-of-detail rendering algorithms is to adjust the geometry of rendered objects for improved detail and performance. Greater realism is achieved by adding geometric detail to close and important objects. Performance is improved by simplifying objects far from the camera. Level-of-detail algorithms can be essential for realizing very large worlds. They can be used to control the total amount of geometry in a scene. They can also help meet fixed performance goals under varying conditions (such as running on different machines).</p><p>To make the best use of available resources, a level-of-detail algorithm should be view-dependent. That is, it should tailor the rendered geometry to the location of the view point, on a frame-byframe basis. The algorithm should have fine-grained control over the geometry so that changes in the level of geometric detail are not objectionable. These desires tend to be at odds with keeping geometry static so that it may be cached <ref type="bibr" target="#b22">[23]</ref>.</p><p>Consumer graphics hardware has improved dramatically, doubling in speed every six months and now integrates the full rendering pipeline. Recent fine-grained level-of-detail algorithms generate a new mesh every frame. This requires a great deal of CPU power and has become a major bottleneck. Consequently, graphics board manufacturers have in recent years been discouraging the use of all but the simplest level-of-detail algorithms.</p><p>Our goal is to describe a level-of-detail algorithm appropriate for commercial applications. As such, it needs to be able to take advantage of video hardware available to consumers now and in the future. Further, it should be adaptable to give acceptable performance on older machines. A desirable level-of-detail rendering algorithm would:</p><p>• reduce CPU workload without a large increase in the number of triangles needed to achieve a given error rate, • be adjustable to take advantage of the relative performance of the video card and CPU, and • dynamically adjust the mesh based on the view point in order to render as quickly as possible without visible errors.</p><p>The starting point for meeting these goals is an existing viewdependent level-of-detail algorithm that outputs triangles. However, we modify the algorithm to manage collections of geometry called aggregate triangles, instead of individual triangles. These aggregate triangles may then be cached on the video card. This has several benefits, including:</p><p>• improving transformation performance: the graphics subsystem operates more efficiently in retained mode than immediate mode • takes advantage of temporal coherence: changes between frames are localized, and there is little or no processing for triangles in the unchanged areas • reducing stalls in the graphics pipeline: cached data can be processed directly by the video card without delays</p><p>In order to realize the benefits of caching, a level-of-detail algorithm must incrementally modify small fractions of the mesh each frame. Further, the CABTT algorithm needs to include a strategy that ensures adjacent aggregate triangles match up without Tjunctions. This strategy ideally allows an aggregate triangle to use the same geometry regardless of the detail level of adjacent aggregate triangles.</p><p>Binary triangle trees (BTTs, also called triangle bintrees <ref type="bibr" target="#b6">[7]</ref>, right triangular irregular networks <ref type="bibr" target="#b8">[9]</ref>, or, in finite elements, newest-vertex-bisection <ref type="bibr" target="#b23">[24]</ref>) are ideally suited to represent meshes for the CABTT (Cached Aggregated Binary Triangle Trees) algorithm. BTTs use a single shape, the right isosceles triangle, and have a refinement rule that keeps the mesh crack-free. This simple structure means a straightforward policy will ensure aggregate triangles abut without T-junctions. Contrast this with red-green triangulations <ref type="bibr" target="#b0">[1]</ref> which have two different refinement rules and use two different shapes. The ROAM <ref type="bibr" target="#b6">[7]</ref> algorithm uses BTTs to incrementally update a mesh from frame to frame.</p><p>Previous algorithms have difficulty maintaining interactive frame rates at high detail levels. The CABTT algorithm not only scales well, but also balances the workload between the video card and CPU to achieve good performance on a wide variety of machines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PAST WORK</head><p>There is a very large field of level-of-detail algorithms, but real-time view-dependent algorithms are relatively recent <ref type="bibr" target="#b22">[23]</ref>.</p><p>There are several level-of-detail techniques applicable to general meshes <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b31">32]</ref>. While able to use relatively few triangles to approximate a mesh, they generally are expensive in time or memory and do not scale to high detail levels.</p><p>Some height field level-of-detail algorithms use Delaunay triangulations <ref type="bibr" target="#b5">[6]</ref>. View-dependent progressive meshes have been specialized to the terrain case <ref type="bibr" target="#b14">[15]</ref>, allowing a very general class of meshes, and generally achieve higher accuracy per given triangle count.</p><p>Regular subdivision meshes have been more popular in recent years. These allow simpler and faster processing at the expense of an increase in the number of triangles needed to achieve the same error threshold. Restricted quadtree triangulations <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref> were among the first used. They use a similar but somewhat less flexible class of meshes as BTTs. In particular, the coarsest mesh representable is finer for restricted quadtrees and they are less applicable to non-height-field models.</p><p>Binary triangle trees have seen a lot of recent research interest <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b26">27]</ref>. While typically used to render height fields, they may be used to render any base mesh with an offset map <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b23">24]</ref>. Blow <ref type="bibr" target="#b3">[4]</ref> gave a method of reducing error metric computation for high detail meshes. Lindstrom and Pascucci <ref type="bibr" target="#b19">[20]</ref> described a cache-friendly vertex indexing scheme. RUSTiC <ref type="bibr" target="#b26">[27]</ref> has triangle clusters very similar to our aggregate triangles, though with much greater memory cost than the approach presented here.</p><p>We maintain a crack-free mesh using split and merge operations that incrementally modify the mesh without introducing Tjunctions, as in ROAM <ref type="bibr" target="#b6">[7]</ref>. Another approach to maintain a crackfree mesh <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b27">28]</ref> adjusts the error metric so that adjacent triangles in the mesh differ by at most one level of refinement. This increases the number of triangles rendered but allows rendering to be done in a single pass and does not require temporal coherence.</p><p>Some previous algorithms deal with blocks of geometry <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b20">21]</ref>, typically as a starting point for view-dependent simplifications. RUSTiC <ref type="bibr" target="#b26">[27]</ref> uses triangle clusters to reduce CPU bottlenecks, though it does not perform any caching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">REVIEW OF BINARY TRIANGLE TREES</head><p>Binary triangle trees are typically used to represent terrain, given as a (2 n + 1) × (2 n + 1) regular grid of height field data. More generally, BTTs can represent a base mesh with a displacement map or offset map (such as from a remeshing algorithm <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b24">25]</ref>). In the case of a height field, the base mesh is a square divided into two right triangles. At the other end of the spectrum, the full mesh is the most detailed mesh.</p><p>While this paper focuses on BTTs representing height fields, the techniques are equally applicable to more general meshes.</p><p>A binary triangle tree represents a mesh of binary triangles satisfying certain rules. Each binary triangle corresponds to a right isosceles triangle in the grid of offset data. For the specific case of a height field, the projection of any binary triangle onto a horizontal plane is a right isosceles triangle. The hypotenuse or base of the triangle can only abut either the base of a triangle at the same level of detail (like triangles A and B in <ref type="figure">Figure 2</ref>) or the leg of a triangle one level coarser (triangles C and D in <ref type="figure">Figure 2</ref>).</p><p>Two triangles that meet base-to-base are called a diamond. A split divides each triangle of a diamond in two, as shown in <ref type="figure">Figure</ref> 3. This introduces a vertex in the middle of the base of the original two triangles. The inverse of this operation is called a merge. Also note that one can split a triangle whose base is part of the boundary of the mesh. <ref type="figure" target="#fig_2">Figure 4</ref> shows meshes corresponding to the first few levels of a binary triangle tree, formed by repeatedly splitting every triangle. The vertices in the base mesh are associ-   ated with grid positions 2 n apart to ensure that only vertices on the regular grid are generated in a 2n-level tree.</p><p>In order to refine a triangle that is not part of a diamond, we must split its base neighbor. This operation is called a force split. Note that this may recursively force other triangles to split, as in <ref type="figure" target="#fig_3">Figure 5</ref>. This operation always terminates, since a split can only force the split of a coarser triangle.</p><p>Rendering is a two-step procedure. First, the BTT from the previous frame is updated using splits and merges. These updates are determined by the error metric (see Section 5) and the current location of the view point. Second, the BTT is drawn using a simple recursive algorithm. We can easily perform hierarchical frustum culling as part of this traversal. We can traverse the BTT with a Sierpinski space-filling curve, enabling efficient triangle strip or triangle fan rendering.</p><p>To avoid lighting-related artifacts as geometric detail is modified, vertex lighting should be avoided. Per-pixel techniques such as bump maps <ref type="bibr" target="#b2">[3]</ref>, normal maps <ref type="bibr" target="#b4">[5]</ref>, or pixel shaders can be employed instead. Our implementation uses simple, baked-in lighting (fixed lighting included in the texture map) to avoid these problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">AGGREGATE TRIANGLES</head><p>An aggregate triangle is a collection of triangles that substitutes for a single binary triangle in a BTT. An aggregate triangle must therefore correspond to a right isosceles triangle in the grid of offsets. In the case of a height field, this means an aggregate triangle projects to a right isosceles triangle in the horizontal plane.</p><p>Instead of constructing a BTT to represent the triangulation of the terrain, we will construct a much shallower aggregated BTT dividing the terrain into aggregate triangles. We will cache the aggregate triangles, so it is important that the geometry (or subtriangulation) of each aggregate triangle remains fixed for several frames. When an area of an aggregated BTT needs to be refined, we replace a diamond of aggregate triangles with four aggregate triangles. This happens just like the split operation described in Section 3, except with aggregate triangles instead of triangles. The merge operation is analogous.</p><p>The number of triangles in the average sub-triangulation determines the granularity of these operations. Coarser granularity means fewer aggregate triangles to manage and fewer split and merge operations, but more data to upload to the video card every time a split or merge occurs. Also, coarser granularity will increase the number of triangles needed to meet a particular maximum error tolerance. By profiling, we can find the level of aggregation that performs best. This will vary depending on several factors including the relative performance of the CPU and video card.</p><p>We render an aggregated BTT much like a regular BTT (see Section 3). When splitting or merging, we must release the caches of the aggregate triangles we are replacing and upload the geometry for the new aggregate triangles. Then, when traversing the BTT, we simply render the caches associated with any on-screen aggregate triangle. As an optimization, the caching is performed during the drawing stage instead of the split and merge stage (see <ref type="figure" target="#fig_8">Figure 10</ref>). This avoids wasted work if more than one split or merge happens in same area of mesh. Even better, we also avoid wasting time uploading culled or off-screen geometry. When creating the sub-triangulations for aggregate triangles, we must ensure that adjacent aggregate triangles match up along their common boundaries. We have adopted the simple policy of uniformly subdividing all of the boundaries into a fixed number of segments (defining the aggregation level). This policy ensures continuity between adjacent aggregate triangles even when they are at different levels of detail. It isolates sub-triangulations from each other, so mesh operations are local and fast. Sub-triangulations may be generated on the fly with a minimal amount of pre-computed data (contrast with RUSTiC <ref type="bibr" target="#b26">[27]</ref> which pre-computes and stores all sub-triangulations).</p><p>The simplest sub-triangulation policy is to uniformly subdivide each aggregate triangle, as in <ref type="figure">Figure 6</ref>. That is, every aggregate triangle is subdivided the same way, except that the vertices are displaced according to the offset or displacement map. Typically, aggregate triangles will be subdivided using one of the patterns from <ref type="figure" target="#fig_2">Figure 4 (a)</ref>, (c), (e).</p><p>We may achieve a closer fit to the full mesh with an adaptive method of sub-triangulation (see <ref type="figure">Figure 1)</ref>. The CABTT algorithm creates a miniature BTT that represents a single aggregate triangle. It starts with a single binary triangle. It splits the triangle's boundary until it has the desired number of segments (see <ref type="figure">Figure 7)</ref>. We then apply additional splits to minimize the error metric (described in Section 5). This continues until we either reach a maximum number of triangles or we want to perform a split that would cause the boundary of the aggregate triangle to be further subdivided. This procedure is called SubTriangulation in <ref type="figure" target="#fig_7">Figures 9 and 10</ref>. Note that we can discard this BTT as soon as it has been uploaded to the In our tests, adaptive sub-triangulations reduced the number of triangles needed to achieve a particular error tolerance by as much as 50% over uniform sub-triangulations. Since the time to compute these sub-triangulations is modest, this almost doubles the frame rate.</p><p>In our test case, we achieved the best performance with aggregate triangles containing 16 segments in each edge. On average, these sub-triangulations would consist of 206 triangles. At this level of aggregation, at most 20% of these triangles are an overhead cost introduced by the boundary rule. That is, if we run the test without restrictions on the boundaries of the aggregate triangles, we achieve the same error tolerance with 20% fewer triangles (though with cracks in the mesh between adjacent aggregate triangles).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ERROR METRICS</head><p>We use an error tolerance τ (measured in pixels) to trade quality for speed. Lower τ corresponds to higher quality at reduced speed. We introduce splits anywhere the screen space error is larger than τ and merge when that does not introduce errors larger than τ . After describing the error metric, we will show how to adapt it to aggregated BTTs.</p><p>To determine when to split a triangle, we use Blow's isosphere error metric <ref type="bibr" target="#b3">[4]</ref>. Suppose we are given a triangle T with point C at the midpoint of its base (see <ref type="figure" target="#fig_5">Figure 8</ref>). We want to compute the distance D such that whenever the view point is at least D away from C, the rendering of T will be within τ pixels of the full mesh. T is split when the view point enters the sphere (an error isosphere) with center C and radius D.</p><p>Let K be the screen resolution divided by the tangent of the field of view. <ref type="bibr" target="#b0">1</ref> Let Pi be a point in the full mesh corresponding to the point Pt in T (for a height field, these points will be aligned vertically). Let d be the distance from the view point to Pi, 2 then we want to ensure that τ ≥</p><formula xml:id="formula_0">K |P t −P i | d</formula><p>. This equation is conservative -it assumes the triangle is viewed edge-on. We want D to be at least d plus the distance from C to Pi, so (assuming fixed τ ):</p><formula xml:id="formula_1">D = max P i K • |Pt − Pi| τ + |Pi − C| .</formula><p>Away from the center of the screen, this may underestimate the error by 10-40% (typically, depending upon the field of view). This is normally ignored since the center of screen is considered the most important (a conservative bound is possible). This error metric is orientation insensitive -it does not depend on the angle at which the triangle is viewed.</p><p>This error metric is non-monotonic <ref type="bibr" target="#b25">[26]</ref>, that is, splits may increase the total error. Non-monotonic error metrics produce triangulations with fewer triangles than corresponding monotonic metric where the error is bounded hierarchically. However, if the mesh is altered locally, monotonic metrics may be recomputed more quickly.</p><p>In order to meet a target frame rate, we may want to adjust τ . Recomputing D for every triangle is computationally expensive, but accurate. However, when D is large compared to the cluster width, D is nearly linear in 1/τ . If we want to increase the number of triangles rendered, scaling D by a constant factor α &gt; 1 will reduce τ by a factor of α.</p><p>Aggregate error measures the approximation error of using an aggregate triangle just as a regular error metric measures the approximation error of a single triangle. We use the point C in the middle of the base edge of the aggregate triangle and compute a distance D for the whole triangle. In fact, we could use the equation for D given above directly, with the understanding that T is an aggregate triangle.</p><p>An approximation to this is to simply choose D so that it contains every isosphere of the sub-triangulation. This is fast enough 3 that several aggregation levels may be profiled at startup to determine which is optimal.</p><p>When constructing an adaptive sub-triangulation for an aggregate triangle, we want to minimize D. We therefore prioritize the triangles in the miniature BTT by their distance to C plus the isosphere radius. We may then use a priority queue to efficiently determine which binary triangle to split next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">OPTIMIZATIONS</head><p>To reduce the number of times per frame that the error metric is evaluated, we set up queues that track how soon a triangle could need to split or merge. If a split sphere for a triangle is x units away from the current camera position, we only need to consider splitting the triangle after the camera has moved at least x units. The advantage of this technique is that it does not require a heuristic to estimate how many frames before an error needs to be reevaluated, as required by ROAM's <ref type="bibr" target="#b6">[7]</ref> dual queues. ROAM, however, supports control over the number of triangles rendered, while this technique only controls the maximum error.</p><p>Blow <ref type="bibr" target="#b3">[4]</ref> uses a hierarchical sphere tree to reduce metric evaluations at higher detail levels. With aggregation, we found our queue implementation sufficient. The CABTT algorithm required 45 error metric evaluations per frame, compared to about 2,100 without aggregation.</p><p>To keep the comparison fair, our ROAM implementation includes additional optimizations. Since queue operations were a large part of the CPU work in ROAM, we used an optimized bucket queue instead of a standard STL set. This increased frame rates by 28%. Instead of sending individual triangles using immediatemode OpenGL, we stitched adjacent triangles together into fans, averaging 3.7 triangles per fan. Fan rendering increased frame rates by a further 12%. These optimizations gave ROAM an advantage over the lowest levels of aggregation. Other factors, such as the error metric, were kept the same between the ROAM and aggregate triangle implementations.</p><p>Pseudo-code for our CABTT implementation is given in   and merge queues are indexed by the value of DistanceSoFar when they will be reevaluated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS</head><p>Our test machine was a 450 MHz Pentium II with 128 MB of RAM. It was equipped with a NVIDIA GeForce 2 with 32 MB of video memory. Our implementation of the algorithm used OpenGL extensions <ref type="bibr" target="#b3">4</ref> to cache geometry on the video card.</p><p>Unless otherwise noted, our test scene was a 2049 × 2049 texture-mapped height field. The camera followed a circular path in the horizontal plane. The error metric was set to K/τ = 600, corresponding to a maximum error of τ ≈ 1 pixel at a resolution of 640×480 with a 45 • field of view. Popping, or discontinuities from changes in the level of detail, was barely detectable in our tests. We found that window size had only a small effect on average speed. Results were averaged over the 2400 frames of the test. <ref type="figure" target="#fig_10">Figure 11</ref> summarizes the performance of our implementation. Observe that both aggregation and caching improve total triangle throughput <ref type="figure" target="#fig_10">(Figure 11(b)</ref>), though with diminishing returns at high aggregation levels. Higher aggregation levels require more triangles to achieve a given error bound, as shown in <ref type="figure" target="#fig_10">Figure 11(c)</ref>. Caching aggregate triangles with an average of 206 sub-triangles gave the highest frame rate of 44 frames per second <ref type="figure" target="#fig_10">(Figure 11(a)</ref>). In this case, an average of 1.8 splits/merges of aggregate triangles were required per frame. <ref type="bibr" target="#b3">4</ref> Specifically NV vertex array range and NV fence. The alternative for ATI video cards would be ATI vertex array object. OpenGL 2.0 plans to directly support this form of caching.     Aggregation also kept the memory requirements modest. Height field and error data used the most memory (a total of two floats per vertex in the full mesh). Cached geometry data, taking 12 bytes per rendered triangle, <ref type="bibr" target="#b4">5</ref> accounted for the remainder. The aggregated BTTs and aggregate errors used a negligible amount of storage. <ref type="figure" target="#fig_12">Figure 12</ref> demonstrates how well our algorithm scales to higher resolution meshes. A 4097 × 4097 height field renders at interactive rates (24 frames per second) using the CABTT algorithm. As expected, rendering the full mesh every frame is efficient at lower resolutions, but not at higher resolutions. On the other hand, the level-of-detail algorithms (ROAM and CABTT), handle higher resolutions more gracefully. Aggregation and caching are significant improvements to ROAM at all resolutions. The graph only shows the optimal aggregation level for each resolution. Lower resolution meshes used a lower aggregation level.</p><p>Since the algorithm exploits temporal coherence, frame rates drop as the camera moves faster. <ref type="figure" target="#fig_13">Figure 13</ref> shows how increased flight speed degrades performance of ROAM-based algorithms. One way of controlling level of detail without using temporal coherence is to generate a mesh from scratch every frame. For compar-ison, we implemented a binary triangle tree algorithm that applies splits to the base mesh every frame, labeled split-only in the figure. The higher flight speeds tested were so fast that the animation did not appear smooth. Still, the CABTT algorithm performed better than the algorithm that did not use temporal coherence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED AND FUTURE WORK</head><p>There are several optimizations, areas for future research, and related work to enhance the presented algorithm.</p><p>The isosphere error metric was constructed for efficient evaluation. It replaced the orientation sensitive metrics from Lindstrom, et al. <ref type="bibr" target="#b20">[21]</ref> or ROAM <ref type="bibr" target="#b6">[7]</ref> since they have been found to be too CPU intensive <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b19">20]</ref>. Aggregation would reduce the CPU burden and benefit from fewer triangles to render. However, these metrics would complicate the split criteria for computing adaptive sub-triangulations.</p><p>ROAM has a dual-queue system that controls the number of triangles rendered and prioritizes the work performed for each frame. Adapting this system to the CABTT algorithm would allow rendering with hard real-time deadlines.</p><p>To handle high resolution texturing, we could precompute the resolution needed for each aggregate triangle. Chunks of texture data could then be swapped along with the geometry.</p><p>A common optimization, used by Lindstrom and Pascucci <ref type="bibr" target="#b19">[20]</ref> for example, is to split rendering and geometry updates into separate threads. The implementation for the CABTT algorithm will be similar. Extra thread synchronization will be needed before freeing caches, however. Other threads could prefetch or precache texture or geometry data, based on possible future view points.</p><p>To render several instances of a single model, in addition to displacement map, texture map, and base mesh data, we can share caches between the instances. This requires a data structure that maps a position in the binary triangle tree to a reference count and cache identifier. Depending on the situation, it may help to have a separate cache for the lowest level of detail.</p><p>Using a fixed level of aggregation for aggregate triangles prevents very low levels of detail. For faraway objects, alternative level-of-detail approaches should be employed.</p><p>Lindstrom and Pascucci <ref type="bibr" target="#b19">[20]</ref> give an indexing scheme appropriate for standard binary triangle trees with large data sets. The access patterns of our algorithm are somewhat different, but their approach should still work well. An approach tailored to CABTT would divide data into two sets. Low-resolution data is appropriate for splits, merges, and error metric evaluations. High-resolution data is needed for generating sub-triangulations.</p><p>The geometric error metric given in Section 5 will allow distant sand dunes to be approximated by a plane. This will reveal the valleys of the dunes when you should only be able to see the tops. Some research exists <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b11">12]</ref> that addresses this problem.</p><p>Several papers address automatically converting a model into a base mesh plus displacement data. MAPS <ref type="bibr" target="#b18">[19]</ref> and Kobbelt, et al. <ref type="bibr" target="#b15">[16]</ref> address standard remeshing. Other model representations appropriate for use with our algorithm are:</p><p>• normal meshes <ref type="bibr" target="#b10">[11]</ref>,</p><p>• displaced subdivision surfaces of Lee, et al. <ref type="bibr" target="#b17">[18]</ref>; combined with the incremental evaluation scheme of Müller and Havemann <ref type="bibr" target="#b24">[25]</ref>, and</p><p>• spline patches with displacement maps by Krishnamurthy and Levoy <ref type="bibr" target="#b16">[17]</ref>, and Blow <ref type="bibr" target="#b3">[4]</ref>.</p><p>Once a base mesh has been found, Mitchell <ref type="bibr" target="#b23">[24]</ref> has a method of consistently marking which edges are bases.</p><p>For models other than height fields, it makes sense to store culling or occlusion information for each aggregate triangle. Depending on the form of the displacement data, it should be straightforward to generate a frustum where the entire aggregate triangle is facing away from the view point.</p><p>Currently, the CABTT algorithm is only appropriate for rigidbody animation. Research into updating the error data for soft-body animation or other mesh updates would increase the applicability of the algorithm.</p><p>Geomorphing <ref type="bibr" target="#b12">[13]</ref>, morphing between level of detail changes, has not been included in our implementation. Geomorphing would require a significant amount of extra CPU work and bus bandwidth. On some cards, geomorphing could be implemented in a vertex shader program for a more modest speed hit.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Adjacent triangles are always within one level of detail.SplitMerge The split and merge operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Uniform subdivision of a binary triangle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Splitting a triangle may force other triangles to split.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>An aggregated BTT with uniform sub-triangulations. The boundaries of the aggregate triangles are bold. Splitting a binary triangle so that its edges have (a) 2 segments, (b) 4 segments, (c) 8 segments, and (d) 16 segments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Isosphere error metric notation. graphics card.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Figures 9 and 10. Please note that triangles that may be split are indexed by the midpoint of their base edges. Diamonds in the split procedure Initialize(BaseMesh, InitialCameraPosition, AggregationLevel): compute and store D for each diamond for each possible splittable Diamond of aggregate triangles: Error1 = error of SubTriangulation(Diamond.Triangle1) Error2 = error of SubTriangulation(Diamond.Triangle2) AggregateError[Diamond]=Max(Error1, Error2) DistanceSoFar = 0 LastPosition=InitialCameraPosition AggregateTree = BaseMesh MergeQueue = empty SplitQueue = [each diamond of BaseMesh]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Initialization for aggregate BTT rendering algorithm. procedure RenderCABTT(NewCameraPosition): update DistanceSoFar and LastPosition while Diamond in MergeQueue/SplitQueue needs to be reevaluated: remove Diamond from the queue recompute distance until merge/split if negative: merge/split Diamond (updating queues) else: add Diamond back to the queue for each Triangle in AggregateTree: if off-screen: discard caches for Triangle else: if Triangle has no cache: Triangle.Cache = Cache(SubTriangulation(Triangle)) RenderCache(Triangle.Cache)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Render procedure called once per frame.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Performance of aggregation and caching with a maximum error τ of one pixel, a 640 × 480 window, and a 2049 × 2049 height field. Triangles refers to triangles requested to be drawn after using a simple field-of-view culling procedure. The columns of each graph correspond to 1, 2, 4, . . ., 512 edges per side of the aggregate triangles. Graph (a) demonstrates that peak performance occurs with an average of 206 sub-triangles in each aggregate. Graph (b) shows that triangle throughput improves with greater aggregation. Graph (c) indicates how many triangles are rendered at each aggregation level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>A log-log plot of frame rate versus resolution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 :</head><label>13</label><figDesc>The frame rate at various camera-movement speeds shows the influence of temporal coherence. For comparison, splitonly calculates each frame from scratch, and so is not influenced by flight speed.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Assuming the pixels are square, K will be the same if computed from the horizontal resolution and field of view or from the vertical resolution and field of view.<ref type="bibr" target="#b1">2</ref> To be conservative, we should use Pt when it is farther from C.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">Pre-computing D for every aggregate triangle takes less than a tenth of a second for a 257 × 257 height field on a 450 MHz Pentium II.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">Half of this, the vertices, are kept on the video card -ATI cards support ATI element array which allows everything to be stored on the video card.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">ACKNOWLEDGMENTS</head><p>Special thanks to Rebecca Middleton, Ka-Ping Yee, and Georgia Saltsman for their help revising this paper. We are also grateful to Jonathan Blow and Thatcher Ulrich for sharing their algorithms and their insightful correspondence. Finally, the (anonymous) reviewers of this paper helped direct and improve this paper in numerous ways.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Refinement Algorithms and Data Structures for Regular Local Mesh Refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randolph</forename><forename type="middle">E</forename><surname>Bank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">H</forename><surname>Sherman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><surname>Weiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Scientific Computing</title>
		<imprint>
			<date type="published" when="1983" />
			<biblScope unit="page" from="3" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Smooth Transitions between Bump Rendering Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><forename type="middle">L</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 93</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="183" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Simulation of Wrinkled Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Blinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIG-GRAPH</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="286" to="292" />
			<date type="published" when="1978" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Terrain Rendering at High Levels of Detail</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Blow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Game Developers&apos; Conference</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Appearance-Preserving Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Olano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinesh</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 98</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="115" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Temporal Continuity of Levels of Detail in Delaunay Triangulated Terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-Or</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yishay</forename><surname>Levanoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ROAMing Terrain: Real-time Optimally Adapting Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Murray</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">E</forename><surname>Sigeti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">B</forename><surname>Mineev-Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generalized View-Dependent Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jihad</forename><surname>El</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-</forename><surname>Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics &apos;</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Right Triangular Irregular Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregg</forename><surname>Townsend</surname></persName>
		</author>
		<idno>TR97- 09</idno>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">30</biblScope>
		</imprint>
		<respStmt>
			<orgName>University of Arizona</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Error Indicators for Multilevel Visualization and Computing on Nested Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Gerstner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rumpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulrich</forename><surname>Weikard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="363" to="373" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Wim Sweldens, and Peter Schröder. Normal Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Igor</forename><surname>Guskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kiril</forename><surname>Vidimce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 2000</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Illuminating Micro Geometry Based on Precomputed Visibility</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Heidrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katja</forename><surname>Daubert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Kautz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-Peter</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 2000</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="455" to="464" />
		</imprint>
	</monogr>
	<note>Published as Computer Graphics Proceedings, Annual Conference Series</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Progressive Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 1996</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">View-Dependent Refinement of Progressive Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 1997</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Smooth View-Dependent Level-of-Detail Control and its Application to Terrain Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ulf Labsik, and Hans-Peter Seidel. A Shrink Wrapping Approach to Remeshing Polygonal Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><forename type="middle">P</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Vorsatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics &apos;</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1999-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fitting Smooth Surfaces to Dense Polygon Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Venkat</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 96</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="313" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Displaced Subdivision Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Moreton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 2000</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="85" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">MAPS: Multiresolution Adaptive Parameterization of Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W F</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cowsar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 98</title>
		<imprint>
			<biblScope unit="page" from="95" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Visualization of Large Terrains Made Easy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Real-Time, Continuous Level of Detail Rendering of Height Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><forename type="middle">F</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 96</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">View-Dependent Simplification of Arbitrary Polygonal Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A Survey of Polygonal Simplification Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Luebke</surname></persName>
		</author>
		<idno>TR97-045</idno>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
		<respStmt>
			<orgName>University of North Carolina at Chapel Hill</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Unified Multilevel Adaptive Finite Element Methods for Elliptic Problems. PhD thesis, U.I. at Urbana CS Dept</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">F</forename><surname>Mitchell</surname></persName>
		</author>
		<idno>No. UIUCDCS-R-88-1436</idno>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Subdivision Surface Tessellation on the Fly using a versatile Mesh Data Structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kerstin</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sven</forename><surname>Havemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="151" to="138" />
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Large Scale Terrain Visualization Using The Restricted Quadtree Triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">ROAM Using Triangle Clusters (RUSTiC)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Pomeranz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-06" />
		</imprint>
	</monogr>
	<note>Master&apos;s thesis, U.C. Davis CS Dept</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Real Time Generation of Continuous Levels of Details for Height Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Heidrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Slusallek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-Peter</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sixth International Conference in Central Europe on Computer Graphics and Visualization</title>
		<imprint>
			<date type="published" when="1998-02" />
		</imprint>
		<respStmt>
			<orgName>Winter School on Computer Graphics). WSCG</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Algorithms for Constructing Quadtree Surface Maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Sivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanan</forename><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int. Symposium on Spatial Data Handling</title>
		<meeting>5th Int. Symposium on Spatial Data Handling</meeting>
		<imprint>
			<date type="published" when="1992-08" />
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thatcher</forename><surname>Ulrich</surname></persName>
		</author>
		<ptr target="http://www.gamasutra.com/features/20000228/ulrich01.htm" />
		<title level="m">Continuous LOD Terrain Meshing Using Adaptive Quadtrees. Gamasutra</title>
		<imprint>
			<date type="published" when="2000-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Accurate Triangulations of Deformed, Intersecting Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Von Herzen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIG-GRAPH 87</title>
		<meeting>SIG-GRAPH 87</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1987" />
			<biblScope unit="page" from="103" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Dynamic View-Dependent Simplification for Polygonal Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julie</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 96</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
