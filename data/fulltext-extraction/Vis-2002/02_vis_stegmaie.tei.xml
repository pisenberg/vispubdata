<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Case Study On The Applications Of A Generic Library For Low-Cost Polychromatic Passive Stereo</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Stegmaier</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Dirc Rose Thomas Ertl Visualization and Interactive Systems Group</orgName>
								<orgName type="institution">University of Stuttgart</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">IfI, Department VIS</orgName>
								<orgName type="institution">University of Stuttgart</orgName>
								<address>
									<addrLine>Breitwiesenstrasse 20-22</addrLine>
									<postCode>D-70565</postCode>
									<settlement>Stuttgart</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Case Study On The Applications Of A Generic Library For Low-Cost Polychromatic Passive Stereo</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.2 [Computer Graphics]: Graphics Systems-Distributed/network graphics; I.3.3 [Computer Graphics]: Picture/Image Generation-Viewing algorithms Stereo Graphics</term>
					<term>OpenGL</term>
					<term>Preloading</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Active stereo has been used by engineers and industrial designers for several years to enhance the perception of computer generated three-dimensional images. Unfortunately, active stereo requires specialized hardware. Therefore, as ubiquitous computing and teleworking gain importance, using active stereo becomes a problem. The goal of this case study is to examine the concept of a generic library for polychromatic passive stereo to make stereo vision available everywhere.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The use of stereoscopic techniques to enhance perception dates back to 1832, when Charles Wheatstone proved that the effect of three-dimensional vision could be reproduced by placing two slightly different drawings side-by-side and looking at them through a system of mirrors and prisms.</p><p>More than a hundred years later, in the late 1960s, stereo graphics found its way into computer graphics. At that time, high-quality stereo was only available in environments that could bear the high costs of stereo equipment. A constant increase in the performance of consumer graphics boards during the last years has changed this and active stereo using a single projection device and shutter glasses is now a standard technology that is affordable for everyone. Still, active stereo requires sophisticated technology that is not available for every workplace, especially portable display devices. However, ubiquitous computing is gaining importance, so solutions are required that enable also these devices to display stereoscopic images.</p><p>This case study discusses the concept of using a generic low-cost software solution to solve this problem. The solution is provided by means of a preload library which enables most OpenGL based applications to display high-quality polychromatic passive stereo. With the presented solution no modifications of any kind are necessary to convert a monoscopic application to a stereoscopic application. This allows us to include software packages in our study, which we do not even have source code for.</p><p>Our case study is organized as follows: Section 2 compares the different techniques for generating stereo images using examples of software and hardware solutions developed by other researchers and justifies our interest in passive stereo. Section 3 gives an introduction to the technique of preloading that is used for our library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>We evaluated several stereoscopic techniques, which have been developed previously. It turned out that most of them fail to meet some or all of our criteria: no need for specialized hardware, multicolor images, and portability.</p><p>Solutions for active stereo, also used in high-end VR environments, are mostly hardware based and require special drivers <ref type="bibr" target="#b5">[6]</ref>. Some software tricks <ref type="bibr" target="#b0">[1]</ref> allow to circumvent the need for special drivers, providing support for a minor subset of shutter glasses. In any case, synchronization problems have to be dealt with or active stereo does not work at all. In addition, there is currently no Pocket PC that provides the hardware capabilities required for active stereo.</p><p>On the other hand, passive stereo using filter glasses works on all systems. One common technique is based on polarized light <ref type="bibr" target="#b3">[4]</ref>. However, polarized light would contradict our requirement for a pervasive usage and, therefore, was dropped.</p><p>Another solution is ChromaDepth <ref type="bibr" target="#b1">[2]</ref>, but this is difficult to implement without having access to the source code of the application and requires the altering of the scene's colors. Therefore, Cro-maDepth, too, is no alternative for our case study.</p><p>On the contrary, anaglyphs can be generated without having source code access. Formally, anaglyphs can be defined as follows: Given a color model with a set of primaries P, the images for the left and right eye are rendered using subsets L ⊂ P and R ⊂ P of primaries, with L ∩ R = ∅. Informally, this just means that the stereo pair can be separated using glasses of different color. However, not all subsets of P are suitable for stereographic viewing. If L ∪ R = P, the application's color space cannot be reproduced in a satisfying way. For example, using the RGB color model and red-green glasses, no blue tones can be perceived by the viewer.</p><p>Yet, this limitation does not apply to colored anaglyphs using e.g. red-cyan glasses. In addition, since anaglyphs can be implemented efficiently using OpenGL's glColorMask functionality, colored anaglyphs are an stereoscopic technique ideally suitable for our needs.</p><p>As a matter of fact, another anaglyph-based effort <ref type="bibr" target="#b5">[6]</ref> similar to ours has already been made. However, this implementation proved to be unreliable and did not support many applications. Moreover, since a stereo library can be implemented with a few hundred lines of code and integration in already existing code was under consideration, we decided to develop an easy to use library on our own that allows us to experiment with different types of passive stereo techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PRELOADING LIBRARIES</head><p>When an application is being developed, functionality implemented in some library may be included using static or dynamic linking <ref type="bibr" target="#b4">[5]</ref>. Using static linking the library's functionality is copied into the executable. The application is, therefore, unaffected if the archive is replaced later. On the other hand, dynamic linking adds references to a shared library to the application's executable instead of the library's code itself. This allows an application to use always the latest version of a library.</p><p>Most computer systems allow the programmer to modify the behavior of shared libraries without having to modify the libraries themselves. This technique is called preloading and works by implementing a shared library that selectively overrides the interface of another shared library. Using runtime linking <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref> the original library's functionality is still available as long as both the original and the replacement library are dynamically linked to the application. Since the executable does only contain references to the original library, the order to preload the replacement library must be given to the linker using a second mechanism. Most systems choose to use environment variables for this purpose.</p><p>OpenGL is usually implemented both as a static as well as a shared library. Because most applications are linked dynamically to take advantage of improved versions of the OpenGL library, preloading can be used to modify the behavior of most OpenGLbased applications without having to modify any source code. The library described in this case study takes advantage of this fact and adds stereo capabilities to an application solely using preloading. A detailed description of what functionality of the OpenGL library was replaced is given in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">LIBRARY ARCHITECTURE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Stereo Rendering</head><p>Basically, there are two possibilities to adjust the camera for stereographic perspective. The "toe-in" method ( <ref type="figure" target="#fig_0">Figure 1(a)</ref>) rotates the camera frusta around the center of projection. This approach is geometrically incorrect, and leads to variable misalignments, namely keystoning or vertical parallaxes between homologous points <ref type="bibr" target="#b3">[4]</ref>. The correct approach, implemented in our library, is shown in era parameters given inside the preloaded application, we have to extract the information needed to calculate the camera properties for the left and right eye from the existing projection matrix P. In general, P is of the following form:</p><formula xml:id="formula_0">P =    2n r−l 0 r+l r−l cx 0 2n t−b t+b t−b cy 0 0 n+f n−f 2nf n−f 0 0 −1 0    .<label>(1)</label></formula><p>Hereby, n, f , l, r, t, and b represent the near, far, left, right, top, and bottom clipping planes, respectively. The eye offset in screen space is given by cx and cy. The near and far clipping planes can be derived easily from the third row of this matrix. Furthermore, from the first row we determine the left and right planes which in general are symmetrical to the viewing direction. Using this information we are able to adjust the asymmetry and the camera offset for the left and right eye by manipulating the third and fourth entry of the matrix P's first row, respectively.</p><p>What is left is identifying the OpenGL calls that manipulate the projection matrix. We have found that glFrustum and all glLoadMatrix* and glMultMatrix* OpenGL calls must be overridden. To handle the unexpected case that gluPerspective does not call glMultMatrix*, we have overridden this utility function, too.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Redrawing</head><p>Calculating the viewing frusta for the left and right image is just one part of the process in generating stereo images. The other task is to perform the actual rendering using the determined settings.</p><p>The obvious solution is to render the scene once using the settings for the left eye, and then to rerender it with the settings for the right eye. Obviously, this approach requires knowledge about the routine performing the rendering. This is trivial for a glut-based application: Overriding glutDisplayFunc will yield the desired information. However, in the general case invocation of glut functions cannot be assumed. But if the redraw function cannot be determined in a safe way, any attempt to find the redraw function, e.g. by calculating the return address of glClear and tracing the callstack back to the first enclosing function, must be considered a heuristic that will not work for many applications. A simple OpenGL pseudocode that does all rendering within main demonstrates the problem: The correct address for redrawing is labeled redraw in this example. Obviously, neither the function enclosing glClear (main) nor the return address of glClear can be used for redrawing without altering the program logic.</p><p>Another approach is to record all issued OpenGL commands when rendering the left-eye scene and playing them back for rendering the right-eye scene. This approach requires preloading all OpenGL calls. Doing this sounds worse than it really is because most of the code can be generated automatically by parsing the OpenGL sample implementation specification files provided by SGI <ref type="bibr" target="#b9">[10]</ref>. Still, preloading the complete OpenGL library is a challenging task and may slow down the application considerably when large vertex arrays must be saved for further reference.</p><p>Creating a second GLX context will also require a preload of all OpenGL functions. In contrast to the previous approach the arguments need no longer to be saved which makes the code much simpler. The disadvantage is that a naive implementation will cause a large number of context switches and therefore will again lower the application's performance. Switching contexts only with glEnd and recording calls issued in a glBegin/glEnd block will be much better. But even this approach will not give the correct results if the application changes its internal state between two glXSwap-Buffers.</p><p>Given these facts, our opinion is that simply sending an Expose event 1 is the best tradeoff between complexity and universality <ref type="bibr" target="#b7">[8]</ref>. The application may still change its internal state between two buffer swaps but this should be considered rather a design flaw than good programming style. To conclude: Expose events will give identical results compared to the last (and even the first) approach at a much lower cost.</p><p>Using this approach, generation of the stereo image requires preloading glXSwapBuffers only and discarding the swap after the left-eye view has been rendered. At this point the projection matrix for the right-eye view is set and an Expose event is generated. As soon as glXSwapBuffers is reentered the eventactivated rendering can be considered to be complete and buffers are swapped. Since glClear is probably called between two buffer swaps this routine has to be overridden, too, to unmask the color buffer bit when the right-eye view is to be rendered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Configuration</head><p>The computed stereo pairs are controlled by three major parameters: the viewers eye separation, the display width, and the location of the zero-parallax. The former two parameters usually do not need to be changed frequently. However, the last parameter should be adjustable interactively to focus on different parts of the scene. Therefore, we have decided not to save the settings in a configuration file, but instead in a permanent shared memory segment. The segment is created at the application's first start and is initialized with default values. If these are not suitable, a standalone graphical configuration program can be used to attach to the shared memory segment and to adjust the settings. All this can be done without having to restart the application and the settings' effects become visible instantly.</p><p>Another adjustable parameter is color saturation, motivated by the fact that anaglyphs cannot reproduce the RGB color space (see Section 2). This drawback can be alleviated by adding white to colors like pure red or green, i.e. by lowering the color's saturation. Still, there is no need to lower the saturation S in general, therefore, the following weighting function based on the luminances L red /cyan is being used to compute the adjusted saturation S :</p><formula xml:id="formula_1">S = S • 1 − (1 − Smax ) • L red − Lcyan L overall ,<label>(2)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPLICATION RESULTS</head><p>Using passive stereo, each stereo image is the result of a superposition of two images using two slightly different viewing frusta. Let R be the time between two buffer swaps, S be the time needed for the buffer swap itself, and fpsstereo and fpsmono be the application's <ref type="bibr" target="#b0">1</ref> or the corresponding event that tells the application that the window must be redrawn after being obscured if not using the X Window System frame rate with and without using the library, respectively. Then the following two relations are expected:</p><formula xml:id="formula_2">lim R S →0 fpsmono fpsstereo = 1 , lim R S →∞ fpsmono fpsstereo = 2 .<label>(3)</label></formula><p>Both of these equations can be confirmed using the standard glxgears OpenGL application and drawables of different sizes and various numbers of gear teeth. Therefore, geometry-bound applications will experience half the frame rate in the worst case, but typically only a decrease of some ten percent when using large drawables. On the other hand, rendering scenes with little geometry will typically be almost unaffected by preloading the stereo library since buffer swaps are ignored for the left eye and no color buffers are cleared for the right eye.</p><p>A visual evaluation of the library was done using real-world commercial software packages for the Linux operating system. The first package, PowerVIZ <ref type="bibr" target="#b8">[9]</ref> is a Qt-based flow visualization tool distributed by Exa Corporation that is used by car manufacturers for visualizing the air flow around car bodies as well as within catalysts. PowerVIZ makes extensive use of textures. The second package is FEMod <ref type="bibr" target="#b2">[3]</ref>, an interactive preprocessing tool for car crash simulations. FEMod is developed by science+computing AG in cooperation with the BMW AG, Munich and is also based on the Qt toolkit.</p><p>Our library is implemented on the lowest level of OpenGL. Therefore, any OpenGL-based application is expected to work with the library, whether it uses glut or any other toolkit that provides GLX drawables. As expected, both PowerVIZ and FEMod can be used with the library without any problems; in particular, there were no problems caused by interference of the stereo and the Qt library. Depth impression is excellent and most colors are crisp (see Sec-  <ref type="figure" target="#fig_2">Figures 2 and 3</ref> show some screenshots. The screenshots must be viewed with red-cyan glasses, however, ghosting artifacts may occur due to intentionally enlarged eye distances.</p><p>Use of our library is not restricted to desktop computers. Some modern Pocket PCs are able to run the Linux operating system and are, therefore, potential display devices. However, due to a still limited computing performance of these devices, combining our library with a remote visualization library is a more sensible decision at the moment. In <ref type="bibr" target="#b10">[11]</ref> remote visualization on a Compaq iPAQ <ref type="figure">Figure 3</ref>: FEMod with enlarged eye distance. As can be seen at the front and rear wheel the zeroparallax is located near the car body's center. Pocket PC is demonstrated. Clearly, an iPAQ is not suitable for active stereo. However, passive stereo is possible by preloading our library to the visualization application that runs on the server <ref type="figure" target="#fig_3">(Figure 4)</ref>. In this case, passive stereo is quite superior to active stereo due to the need to transmit only one image per stereo image instead of two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">LIMITATIONS</head><p>The library overrides glXSwapBuffers and sends Expose events for redrawing. Using single-buffered applications or applications that do not handle Expose correctly, only monoscopic images will be perceived. The same applies to the use of glColor-Mask for superpositioning the stereo image: An application that makes use of color masks will show unexpected behavior.</p><p>A last limitation inherent in preloading is that our library is only applicable to programs that are dynamically linked with the OpenGL libraries. However, linking the OpenGL library statically is not reasonable; thus, the number of applications affected by this limitation is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>In this case study we examine applications of a preload library for polychromatic passive stereo. We have found that the results with regard to depth impression and color are very satisfying. Paired with the ease of use, low purchase and maintenance costs, and the applicability to most OpenGL-based applications, it is our opinion that polychromatic passive stereo is a real alternative to active stereo in environments where sophisticated hardware for active stereo is not available. Furthermore, it has been demonstrated that even Pocket PCs can be used as a stereographic display-no matter whether they generate the stereo images themselves or receive them from a visualization server.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure1(b). This method uses asymmetric frusta with parallel axis vectors (indicated by the arrows). As we do not know the cam-Stereo camera perspectives: (a) approximating "toe-in" method, (b) correct, asymmetric frusta.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Flow visualization with PowerVIZ. The eye distance has been enlarged to emphasize parallax effects. tion 6 for details).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Remote stereo on an iPAQ Pocket PC.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">IEEE Visualization 2002 Oct. 27 -Nov. 1, 2002, Boston, MA, USA 0-7803-7498-3/02/$17.00 © 2002 IEEE</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Allard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lecointre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Raffin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Gouranton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Melin</surname></persName>
		</author>
		<title level="m">Rapport de Recherche: Net Juggler Guide, SoftGenLock</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Using OpenGL and ChromaDepth to obtain Inexpensive Single-image Stereovision for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graphics Tools</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Visualization and pre-processing of independent finite element meshes for car crash simulations. The Visual Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Frisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Sommer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Th</forename><surname>Ertl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mcallister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dulberg</surname></persName>
		</author>
		<title level="m">Stereo computer graphics for virtual reality. SIGGRAPH &apos;97, Course Notes 6</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">An approach to genuine dynamic linking. Software, Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Olsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="375" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Villanustre</surname></persName>
		</author>
		<ptr target="http://sourceforge.net/projects/stereogl/" />
		<title level="m">Stereo3D library for OpenGL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">ELF: From the programmer&apos;s perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<ptr target="ftp://tsx-11.mit.edu/pub/linux/packages/GCC/ELF.doc.tar.gz" />
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">Protocol Reference Manual. X Window System Series. O&apos;Reilly &amp; Associates</title>
		<editor>A. Nye</editor>
		<imprint>
			<date type="published" when="1995-01" />
			<biblScope unit="volume">0</biblScope>
		</imprint>
	</monogr>
	<note>4th edition</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interactive Visualization of Fluid Dynamics Simulations in Locally Refined Cartesian Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Reck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bartelheimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Th</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;99</title>
		<meeting>Visualization &apos;99</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="413" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<ptr target="http://oss.sgi.com/projects/ogl-sample/" />
	</analytic>
	<monogr>
		<title level="j">Silicon Graphics, Inc. OpenGL Sample Implementation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A generic solution for hardware-accelerated remote visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Stegmaier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Magallón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Th</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procceedings of EG/IEEE TCVG Symposium on Visualization VisSym &apos;02</title>
		<meeting>ceedings of EG/IEEE TCVG Symposium on Visualization VisSym &apos;02</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
