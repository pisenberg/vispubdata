<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Case Study: Visual Debugging Of Finite Element Codes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><surname>Crossno</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">H</forename><surname>Rogers</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">J</forename><surname>Garasi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandia</forename><forename type="middle">National</forename><surname>Laboratories</surname></persName>
						</author>
						<title level="a" type="main">Case Study: Visual Debugging Of Finite Element Codes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I</term>
					<term>3</term>
					<term>8 [Computer Graphics]: Applications; C</term>
					<term>4 [Performance of Systems] Modeling techniques -Performance attributes visual debugging, parallel finite element codes and simulations</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present an innovative application developed at Sandia National Laboratories for visual debugging of unstructured finite element physics codes. Our tool automatically locates anomalous regions, such as inverted elements or nodes whose variable values lie outside a prescribed range, then extracts mesh subsets around these features for detailed examination. The subsets are viewed using color coding of variable values superimposed on the mesh structure. This allows the values and their relative spatial locations within the mesh to be correlated at a glance. Both topological irregularities and hot spots within the data stand out visually, allowing the user to explore the exact numeric values of the grid at surrounding points over time. We demonstrate the utility of this approach by debugging a cell inversion in a simulation of an exploding wire.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>We use visualization to help us understand the results of complex, scientific simulations. Transforming large quantities of numbers into three-dimensional shapes and images allows us to use our innate visual processing skills to interpret the data and identify patterns. We use these same skills to assist us in understanding the complexities of software systems, such as massively parallel physics simulations.</p><p>Typical scientific visualization algorithms seek to hide the underlying data structures from the viewer. For instance, if the visualization is of an isosurface through a volumetric data set, the goal is to present a smooth surface that does not provide any indication of the underlying grid resolution or processor decomposition. However, while debugging a simulation, if an error in the output is identified while visualizing the results, it is difficult to correlate the error with the underlying data structures on the appropriate processor. In this situation, it would be better to explicitly represent data structures, processor assignment, and other program elements to assist the software developer in finding the error that led to the anomalous results.</p><p>Given that software execution is a dynamic process, another component of understanding the complexities of simulation codes is to literally see how variables change over time. By abstracting the variable values to color or shape, mapping them into a three-dimensional domain so that proximity relationships can be correlated with the values, and then showing this over time, the software developer can gain insights into complex, dynamic behaviors within the code. Without this sort of tool, the developer must try to mentally generate a model of variable values in space changing through time. For most people this is very difficult to do, so the dynamics of program behavior must be gleaned through traditional animations of the simulation.</p><p>In response to these issues, we have developed a suite of tools for visually debugging parallel physics simulations that make the underlying finite element structures explicit in the visualization. Visual complexity is reduced by using feature detection to find and extract regions of interest from within the mesh prior to detailed viewing. Context within the larger mesh is provided by also extracting external element faces for either the entire volume or blocks of elements within the volume representing significant model components or parts. <ref type="figure">Figure 1</ref>: The simulation is of an exploding wire. The volume fraction of the wire material in each element is shown through color, with low amounts as blue and high amounts in red. Elements with levels below a threshold are culled. An inverted element is highlighted in pink on the right. The elements are subsets of extracted planes taken through the inverted element. Black arrows show the derived vectors for magnetic force, J x B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>----------------------------------------------------------------------------------------------------------------------------</head><p>1 pjcross@sandia.gov, 2 dhroger@sandia.gov, <ref type="bibr" target="#b2">3</ref>  We have used this tool to help debug a three-dimensional simulation of an exploding wire in which an element inverted unexpectedly. Using our tools, we were able to rapidly locate the inverted element and extract a subset of elements surrounding it. Examining this mesh subset in our viewer as shown in <ref type="figure">Figure 1</ref>, we were able to see the topology that lead to the failure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>This work builds upon our previous work in debugging particle systems <ref type="bibr" target="#b2">[3]</ref> and cluster hardware <ref type="bibr" target="#b3">[4]</ref> <ref type="bibr" target="#b4">[5]</ref>. Although we have not found any previous work that uses visualization to debug finite element codes in particular, using visualization to debug or do performance analysis of parallel programs is relevant. The Rivet system performs analysis and visualization of parallel applications in a shared memory environment <ref type="bibr" target="#b0">[1]</ref>. Browne et al created a directed graph representation for parallel programs to simplify parallel programming <ref type="bibr" target="#b1">[2]</ref>. The Interactive Visualization Debugger integrates debugging, performance analysis, and data visualization for message passing parallel applications <ref type="bibr" target="#b5">[6]</ref>. Devise is a generic integrated performance analysis and visualization system that has been coupled with the Paradyn Parallel Performance Tool <ref type="bibr" target="#b6">[7]</ref>. The MAD environment is a tool set for parallel program debugging <ref type="bibr" target="#b7">[8]</ref>. Zhang, Hintz, and Ma use graph formalisms and notation to visualize parallel programs and their execution <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">IMPLEMENTATION</head><p>Finite element models use elements and groups of elements, called element blocks, as central conceptual components. In the simulation examined in this paper, each element is a hexahedron and is formed by eight nodes designating the corners of the element. Variable values are associated with both elements and nodes and change over time as the simulation progresses. These values are output at regular time intervals and represent changes in the program's state.</p><p>Our implementation consists of three parts. First we have a parallel query tool, which divides up the simulation model across multiple processors, scans each of the variables at each time step, and outputs value range information and histograms. Next, we use a parallel feature extraction tool to search the data for either topologically incorrect elements or variable values outside a userspecified range, extracting a neighborhood of elements around any features that are found. Lastly, we have a viewer that draws mesh subsets using color-coding of variables combined with explicit representations of the underlying grids, which allows the user to see anomalies in the data visually and to drill down to get detailed numeric information from specific elements or nodes.</p><p>The tool is implemented using a combination of C and C++ using OpenGL as the graphics API. The user interface is implemented using Tcl/Tk. The tool is platform independent and runs on IRIX, LINUX and NT systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Query</head><p>The first time a user interacts with a data set, we generate a meta-data file describing the names and types of variables, their minimum and maximum values at each time step, and the distribution of values per variable per time step. This meta-data is then displayed both numerically and visually to provide information to the user in selecting parameters for feature detection and mesh subset extraction.</p><p>Typically, data sets are generated in parallel on a cluster. Each processor writes a separate output file that describes a section of the global grid over a series of time steps in the simulation. The query tool also runs in parallel, though it need not run on the same number of processors as the original simulation. Each processor scans its portion of the data and the results are gathered onto a single processor and written out into an XML file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Feature Extraction</head><p>Mesh data can be searched for both inverted elements and variable values that fall outside a user-specified range. Inverted elements are detected by searching for elements in the final time step that have a negative Jacobian. Value scanning can be done on element and node variables over a user-specified range of time steps. The variables are selected and their limits are set using a graphical user interface (GUI). The extraction tool then searches for values outside that range.</p><p>Once features are found within the mesh, the extraction tool marks those elements for output. If the feature is centered on a node, all of the elements using that node are marked. A neighborhood distance parameter defines the size of the featurecentered sub-mesh to output. This distance is a topological radius that can be thought of as the number of layers of elements around the feature, where the elements are maximally connected using face, edge, and node connectivity. A small neighborhood of elements is shown in <ref type="figure" target="#fig_0">Figure 2</ref>. Multiple features can be extracted at once, even if they form disconnected components. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Mesh Subset Viewer</head><p>The mesh subset viewer provides a unique paradigm for debugging and is the core of the project. To make the images easier to understand, the viewer is entirely application specific and only deals with finite element meshes. The challenge in the viewer is to deal with the problem of scale in dealing with very large meshes, while still providing both context and focus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Context</head><p>As the number of elements within a simulation increases, visualizing all of the elements fails when the number of elements exceeds the number of pixels in the display. In fact, even moderate-sized meshes present a viewing problem because the meshes are three-dimensional and interior elements are obscured. Subset meshes require context with respect to the original mesh in order to be useful. The viewer provides context in three ways.  <ref type="figure">Figure 1</ref>. The element block on the left is drawn as a solid with the element boundaries outlined. The cylindrical element block representing the wire is drawn in wire-frame mode to permit elements interior to the wire to be visible. The element block encompassing the inverted element and the elements in the material interface has been turned off. <ref type="figure">Figure 4</ref>: The material interface between the wire and the vacuum is shown in these two images. The elements are colored by the amount of the wire material in each element. As the wire is exploding, fingers of the material are coming off the wire, which lies to the left as the solid red region. Although in the image on the left the inverted element appears isolated from the material, by adding additional elements from the neighborhood around the inverted element, we can see it is tenuously connected.</p><p>First, the user needs to know where the subset lies relative to the boundaries and components of the original model. During the extraction process, the user can choose to output external element faces from significant structures within the model, which are then loaded into the viewer along with the mesh subset. There are three options for defining the external faces: the boundary elements for the entire volume, the boundary elements for each piece of the model or element block, or a user specified list of element block groups. In the viewer, these faces can be viewed as wire frames, solid surfaces, and groups of faces can be turned on and off. These viewing options are shown in <ref type="figure" target="#fig_1">Figure 3</ref>.</p><p>The second type of context is to know where the feature element lies relative to various material boundaries that change dynamically during the simulation. Typically, the neighborhood of elements extracted surrounding the feature element is not large enough to see the salient aspects of the material interface, so we also allow the user to optionally extract topologically-orthogonal "planes" of elements centered on a feature element. An element plane is found in a manner similar to that used in extracting a neighborhood of elements, but instead of stepping out in all directions using maximum connectivity, a subset of faces is followed in an ever-expanding ring from the center element. This is repeated for each orthogonal direction. As elements are extracted as either features or planes, they are tagged with a USAGE variable so that the viewer can quickly show or hide these groups. Examples of topological planes displaying material interfaces are given in both <ref type="figure">Figure 1</ref> and <ref type="figure">Figure 4</ref>.</p><p>Time is the third contextual frame of reference. Not only do the contents of variables change over time, but the topology of the mesh can also warp as node positions shift. Additionally, animation provides insights into dynamic behaviors, such as watching the progression of the material interface or the propagation of temperature over time. We provide a VCR-like interface that allows both animation and single stepping. Random access to individual time steps is also available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Focus</head><p>The two central issues in the visualization of the focus region are how to maximize information content, while simultaneously minimizing visual clutter. We use color, shape, mesh topology, and spatial juxtaposition to represent model information. To reduce the number of objects in the display to just those which address a specific question, we provide a variety of filtering mechanisms that give the user fine control of the features desired in the culled subset of focus elements. We use a spectrum scale for our color-encoding scheme because it is familiar to our users and they requested it. In this scale, the color order from high values to low values is red, orange, yellow, green, cyan, blue, indigo. Violet is the bottom of the scale and elements with this color are generally culled.</p><p>We render elements as colored boxes with their edges highlighted in black to reinforce the three-dimensionality of the model. We can either draw the elements at full size as shown in <ref type="figure">Figure 4</ref>, or we can draw the elements at a reduced scale as shown in <ref type="figure" target="#fig_2">Figure 5</ref> and <ref type="figure" target="#fig_0">Figure 2</ref>. One advantage of reducing the scale is that it enables the user to see interior elements, or the sides of elements lying in a group. In <ref type="figure" target="#fig_2">Figure 5</ref>, the color-coding combined with the topological information tells us that the inverted element had a lower temperature while the adjacent red element had an unusually high temperature compared to nearby elements.</p><p>Although the nodes are implicitly rendered as the corners of the elements, the nodes can be explicitly represented in one of two ways. To view scalar-valued nodal variables, or a single component of a vector variable, the user can enable small colored spheres to be drawn at element corners. For vector variables, scalable arrow glyphs can be either combined with the spheres or drawn independently as shown in <ref type="figure">Figure 1</ref>. By rendering a combination of colored element boxes, colored nodal spheres, and nodal vector arrows, three different variable values can be viewed simultaneously. These variables can then be viewed changing over time through the animation capability. In addition, derived quantities can also be generated and viewed, such as the vector cross product shown in <ref type="figure">Figure 1</ref>.</p><p>Elements can be selected using picking. Numeric values for the picked element's variables appear in a display window. These values are updated with each time increment during animation or when single stepping. The highlight designating the picked element provides feedback and element tracking as the element color or shape changes through time.</p><p>We reduce visual clutter by providing many different ways to cull sections of the model. The coarsest level of culling is done during the extraction step with the selection of a neighborhood of elements and topological planes around a feature. Once in the viewer, the neighborhood and each of the planes is treated as a separate object whose display is individually controllable. Elements within each of these objects are also automatically partitioned into processor groups based on the element's processor id during the simulation. These groups can also be individually controlled, so a display can be constructed from a combination of processor groups and extraction groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RESULTS</head><p>We used our tools to debug a simulation of an exploding wire in which an element inverted after the 17 th time dump. The simulation model was of moderate size and consisted of 241,600 elements distributed over 40 processors. Prior to our tool's development, finding the inverted element would have required manually searching for the inverted element using a conventional scientific visualization package to whittle away elements from the model with slicing planes until the inverted element could be seen. Our extraction tool automatically located the inverted element and extracted a neighborhood of elements around it, along with the topological planes running through the element.</p><p>Using the viewer, we were able to determine that the inverted element existed at the outer radial edge of the exploded material as seen in <ref type="figure">Figure 4</ref>. These boundary elements are mixtures of material and vacuum. By culling the boundary elements based on the percentage of material, we were able to answer the question: is the inverted element an isolated fragment, tenuously attached, or a portion of the main body? This illustrates a potential algorithmic issue with the computation of magnetic forces in a mixed element. This hypothesis was verified using the derived magnetic force vector, J x B, which in <ref type="figure">Figure 1</ref> shows anomalous values at the inverted element. Additionally, the time history of neighboring elements indicates a precursor phenomenon involving temperature, as shown in the time dumps in <ref type="figure" target="#fig_2">Figure 5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSIONS AND FUTURE WORK</head><p>Automatic feature location and extraction combined with visualization of color-coded variables mapped into the three-dimensional topology and components of the finite element mesh provide a powerful tool for visually debugging simulation codes. By showing the user multiple variable values in their spatial context, how these values change over time, and how a combination of element and node variables interact, our tools allow the user to examine the simulation at a higher level of abstraction than a conventional textual debugger can provide.</p><p>In the future, we intend to generalize our derived variable capability to allow users to enter expressions using variables generated by the simulation to produce arbitrary derived element or node variables for display in the viewer. Additionally, we want to tie histograms and statistical information in the query tool back into the viewer, so that the user can filter the display of elements by selecting sections of the histogram.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>The inverted element, which is highlighted in black, is surrounded by a neighborhood of elements. Elements are colorcoded by processor id.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>External faces showing selected element blocks provide context for the mesh subset shown in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>The image on the left shows time dump 16. On the right is time dump 17. The inverted element is highlighted in black. Elements are colored by temperature and culled to show only higher temperatures.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">ACKNOWLEDGMENTS</head><p>We thank Daniel Carroll for providing the element inversion code and for test data sets. The DOE Mathematics, Information, and Computer Science Office funded part of this research. The work was performed at Sandia National Laboratories. Sandia is a multi-program laboratory operated by Sandia Corporation, a Lockheed Martin Company, for the United States Department of Energy under Contract DE-AC04-94AL85000.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Performance Analysis and Visualization of Parallel Systems Using SimOS and Rivet: A Case Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gordon</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Symposium on High-Performance Computer Architecture</title>
		<meeting>the Sixth International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2000-01" />
			<biblScope unit="page" from="360" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Visual Programming and Debugging for Parallel Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>Browne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Syed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jack</forename><surname>Hyder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keith</forename><surname>Dongarra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Newton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Parallel &amp; Distributed Technology: Systems &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="75" to="83" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visual Debugging of Visualization Software: A Case Study for Particle Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><surname>Crossno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Angel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;99</title>
		<meeting>Visualization &apos;99</meeting>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="417" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Case Study: Visual Debugging of Cluster Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><surname>Crossno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rena</forename><surname>Haynes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization</title>
		<meeting>Visualization</meeting>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="429" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Visualization Tool for Analyzing Cluster Performance Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rena</forename><surname>Haynes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patricia</forename><surname>Crossno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE International Conference on Cluster Computing</title>
		<meeting>IEEE International Conference on Cluster Computing</meeting>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="295" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On-the-Fly Visualization and Debugging of Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><forename type="middle">C</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">H</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milon</forename><surname>Mackey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vineet</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Chien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings International Workshop on Modeling, Analysis, and Simulation of Computer Telecommunication Systems</title>
		<meeting>International Workshop on Modeling, Analysis, and Simulation of Computer Telecommunication Systems</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="386" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Integrated Visualization of Parallel Performance Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karen</forename><forename type="middle">L</forename><surname>Karavanic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jussi</forename><surname>Myllymaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miron</forename><surname>Livny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barton</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="181" to="198" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Debugging with the MAD Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kranzlmüller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grabner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Volkert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="199" to="217" />
			<date type="published" when="1997-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Role of Graphics in Parallel Program Development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Hintz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xianwu</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="215" to="243" />
			<date type="published" when="1999-06" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
