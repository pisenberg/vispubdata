<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ray Traced Scalar Fields With Shaded Polygonal Output</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1990-10">October 1990</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Ph.D</roleName><forename type="first">Ray</forename><forename type="middle">J</forename><surname>Meyers</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Ph.D</roleName><forename type="first">Michael</forename><forename type="middle">B</forename><surname>Stephenson</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Sandia National Laboratories Applied Mechanics Division I11 Albuquerque</orgName>
								<address>
									<postCode>87185</postCode>
									<region>NM</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department, 368 CB Brigham Young University Provo</orgName>
								<orgName type="laboratory">Engineering Computer Graphics Laboratory Civil Engineering</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Utah</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Ray Traced Scalar Fields With Shaded Polygonal Output</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1990-10">October 1990</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>An algorithm is presented for rendering scalar field data which reduces rendering times by as much as two orders of magnitude over traditional full resolution images. Less than full resolution sampling of the scalar field is performed using a fast ray tracing method. The sampling grid points are output as a set of screen based Gouraud shaded polygons which are rendered in hardware by a graphics workstation. A gradient based variable resolution algorithm is presented which further improves rendering speed. Several examples are presented.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent years have witnessed a great increase in the use of computers for solving engineering problems. As computational power increases, more and more algorithms appear which model physical processes using digital computers rather than physical scale models or experiments. Many of these algorithms, such finite difference calculations, use discrete approximation methods to solve a continuous problem, yielding an answer in the form of an orthogonal grid of data points, each of which represents the converged value of the answer at that point in the model. In this paper we consider the specific problem of the graphic display of three-dimensional scalar data fields. These can be thought of in general as threedimensional orthogonal grids of points in space, for which there is assigned a scalar value of some variable (temperature, pressure, stress, concentration, etc.) at each point in the grid. Although the grid is orthogonal, spacing between grid planes is not necessarily constant. We wish to render an entire three-dimensional function field in a single image which will retain and highlight the threedimensional spatial distribution of the scalar over the field. We consider carefully the competing demands of image quality and interactivity (rendering speed), and gear the algorithm for maximum speed consistent with usable image quality.</p><p>Most early algorithms for display of threedimensional scalar fields were concerned with extracting an iso-valued surface from the data field for rendering using conventional polygonal techniques. The Marching Cubes algorithm positions a moving cube within each region of the scalar field and reliably extracts a planar approximation of the isovalued surface <ref type="bibr">[lO]</ref>. A variation of this technique called the Dividing Cubes algorithmoutputs the approximate surface as a series of points rather than a plane, a technique which becomes escient when the size of the cubes approaches pixel size <ref type="bibr" target="#b2">[3]</ref>.</p><p>Other display techniques divide the object space into a three-dimensional grid of cubes called VOXels (volume elements), each of which is treated as a small subset of the image. The cuberille technique specifies a scalar threshold value which defines the surface to be created. A binary classification is used to classify each voxel as either inside or outside the surface, and the approximate surface is rendered by outputting the faces of the cuberilles along the boundary <ref type="bibr" target="#b6">[7]</ref>. An improved shading algorithm for cuberilles results in a much smoother representation <ref type="bibr" target="#b1">[2]</ref>. A somewhat similar approach is the octree approach, which organizes a space hierarchically into subsets of ever smaller cubes. Each voxel is classified to be inside, outside, or partially inside the surface. If partially inside, the voxel is decomposed into its octants, and each octant is retested until the surface is described in arbitrarily fine detail. When the octree is traversed, the faces of the voxels are output as a representation of the surface[ 111.</p><p>All of the surface based algorithms above are based on the assumption that the data can be represented usefully by one or more iso-valued surfaces. More recent research focuses on imaging the volume data directly. The goal is to give a more holistic view of the entire data set than is possible with surface based techniques.</p><p>In the additive reprojection technique, parallel rays are traced entirely through a voxel array, summing the intensity along each ray to produce an intensity at each pixel <ref type="bibr">[6, 81.</ref> This yields a simulated x-ray image of the data. The source-attenuation reprojection technique assigns a source strength and attenuation coefficient or opacity to each voxel. This allows the summing of opacity along the ray, yielding an image with variable opacity at each pixel. A related approach traces a ray through the voxel array until a surface is found, then assigns intensity based on the inverse distance from the eye[l7]. This yields an image with depth cueing as the shading method.</p><p>The particle systems introduced by Reeves, which use small, volume-filling particles as the basic modeling primitive, have been successful in modeling not only density phenomena, but also light emitting processes such as fire <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">131</ref>. Particle systems are particularly useful for dynamic systems.</p><p>Recently, algorithms have emerged which are intended expressly for scalar fields and geared to clarity and understanding of the data rather than pure realism. The varying density emitter model renders the field as a system of particle light sources[l4]. The field is ray-traced and the ray evaluated for characteristic values of the field function such as maximum value along the ray, distance to maximum, and attenuated intensity. The image is modeled in Hue-Saturation-Value ( H S V ) color space, and the characteristic values mapped to the HSV components. Typically, the maximum value is mapped to hue, the distance to saturation, and intensity to value. The resulting image for a continuous function somewhat resembles bright lights in a fog, with 'hot spots' in the field being rendered as bright but fuzzy light sources.</p><p>The v-buffer algorithm uses computational cells rather than pixels as the basic volume element[l6]. A computational cell is a rectangular volume with data values at each vertex, rather than at the cell center. A trilinear variation of the field is computed for each cell, smoothing the function over the entire computational cell. This method avoids the blocky image rendered by voxel-based systems with small data sets. The shading model used allows variable color and transparency, external light sources, surface shading, and texture mapping to provide threedimensional clues to the function model. Rendered images can vary from threshold or surface rendering with shading to transparent, wispy images with no external shading.</p><p>Researchers at PIXAR have presented a technique for rendering strikingly realistic images of volumes containing a mixture of materials, a criterion commonly satisfied in computed tomography and magnetic resonance scans <ref type="bibr" target="#b4">[5]</ref>. A main feature of this algorithm is that voxels are not classified as a single material in a binary fashion. Instead, each voxel is specified as containing percentages of one or more different materials. The density and color of the voxels are weighted averages of the materials present. Virtual surfaces are inferred by the algorithm wherever two materials of different densities meet. The surfaces are represented in terms of surface strength, and not as a binary value indicating whether the surface is present or not. A robust shading algorithm is implemented which provides a high degree of realism as well as spatial data visualization.</p><p>The algorithms described above give good results for a wide range of scalar field data sets. However, interactivity is largely sacrificed for image quality. We describe here an algorithm which gives good image quality and near interactive speed (&lt; 10 seconds) for large data sets. The hardware required is fairly common: a graphics workstation with 10+ MIPS performance, graphics hardware to render 5000+ shaded polygons per second, and a full 24 bits per pixel color frame buffer. Of course, higher performance hardware will increase interactivity. The algorithm combines ray tracing methods with hardware polygonal output to achieve the required speed. Interested readers are encouraged to review recent work by <ref type="bibr">Levoy[S]</ref>, which has several points in common with the algorithm described below. The next sections will describe the ray tracer used, lighting models, and the overall algorithm in detail. A final section gives conclusions concerning the algcrithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Ray Tracer</head><p>The ray tracing algorithm used here is essentially a simplified version of that described by Snyder and Barr[l5], and similar to that used by <ref type="bibr">Sabella[l4]</ref> or <ref type="bibr">Upson and Keeler[l6]</ref>. In order to simplify ray/object intersections, the scalar field is always aligned with the coordinate axes, and the viewing position is rotated in world space. A mapping is established from pixel to world coordinates, and intersections are calculated in actual world coordinates.</p><p>With any discrete sampling technique such as ray tracing, a crucial consideration is the frequency of sampling to be used along the ray. In calculating the color to be assigned to any sampling ray, the function is sampled at several points along the ray, and the results summed up to approximate the integral for that ray. If too few points are sampled, inaccuracies result; if too many points are sampled, the calculation becomes intractable.</p><p>Voxel based volumetric rendering algorithms typically assume a constant value for the function within each voxel and a constant voxel size, greatly simplifying the integration (summation) process. If the voxels are small enough, this is a good approximation. For small data sets, however, the im-o Bilinear Sampling Points 0 Trilinear Sampling Points <ref type="figure" target="#fig_0">Figure 1</ref>: Two Averaging Methods for Ray Tracing age looks blocky and unnatural. This blockiness is avoided by defining cells which have function values at each vertex and allowing trilinear smoothing for any point interior to the ce11 <ref type="bibr" target="#b16">[16]</ref>. Typically, a stepping length is specified for the ray, and the function sampled at each step. Due to the trilinear averaging and multiple samples per cell, this method can be very computationally intensive.</p><p>The sampling algorithm used here represents a compromise between the two methods described above. The algorithm relies on the assumption that the computational mesh used is well graded, i.e., that small cells are placed where function gradient is large, and larger cells where the gradient is small. Sampling is done only at the faces of each computational cell (see <ref type="figure" target="#fig_0">Figure 1</ref>). The value at the face then becomes a bi-linear average of the four vertices of the face. Each face of the cell is sampled, the values averaged, and the ray length through the cell used to sum the values along the ray. The sampling frequency thus varies with the mesh size and (hopefully) therefore with the function gradient. Of course, if the function changes too much or has a highly non-linear change within the cell, the accuracy of the approximation may be insufficient. This sampling algorithm works well for the data fields we typically render, which are generally well graded meshes and the resulting function fields generally well behaved.</p><p>When a sampling ray is cast, the algorithm first checks whether the ray intersects the model. This is easily done by checking for intersection with the six oriented planes which bound the model. Since each of these planes (and indeed all faces of all cells in the field) are constant in either z,y, or z , this intersection calculation is very simple. If the cell is found to intersect the model, the cell indices of the penetration point are calculated, and the ray is stepped through the model. For each cell pierced, the algorithm calculates the function value at the entry and exit points using bi-linear averaging among the cell face vertices. The average value and distance traversed are calculated and passed to the lighting model for integration. The termination criteria for the ray are determined by the lighting model used and are discussed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Lighting Models</head><p>Two different lighting algorithms were implemented for calculating model colors. The first is a simple model for transmission of light through a set of translucent surfaces, and uses the standard Red-Green-Blue (RGB) color scheme. The second is a different system using Hue-Saturation-Value ( H S V ) color representations. These two approach-are described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Simple RGB Mapping</head><p>This technique treats the individual function value/length pairs from the ray tracer as a series of translucent surfaces which may both emit and attenuate light. <ref type="bibr">Sabella[l4]</ref> states that the total light intensity remaining after traversing n translucent surfaces is</p><formula xml:id="formula_0">n i -1 I = ~e , n+, ~~ i = l j=1</formula><p>where e i is the light emitted from the ith surface, and 4, is the transmittance factor for the surface.</p><p>Since light from the surface must pass through the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I -</head><p>The T factor is used to scale the fi term; higher values of 7 increase attenuation, causing more rapid darkening of the image. The intensity is calculated for red, green, and blue wavelengths independently to arrive at the color triplet for each ray.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">HSV Color Mapping</head><p>The second color model, an HSV based approach, is a simplification of that proposed by <ref type="bibr">Sabella[l4]</ref>. The intensity of the sampled point is determined by calculating the attenuated intensity exactly as in the RGB method, except the calculation is no longer a function of wavelength. The maximun intensity of each ray is also stored, normalized, and mapped into the value component for the pixel. For this implementation, the saturation component is held constant at maximum value. The HSV colors are then converted to RGB values for use by the output hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Comparing Lighting Models</head><p>Although both lighting models gave good picture quality, the characteristics of the two differ somewhat.</p><p>The HSV model is simpler to use, especially for a first picture, because the normalization of the HSV values assures that a good spread of color values will be seen. Additionally, the HSV system allows some quick adjustment of colors on an image without recalculating: by remapping the hue component upward or downward, the color range of the image is nearly instantly modified. Because the hue is based on the maximum value encountered, the HSV system always maps maximum color values and integrates only the intensity, whereas the RGB system integrates the colors and intensity simult aneously.</p><p>The RGB system is somewhat more difficult to control, but has more potential for extension. Opacity, surface shading, environment mapping, and other more sophisticated techniques can be used with this formulation if desired. That extensibility has yet to be proven for the HSV model. Though two methods are described here, there are several other lighting models available, all of which can be utilized within the algorithm as well. In fact, any method which ultimately produces an RGB value for each sampled ray is permissible. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Rendering Algorithm</head><p>Previous sections have described in detail how an arbitrary ray may be traced through a scalar field model. We now look at the overall rendering algorithm in terms of casting a series of rays in order to render an appropriate image. We will describe a new rendering algorithm which attempts to greatly decrease image rendering time by combining ray tracing techniques with a polygonal output scheme. In simple terms, the ray tracer is used to sample the function at each node of a polygon, and the custom hardware of the computer workstation utilized to quickly render the polygon using smooth (Gouraud) shading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Fixed Resolution Rendering</head><p>The simplest rendering possible with the hybrid algorithm is a fixed resolution image. First, a sampling resolution is specified for the image. For a sampling resolution of n, a ray traced sample of the function is made every nth pixel in both x and y directions. Using this fixed resolution sampling grid, the algorithm directs the workstation hardware to render the image as a set of contiguous, square, Gouraud shaded polygons having vertices coincident with the sampling grid <ref type="figure">(Figure 2)</ref>. The resulting image is a smooth approximation of the true image which requires only l/n2 as many samples as the full resolution (one ray per pixel) image. The number of samples may be further reduced by calculating the bounding box of the image in screen coordinates. Any sampling points lying outside the bounding box are set directly to background color, with no further work required.</p><p>The usefulness of a fixed resolution image depends upon the data sampled, the sampling frequency, and the intended use of the image. The <ref type="figure">Figure 2</ref>: Fixed Resolution Sampling Method smoother the function (that is, the smaller the rate of change of the function gradient), the closer the output scheme comes to approximating the exact function, and the lower the required sampling resolution for a good image. Data with high function gradients will require a correspondingly high sampling frequency to properly resolve the image details.</p><p>Though a fixed resolution image with a low sampling frequency may sometimes lack the detail necessary for a finished rendering, it is still an excellent time saving tool for the user. Using a series of fixed resolution images, the user can quickly establish the proper viewing, color and lighting parameters. Then, a higher resolution image can be made as a finished product. Because a low sampling frequency image may be one to two orders of magnitude faster, this time savings can be significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Incremental Resolution</head><p>Regardless of the rendering method used, graphics applications must always try to balance the competing demands of image quality and interactivity. One approach to solving this problem is often called adaptive or progressive refinement[l, 41. The goal is to produce a rough image very quickly for user feedback, and then continuously and gracefully refine this image until finished, or until the user changes An incremental resolution image requires an initial or coarse sampling size, and a final or fine sampling size. The algorithm first renders a low resolution image using the initial sampling size. The sampling size is then halved, all points on the new grid not already calculated are sampled <ref type="figure" target="#fig_2">(Figure 3)</ref>, and the new polygon set output to the screen. This process repeats until the final sampling size is reached, and algorithm terminates. Incremental resolution requires the same number of sampling rays as would the low resolution algorithm using the final resolution size; the incremental method simply performs the sampling in an order which allows the display of intermediate results. The incremental algorithm is slightly slower, due to the output of several sets of polygons as well as a small amount of overhead to keep track of sampling order. The advantage of this approach is that an initial image is displayed much faster, and then incrementally updated. This gives the user the feeling that the incremental method is much faster, rather than slightly slower, than the equivalent fixed resolution image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Gradient Based Resolution</head><p>As has been mentioned, the accuracy of the polygonal output scheme is dependent on the gradient of the function (or more precisely, the color) for the data used. It is obvious that the resolution accuracy required for an image is based upon the maximum gradient of the image (which usually occurs in a fairly small area of the image), and that requiring the same high resolution throughout the image gives rise to inefficiency. We present here a simple algorithm which allows variable resolution based upon the gradient of the color between adjacent sampling points.</p><p>We define the gradient between any two points to be the sum of the absolute value of the differences of the rgb components of the color:</p><p>The algorithm requires an initial grid size, a final grid size, and a gradient tolerance tol. First, a low resolution image is rendered using the initial grid size. Then, a refining algorithm is repeatedly applied to the grid until the grid size reaches the final size, or until there are no points at which the color gradient exceeds the tolerance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">The Refining Algorithm</head><p>The refining algorithm examines each polygon in the current grid size and attempts to break each into four quadrants. Five new nodes are created, four on the midpoints of the polygon sides, and one in the middle. For each midside node, the algorithm examines the gradient between the endpoints of that side. If grad &gt; tol, then a new sampling ray is traced through the model to determine color at the midside node; otherwise, the color assigned at the node is the average of the colors of the endpoints. If any of the midside nodes of the polygon require sampling, the center point is also sampled. If all midside nodes are averaged, then the center point is assigned a color based on the average of the left and right midside nodes.</p><p>As each polygon is checked in turn, the refining algorithm also keeps track of any exterior rows or columns of the current grid where no new sampling has taken place for the current pass. Using this information, the limits of the sampling grid are modified to exclude low resolution areas. The effect of this is to allow the algorithm to zoom in  on the high gradient portions of the image, ignoring areas for which resolution is already sufficient. For many typical data sets where there is one area of high function gradient, this makes the algorithm extremely fast. When repeatedly refining the sampling grid and allowing the extent of the grid to shrink with each iteration, it is normal to have areas of the output image where polygons of unequal size are conjoint. In this case, we must insure that the boundary between these polygons always appears smooth. The averaging scheme used in dividing follows exactly the rules of Gouraud shading; therefore, as long as all boundaries between unequal sized polygons have only averaged nodes, the composite image will appear smooth. By shrinking the active sampling grid only when no new sampling takes place along a row or column, we effectively enforce this condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Performance Comparisons</head><p>In order to judge the relative performance improvement possible with the new algorithm, two test cases were selected for comparison. Each test case shows a reduction in rendering time of nearly two orders of magnitude, with no noticeable loss in image quality. Even greater gains can be realized for coarse sampling rates, a useful capability for high speed interactive analysis of the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Examples</head><p>Several examples have been chosen to display the utility of the algorithm for analysis purposes. <ref type="figure">Figure 4</ref> is an image of the flame database, a finitedifference simulation of a methane flame burning in air rendered at full resolution. <ref type="figure">Figure 5</ref> shows the same data rendered using a sample spacing of 8 pixels. The quality of the two is comparable, though the second was rendered 40 times faster. <ref type="figure">Figure 6</ref> is a wireframe representation showing the finite difference grid used for the consol furnace, a simulation of a full scale utility boiler. Fuel and oxygen, introduced near the bottom of the furnace, are mixed and burned in the combustion chamber, with waste products being carried around the 'nose' of the furnace and through the outlet near the top. At the outlet, the exhaust is split into four paths by a set of plenums used to increase heat exchange. <ref type="figure">Figure  7</ref> is a rendering of carbon monoxide concentration within the furnace during simulation done using the RGB color model. The image shows CO escaping through the outlet, indicating incomplete combustion of fuel within the boiler. This image also shows a swirling pattern marking the mixing vortex of the furnace. <ref type="figure">Figure 8</ref> is a rendering of the same consol furnace using the HSV color model. Colors for this image are peak values along the ray, giving the feeling of an x-ray image. Also clearly shown is the splitting of the outlet stream into four sections at the outlet. <ref type="figure">Figure 9</ref> is an image of a corner fired furnace, with fuel and oxygen being introduced in the four corners of the combustion chamber at angles designed to produce a central mixing vortex in the furnace. The scalar being rendered is free oxygen. The inlet streams can be clearly seen, with the front oxygen jet impinging on its neighbor. Mixing in the simulated furnace is inadequate, allowing a sheet of free oxygen to excape up the rear wall of the furnace and through the outlet, reducing combustion efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>A new hybrid algorithm was presented for the volumetric rendering of scalar fields. The technique is geared for interactivity without sacrificing ultimate image quality. By combining less-than-pixel sampling resolution with high-speed polygonal output, performance improvements of two orders of magnitude are possible. With the increase in speed, volumetric images of this type can be generated and manipulated easily, making the tool viable for everyday use, rather than to generate occasional highquality 'finished' images. Variable-gradient resolution techniques allow a range of resolutions within a single image, allowing high-resolution volumetric images at a small fraction of the cost of full resolution sampling.</p><p>For fast rendering, the algorithm depends on hardware to quickly output gouraud shaded polygons. Because the output polygons are already in screen coordinates and aligned with the screen axes, the algorithm does not require any transformations of the polygon vertices, but only fast fill with bilinear averaging of colors through the polygon. For this reason, the algorithm could be run with fairly reasonable speed by simply outputting the polygons on a pixel-by-pixel basis using software shading. However, the algorithm does require a full 24 bit per pixel frame buffer, and it seems unlikely that a workstation would be designed with ful color capability without having corresponding hardware transformation capabilities. By using a suitable lookup table, the algorithm may be effective with as few as 12 bits per pixel, a very common configuration of current graphics workstations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>preceding i - 1</head><label>1</label><figDesc>surfaces, the total transmittance for light from that surface is the product of the preceding (i -1) 4 terms. The emitted light for surface i with function value fi and thickness 6t is where c is the color intensity of the surface as a function of the wavelength A as well as the function value. The attenuation factor for the surface is Q .e -~f , 6 t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Incremental Sampling Grid some image parameter. We can perform a similar refinement by varying or incrementing the resolution of the image to add progressively more detail.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>The flame database is a small simulation of a methane flame burning in air, and utilizes a grid of 50 x 12 x 12 for a total of 7200 data points. The second test case is a database of a pulverized coal utility boiler called the 'consol' database. The consol database has grid resolution of 90 x 55 x 45 for a total of 222,750 data points. Tables 1 and 2 show elapsed times (not CPU seconds) for the two data sets using conventional full resolution (1280 x 1024), a low resolution plot utilizing sample spacing of n = 4 pixels, an incremental plot with resolution varying from n = 16 to n = 4, and a gradient based plot varying from n = 16 to n = 4 with a gradient tolerance of 0.2 color units. All tests were done on a Silicon Graphics Personal Iris graphics workstation with a full complement of color bit planes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Rendering Times for Consol Database</figDesc><table><row><cell>1 n/a I 4 16 I 4</cell><cell>n/a n/a</cell><cell>~~ 48 54</cell><cell>~~~ 0.065 0.073</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgement</head><p>This work is sponsored in part by the National <ref type="figure">Science Foundation</ref>  </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Image rendering by adaptive refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><surname>Bergman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Grant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><surname>Spach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1986-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Surface shading in the cuberille environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lih-Shyang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabor</forename><forename type="middle">T</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">Anthony</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayaram</forename><forename type="middle">K</forename><surname>Udupa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="33" to="43" />
			<date type="published" when="1985-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Two algorithms for the reconstruction of surfaces from tomograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorenson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sigwalt</forename><surname>Ludke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><forename type="middle">C</forename><surname>Teeter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Medical Physics</title>
		<imprint>
			<date type="published" when="1988-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A progressive refinement approach to fast radiosity image generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Micheal</forename><forename type="middle">F</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shenchang</forename><forename type="middle">Eric</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">R</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">P</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loren</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="65" to="74" />
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Noninvasive numerical dissection and display of anatomic structure using computerized x-ray tomography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lowell</forename><forename type="middle">D</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">A</forename><surname>Robb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tak</forename><forename type="middle">S</forename><surname>Yuen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erik</forename><forename type="middle">L</forename><surname>Ritman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the Society of Photo-optical Instrumentation Engineers</title>
		<imprint>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="75" to="84" />
			<date type="published" when="1978-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Threedimensional display of human organs from computed tomograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gabor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hsun</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kao Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Image Processing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="1979-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Combined surface display and reformatting for the threedimensional analysis of tomographic data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><surname>Heinz Hoehne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">L</forename><surname>Delapaz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralph</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">C</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">vestigative Radiology</title>
		<imprint>
			<date type="published" when="1987-08" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="658" to="664" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Volume rendering by adaptive The Visual Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="2" to="7" />
		</imprint>
	</monogr>
	<note>refinement</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Marching cubes: A high resolution 3d surface construct ion algorithm . Co m p ut e r Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvery</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Geometric modeling using octree encoding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Meagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Image Processing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="129" to="147" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Particle systems-a technique for modeling a class of fuzzy objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">T</forename><surname>Reeves</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>A C M</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="91" to="108" />
			<date type="published" when="1983-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Approximate and probabilistic algorithms for shading and rendering structured particle systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ricki</forename><surname>Reeves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Blau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="322" />
			<date type="published" when="1985-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A rendering algorithm for visualizing 3d scalar fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="5" to="6" />
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ray tracing complex models containing surface tesselations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">H</forename><surname>Snyder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="119" to="128" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">V-buffer: Visible volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Keeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="59" to="63" />
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Three dimensional computer graphics for craniofacial surgical planning and evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">W</forename><surname>Vannier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">L</forename><surname>Marsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">0</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="182" to="189" />
			<date type="published" when="1983-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
