<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visualization of scalar data defined on a structured grid -Applications to petroleum research</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Pajon</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Bui</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tran</forename><surname>Institut</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franqais</forename><surname>Du Pktrole</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bois</forename><surname>Prgau</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rueil</forename><surname>Malmaison</surname></persName>
						</author>
						<title level="a" type="main">Visualization of scalar data defined on a structured grid -Applications to petroleum research</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>W e will describe in this article some simple visualization techniques that m a y be used t o explore dynamic 3D scalar fields in a n interacfive way. Scalar data are assumed t o have been already computed, and graphic manipulafions are done afterwards on a gmphics workstation. Structured grids (finite difference grids) are used, leading to an easy and fast ezploration of the interior of a volume. Smooth animation and simuhaneous visualization of two o r three scalar fields are also described. W e have tested our methods on various types of data issuing from d i f e rent fields of petroleum engineering, i.e. oil reservoir simulation, geophysics, geology and combustion engine simulations. A demonstration videotape is available.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This paper reviews some visualization techniques that are easy to code, which may help an engineer in visualizing and exploring a three-dimensional set of data defined on a structured grid. It also attempts to describe some programs in which these techniques are combined in a way that we think logical, powerful and attractive to use.</p><p>Some of these techniques are specific to structured grids (finite difference grids), while others are applications of more general methods t o this particular case.</p><p>The specific nature of this type of space organization is fully exploited. One of its great advantages is that the user can easily travel throughout the domain he is studying, exactly as he had defined it.</p><p>The whole system of visualization expounded here aims to be very practical and interactive and to run fast on various types of data sets, provided they are not too voluminous. In this latter case, efficient improvements may easily be made in the future. Usually, our grids have small dimensions such as 30 x 30 x 30, which results in great interactivity. But, these dimensions can be larger (100 x 100 x 100). In this case, graphic manipulations can be made on a temporarily simplified model, and interactivity is thus possible.</p><p>The primary purpose of our visualization software was to facilitate the manipulation of scalar fields derived from oil reservoir simulation. Nevertheless, the graphic tools developed may be very useful in many other scientific areas.</p><p>We have focused our at tention on time-dependent scalar fields.</p><p>Our software runs on a Silicon Graphics workstation and makes use of the graphics library (GL) that is associated with it.</p><p>Finally, this paper is also intended for people who are eager to see the results of their simulation and who are not especially concerned with computer graphics. Our aim is to provide them with some ideas that will encourage them to make visualization programs and show them that it is not so difficult as it may seem a t first sight. We were among the ranks of such people six months ago, and we would have been happy at that time to be so guided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Goals of petroleum engineering</head><p>These goals are principally the search for reservoirs, their exploitation, the transformation of hydrocarbons into their derived products (oil refining) and the use of these products such a gasoline in engines. We will take examples extracted from all these areas, except for oil refining, and we will mainly stress the examples of production, or, more specifically, oil reservoir simulation.</p><p>A reservoir is a porous rock formation that contains water, oil and gas. It is exploited in several stages.</p><p>In the first stage, wells are sunk and production is due to pressure drawdown and water release.</p><p>In the second stage, water or gas is injected to displace fluids. This is called a secondary or enhanced recovery technique.</p><p>There may be a third stage, which makes use of chemical or thermal processes. Injection of chemicals (surfactants, polymers) and temperature increase may significantly improve the flow properties of the fluids contained in a reservoir. Thermal methods include steam injection and in situ combustion.</p><p>The quantity of oil that may be recovered depends on the properties of the rock formation, such as porosity and permeability, which measure the ability of the fluids to go through the interconnections in the pore spaces.</p><p>In this way, the production from oil fields leads to the study of scalar parameters such as rock type, pressure, temperature, flow quantities, i.e. saturations in water, steam, oil, etc.</p><p>All the sectors of the petroleum industry are the object of intensive research at IFP (Institut Franqais du PBtrole). Numerous codes have been developed, which are used by clients in many countries. Voluminous files of data are produced both by IFP and petroleum companies. Visualization of these results has remained rudimentary for a long time. It was static, not interactive, and was restricted to cutting The use of dedicated hardware (Silicon Graphics) will give us better understanding of the complicated, dynamic and three-dimensional nature of these data. The pictures thus created will be exploited in multiple ways: t o adjust programs, t o facilitate research and comprehension of physical phenomena at IFP, to offer practical guidance, t o spread techniques and knoweledge and to do advertising in industry.</p><p>planes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Examples of visualized data</head><p>The examples shown in this paper are the following: </p><formula xml:id="formula_0">0 in reservoir simulation,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Our own experience in visualization</head><p>Our activity has developed in two stages. In the first stage, our concern was to create rapidly a practical and user-friendly tool for manipulating medium-size files of scalar data with great facility. We wanted to see the evolution of scalar parameters defined for a simple 3D object made of hexahedra organized in a structured grid. The dynamic behavior was to be rendered by continuous variation ( in time and space ) of color over surfaces of the object. Since we were in a three-dimensional space and wanted to move around in it, we wanted to be able t o modify the POsition of the object (or the observer) in an interactive way. The visualized domain also had t o be strechable to enable us to concentrate on particular regions of interest. To render dynamics, animation was made possible a t the same time as geometric manipulations.</p><p>Roughly speaking, two types of representation methods were investigated, depending on whether the 3D object was considered as a set of surfaces or as a set of hexahedra.</p><p>The first method is more practical though less convenient in some cases. Its principle was to consider the whole 3D object in three possible ways, i.e. a boundary surface made of six partial surfaces, a series of layers, or a triplet of crossed surfaces. Of course, these surfaces could be moved interactively. Color was interpolated between grid points.</p><p>In the second method, we visualized layers of hexahedra in a way that better suits the needs of some geologists. They attribute a material to each hexahedron, such as clay, limestone or sandstone. A discrete palette is thus constituted, with each color corresponding to one material. Therefore, each hexahedron has one color, and interpolation makes no sense. Then, our program enabled the user to see the distribution of these materials through all the space by giving him the possibility to select the visualized materials, while the others remained transparent.</p><p>An alternative to this approach was to render only values on grid nodes, represented as small cubes or spheres scattered in space.</p><p>All these programs have the property of being interactive and of using the same basic functionalities.</p><p>In the second stage, we developed a rendering method directly inspired by a paper by P. <ref type="bibr">Sabella ([7]</ref>). This method, where each pixel is calculated by ray tracing, is too independent of the Silicon Graphics graphics library to be fast and interactive. Nevertheless, it provides an original vision of geologic data that we will explore in the future.</p><p>In this paper we will limit ourselves to describing interactive programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">General scheme of a visualization program</head><p>As the object we want to see is 3D and the screen 2D, let us make the following definitions: In the most standard case where the programmer prefers to construct a set of scenes, the parameters t h a t contribute t o the final image may be classified in the following way: </p><formula xml:id="formula_1">0 image</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Geometric transformations</head><p>Three types of geometric transformations are usually used, i.e. scalings, rotations and translations. Scalings are intended to dilate the object in a given direction. At the beginning of the program, they may be used to give proper dimensions t o a disproportionate object. But, at all stages of visualization, scaling factors may be modified interactively.</p><p>Rotations and translations define the location and sizes of the window to which the object will be projected, as well as the type of projection made. We have chosen a perspective projection. The object is seen through a viewing pyramid at the top of which the observer stands. We have made the following simplifications: the object is systematically centered at the origin and the observer keeps his eyes on this origin. With regard to rotations, two interpretations can be made: either we consider that the object is moved in the space, or else we consider that the observer turns around it. We have combined these two interpretations by using two blocks of rotations. The first one is attached to the observer and is used t o select three axes around which the object is rotated.</p><p>All the rotation axes go through the center of gravity of the object. Nevertheless, it can be moved in the visualization field by translating it according to the three reference axes associated with the object.</p><p>As incomplete as the strategy used may seem, it has given much satisfaction, and its use is very flexible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Time evolution</head><p>T h e time evolution that secms the most logical is to make the images succeed one another at a rhythm proportional to the one that actually governs the physical phenomenon studied.</p><p>This idea is implemented in the following way.</p><p>The database is made up of several blocks describing the phenomenon at arbitrary successive instants "of reference" stored themselves in an array that we will call t i m e . By "block" we mean the scalar values of a given type (pressure, temperature, ...) and the grid associated whith them. Each visualized scene is generated from a block of the same type.</p><p>Two parameters have to be considered. The first one is the display speed that depends on t h e number of loops during which the same image is displayed. The maximum speed that can be obtained is the speed of one loop.</p><p>The second is the "physical" time interval that s e p arates the two instants at which the phenomena associated with two successive images really happen. It is expressed in the same unit as the reference instants. Let us call it step. is positive, the operation is iterated until the end of t h e array of reference instants is reached. Then we return to the first instant. In a similar way, we can go through time in the reverse sense by a negative step.</p><p>The interest of this method is the great interactivity i t allows by enabling the user to choose the display speed and especially the step. In this manner, a very slow and smooth evolution can be obtained.</p><p>Another way to perform animation is t o display only t h e images associated with the blocks contained in t h e database without interpolating the blocks. This method doesn't cause errors sometimes due to interpolation, but it is less adjustable and frequently results in a rough succession of images.</p><p>To summarize, every time a new image is created, t h e block of data used is determined by a routine such as this one: Spatial exploration is thus greatly facilitated. It is easy to go from one point to another by following three possible ways indicated by three indices I, J, K .</p><p>Moreover, scalar values can be interpolated naturally on any geometric object.</p><p>To travel through the domain in one way by making an index vary is equivalent to describing a curve. To do it in two ways is equivalent to describing a surface.</p><p>This can be done with six routines, the first three for the three possible types of curves by selecting the way to follow, the last three for the three possible types of surfaces by letting two indices vary and one remain constant .</p><p>Obviously, the indices that remain constant are arguments for these routines.</p><p>There are two other types of arguments. The visualized domain can be restricted by defining a subvolume, i.e. subindices <ref type="figure">nio, nil, njo, nj1, nko,</ref>  Likewise, surfaces can be drawn in different ways. As they are primarily defined by a set of grid points, we can only visualize them. But this is not very impressive. To prevent this, points can be joined by lines or polygons, colored as we will see in the next section (see <ref type="figure">Figure 2)</ref>.</p><p>By assembling these routines intended t o make surfaces, we obtain three modes of representation :</p><p>A set of surfaces obtained by using several times the same routine, i.e. by always letting the same two indices vary and by giving each time a different value for the constant index. These surfaces are superposed on one another and usually don't intersect each other.</p><p>A set of three surfaces obtained by using each of the three routines. These surfaces cross themselves. The constant indices take values n i , nj, nk so that nio 5 ni &lt; n i l , njo 5 n j 5 n j , and</p><formula xml:id="formula_2">nko 5 nk 5 nkl.</formula><p>A set of six surfaces obtained by using each of the three routines twice and by successively giving the constant index the values nio,nil, njo, n j l , nko and nkl. Thus, we can visualize the boundary of the domain. <ref type="figure">nio, nil, njo,  n j l , nko, n k l , ni, n j and nk,</ref> the user can go throughout the visualized hexahedron, in the first mode, by removing and replacing surfaces piled on top of each other, in the second mode, by moving three interior crossed surfaces, and in the last mode by displacing the six boundary surfaces of the hexahedron. Obviously, this process can be combined with time evolution and geometric transformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By interactively modifying parameters</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Coding of scalar values by a palette of colors</head><p>In the preceding paragraph, we defined surfaces by assembling polygons. Scalar values are known at the vertices and interpolated everywhere else.</p><p>To color these surfaces, we construct a function that associates with each scalar value x a color given in RGB mode by the <ref type="figure">three components r ( z ) , g ( z ) ,  b ( z )</ref> . This function is discrete. To make it, a natural way is to subdivide the interval over which x is defined into subintervals of equal size with which one color is associated.</p><p>This is not always sufficient. For example, a scalar field can have all its values concentrated in a few subintervals for large portions of the visualized object, while all the other values are only in small regions. In this case, t o obtain more details, we want to be able to redefine some subintervals more precisely, or, in other words, to create subintervals of inequal size.</p><p>But, a simpler idea in coding is to create a predefined palette and to allow the user, during the visualization, t o adjust this palette interactively to any subinterval he wants. The regions where the scalar values are outside this subinterval can be colored d i s tinctly and uniformly or the colors at the extremities of the palette can be used.</p><p>The colors are selected according to the following convention: blue is associated to weak values, green with moderate ones and red with strong ones. This is equivalent to choosing a function <ref type="figure">( r , g, b )</ref> that successively takeson thevalues ( O , O , l ) , (0,1,0) and (1,0,0)</p><p>with intermediate values verifying mat(r, g, b) = 1.</p><p>According to the number of colors that will be selected, the palette will give the impression of a continuous variation or not.</p><p>The preceding color code may be described more simply in HSV mode <ref type="figure">([1],[2]</ref>), equivalent to the RGB mode but often easier to use. In this mode, a color is characterized solely by its hue, its saturation and its brightness. To follow this code, the hue has to decrease from 240' to O' , while the other components remain equal to 1. This palette can be modified advantageously by making the brightness increase from 0 to 1. In this way, dark colors are associated with weak values. In many cases, the eye may understand the scene much better . only one color may be selected, varying from dark to bright.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Supplementary tools</head><p>Transparency T h e workstation we used enabled us to experiment with two techniques of transparency.</p><p>T h e first one is interactive and gives the user the possibility of choosing a surface and attributing to it any transparency coefficient from 0 to 1. The second is automatic and attributes to each polygon a transparency proportional to the average value of the scalar field covering it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Coding of two scalar fields by a two-</head><p>dimensional array of colors The goal was to combine two scalar values in a color, i.e., to create a function that associates a color <ref type="figure">(r(z,y),g(z,y), b ( z , y)</ref>) with (z,y).</p><p>T h e two scalar fields studied are positive, and their sum cannot be superior to one at any point. They are water and steam saturations.</p><p>The idea adopted is to use the HSV model, to associate with a mixture composed of water and steam a hue that is a combination of green and blue, where green stands for the gas phase and blue the liquid phase, and to equalize the brightness with the total quantity of the two components. Saturation remains equal to 1. Use of the axis perpendicular to visualized planes to code scalar values by heights Here, when the phenomenon is visualized on parallel planes, we define a surface whose coordinates along the axis orthogonal to these planes represent the values of a scalar field on the corresponding points of the planes. This scalar field may be different from the one coded with colors. Thus, on a same location one scalar is coded with colors while another is coded with heights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Visualization by</head><p>In this case, we give each mesh or hexahedron of our 3D object a distinctive property, to which one color is assigned.</p><p>The user may wish to select any number of properties and to ''light up" the hexahedrons that possess elementary hexahedra them.</p><p>For example, if a subsoil is made of sandstone, clayey sandstone and clay, the geologist may want to see the distribution of these materials in the whole object. The idea adopted is to make appear or disappear the hexahedrons having the desired properties by selecting the corresponding colors on a palette.</p><p>This idea is programmed in a simple manner.</p><p>As soon as a modification is made, the 3D object is calculated again and displayed with this additional information taken into account. All the hexahedrons are inspected and their facets examined. A facet will be "lit up" if it is on the boundary of the visualized domain or if the neighboring hexahedron is "extinguished". This work is done very quickly, so that all the interactive functionalities (animation and geometric manipulations) of the preceding program are available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and future work</head><p>The tools we have developed have proved t o be very useful to many researchers at IFP. With them, they can visualize the data they have produced in various ways. They can test and improve simulation programs and communicate results that are easy to assess and understand. Some examples of applications are given in the figures below.</p><p>We will extend the capabilities of our software in three ways: (1) acceptance of instructured grids, <ref type="bibr">(</ref> Simultaneous visualization of different scalars would be imagined. And we would like to visualize these phenomena in a realistic way. Properties of the rock formation, such as permeability and porosity, would be rendered by texture, and the more or less transparent displacement of the fluids by volume rendering techniques. The real nature of the materials and of the fluids would be taken into account.  <ref type="figure">Fig. 4</ref>.a, we can see the steam propagate from five vertical injection wells to one horizontd production well. In <ref type="figure">Fig 4.</ref>b, the pressure is represented by color and the steam saturation by elevation on four transparmt planes. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>1. parameters for constructing a set of scenes a. interactive b. noninteractive 2. parameters for converting these scenes into an image a. interactive b. noninteractive Generally, the structure of an interactive visualization program may be reduced to a loop composed of the following elements : 0 manipulation of parameters 1.a and 2.a 0 determination of the image 0 display of the image Parameters 1.a and 2.a may be: Parameters 1.a 0 number of scenes 0 for each scene choice of a database made of coordinate arrays and scalar values arrays choice of the representation mode lines connecting grid points surfaces colored according to the scalar values * with or without interpolation determination of the visualized subvol--choice of colors choice of time evolution ume Parameters 2.a 0 type of projection 0 position of the observer 0 direction of his view 6 Examples of interactive programs 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>The first image displayed by the program is associated with the first reference instant fime[O] and thus with the first block contained in the database. The second image must be associated with the instant time[O] + step. As this instant is not necessarily in the database, the corresponding block of d a t a must be computed. The solution chosen was the simplest one, i.e. calculating it by a linear interpolation between the two blocks so that their indices i and i + l verify time(;] 5 time[O] + step 5 t i m e [ : + 11. If step</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>case animation choice 1 .. no animation keep the same block 6 . 3</head><label>163</label><figDesc>smoofh animafion if display time is exhausted given the previous instant and the interval of time betawn two images, calculate the current instant and the interpolation coefficient, and select the two data blocks to be used for interpolatkn store the result of the interpolation in the block to visualire2. step-by-sfep ammation if display time i s exhausted substitute far the current block of data the block thai follows it in the database 3Visualization by surfaces 6.3.1 Basic tools Graphic primitives At a fixed instant, the data we have t o consider arc scalar values defined on a structured grid. To manipulate these data more easily, values and grid points are stored in a similar way. So, we have: the number of points = M three arrays of size M : X, Y and Z to store the coordinates in the three reference axes with M points any number of arrays V of size M to store the values in these points of scalars fields Moreover, these arrays are three-dimensional and M = N I x NJ x Xh', so as to order points and values in three possibles mays that are not at all arbitrary.The points are organized in the space exactly in the same way as in these arrays. It is the same thing if we consider objects constructed by rejoining neighboring points as triangles. quadrilaterals, hexahedrons.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>nkl so that 0 5</head><label>5</label><figDesc>nio 5 nil 5 N I , 0 5 njo 5 nj1 5 N J and 0 5 nko 5 nkl 5 N K . This results in reduced sizes for the surfaces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The set of all possible colors can be displayed in a triangle whose tops have black, blue and green as extremal colors corresponding to the values (O,O), (0,l) and (1,O) of the two scalar fields.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>2) acceptance of vector fields, and (3) addition of new interactive functionalities. Special interest will be attached to attractive and original areas such as simulation of multiphase flows in a heterogeneous medium and the behavior of the multiple chemical components of fluids such as oil.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Simulation by the SARIPth progran of an enhanced recovery method steam flooding in a reservoir of heavy oil in Canada. In</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :!Figure 5</head><label>45</label><figDesc>Simulation by the HERESIM program of a subsoil constituted of sandstone, clayey sandstone and clay These materials can be removed and replacrd alternatively and Intrracrl\cly by siniply selecting the rorresporiding colors on a palette I--.". , .s.w .'K,f#q(ICTWJ, (Color Plate 141, page 483) Two modes of representation of the same scalar field. Siniulation bj the liI\'A prograin of oil concentration in the combustion chamber of a piston engine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>or picture = array of pixels displayed by a graphics program on a screen;</figDesc><table /><note>0 scene = colored geometric object constituted of lines and polygons and imagined by the program- mer in a 3D space;0 parameter = any element that contributes to the creation of a scene or an image An image may be obtained with two methods, either directly by calculating a color for each pixel, or in- directly by constructing a set of scenes and by let- ting the graphics processors of the computer tranform these into an image. The first method frequently leadsto long computations and not to interactive visualiza- tion. Its only advantage is that the programmer can supervise what he is doing much better and test vari-ous techniques that may be very effective, such as ray tracing. All the parameters are devoted to obtaining a 2D image and they are completly controlled by the programmer.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>24Oo,O0J. In this way, few colors or I constant J constant nJo I J s nJ I nloi t i nli I , SURFACE 2 (nj) r</head><label></label><figDesc></figDesc><table><row><cell>I I</cell><cell>for I = nlo t o nl I SURFACE 1 (1)</cell><cell>REPRESENTATION RODE 1 for J = njo to nj I SURFACE 2 (J)</cell><cell>Another useful possibility is to enable the user to choose the angular sector covered by the hue instead 1 1. R0Of 3 II 1 1 J of fixing it a t [I I SURFACE 3 (K)</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgments</head><p>The authors would like to thank P. Corlay and I. Morelon (Reservoir Engineering Division), and S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Henriot (Energy Application Techniques Division)</head><p>for providing the data sets used in this paper.</p><p>We thank also C. Lallemand and G. Legendre for their participation and C. Puech for his advice.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Interactive computer graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gillies</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Van Dam A. Fundamentals of Intemctive Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982" />
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Haber</surname></persName>
		</author>
		<idno>SIG- GRAPH&apos;88</idno>
		<title level="m">Visualization in Engineering Mechanics : Techniques, Systems and Issues Visualization Techniques in the Physical Sciences</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">H</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>De Fanti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<title level="m">Visualization in scienfific computing Computer Graphics</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">21</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Technical and Economic Evaluafion of Steam Injection With Horizontal Wells for Two iypical Heavy-Oil Reservoirs Proceedings of the Annual Technical Conference and Exhibition of the Society of</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Petit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-M</forename><surname>Renard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valentin</forename><forename type="middle">E</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Petroleum Engineers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Modelisation tridimensionnelle de l&apos;aerodynamique et de la combustion dans un moteur a allumage commande La combustion dans les moteurs d&apos;automobile, Editions Technip</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pinchon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Baritaud</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page">90</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Rendering Algorithm for Visualizing JD Scalar Fields Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIG-Graph)</title>
		<meeting>SIG-Graph)</meeting>
		<imprint>
			<date type="published" when="1988-08" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page">58</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
