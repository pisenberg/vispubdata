<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Numerical Met hod for Rendering Spherical Reflect ions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Dobkin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
								<address>
									<postCode>08540</postCode>
									<settlement>Princeton</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>Panduranga</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Johns Hopkins University</orgName>
								<address>
									<postCode>21218</postCode>
									<settlement>Baltimore</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><surname>Zhu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Johns Hopkins University</orgName>
								<address>
									<postCode>21218</postCode>
									<settlement>Baltimore</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Numerical Met hod for Rendering Spherical Reflect ions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Reflections in curved surfaces add a n additional dimension to the visualization of computer generated scenes. Conventionally, they are generated by either tezture mapping or ray tracing. However, these methods have serious drawbacks restricting their use in many applications. In this paper, current methods in rendering reflections in curved surfaces are examined. A numerical algorithm to derive spherical reflections is presented as a promising alternative. This algorithm exhibits many attractive properties, e. g. , low computation cost, object space coherence, resolution and device independence, etc. Furthermore, this inethod can be generalized to render reflections in a family of curved surfaces. 2 Current Schemes There are two main schemes for generating scenes with reflections. One, terture mapping, simulates reflections and is limited in scope. The other, ray tracing, is a simple yet brute force method for rendering scenes with reflections. We will describe them in order. 2.1 Simulated Reflections by Texture Mapping Tezizlre mapping was first introduced by Catniull (Catmull, 1974; Blinn et al., 1976). Suppose that there is only a single reflecting object in a sceiie. We also assume that the other surroundiIig objects and light sources are at great distances from the reflecting object, and occlusions of the environment by parts of the reflecting object itself are ignored. Wilh these simplifying assumptions, the environment appears to</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Reflections add another dimension t o the visualization of computer generated pictures. In many practical applications, such as computer visualization, product design, computer arts, mathematical modeling and advertisement, reflections in the scenes make them look more realistic. However, many researchers in computer graphics have focused chiefly on generating pictures with smooth shading and shadows, but ignored reflection. This is primarily due to the lack of sufficient geometric knowledge to systematically render computer reflections in the three-dimensional space, in spite of much research that has been carried out in the field of geometric optics. Optics studies reflections, for applications to the effective design of optical instruments, of point sources. However, this is not sufficient in computer graphics, where it is necessary to study reflections of objects more general than point sources.</p><p>A close look a t virtually any computer synthesized picture reveals that smoothly-shaded curved surfaces are necessary to achieve realism, since many objects found in nature, as well as those made by man, have curved shapes. Our paper will thus concentrate bn techniques for generating reflections in curved surfaces.</p><p>the reflecting object as a picture painted on the inside of a large sphere. The object itself is deemed to be positioned at the center of this sphere. Then, the environment can be modeled as a two dimensional texture map indexed by polar coordinate angles. This texture is mapped onto the reflecting object in the following way to simulate the reflection of environment in the object. For each picture element representing a portion of the reflecting surface, the direction of the ray which is reflected to the eye is computed. The polar coordinate angles of this direction are used as indices into the above texture map to determine the reflected light intensity.</p><p>The chief advantage of texture mapping is that it allows a reflecting object to have a complicated surface. The major drawback is that mutually reflecting objects are difficult, if not impossible, to handle. Rendering reflections by texture mapping is further complicated by multiple reflections. Moreover, texture mapping assumes that light sources and objects to be reflected are far away from the reflecting object. This requirement has seriously restricted people from using texture mapping in many domains. This method has some other shortcomings in common with the second method, ray tracing, which has gained much popularity in the last decade.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Ray Tracing</head><p>Ray tracing was invented by Goldstein et 01. <ref type="bibr">(1967)</ref>, and popularized by <ref type="bibr" target="#b11">Whitted (1980)</ref>. <ref type="figure">Figure 1</ref> illustrates the basic working of the ray tracing algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1: Ray tracing basics</head><p>A ray R is traced from the eye E towards a pixel P on the logical display. If this ray intersects the surface of an object in the scene at a point 0, the color of point 0 is used to compute the color of pixel P. If the surface at 0 is a reflecting one, a reflected ray R' is generated according to the laws of reflection <ref type="bibr" target="#b1">(Born and Wolf, 1965)</ref>, and this reflected ray is traced in turn. If it hits another object at a point S, the color contribution of the surface a t S is suitably scaled with the reflecting coefficient of the surface at 0, and added to the color of P. This is illustrated by the following simplified equation.</p><p>where C p is the color attributed to the pixel P, CO is the color contribution of the surface at 0, Cs is the color contribution of the surface at S, and KO is the reflecting coefficient of the surface a t 0.</p><p>Multiple reflections can be easily accomplished by spawning more reflected rays and adding the color contribution of the intersections with the objects to the color at pixel P. The rendering of the scene is complete when rays to all the pixels of the display screen have been traced.</p><p>Ray tracing is a simple yet powerful and general method for rendering scenes with realism. It was the first algorithm to yield satisfactory visual images that resemble true reflection. In addition, ray tracing encompasses many more aspects of picture generation than just reflection. This power is derived from the fact that ray tracing is modeled after several aspects of the visual process.</p><p>Ray tracing is an extremely CPU-intensive process. For example, to render a scene with a resolution of 512 x 512 pixels and single level reflections, 512 x 512 x 2 = 524,288 rays must be traced (2 because there is both a primary ray and a reflected ray). It turns out that a major portion of the CPU time is spent computing intersections of these rays with the objects in the scene.</p><p>Having recognized this serious drawback, most researchers have focused on devising methods to speed up the ray tracing process. These include such methods as dividing the world into an octree data structure <ref type="bibr" target="#b5">(Glassner, 1984;</ref><ref type="bibr" target="#b4">Fujimoto et al., 1986)</ref>, or arranging the world a s a constructive solid geometry tree <ref type="bibr" target="#b12">(Wywill et al., 1985;</ref><ref type="bibr">Wywill et al., 1986)</ref>, which in general take advantage of the image space coherence to reduce the number of intersection calculations to be performed per ray. Other ray tracing schemes include beam tracing <ref type="bibr" target="#b6">(Heckbert and Hanrahan, 1984)</ref>, and cone tracing (Amanatides, 1984), etc., which either lack image accuracy or work quite slowly.</p><p>In computer graphics, conventional methods achieve speed by exploiting both object space and image space coherence. However, in the field of ray tracing, little work seems to have been done on exploiting the coherence properties of the objects in the scene to reduce the number of rays traced. Moreover, a given ray is computed independently of the other rays adjacent to it. This approach is quite wasteful, as it is very likely that rays close to each other will intersect the same object. In this case, it would be advantageous to trace one ray, and use the information gained in computing adjacent rays. Some research <ref type="bibr" target="#b10">(Speer et al., 1985)</ref> has addressed this issue in the image space. Few gains were reported with this approach, because of the overhead involved in maintaining coherence information.</p><p>We take an approach similar to those conventional methods for generating reflections by using of object space coherence. We demonstrate that, by making use of coherence, certain objects in the scene can be rendered very rapidly without using ray tracing at all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">No Analytic Solution for Rendering Reflections</head><p>Reflections in plane mirrors are well-behaved. The reflection in a plane mirror is virtual, is of the same shape and size as the source, and the position of the reflection is such that "the image behind the mirror is at the same distance from the plane mirror as the object i s in front of." On the contrary, reflections in curved surfaces are very different and defy analytical methods to characterize them. It is known that there does not exist a simply definable reflection (what shape the reflection would be) in a curved surface, even in a sphere, the simplest class of curved surfaces <ref type="bibr" target="#b1">(Born and Wolf, 1965)</ref>. This is rather disappointing, since it eliminates the possibility of getting a clean solution to the problem.</p><p>However, a careful study of ray tracing reveals that there might exist other alternatives for rendering reflections in curved surfaces. Recall in ray-tracing, a ray R is traced from the eye E to a pixel P on the logical display screen ( <ref type="figure">Figure 1</ref>). If this ray intersects a surface at point 0, the shading of the surface at 0 is used to compute the shading of pixel P. If the surface at 0 is a reflecting one, a reflected ray R' is generated and traced in turn. If the reflected ray R' hits another object at point S, the shading contribution of the surface at S is suitably scaled and added to the shading at P. This leads to an immediate observation. Even though there is no simply defined virtual image point, there exists a unique point 0 on the surface of the reflecting sphere, such that the ray starting from a given point S has to reflect off the surface at this point in order to reach the eye situated at a given position. We can extend this idea further. Consider all the rays originating from points on a given object which reach the eye after reflection on the surface of a convex body. The points of incidence of all such rays on the reflecting surface lie within a closed region. There exists a clearly defined boundary of such a region. This can be observed in <ref type="figure" target="#fig_0">Figure 2</ref>, which depicts the reflection of sphere B on sphere A. The boundary of the reflection is what we call the contour. Our belief is that if we are able to find this contour, we can then fill in the region enclosed by the contour in a fast and efficient manner. We say this because, for the points in such a region, we know the exact objects that are involved in the reflection. Hence we need not trace as many rays as a ray tracer does. We can use interpolation or other suitable methods to improve efficiency.</p><p>Even with the above simplification, it is hard to tackle the geometry of reflections analytically. To see this, we can focus our attention to the reflection in the simplest of curved surfaces, spheres. We further reduce the dimensionality of the problem from three to two. Essentially, we attempt to obtain the reflections of one circle on another. Applying the laws of reflections to solve the problem, it was quite unexpected that we got a sixth degree equation in two independent variables. The derivation was done using a symbolic manipulation language, and the result is too complicated to be presented in this paper. Instead, we offer an intuitive explanation. Besides the two "normal" reflections, which are physically realizable, we can find four other "abnormal" solutions, which are physically unrealizable, though they are ge-ometrically realizable. These "abnormalities" satisfy all of the reflection laws, i.e., they all satisfy the sixth degree equation. <ref type="figure">Figure 3</ref> depicts two physically realizable reflections from a circle S to another circle 0, whereas <ref type="figure">Figure 4</ref> shows a physically unrealizable reflection A' corresponding to point A in <ref type="figure">Figure 3</ref>. Though it is possible to clip off these abnormalities for circle reflections by imposing additional constraints, this can be done only after we get the re-flections, which requires the solutions to the original sixth degree equation. It is well-known <ref type="bibr">(Herstein,</ref> 1975; <ref type="bibr" target="#b8">Jacobson, 1974</ref>) that a general algebraic equation with degree greater than four is not solvable in closed form as a function of its coefficients, using radicals. Moreover, this sixth degree equation does not possess useful properties like symmetry. Therefore, the possibility of reducing the order of the sixth degree equation is almost zero.</p><p>Given the difficulty of the problem in 2-D, the extension to 3-D is unapproachable. Therefore, we are forced to abandon the search for analytic solutions and look for alternative approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Numerical Algorithm to Generate Spherical Reflect ions</head><p>We have already shown that it is not feasible to render reflections in curved surfaces by analytic solutions. Meanwhile, we have made the observation that it is possible to find the contour enclosing the reflection, and then fill the region ( L e . , the reflection) in a fast and efficient manner. This motivates us to propose a numerical method to solve the reflection problem in curved surfaces. We point out that, since we want to find the contour enclosing the reflection, we may use the contour tracing algorithm <ref type="bibr" target="#b3">(Dobkin et al., 1986)</ref>. Briefly, this algorithm acquires an initial point, and proceeds by finding successive points on the contour. These points are found by taking small steps along the tangent to the curve, and searching in a direction perpendicular to the tangent to "get back" onto the curve. This algorithm is general-purpose, and the points generated are device independent.</p><p>However, there are some drawbacks in the contour tracing algorithm. There is extra overhead due to its general-purpose nature, and the tracing is usually quite slow. Moreover, contour tracing renders only the projection of the contour, which potentially gives less information than generating the contour directly in 3-D. Another limitation is that contour tracing has to acquire, instead of producing automatically, the starting point on the contour. This restriction has kept it from becoming widely used.</p><p>As an alternative, we propose a numerical method to render reflections in curved surfaces. Even though this algorithm is not as general-purpose as the contour tracing algorithm, it offers many extra benefits, such as low computation cost, rendering the reflection in 3-D instead of its projection, etc., which make this algorithm very attractive. Here, we discuss this method applied to the reflections in spheres.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Circle Reflections</head><p>First, we consider the two-dimensional version of spherical reflections, i.e., the generation of reflections between two circles. The result can be easily extended to the three-dimensional case, because of the first law of reflection, Yhe incident ray, the reflected ray, and the normal to the surface at the point of incidence, all lie in the same plane". <ref type="figure">Figure 6</ref> shows two circles centered at points 0 and S respectively. The eye is at position E, and the circle S is to be reflected to the circle 0. The problem is to find the points A and B on the circumference of circle 0, which correspond to the contour of reflection from S to 0: the ray EA is reflected by the circle 0 to the ray A P which is tangential to the circle S, and EB is reflected to BQ tangential to the circle S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E .</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6: A circle reflecting another</head><p>We assume that 0 lies a t the origin, and S lies on the x-axis. To solve the problem numerically, we start out with an initial guess for the solution. For a naive guess, we can take the point of intersection of the circle 0 with the line OX which bisects LEOS <ref type="figure" target="#fig_2">(Figure 7)</ref>. More intelligent guesses are possible; but, for illustration purposes, this simple guess is adequate.</p><p>Consider the ray EX and the direction XR it takes after reflection in the circle 0. We can compute the direction XR simply by the laws of reflection. The vector analysis used to compute the direction XR is shown in (2).</p><p>A point on the circle 0 ( <ref type="figure" target="#fig_2">Figure 7)</ref>, satisfies the equation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Z o Z = r 2 (2)</head><p>where x' represents the vector from the origin 0 to the point X, r is the radius of the circle O_, and 0 represents the dot product of vectors. Let V be the vector from the eye to the point X, which corresponds to EX, and I? be the normal vector to the _circle 0 a t point X. Then the reflected ray direction R, which corresponds to XR, is given by <ref type="bibr" target="#b11">(Whitted, 1980)</ref> where We then compute the algebraic perpendicular distance from the point S to the line XR. For the line XR to be tangential to the circle S, this distance should equal p, the radius of circle S . If the computed distance is not equal to p, we make an adjustment to the current guess by a binary search technique. That is, when the distance is greater than p, we search the range between OX and OS; when the distance is less than p , we search the range between OE and OX. The new guess yields a point X' and reflected ray X'R'. We iterate until the tangency condition is satisfied within the precision required. When this happens, the solution is said to have converged to the reflection A. We can use similar technique to get the reflection corresponding to the point B in <ref type="figure">Figure 8</ref>. The initial guess still uses the bisector of LEOS. The adjustment procedure is also identical to that of A, except that the distance from S to XR should be -p to justify that XR is tangential to circle S. We can use the same method to get the reflections when E is either completely or partly hidden from circle 0 by circle S. The main concern is choosing the right initial search range of reflections, to derive both efficiency and correctness. Using a thorough case study, we are able to generate all of the one level reflections in 2-D, regardless the spatial combinations of the eye position and the circles. The case study is omitted in this paper for the sake of brevity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Spherical Reflections</head><p>The numerical algorithm in the two-dimensional space can be easily extended to the three-dimensional case. Consider two spheres 0 and S, the eye position E, and the plane S E 0 <ref type="figure">(Figure 8)</ref>, which intersects the spheres 0 and S in two circles. The normal to the reflecting sphere 0 at any point on the intersection circle also lies in the plane since the origin 0 is in the plane. If the rays that emanate from the eye lie in this plane, the reflected rays are restricted to lie in the same plane because of the first law of reflection. Thus the problem in 3-D reduces to that of a plane and thus can be solved using the numerical algorithm in 2-D. We get two points on the required contour. We can imagine the plane rotating about a line through EO, sweeping the sphere S in small increments, until it becomes tangential to the sphere on either side. For each position of the plane we solve the two dimensional problem and get two more points on the contour. The collection of all such points yields the desired contour. After we find this contour, we can get the reflection by efficiently filling in the shadings for the region enclosed by the contour. (This topic will be covered in the next section.) I I W <ref type="figure">Figure 8</ref>: Plane through the eye and the center of reflecting sphere 0</p><p>To a certain extent, the increment used for sweeping in this algorithm will determine the smoothness of the contour. However, besides simply decreasing the magnitude of increment, there is another attractive alternative. We can use spline approximation to interpolate the points on the contour, which are not generated by the sweeping algorithm. This is a very important observation. Using our algorithm to produce enough points on the reflection, we can render the contour by a bicubic spline by using these points as control points. This could potentially minimize the computation cost, and guarantee smoothness of the contour.</p><p>Another attractive feature is that our algorithm can be used to render reflections in spheres at any spatial combination of the eye position and spheres, provided that such combination is valid (e.g., the case when the eye lies inside a sphere is not valid). Moreover, it can generate reflections among any number of spheres, because we can always transform any pair of spheres to the "standard" positions, as show in <ref type="figure">Figure 8</ref>. Then we can apply our algorithm to obtain the reflections. Finally, we perform an inverse transformation to get the reflections in the original coordinate system. This argument also applies to the reflections in the two-dimensional space. With this observation, we only need to maintain a kernel package to handle the "standard" case, which therefore preserves the simplicity of the algorithms. Using this kernel, along with the necessary transformations, we get the three-sphere reflection scene with single level reflection in Plates 1 through 4.</p><p>Of course, we might need to take hidden surface elimination into account since spheres and reflections might hide each other.</p><p>Having solved the first level reflection, we are able to extend these ideas to multiple level reflections quite successfully. The algorithms and analysis are long, and have been omitted from this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Shading Model</head><p>Suppose we already have obtained the contours enclosing the sphere reflections. We need to find a way to fill in the enclosed regionb.</p><p>The contours generated by our numerical algorithm consist of points which have one-to-one correspondence to points on the reflected spheres. This gives us a hint as to how to generate the shadings for the reflections. We can add the shading contribution from the corresponding points of the reflected spheres with proper filtering, to the shadings of the points on the reflecting spheres. However, merely doing this is not sufficient, as the regions within the contours constitute the main part of the reflections. Therefore, we should also take into account their reflection contribution.</p><p>Once again, this problem can be effectively resolved by simulating ray tracing. Suppose we want to find the added shading contribution for a point A by reflecting sphere S to sphere 0. Recall that a primary ray shot from the eye E will hit sphere 0 a t A, and the reflected ray will in turn hit sphere S a t another point B. The shading contribution from B should be added to the original shading at A without considering reflections. This will give us the correct shading a t A with the first level reflection. Therefore, we can compute the shadings for single level reflections as follows.</p><p>We shoot a primary ray from the eye to any surface point A lying within the contour (the boundary of reflection) on a sphere, and trace the reflected ray until it hits another sphere at a point B. Then, we add the shading a t B after proper scaling to the original shading at A without considering reflection. This is the final shading for the surface point A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(5)</head><p>where Ci and Ck are the shadings without considering reflections; CA is the shading with the first level reflections, and K A is the reflecting coefficient a t the surface point A. When considering projection, we need to project (either perspectively or parallelly) points A and B to the logical display. Plates 1 through 4 depict the simulated shadings for two, three, four, and five-sphere reflections respectively. The pictures are essentially identical from those obtained from ray tracing.</p><p>We have to point out that this shading model uses brute force, which may not be necessary. Efficiency would be improved by incremental computation, that is, if we can compute the shading of point within the reflecting contour by utilizing the shadings of its neighboring points. With perspective projection, our initial attempt to solve this problem was not very successful. With orthographic project ion, however, we have achieved certain success by using a variant of the scan conversion method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation and Perspective</head><p>There are a lot of advantages to this numerical algorithm for rendering spherical reflections. First, it involves much less computation overhead than either the ray tracing algorithm or the contour tracing algorithm. Empirical results have shown that the computation cost ray tracing involved to generate visual images with single level reflections is approximately twice to six times more than that for the numerical method with perspective projection and a resolution of 600 x 600 pixels. With orthographic reflections, the difference is even more significant. Moreover, the gain will be further increased when we use high resolution displays. We have also observed that computing the reflections (more appropriately, the silhouettes of reflections) constitutes only a marginal fraction of the total cost for our numerical method. In other words, most of the computation is used for computing shading. If we could bring down the portion for computing shading by using a reasonable incremental or approximation scheme, our method would be further improved.</p><p>A theoretical explanation for the cost difference between ray tracing and the numerical method is that ray tracing needs to trace rays to each pixel on the logical display, which involves extensive computation. The numerical method, on the other hand, only computes the boundaries of reflections. Therefore, the cost for computing reflections is mainly determined by how many points we need on the boundaries, and how fast our initial search ranges for the reflections converge to the real reflections. As experiments have demonstrated, this usually constitutes only a fraction of the cost for ray tracing, when the reflecting objects in the scene are not too many.</p><p>Most of our work is done in the object space instead of the image space. This numerical algorithm is able to generate the reflecting contours, which are critical intermediate results to determine the final reflections. Therefore, this algorithm can be carried out in both device independent and resolution independent manners. These attractive properties are, however, not possessed by most ray tracing algorithms.</p><p>Compared with the contour tracing algorithm, our numerical algorithm has shown other benefits than merely low computation cost. First, it does not require a starting point. This algorithm can actually be adopted by the contour tracing algorithm as a complement to find the initial solution. Moreover, our algorithm yields contours in 3-D as opposed to the projections of 3-D contours by the contour tracing algorithm. This preserves more information.</p><p>Some study indicates that the extent of our numerical method is not limited to spheres. On the contrary, reflections in many three-dimensional curved surfaces can be rendered in a similar fashion. The best examples are ellipsoids. However, trivially transforming ellipsoids to spheres, obtaining the reflections, and inverse-transforming the reflections back, will not work, because reflections are eye position dependent. Nevertheless, We strongly believe that rendering the reflections in ellipsoids can be carried out in a manner similar to that used for spheres. This is due to the fact that ellipsoid reflections can be obtained by converging search ranges to real reflections. This observation inspires us to take ellipsoid reflections as our next goal.</p><p>Moreover, if we can get reflections of more general objects (e.g., algebraic swjaces with limited volumes) with analogous methods to our current one, then it is possible to develop a systematic way, combined with constructive solid geometry (CSG), to render a whole family of reflections numerically. We already have much confidence in generating reflections in planar surfaces, which has been thoroughly studied in geometric optics. If only we can render reflections for more general objects numerically, we would have a much better chance to systematically evolve this method.</p><p>Another interesting problem is animation of reflections. It is known that the reflections in the curved surfaces are eye position dependent. Still, it appears to be wasteful to regenerate the reflections afresh, whenever the eye position is changed. There are no kuown algorithms effectively utilizing the coherence of information, to handle animating reflections in the curved surfaces, either in image space or in object space. Nevertheless, we believe there is some coherence between the "current" reflections and the "next" reflections, assuming the reflections are changing smoothly. In this sense, an object space algorithm is much more promising than an image space algorithm, as the latter requires a regeneration of the picture from scratch even with the slightest change of the scene. We hope our numerical method, which offers more information about reflections than ray tracing or contour tracing, will provide an effective way of animating spherical reflections with minimal modifications to the current scenes. This will be of much importance in visualizing reflections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we have examined the current schemes for generating reflections in curved surfaces. We have demonstrated that rendering reflection is a very hard problem, as it defies analytic solutions. Moreover, we proposed a numerical algorithm to render spherical reflections. This algorithm has many attractive qualities, such as low computation costs, object space coherence, device and resolution independence, and generation of maximum information about reflections in curved surfaces. Furthermore, we have indicated several alternatives for generalizing our method to a broader domain.</p><p>At this stage, there are many avenues to be explored, such as an efficient way to compute shading for reflections, and extension of our algorithm to the reflections of more general objects than simple spheres. We have already sensed that this 'hewcomer", in the family of reflection algorithms, will stand out as an important technique in rendering and visualization of reflections in 3-D space.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Reflection of sphere B on sphere A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5 Figure 4 :Figure 5 :</head><label>545</label><figDesc>displays the other physically unrealizable reflection A" corresponding to A. Similarly, we can find two physically unrealizable reflections corresponding to point B in Figure 3. E Figure 3: Physically realizable circle reflections b A physically unrealizable but geometrically realizable reflection Another physically unrealizable but geometrically realizable reflection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 7 :</head><label>7</label><figDesc>Numerical solution</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Texture and Reflection in Computer Generated Images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Blinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Newell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communication of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="1976-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Principles of Optics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Born</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wolf</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1965" />
			<publisher>Pergamon Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A Subdivision Algorithm for Computer Display of Curved Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1974" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Univ. of Utah</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Robust Contour Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Thurston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Wilks</surname></persName>
		</author>
		<idno>CS-TR-054-86</idno>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
	<note type="report_type">Princeton University Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ARTS: Accelerated Ray Tracing System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fujimoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Iwata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE CG&amp;A</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1986-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Space Subdivision for Fast Raytracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Glassner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE CG&amp;A</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1984-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Beam Tracing Polygonal Objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1984-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Topics in Algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">N</forename><surname>Herstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975" />
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Basic Algebra I</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jacobson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974" />
			<publisher>W.H.Freeman and Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Reflections in Curved Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>Panduranga</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-10" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Univ. of Princeton</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Theoretical and Empirical Analysis of Coherent Raytracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">R</forename><surname>Speer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">D</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Barsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Interface 85</title>
		<meeting>Graphics Interface 85</meeting>
		<imprint>
			<date type="published" when="1985-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Improved Illumination Model for Shaded Display</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Whitted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1980-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Functional Model for Constructive Solid Geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wywill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Kunii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Ray Tracing with Cones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wywill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Kunii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shirai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Space References 1. J. Amanatides</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1984-07" />
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
