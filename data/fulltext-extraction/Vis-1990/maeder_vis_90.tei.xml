<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Animation Techniques for Chain-Coded Objects</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anthony</forename><forename type="middle">J</forename><surname>Maeder</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="laboratory">Computer Imaging Research Laboratory</orgName>
								<orgName type="institution">Monash University</orgName>
								<address>
									<postCode>3168</postCode>
									<settlement>Clayton</settlement>
									<country key="AU">AUSTRALIA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Animation Techniques for Chain-Coded Objects</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Chain coding is a common boundary representation for objects used in image analysis. When animating digital image sequences for visualization, it is often convenient to retain this representation. Methods for scaling, rotation and elastic deformation of objects based solely on chain code elements are discussed here. Quantized methods transform groups of chain code elements into other groups while incremental methods construct the transformed chain code element by element.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Data representation is an important issue in computer animation. Computational expense can be restricted by using a representation of objects in the scene at higher than pixel level.</p><p>The savings occur because the high-level representation requires comparatively little space to store Object data and because animation operations need only be applied to this smaller body of data. The scene must then be reconstructable quickly and cheaply from the high-level representation for each frame in the animation sequence. Oach of these representations satisties the above criteria and allows the oblect shape to be reconstructed exactly or to be approximated to a visually acceptable depree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This paper is concerned with the animation of</head><p>Animation of objects with these representations requires transformations to be applied t o data in the high-level representation, followed by scan conversion to reconstruct the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CH2913-2/90/0000/0067i! ยง01 .OO -1990 IEEE</head><p>The work described here demonstrates the usefulness of boundary chain coding L 4 1 representation f o r animating 2 -U objects. The chain code is a sequence of elements indicating displacement from the current boundary pixel to the next boundary pixel on the object. This is a compact way to represent the object boundary because few bits a r e needed to specify the relative position of the next pixel.</p><p>For this reason chain coding is often used in image compression 1 5 1 .</p><p>Chain coding is also frequently used to measure object shape properties such as perimeter, area and overall extent 1 2 1 . The same approach can be used at coarser than pixel resolution to generate shape numbers f o r shape characterization.</p><p>Chain coding arises naturally in much of image analysis, for instance representing the disjoint regions when an image is segmented 131.</p><p>In animation related to image sequence analysis, such as extrapolation or synthesis of changes for visualization purposes, it would be convenient to retain the original chain code representation so that image analysis measurements could still be made.</p><p>The expense of transforming a large number of points to achieve the required animation might be counteracted by the convenience o f not needing to scan convert boundary points for the object. 'l'his paper demonstrates that various cheap approximate transformations exist for chain coded objects which achieve similar effects to conventional transformations on higher level data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantized Transformations</head><p>In general, translation, scaling, rotation and elastic deformation transtormations are needed for animating 2-D objects. Chain codes f o r objects are interpreted as a sequence o f relative pixel addresses. In order to reconstruct the object from the chain code, the address o f the first pixel must be given. Translation of the object is always achieved by changing this address and without any alteration of the chain code. This transformation will thus not be discussed further here.</p><p>The simplest way in which the other transformations can be achieved for chain codes is to specify each elementary case of a transformation by its effect on a few of adjacent chain code elements. Changes in the overall chain code due to the transformation are approximated concatenating these elementary 'quantized cases.</p><p>Any chain code sequence which represents an object with a whole number of elements will be transformed to another such sequence. Some straightforward ways f o r doing this are described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scaling</head><p>Horizontal (or vertical) scaling up by an integer factor can be achieved by appropriate repetition of each chain code element in that direction (e.g. repeating each occurrence of elements 0 and 4 when doubling the length of an object horizontally).</p><p>Those elements with no component in the direction of scaling are unaffected (e.g. 2 and 6 in the above example).</p><p>However, elements with some component in the scaling direction (e.g. 1, 3 , 5 and 7 ) must have that component scaled accordingly. For horizontal doubling, this is achieved by using the closest horizontal element in conjunction with the diagonal element (e.g. 1 becomes 01 or 1 0 ) .</p><p>The choice of 01 or 10 etc. depends on the context defined by the surrounding chain code elements. For instance, 0 1 might be used if a 0 immediately preceded the 1 being scaled horizontally, to preserve the directional continuity of the edge.</p><p>This choice is largely arbitrary and affects the local appearance of the object boundary and the object area but not its overall perimeter or extent.</p><p>Since the increase in the number of horizontal ( o r vertical ) elements is always exactly the scaling factor, an originally closed boundary will remain closed.</p><p>An example of scaling horizontally by factor of 2 using different context strategies' is shown in <ref type="figure" target="#fig_13">Figure   2</ref> .</p><p>The individual element transformations used are shown in <ref type="table" target="#tab_2">Table 1</ref>.</p><p>Combining horizontal and vertical. scaling can be achieved by performing first one then the other, o r by precombining the effects of both scalings on the elements. The latter approach gives smoother results f o r diagonal elements and briefer chain codes. For instance, successively scaling element 1 by factors of 2 horizontally and 3 vertically might yield 01, then 0212; considering the two scalings jointly might yield 112 instead. The same effect can be obtained hy post-processing the result of b : the separate successive scalings to look for element groups (e.g. 02) that could be replaced by a simpler code (e.g. 1). There may be differences in the perimeter and area of an object generated by the two different methods but the overall extent would be the same.</p><p>Quantized scaling along directions other than horizontal and vertical can be approximated by using appropriate component values. For small objects, changes in area and perimeter will not be as obvious as for large objects during an animation sequence. For small objects then, 0 can be transformeg to</p><formula xml:id="formula_0">1 , 1 to 2 etc. for a 4 5</formula><p>counter-clockwise rotation.</p><p>Oth%r cases which are integer multiples of 45 can be treated similarly.</p><p>For large objects, sequences of several elements can be replaced with a different number of rotated elements (e.g. 000 could be transformed to 11. since Z f i approximates 3 fairly well). counter-clockwise by both methods. <ref type="table" target="#tab_4">Tables 3 and 4</ref> show the sets of sequence transformations used.</p><p>Ln both methods distortion is introduced to the ob.ject so that closure (i.e. endpoint transformation accuracy 1 cannot be guaranteed. The last few elements might need to be chosen to force closure and the resulting object boundary wi 11 be distorted. This situation is less significant for sequence rotation applied to large objects but nevertheless motivates the need for a non-quantized approach to rotation as discussed later. When using the quantized approach, errors can accumulate if several rotations are computed successively; so the precombined transformation approach ip preferred (e.g. using ope rotation of 135 rather than three of 4 5 1 .</p><p>Rosation by specified angles of less than </p><formula xml:id="formula_1">-(i.e.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">8 . 5~~</head><p>) .</p><p>An exarnple of counter-clockwise rotation of 2 6 . 5</p><p>using <ref type="table" target="#tab_6">Table 5</ref> is shown in <ref type="figure" target="#fig_3">Figure 4 ( c )</ref> .</p><p>The line length is not preserved in these rotations, . so perimeter, area and extent of the new object will be different from the old. This effect can be reduced by careful choice of sequences. bor example, the new sequence 1 1 1 in <ref type="table" target="#tab_7">Table 6</ref> could be replaced by 11 to give a length of 2~5 , which better approximates the actual length of 3 than 3 f i does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Elastic Deformation</head><p>How one chain code should be changed into another is a complex problem to which many different approaches exist (e.g.</p><p>[ l ] 1 6 1 ) .</p><p>In the application considered here, two scenarios for the process need to be considered. In order to incorporate registration information, the above linear approach can be applied piecewise over each pair of m corresponding chain code sequences. This means that some arithmetic calculations are necessary tor each section o t the boundary rather than once per object. For instance, if the five elements in bigure 1 ( b ) correspond successively to sequences 0, 0 0 5 5 , 4 4 3 , 2 and nothing in <ref type="figure">Figure   P</ref>(a), m and n take values <ref type="figure" target="#fig_3">of 1 , 1 , 1 , 1 , 1  and 1 , 4 , 3 , 1 , 0</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Incremental Transformations</head><p>The quantized transformations above are limited to rather coarse changes, such as scaling by integer factors and rotation by fixed angles. It is necessary to perqorm finer transformations than these for in-betweening.</p><p>In t.he cases o f rotation and elastic deformation, some distortion of the ob.iect can result, producing perimeter and area variations which can accumulate if the transformations are concatenated. It is desirable to restrict the amount of such distortion which occurs.</p><p>An incremental approach, as is used for scan converting, can satisfy both of these requirements.</p><p>This approach relies on maintaining indicators of the error between the current true position of the transformed object boundary and the actual position reached by transformed chain code elements which approximate the boundary.</p><p>The generation of new elements from old is performed by predicting the actual posit ion , inspecting the indicators, choosing new elements that will minimize the cumulative error and updating the indicators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scaling</head><p>As before, scaling transformations can be separated into horizontal and vertical components and separate indicators would be maintajned for these. lnitially the indicator values are both zero. For each chain code element of the object boundary, new elements are generated for the transformed object boundary. 'The indicators are then changed to represent the effect of these elements independently on the horizontal and vertical errors. Elements may be chosen ( o r discarded) according to some strategy based on the indicator value.</p><p>For example, when an indicator registers an error of 0 . 5 or more, another element could be generated in that direction. Dynamic strategies are also possible, such as forcing the indicator sign to alternate. horizontally.</p><p>The chain code sequence produced would be 110 using a fixed maximum error threshold of 0.5, or 1 0 1 using the alternating sign strategy. The horizontal error indicator values would be 0.33, 0.67, <ref type="figure" target="#fig_14">0 . 0 and 0 . 3 3 ,</ref> -0.33, 0.0 respectively. It is possible that closure of the ob.ject will not he maintained by the process described above, since the error indicators may not return to zero at the end of the generated chain code sequence.</p><p>As noted previously, this problem can be overcome by joining the endpoints after the transformation has been performed.</p><p>The incremental method permits scaling by any real factor in any direction to be performed within nominated accuracy constraints.</p><p>The object in <ref type="figure" target="#fig_13">Figure 2</ref>(a) is shown scaled by 0 . 5 horizontally in <ref type="figure">Figure 6</ref>  Values for the indicators and elements chosen are shown for each step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rotation</head><p>The quantized approach to rotation can result in perimeter and area distortions. lhese distortions can be controlled in incremental methods.</p><p>Both perimeter and area for chain coded ob.jects may be computed by sequential algorithms which construct partial results as they traverse the chain code.</p><p>Indicators could be maintained for error in these partial results and used to decide which element to generate next. Alternatively, horizontal and vertical error indicators could be used, as for incremental scaling. In conjunction with the rotation tables described before, these would enable the new element sequence to be modified if the error was too high to accept it in whole.</p><p>Rotation by an arbitrary angle can be achieved by construction of an appropriate rotation table and dynamic modification of the entries where necessary.</p><p>For very small angles this would result in little change over much of the chain code sequence with only occasional elements needed to satisfy the indicator error constraints.  to give an in-between view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Elastic Deformation</head><p>In both methods described f o r quantized elastic deformation, the calculation of the number of elements to choose f o r each section of the object boundary could be regarded as a type of static indicator. A further application of indicators in this transformation is keeping track of horizontal and vertical errors in the element sequence. In this case the choice of particular elements along each section could he determined with reference to these indicators. This brings the elastic deformation process closer to the model of piecewise linear transformation mentioned previously. <ref type="figure">Figure 8</ref> demonstrates how the additional indicators could be used to generate deformation similar to <ref type="figure">Figure 5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion</head><p>The use of chain codes as a boundary representation for 2 -D objects undergoing animation has been shown to be practical for several typical transformations. Various different methods for implementing the transformations have been described. The low cost of quantized methods, which rely on table lookup and minimal arithmetic, must be weighed against the increased accuracy offered by incremental methods, which maintain error indicators to ensure minimal differences between ideal and generated chain codes.</p><p>Some scope exists to make the sequences for transformation of chain code sequences more sophisticated. One possibility is to put more weight on the use of context in deciding which chain code elements to choose. If contexts were considered at a higher level than individual elements, some consistency of overall shape properties for an object could be retained (e.g. cornerso could obe sharply defined by using only 90 or 45 sequences). The use of more complicated elastic deformation models is another direction for future investigation.</p><p>Non-linearity in the transformation could be introduced by weighting the number of elements used in each section by factors other than the section length.              </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>home conventional hish-level representations for these ob.lects are vertices, spline control points, and sets of elementary polygons.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure l(a) shows the 8 direction elements and Figure l ( b ) shows simple chain coded object.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>vertically, or by a factor of fi in the direction arctan 2. General scaling by non-integer factors in any direc.tion requires the use of non-quantized methods, introduced later. Rotation A distance problem arises when rotation is considered because elements 1 , 3 , 5 and 7 represent distances of fi along the object boundary whereas 0, 2, 4 and 6 represent distaaces of 1 unit. Rotating element 0 by 4 5 counter-clockwise should produce a line lying in direction 1 but only 1/ 6 of the length of element 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 (</head><label>4</label><figDesc>a1 and (b) show thp scaled object of Figure Z(a) rotated 4 5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>and an intermediate chain code with 1 + 3 + 2 + 1 + 0 elements results. Figure 5 shows the lntermediate objects formed by the two methods. The existence of the lower right corner in Figure 5(b) results from the skewed registration of the center right corner of Figure l ( b ) to the lower right corner of Figure 2 ( a ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(a) and by 1 . 5 vertically in Figure 6(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 6(a) therefore represents the same object as Figure l ( b ) while Figure 6(b) represents the object midway between the states of Figure 2(a) and Figure 3(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7</head><label>7</label><figDesc>(a) illustrates incremental rotation of the object of Figure 2(a) by 4 5 counter-clockwise and should thus be compared with Figure 4(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Figure 7(b) shows the same object rotated by 26.5'as in Figure 4(c), a,"d Figure 7(c) shows it rotated by 33.5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Chain code object representation and animation offers a useful means of uniting the output of image processing activities (such as image sequence segmentation) with the input for computer graphics activities (such as visualization of changes over time)such symbiosis. Brice C R , Fennema C L ( 1 9 7 0 ) Scene analysis using regions, Art. I n t . 1 ( 3 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 1 :</head><label>1</label><figDesc>(a) Chain code element definition; (b) a simple chain coded object.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 2 :</head><label>2</label><figDesc>Quantized scaling of Figure l(b) by 2 horizontally using Table 1: (a) maintaining directional boundary coherence (b) avoiding directional boundary coherence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 3 :</head><label>3</label><figDesc>Quantized scaling of Figure I(b) by 2 horizontally and 3 vertically using (a) successive scaling applied to Figure 2(a) using Table 2(a); (b) precombined scaling applied to Figure I(b) using Table 2(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 4 :</head><label>4</label><figDesc>Quantized rotation of Figure W by 45 de,gees counter-clockwise using (a) individual element rotation using</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 5 :Figure 6 :Figun 7 :Figure 8 :</head><label>5678</label><figDesc>Intermediate stage during quantized elastic deformation of Figure l(b) into Figure 2(a) using (a) unregistered chain codes; (b) registered chain codes. Incremental scaling of Figure 2(a) by (a) 0.5 horizontally using horizontal indicator, altemating indicator sign; (b) 1.5 vertically using vertical indicator, altemating indicator sign. Incremental rotation of Figure 2(a) counter-clockwise with fixed indicator threshold of 0.5 by (a) 45 degrees using perimeter indicatoc b) 26.5 degrees using horizontal and vertical indicators; (c) 33.5 degrees using perimeter indicator. D +.4 + . 0 -.2 -.6 -. 0 +.4 + . O -.6 + . 0 +.4 Intermediate stage during incremental registered elastic deformation of Figure 7(a) into Figure 7(b) using horizontal and vemcal indicators and fixed indicator threshold of 0.5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>line at the new angle can be formed and a sixitable corresponding sequence is entered in the table. Table 5shows 2-element sequences</figDesc><table><row><cell cols="8">sequences of elements. I f each unrotated</cell></row><row><cell>sequence</cell><cell>is</cell><cell cols="2">small</cell><cell>it</cell><cell>can</cell><cell>be</cell><cell>well</cell></row><row><cell cols="2">approximated</cell><cell>by</cell><cell>a</cell><cell cols="2">straight</cell><cell cols="2">line;</cell><cell>a</cell></row><row><cell cols="8">corresponding approximate straight 1 rotated counter-clockwise by arctan -2</cell></row><row><cell cols="8">(i.e. 2 6 . 5 ' ) and Table 6 shows the first</cell></row><row><cell cols="8">quadrant of 3-element sequences rotated</cell></row><row><cell cols="3">counter-clockwise</cell><cell>by</cell><cell cols="2">arctan</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>4 5</cell><cell>( o r multiples of these) can be</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>achieved by using a table of appropriate</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>replacement</cell><cell>sequences</cell><cell>for</cell><cell>unrotated</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>n ) , an intermediate code of approximately 1 3</head><label></label><figDesc>Given the first scenario, it is a reasonable simplifying assumption that tho two chain codes correspond linearly to each other along the sequence.That is, the number of elements in one code per element in the other code is constant. If there are m edge elements in the first code and n in the second code (assume m &lt;</figDesc><table><row><cell></cell><cell></cell><cell cols="4">First, two separate chain</cell></row><row><cell cols="6">codes exist (e.g. for one object deforming</cell></row><row><cell cols="6">to another object) and we seek to generate</cell></row><row><cell cols="6">intermediate chain codes with no further</cell></row><row><cell cols="3">information about</cell><cell cols="3">the nature</cell><cell>of</cell><cell>the</cell></row><row><cell cols="2">deformation.</cell><cell cols="4">Second, particular boundary</cell></row><row><cell cols="6">points may be mutually registered between</cell></row><row><cell cols="4">the two chain codes</cell><cell></cell><cell>and we seek to</cell></row><row><cell cols="2">generate</cell><cell cols="3">intermediate</cell><cell>chain</cell><cell>codes</cell></row><row><cell cols="6">consistent with the location of these</cell></row><row><cell cols="6">points. m+ n -2m elements in total from each sequence</cell></row><row><cell>of</cell><cell cols="5">elements in the second code and 1</cell></row><row><cell cols="6">element in the first code. This selection</cell></row><row><cell>might</cell><cell cols="5">be made by averaging the element</cell></row><row><cell cols="2">directions,</cell><cell>by</cell><cell cols="3">choosing</cell><cell>the</cell><cell>most</cell></row><row><cell cols="4">frequently occurring</cell><cell cols="2">direction, or by</cell></row><row><cell cols="5">various other strategies.</cell></row></table><note>-min elements can be formed by selecting</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Scaling of single elements by 2 horizontally.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Scaling</figDesc><table><row><cell>of single elements by (a) 3 vertically;</cell></row><row><cell>(b) 2 horizontally and 3 vertically.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Rotation of single elements counter-clockwise by 45 degrees.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Rotation of some variable length sequences counter-clockwise by 45 degrees.</figDesc><table><row><cell cols="5">OLD SEQUENCE 0 1 2 3 4 5 6 7 000 11 222 33 444 55 666 77</cell></row><row><cell>NEW SEQUENCE 1 2 3 4 5 6 7 0 11</cell><cell>222 33</cell><cell>444 55</cell><cell>666 77</cell><cell>000</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5 :SEQUENCE 00 01 11 12 22 23 33 34 44 45 55 56 66 67 77 70 10 21 32 43 54 65 76 07 NEW SEQUENCE 01 11 12 22 23 33 34 44 45 55 56 66 67 77 70 00 10 21 32 43 5 4 65 76 07</head><label>5</label><figDesc>Rotation of 2-element sequences counter-clockwise by 26.5 degrees.</figDesc><table><row><cell>OLD</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 6 :</head><label>6</label><figDesc>Rotation of 3-element sequences in the first quadrant counter-clockwise by 18.5 degrees.</figDesc><table><row><cell cols="2">OLD SEQUENCE 000 001 011 111 112 122</cell></row><row><cell>010 110</cell><cell>121 221</cell></row><row><cell>100 101</cell><cell>211 212</cell></row><row><cell cols="2">NEW SEQUENCE 001 011 111 112 122 222</cell></row><row><cell>010 110</cell><cell>121 221</cell></row><row><cell>100 101</cell><cell>211 212</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 3 :</head><label>3</label><figDesc>(b) sequence rotation usingTable 4; (c) rotation by 26.5 degrees usingTable 5.</figDesc><table><row><cell>/ I / /</cell><cell></cell><cell></cell></row><row><cell>CHAIN CODE: 111065544</cell><cell>CHAIN CODE: 11065542</cell><cell>CHAIN CODE: 010055442</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">2 1 Ballard DH, Brown CM ( 1 9 8 2 ) Computer Vision. Prentice-Hall.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">0 ) When is a string like a string&apos;?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Allison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">N</forename><surname>Yee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Procs. Intl. Sym. of Art. Int. and Math</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
		</imprint>
	</monogr>
	<note>Fort Lauderdale 3 -5 January ( t o appear</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
