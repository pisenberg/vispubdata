<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Journey into the Fourth Dimension</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Ke</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computational Science</orgName>
								<orgName type="institution">University of Saskatchewan</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sask</forename><surname>Saskatoon</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Johns Hopkins University</orgName>
								<address>
									<postCode>21218</postCode>
									<settlement>Baltimore</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>S7n</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Johns Hopkins University</orgName>
								<address>
									<postCode>21218</postCode>
									<settlement>Baltimore</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Panduranga</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Johns Hopkins University</orgName>
								<address>
									<postCode>21218</postCode>
									<settlement>Baltimore</settlement>
									<region>MD</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Journey into the Fourth Dimension</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper shows that by a simple (one way) mapping from quaternions to complex numbers, the problem of generating a 4D Mandelbrot set by iteration of a quadratic function in quaternions can be reduced to iteration of the same function in the complex domain, and thus, the function values in 4D can be obtained by a simple table lookup. The computations are cut down by an order. Simple ways of displaying the fractal without shading and also of fast raytracing such a fractal using the table so generated are discussed. Further speed up in raytracing can be achieved by estimates of a distance of a point from the Mandelbrot set. Animation is a key factor in visualizing 4D objects. Three types of animation are attempted: (a) translation in 4D, (b) rotation in 4D and (c) flythrough in 3D.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Ever since their introduction by B. <ref type="bibr">Mandelbrot (1)</ref> , fractals have grown in popularity. Recently there has been a tremendous interest in fractals. A number of recent books have been devoted entirely to fractals <ref type="bibr">(2,</ref><ref type="bibr">3,</ref><ref type="bibr">4,</ref><ref type="bibr">5)</ref>. The fractals have wide applications as models of complex geometric shapes. There are several methods for generating fractals, both deterministic and random, such as iteration of algebraic functions, iterated function systems, graftals and the like. (4) is a good reference on the topic. Basically, most of these methods have been applied to obtain two-dimensional fractals in the complex plane. Some authors have extended some of the methods to generate three dimensional fractals <ref type="bibr">(6,</ref><ref type="bibr">4)</ref>: In this paper, we Fractals obtained by the iteration of algebraic transforpdations are easy to understand. Colisider a mapping:</p><p>f : e -e of the complex plane into itself. Starting with an initial point zo = z + iy, successive applications of the transformation yield a sequence of points in the complex plane: and so on. The magnitude (length of the radius vector) of the point 2, of the sequence thus obtained may diverge to infinity or remain bounded. In the latter case, we include the initial point as belonging to the fractal set that we are exploring, and in the former case, we exclude the point. This scheme is popularly known as the Boundary Scanning Method (4). It is important to recognize that we include or exclude a point based only on the magnitude of sequence of points generated.</p><p>A color illustration of a portion of the fractal set in the plane is generated as follows: The computer display is mapped on to a rectangular region of the complex plane. Thus each pixel is associated with a corresponding point in the complex plane and they can be interchanged for each other. The points in the set are given a color of zero or b l x k , and those not in the set are given a color which is a function of the iteration a t which the magnitude exceeds a predetermined large integer. For example, the famous Mandelbrot set is generated by the iteration of the function f(z) = 2 + c would like to explore the possibility of extending the first of the above methods to four dimensions. We do this in a natural straightforward manner.</p><p>where ZCJ is taken to be 0 and C is the complex number associated with the point to be colored. Plate 1 shows a picture of this set with the color function for the CH2913-2/90/0000/0219/$01 .OO -1990 IEEE 219 points not in the set being</p><formula xml:id="formula_0">color = ( i d 7) + 1</formula><p>where i is the iteration at which the magnitude exceeds two (it is known for the Mandelbrot set that once the magnitude of a point exceeds two, then it will diverge to infinity). The color 1 is red, 2 is green and so on.</p><p>The beauty of these fractals seems to stem from the algebraic properties of the vector space defined on the complex field. In particular, we have a basis for the space consisting of 1 = ( 1 , O ) and i = ( 0 , l ) such that i2 = -1 = (-1, 0). There are no such vector spaces possible with three basis vectors of the form 1 = ( l , O , 0), i = (0,1,0) and j = (O,O, 1) which would yield i2 = j 2 = -1. The reader is referred to a standard book on algebra (7) which narrates Sir Hamilton's efforts to find such a vector space in higher dimensions. Like him, we should go into four dimensions to find a field with similar properties. The quaternions fulfill our needs. The field of quaternions has a basis consisting of 1 =</p><p>O ) and IC = (0, 0, 0 , l ) . Of course i2 = j 2 = le2 = -1. The quaternion multiplication is known to be non commutative, but that should not bother us. Given this information, one could easily visualize a method for generating fractals in four dimensions. We can think of a hyperrectangular lattice of points in four dimensions. With each point of the lattice we associate a quaternion. The point is colored according to a similar scheme based on the iteration of an algebraic function defined on the quaternions. Voila, we could thus have fractals in four dimensions. To visualize a 4D fractal, we intersect it with a 4D hyperplane and display its three dimensional slice thus obtained. Changing the position of the hyperplane would give us different 3D images.</p><p>However, this conceptually simple approach for generation of 4D fractals is practically infeasible. Because of the added dimensions, the number of points to be iterated is large and hence the computational costs could be potentially intolerable. In section 2, we show that by a simple algebraic mapping from quaternions to complex numbers, the problem of generating a Mandelbrot set by iteration of a quadratic function in quaternions can be reduced to iteration of the same function in the complex domain. This forms our mathematical basis for fast generation of 4D Mandelbrot set. The remainder of the paper is organized aa follows: Section 3 concerns the issue of displaying a portion of the 4D Mandelbrot set. Rendering its three dimensional slices is the topic of Section 4. We discuss possible speed up of the raytracing procedure in Section 5. Section 6 discusses some issues of animation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">An Algebraic Transformat ion</head><p>In this section, we show that the iteration of a quaternion function that computes a four dimensional Mandebrot set can be reduced to the iteration of an equivalent complex function. This leads to a fast method for generating the 4D Mandelbrot set.</p><p>The theory of iteration of complex numbers haa been quit well developed. For example, one could show that for the iteration</p><formula xml:id="formula_1">f ( z ) = z2 + c</formula><p>where ZO = 0 and C is a complex number, which obtains the Mandelbrot set, one need not iterate until the magnitude reaches infinity. Rather one iterates only until the magnitude exceeds two. And there are various proofs on the connectivity of the set and other properties of the set. We may try to develop similar proofs for the iteration of quaternions starting from scratch. However, as we remarked before, since the important characteristic of the iteration is the magnitude of the complex number only, we can get by with the following observation. For practical purposes, we need not compute q at all. We need it just to make the proof of the theorem easier to work out. All we need is the mapping AM.</p><p>By the above theorem, whenever we need to iterate the quaternion function and check the magnitude of the result, we simply map quaternion into the corresponding complex number and carry out the iteration and check the magnitude in the complex domain. This immediately givee us direct proof that the Mandelbrot set in the four dimensional space is equivalent, in a sense, to that in the two dimensional complex plane. In particular, if someone were to generate the four dimensional Mandelbrot set, directly using quaternion iterations, the magnitudes should still be checked against the value of 2. An intuitive way to think of the 4D Mandelbrot set is by rotating the 2D Mandelbrot set along the real axis in 4D space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Simple Projection Scheme</head><p>We as humans are adapted to viewing three dimensional objects. Hence to display a four dimensional object on a two dimensional display device, we have to project the object onto a three dimensional space and then project the resulting three dimensional projection onto a two dimensional display plane. Various projection techniques are possible, such as perspective, orthogonal, auxonometric etc. Furthermore, we</p><formula xml:id="formula_2">-- --</formula><p>to a three dimensional space and then use isometric projection to project onto the two dimensional display. Orthogonal projection is easy to compute since to project a point all we need to do is to simply drop one of the coordinates. For the three to two dimensional projection we chose isometric projection because using orthogonal projection again would lose information about one more coordinate.</p><p>Theorem 2.1 straight away gives us a technique for cutting down the number of computations. For multiplying two quaternions and checking the length, we need about 14 multiplications and 9 additions per iteration. On the other hand to map the quaternions to complex numbers and carrying out the multiplication and magnitude checking in the latter domain, we need 12 multiplications, 7 additions and 1 square root operation (to carry out the map) for the first iteration and only 6 multiplications and 3 additions for the subsequent iterations. This observation alone gives us a speed up by a factor of more than 2 (neglecting savings in additions) when the number of iterations is large.</p><p>We can achieve further speed up. For the hyperrectangle in which we set out to explore the Mandelbrot set, we can pre-compute the range of the "real" part and of the "imaginary" part that we are likely to encounter. Then we can create the portion of the two-dimensional Mandelbrot set in this range. The resolution of this two-dimensional set could be about twice the resolution of one of the sides of the 4-D hypercube. Once this is created, for each point in 4D, we can compute its iteration count simply by a table look up. If the resolution of the 4-D hypercube lattice is n, there are O(n4) points in the 4-D lattice and O(n3) points in the 3-D projection. We need to find the iteration count for only the points in the 3-D projection since these are the points we are potentially going to see in a display. Now, since we are generating a map for only about O ( n 2 ) points, we can cut down the iteration time from O(n3) to O ( n 2 ) . This is a significant reduction compared to the constant time reduction obtained by the direct application of the theorem as in the previous paragraph.</p><p>For comparison, the picture of Plate 2 was generated while the second author was a graduate student at Princeton. It took over three days on a dedicated graphics engine (Ikonas) executing about five million microcoded instructions per second. At that time the author could not think of running the program on the general purpose machine for the fear that it may hog the CPU and evoke severe complaints. The maximum iteration for each point was limited to 50. With the present technique, a picture of nearly the same resolution and the maximum iteration count set at 256, can be obtained in less than 30 minutes of clock time on a general purpose computer. The picture of Plate 3 was obtained this way on a VAX 8650.</p><p>Further savings are possible with clever hidden surface techniques. We used a variation of the floating horizon technique. The pixels were generated plane by plane proceeding from a plane closer to the observer to a plane farther away. Before even mapping a point, we first see if it has already been colored by a point nearer to the observer. If so, the point is skipped without further computations.</p><p>This technique does give us considerable speed up. It can still be speeded up further by keeping track of segments which are hidden instead of points. However, the complexity of the whole operation is still O(n3) since each point has a potential for being touched once. This is true if the hyper-rectangle being explored is very close to the border of the set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Raytracing the 4D Mandelbrot Set</head><p>To raytrace the 4D Mandelbrot set, we intersect the set with a 4D hyperplane. The intersection obtained is a 3D slice of the 4D Mandelbrot set, a bounded portion of which can then be visualized. With different positions and orientations of the hyperplane, we obtain different intersections, and therefore different 3D images. Such a 3D image is then projected onto the display by raytracing. Of course some information of the 4D Mandelbrot set is lost as we go from 4D to 3D, and 3D to 2D. To recover the lost information from 4D to 3D, we can continuously change the position and orientation of the hyperplane, by either a pure translation or a pure rotation or a combination of both, and obtain different 3D images reflecting all aspects of the 4D Mandelbrot set. To recover the lost information from 3D to 2D, we can change the position of the camera around the image (even move inside) and have a complete view of the 3D image. Both these suggest that animation is a key factor for visualizing the 4D Mandelbrot set (in fact, for any 4D object). We will discuss in detail an efficient generation method for our animation in Section 6. Given the position and orientation of a hyperplane, we have a geometric transformation G M that maps a point in 3D into a quaternion. Then the corresponding 3D image can be generated as follows. For each point in the three dimensional space, we transform it into the corresponding quaternion by the geometric transformation G M defined by the hyperplane, then apply the algebraic transformation AM to transform the quaternion into the corresponding complex number, then iterate the complex function and check the magnitude against 2. If the hyperplane is perpendicular to the real axis at <ref type="figure">ru, then a point (a, b, c)</ref> in 3D is simply transformed to the quaternion <ref type="figure">( T O , a, b, c )</ref> . For the general position and orientation of the hyperplane, the transformation is more complex and not easy to compute. The method we adopted is to define a geometric transformation T that maps the current 4D quaternion system into a new system, such that within the new system, the hyperplane is perpendicular to the real axis (of the new system) at ru. Then given any point (a, b, c) in 3D, its corresponding point in the new system is <ref type="figure">simply ( r g , a, b, c)</ref>. Then the inverse of T maps <ref type="figure">(rg, a, b, c)</ref> to a point in the original quaternion system, which is taken to be the corresponding quaternion of (a, b, c).</p><p>If the resolution of the 3D image is n along each axis, then the above described method requires that we iterate the complex function f ( 2 ) = 2 + c O(n3) times, as we have a 3D lattice with a total of O(n3) points. And when n is large, which is usually the case, we find this generation method is slow (although faster than iterating quaternion function directly). To speed up the generation, an observation is that in many cases, many points in 3D map to the same complex number, and we iterate on the same complex number again and again. Certainly this is not desirable in terms of time efficiency. This motivates the following improved method. Since the 3D image is bounded by a certain volume (in our case, a box whose sides are parallel to three axes of the coordinate system), we can compute the range of the complex numbers that are mapped by all points of the image. Then iterate the complex function over all, and only, these complex numbers. The results are then arranged in a table. After this preprocessing, given any point of the image, we find its corresponding complex number and simply look up the table. The total number of points we have to iterate is now bounded <ref type="figure">by O ( n 2 )</ref> , a significant improvement over the previous method.</p><p>When the volume that bounds the 3D image is an arbitrary convex polytope (this case has to be considered even when the volume itself is a box, since when we have a closeup view of cube, its portion that is within the visibility of camera can be a non-regular convex polytope), it is more difficult to compute the corresponding range of complex numbers. Let P be such a convex polytope and P' be the polytope in the new coordinate system after the geometric transformation. <ref type="figure">Since a point ( u , b , c , d</ref> ) of P' maps to the complex number <ref type="figure">(U, d/az + c2 + d 2 )</ref> , the range for the real part of the complex number is simply bounded by the minimum and maximum x-coordinate of all points in P'. And clearly these can be achieved by two vertices of P'. Thus we simply look at all vertices of P' and compute their minimum and maximum xcoordinates. Computing the range of the imaginary parts is less obvious. However, it can be shown that the maximum (the upper bound of the range) can always be achieved by a vertex of p'. Thus again we can look at all vertices of P' and find the one such that the sum of the squares of its other 3 coordinates is the maximum. The difficulty occurs when we compute the minimum for the range of the imaginary parts (the lower bound), as it can be achieved by a vertex, or a point in the interior of an edge, or even a point in the interior of a face. In other words, any points on the surface of P' are possible candidates in this case. If we also compute the adjacency relation between vertices, edges and faces of P', we can certainly find this maximum, but the overhead computation is too much. Thus we approximate the minimum as follows. First we bound P' by a box whose sides are parallel to axes. This box can be easily computed by looking at all vertices of P' to find their minimum and maximum coordinates. Then compute the radius of the cylinder that is along x-axis and supports the box. And we take this radius to be the minimum of the imaginary parts.</p><p>Once the table has been computed, we can start the raytracing procedure. Two essential issues here are the computation of the intersection point between a ray and the 3D image, and the computation of the normal of the surface at a given intersection point. The intersection point is computed based on the following procedure, which takes a ray r as an argument.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROCEDURE WALK(r)</head><p>1. p +-the origin of r , which is the position of the camera if r is a primary ray, or an intersection point on the image otherwise; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>END of WALK(r).</head><p>The main issue in this procedure is its step 4: computing the advancing distance. Let us consider first how the complex number changes in 2D as we move along the ray r in 3D, in other words, what is the trace of the corresponding complex numbers in the complex domain. Recall the transformation of a point p in 3D to 2D consists of three steps: first p is transformed to a point p' in 4D (the new coordinate system) by adding the position of the hyperplane as the first coordinate, then p' is transformed to p' ' in 4D (the original coordinate system) by applying the reversed geometric transformation, finally p" is transformed into the complex number C by the algebraic transformation. Since the the first two transformations maps straight lines to straight lines, we only need to consider the last transformation. So, let a straight line in 4D have the following equation:</p><formula xml:id="formula_3">w = WO + Wlt t = 2 0 + a1t Y = Yo + Ylt 2 = 20 + 2 l t</formula><p>where <ref type="figure">( W O , EO, yo, 2 0 )</ref> is the <ref type="figure" target="#fig_0">origin, (201, 21, yl, 21)</ref> is the direction and t is the non-negative parameter.</p><p>Applying our algebraic transformation, we obtain the parametric equation for the corresponding complex numbers: The above equation gives a quadratic curve that is very much similar to a parabola. See <ref type="figure" target="#fig_0">Figure 1</ref>. Advancing a point along a ray in 4D is equivalent to increasing the parameter t , which correspondingly changes the complex number in the complex domain. ing the idea of rasterization algorithm, we can choose to which complex number we move next. Consider several cases shown in <ref type="figure">Figure 2</ref>. In the first case, the curve is more closer to C 1 than to other complex numbers, thus C 1 is chosen as our next position. Similarly Cz and C, are chosen in the other two cases.</p><formula xml:id="formula_4">x = Y = -- -- --</formula><p>Once the next complex number is known, we reverse the sequence of transformations described above to compute the corresponding point in 4D. Therefore the next point is obtained without actually knowing the advancing distance d .</p><p>Once the intersection point between a ray and the image is found, we next need to compute the normal of the surface at that intersection point. If the intersection point is on the bounding box, then the normal is taken to be perpendicular to the face of the box that contains the point. Otherwise, we find neighbors of the intersection point, and approximate the normal by the cross product of the vectors from the intersection point to its neighbors. Currently we have tried two methods to compute the neighbors.</p><p>The first method is again based on the precomputed table. Let C be the corresponding complex number of the intersection point. Since the intersection point is on the surface of the image, it must satisfy the condition that its 8 neighbors in the table correspond to both points that are outside image, inside image and on the surface of the image. We therefore simply find those neighbors of C that satisfy the stated condition, which guarantees that these neighbors of C also correspond to points on the surface of the image, and they are nearby neighbors of the intersection point C.</p><p>The second method to compute the neighbor is based on the order by which the rays are generated. We scan the viewport from left to right, from top to bottom. Let (a,y) be the current position on the viewport and r be the ray from the camera and through (z,y), where z and y denote the horizontal and vertical distances of the position from the lower left corner of the viewport. Suppose we have obtained the intersection point p between r and the image. By the order the viewport is scanned, we have already computed the intersection points of the rays through the positions (z -1,y) and ( z , y + 1) respectively.</p><p>We thus take these two intersection points to be the neighbors of p. See <ref type="figure">Figure 3</ref>. This is not true, however, when p is right on the edge of the image, in which case the other two intersection points may fall on other surfaces and thus are not true neighbors of p. Nevertheless, this is a very fast method for computing the normals and the pictures obtained turn out to be equally good as the previous method.</p><p>Some raytraced 3D images are shown in Plates 4, 5 and 6, The orientation of the hyperplane is taken to be parallel to real axis in Plate 4, and orientation is parallel to one of imaginary axes in Plate 5. The orientation is arbitrary in Plate 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Variations of the Generation Method</head><p>In this section, we discuss how to generate the closeup image using the previous generation method. We also explore possible further speedup by using the distance approximations. This allows us to "jump" along each ray to the next point instead of "walking" by each entry of the table. We compare the two methods at the end of the section and discover some surprising results. First we discuss the close-up display of the image. The purpose of the close-up display is to reveal more details of the image. It is achieved by moving the camera closer and show, with the same resolution, only a portion of the image instead of the entire image. In our generation method, the resolution of the image depends on two factors, the resolution of the display (determined by the size of the viewport) and the resolution of 2D Mandelbrot set (determined by the size of the table). Thus bringing the camera closer is not enough for us, we also have to increase the size of the table. The size of the table is determined by the size of the box. This is not true, however, in close-up view since only a portion of the box is in the visibility portion of the camera, the size of the table should be determined only by the visible portion of the box, in other words, the intersection of the box with the viewing pyramid of the camera. See <ref type="figure">Figure  4</ref>. The edges of the cone are four rays from the camera through the four corners of the viewport. As we discussed in Section 4, we do not need to compute a complete description of the intersection, but rather only its vertices. Clearly, there are only three type of vertices: the original vertices of the box, the intersection points of the box with rays, and the intersection points of the edges of the box with the cone. Once these vertices are known, we can compute the range of the table, and hence its size, as described in Section 4.</p><p>This method, however, is not perfect. Sometimes a bad table size can be derived. To see how this can happen, consider our box to be long and thin. And we can arrange the camera such that the entire box is inside the cone. See <ref type="figure">Figure 5</ref>. Thus the size of the table is determined by the box. Since the box is long at one direction and short at other directions, We can have very poor resolution at the front face and unnecessary high resolution (unnecessary in the sense that it exceeds the resolution of the display) at the other faces. The ideal situation, of course, is that the resolution of the 2D Mandelbrot set exactly matches the resolution of the display everywhere. However, because of the non-linearity of our algebraic transformation, this requires that the table has non-constant density over the complex domain. Sometimes even this is not sufficient. At this moment, we see no easy solution to this problem. Nevertheless, the problem can be avoided by carefully choosing the position of the camera and the shape of the box.</p><p>Some close-up views of the images in Plates 4, 5 and 6 are shown in Plates 7, 8 and 9. Since the box is is actually a cube in these plates, we do not observe the problem described in the previous paragraph.</p><p>As we increase the size of the table, we also increase the density of the table over the complex plane. Therefore it takes more steps to intersect a ray with the image, as the advance distance is totally determined by the entries of the table. One solution to this is to use the distance approximation. Suppose we are advancing along a ray and are currently at the position c, a lower bound for the distance from c to the surface of the Mandelbrot set can be derived by using the equations given in (4). Let r be this bound. To find the next position to advance, we can intersect the quadratic curve of this ray in 2D complex plane with a circle centered at c with radius r . However, there seems to be no easy solution for computing the intersections of these two quadratic curves. To cut down the computation overhead, we approximate the advancing distance along the ray by r . Obviously, the next point obtained by this approximation is guaranteed to be within the circle, as the distance between c and the intersection point of the two curves is no less than r . See <ref type="figure">Figure 6</ref>. With the distance approximation, we can even omit the table computation, and simply iterate on complex numbers as we advance along rays. In this way, the resolution of the image purely depends on the resolution of the display. And therefore we can obtain higher quality images in exchange for time efficiency. Plate 10 shows an image generated in this way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Animation Issues</head><p>In this section, we consider the issue of animation for the 3D image we generated in the previous section. The purpose of this, as mentioned before, is to pick up the lost information as we project the original 4D image down to 2D display screen. We first generate sequences of frames by conventional method, and discuss various possible solutions to improve the time complexity. Then we conclude the section with some remarks.</p><p>The first animation we considered is to change the position of the hyperplane continuously, either by a pure translation or a rotation. We think the latter is more interesting. The frames in Plate 11 are generated by changing the orientation of the hyperplane continuously while keeping the distance from the origin to the hyperplane to be the same. The next type of animation is to change the position of the camera around the 3d image. This is the classical 3D animation technique. Pictures of this animation are not included in the paper except for the close-up pictures mentioned earlier. We are currently attempting a video-tape recording of all the above variations of animation.</p><p>Since changes between two consecutive frames are small, most pixels of the two frames have the same color. Therefore it is inefficient to recompute the second frame even with the availability of the first. To speed up the frame generation, the idea is to compute the second frame by using (more or less) what we know about the first. A high level description is as follows. Let the camera be at the first position p1 with towards vector 211. Its viewport is perpendicular to 211. See <ref type="figure">Figure 7</ref>. Suppose we have computed the intersections of all rays to the viewport from the camera at this position p1. Now let the camera be slightly moved to position p z , and suppose we want to compute the intersection of a particular ray r2 from p a . Clearly, most rays from pz will intersect the first viewport (since p1 and pa differ only slightly). So, let rl intersect the viewport at point p . Correspondingly, there is a ray r2 from pa that passes through the viewport approximately at p. Let ri be another ray from pl and parallel to r2. It should be clear that the intersection of r2 is between the intersections of r1 and r i . Thus we can either approximate the intersection of r2 by a particular ray from p1 between r1 and p i , or narrow down our search range along r2. In both cases, we expect the time needed to find the intersection for a ray from pz can be significantly reduced.</p><p>The same idea can be applied to the situation when the position of the camera is fixed but the position of the hyperplane is changing. Let r be a particular ray with intersection point p1. Then let the hyperplane change slightly. Let pz be the new intersection point, which is what we want to compute. The idea is to find an approximation for the distance between p1 and pa, 80 that our search range along r can be shortened. By the same way we compute the normal of the 3D image at an intersection point, we can compute the normal of the 3D Mandelbrot set at point p l . Then the tangent plane of the surface at pl can be obtained. It is clear that the slope of the tangent plane and the difference between two positions of the hyperplanes can give us a good approximation for the distance between p1 and pa. As the difference between two positions of the hyperplane is small, as long as the slope of the tangent plane is not huge, the distance between p l and pa can be expected to be small. Therefore for most cases, this will improve the naive generation method.</p><p>The techniques of the previous two paragraphs are yet in the beginning stage and form the basis for our future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>We have shown how a 4D Mandelbrot set can be generated and displayed. With our technique, what once took several days of a dedicated machine to produce now takes only a few minutes of CPU time on a general purpose computer. We have also shown the possibility of raytracing the fractal. The techniques developed generalize to the class of fractals obtained iterations which are invariant under our algebraic transformation. We hope to extend our methods to the generation of 4D Julia sets and hope to improve upon the timings of earlier methods (9). The implementation of the fast animation described in the previous section is currently under investigation and the results will be compared with the original ones, both in image quality and time complexity.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 2. 1 :</head><label>1</label><figDesc>The iteration of the quaternion function f(w) = w2 + Q with WO = 0 is equivalent to the iteration of a complex function f(z) = z2 + C with z,, = 0 as far as only magnitudes ofnumbers involved are concerned. Here w and Q are quaternions whereas z and C are complex numbers. Proof: Let Q = (a, b, c, d ) be a quaternion. Given a quaternion Q , we can find a quaternion q of unit length with the following property (8) q-lQq = C where C is a complex number, i.e., C = (e, f) = (e, f, 0,O). Letwhere A M is an algebraic mapping from the quaternions to complex numbers. Obviously the magnitude of C is the same as that of Q , since the magnitude of the quaternion q (and therefore that of q -' ) is unity. Also, we can consider the quaternion to be made of two components, a scalar component (a, 0, 0,O) and a vector component(0, b, c , d). By simple algebra one can see that the mapping AM leaves the scalar part alone and hence we writeA M ( Q ) =AM((% b, C , d )) = C = (e, f) = ( 0 1 are at liberty to choose different projection methods for the two projections involved. d L o r the pictures in this section, we use orthographic b2 + C2 &amp;#f&amp;tion to project the four dimensional fractals on Given this observation, a simple induction suffices to prove the theorem. The quaternion IN, at any iteration is of the form w = qzq-1 For the first iteration, when 'ut1 = Q, and z1 = C w = w1 and z = z1 have the same magnitude. For the next iteration, we have The last equality is holds since z2 = C2 + C. The rest of the details are similar and left to the reader.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>a</head><label></label><figDesc>= zf + y1 + 21 b = 2 (~z i + yoyi + 2021) c = xi + y; + 2 ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>2. more -TRUE 3. while more is TRUE do 4.</head><label></label><figDesc>Compute the distance d along r between p and</figDesc><table><row><cell>10.</cell></row><row><cell>the next position;</cell></row><row><cell>5. Move p along r by distance d;</cell></row><row><cell>6. compute the corresponding complex number of</cell></row><row><cell>p using the defined geometric and algebraic transfor-</cell></row><row><cell>mations and look up the precomputed table; 7. if the entry of the table contains value of zero 8. more -TRUE; 9. else</cell></row></table><note>more -FALSE; 11. end of while loop;</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The distance d is therefore computed by using the precomputed table. Suppose p maps to a complex number C and WLOG, let the quadratic curve be oriented towards lower right corner of the table. Us-</figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Fractal Geometry of Nature</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Mandelbrot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982" />
			<publisher>W. H. Freeman Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Chaotic Dynamics and Fractals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Machael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">G</forename><surname>Barnsley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Demko</surname></persName>
		</author>
		<imprint>
			<publisher>Academic Press, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Feder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fractals</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Barnsley et all &quot;The Science of Fractal Images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Barnsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fractals Everywhere</title>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Academic Press, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generation and Display of Geometric Fractals in 3-D</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><surname>Norton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="61" to="67" />
			<date type="published" when="1982-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Survey of Modern Algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Garrett</forename><surname>Birkhoff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saunders</forename><surname>Mclane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Macmillan Company</title>
		<imprint>
			<date type="published" when="1961" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A Manual of Quaternions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">Jasper</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joly</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1905" />
			<publisher>Macmillan and Co</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Ray tracing deterministic 3-D fractals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Hart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Louis</forename><forename type="middle">H</forename><surname>Sandin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kauffman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="296" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
