<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Applying Space Subdivision Techniques to Volume Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Sciences</orgName>
								<orgName type="institution">The University of Texas at Austin Austin</orgName>
								<address>
									<postCode>Tx-78712</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">S</forename><surname>Fussell</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Sciences</orgName>
								<orgName type="institution">The University of Texas at Austin Austin</orgName>
								<address>
									<postCode>Tx-78712</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">tCenter for High Performance Computing</orgName>
								<orgName type="institution">The University of Texas at Austin</orgName>
								<address>
									<addrLine>10100 Burnet Road</addrLine>
									<postCode>Tx-78758</postCode>
									<settlement>Austin</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Applying Space Subdivision Techniques to Volume Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present a new ray-tracing algorithm for volume rendering which is designed to work efficiently when the data of interest is distributed sparsely through the volume. A simple preprocessing step identifies the voxels representing features of interest. Frequently this set of voxels, arbitrarily distributed in three dimensional space, is a small fraction of the original voxel grid. A mediancut space partitioning scheme, combined with bounding volumes to prune void spaces in the resulting search structure, is used to store the voxels of interest in a kd tree. The tree is then efficiently ray-traced to render the voxel data. The k-d tree is view independent and can be used for animation sequences involving changes in positions of the viewer or positions of lights. We have applied this search structure to render voxel data from MRI, CAT Scan and electron density distributions.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An increasingly important application of computer graphics technology is in providing visualization tools to help scientists in a number of fields understand massive amounts of data. Some of these fields include medical imaging, molecular modeling, computational fluid dynamics, seismology, weather models and oceanography. In most of these applications, the data generated are usually too large to interpret directly in their raw form. Also, the data models usually contain a large number of features which are difficult to study all at once. A visual representation of these features, either individually or in some reasonable combination, is desirable for a better understanding of the underlying phenomena.</p><p>Many of these data-sets are scalar or vector fields of functions sampled in three spatial dimensions. For example, medical imaging data consists of scalar density values at each vertex of a three dimensional grid. These 'voxel' data are either input directly to a rendering program, in which case the visualization procedure is termed 'volume rendering', or converted to an intermediate representation, for example a surface model, before rendering.</p><p>One advantage of creating a surface model from a volumetric representation is that it is often a compact encoding of the characteristic that is being visualized. A surface model, built of polygonal primitives, for instance, can be rendered efficiently with special purpose graphics hardware. The model needs to be created only once and can be viewed from any direction. If the number of surface primitives is not too large, rendering can often be performed in real time, a very useful feature in scientific visualization. A popular method for creating surface models from voxel data is the Marching Cubes method <ref type="bibr" target="#b19">[21]</ref>.</p><p>CH2913-2/90/0000/0150/$01 .OO -1990 IEEE Most often, creating a surface model involves making a binary classification decision of whether a surface passes through a voxel or not. This can lead to aliasing problems. Also, it may not make sense to create surfaces for certain kinds of volume data. In these cases, alternate solutions involving the direct rendering of volumetric data are preferred. Direct volume rendering techniques are generally based either on a ray-casting approach Ray-casting techniques sample points along the path of each ray (as often as needed) that is cast into the volume. A weighted sum of the contributions of all these points is projected onto the view plane. The images obtained using this method typically have fewer aliasing artifacts than surface modeling methods because no binary classifications need to be made,although the point sampling involved can also be a source of aliasing. Also the grid is sampled at a greater level of detail, thus providing a more accurate picture of the volume data. Similar advantages can be obtained with projection and compositing methods.</p><p>Unfortunately, direct volume rendering is generally frequently more time consuming than surface rendering. Such methods, in general, do not take advantage of standard graphics hardware. Though the images produced are of higher quality than those generated from surface models, each image is more expensive to compute. It can be quite expensive to generate animation sequences, which are often a key to understanding scientific phenomena.</p><p>Surface modeling approaches to visualizing volumetric data take advantage of the fact that very often the features of interest to a scientist are contained in only a small portion of the original voxel data. By suitably identifying this subset of voxels and representing them as a set of surfaces, considerable savings in computation and space can sometimes be obtained. A surface may be an effective way to visualize data in cases in which a single type of real surface is being identified in the volume data. Frequently, however, either many different surfaces are of interest or the data actually contains no real surfaces. In these situations, direct volume rendering may provide a more useful way for investigators to understand the information of interest in the data.</p><p>In this paper, we present a volume rendering algorithm which takes advantage of the lack of interesting information in a large fraction of voxel data in many applications without representing the interesting voxels as surfaces. Our goal is to achieve the benefits of the relatively fast rendering and compact representations of surface models while retaining the ability to effectively represent data which are poorly suited to surface modeling.</p><p>Our strategy is to first identify the voxels which do not contain interesting data and remove them, rather than attempting to identify a set of interesting voxels which can constitute a surface. After this initial step, we are left with clumps of interesting voxels distributed throughout the original volume.</p><p>We incorporate this data into a k-d tree, which we build using a median-cut space partitioning scheme [10] <ref type="bibr" target="#b17">[19]</ref> with bounding volumes in the interior nodes of the hierarchy. Interesting voxels are recursively partitioned by axisaligned planes along their medians, resulting in a balanced binary tree. Bounding volumes are computed at nodes of the hierarchy to help in reducing void space created by the partitioning. Ray tracing method is used to render the data contained in the k-d tree.  <ref type="bibr" target="#b13">[14]</ref> have used octrees for rendering volume models. Our own studies of different characteristics of ray tracing hierarchies <ref type="bibr" target="#b18">[20]</ref> have shown that for surface models, the kd tree is a more adaptive and flexible data structure, principally because it combines the advantages of pure space partitioning structures such as the octree and of bounding volume hierarchies.</p><p>An important advantage of the kd tree is its view independence. Animation sequences involving changes in viewer locations or positions of lights require no change in the search structure. Slicing the volume data to look at the internals of a feature also can use the same search structure with a minor modification in the preprocessing step. We have used this structure to efficiently render animation sequences of a human heart (from an MRI data-set) and scalar fields of electron density distributions.</p><p>The remainder of the paper is organized as follows. First, we survey some major existing surface rendering and ray-tracing techniques for volume data in order to identify techniques for identifying and processing interesting voxels which we will also make use of. We then describe some important search structures used to ray-trace surface models. Subsequently, we present a detailed description of our algorithm, and then examine implementation results on the data mentioned above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Visualizing Volumetric Data</head><p>Among the different methods of visualizing volumetric data, two techniques are commonly used in medical imaging and molecular modeling applications. The first is the marching cubes method, which outputs polygonal surfaces of a certain density threshold value. The second method is based on ray tracing and directly samples the voxel grid.</p><p>The marching cubes method builds triangle models of constant data value surfaces from 3D scalar fields. A threshold density value (or surface constant) is first selected. This value is compared with the density values at the eight corners of each voxel. If it falls within the density range of any of the edges of the voxel, then the surface intersects that edge. The intersection points, determined by linear interpolation from the edge densities define one or more planar surfaces. These surfaces are then triangulated. Before rendering, a unit normal is computed for each triangle vertex. For a constant data value surface, the gradient vector is normal to the surface. The gradient at each vertex ( i , j , k) of the grid is computed using central differences. Let this be vf(z7). The unit normal is given by Normals at the vertices of the triangles are calcu-lated by linear interpolation from the corner gradients. Once the normals for the vertices of all the triangles are computed, the triangles can be rendered on any standard graphics workstation.</p><p>In the ray tracing approach, rays are cast into the voxel grid, through an imaginary projection plane. Each of these rays is sampled at equal intervals along its path through the grid. This can exploit the use of incremental techniques [9][4]. At each sample location, the voxel density, opacity and local gradient is determined. The voxel density is usually obtained by linear interpolation from the corner density values. The opacity can be a made a function of the density, although this is not necessary. Theoretically, the opacity can be any meaningful function. For instance, if it were a step function peaking at a certain density value, then we end up with iso-surfaces, as in the marching cubes method. A method proposed by Levoy <ref type="bibr" target="#b14">[15]</ref> to compute opacity is as follows: What the above equation does is make the opacity maximum when the density value is the selected threshold. At nearby density values, the opacity falls off at a rate inversely proportional to the local gradient vector.</p><p>A unit normal is computed as in the marching cubes method. A lighting model is then applied at this sample location to compute a color. A running sum of the accumulated opacity is maintained and used to weight the color of each sample location. Processing terminates when the accumulated opacity reaches unity or there are no more voxels left to process. The sum of all the weighted sample colors is the final color for the ray.</p><p>The total intensity for each ray cast into the grid is given by </p><formula xml:id="formula_0">k -1 i-1 z = Z(6)a(6) n(1-a(.?))<label>(2)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Building the k-d Tree</head><p>As indicated in the introduction, our goal is to create a data structure which represents interesting volume data in a way that supports fast ray tracing. We do this in two steps.</p><p>In the first step, we design a culling function that identifies voxels that can be eliminated from any consideration since they do not contribute to the current view. This step depends on the opacity function used. We demonstrate a culling function to be used when equation 1 computes the opacity. The output of this step is a list of voxels representing the characteristic that will be visualized.</p><p>Next we build the IF-d tree using the median-cut scheme The partitioning is highly flexible in adapting the partitioning planes to the distribution of the voxels in the hierarchy. For early detection of rays that do not intersect any interesting voxels, bounding volumes are stored at nodes of the hierarchy to make the data structure even more compact.</p><p>The k-d tree will be used to efficiently access the voxels of interest during ray tracing. The remainder of this section is devoted to a detailed description of the building of the data structure. The next section describes its use in ray tracing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Identifying 'Relevant' Voxels</head><p>The inequalities at the right of equation 1 are the key to determining a culling function for identifying voxels of zero opacity. The culling function is given by</p><formula xml:id="formula_1">{ ( f m a r ( u O z i , j , k ) -k PI v f m a z ( v O 2 i , j , k ) l ) &lt; f v } OR { ( f m i n ( v o z i , j , k ) -7'1 v f m a r ( v o + i , j , k ) l ) &gt; f u } where f m i n ( v o z i , j , k ) = min. voxel density at ( i , j , k). f m o z ( v o z i , j , k ) = max. voxel density at (i, j, k ) . V f m a z ( V O l i , j , k ) = max. voxel gradient at ( i , j , k )</formula><p>If the above function is TRUE for a voxel at (i, j, k ) , it is discarded; otherwise, it is added to the list of relevant voxels.</p><p>Since linear interpolations are used for determining densities as well as gradients within each voxel, the range of densities within each voxel as well as the maximum density gradient of each voxel can be determined. This immediately lets us design a culling function which checks to see if any density in a voxel is within the range of density values that could possibly contribute to the final image. That is exactly what the inequalities in the above function test for. A voxel is irrelevant if its range of densities does not contain the surface threshold density and its density and gradients are such that the opacity function lies completely outside its range. The two parts to the function (on either side of the OR operator) consider the density ranges on either side of f u , the selected threshold. This process is repeated for each voxel in the grid and a list of 'relevant' voxels is recorded. All other voxels are not of interest until a different feature or characteristic needs to be studied. The output from the preprocessing step is a list of voxels representing the characteristic of interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Building the Median-cut Hierarchy</head><p>Having identified the voxels of interest, the next step is to build a hierarchy to store them. The process begins by determining the three dimensional extent of the voxels. This is easily computed from the knowledge of the locations of all the voxels. A binary search is conducted next to determine the plane that best balances the number of voxels on both sides of the partition. This is done in all three dimensions. The criterion or figure of merit (fom) for the plane choice is simply fom = llcntrcntl where lcnt and rcnt are the voxel counts on either side of the plane. Once the plane is determined, the voxels are partitioned into two subsets, on either side of the plane. These subsets of voxels are recursively partitioned in a similar fashion until each region contains exactly one voxel. An example is shown in <ref type="figure">Fig.  1</ref> with five levels of partitioning. The dotted lines are partitioning planes and the rectangles represent voxels.</p><p>Each time we partition a set of voxels, we need to determine if bounding volumes are required to   <ref type="figure" target="#fig_4">Fig. 2</ref>. In 2a, bounding volumes are required on both sides of the plane. In 2b, no bounding volumes are required as this results in no reduction in void space, whereas in 2c only the left side needs it. The reasoning behind using bounding volumes is that a lot of the rays will intersect the void areas without intersecting the surface areas, in which case they can be quickly eliminated from further consideration with a simple bounding volume intersection test.</p><p>Some important optimizations in this preprocessing step include the following:</p><p>When we are dealing with regular grids (common in medical imaging and molecular modeling applications), partitioning planes need be located only on voxel boundaries, which means the entire search can be performed using integer arithmetic.</p><p>Since the partitioning planes are axis-aligned and there are only a finite number of locations for each of them, voxels that fall in each of these locations can be summed up. These partial sums can be used to determine the best plane choice. Thus, when we need to determine a plane that best balances the voxels in a region, the partial sums are first computed parallel to the orientation of the plane. These sums can be used to determine the best plane as the binary search is conducted. In <ref type="figure" target="#fig_5">Fig. 3</ref>, vertical columns of voxels are added up when we are determining a plane orthogonal to the horizontal axis. In 3D, if we are searching along the X axis, voxel counts in YZ plane will be summed up at each possible location of the partitioning plane.</p><p>During the binary search, when we move the plane towards a location that tends to give a better balance of voxels, the side we are moving away from need not have its voxels examined any further. Thus the total number of voxels in this region just needs to be remembered and taken into consideration when the figure of merit is computed. This is explained with an example in <ref type="figure" target="#fig_5">Fig. 3</ref> represents a set of voxels, stored in its subtree. One advantage of such a structure is that its height is smaller than an unbalanced tree, making it less expensive to reach the leaf nodes where the voxels are stored. Secondly, our studies have shown that using bounding volumes in the internal nodes of the hierarchy is critical to its success. In this configuration, it is a very compact encoding of the original data for rendering purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Ray-tracing the k-d Tree</head><p>A ray with arbitrary origin and direction can be traced efficiently using the k-d tree. The partitioning planes and the bounding volumes in the hierarchy help determine a set of voxels ordered along the path of the ray. More important, only voxels close to the path of the ray are identified, thus ignoring the bulk of the voxels in the tree. This is done with the help of bounding volume and partitioning plane intersections described as follows.</p><p>Given a ray and the root of the tree, the ray is intersected with the bounding volume stored at the root node. If there is an intersection, then we need to determine if this is an internal node or a leaf node. If it is a leaf node, then the voxel at this node needs to be sampled and its contribution to the color of the ray is computed as described in section 2. On the other hand, if it is an internal node, we have two different cases:</p><p>1. The ray lies entirely on one side of the partitioning plane.</p><p>The ray crosses the partitioning plane.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>These two cases can be easily determined by intersecting the ray against the partitioning plane and comparing its parametric intersection value with those obtained from intersecting the region's bounding volume. For case 2, the direction of the ray helps define the order in which the two regions need to be processed. It must be pointed out that no coordinates need be computed during this process.</p><p>For case 1 we need to search the region containing the ray segment (the ray has been clipped to the bounding volume of this node). For case 2, we need to potentially examine both regions. However the region closer to the ray origin is processed first, since the accumulated opacity might reach unity while examining this region. This would make it unnecessary to examine the farther region. This process is recursively applied, until either the opacity accumulates to unity or there are no more regions (and hence, voxels) to examine. <ref type="figure" target="#fig_7">Figure 4</ref> illustrates this. Here r l ( t ) , r 2 ( t ) and r3(t) are three different rays. t l and t 2 are the parametric intersection points with the region, and t , the intersection with the partitioning plane z = c1. The top ray visits only one of the 2 regions, which is recognized by the fact that t l &lt; t and t 2 &lt; t . The actual region visited by the ray is determined by the 3: component of the  ray direction. For the top ray, direction along the z axis is positive, i.e. z increases along the path of the ray, thus identifying region 1. Otherwise, the region 2 will be visited. The middle and bottom rays visit both regions, indicated by t l &lt; t and t2 &gt; t .</p><p>The z component of the ray direction determines the traversal order. For the middle ray, the direction is positive, so the order is region 1 followed by 2, while it is 2 followed by 1 for the bottom ray because its z direction is negative. A similar strategy holds for identifying the traversal order when the partitioning dimension is y or z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation and Results</head><p>We have implemented our algorithm in C on an Ardent  vertically (by a plane) and the voxels in front of the slicing plane are removed so as to get a better view of the heart chambers. Plate 2 shows two views after slicing.</p><p>The The last example is a quantum mechanical calculation of one electron orbital of a four-iron, eightsulphur cluster found in many natural proteins. This particular data-set is a high potential iron protein (HIPIP). The data represents the scalar field of the wave-function at each point. The resolution of the data is 64x64~64. Scientists are interested in seeing 'nodal' surfaces, where the data value crosses zero. Plate 4 attempts to demonstrates this. <ref type="table" target="#tab_3">Table 1</ref> illustrates the reduction in voxel data after the preprocess. In all cases, less than 10% of the total voxels are relevant to the final image. This demonstrates the importance of culling irrelevant voxels and working with only voxels of interest. In the heart images, slicing cause8 further culling of the data. All timings are for a resolution of 640x480, with one ray cast per pixel. In this implementation, we have not taken advantage of either vectorization or parallelization to optimize performance.</p><p>We are presently adapting this technique to be useful for supercomputer users located remote from our center. Our strategy is to preprocess the data, whereby the voxels representing a given characteristic is identified. This set of voxels is then transmitted over the network to the researcher's workstation for rendering. In filtering the voxels of interest from the original three-dimensional grid, a large reduction in the number of voxels transmitted over the network will result a natural compression of the original d a t a set. Since building the k-d tree search structure usually takes a fraction of the rendering time, it can be performed remote from the supercomputer center, thus making it unnecessary to transmit the search structure over the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We have presented an algorithm which uses space partitioning techniques to support efficient volume rendering. A cull function prunes voxels from the original data that are irrelevant to the characteristic being studied. A k-d tree based on mediancut space partitioning with bounding volumes at selected nodes of the hierarchy is used as a data structure for storing the relevant voxels so that they may be accessed efficiently during rendering. This data structure has important advantages for rendering volumetric data:</p><p>1. It provides a compact representation of voxels. The partitioning planes in the hierarchy help in determining a traversal order that identifies only voxels close to the path of each ray. The bounding volumes used in the internal nodes of the hierarchy help in identifying rays that do not intersect any relevant voxel by simple bounding volume intersection tests. Since the tree can be traversed along the path of a ray, the ray trace can be terminated once the accumulated opacity reaches unity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>3. The search structure is view independent. With the help of the partitioning planes, a traversal order can be determined for any ray with arbitrary origin and direction. Changes in viewing or lighting parameters require no change in the search structure.</p><p>The choice and location of the partitioning planes is flexible. The plane that best balances the voxel counts on either side of the partition is chosen. The plane can be aligned with any of the three dimensions.</p><p>Since partitioning planes need to be located only on voxel boundaries, the entire plane search can be performed using integer arithmetic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">.</head><p>Surface modeling approaches to visualizing volumetric data work best when few surfaces are involved. Existing direct volume rendering approaches exploit the regular nature of three-dimensional grids through the use of incremental techniques for volume traversal. These techniques are most efficient when the voxels of interest are distributed sufficiently densely through the volume. In the data that we have worked with, this has not been the case. Visualizing multiple features increases the number of voxels participating in the view, but there is a point beyond which visualizing multiple characteristics (thereby increasing the number of relevant voxels) only makes it increasingly difficult to interpret the data. Our approach is targeted at producing images of intermediate complexity, i.e. those which may contain more than one type of surface but not so much relevant data that the majority of the volume is involved. The technique should thus be complementary to existing direct volume rendering approaches which work best on very dense data and surface modeling techniques which work best on data with few surfaces of interest. Jolla, California. The electron orbital data was provided by Louis Noodleman and David Case, Scripps Clinic, La Jolla, California. Our thanks to the CHPC Visualization Laboratory staff for their help and comments. Our thanks to Don Speray for his useful insights on volume visualization. Lastly, our thanks to Dr. James Almond and Dr. Matthew Witten for making time available to perform this research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>or on the projection and compositing of preprocessed voxels onto the image plane [5][6].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>where z ; = i th sample location f, = surface threshold constant. a, = opacity of voxels having density of f v . f(z7) = density at sample z : . ~f ( z 7 ) = local gradient vector. a(.;.) = opacity at sample 4. r = voxel thickness of the transition region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>= i th sample. Z ( 6 ) = Intensity at sample 6 . a ( 6 ) = opacity at sample 2;.IC = total number of samples along the ray.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 1: A median-cut subdivision</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>CFigure 2</head><label>2</label><figDesc>Figure 2: Using Bounding Volumes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Optimizing the preprocess cull void space. A 2D example is shown in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>.</head><label></label><figDesc>Here the plane I = c1 results in a partition with more voxels to its left (Icn* &gt; T , ,~) . The next plane choice is at z = c i , midway between c1 and the left bound. To determine the number of voxels on either side of 2 = ci , its enough to examine the voxels between the left bound and c l . The number of voxels to the right of c1 is rcnt and just needs to be remembered. A similar argument holds if lent &lt; rcnf. The median-cut hierarchy built is a binary tree, also called a k-d tree [2][3]. Each node in this tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Ray Traversal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>next example is an electron density map of the active site of superoxide dismutase (SOD) enzyme as determined by x-ray crystallography at 1.8 angstrom resolution. The data-set consists of 116 slices, each of size 97x97. Plate 3 shows one frame of an animation sequence when centered around a threshold of 80. At this level, teardrop shapes and clumps of atomic density are seen. At a level of 100, we start seeing individual atoms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>the ray tracing of surface mod- els [11][13][18][12][1][8]. Levoy [16] and Meagher</head><label></label><figDesc></figDesc><table><row><cell>The motivation for applying space subdivision</cell></row><row><cell>techniques to volumetric rendering comes their suc-</cell></row><row><cell>cess in accelerating</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Experimental Results</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head><p>The heart data was provided by Dr. Raleigh F. Johnson, Jr. and Dr. Donald G. Brunder, University of Texas Medical Branch, Galveston. The SOD data ww due to Duncan McRee, Scripps Clinic, La</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Arvo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kirk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">September</title>
		<meeting><address><addrLine>Jon Louis Bentley</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975" />
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Data structures for range searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><forename type="middle">Louis</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">1979</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Analysis of an algorithm for fast ray tracing using uniform space subdivision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoff</forename><surname>Cleary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wyvill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Visual Computer</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="65" to="83" />
			<date type="published" when="1988-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Vbuffer:visible volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loren</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Three dimensional display of medical image volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Shlusselberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NCGA 86 Con) Proc. NCGA, Fairfaz, Virginia</title>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">D</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">D</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Near real-time shaded display of rigid objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Grant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="65" to="72" />
			<date type="published" when="1983-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Arts: Accelerated ray-tracing system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akira</forename><surname>Fujimoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takayuki</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kansei</forename><surname>Iwata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="269" to="278" />
			<date type="published" when="1986-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Fast ray tracing using k-d trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Fussell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
		</author>
		<idno>TR-88-07</idno>
		<imprint>
			<date type="published" when="1988-03" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Sciences, The University of Texas at Austin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Space subdivision for fast ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">S</forename><surname>Glassner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="15" to="22" />
			<date type="published" when="1984-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Automatic creation of object hierarchies for ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Goldsmith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Salmon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="14" to="20" />
			<date type="published" when="1987-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The uses of spatial coherence in ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kaplan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGGRAPH Course Notes</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="1985-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Geometric modeling using octree encoding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Meagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Image Processing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="129" to="147" />
			<date type="published" when="1982-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Design for a real-time high-quality volume rendering workstation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Chapel Hill Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1989-03" />
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="85" to="92" />
		</imprint>
		<respStmt>
			<orgName>Computer Science Dept. of the University of North Carolina</orgName>
		</respStmt>
	</monogr>
	<note>A hybrid ray tracer for rendering polygon and volume data</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A 3-dimensional representation for fast rendering of complex scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Turner</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Whitted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="110" to="116" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Fast ray tracing using k-d trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-12" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Sciences, The University of Texas at Austin</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Factors affecting performance of ray tracing hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
		</author>
		<idno>TR-90-21</idno>
		<imprint>
			<date type="published" when="1990-07" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Sciences, The University of Texas at Austin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface reconstruction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
