<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Procedural Interface for Volume Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">L</forename><surname>Montine</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Alliant Computer Systems One Monarch Drive Littleton</orgName>
								<address>
									<postCode>01460</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Procedural Interface for Volume Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents a simple, procedural interface for doing volume rendering. The interface is built upon three types of objects: volumes, which contain the data to be visualized, environments, which set up viewing and lighting, and image objects, which convert results to a user definable format. A volume is rendered against a particular environment with the results sent to an image object for conversion. By defining volume qualities such as color, opacity, and gradient in terms of user definable transfer functions, the rendering process is made independent of the data set&apos;s underlying representation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A large class of scientific and engineering applications produce results in the form of 3D grids or volumes.</p><p>Volume rendering has proved itself a useful technique for visualizing these data sets. Although numerous volume rendering algorithms have been developed (see 123, <ref type="bibr" target="#b6">[7]</ref>, [81, [91). there has been little published which formalizes and standardizes the interface to these capa-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>bilities.</head><p>The Alliant Volume Visualization Environment (AVOLVE) defines a C procedural interface for manipulating, and rendering volume data sets. This interface was developed with several goals in mind:</p><p>The interface should make it simple for existing applications to incorporate volume rendering. The interface should be flexible enough to handle a variety of volume rendering problems.</p><p>The interface is based on the creation and manipulation of three object types: volumes, environments and images. Volumes are three dimensional rectangular grids containing data and attributes. Environments define external items like light sources and viewing parameters. Images are objects that produce 2D volume images in a particular format (e.g. a twenty-four bit X image). Visualizing a volume involves rendering it against an environment and sending the results to an image object for conversion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Volume Objects</head><p>Volume objects are 3D rectangular grids that have an arbitrary data structure defined at each discrete grid location. Examples of grid data structures include an 8 bit scalar density field and a three dimensional, real valued vector field.</p><p>The data is stored as a one dimensional array of grid locations arranged in depth (z) by height (y) by width (x) order (i.e. depth varies the slowest, and width varies the fastest). This ordering is equivalent to the ordering found in a C three dimensional array of structures declared as structure[zl [yl [XI.</p><p>The volume is positioned in a world coordinate system so that grid location &lt;O,O,O&gt; coincides with the origin.</p><p>The positive x direction corresponds to a positive increase in volume width. The positive y direction corresponds to a positive increase in volume height.</p><p>The positive z direction corresponds to a positive increase in volume depth.</p><p>Points within a volume fall into two categories. A volume sample point is a 3D world coordinate point contained within the extent of the volume. A voxel is a sample point that has no fractional part-Such a point corresponds exactly to a value in the data set and the ar,y,z&gt; coordinates can be used to index the data directly. A cell is a rectangular subvolume defined by eight adjacent voxels.</p><p>The Createvolume procedure takes a pointer to the data set together with dimension information and returns a unique volume identifier. This identifier is then passed to all procedures which need to manipulate this particular volume.</p><p>CH2913-2/90/0000/0036'$01 .OO -1990 IEEE</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Opacity &amp; Color Transfer Functions</head><p>Visualizing a volume data set requires understanding how color and opacity vary within the volume. In AVOLVE, this variation is under direct user control and is specified via independent transfer functions for both color and opacity <ref type="bibr" target="#b6">[7]</ref>. These transfer functions are invoked whenever information about volume opacity or color is required.</p><p>Each volume object has its own opacity and color transfer functions which are set by the SetColorXfer and SetOpacityXfer procedures. For input, both routines require a volume identifier, a pointer to the corresponding transfer function, and a pointer to a parameter structure. The parameter structure serves as a communication buffer between the application and the transfer function (i.e. it can be used to communicate interactive parameters like slider values).</p><p>When invoked during processing, the transfer functions are passed a volume identifier, a pointer to a sample point, and a pointer for storing the result. If the sample point is a voxel, the transfer function can index directly into the data set to make an opacity or color calculation.</p><p>If the sample point is not a voxel, the transfer function </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Voxel Attributes</head><p>Various attributes can be calculated and stored at each voxel. These types fall into two categories: merits and lighting dot products.  Voxel attributes are used in a variety of calculations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1.">Gradient Attributes</head><p>For example, the calculation of voxel dot products requires a voxel gradient. If a particular attribute is required for a calculation but has not been stored at the voxel, then it is generated on demand (but not stored).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Data Independence</head><p>The three quantities that AVOLVE must derive while rendering a volume are color, opacity, and voxel gra-dient. Making each of these quantities definable in terms of user specified transfer functions allows the interface to be independent of the data set's underlying representation. Voxel formats can be defined in terms of any arbitrary C data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Lighting Coefficients and Exponents</head><p>Each volume has a set of coefficients which determine how it interacts with light from the environment. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Environment Objects</head><p>Environment objects define external items required for rendering a volume. These items include light sources, views, and lighting methods. When a volume is rendered, its current renderer uses these items provided by the specified environment to produce the volume image.</p><p>The CreateEnviron procedure creates a new environment and returns a unique environment identifier. This identifier is then passed to all procedures which manipulate or communicate with this particular environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Views</head><p>Views are used to detennine the orientation of the volume in the final volume image. Each environment has a table of views. A particular view is created by invoking the Loadview procedure and passing it an environment identifier, a view number, a pointer to a view structure, and a pointer to a pixel dimension struc- The RenderVolume procedure uses the current view of the specified environment while rendering a volume. A particular view is made the current view by calling SetCurrentView and passing it an environment identifier and the appropriate view table index. Each environment also supports an ambient light intensity. This intensity is controlled through the Seambientlntensity procedure, passing it an environment identifier and a floating point intensity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Light Sources</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Lighting Methods and Calculations</head><p>Environments also control the type of lighting calculation that is applied to volume sample points. This type is specified using the SetEnvironLighting procedure and setting the lighting flag parameter to either FLAT, AMBIENT, DIFFUSE, or SPECULAR. The lighting calculation requires the following variables, let: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P =</head><note type="other">Lp</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Miscellaneous</head><p>The procedure SetBackgroundColor is used to set the background color the volume will be rendered against.</p><p>It takes a environment identifier and a pointer to a o ,g , b &gt; color triplet.</p><p>The environment can also limit rendering to a specific box region within the volume. The bounds of this box region are set by invoking the procedure SetDisplaya-bleExtent and passing it an environment identifier and an extent structure. This structure contains two points which indicate the front lower left and back upper right comers of the box (when viewed along the positive z axis). Sample points outsick this extent are ignored during the rendering process. By default, the displayable extent is the entire volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Image Objects</head><p>All An image object is created by the procedure CreateImage. The procedure returns a unique image identifier which is passed to all routines wishing to use this particular image object. This identifier is the third parameter passed to the RenderVolume procedure. The three parameters required by CreateImage are: a pointer indicating where to store the formatted volume image, the pixel dimensions of the volume image, and a pointer to an image conversion structure. This last structure contains pointers to various image conversion routines (i.e. routines to convert a pixel, scan line, or region of the image into a particular format).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implementation Details &amp; Results</head><p>AVOLVE is currently running on a Sun 4/260, an Alliant FX/80 and an Alliant FX/2800. On multiple processor machines like the FX/80 and W2800, parallelism can occur in two ways: voxel attributes (e.g. gradients) can be calculated in parallel; actual rendering of the volume can occur in parallel.  pixel-t pd;</p><p>xferp xferp.Thresh = .02;</p><p>xferp.Negative0pacity = .7;</p><p>P Render that hipip */ RenderVolume(volume,environ,image);</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>can</head><label></label><figDesc>interpolate data set values from the eight voxels of the surrounding cell and then can perform the required calculation on these interpolated values. Opacity calculations return floating point results in the range [O,ll. Color calculations return a u , g , b &gt; triplet with each component a real number in the range [0,1].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Lighting dot products are calculated at voxels by calling the procedure CalcDotProdAttributes and passing it a volume identifier, an attribute flag, an environment identifier, and a cull flag. If the attribute flag is DIFFUSE-DOT-PRODUCT, then the floating point quantity C I j (Nv 'Lj j j = l is stored at each voxel. where N, is the gradient at the voxel, and Lj and Ij are the direction vector and intensity for light source j. If the attribute flag is SPECULAR-DOT-PRODUCT, then the quantity j = l is stored at each voxel, where Hi is the highlight vector for light source j. All light source information is provided by the environment parameter. The cull flag allows dot product attribute calculations to be suppressed at certain voxels. If the flag is CULL-EXTENT, then only those voxels within the displayable extent specified by the environment are visited for calculation. If the flag is CULL-OPACITY, then only those voxels with non-zero opacity are considered. Both effects can be achieved by ORing flag values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>ture.00V K a k 1. 0</head><label>0</label><figDesc>As a result, a new view is created and loaded into the indicated table location. The view structure contains the following items:The view type (perspective or parallel). A view reference point (VRP) specified in world coordinates.A view plane normal 0.A view up vector (vup).The dimensions of the view plane window (U,,,,Voff 1.The scale of the view plane window (uXak,The offset of the eye hom the view reference point.The view plane (VP) is determined by the VRP and the VI". The view plane window (VPW) is a rectangle on the view plane centered about the VRP. When a volume is rendered, it is projected onto the VPW in a parallel or perspective manner as specified by the view type.this system will be denoted by U, V, and N, with corresponding unit vectors li , v^ , ii . The vector 5 is the unitized view plane normal, and li is the projection of the VUP onto the VP. These unit vectors are calculated according to the formulae [31:The sides of the VPW are parallel to the U and V axes.Measured in terms of the UVN system, the upper left hand corner of the VPW has the coordinates &lt; -U ,~~, V ,~~, O &gt; . This upper left hand comer coincides with the upper left hand corner of any volume image rendered using this view. The dimensions of the VPW in U and V are 2u,~f and 2vOff respectively. The u,,,~ and vscd parameters are used to scale the contents of the window. Together with uOff and voff, they determine the number of pixels within the VPW. These pixels correspond exactly to the pixels in the final volume image. Starting at the upper left hand comer of the VPW, a positive step in U moves from left to right across the image, and a negative step in v moves down the image (left, right, up and down are measured relative to an observer at the eye point looking in the direction of the view plane normal). The number of pixels in the VPW is returned in the pixel dimension structure passed to Loadview.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>An</head><label></label><figDesc>environment also contains a table of light sources. A light some is loaded into the table by calling the procedure LoadLight and passing it an environment identifier, a light source index, and a pointer to a light source structure. The light source structure contains the following items: the light source type (infinite or point), the light source intensity (O..l); the light some direction (infinite) or position (point).In addition to the table of light sources, an environment also has a list of active light sources. Only the active light sources are used during the rendering process. By default, light sources are not active after they are created. Light sources can be added U, or deleted from the active list by using the pIocedure Toggldight-Source. This procedure requires an environment identifier, a light source index, and a state flag. The indicated light source is added or deleted depending on whether the state flag is ON or OFF.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>sample point, the lighting value calculated at p, the opacity at p , the rgb color at p , the gradient at p , the volume's ambient coefficient, the volume's diffuse coefficient, the volume's specular coefficient, the volumes specular exponent, the environment's ambient intensity, normalized direction vector for light j the intensity of light source j, highlight vector for light j [51, normalized eye direction vector. If flat lighting is specified, then the lighting value is L, = 0, C , . Otherwise the value is given by [5]: 1 -+ kdCp Ij(N,.Lj) + k , z Ij(N,.Hj)" j=l j = l By using the procedure EvalLightingDotProdwt, dot products in the lighting equation can be either left alone (DOT-POSITIVE), negsted (DOT-NEGATIVE), or forced positive (DOT-ABSOLUTE).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>internal lighting calculations are done in &lt;r,g,b&gt; floating point format. An image object processes the results of a Rendervolume invocation and produces a volume image in a user specified format. For example, the final volume image could be written as an X11 twenty-four bit image, as a PHIGS Cell Amy, or in a compressed format for transmission over an image network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>For</head><label></label><figDesc>voxel attribute calculations, processor p works on all voxels u',j,k&gt; where k = p . N + p , W + p , . . . , and N is the total number of processors. For ray traced rendering, each processor performs ray tracing on different scan lines of the volume image. Each scan line is passed off to the image object for conversion. Appendix A lists the C code used to visualize a quantum mechanics calculation of a one electron orbital of a four iron, eight sulfur cluster found in many natural proteins (HIPIP). The data set is a 64 x 64 x 64 volume of floating point values. The gradients are calculated up front and uilinearly interpolated to each sample point. Specular lighting with a single infinite light source is set up by the environment. The data set is scaled by a factor of eight in x and y by the environment's view. Plate A1 of the Appendix shows a picture of the result.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>PP 4 ;PP</head><label>4</label><figDesc>-t xferp; P Read slices for volume. node = ReadSlices("hipip"); dim.i = dim.j = dim.k = 64, volume = CreateVolume(node,&amp;dim); */ Set up opacity and color transfer functions */ SetColorXfer(vo1umeJipip-color,&amp;xferp); SetOpacityXfer(vo1umeJlipip-opacity ,&amp;xferp); P Set voxel gradient routine for 32 bit * scalar fields. Set up volume reflection coeficients. coeff.red = coeff.green = coeff.blue = 1.0; SetVolumeDiffuseCoeffs(volume,&amp;coeff); SetVolumeAmbientCoeffs(volume,&amp;coeff); coeff.red = coeff.green = coeff.blue = .SetVolumeS pecularCoeffs(volume,&amp;coeff); */ /* Set up renderer 0 &amp; make it current. LoadRenderer(volume,O,RENDER-RAY-TRACE); Calculate the w e n t at voxels */ CalcGradientAttribute(vo1ume); Create an environment. */ environ = CreateEnvironO; SetAmbientIntensity(environ, .08); /* Set up viewing information. view.type = PARALLEL; view.vref.x = view.vref.y = 32; view.vref.z = -1; view.window.uoff = view.window.voff = 32; view.window.uscale = view.window.vscale = 2.0; view.vnonn.xdir = view.vn0rm.ydi.r = 0; view.vnorm.zdir = 0; view.vup.xdir = 0; view.vup.ydir = 1; view.vup.zdir = 0; view.eye-off = -1.0; */ LoadView(environ,O,&amp;vie w ,&amp;pd); SetCurrentView(environ,O); coeff.red = .6; coeff.green = .5; coeff.blue = .6; SetBackgroundColor(environ,&amp;coeff); Define single infinite light source. */ 1ight.type = " E -L I G H T ; 1ight.L.inf.direction.xdir = 0; 1ight.L.inf.direction.ydi.r = 0; 1ight.L.inf.direction.zdir = 1; light.L.inf.1 = 1.0; LoadLight(environ, 0, &amp;light); ToggleLightSource(environ, 0, ON); EvalLightingDotProduct(environ,DOT-AJ3SOLUTE); P Create an image object */ data = (rgba-t *)malloc@d.u*pd.v*sizeof(long)); image = CrteateImage(data, &amp;pd, NULL); P Load parameters for transfer functions. */</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>.2. Lighting Dot Product Attributes</head><label></label><figDesc></figDesc><table><row><cell>voxel. Gradient calculations using more elaborate filter-</cell></row><row><cell>ing techniques are planned for the future [61.</cell></row><row><cell>2.2Rendering a volume involves generating lighting values</cell></row><row><cell>(i.e. shaded color values) at volume sample points.</cell></row><row><cell>Diffuse lighting requires dot products between a gra-</cell></row><row><cell>dient and light some vectors. Specular lighting</cell></row><row><cell>involves dot products between a gradient and highlight</cell></row><row><cell>vectors; the result is then exponentiated. AVOLVE per-</cell></row><row><cell>mits both types of lighting dot products to be calculated</cell></row><row><cell>and stored at a voxel. During the rendering process,</cell></row><row><cell>these quantities can be interpolated to a sample point</cell></row><row><cell>and used in the lighting calculation. This reduces</cell></row><row><cell>rendering time at the expense of rendering quality (see</cell></row><row><cell>section 3.3 for more details on lighting).</cell></row><row><cell>Voxel gradients are stored as floating point triplets and</cell></row><row><cell>are calculated by a user specified voxel gradient transfer</cell></row><row><cell>function. This function is specified by the p d u r e</cell></row><row><cell>SetVoxelGradieniYfer which takes a volume identifier</cell></row><row><cell>and the pointer to the transfer function for input. When</cell></row><row><cell>invoked during processing, this voxel transfer function</cell></row><row><cell>is supplied a volume identifier, the coordinates of the</cell></row><row><cell>voxel, the offset of the voxel in the data set, and a</cell></row><row><cell>pointer indicating where to store the normalized results.</cell></row><row><cell>The procedure CalcCradientAttribute takes a volume</cell></row><row><cell>identifier for input and invokes the gradient transfer</cell></row><row><cell>function to calculate and store this attribute at each</cell></row><row><cell>voxel. AVOLVE provides routines to calculate gmbents</cell></row><row><cell>for a variety of scalar fields. These calculations use a</cell></row><row><cell>central difference on the six principal neighbors of the</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Each volume contains a table of renderers, any one of which can be used to provide rendering support. Providing multiple renderers per volume allows the same volume to be drawn using different techniques, or to be drawn with the same technique but with slightly different parameters. For example, one renderer may support a ray traced technique, another may support a cell by cell technique, and yet another may support a more interactive technique.A renderer is created with the LoadRenderer procedure. This procedure accepts a volume identifier, a renderer table index, and a renderer type. It creates the appropriate renderer and loads it into the requested table location. Currently, both a ray traced renderer and a slice plane renderer are supported.A volume is rendered by invoking RenderVolume and passing it the identifiers of the volume, environment and image objects to be used in the rendering process. The current renderer of the specified volume does the actual rendering. A particular renderer is made the current renderer by calling SetCurrentRenderer and passing it a volume identifier and the appropriate renderer table index. Ray Traced Rendering A ray traced renderer is created by invoking badtenderer with the type parameter set to RENDER-RAY-TRACE. This rendering method casts rays through each pixel in the view plane window. This window is defined by the current view of the environment passed to the RenderVolume procedure. If the current view is parallel, then the ray direction is the same as the view plane normal. If the view is perspective, then the ray direction is determined by the vector from the eye point to the pixel. The entry and exit points of the ray with the volume's extents are calculated. Evenly spaced sample points are then generated along the ray. At each sample point a shaded color and opacity are determined. The color and opacity of all the sample points along the ray are composited together. The result of this compositing operation is the final color of the corresponding pixel in the volume image [2]. opacity and shaded color value are determined at the sample point using the opacity transfer function and the renderer's shading precision (iust as it was for ray traced rendering). The sampled opacity times the sam-pled shaded color is stored as the color for the The VPW is oriented within the VP via a local coordicorresponding pixel. nate system whose origin is at the VRP. The axes of By default, the slice plane is positioned at &lt;o,O,o&gt; with its normal vector pointing along the positive z axis.The position and orientation of the slice plane are modified by invoking the procedure SetSlicePlane and passing it a volume identifier, render table index, and a pointer to a plane description. The plane description is in terms of a point on the plane and a normal to the plane. Note that the designated renderer must be a slice plane renderer.</figDesc><table /><note>Included in this set are coefficients for ambient, diffuse and specular reflections. In each case, the coefficients are specified via a u , g , b &gt; floating point triplet. SetVolumeAmbientCods, SetVolumeDiffiueCoeffs, and SetVolumeSpecularCoeffs are used to manipulate these coefficients. A volume identifier and a pointer to the coefficient structure are passed to the procedures as The specular exponent for a volume is set using SetVo- 1umeSpecularExp. This exponent is a single floating point number and determines the sharpness of specular highlights.input.2.5. Renderers Renderers perform the work needed to visualize a volume.2.5.1.The opacity at the sample point is determined by the opacity transfer function. There are two ways to calcu- late a shaded color at a ray sample point. These methods are specified by the SetRendererShadingPreci- sion function. Its parameters include a volume identifier, a renderer table index, and a method flag. If the method flag is IhTERP-GRADIENT, then shaded colors at a sample point are determined by trilinearly interpolating the gradients from the eight voxels of the surrounding cell and doing a full lighting calculation. If the method flag is INTERP-DOTPRODUCTS, then the shaded color is determined by trilinearly interpolating the lighting dot products from the eight voxels of the surrounding cell and then substituting these quantities into the lighting equation. This provides a lower qual- ity but faster result than the first method. The spacing between sample points along a ray is con- trolled by the procedure SetRendererSampleStep. Com- positing along a ray can be terminated at a user specified threshold by the function SetRendererOpaci- tyThresh. By default, compositing terminates when opa- city reaches unity. Both procedures require a volume identifier, a renderer index, and a floating point value indicating step size or threshold.2.5.2. Slice Plane RenderingA slice plane renderer is created by invoking M e n d e r e r with the type parameter set to RENDER-SL,ICE_PLANE. This rendering method sam- ples the volume at points lying on an arbitrary plane. Rays are cast through each pixel in the view plane win- dow and intersected witli the plane at a sample point.An</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>SetAttributeInterpolation procedure which takes a volume identifier, an attribute flag, and an interpolation method (e.g. LINEAR, or CUBIC) for input.The ability to mix geometric and volumetric data is becoming important to many volume rendering applications. AVOLVE could support this feature by providing a geometric display list per volume. This list can then be rendered along with the volume using techniques described in [ll and [21.Texture mapping volume data sets can be supported by providing a solid texture transfer function for each volume (see<ref type="bibr" target="#b3">[4]</ref> and<ref type="bibr" target="#b6">[7]</ref>). Additional renderer types will also be supported, for example, a cell by cell technique like the one described in[7]. Appendix A: AVOLVE Example This appendix contains the C code used to visualize the hipip orbital simulation presented in Plate A. The data set is a 64 x 64 x 64 grid of floating point values in the range of -.55 to .58.</figDesc><table><row><cell>densi-ties. Diffuse dot products with a single infinite light source are stored at each voxel and interpolated to sam-ple points. Data courtesy of Siemens Medical Systems, Inc., Iselin, NJ. 6. Future Work Support for other types of volumes (e.g. spherical) can be achieved by adding an additional volume type param-eter to the Createvolume routine. Each volume possesses enough information to render itself against a given environment. Currently, voxel attributes are trilinearly interpolated to sample points. Additional control over interpolation can P Define structure for communicating to transfer * functions. */ typedef struct -xferp-t ( I x f e w s r e a l t NegativeOpacity ; real-t Thresh; main 0 ( char *CreateVolumeO, *CreateEnvironO; char *CreateImageO. *Readsliceso; char *volume, *environ, *image; char *ReadSlicesO,*node; void hipip-color0, hipip-opacity(); void CalcGradient-S32FO; light-source-t light; view-t view; rgb-t coeff; rgba-t *data; be achieved by providing a ##include cavolve.h&gt; node3d-t dim;</cell></row></table><note>The data set is courtesy of Louis Noodleman and David Case, Scripps Clinic, La Jolla, California.Plate A2 of the same appendix is a rendering of a mag- netic resonance data set for a human head. The skull has been partially removed to reveal the brain. The data set is a 256 x 256 x 109 volume of 16 bit</note></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">3D Scan-Conversion Algorithms for Voxel Based Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shimony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Worhhop on Interactive 3 0 Graphics</title>
		<meeting>ACM Worhhop on Interactive 3 0 Graphics<address><addrLine>Chapel Hill, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-10" />
			<biblScope unit="page" from="45" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Natural and Efficient Viewing Parameters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Michener</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Carlbom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Solid Texture Mapping of Complex Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Illumination for Computer Generated Pictures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phong</forename><surname>Bui-Tong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="311" to="317" />
			<date type="published" when="1975-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Active-Ray Tracing for 3D Medical Imaging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Trousset</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Schmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROGRAPHICS &apos;87</title>
		<imprint>
			<date type="published" when="1987-10" />
			<biblScope unit="page" from="139" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">VBUFFER: Visible Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Rendering Algorithm for Visualizing 3D Scalar Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
