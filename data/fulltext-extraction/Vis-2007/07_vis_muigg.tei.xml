<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Hybrid Unstructured and Structured Grid Raycasting</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-10-27">27 October 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Muigg</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Hadwiger</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Helmut</forename><surname>Doleisch</surname></persName>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Helwig</forename><surname>Hauser</surname></persName>
							<email>helwig.hauser@uib.no</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">VRVis Research Center</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Bergen</orgName>
								<address>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scalable Hybrid Unstructured and Structured Grid Raycasting</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-10-27">27 October 2007</date>
						</imprint>
					</monogr>
					<note type="submission">received 31 March 2007; accepted 1 August 2007</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Hierarchy Generation Cell Clipping Direct Volume Rendering Unstructured Result Image Compositing Entry Surface Visualization Single Brick Volume Rendering Exit Surface Visualization Volume Subdivision Brick Classification Priority Computation Memory Allocation</keywords>
			</textClass>
			<abstract>
				<p>This paper presents a scalable framework for real-time raycasting of large unstructured volumes that employs a hybrid bricking approach. It adaptively combines original unstructured bricks in important (focus) regions, with structured bricks that are resampled on demand in less important (context) regions. The basis of this focus+context approach is interactive specification of a scalar degree of interest (DOI) function. Thus, rendering always considers two volumes simultaneously: a scalar data volume, and the current DOI volume. The crucial problem of visibility sorting is solved by raycasting individual bricks and compositing in visibility order from front to back. In order to minimize visual errors at the grid boundary, it is always rendered accurately, even for resampled bricks. A variety of different rendering modes can be combined, including contour enhancement. A very important property of our approach is that it supports a variety of cell types natively, i.e., it is not constrained to tetrahedral grids, even when interpolation within cells is used. Moreover, our framework can handle multi-variate data, e.g., multiple scalar channels such as temperature or pressure, as well as time-dependent data. The combination of unstructured and structured bricks with different quality characteristics such as the type of interpolation or resampling resolution in conjunction with custom texture memory management yields a very scalable system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Unstructured grids are an important volumetric representation that is especially common in the field of computational fluid dynamics (CFD), e.g., simulations of engineering problems computed with finite volume methods. Real-world simulation grids are often comprised of a variety of cell types, such as tetrahedra, hexahedra, octahedra, and prisms. However, most rendering approaches convert general unstructured grids into tetrahedral grids in a pre-processing stage and only handle tetrahedra during actual rendering. This subdivision of more complex cells into linear subcells, however, naturally prevents interpolation of a C 1 -continuous function within non-tetrahedral cells. Thus, it is desirable for many real-world applications to avoid tetrahedralization for rendering. Naturally, another challenge for rendering is the number of cells, which can easily be several hundred thousand to millions of cells. Avoiding tetrahedralization reduces the number of cells that need to be rendered significantly. <ref type="figure" target="#fig_2">Figure 2</ref> shows a dataset of a generator that contains more than six million cells of mixed type (for one time step), which can be rendered interactively by our system.</p><p>The four main approaches for GPU-based rendering of unstructured grids are cell projection via the projected tetrahedra algorithm <ref type="bibr" target="#b22">[23]</ref>, raycasting <ref type="bibr" target="#b30">[31]</ref>, resampling into a structured grid and rendering this grid instead <ref type="bibr" target="#b34">[35]</ref>, and point-based approaches <ref type="bibr" target="#b36">[37]</ref>. One of the most important problems when rendering unstructured grids is obtaining a correct visibility order. Cell projection and point-based approaches require explicit visibility sorting, which is a major bottleneck of these methods. Raycasting implicitly establishes correct visibility without explicit cell sorting. This property is a huge advantage of raycasting approaches and makes them competitive with cell projection when for the latter not only the time for projection and rendering but also for sorting is considered. Our framework employs raycasting as basic rendering method, but in contrast with similar approaches does not require the entire grid to be resident in GPU memory due to bricking.</p><p>Another important problem is how data interpolation is performed. Although CFD simulations are commonly computed on a per-cell basis (cell-centered data), visualization with interpolation usually builds on data values given at the vertices of the grid (vertex-centered data).</p><p>If necessary, conversion between these different representations can be performed. The main problem, however, is how to perform interpolation when rendering general unstructured cell types. Cell projection is usually restricted to tetrahedral cells and thus linear interpolation, i.e., barycentric interpolation within individual tetrahedra. An important goal of our work is to be able to render the original cells, and thus also to perform consistent interpolation in these cells. A powerful method for interpolating in general polygons are mean value coordinates <ref type="bibr" target="#b6">[7]</ref>, which have been extended for closed triangular meshes <ref type="bibr" target="#b11">[12]</ref>, and for general polyhedra <ref type="bibr" target="#b16">[17]</ref>. Our method offers different interpolation options and builds on mean value coordinates for high-quality interpolation in general cells.</p><p>The approach presented in this paper renders large, and possibly time-dependent, unstructured grids in real-time by performing raycasting through a hybrid unstructured and structured brick subdivision of the original unstructured grid. We employ a focus+context approach where the goal is to render as many bricks as possible using the original cells, especially bricks in the focus, and render less important bricks in the context using a structured grid obtained via on-the-fly resampling. Focus and context regions are selected via interactive specification of a degree of interest (DOI) function <ref type="bibr" target="#b3">[4]</ref>. DOI values in [0, 1] are specified for each grid vertex or cell, and constitute an additional volume that is always used during rendering in addition to measured or simulated data values such as temperature or pressure. That is, our system handles multi-variate scalar data and at any one time renders one selected scalar channel such as temperature in conjunction with the scalar DOI function. The original grid cells are never subdivided into tetrahedra, but are rendered directly using one of several options for data interpolation. Scalability is mainly achieved by combining:</p><p>• Unstructured and structured bricks (hybrid rendering) • Different structured brick resolutions • Different interpolation options and adaptive sampling rate • Distinguishing between focus and context regions • Custom dynamic texture memory management Furthermore, although we are focusing on rendering on a single GPU, our method would also be easily parallelizable by distributing individual bricks to multiple GPUs <ref type="bibr" target="#b25">[26]</ref>. To summarize, the major contributions of this paper are:</p><p>• Hybrid raycasting through unstructured and structured bricks  . Overview of our hybrid raycasting pipeline. In a pre-processing step, the grid is subdivided into a kD-tree hierarchy of bricks. Given the current degree of interest (DOI) function, bricks are classified for rendering as unstructured bricks, resampled into structured bricks, or "empty" bricks that will be rendered as grid boundary only. Dynamic memory allocation is performed depending on brick type. Direct volume rendering proceeds in front to back order, rendering each brick according to its type, and also rendering the geometric grid boundary in correct visibility order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Most object-order methods for rendering unstructured grids are based on the Projected Tetrahedra (PT) algorithm <ref type="bibr" target="#b22">[23]</ref>, which samples only cell faces. Depending on graphics hardware features, the volume rendering integral can be solved using improved accuracy <ref type="bibr" target="#b24">[25]</ref>, with the best results generally achieved by pre-integration <ref type="bibr" target="#b21">[22]</ref>. Almost all cell projection approaches are constrained to tetrahedra, although the extension to polyhedra is possible using approximations <ref type="bibr" target="#b18">[19]</ref>. However, a major performance bottleneck of all PT variants is the need for explicit visibility sorting. A variety of powerful sorting approaches have been developed <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b23">24]</ref>, including hybrid CPU/GPU methods <ref type="bibr" target="#b2">[3]</ref>. An explicit sorting step is also required by most point-based methods for rendering unstructured grids <ref type="bibr" target="#b36">[37]</ref>. Point-sampling strategies have also been employed successfully for simplification of very large unstructured grids <ref type="bibr" target="#b27">[28]</ref>. However, the sorting step required by all object-order methods can only be neglected when commutative blending modes such as purely emissive volumes <ref type="bibr" target="#b31">[32]</ref> are used. In contrast, image-order approaches such as raycasting <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b9">10]</ref> are usually slower in pure rendering performance than cell-projection techniques, but compensate for this fact by the lack of an explicit sorting step. They are also very flexible, e.g., with respect to adaptive sampling, and are a natural choice when complex non-linear interpolation techniques such as mean value coordinates <ref type="bibr" target="#b11">[12]</ref> are desired. For structured grids, GPU raycasting approaches have also been shown to work very well <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b9">10]</ref>. In order to tackle very large volumes, many approaches employ a hierarchical subdivision, e.g., octrees for a multiresolution representation and rendering of structured grids <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b0">1]</ref>. Bricking approaches such as these are usually only used for structured data, whereas for unstructured grids, cells are only roughly assigned to nodes in a hierarchy for acceleration <ref type="bibr" target="#b19">[20]</ref>. In contrast, our approach for bricking unstructured data for memory management and hybrid rendering is very similar to bricking of structured data. Another possibility to render unstructured grids is to resample them into a structured representation for rendering, which can be performed hierarchically <ref type="bibr" target="#b17">[18]</ref>. Powerful resampling algorithms have been developed, especially in order to leverage the rasterization power of GPUs <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b34">35]</ref>. A recent approach is to use a resampling strategy on-the-fly during rendering <ref type="bibr" target="#b8">[9]</ref>. Client/server architectures are another powerful approach to rendering very large unstructured grids <ref type="bibr" target="#b1">[2]</ref>. Many cell sorting and also raycasting techniques require non-convex grids to be convexified <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b20">21]</ref> before they can be rendered. Our approach circumvents this by using a depth peeling approach <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>The hybrid renderer discussed in this paper has been implemented as a plugin for the SimVis system <ref type="bibr" target="#b3">[4]</ref>. SimVis employs multiple linked views ( <ref type="figure" target="#fig_2">Figure 2</ref>) for concurrently showing, exploring, and analyzing different aspects of multi-variate data. 3D views can be used to visualize features that are specified interactively in several types of attribute views, e.g., scatterplots or histograms. For this feature specification, the user visually inspects selected attributes in order to gain insight into the selected relations in the data. The interesting subsets are then brushed interactively, the result of which is integrated with the data volume in the form of an additional degree of interest (DOI) volume. This DOI attribution is used in all views of the analysis setup to visually discriminate the specified features from the rest of the data in a focus+context visualization style that is used consistently in all linked views. Focus+context approaches are very well suited for showing the user the actual parts of interest in large data sets <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b13">14]</ref>. The SimVis system and the hybrid raycaster support smooth brushing <ref type="bibr" target="#b4">[5]</ref>, i.e., fractional DOI values, as well as the logical combination of brushes for the specification of complex features based on multiple data attributes and derived information. <ref type="figure" target="#fig_1">Figure 1</ref> shows an overview of our hybrid raycasting pipeline. It consists of three major stages. The first stage (Section 3.1) is a preprocessing stage that subdivides the entire unstructured grid into a kDtree hierarchy by clipping grid cells against kD-tree leaf boundaries, which determines the bricks used in the interactive stages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">HYBRID RAYCASTING</head><p>The second stage (Section 3.2) must be invoked whenever the user changes the DOI function or selects a different scalar data channel such as "temperature". According to the DOI, bricks are classified in order to determine their importance and corresponding rendering quality and style. Furthermore, the scalar data in a brick also influence the choice of rendering quality. The major choice here is whether a brick should be rendered in its original unstructured form, or as a lower-quality structured brick. The latter are obtained by on-demand resampling whenever a brick that has not been resampled before is required in structured form. Finally, when the DOI for all values in a brick is zero, it is classified as "empty" brick for which only the contained geometric grid boundary is rendered.</p><p>The final stage is invoked whenever a new view needs to be generated, for which the kD-tree is traversed in front-to-back visibility order, rendering the contained mesh boundary and raycasting each en-countered brick in turn, and compositing in the output image buffer. As illustrated in <ref type="figure" target="#fig_3">Figure 3</ref>, viewing rays can traverse different brick types, and the sampling pattern and kind of interpolation along each ray is adapted to the current underlying type. Especially due to the hybrid nature of our pipeline, the transition between individual bricks must be handled with care (Section 3.3). Raycasting of individual bricks also depends on their type, such as unstructured bricks (Section 3.4) or structured bricks (Section 3.5). For each brick, the frontmost mesh surface in it is rasterized first in order to obtain ray start positions. The mesh surface itself is rendered as well, and direct volume rendering with one of several user-selectable optical models is performed in-between. This ensures that the original mesh boundary is rendered accurately and consistently everywhere and is independent of actual brick types and quality settings. Non-convex parts of the mesh are handled using a depth peeling approach. For "empty" bricks, the mesh boundary is rendered using regular depth peeling <ref type="bibr" target="#b5">[6]</ref>, whereas for all other bricks each depth layer is ray-cast individually with proper compositing of layers in front-to-back order <ref type="bibr" target="#b32">[33]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Spatial Subdivision</head><p>An important advantage of our bricking scheme is that it allows one to apply optimizations from structured volume rendering to all brick types uniformly, including unstructured bricks. Each brick is a leaf node of a kD-tree, which is used here because it provides better control over the number of entries in its child nodes than similar data structures such as octrees. For each brick, view frustum culling is performed, and empty bricks are skipped entirely (by the volume renderer). This helps with distributing rendering and memory resources only among visible parts of the data. Besides this, rendering individual bricks enables efficiently dealing with highly non-convex meshes. Many datasets from the engineering field have very complex surface geometries (e.g., <ref type="figure" target="#fig_8">Figure 7)</ref>, which would require a high number of rendering passes when treated as one entity. Our bricking scheme greatly reduces the overall number of depth peels, because each brick is peeled independently.</p><p>The contents of each brick are clipped against the brick boundary in order to guarantee correct compositing of brick contributions during raycasting. Depending on the brick type one of three different clipping methods is used: The intersection polygon for cells in structured bricks is obtained via cell/brick intersection on the CPU. For cells in unstructured bricks, a quad is clipped to the cell interior on the GPU. The boundary of "empty" bricks is clipped using simple clipping planes. The depth of the kD-tree is determined by limiting the number of cells and vertices within each brick to 64K, which allows for memory savings when storing unstructured grid topology. If time-varying meshes have to be visualized, the brick decomposition is performed for every timestep, except for time-dependent data specified on static grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Brick Classification</head><p>The bricking scheme we employ facilitates distribution of processing and memory resources such that important portions of the dataset are favored over less interesting regions, which is done based on each brick's importance. In order to determine the importance of a brick, we combine three simple measures that can be evaluated efficiently. The first measure is the average DOI value within the brick, which represents the user's interest in its contents. The second and third measure are the entropy of the histograms of the DOI and the scalar field within the brick, respectively, in order to reflect its information content. All three measures result in values in [0, 1] and are weighted equally. The individual bricks are then sorted based on their importance, and texture memory resources are distributed in this order. The original unstructured representation (Section 3.4) of a brick is used as long as enough memory is available, while for all other bricks a small 3D texture is allocated and filled on-demand by resampling the unstructured data (Section 3.5). Since empty bricks do not need any volumetric representation, they are ignored by the memory management system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Inter-Brick Ray Propagation</head><p>An important issue in bricked volume rendering is that the transition between individual bricks does not introduce visual artifacts. Naturally, this issue is especially important in a hybrid bricking scheme s barycentric interpolated sample mean value interpolated sample linearly approximated sample trilinearly interpolated sample such as the one presented here. Specifics of raycasting unstructured and structured grids, respectively, are described in the two following sections, whereas this section highlights common details and describes how rays are propagated from brick to brick.</p><p>Each ray cast through a brick starts either at the front-most mesh boundary contained in the brick, or at the intersection of the brick boundary with the interior of an unstructured cell. This is true for both unstructured and structured bricks, and ray start positions are obtained via rasterization of either mesh boundary faces or cell/brick-boundary intersection geometry. Compositing is performed using two compositing buffers that are used alternately (ping-pong blending). <ref type="figure" target="#fig_3">Figure 3</ref> shows the two most important cases for ray traversal from one brick to the next. In a single rendering pass, each ray stops either when the mesh interior is exited, which may happen multiple times in a single brick due to non-convex mesh geometry and depth peeling, or when a back-face of the brick bounding box is hit. Depending on these cases, raycasting in the next brick continues either at the last location of the previous ray segment (lower ray in <ref type="figure" target="#fig_3">Figure 3</ref>), or continues where the ray re-enters the mesh interior (upper ray in <ref type="figure" target="#fig_3">Figure 3)</ref>. This property is consistent between brick transitions of the same type (e.g., unstructured to unstructured) and mixed type (shown in <ref type="figure" target="#fig_3">Figure 3</ref>). Within a brick, non-convex mesh geometry is handled via depth peeling, and thus raycasting may be performed in multiple passes. Each subsequent pass continues at the next ray entry position behind the last depth of the previous pass, until the last depth layer has been traversed. The number of raycasting passes is determined via OpenGL occlusion queries, which detect whether an additional depth layer within the current brick exists. Thus, bricking significantly reduces the number of passes due to depth peeling which alleviates its potential performance impact, because the maximum number of depth layers within a single brick is much lower than for the entire grid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Unstructured Bricks</head><p>Our raycasting algorithm for unstructured bricks is based on the work of Garrity <ref type="bibr" target="#b7">[8]</ref> and Weiler et al. <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b32">33]</ref> for tetrahedral meshes. However, we perform direct raycasting of non-tetrahedral cells without a (often ambiguous) tetrahedral decomposition, which usually introduces C 1 discontinuities of the interpolated scalar within a cell. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data and Memory Management:</head><p>Raycasting of one brick is performed for small submeshes of the whole dataset, which have to be represented efficiently in texture memory. We employ a custom memory manager to distribute texture resources between bricks. <ref type="figure">Figure 5</ref> shows the four different types of texture sets we are using to store the  Addressing cell face information is done using indices i x , i y , and f , where f is the face index <ref type="table" target="#tab_1">(Table 1</ref>). There are two alternative schemes for this memory layout and addressing with different tradeoffs between access speed and memory consumption: The first method (marked with * in <ref type="table" target="#tab_1">Table 1</ref>) simplifies address computations, and assumes that all cells contain an equal number of f max faces. Both triangle and quad faces occupy the same amount of space, and for the former the fourth vertex index is simply flagged as invalid. In this case, n cell /256 f max rows have to be allocated. The second addressing scheme (marked with * * in <ref type="table" target="#tab_1">Table 1</ref>) allows for a more compact memory footprint. Here, triangle and quad faces are stored in separate texture sets which are addressed independently. All cells are grouped by the number of triangle faces (n i,tri ) and quad faces (n i,quad ), also using corresponding row offsets o tri and o quad , respectively. This enables allocating only as many texture rows as necessary for each group, which allows for a tighter packing of face data. Both of these memory layouts have been tested on real world datasets, and are denoted as simple and packed layout in Section 5.2.</p><formula xml:id="formula_0">i y + o cell Vertex v x v y + o vtx Face * i x i y • f max + f + o face Tri Face * * i x i y • n i,tri + f + o tri (n i,tri , n i,quad ) Quad Face * * i x i y • n i,quad + f + o quad (n i,tri , n i,quad )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Raycasting:</head><p>The raycasting process itself consists of two major parts: ray propagation through the grid, and sampling the scalar function within a cell in order to evaluate the volume rendering inte-  gral. Rays are started by rasterizing the surface of the mesh in order to write encoded cell indices into the red and green color channels. Since we limit the maximum number of cells per brick to 64K, two channels with 8 bits each are sufficient. Additionally, the face through which a ray enters a cell is encoded in the blue channel. If a cell is clipped by the brick boundary, this is indicated in the blue channel as well.</p><p>During ray propagation, only cell-centered and cell face information is used, which can be addressed directly, which allows for rapid evaluation of the face through which a ray exits the current cell. This is achieved by intersecting the ray with all face planes and choosing the intersection closest to the entry point in the ray's direction <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sampling and Interpolation:</head><p>The volume rendering integral is approximated by sampling the DOI and scalar data volumes within each cell and compositing the corresponding opacities and colors according to one of several optical models (Section 4). In contrast with approaches for tetrahedral cells, sampling a single cell multiple times is necessary in order to handle complex cell types. In order to obtain scalar values at arbitrary positions within a cell, we employ mean value coordinates for interpolation as introduced by Floater <ref type="bibr" target="#b6">[7]</ref>, and generalized to triangular meshes by Ju et al. <ref type="bibr" target="#b11">[12]</ref>. An important property of mean value interpolation is that it can be evaluated locally for each face. Thus each vertex weight can be split up into components w j k that are contributed by the faces j that contain the vertex at index k. Now w j k can be evaluated for position x as</p><formula xml:id="formula_1">w j k (x) = n j k • m j n j k • (p j k − x) .<label>(1)</label></formula><p>Here, p j k is the position of vertex k in face j, and n j k the normal of the plane defined by points x, p j k+1 and p j k+2 . The vector m j is the so called mean vector of face j which can be computed as</p><formula xml:id="formula_2">m j = 3 ∑ k=1 θ j k n j k<label>(2)</label></formula><p>θ j k denotes the angle between p j k+1 − x and p j k+2 − x. For a more elaborate description of mean value coordinates for meshes we refer to Ju et al. <ref type="bibr" target="#b11">[12]</ref>, who additionally propose several optimizations to enhance the numerical robustness of their approach in the vicinity of the polyhedron's faces and vertices. Evaluating all contributions of all cell faces to one sample position means iterating over all faces. This implies that the face data used to perform the interpolation (vertex positions, scalar and DOI data) all has to be available for the evaluation of each sample. The drawback of this approach is that either a large amount of temporary registers in the shader has to be used to store all face information or that fetching the data multiple times from textures would be necessary. We avoid this by computing the scalar and DOI contributions from one face j to all sampling positions before the next face is considered:</p><formula xml:id="formula_3">S i = 3 ∑ k=0 s j k w j k DOI i = 3 ∑ k=0 doi j k w j k W i = 3 ∑ k=0 w j k<label>(3)</label></formula><p>Only three values per sample i have to be stored: the current scalar value S i , DOI value DOI i , and the accumulated weight W i which is used to homogenize the samples after all faces of a cell have made their contributions. s j k and doi j k denote scalar and DOI data sampled at the face's vertices. The main advantage of this approach is that only the data from one face and one small array (the number of mean value samples is limited to a user-defined upper bound) storing three values per sample has to be used by the raycasting shader. Sample Distribution: Since the computation of mean value coordinates for a sample is expensive (it involves several cross products, normalizations, and an inverse trigonometric function to compute the angle θ j k ), it is desirable to distribute mean value samples carefully. Thus, mean value interpolation is only used in a cell's interior, distributing the samples equally along the ray segment within it. Simple barycentric interpolation is applied to compute scalar values at the ray-face intersections. In order to further improve the image quality without sacrificing much performance, additional samples can be computed between the positions of the already computed samples by linearly interpolating between them. If only one scalar volume is used, pre-integration methods from tetrahedral grid raycasting could be applied <ref type="bibr" target="#b21">[22]</ref> instead of computing multiple linearly interpolated samples.</p><p>In order to steer the performance/image quality of the visualization, two parameters are used by the raycaster for unstructured bricks: The maximum length of a ray segment which can be approximated linearly (l l ), and the maximum length of a ray segment along which a scalar is considered to be constant (l c ). Thus s l /l l mean value samples are computed for a ray segment within a cell, where s l is the length of the ray segment. We have chosen to distribute the sampling positions evenly to avoid mean value coordinate computations near the face through which the viewing ray exits, which degenerates towards barycentric interpolation anyway. The parameter l c is used to determine how many samples should be taken in-between two mean value/barycentrically interpolated values by interpolating linearly, as shown in <ref type="figure" target="#fig_3">Figure 3</ref>. Again s c /l c equally-distributed samples are computed and evaluated, where</p><formula xml:id="formula_4">s c = s l / ( s l /l l + 1).</formula><p>Both parameters can be used to specify several special cases that can either be used to render preview images or to produce highquality presentation visualizations. By setting s l larger than the diameter of the largest cell's bounding sphere, only barycentric samples are computed at the cell's faces. This reduces rendering complexity tremendously and results in highly interactive framerates even for large datasets. In order to create very high-quality images, s l can be specified far smaller than the largest cell, and s c larger than s l , which forces the raycaster to perform only mean value interpolation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Structured Bricks</head><p>If the brick classification step (Section 3.2) determines that a brick should be rendered in structured form, all unstructured cells contained in or intersected by the brick will be resampled into a single 3D texture. The resampling resolution depends on the number of unstructured cells n in the brick instead of its volume. For this purpose, a uniform distribution within the brick is assumed in order to guarantee memory savings over the unstructured representation. To account for the brick's aspect ratio we first approximate the structured brick's resolution as</p><formula xml:id="formula_5">x = 3 nr 2 1 r 2 y = (nr 2 )/x z= n/(xy)<label>(4)</label></formula><p>where r 1 = width/height and r 2 = height/depth denote the aspect ratio of a brick bounding box. The actual texture resolution along each axis is then selected as the first power-of-two that is not smaller than x, y, and z, respectively. In this work, we are not focusing on the actual algorithm used for resampling, as any existing method could be used for this purpose, e.g. <ref type="bibr" target="#b34">[35]</ref>. Currently, we are using a very simple and fast CPU-based resampling algorithm that still achieves good results. Basically, the scalar values at the resampling locations are determined by Gaussian splats positioned at the cell centers. The size of these splats is chosen according to the cell size, and modified if necessary such that even cells that are much smaller than a single voxel still contribute to the eight surrounding voxels. Raycasting of the resulting structured bricks is performed by rasterizing the mesh boundary in order to obtain ray start and end positions, respectively. In order to handle non-convex grids and skip all empty space, we use a modified depth peeling approach <ref type="bibr" target="#b32">[33]</ref>, where the number of raycasting passes is determined by the number of depth layers. Depth peeling also makes rendering the geometric grid boundary in correct visibility order straight-forward. The main difference to regular volume raycasting <ref type="bibr" target="#b14">[15]</ref> is that rays are started and stopped at exactly those positions where a ray enters and exits the unstructured mesh, respectively. The mesh boundary is rendered into two floating point textures: The first one for the position of the ray entry point, and the second one for the ray exit point. Depth peeling is also performed separately for ray entry and ray exit positions, respectively. The main reason for this is that common simulation approaches such as coupled heat transport and flow simulation result in meshes where interface faces are duplicated, i.e., both the front-face and the backface are present in the mesh. Section 5 describes an example. The sampling rate for structured bricks is chosen to be consistent with unstructured brick rendering. The parameter l c described in the previous section that determines the maximum distance between two linearly interpolated samples in unstructured bricks also determines the sampling rate of structured bricks. As shown in <ref type="figure" target="#fig_3">Figure 3</ref> and described in Section 3.3, the actual positions of samples are chosen such that the visibility of the brick boundary between different brick types is minimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RENDERING MODES</head><p>Our hybrid raycaster has to deal with two different data volumes simultaneously: the scalar field of the underlying dataset (e.g., temperature), and the scalar DOI function specified by the user. In order to visualize this multi-volume, several rendering modes can be selected by specifying a boundary visualization technique, and an optical model for   <ref type="table">Table 3</ref>. Various datasets used throughout this paper. In addition to the cell type percentage (tetrahedra, pyramids, triangular prisms and hexahedra), the equivalent number of tetrahedral cells using a minimal subdivision is given for comparison. The overall number of bricks is shown along the number of resampled bricks (in brackets). The performance measures are based on the simple memory layout presented in Section 3.4. For comparison purposes, performance numbers using the public version of HAVS <ref type="bibr" target="#b2">[3]</ref> are also given for the tetrahedralized datasets (using the command line options "-none -p").</p><p>direct volume rendering. <ref type="figure" target="#fig_6">Figure 6</ref> illustrates all four combinations of two different optical models and boundary visualization techniques. <ref type="table" target="#tab_4">Table 2</ref> summarizes the major parameters and the underlying data required. Color and opacity at position x are computed according to the following equations, using a local blending factor λ (x) that depends on the optical model:</p><formula xml:id="formula_6">c(x) = λ (x)tf s win (x) + 1 − λ (x) c l , (5) α(x) = λ (x) f α ,<label>(6)</label></formula><p>where c l is the luminance of the context, f α is the opacity of the focus, and s win (x) is the scalar s(x) mapped from [s min , s max ] to [0, 1] with a windowing function ( <ref type="table" target="#tab_4">Table 2)</ref>. The first optical model is based on emission/absorption without shading and distinguishes between context and focus according to the DOI function:</p><formula xml:id="formula_7">λ (x) = DOI(x)<label>(7)</label></formula><p>This choice of λ smoothly blends between the context luminance and the color transfer function, and derives the opacity linearly from the DOI function. <ref type="figure" target="#fig_6">Figures 6 (a)</ref> and (b) show this optical model applied to the Small Cooling Jacket dataset in which regions of high turbulent kinetic energy have been selected smoothly. Color values represent the corresponding pressure within the volume. The context luminance c l is set to zero to emphasize the structure of the selected data region. The second optical model shown in Figures 6 (c) and (d) creates visualizations that resemble smooth iso-surfaces. In this case, both the DOI function and the windowed scalar value are used to determine the blending factor λ :</p><formula xml:id="formula_8">λ (x) = DOI(x)t 01 s win (x)<label>(8)</label></formula><p>where t 01 (•) is a tent function centered at 0.5 in the interval [0, 1], which smoothly fades out λ around the window center. The DOI function is incorporated in order to ensure that bricks with DOI(x) = 0 for all x also use a constant opacity of zero. For such bricks only the boundary will be rendered. Thus, the smooth iso-surface created by this optical model can additionally be clipped smoothly by specifying an adequate DOI function. By using λ (x) to modulate the resulting color the lack of proper shading of the smooth surface can be somewhat compensated. Rays only touching the surface will gather more dark samples (if c l is set to zero) than rays intersecting it, which results in dark silhouettes. This "shading" approach is similar to limb darkening <ref type="bibr" target="#b10">[11]</ref>.</p><p>It is important to note that besides the optical model for volume rendering the boundary visualization is of very high importance to the overall visualization approach presented in this paper. Datasets from the engineering field very often contain complex surfaces which can be of high interest to the user if they interact with the simulated phenomena. Therefore, we have decided to treat the mesh surface as context information which can be visualized using different boundary visualization techniques. <ref type="figure" target="#fig_6">Figures 6 (a)</ref>  </p><formula xml:id="formula_9">α = (n s • v) 4 c α .</formula><p>With this approach only a minimal amount of the data volume is obstructed by the boundary visualization, which, however, still provides proper contextual cues to relate the selected flow features to the overall geometry of the dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPLICATION RESULTS</head><p>In this section an example application of the hybrid raycasting algorithm in conjunction with the SimVis system is presented. Additionally the memory requirement, rendering performance and image quality of our approach is discussed.</p><p>Additional application results, high-quality images, and the accompanying video are available from the project homepage at www. vrvis.at/via/research/hybridRC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Large Data</head><p>The Generator dataset contains one sixth of the geometry of a generator (the remaining five sixth are symmetrical). The data volume itself consists of two parts: the solid portion of the generator and the air surrounding it. Both parts are separate meshes which touch each other on a common surface. The problem that has been modeled within the dataset, is the cooling of the generator. Thus heat transport and dissipation has been simulated for the solid portion of the dataset, while air temperature and flow has been computed for the surrounding air.</p><p>The grid itself poses multiple challenges to the visualization system. First of all the mesh surface has a very high depth complexity, which requires many depth layers to be rendered for the final visualization. Even when decomposed into 282 bricks every brick contains between two to eight depth layers (depending on the view port). On average five depth layers have to be rendered. Since nearly all stateof-the-art methods can only handle tetrahedral volume cells, the Generator dataset would have to be tetrahedralized to be visualized with them, which would result in a cellcount of over 15 million as shown in <ref type="table">Table 3</ref>. <ref type="figure" target="#fig_2">Figure 2</ref> shows a result image from a complete visualization session using the SimVis system and the hybrid raycasting algorithm. It is comprised of four different selections which are combined by using a fuzzy OR operation, and maps temperature to color. The first selection specifies the solid portions of the dataset which are used to provide additional context to the user. Additionally cold and warm portions of air have been selected. It can be observed that cool air which is sucked through the cooling ducts at the top of the dataset is heated up rather quickly and stagnates in the space above the winding heads. In order to visualize the vortex, which is located behind the air outlet the fourth selection marks low pressure as important. As concluded by Trenker et al. <ref type="bibr" target="#b26">[27]</ref> (who used the SimVis system with an early prototype implementation of the hybrid raycasting method) it is desirable to deflect this vortex to pass through the winding heads at the air outlet (probably by moving the outlet itself) to avoid the stagnation of hot air and thus provide better cooling for the overall machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Quality and Performance Considerations</head><p>Several parameters can be used to steer the memory consumption, the speed, and the image quality of the presented visualization approach. In order to guarantee responsiveness during an analysis and exploration session two different sets of parameter settings can be chosen: one is applied during interaction, and one is used for generating static images. Additionally, it is possible to progressively update the display during the generation of a static image (every n'th brick the accumulated color and opacity information is copied to the front buffer). In <ref type="table">Table 3</ref> some performance measures are presented for the different datasets shown in this paper. Different quality settings have been used to measure rendering performance during interaction, for a static image and for the dataset without using resampling (here, an unstructured brick always forces the memory manager to allocate texture memory, even if data from another brick has to be overwritten). During interaction only one depth peel for every brick is rendered, and the unstructured brick sampling settings are configured to perform only barycentric interpolation at the cell boundaries. Additionally the result image resolution is reduced to 256 2 (instead of 512 2 for the static measurements). In the static case the sampling settings for the unstructured bricks are set to l l = c max /4 and l c = c max /16 with c max being the maximum diameter of a cell's bounding sphere. Thus a maximum of four mean value samples are computed per cell per ray. These settings are equal to those used to create the "Presentation" column of <ref type="table">Table 3</ref> resulting in the same measures for datasets which completely fit into the texture memory allocated for unstructured data.</p><p>For comparison with a fast state-of-the-art tetrahedral volume renderer, the last column of <ref type="table">Table 3</ref> shows the performance of the publicly available implementation of the HAVS algorithm <ref type="bibr" target="#b2">[3]</ref> for our datasets converted to tetrahedral grids. It can be observed that HAVS is more than five times faster than our approach when generating high-quality images for the Small Cooling Jacket. However, the time required by visibility sorting increases at least linearly with the number of cells (2.5s for the Large Cooling Jacket), which is probably the main factor why our raycasting method outperforms HAVS for this dataset even under "Presentation" quality settings that cause streaming of texture data onto the GPU during rendering. For loading the Generator dataset, the HAVS implementation that we used exceeded the memory limits on our machine. However, this implementation is probably not optimized for datasets of this size, and the client/server version <ref type="bibr" target="#b1">[2]</ref> would have to be used for comparison purposes.</p><p>A more in-depth analysis of memory consumption and performance characteristics of our approach is presented in <ref type="table" target="#tab_6">Table 4</ref>. Here the Large Cooling Jacket and the Generator are used to compare the simple and packed memory layouts. The table clearly shows that the effectiveness of the two layouts highly depends on the distribution of different cell types within the dataset. The percentage of tetrahedral cells is far higher in the Generator which leads to a less efficient representation when compared to the Large Cooling Jacket which can be observed when comparing the memory requirements per tetrahedron (as comparison the tetrahedral strip encoding proposed by Weiler et al. <ref type="bibr">[</ref>  uses 76 byte/tet which can be reduced to 15 byte/tet if additional rendering speed is sacrificed for a less redundant data representation). Furthermore, the packed layout is only more efficient than the simple layout if the mesh contains a large variety of cell types, e.g., the Generator. If most cells are of the same type, such as in the Large Cooling Jacket, the simple layout uses less memory <ref type="table" target="#tab_6">(Table 4</ref>). This is also reflected in the percentage of resampled cells, since a higher memory consumption requires resampling more cells. Additionally, the increased cost for fetching face data in the packed layout is reflected in the performance measures (using the same settings as <ref type="table">Table 3</ref>). Besides the rendering performance itself the brick boundaries are of high importance for image quality (especially between structured and unstructured bricks). <ref type="figure" target="#fig_8">Figure 7</ref> shows some comparisons between a high-quality visualization using only unstructured bricks and the default still image settings mentioned above (in order to reduce obstructions the boundary visualization is set to completely transparent). The overview on the left-hand side indicates resampled bricks in red. In <ref type="figure" target="#fig_8">Figure 7</ref> (a) barely any difference between resampled and original mesh can be seen, whereas <ref type="figure" target="#fig_8">Figure 7 (b)</ref> shows the low-pass filtering effect of the resampling process. Additionally <ref type="figure" target="#fig_8">Figure 7</ref> (c) shows a slight discontinuity between the resampled and original mesh. It should be noted that the previously mentioned effects mostly occur if high frequency transfer functions and DOI specifications are used. But since the SimVis framework emphasizes the smoothness of flow features (through smooth brushing) and the resampling process can be steered by interactively modifying the DOI specification, the application of resampling to unimportant regions is feasible.</p><p>All tests have been carried out on an AthlonX2 4400+ with 4GB of RAM, and a Geforce 8800GTX with 768MB video memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FUTURE WORK</head><p>We have presented a scalable hybrid GPU raycasting algorithm for unstructured grids. Our method directly renders complex cell types without tetrahedralization, where non-tetrahedral cells employ mean value interpolation for selected samples, and interpolates linearly inbetween. We employ bricking, resampling, and custom texture memory management in order to sustain interactive performance and make optimal use of the available amount of texture memory. It is a hybrid approach in the sense that it combines unstructured and structured grid raycasting, as well as image order methods (raycasting) and object order approaches (bricking). Different volume rendering styles are combined with surface rendering methods to create highly parameterizable visualizations that are based on two concurrent data volumes: a degree of interest (DOI) function specified in the SimVis system, and the scalar data volume. We also pay special attention to accurately rendering the surface mesh of the original grid at all times. Apart from better interpolation quality, avoiding tetrahedralization also balances the additional amount of work required by mean value interpolation as well as the additional memory for storing a variety of cell types. Converted to tetrahedral meshes, our datasets would contain twice to four times as many cells. The effectiveness and scalability of our ap-proach has been demonstrated by applying it to real-world datasets of different sizes containing large and highly complex meshes.</p><p>There are several interesting areas for future work. Some limitations of our current implementation, like the necessity for quad faces to be planar (which is not the case in some real world datasets) or the lack of gradient based shading could be addressed. The interpolation scheme could be extended to completely arbitrary polyhedra, which are becoming more common in real-world simulation grids. Moreover, new surface and volume rendering models could be integrated easily. The current resampling process could be greatly improved by implementing GPU-based methods. Finally, resampled bricks do not necessarily have to be seen as low-quality substitute of unstructured bricks. If adequate pre-filtering is performed during resampling, rendering those bricks where a single image pixel covers many cells in structured form could provide a way for performing anti-aliasing for high-quality rendering.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>• On-demand resampling steered by interactive focus+context specification • Rendering of original cell types with interpolation • Exact grid boundary visualization • Scalability in image quality and memory consumption Published 14 September 2007.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1. Overview of our hybrid raycasting pipeline. In a pre-processing step, the grid is subdivided into a kD-tree hierarchy of bricks. Given the current degree of interest (DOI) function, bricks are classified for rendering as unstructured bricks, resampled into structured bricks, or "empty" bricks that will be rendered as grid boundary only. Dynamic memory allocation is performed depending on brick type. Direct volume rendering proceeds in front to back order, rendering each brick according to its type, and also rendering the geometric grid boundary in correct visibility order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>The SimVis system with our raycasting view showing high/low temperature (red/green) regions, and low pressure (yellow) regions within the Generator dataset containing more than six million cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Two different viewing rays traversing an unstructured (left), followed by a structured (right) brick. The different sampling types are represented by the colored dots along the rays.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Figures 4 (a) and (b) show volume renderings of two different tetrahedral subdivisions of an octahedron, with color representing the influence of the top-most vertex. In contrast, Figure 4 (c) uses our algorithm without decomposition, and interpolation using mean value coordinates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Comparison of the influence of the top-most vertex of an octahedron in two different tetrahedralizations (a) and (b), and the original cell using mean value interpolation (c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Two different boundary rendering techniques (surface and silhouette enhancement) combined with two different optical volume models (standard DVR and smooth iso-surfaces) to four different rendering modes. High turbulent kinetic energy (TKE) is brushed and pressure mapped to color in the DVR images and used as parameter for the isosurface visualizations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>and (c) show silhouette boundary visualizations, whereas Figures 6 (b) and (d) have been created using simple shaded semi-transparent surface rendering. Silhouette rendering is realized by assigning a color b c to boundary samples and computing the corresponding opacity as</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Overview and magnifications of the Large Cooling Jacket dataset comparing the low quality resampled to the original unstructured representation. Resampled bricks are shown in red in the overview.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Addressing in texture sets (Figure 5).data of unstructured bricks: the cell texture set, triangle face texture set, quad face texture set, and cell vertex texture set. The cell texture set stores the number of faces of each cell. For cell-centered data, it also stores the per-cell DOI and the data scalar. The triangle and quad face texture sets store the neighboring cells' indices, face plane equations, and vertex indices corresponding to a face. The cell vertex texture set stores vertex (x, y, z) position, and per-vertex DOI and scalar data. Each texture set is comprised of one or more 2D textures of size 256 × s max , where s max is the maximum allowed size of a 2D texture. The information of several consecutive bricks is stored backto-back as long as there is space, and a new texture is only allocated when the previous one is full. For each brick as many consecutive rows</figDesc><table /><note>as necessary are allocated, forcing an integral number of rows to make addressing simpler. Thus, a brick containing n cell cells and n vtx vertices uses n cell /256 and n vtx /256 rows in the cell and ver- tex texture sets, respectively. In our implementation, all indices are 16-bit integers that are represented by two separate 8-bit components that can directly be stored in two 8-bit color channels, e.g., the red and green channel. Thus, we also create bricks such that n cell &lt; 64K and n vtx &lt; 64K. Table 1 illustrates addressing in texture sets. Every data item is addressed with two 8-bit values i x and i y for the index within a row and the address of the row, respectively. Additionally, row base offsets o cell and o vtx must be added in order to perform addressing relative to where the brick's data start in the texture set.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>User-definable parameters, and the data available to the different boundary rendering and direct volume rendering models.</figDesc><table><row><cell>Dataset</cell><cell>Tet</cell><cell cols="2">Pyram. Prism</cell><cell>Hexa</cell><cell cols="2"># Cells Tet</cell><cell>Bricks</cell><cell cols="2">Interact. Static</cell><cell>Pres.</cell><cell>HAVS</cell></row><row><cell>Generator</cell><cell cols="2">55.4% 0.6%</cell><cell cols="6">23.9% 20.1% 6,730K ≈15,405K 282(222) 375ms</cell><cell>2.6s</cell><cell>22s</cell><cell>-</cell></row><row><cell cols="2">Large Cooling Jacket 0.2%</cell><cell>5.2%</cell><cell>9.3%</cell><cell cols="3">85.3% 1,538K ≈7,149K</cell><cell>60(10)</cell><cell>234ms</cell><cell>1.0s</cell><cell>2.4s</cell><cell>6.0s</cell></row><row><cell cols="2">Small Cooling Jacket 0.2%</cell><cell>1.3%</cell><cell>2.1%</cell><cell cols="2">98.4% 77K</cell><cell>≈377K</cell><cell>2(0)</cell><cell>53ms</cell><cell>784ms 784ms 156ms</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 .</head><label>4</label><figDesc></figDesc><table /><note>Comparison of the two different layouting schemes (packed and simple) for the face texture sets described in Section 3.4.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGEMENTS</head><p>We thank Hermann Lang, Markus Trenker, Stephan Schmidt and Oliver Schögl for their support during this work. The datasets are courtesy of the Institute for Internal Combustion Engines and Thermodynamics, University of Technology Graz, Austria, AVL List GmbH, Graz, Austria, Arsenal Research, Vienna, Austria and Traktionssysteme Austria (contact: DDr. Neudorfer).</p><p>This work has been partly funded by the Bridge funding program of the Austrian Funding Agency (FFG) in the scope of the Severe Weather Explorer project (Nr. 812122).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multiresolution volume visualization with a texture-based octree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Boada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Navazo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="197" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Progressive volume rendering of large unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1307" to="1314" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hardwareassisted visibility sorting for unstructured volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ikits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L D</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="285" to="295" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Interactive feature specification for focus+context visualization of complex simulation data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization</title>
		<meeting>of the 5th Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="239" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Smooth brushing for focus+context visualization of simulation data in 3D</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSCG 2002 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="147" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Interactive order-independent transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Everitt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mean value coordinates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Floater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A generic and scalable pipeline for GPU tetrahedral grid rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Georgii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1345" to="1352" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Realtime ray-casting and advanced shading of discrete isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Scharsach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Buhler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="303" to="312" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Visualization of vector fields using seed LIC and volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Helgeland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Andreassen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="673" to="682" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Mean value coordinates for closed triangular meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 2005</title>
		<meeting>SIGGRAPH 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="561" to="566" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Cell-projection of cyclic meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="215" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">ClearView: An interactive context preserving hotspot visualization technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="941" to="948" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Acceleration techniques for GPU-based volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization 2003</title>
		<meeting>IEEE Visualization 2003</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="287" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multiresolution techniques for interactive texture-based volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lamar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;99</title>
		<meeting>IEEE Visualization &apos;99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="355" to="361" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Spherical barycentric coordinates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Langer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Belyaev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Eurographics Symposium on Geometry Processing 2006</title>
		<meeting>Eurographics Symposium on Geometry Processing 2006</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Interactive visualization of unstructured grids using hierarchical 3D textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEEE Symposium on Volume Visualization</title>
		<meeting>IEEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="2002-10-28" />
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Volume rendering for curvilinear and unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Computer Graphics International</title>
		<meeting>of Computer Graphics International</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="210" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-P</forename><surname>Sloan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="238" to="250" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Convexification of unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schieber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Fall Workshop on Vision, Modeling and Visualization (VMV 2004)</title>
		<meeting>of the 9th Fall Workshop on Vision, Modeling and Visualization (VMV 2004)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="283" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Hardware-accelerated volume and isosurface rendering based on cell-projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="109" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings San Diego Workshop on Volume Visualization</title>
		<meeting>San Diego Workshop on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An exact interactive time visibility ordering algorithm for polyhedral cell complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Volume Visualization &apos;98 (VolVis &apos;98)</title>
		<meeting>IEEE Symposium on Volume Visualization &apos;98 (VolVis &apos;98)</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="87" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Sorting and hardware assisted rendering for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">L</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Volume Visualization &apos;94 (VolVis &apos;94)</title>
		<meeting>IEEE Symposium on Volume Visualization &apos;94 (VolVis &apos;94)</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="83" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hierarchical visualization and compression of large volume datasets using GPU clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strengert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Magallón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th Eurographics/ACM SIGGRAPH Symposium on Parallel Graphics and Visualization (EGPGV 2004)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Validation of vortex flow phenomena in electrical machinery using advanced simulation and visualization techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Trenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Muigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the NAFEMS Worldcongress, page full Proceedings on CDROM</title>
		<meeting>the NAFEMS Worldcongress, page full Proceedings on CDROM</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Simplification of unstructured tetrahedral meshes by point sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Uesu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Fleishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shepherd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Volume Graphics</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="157" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Importance-driven focus of attention</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Viola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Feixas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="933" to="940" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Hardware-software-balanced resampling for the interactive visualization of unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hardware-based ray casting for tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="333" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Hardware-based viewindependent cell projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="163" to="175" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Texture-encoded tetrahedral strips</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Mallón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Volume Visualization</title>
		<meeting>IEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Level-of-detail volume rendering via 3D textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zimmerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Volume Visualization</title>
		<meeting>IEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The rendering of unstructured grids revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization</title>
		<meeting>of the 3rd Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Visibility-ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Interactive point-based rendering of higherorder tetrahedral data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1229" to="1236" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
