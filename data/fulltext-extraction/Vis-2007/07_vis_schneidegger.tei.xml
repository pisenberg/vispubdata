<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Querying and Creating Visualizations by Analogy</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><forename type="middle">E</forename><surname>Scheidegger</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huy</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Koop</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Juliana</forename><surname>Freire</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Cláudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
						</author>
						<title level="a" type="main">Querying and Creating Visualizations by Analogy</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>visualization systems</term>
					<term>query-by-example</term>
					<term>analogy</term>
				</keywords>
			</textClass>
			<abstract>
				<p>While there have been advances in visualization systems, particularly in multi-view visualizations and visual exploration, the process of building visualizations remains a major bottleneck in data exploration. We show that provenance metadata collected during the creation of pipelines can be reused to suggest similar content in related visualizations and guide semi-automated changes. We introduce the idea of query-by-example in the context of an ensemble of visualizations, and the use of analogies as first-class operations in a system to guide scalable interactions. We describe an implementation of these techniques in VisTrails, a publicly-available, open-source system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Over the last 20 years, visualization research has emerged as an effective means to help scientists, engineers, and other professionals extract insight from raw data. Visualization techniques are key to understanding complex phenomena, and the field has grown into a mature area with an established research agenda <ref type="bibr" target="#b21">[23]</ref>. Software systems have been developed that provide flexible frameworks for creating complex visualizations. These systems can be broadly classified as turnkey applications (e.g., ParaView, VisIt, Amira) <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr">22</ref>] and dataflow-based systems (e.g., VTK, SCIRun, AVS, OpenDX) <ref type="bibr" target="#b24">[27,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b26">29]</ref>. In this paper, we focus on dataflow systems, since they are more general and often serve as the foundation of turnkey applications (e.g., both ParaView and VisIt are based on VTK).</p><p>Most dataflow-based systems have sophisticated user interfaces with visual programming capabilities that ease the creation of visualizations. Nonetheless, the path from "data to insight" requires a laborious, trialand-error process, where users successively assemble, modify, and execute pipelines <ref type="bibr" target="#b27">[30]</ref>. In the course of exploratory studies, users often build large collections of visualizations, each of which helps in the understanding of a different aspect of their data. A scientist working on a new computational fluid dynamics application might need a collection of visualizations such as 3-D isosurface plots, 2-D plots with relevant quantitative information, and some direct volume rendering images. Although in general each of these visualizations is implemented in a separate dataflow, they have a certain amount of overlap (e.g., they may manipulate the same input data sets). Furthermore, for a particular class of visualizations, the scientists might generate several different versions of each individual dataflow while fine tuning visualization parameters or experimenting with different data sets.</p><p>In previous work, we proposed a new provenance model that uniformly captures changes to pipeline and parameter values during the course of data exploration <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4]</ref>. We showed that this detailed history information, combined with a multi-view visualization interface, simplifies the exploration process. It allows users to navigate through a large number of visualizations, giving them the ability to return to previous versions of a visualization, compare different pipelines and their results, and resume explorations where they left off.</p><p>In this paper, we show how this provenance information can also be used to simplify and partially automate the construction of new visualizations. Constructing insightful visualizations is a process that</p><p>• Carlos E. <ref type="bibr">Scheidegger</ref> requires expertise in both visualization techniques and the domain of the data being explored. We propose a new framework that enables the effective reuse of this knowledge to aid both expert and non-expert users in performing data exploration through visualization.</p><p>The framework consists of two key components: an intuitive interface for querying dataflows and a novel mechanism for semiautomatically creating visualizations by analogy. The query interface supports both simple keyword-based and selection queries (e.g., find visualizations created by some user), as well as complex, structure-based queries (e.g., find visualizations that apply simplification before an isosurface computation for irregular grid data sets). The query engine is exposed to the user through an intuitive query-by-example interface whereby users query dataflows through the same familiar interface they use to create the dataflows (see <ref type="figure" target="#fig_1">Figure 1</ref>). This simple, yet powerful approach lets users easily search through a large number of visualizations and identify pipelines that satisfy user-defined criteria.</p><p>While the query interface allows users to identify pipelines (and sub-pipelines) that are relevant for a particular task, the visualization by analogy component provides a mechanism for reusing these pipelines to construct new visualizations in a semi-automated manner-without requiring users to directly manipulate or edit the dataflow specifications. As <ref type="figure" target="#fig_2">Figure 2</ref> illustrates, our technique works by determining the difference between a source pair of analogous visualizations, and transferring this difference to a third visualization. This forms the basis for scalable updates: the user does not need to have knowledge of the exact details of the three visualization dataflows to perform the operation. Together, these contributions are a step towards scalable pipeline development and refinement as an integral part of visualization systems.</p><p>Contributions and Outline. To the best of our knowledge, this is the first work that leverages provenance information to simplify and automate the construction of new visualizations. The paper is organized as follows. We review related work in Section 2. In Section 3, we define a set of basic operations over sets of dataflows. These operations include computing the difference between two pipelines, updating pipeline definitions, and matching similar pipelines. For the latter, we describe a new algorithm based on neighborhood similarities (Section 5.3). The basic operations are used both in the query-by-example interface and in creating visualizations by analogy, which are presented in Section 4. An implementation of the proposed framework is discussed in Section 5. In Section 6, we present case studies that illustrate how our new dataflow manipulations streamline the process of constructing visualizations, and provide scalable mechanisms for exploring a large number of visualizations. We discuss the potential impact of our work on existing visualization systems in Section 7. We conclude in Section 8 where we outline directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Visualization systems have been quite successful at bringing visualization to a greater audience. Seminal systems such as AVS Explorer and Data Explorer <ref type="bibr" target="#b26">[29,</ref><ref type="bibr" target="#b10">11]</ref> enabled domain scientists to create visualiza-  . Querying by example. The interface for building a query over an ensemble of pipelines is essentially the same as the one for constructing and updating pipelines. In fact, they work together: portions of a pipeline can become query templates by directly pasting them onto the Query Canvas. In this figure, the user is looking for a volume rendered image of a file whose name contains the string "4877". The system highlights the matches both at the visualization level (version tree, shown in the middle) and at the module level (shown in the right insets).</p><p>tions with minimal training and effort. The early success of these systems led to the development of several alternative approaches. SCIRun <ref type="bibr" target="#b22">[24]</ref> focuses on computational steering: the intentional placement of visualization and human intervention in the process of generating simulations. The Visualization Toolkit <ref type="bibr" target="#b24">[27]</ref> is a library that directly exposes a powerful dataflow API for several programming languages.</p><p>However, as scientific visualization becomes more widely used, several scalability issues have arisen, which range from ensuring good performance, handling large amounts of data, capturing provenance, and providing interfaces to interact with a large number of visualizations. Distributed, parallel systems <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b2">3]</ref> have been developed to address performance and dataset size concerns. Such systems provide a scalable architecture for creating and running visualization pipelines with large data.</p><p>Another important requirement that has come to the attention of developers and users of visualization systems is the ability to record provenance so that computational experiments can be reproduced and validated. Provenance-aware scientific workflow systems have been developed that record provenance both for data products (i.e., how a given result was generated) and for the exploratory process, the sequence of steps followed to design and refine the workflows used to process the data <ref type="bibr">[25,</ref><ref type="bibr" target="#b23">26,</ref><ref type="bibr" target="#b3">4]</ref>. Provenance mechanisms have also been proposed for visualization-specific systems. Kreuseler et al. <ref type="bibr" target="#b15">[16]</ref> proposed a history mechanism for keeping track of parameter values in visual data mining, and Jankun-Kelly et al. <ref type="bibr" target="#b12">[13]</ref> recently proposed a formal calculus for parameter changes. VisTrails uses a scheme that uniformly captures both parameter and pipeline changes <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4]</ref>.</p><p>As multiple workflows are manipulated in exploratory processes, it is important to provide interfaces that allows users to compare their results. Jankun-Kelly and Ma <ref type="bibr" target="#b11">[12]</ref> have proposed a spreadsheet-like interface for quickly exploring the parameter space of a visualization. In the area of user interfaces, Kurlander et al. <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b16">17]</ref> have presented approaches to streamline the repetitive tasks users often face. The seminal example of a system which uses the same interface to both manipulate and query data is the Query-By-Example database language <ref type="bibr" target="#b28">[31]</ref>. We propose a similar approach for querying visualization ensembles in Section 4.2. Graph searching and query languages have also been investigated in database systems <ref type="bibr" target="#b25">[28]</ref>.</p><p>The algorithm we describe for matching two pipelines is similar to a technique developed to match database schemas <ref type="bibr" target="#b20">[21]</ref>. It is also reminiscent of well-known variations of PageRank, which is the basis for Google's successful ranking algorithm <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19]</ref>. Our visualizationby-analogy mechanism shares some of the objectives of programmingby-example techniques <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PIPELINE OPERATIONS</head><p>Below, we review some terminology and introduce basic pipeline operations that serve as the basis for query-by-example and visualization by analogy.</p><p>Definitions. A visualization system is a system that provides functionality for graphically displaying data according to a specific set of rules. The programmatic rules for displaying this data constitute a pipeline. Executing the pipeline in the visualization system produces a visualization. The pipeline is composed of modules which define specific operations and connections which specify the conceptual flow of data between modules. Each connection links an output port of one module (the source) with an input port of another module (the destination). Module state is represented by module parameters. We denote the set of all visualization pipelines as V.</p><p>Operations as functions on V. One important observation that we leverage throughout the text is that every operation performed on a pipeline (adding and deleting modules, connections and parameters, etc.) can be directly expressed as a (potentially partial) function f : V → V. Many of our results depend on making these functions firstclass elements in the visualization system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Computing Pipeline Differences</head><p>Dataflow-based systems allow users to create a variety of pipelines, rather than being restricted to a predefined set of visualizations. In the process of deriving insightful visualizations, a series of pipelines is often created by iterative refinement. To understand this process as well as the derived visualizations, it is useful to compare the different pipelines. The standard representation of a pipeline is a directed graph, with labeled vertices representing operations. Given a pair of such pipelines, we want to determine the difference between the visualizations they generate. In the following, we show how to describe and manipulate differences between pipelines.</p><p>We define δ : V → V as a function on the space of visualizations, and Δ : V × V → δ as a function that takes two pipelines p a and p b and produces another function that will transform p a to p b . For brevity, let δ ab = Δ(p a , p b ). From now on, we will use δ to refer to an arbitrary Δ(a, b). It is clear that δ is not unique: even though δ ab (p a ) = p b is a necessary constraint, there are no further restrictions. In some sense, we would like to pick the δ ab that minimally changes all other pipelines. We define the distance between p a and p b as the number of changes necessary to perform the transformation. We then look for the minimal set of operations that takes p a to p b . As we discuss in section 4.1, this is computationally impractical, so we relax the minimality requirement and instead use heuristics. In this case, the pair represents a change where a file downloaded from the WWW is smoothed. Then, the user chooses a set of other visualizations that will be used to derive new visualizations, with the same change. These new visualizations are derived automatically. The pipeline on the left reflects the original changes, and the one on the right reflects the changes when translated to the last visualization on the right. The pipeline pieces to be removed are portrayed in orange, and the ones to be added, in blue. Note that the surrounding modules do not match exactly: the system figures out the most likely match.</p><p>We also restrict our initial analysis to the simple case where p b is derived from p a -the user created p b by applying a finite set of changes to p a . We denote this relationship as p a &lt; p b . Then, a system with some knowledge of how the pipelines were constructed should be able to determine the differences between related pipelines using this history. We demonstrate such an implementation in Section 5.</p><p>When p a &lt; p b , we can then say δ ab is the sequence of operations that was used to derive p b from p a . However, few pairs of pipelines respect this property, and we would like Δ to be completely general. We start with a simple extension: if δ ab exists, so should δ ba . In fact, we would like</p><formula xml:id="formula_0">δ ab δ ba = e</formula><p>where e is the identity function. We can achieve this if our sequence of changes consists of invertible atomic operations. Specifically, suppose</p><formula xml:id="formula_1">δ ab = f n ••••• f 1</formula><p>where each f i has a well-defined inverse. For example, if f i is the operation of adding a module to the pipeline, f −1 i is the operation of deleting that module from the pipeline. Then,</p><formula xml:id="formula_2">δ ba = δ −1 ab = f −1 1 • ••• • f −1 n</formula><p>From now on, we assume that any function that operates on V has an inverse (note that both functions might still be partial).</p><p>Our ultimate goal is to apply the pipeline difference result δ to pipelines other than those used to create it. To analyze where δ is applicable, we introduce the domain and range context of δ . Formally, the domain context of δ , D(δ ), is the set of all pipeline primitives required to exist for δ to be applicable. We represent these contexts as sets of identifiers. For example, if δ is a function that changes the file name parameter of a module with id 32, D(δ ) is the set containing the module with id 32. Similarly, the range context of δ , R(δ ), is the set of all pipeline primitives that were added or modified by δ . Note that D(δ −1 ) = R(δ ), which provides an easy way to compute range contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Updating Pipelines</head><p>Finding differences is not only a useful technique for analyzing pipelines, but it can also be used to create new visualizations. The idea is similar to applying patches in software systems: the difference results can be applied to modify an existing pipeline. Given a δ , it is straightforward to apply it to a pipeline. Recall that δ is a sequence of actions that transform a pipeline. Thus, updating a pipeline p a is as simple as computing δ (p a ). Note, however, that δ can fail if an element of D(δ ) does not exist in p a . However, if we allow δ to continue despite one or more operations failing, we can still achieve a partial update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Matching Pipelines</head><p>While computing pipeline differences is an integral part in reasoning about multiple visualizations, another important operation is to match similar pipelines, i.e., we wish to find correspondences between pipelines. The result of pipeline matching can either be a binary decision (whether the pipelines match) or a mapping between the two inputs. Note that different metrics and thresholds can be used to determine the similarity of two pipelines. In the remainder of this section, we discuss an approach for finding the best mapping between two pipelines.</p><p>Let D represent the set of all domain contexts and define map : To construct such a mapping, we formulate the problem as a weighted graph matching problem. Let G a = (V a , E a ) be the graph corresponding to the pipeline p a . In a straightforward definition, V a would be the modules in p a and E a the connections in p a . However, one could consider other definitions such as the dual of this representation. For V a , we define a scoring function s : V a ×V b → [0.0, 1.0] that defines the compatibility between vertices. For example, the similarity score of two modules that are exactly the same can be set to 1.0 and the score of modules M 1 and M 2 such that M 1 is a subclass of M 2 may be set to 0.6.</p><formula xml:id="formula_3">V × V → (D → D)</formula><p>We define a matching between G a and G b as a set of pairs of vertices</p><formula xml:id="formula_4">M = {(v a , v b )} where v a ∈ V a and v b ∈ V b . A matching is good when ∑ (v a ,v b )∈M s(v a , v b )</formula><p>is maximized. A good matching on pipelines is one that corresponds to a good matching on their representative graphs. Given a good matching M, we can define a mapping from p a to p b as</p><formula xml:id="formula_5">v a → v b for all (v a , v b ) ∈ M.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SCALABLE PIPELINE MANIPULATION PRIMITIVES</head><p>Using the concepts defined in the previous section, we now introduce two new primitives for manipulating visualizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Complexity Analysis</head><p>The operations described in this section are theoretically hard to compute. Computing a minimal Δ(p a , p b ), or matching two pipelines p a and p b , is, in general, as hard as solving a subgraph isomorphism. <ref type="figure">Fig. 3</ref>. Query-by-example and analogy-based updates provide a simple way for users to manipulate multiple pipelines simultaneously. In this example, the user selects parts of a query result and updates them all with an analogy that introduces a preprocessing module to the pipeline that supersamples the original dataset.</p><p>This problem is trivially reducible from the MAX-CLIQUE problem, a well-known NP-complete problem. Additionally, MAX-CLIQUE is a particularly hard problem: there is no approximation algorithm for it with a subpolynomial approximation factor <ref type="bibr" target="#b8">[9]</ref>. Since we cannot get a good approximation, heuristics for both problems are well justified.</p><p>In this work, we make use of the information stored in δ functions both to reduce the search space and to increase the effectiveness of these heuristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Query-By-Example</head><p>Working with multiple visualizations is problematic if they have to be treated individually. In the process of visualizing different data sets, trying different techniques, and tweaking parameters, a user may create a large number of visualizations. It is clearly impractical to locate those that match certain criteria by examining each individually.</p><p>To solve the problem of locating pipelines, we introduce the idea of query-by-example for visualizations. Instead of formulating the search criteria in a structured language, a user builds a pipeline fragment that contains the desired features. The exact same interface used in building a pipeline can be used for building a query, which means that a user familiar with building pipelines can easily query them. <ref type="figure" target="#fig_1">Figure 1</ref> shows an excerpt of the query-by-example functionality.</p><p>Our algorithm is based on the observation that searching all pipelines for a given pattern is equivalent to determining whether a candidate pipeline matches the pattern. Once a query, represented as a pipeline fragment, is constructed, we can use the pipeline matching algorithm on each candidate pipeline to determine if it satisfies the query. Depending on user preferences, we can require an exact or an approximate match. While each element of the query pipeline (modules, connections, parameters, etc.) needs to be included in the match, a candidate pipeline that contains more elements than those in the query pipeline still satisfies the query.</p><p>It should be noted that differences can help optimize our matching. For example, suppose that we have a given query pipeline p q and two candidate pipelines p a and p b . If we find that p a satisfies the query, and we know δ ab , we can check to see if the domain context D(δ ab ) contains any elements that matched p q . If it does not, we know that p b also matches. Similarly, if p a does not match p q and R(δ ab ) does not contain necessary elements for matching p q , we know that p b will not satisfy the query. Thus, we can determine all pipelines that satisfy our query by iteratively matching and updating the matches based on differences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Visualization by Analogy</head><p>When creating visualizations, users often have to integrate new features into existing pipelines. For example, a user may wish to improve a given visualization by adjusting parameter so they match a published result. The user might also simply want to switch to a different visualization algorithm. In either case, there usually exists an example that demonstrates the given technique. A user can infer the necessary changes, and then apply them to a particular visualization. This analogical reasoning is very powerful, and we show that visualization by analogy can be (partly) automated. <ref type="figure" target="#fig_2">Figure 2</ref> illustrates the process of creating visualizations by analogy.</p><p>Two ordered pairs are analogous if the relationship between the first pair mirrors the relationship between the second pair. Therefore, if we know what the relationship is between the first pair, and are given the first entity of the second pair, we should be able to determine the other entity of that pair. More concretely, given a difference between δ two pipelines, we should be able to modify an arbitrary pipeline so that the resulting changes mirror δ .</p><p>To automate this operation, we need to compute the difference between two pipelines and apply this difference to another (possibly unrelated) pipeline. Suppose that we have three pipelines p a , p b , p c , and wish to compute p d so that p a : p b as p c : p d . We discussed the problem of finding the difference in Section 3.1, but recall that updating a pipeline p c with an arbitrary δ will fail if p c does not contain the domain context of δ . When this is the case, we need to map the difference so that it can be applied to p c .</p><p>We wish to express δ ab so that δ ab (p c ) succeeds. This is exactly what map ac does; recall that to construct this operator we need to find a match between p a and p c , as described in Section 3.3. More precisely, we first compute δ * cb = map ac (p a , p b ) and then find δ * cb (p c ). In summary, our algorithm is:</p><p>1. Compute the difference:</p><formula xml:id="formula_6">δ ab = Δ(p a , p b )</formula><p>2. Compute the map: map ac = map(p a , p c ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Compute the mapped difference: δ</head><formula xml:id="formula_7">* cb = map ac (δ ab ) 4. Compute p d = δ * cb (p c ) 5 IMPLEMENTATION</formula><p>To implement the scalable manipulation primitives introduced in Section 4, we use the freely available VisTrails system. VisTrails automatically captures the evolution of workflows which allows straightforward implementations of the pipeline operations presented in Section 3. We provide a quick overview of some key concepts in VisTrails; the reader is referred to <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4]</ref> for more details.</p><p>In VisTrails, as a user constructs a visualization, the entire history of manipulation is transparently stored in the version tree (the term vistrail is used interchangeably). Each action f that modifies the pipeline (e.g., adding or deleting a module, connecting modules, or changing </p><formula xml:id="formula_8">V → V,</formula><p>where V is the space of all possible visualizations. A pipeline is then the composition of these functions and is materialized by applying the resulting function to the empty visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Pipeline Differences</head><p>In a vistrail, the straightforward application of the action-based formalism allows the computation of simple differences. When p a &lt; p b , Δ(p a , p b ) is the sequence of actions from p a to p b which can be read directly from the vistrail. In addition, we have implemented the inverse operation of f for each type of operation in VisTrails so δ ba is also easily constructed. However, it is likely that we wish to compute a difference between pipelines that are not related in such a simple manner. Specifically, suppose that p a &lt; p b and p b &lt; p a . Note that there exists some p c (possibly the empty pipeline, which is in general the least common ancestor of both p a and p b ) such that p c &lt; p a and p c &lt; p b . Then,</p><formula xml:id="formula_9">δ ab = δ ac δ cb = δ −1 ca δ cb</formula><p>Thus, we can find Δ(p i , p j ) for any two pipelines, even if they are not directly related.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Pipeline Updates</head><p>Pipeline updates are also easily computed by taking the action-based representation of a pipeline and appending the new actions given by a δ . Although it is always possible to append the new actions in a vistrail, the resulting sequence of actions may be invalid. As noted earlier, this update can fail if the domain context of δ does match p a . More specifically, each operation in δ can succeed or fail based on whether the elements to be modified or deleted exist in p a .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Pipeline Matching</head><p>In our matching algorithm, we use the standard graph representation where vertices correspond to modules and edges to connections. In addition, even though we still discriminate between input and output ports, we do not enforce directionality on the edges so that we can diffuse similarity along them.</p><p>Recall that our goal in pipeline matching is to determine a mapping from the context of one pipeline to another. To do so, we convert the pipelines to labeled graphs and define a scoring function for nodes based on their labels. With a graph for each pipeline, we compute the mapping by pairing nodes that score well and enforcing connectivity constraints between these pairs.</p><p>Let G a and G b be the graphs corresponding to p a and p b . For our implementation, we define modules as vertices and connections as edges. Denote a connection between two vertices a and b as a ∼ b and define the scoring function that measures the pairwise compatibility of vertices by where ports(v) denotes the ports of the module corresponding to the vertex v. This measure emphasizes port matching: it gives higher scores to modules that can be more easily substituted for each other. Such a substitution depends solely on the compatibility of the input and output ports and not on module name or functionality. <ref type="figure" target="#fig_4">Figure 4</ref> shows an example of such an approximate matching.</p><formula xml:id="formula_10">c(v a , v b ) = | ports(v a ) ∩ ports(v b )| | ports(v a )| + | ports(v b )|</formula><p>Notice that this scoring function is defined only for nodes, and therefore, it does not help us in comparing the topologies of the pipelines. While a simple maximum bipartite matching <ref type="bibr" target="#b5">[6]</ref> between nodes may succeed in finding a map between nodes, we would like to enforce some connectivity constraints on the graphs. Intuitively, we want to define the similarity between vertices as a weighted average between how compatible the modules are and how similar their neighborhoods are. The similarity score strikes a balance between the locality of pairwise compatibility and the overall similarity of the neighborhood. This definition seems circular, but, surprisingly, it leads to a very simple and elegant matching technique based on the dominant eigenvector of a Markov chain <ref type="bibr" target="#b18">[19]</ref>.</p><p>We create a graph G = G a × G b that combines both G a and G b . In this graph, we define a vertex v a,b for each pair of vertices</p><formula xml:id="formula_11">v a ∈ V a , v b ∈ V b . Similarly, an edge v i, j ∼ v k, exists when v i ∼ v k in G a and v j ∼ v in G b .</formula><p>(G is the graph categorical product of G a and G b .) Notice that the connectivity of G encodes the pairwise neighborhoods of the vertices in G a and G b . We now want to translate our intuitive algorithm from the previous paragraph into an iterative algorithm. First, we need the following notation:</p><p>• π k (G) is the measure of pairwise similarity after k steps • A(G) is the adjacency matrix of G normalized so that the sum of each row is one (a row with sum zero is modified to be uniformly distributed)</p><p>• c(G) is the normalized vector whose elements are the scores for the paired vertices in G:</p><formula xml:id="formula_12">c(G) = (c(v a , v b ), v a ∈ G a , v b ∈ G b )</formula><p>• α is a user-defined parameter that determines the trade-off between pairwise scoring and connectivity</p><p>To iteratively refine our estimate, we diffuse the neighborhood similarity according to the following formula:</p><formula xml:id="formula_13">π k+1 = αA(G)π k + (1 − α)c(G) = M G π k (1)</formula><p>The final pairwise similarity between modules is given by π ∞ = lim k→∞ π k . For our purposes, c(G) gives a good measure of similarity so A(G) is used mainly to break ties between two alternatives. Thus, we choose a small weight for the neighborhood in our implementation (α = 0.15). Though this formulation makes intuitive sense, we want to ensure that repeated iteration always converges and does so quickly. It is clear that M G in Equation 1 is a linear operator; therefore, if π converges, it does so to an eigenvector. The theory of Markov chains tells us that because of the special structure of M G , it has spectrum <ref type="figure">Fig. 7</ref>. Switching the rendering technique by analogy. The analogy template on the left specifies that volume rendering modules should be replaced by isosurfacing ones. The analogy target and the resulting pipeline are shown, together with the resulting visualization. <ref type="bibr" target="#b18">[19]</ref>, and so the iteration is exactly the power method <ref type="bibr" target="#b7">[8]</ref> for eigenvalue calculation. Hence, the iteration will converge to the single dominant eigenvector, and each iteration will improve the estimate linearly by 1 − α. Since we are using a small α, this ensures quick convergence. From this iteration, we obtain π ∞ which contains the relative probabilities of v a ∈ G a and v b ∈ G b matching for each possible pair. For each vertex in v a , the vertex in v b whose pair has the maximum value in π ∞ will be considered the match. <ref type="figure" target="#fig_5">Figure 5</ref> illustrates how the matchings are refined as the mapping algorithm iterates.</p><formula xml:id="formula_14">(1, α, α 2 , •••)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Query-by-example</head><p>Recall that the benefit of query-by-example is that users do not have to learn a query language or a new interface to find matching pipelines. Our implementation presents the same interface used in building a pipeline as it does for querying an ensemble of pipelines, as shown in <ref type="figure" target="#fig_1">Figure 1</ref>. A user constructs a query pipeline by dragging modules from a list of available modules or copying and pasting pieces of existing pipelines. Parameters and connections can also be specified in a similar manner. When the user executes the query, the system searches the current version tree for all pipelines that match that query.</p><p>As discussed in Section 4, we want to find pipelines that contain the query pipeline. Currently, this matching is computed on a per pipeline basis. Specifically, for each pipeline, we topologically sort the vertices of the graph induced by the pipeline and match the vertices of the query graph. If all vertices match, we return the candidate pipeline as a match. All matches are selected and highlighted in the version tree so that users can quickly see query results. Selecting a version will display the pipeline with the portion of the pipeline that matched the query highlighted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Visualization by analogy</head><p>There are two steps involved in applying an analogy to a pipeline. First, the user defines the analogy template by selecting the two pipelines whose difference is to applied to another pipeline. Second, the user selects another pipeline and applies the analogy to that pipeline, creating a new pipeline. In VisTrails, these operations can be executed in either the version tree pane of the builder window or the visualization spreadsheet. In either case, the application of the analogy creates a new version in the vistrail.</p><p>In the version tree, an analogy is defined by dragging the version representing initial pipeline to the version representing the desired result. This operation displays the difference between the pipelines and the user is able to click a button to create an analogy from these pipelines. To apply the analogy, the user right-clicks on the version representing the pipeline and selects the desired analogy.</p><p>Creating and applying analogies in the VisTrails Spreadsheet is similar but even easier to use. The spreadsheet supports a viewing mode and a composition mode. In the composition mode, a user can create an analogy by dragging one cell into another cell. To apply the analogy, the user drags the pipeline to be modified to a new cell, at which point the analogy is applied and the new visualization displayed.</p><p>The computation of the analogy mirrors the algorithm described in Section 4.3. More concretely, for pipelines p a and p b defining the analogy and the pipeline to be updated p c , we derive δ ab using the version tree. We then match G a and G c using the algorithm described in Section 5.3 to obtain map ac and use this function to compute δ * cb which can then be applied to p c to produce a new pipeline p d .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CASE STUDIES</head><p>We present three examples that illustrate the proposed primitives.</p><p>Example 1: Updating Inputs in Multiple Pipelines In this scenario, we want to compare different isosurface extraction techniques. In particular, we wish to investigate how resilient the techniques are to subsampled or oversampled data. Typically, the techniques are first compared using raw inputs. The task, then, is to update the pipelines with the new test data.</p><p>There are several ways to address this problem. The most straightforward one is to develop a preprocessing script that converts the files. Although this is feasible, it is not desirable since it puts the burden to manage the data on the user. At the least, it requires explicit management of intermediate files, and it does not provide an explicit record of the desired experiment. A better alternative is to directly create new dataflows that exercise the test regime. It is clear, however, that this can be time consuming if the specialist must first examine each pipeline to determine whether it needs to be updated and only then perform the required modifications.</p><p>It is therefore desirable to automate this process. With query-byexample, we can find all matching pipelines with one operation. With analogies, we can perform the desired update once, capture that change as an analogy and apply it to the matching pipelines. Not only does this save time and effort, but it ensures that all pipelines are updated. In addition, each update is done in a similar manner; the possibility that the updates are inconsistent is reduced.</p><p>In this example, we construct a query template by copying the relevant portion of the pipeline onto the Query Canvas. This procedure returns a set of pipelines (highlighted in <ref type="figure">Figure 3</ref>) which we need to update. We first update one of the pipelines by directly adding the resampling step. Then, we define an analogy template using the original pipeline and the updated one. We apply this analogy to automatically update the other pipelines that match the query. As result, several new results are produced without requiring the user to manually update each individual pipeline.</p><p>Example 2: Changing a rendering algorithm In this example, we show a moderately complex change in a pipeline that replaces an entire rendering technique with another. When designing an effective visualization, one algorithm tends to perform better than the alternatives. It is natural, then, that a single visualization will be tried with different algorithms. When the best result is identified, the user must change the other visualizations to reflect this. In this example, we show that it is possible to replace an entire algorithm by analogy.</p><p>The visualization portrayed in <ref type="figure">Figure 7</ref> renders an ITK <ref type="bibr" target="#b9">[10]</ref> scalar field in VTK <ref type="bibr" target="#b24">[27]</ref>, using the Teem tools <ref type="bibr" target="#b13">[14]</ref> to generate the appropriate data format. While in the original change, there was only one generated view, in the analogy target there are two renderings, so the system must correctly decide the proper one to modify.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3: Chaining Analogies</head><p>We have discussed that one can modify a pipeline by analogy as a single update operation. However, one can also use analogies to quickly combine multiple examples. In this example, illustrated in <ref type="figure" target="#fig_6">Figure 6</ref>, we show how three different techniques can be combined to transform a very simple pipeline into a visualization that is not only more complicated but also more useful.</p><p>In many scientific fields, the amount of data and the need for interaction between researchers across the world has led to the creation of online databases that store much of the domain information required. Scientists are concerned not only with using data from these centralized repositories but also publishing their own results for others to view. In this example, we show how analogies can be used to modify a simple pipeline that visualizes protein data stored in a local file to obtain data from an online database, create an enhanced visualization for that protein, and finally publish the results as an HTML report.</p><p>We begin with a vistrail that contains pipelines that accomplish each of the individual tasks outlined above. Specifically, we have a simple pipeline p 0 that reads a file with protein data and generates a visualization of that data. We also have pipelines p 1 and p 1 where the difference between the two is that p 1 reads a local file and p 1 reads data from an online database, pipelines p 2 and p 2 where p 2 features a simple line-based rendering and p 2 improves the rendering to use a ball-and-stick model. Finally, p 3 displays a visualization while p 3 generates an HTML report that contains the visualized image.</p><p>To create the new pipeline, we compute the analogy between p 1 and p 1 and apply it to p 0 . Then, we compute the analogy between p 2 and p 2 and apply that the result of the previous step. Finally, we compute the analogy between p 3 and p 3 and apply it. The new pipeline p * 0 prompts the user for a protein name, uses that information to download the data for that protein, creates a ball-and-stick visualization of the data, and embeds that image in an HTML report.</p><p>The benefits of using analogies to generate this new pipeline not only include faster results but also a lower level of knowledge needed to modify pipelines. One can imagine a scientist who executes a pipeline to create a visualization downloading a pipeline which publishes data to the web and adding the same capability to their pipeline via analogy. Instead of trying to find the correct modules and manually modifying the pipeline, the scientist can use the analogy from the example pipeline to add the new feature automatically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>We argue that both query-by-example and visualization by analogy are useful operations that provide efficient solutions for what are otherwise manual, time-consuming tasks. The basic operations introduced in Section 3 rely both on the graph structure of pipelines and on pipeline modification history. As discussed, global comparisons of graphs are intractable in general, but the fact that visualization pipelines translate to labeled graphs where the nodes are largely distinct allows us to define effective heuristics. We believe that this framework can be used to develop additional primitives that significantly reduce the amount of work required to maintain and integrate ensembles of visualizations.</p><p>The proposed primitives can be easily implemented in dataflowbased visualization systems that provide undo/redo capabilities. As long as undo/redo operations are represented explicitly in the system (for example, using the Command design pattern <ref type="bibr" target="#b6">[7]</ref>), a straightforward serialization of these would achieve the wanted capabilities. Module and connection representations may vary across systems, but the framework and techniques apply as long as the elements can be translated to <ref type="figure">Fig. 8</ref>. A situation where creating pipelines by analogy fails. The intended effect when defining the analogy was to replace the raw file with a preprocessing step. Note, however, that there still is one lingering connection, highlighted in red.</p><p>labeled graphs.</p><p>As with most heuristics-based approaches, our approach to matching is not foolproof, and there are cases where it may fail to produce the results a user expects. For example, if a user applies an analogy to a pipeline that shares little or no similarity with the starting pipeline, the matching algorithm will return a mapping which is likely to be meaningless. However, when application of an analogy fails or produce poor results, the user can either discard or refine the resulting pipeline: analogies always construct new pipelines-they do not modify existing pipelines.</p><p>Analogies can be highly subjective. In some cases, applying an analogy can lead to ambiguity and derive multiple results. <ref type="figure">Figure 8</ref> shows an example of an analogy that is supposed to resample an input file before continuing with the rest of the pipeline. Instead of removing a connection from the raw file to downstream modules, the application keeps the old connection in addition to adding the new connection to the resampling module. In this case, a user might have to "clean up" the results of the pipeline. Our current pairwise similarity score tries to establish a compromise in the absence of domain-specific knowledge about modules. Formulating and incorporating such knowledge into the matching is certainly possible and desirable. An interesting avenue for future work is to investigate how to acquire this information in an unobtrusive way, for example, by taking user feedback about derived analogies into account. as an avenue for future work. Furthermore, our current implementation finds the best mapping in a greedy fashion, on a per-module basis. There are alternative ways of using π ∞ , and this investigation is part of future work.</p><p>One important consideration when introducing new manipulation primitives is the impact on how users interact with them. Query-byexample represents an intuitive way for users to query pipelines. One could imagine a querying tool that narrows results as the query is built (e.g., similar to auto-completion). Also, to extend our analogy tool, users' input could be used to guide the matching process, especially in cases where the automatic construction fails. Constraint information might be incorporated into the matching, allowing it to generate better results in situations where the information in the pipeline definitions is not sufficient. Along the same lines, it may be useful to allow users to explore the results of many possible matchings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS AND FUTURE WORK</head><p>We have described a new framework that leverages visualization provenance to simplify the construction of new visualizations. This framework provides scalable and easy-to-use primitives for querying pipeline ensembles and for creating multiple visualizations by analogy. We have also proposed efficient algorithms and intuitive interfaces for realizing these primitives in a visualization system.</p><p>There are many avenues for future work. The use of domain-specific distance measures between pipelines and modules may be useful for customizing analogy generation in some domains (for example, for transfer function design and comparison). We are currently investigating machine learning techniques for automatically determining common pipeline operations on a large database of visualizations, allowing templates to also be determined automatically.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Published 14</head><label>14</label><figDesc>September 2007.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1. Querying by example. The interface for building a query over an ensemble of pipelines is essentially the same as the one for constructing and updating pipelines. In fact, they work together: portions of a pipeline can become query templates by directly pasting them onto the Query Canvas. In this figure, the user is looking for a volume rendered image of a file whose name contains the string "4877". The system highlights the matches both at the visualization level (version tree, shown in the middle) and at the module level (shown in the right insets).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Visualization by analogy. The user chooses a pair of visualizations to serve as an analogy template.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>as a function which takes two pipelines, p a and p b , as input and produces a (partial) map from the domain context of p a to the domain context of p c . The map may be partial in cases where elements of p a do not have a match in p b or vice versa. Notice that if p a &lt; p b , map(p a , p b ) = map ab is the identity on all elements that were not added or deleted in the process of deriving p b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Example of an analogy between pipelines where there is no perfect module matching. The difference in the left pipeline pair is transferred to the right pipeline pair. Note, however, that the module names are not the same-the system must find the most likely pairing based on the similarity measure described in Section 5.3. a parameter) is represented explicitly as a function f :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Example matching generated by the pipeline matching algorithm. Thicker edges correspond to stronger correspondences. Notice that the correspondences get progressively better as the algorithm iterates. This matching corresponds to Example 2 in Section 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Creating complex pipelines by chaining simple analogies. From three simple examples, the user creates a complex visualization that creates a web page with enhanced molecule rendering, whose results are fetched from the Protein Database, an online macromolecular database.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, Huy T. Vo, David Koop and Cláudio T. Silva are with the Scientific Computing and Imaging (SCI) Institute at the University of Utah. email: {cscheid, hvo, dakoop, csilva}@sci.utah.edu. • Juliana Freire is with the School of Computing at the University of Utah.</figDesc><table /><note>email: {juliana}@cs.utah.edu Manuscript received 31 March 2007; accepted 1 August 2007; posted online 27 October 2007. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We acknowledge the generous help of many colleagues and collaborators. Suresh Venkatasubramanian helped with discussions on graph matching and complexity. Erik Anderson and João Comba graciously provided their vistrails for this work. Chems Touati and Steven Callahan helped produce the video and figures. This work uses a number of existing open-source software and data repositories, including Teem (http://teem.sourceforge.net), VTK (http://www.vtk.org), ITK (http://www.itk.org), trimesh2 (http://www.cs.princeton.edu/gfx/proj/trimesh2/), and the RCSB Protein Database. This work was funded by the National Science Foundation, the Department of Energy, and an IBM Faculty Award.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">VisTrails: Enabling interactive, multiple-view visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Crossno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The anatomy of a large-scale hypertextual Web search engine. Computer Networks and ISDN Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="107" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visualization in grid computing environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Brodlie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gallop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sagar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Walton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Managing the evolution of dataflows with VisTrails</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Workshop on Workflow and Data Flow for Scientific Applications (SciFlow)</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A contract-based system for large data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Childs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>Brugger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Bonnell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J</forename><surname>Whitlock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="190" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms, chapter 26</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Design Patterns: Elements of reusable object-oriented software, chapter 5</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Matrix computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">F V</forename><surname>Loan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Johns Hopkins University Press</publisher>
			<pubPlace>Baltimore, MD, USA</pubPlace>
		</imprint>
	</monogr>
	<note>3rd. edition</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Clique is hard to approximate within n 1−ε</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hastad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Mathematica</title>
		<imprint>
			<biblScope unit="volume">182</biblScope>
			<biblScope unit="page" from="105" to="142" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ibanez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cates</surname></persName>
		</author>
		<title level="m">The ITK Software Guide. Kitware, Inc. ISBN 1-930934-15-7</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>2nd. edition</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Opendx</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com/dx" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Visualization exploration and encapsulation via a spreadsheet-like interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jankun-Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="275" to="287" />
			<date type="published" when="2001-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A model and framework for visualization exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jankun-Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gertz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="357" to="369" />
			<date type="published" when="2007-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<ptr target="http://teem.sourceforge.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kitware</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paraview</surname></persName>
		</author>
		<ptr target="http://www.paraview.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A history mechanism for visual data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kreuseler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nocke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Information Visualization Symposium</title>
		<meeting>IEEE Information Visualization Symposium</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Graphical search and replace</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kurlander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Bier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 1988</title>
		<meeting>SIGGRAPH 1988</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="113" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A history-based macro by example system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kurlander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Feiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of UIST 1992</title>
		<meeting>UIST 1992</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="99" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Google&apos;s PageRank and Beyond: The Science of Search Engine Rankings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">N</forename><surname>Langville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Your Wish is My Command: Programming by Example</title>
		<editor>H. Lieberman</editor>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Similarity flooding: A versatile graph matching algorithm and its application to schema matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Data Engineering</title>
		<meeting>the 18th International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="117" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">NIH-NSF visualization research challenges report summary</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Moorhead</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rheingans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Yoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="20" to="24" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">SCIRun: a scientific programming environment for computational steering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (Supercomputing)</title>
		<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis (Supercomputing)</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Tackling the provenance challenge one layer at a time. Concurrency and Computation: Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>Kitware Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Algorithmics and applications of tree and graph searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Giugno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Database Systems</title>
		<meeting>the ACM Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The application visualization system: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Thomas</forename><surname>Faulhaber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The value of visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Query-by-example: a data base language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="324" to="343" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
