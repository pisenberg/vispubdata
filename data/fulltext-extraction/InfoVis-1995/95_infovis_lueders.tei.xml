<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Research Report rowsing in Information by the Automatic Display Layout</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Liiders</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universitst Braunschweig</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolf</forename><surname>Ernst</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universitst Braunschweig</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Research Report rowsing in Information by the Automatic Display Layout</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>It is well known that graphical representations could be very helpful to browse in graph structured information. But this promising approach requires the capability of an automatic layout system because the tedious and time consuming task of a manual layout leads to a rejection of this approach by the user: In our approach, we split the task of retrieving information into two phases that are getting the orientation within the network and reading currently visited information. We present layout algorithms for both phases which have the benefit of being flexible and adaptable to individual user requests and ensure the topological consistency, i.e. the stability of the topology of the information layout during a sequence of display layouts. The results show that especially the possibility of an animation of the layout process can assist the user essentially in maintaining the orientation in the information network.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Today, more and more computer are connected to a network. Therefore the total amount of information that is accessible by a computer is immense. Whereas some years ago the main problem in getting information was how to get them physically (example: to lend out and copy a part of a journal from the public library), it is now the main problem to locate the demanded information in the quantity of information (example: on which server and in which directory is the information). Therefore, the aim of the research area of information visualization is to assist the user in finding the appropriate information for a current problem and to display it in a comprehensible mode.</p><p>In the following, we assume that the information is interrelated and can be represented by a graph G = (V, E) consisting of a set of nodes V = {v,,, . . . , vn) -representing the individual informations itself -and a set of edges E = (e,, . . . . ee) -representing the interrelations between them. Each edge ei = (v,, vj) is defined by two nodes O-8186-7201-3/95 $04.00 0 1995 IEEE which can be sorted (directed edge) or unsorted <ref type="bibr">(undirected edge)</ref>.</p><p>It is well known that displaying the structure of a network in a graphical mode is a good means to help the user in finding some information for a current problem which is ,,hidden" within this network. An example of a graphical representation of an information network is shown in figure 1. Within this graphical representation the user can get the orientation within the structure ofi the information and can locate the appropriate information easily. But of cause, this approach seems to come to fail if no automatic computation of the graphical representation of the information network can be used. The tedious and time consuming work of manually arranging the information network on the display leads to a rejection of this promising approach by the user.</p><p>In the following, a layout system is introduced which assists the user in retrieving information by generating a representation of the information structure. At first, a model for the task of searching for information with a tool is presented that supports the automatic layout of the information network. Second, the requirements for a layout system are elaborated. At last, the systems CraphADL (graph browser) and HyperADL (hypertext editor) are introduced and the used layout algorithms are described in detail. It has to be accentuated that the focus of our research is on the development of generally applicable layout algorithms rather than on implementing powerful systems for information retrieval.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Modelling the user hehaviour in searching information</head><p>Let us now assume that layout algorithms exist and let us take a look at the user who works with a tool for information retrieval which supports automatic generation of graphical representations of the information network. In our opinion, the task for a user of finding specific information can be divided into two parts, namely 0 getting the orientation within the information and = working with a selected set of information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Getting the orientation in the information network</head><p>During the first task the user learns the structure of the network by browsing through it. He learns the position of individual nodes of information and how to reach them. It is typical for the first task that the structure of the currently visited part of the network -and therefore the structure of its representing graph -is often changed. The changings can be very small, for example by adding one single node to the display, or they can result in a totally new set of information. For this task of selecting the currently visited information we use the term information$lter. In the graphical representation the nodes are small compared to the placement areai.e. the computer display -in order to give a comprehensible display of the structure of the information. An example of a representation of a selected set of information is shown in figure 2. And because of the small size of the nodes, their contents of information can only be described roughly by some words or specific graphical representations. Therefore, once the user has found a currently appropriate information set, he has to read the contents of the nodes more Thoroughly. At this point the second phase begins.</p><p>2.2. Working with a selected set of information.</p><p>In the second task the set of currently selected information remains constant but the user sets his focus on different nodes in order to read their contents. Therefore, the size of the nodes has to be enlarged. To avoid overlappings or hidings of some nodes behind others, the remaining nodes have to be pushed aside or have to be shrinked according to the between indiviudal information nodes   increased size of the chosen node. When the user sets his focus on another node, the previous node has to shrink again in order to allow the enlargement of the new node. Furthermore, it is possible that the user sets the focus on several nodes at the same time. This has to lead to an appropriate enlargement of the chosen set of nodes. In figure 3 two possible views of the selected set of information are displayed. The user can read the contents of the enlarged nodes, still keeping the orientation in the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.3, Displaj layout versus fisheye views</head><p>Assuming a graphical representation (i.e. layout) of the global information network exists, the first intuitive approach to generate different views emphasizing currently interesting information might be to use fisheye views. A fisheye view of a graph displays an area of interest quite large and in detail and shows other areas successively smaller and in less detail. It achieves this smooth integration of local detail and global context by repositioning and resizing elements of the graph [12], <ref type="bibr">[13]</ref>. Main profits of this approach are: each object is visible and the layout topology is maintained in different subsequent views. Furthermore, the computation of a fisheye view is fast and the generation of a new view can be animated on the screen leading to maintaining the orientation of the user in the display. However, a fisheye view of a small graph (up to 10 nodes) does not seem to be useful and there is only one focus that specifies the center of the enlarged information. Additionally, each object is reshaped and resized by the same function, therefore different shapes and sizes can not be visualized on the screen at the same time.</p><p>As an example for the limitations of the fisheye view approach, a layout of a small graph is shown left hand in figa) original layout ure 4. Let us assume that the user is interested in the contents of the node, that is, the object information should be displayed more detailed. A possible layout is shown right hand in the figure. The nodes have different shapes and sizes according to the contents of information. It is obvious that such a layout can not be generated by a fisheye view but has to be newly computed by a layout system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Requirements for a layout system</head><p>A system that will automate the layout process must have some essential capabilities that are decisive for an efficient work:</p><p>Flexibility and adaptability: different users might prefer different layout characteristics. As a simple example, one user prefers layout with as less as possible crossings of edges that may result in long edges, another user prefers short edges whereas he might accept more crossings of edges. Furthermore, different sets of information structures might be represented by different layout characteristics (example: schematic versus binary tree).</p><p>Constraint handling: we assume that, even if the automatic layout generates intelligibly arranged layouts (regarding some aesthetic criteria), the user must have the possibility to control the result. That is, he might set attributes so that a specific window does not change its place or that it is placed always on the right side. Therefore it is necessary that the layout system can regard simple constraints that have to be guaranteed during layout computation. Surely, given constraints might lead to less optimal layouts regarding the aesthetic criteria. However, the layout system has to compute layouts as well as possible taking the given constraints into account. It should be the task of the b) new view <ref type="figure">Figure 4</ref>: The generation of the right layout can not be generated by a fisheye view because each object is resized and reshaped in a different way.</p><p>user to remove some constraints if the results are not pleasing enough.</p><p>Topological consistency: browsing in a graph layout can lead to frequent modifications in the layout, for example some information will be removed, some other will appear or the representation (size, form) of a displayed information will change on the screen. With a simple deterministic layout algorithm, each time a complete new topology of the layout would be computed. The user has to learn the layout again and again although the displayed information is only changed slightly. Therefore, it is a decisive requirement for a layout system to guarantee the topological consistency in a sequence of display layouts. Obviously, this requirement could also be named by the term ,,geometric consistency" as it handles geometric properties of objects. However, we use the term topological consistency, because it expresses the meaning of the relative object locations and representations better than the term geometric consistency.</p><p>Layout animation: let us assume that a user works with a layout system and is reading the current layout. Then, subsequent to a user interaction, a new layout has to be computed. Now, it seems to be better to give the user an animation of the layout process than to confront him immediately with a new layout. With an animation of the layout computation, the user can learn the layout while it is computed and he can go on with his work immediately after the new Payout is completed.</p><p>Hierarchical structure: furthermore, a system for computing display layouts has to be capable to compute layouts of hierarchical graphs. That is, some nodes can be placed on top of other nodes although they can have interrelations to other nodes in other hierarchical structures as well. In fact that is not necessary for all applications but, as an example, to be capable to visualize the hierarchical structure of a circuit schematic or finite state machine, might lead to promising possibilities in browsing in these types of layouts.</p><p>Computation time: at last, the computation time has to be less than a second to permit efficient user work. But regarding the increasing performance of personal computers we currently extenuate this requirement to a time within the range of a few seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Our approach: combinatorial optimization</head><p>Although there are many experiences in the research area of graph layout [l] and although there are many matured tools for computing graph diagrams (like <ref type="bibr">[5], 191, [ 111)</ref> these approaches do not seem to be adequate to the problem of display layout. As the main difference, in most of the graph layout systems the size of the nodes is taken as relatively small compared to the placement area <ref type="bibr">[2]</ref>. But especially in the second task, nodes with very different node sizes have to be handled. Rnthermore, most of the graph layout algorithms compute layouts according to either implicit or to a limited number of characteristics. Here, the layout characteristics have to be controllable in a wide range by some parameter.</p><p>A related research area in which also objects with very different sizes have to be placed on a placement area regarding different objectives, is the VLSI chiplayout <ref type="bibr">[6]</ref>. Here, combinatorial optimizations are often used for layout computations <ref type="bibr">[7]</ref>. And because of the good experience which have been made in this area, we use them as our approach for the display layout computation.</p><p>A combinatorial optimization problem [7] consists of a countable set of valid solutions S = {so, . . . . s,,) and a cost (or objective) function c (s) that returns the cost or quality of an element si. The aim is to find a solution s' with a cost less or equal than all other elements si or -in heuristic approaches -a ,,good" solution in a reasonable amount of time. In the combinatorial optimization, the cost function is responsible for the resulting layout characteristic whereas the algorithm is responsible for the score of the solution and the used computation time. The essential profit of this approach is the flexibility and adaptability by using only different cost functions to emphasize different layout characteristics in the layout result [8].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Layout algorithm for the orientation phase</head><p>The task of the layout algorithm for this phase is to compute a layout that is clearly arranged considering the given objective function. In our approach we use combinatorial optimization algorithms that improve a given initial layout by modifying it according to the objective function. To achieve the required short computation time, we define in a first step a hierarchical raster with a size adjusted to the number of nodes and to the x-/y-dimension of the screen size. Then, the size of each node is normalized to the raster size leading to a nonoverlapping layout. Both, the coarse raster and the fixed node size lead to a drastically reduced number of possible layouts and therefore to a reduced computation time. At last, the objective function could be simplified because homogeneous distribution is ensured by the coarse raster.</p><p>A well known general combinatorial optimization algorithm is the simulated annealing algorithm <ref type="bibr">[lo]</ref>. We use it for our approach because its mode of work is already examined thoroughly. It melts a random system -in our case a random layout -at a 'high' temperature and then lowers the temperature in small steps. In each iteration step it tries to improve the layout depending on the given objective function. The improvements are achieved by movements of nodes. The temperature determines how far an element may move and how much the quality of the current solution may be (temporarily) reduced. The algorithm terminates by reaching a precalculated estimated optimum of the objective function or by reaching a given limit of computation time. The given constraints are regarded by computing a valid initial layout by a simple deterministic constraint solver and by checking each node movement whether it leads to a valid solution or not.</p><p>Although the simulated annealing is known as a very time consuming algorithm, it computes acceptable layouts in an acceptable amount of computation time (within the range of seconds for a layout consisting up to 50 objects). At last, it has to be annotated that the algorithm can be replaced by any other combinatorial optimization algorithm.</p><p>An essential task for computing a comprehensible layout is the examination and implementation of an objective function to evaluate the quality of a computed layout <ref type="bibr">[15]</ref>. Because the optimization algorithms improve a layout relying on the evaluation of the objective function, it is decisive to get an intelligibly arranged layout. In our approach we have first defined several functions to evaluate obvious characteristics of a good layout that will be summed up to the objective function.</p><p>Considering the problem of topological consistency, we divided the objective function into two parts that are the static and the dynamic one. Whereas the elements of the static part evaluate characteristics of a single layout, the elements of the dynamic part rely on characteristics between succeeding displays. We implemented five elements to evaluate characteristics of the static part of the objective function. These are a) total edge length, b) number of edge crossings, c) homogeneous distribution, d) visibility of nodes and e) preferred edge direction.</p><p>To quantify the dynamic part of the objective function, we implemented two elements: a) absolute changes between each node location in subsequent layouts and b) differences in the relative placement of each pair of nodes in subsequent layouts</p><p>The complexity of the objective function is essential for the computation time. For a graph with approximately 10 -20 nodes it is called several thousand times during the computation process. Therefore it is necessary to be very careful in designing the objective function. In our practical work, we use mainly the static attributes of edge length (and edge direction) and the dynamic attribute of absolute changes to compute a layout. These attributes can be calculated easily because with changing one element of the graph, only the value of the affected elements has to be corrected during the calculation of the objective function. However, each user can choose and assign his own set of aesthetic criterias he considers to be important for a ,,good" layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Reading the currently displayed information</head><p>Once the user has selected the appropriate set of information for his current purpose, he has to enlarge individual nodes for reading their contents. To initiate this, the user can set explizit values for the node attribute desired size. According to its name, this attribute expresses the desired size of a node on the screen. That is the size of the node which will be taken if no overlap of nodes occurs. The user can set this attribute by pressing the mouse button while pointing to a specific node. This leads to a new panel that appears on the display. In this panel, different values can be chosen by pressing the mouse button again and applying the new values to the node. Subsequently to the assignment of a new value a layout computation is started. The layout is changed incrementally in order to achieve the specific node size. If it has to be enlarged, this could result in moving other nodes apart or shrink their size. If it has to be shrinked, this could result in enlarging other nodes depending on their value of the attribute desired size. The attribute is called desired size because it can be possible that no solution can be found for the given sizes. For example, let us assume that a user has assigned the value two-third of the display area as the attribute desired size for two nodes. Then, computing a layout with nonoverlapping nodes is impossible while looking at the assigned desired sizes. In this case, the nodes should have get a size according to their relative value of the desired size compared to each other. Therefore we named this attribute the desired size, i.e. the size the user wishes to be assigned to the node by the placement algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Layout algorithms for the reading phase</head><p>In this phase we use an extended force directed algorithm called pfalgorithm (pressure-force) to improve the layout quality according to the attributes of the desired size. Therefore, the main task of this algorithm is to introduce different node sizes while maintaining the distribution of nodes on the display area and their relative locations.</p><p>Within the traditional force directed algorithm, the edges of the graph are mapped to strings that are set between the nodes. The force between two nodes connected by (an) edge(s) results in the spring constant (e.g. number of edges) times the distance between the nodes. The nodes are moved iteratively in order to reduce the forces between the nodes. An implementation of this algorithm for graph layout is described in <ref type="bibr">Eades [3]</ref> and Fruchterman and Reingold <ref type="bibr">[4]</ref>. Here, attractive and repulsive forces (to prevent a contraction into one point) are used to compute a graph layout.</p><p>Considering the problem of altering node sizes for an efficient use of the placement area that could result in enlarging and I or reducing some nodes or in reducing some nodes to enlarge others, additional functionality has to be introduced. To solve this problem, the terms irkfe pressure and outside pressure have been defined. The basic idea is that a node with an inside pressure larger than the outside pressure enlarges its size until both pressures have the same value.</p><p>The algorithm starts with the calculation of forces and pressures effected on each node during the initialization phase. Within the main iteration loop, the system is improved at first by moving a node and secondly by altering the size of a node. The node to be moved is determined by searching for the node with the largest force effected on. Once it is found, an incremental move in order to lessen the force is executed. The length of the move is given by a user defined parameter adjusted to the size of the actual system. In a similar mode of operation the node to alter its size is found. Here, the result of the substraction of outside pressure and inside pressure is calculated for all nodes. The node with the maximal sum is searched and depending on the sign of the result its size is enlarged or reduced. Again, the factor for changing the size is given by the user. The main iteration impression of a continuous tlow \ of objects stops when a given amount of iterations is reached or the improvement between subsequent iterations remains under a given limit.</p><p>In <ref type="figure" target="#fig_3">figure 5</ref> an example for the layout computation is shown. The animation of the layout process is illustrated by three snapshots that are taken during the layout computation. It seems to be obvious that this kind of layout animaa) Loading a hypertext. c) I-Iiding two cards. e) Selecting an additional card. tion can assist the user essentially in maintaining the orientation in the information display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Further application: HyperADL</head><p>HyperADL is a tool for editing and reading hypertexts. Because we focus on the examination of algorithms for dis-  play layout, the functionality of this tool is quite simple compared to other hypertext systems. Loading a hypertext, the root card is displayed in the center of the main window. Links are marked with the signs ,,I&gt;" and ,,&lt;I", respectively. The clicking of the mouse button while pointing on the text between the marked signs will open the assigned card and display it with its own links on the left window. Using the mouse again, the user can follow new links. Superfluous windows are closed by clicking the ,,hide"-button on the frame of the card. Simple filters are also implemented. For example, it is possible to look for all cards links within the actual card points to or to open all cards with links to the actual card. For using HyperADL as a source file editor, the root textual window has a special filter called combine to linearize the total source code for compiling.</p><p>An example for a sequence of layouts while working with the tool HyperADL is shown in <ref type="figure" target="#fig_5">figure 6</ref> a-e. The first screendump shows the screen after loading a hypertext. Only the root card of the hypertext is shown in the center of the screen (a). Then the user looks for all cards that could be reached by the root card (b). After that he hides some cards (c) and selects one card as being of interest resulting in a larger window size (d). After reading the card the user selects a second card and assigns new desired shapes for some other cards, resulting in layout (e).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conch&amp;on</head><p>As a major step towards an improved user interface for an information processing system, we identified automatic display layout for graphical information representation. We present our approach to compute a layout of an information structure according to the two phases in user search. In the first phase a raster based layout is computed with small node sizes in order to give a comprehensible display of the information structure. As the layout algorithm, we use a simulated annealing optimization algorithm. Then, in the second phase, some nodes are enlarged according to user interactions. But to guarantee the visibility of all nodes, others have to be shrinked. For this phase we use a pf-Algorithm (force directed algorithm with an additional pressure part). Because of the incremental mode of operation of this algorithm, its process of computation can be displayed on the screen to give the user the impression of a contitrnuous flow of objects.</p><p>The main profits of our approach are at first the flexibility because the resulting layout characteristic can be easily controlled by the cost function and secondly the continuous flow of objects which gives the user a very good support in maintaining the orientation in the display layout. The computation times are within the range of seconds for typical screen contents (about 20 objects) on a SparcStation 20; these data show that real-time execution is possible in next generation's personal computers. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Graphical representation of a part of a network of interrelated information.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Graphical representations of two different selected sets of the network shown in figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>For reading the information of some nodes, their sizes have to be enlarged drastically. In this figure two different views of the selected information network shown on the left side in figure 2 are displayed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Redrawing the temporary layout within each iteration of the force directed algorithm results in the impression of a continuous flow of objecfs (top left to bottom right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>.</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>A sequence of display layouts while working with the hypertext editor HyperADL.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the Proceedings on Information Visualization (INFOVIS '95) 0-8186-7201-3/95 $10.00 Â© 1995 IEEE</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Algorithms for Drawing Graphs: an Annotated Bibliography, anonymous ftp from wlima</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuseppe</forename><forename type="middle">Di</forename><surname>Battista</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Tamassia Und Ioannis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tohis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
	<note>cs.brown.edu</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isabel</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Tamassia</surname></persName>
		</author>
		<ptr target="WWW:ht-tp:Nwww.cs.brown.edu/calendar/gd94" />
		<title level="m">How to Visualize a Graph: Specifications and Algorithms</title>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Heuristic for Graph Drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Congressus Numerantium</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">M</forename><surname>Fruchtermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Reingold</surname></persName>
		</author>
		<title level="m">Graph Drawing by Force-directed Placement, Software -Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1129" to="1164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualizing Abstract Objects and Relations</title>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernest</forename><forename type="middle">S</forename><surname>Kuh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tatsuo</forename><surname>Ohtsuki</surname></persName>
		</author>
		<title level="m">Recent Advances in VLSI-Layout, Proceedings of the IEEE</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="37" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Lengauer</surname></persName>
		</author>
		<title level="m">Combinatorial Algorithms for Integrated Circuit Layout</title>
		<imprint>
			<publisher>Teubner -John Wiley</publisher>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Improvement of the User Interface of Multimedia Applications by Automatic Display Layout, Multimedia Computing and Networking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Ltiders</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolf</forename><surname>Ernst</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-02" />
			<biblScope unit="page" from="5" to="10" />
			<pubPlace>San Jose, Califomien, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frances</forename><surname>Newberry-Paulisch Und</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walter</forename><forename type="middle">F</forename><surname>Tichy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software -Practice and Experience</title>
		<editor>EDGE: An Extendible Graph Editor</editor>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="63" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H J M</forename><surname>Otten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">P P P</forename><surname>Van Ginneken</surname></persName>
		</author>
		<title level="m">The Annealing Algorithm</title>
		<imprint>
			<publisher>Kluwer Academic Press</publisher>
			<biblScope unit="page">989</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">A Browser for directed Graphs, Software -Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><forename type="middle">A</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eli</forename><surname>Messinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Spirakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Tuan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="61" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
		<title level="m">Graphical Fisheye Views, Communications of the ACM</title>
		<imprint>
			<date type="published" when="1994-12" />
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="page" from="73" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Ben Shneiderman: Designing the User Interface, Strategies for Effective Human-Computer Interaction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Greenberg</surname></persName>
		</author>
		<idno>#Z/491/29</idno>
		<imprint>
			<date type="published" when="1987" />
			<publisher>Addison Wesleey</publisher>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Calgary</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech Report</note>
	<note>Comparing Fisheye and Full-Zoom Techniques for Naviagtion of Hierarchically Clustered Networks</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Automatic Graph Drawing and Readability of Diagrams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guiseppe</forename><surname>Di Batista</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlo</forename><surname>Batini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Systems, Man and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="61" to="79" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
