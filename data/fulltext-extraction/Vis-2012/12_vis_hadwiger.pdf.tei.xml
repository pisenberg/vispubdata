<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.1" ident="GROBID" when="2016-09-09T15:01+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Volume Exploration of Petascale Microscopy Data Streams Using a Visualization-Driven Virtual Memory Approach</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Markus</forename>
								<surname>Hadwiger</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Johanna</forename>
								<surname>Beyer</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Won-Ki</forename>
								<surname>Jeong</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Hanspeter</forename>
								<surname>Pfister</surname>
							</persName>
						</author>
						<title level="a" type="main">Interactive Volume Exploration of Petascale Microscopy Data Streams Using a Visualization-Driven Virtual Memory Approach</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index Terms—Petascale volume exploration</term>
					<term>high-resolution microscopy</term>
					<term>high-throughput imaging</term>
					<term>neuroscience</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Our system is the first to enable neuroscientists to interactively explore petascale volume data resulting from high-throughput electron microscopy data streams. The volume can be visualized while the acquisition is still in progress, and without pre-processing all data into a 3D multi-resolution hierarchy as required by all previous systems. Shown here: 21, 494 ⇥ 25, 790 ⇥ 1, 850 mouse cortex. Abstract—This paper presents the first volume visualization system that scales to petascale volumes imaged as a continuous stream of high-resolution electron microscopy images. Our architecture scales to dense, anisotropic petascale volumes because it: (1) decouples construction of the 3D multi-resolution representation required for visualization from data acquisition, and (2) decouples sample access time during ray-casting from the size of the multi-resolution hierarchy. Our system is designed around a scalable multi-resolution virtual memory architecture that handles missing data naturally, does not pre-compute any 3D multi-resolution representation such as an octree, and can accept a constant stream of 2D image tiles from the microscopes. A novelty of our system design is that it is visualization-driven: we restrict most computations to the visible volume data. Leveraging the virtual memory architecture, missing data are detected during volume ray-casting as cache misses, which are propagated backwards for on-demand out-of-core processing. 3D blocks of volume data are only constructed from 2D microscope image tiles when they have actually been accessed during ray-casting. We extensively evaluate our system design choices with respect to scalability and performance, compare to previous best-of-breed systems, and illustrate the effectiveness of our system for real microscopy data from neuroscience.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p> Recent advances in high-resolution microscopic imaging result in volume data of extreme size. In neuroscience, electron microscopy (EM) volumes of brain tissue are produced by physically cutting very thin sections of about 25–50 nm, and imaging each section at 3–5 nm pixel resolution <ref type="bibr" coords="1,69.68,524.39,9.52,10.80" target="#b3">[4]</ref>. This resolution is necessary in order to be able to trace neural connections in the area of Connectomics <ref type="bibr" coords="1,207.86,534.35,9.71,10.80" target="#b3">[4,</ref><ref type="bibr" coords="1,220.35,534.35,10.65,10.80" target="#b22"> 23]</ref>, which is the main target domain of the visualization system presented in this paper. However, even sub-millimeter tissue blocks imaged at such resolutions comprise terabytes of raw data, and neuroscientists target much larger volumes of several petabytes. A further complication is the acquisition time itself. Measuring a single terabyte of data, even by using fully automated Scanning Electron Microscopes (SEM), may take half a week <ref type="bibr" coords="1,321.94,483.53,9.52,10.80" target="#b3">[4]</ref>. As neuroscientists strive to measure large blocks of brain tissue to enable the analysis of brain function, a high-throughput acquisition process has to continuously stream data over months or even years. In this scenario, existing visualization approaches fail. Traditional algorithms require complete knowledge of all data, for example in order to pre-compute an octree or kD tree multi-resolution representation . For high-throughput microscopy this is infeasible, since pre-processing the data into a hierarchical representation incurs an unacceptably large gap between acquisition and visualization. Therefore, it is necessary to develop novel visualization paradigms and systems in order to facilitate the interactive exploration and analysis of large-scale microscopy data streams. We have identified the following major system design goals: </p><p>(G1) Scalability to the petascale, even for dense instead of sparse data. </p><p>(G2) Accommodate high-throughput acquisition of 2D microscopic image tile streams. New image data can arrive continuously. </p><p>(G3) Visualize incomplete, incompletely registered, and changing data. Image alignment information can be updated dynamically. Data can be re-imaged dynamically with different parameters. </p><p>(G4) Accommodate highly anisotropic (e.g., 1:10) data. </p><p>(G5) Avoid pre-computation that requires knowledge of all data. </p><p>(G6) Avoid computation and storage for data that are not visible in the visualization as much as possible. This paper introduces the first visualization system that fulfills these goals, enabling the interactive exploration of petascale microscopy data streams. Our system combines the following contributions: @BULLET A novel visualization-driven paradigm for out-of-core volume construction and visualization. Only visible 3D volume blocks are constructed from the raw 2D image data (G1, G2, G5, G6). @BULLET A novel multi-resolution virtual memory scheme, where all data comprise a virtual multi-resolution volume, naturally handling missing data and dynamic updates (G2, G3). Our architecture achieves scalability via a multi-level page table hierarchy (G1). It naturally accommodates highly anisotropic data (G4), in contrast to an octree that would become unbalanced and less efficient. </p><p> @BULLET Visible image data are resampled directly into the resolution required for visualization, avoiding the pre-computation of a 3D multi-resolution hierarchy (G5, G6). This visualization-driven pipeline is enabled by a GPU-based raycaster that detects visible data in virtual volume space, generating cache misses for missing physical data. These cache misses are then propagated backwards to construct, fetch, and cache only visible data. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Our system is related to a lot of prior work, and we can only highlight the most important connections here. Our visualization stage uses GPU volume ray-casting <ref type="bibr" coords="2,115.98,475.19,13.74,10.80" target="#b19">[20]</ref>, which has become the most common approach for GPU volume rendering. However, GPU volume renderers are often restricted by GPU memory size. In order to accommodate large volumes, out-of-core and multi-resolution approaches have been developed. LaMar et al. <ref type="bibr" coords="2,131.59,515.04,14.94,10.80" target="#b20">[21] </ref>and Weiler et al. <ref type="bibr" coords="2,211.04,515.04,14.94,10.80" target="#b29">[31] </ref>were among the first to use hierarchical octree bricking schemes for hardwareassisted volume rendering. Other hierarchical approaches were proposed by Boada et al. <ref type="bibr" coords="2,101.56,544.93,10.45,10.80" target="#b2">[3] </ref>and Guthe et al. <ref type="bibr" coords="2,173.14,544.93,13.74,10.80" target="#b10">[11]</ref>, who use a hierarchical wavelet representation and screen-space error estimation for LOD selection . All previous multi-resolution volume renderers require the multi-resolution hierarchy to be built in a pre-process, which is not feasible for our scenario of dynamically streaming image data. A preprocessing step is also required by all previous systems that support streaming of volume data for progressive rendering, such as the ViSUS system <ref type="bibr" coords="2,49.35,614.66,13.74,10.80" target="#b26">[28]</ref>. The ImageVis3D/Tuvok system <ref type="bibr" coords="2,181.90,614.66,14.94,10.80" target="#b18">[19] </ref> supports both slicedbased volume rendering and ray-casting. Large data are subdivided using a kD tree, which is also exploited for distributed rendering <ref type="bibr" coords="2,260.18,634.59,9.52,10.80" target="#b7">[8]</ref>. Each brick in the tree is rendered in one rendering pass. There is relatively little published work on single-pass GPU octree ray-casting. Gobbetti et al. <ref type="bibr" coords="2,77.62,664.48,14.94,10.80" target="#b9">[10] </ref>determine the potential visibility of octree nodes together with the corresponding partial tree on the CPU, which is then downloaded to the GPU. Octree traversal on the GPU follows explicitly stored rope links between adjacent nodes. Actual visibility is only taken into account in an indirect manner by using occlusion queries. Octree traversal without rope links is usually performed by adapting kD tree traversal algorithms to octrees <ref type="bibr" coords="2,162.95,724.25,9.71,10.80" target="#b5">[6,</ref><ref type="bibr" coords="2,175.12,724.25,6.47,10.80" target="#b6"> 7]</ref> , most of which were developed for ray-tracing geometry <ref type="bibr" coords="2,143.82,734.22,9.71,10.80" target="#b8">[9,</ref><ref type="bibr" coords="2,155.88,734.22,11.21,10.80" target="#b25"> 27,</ref><ref type="bibr" coords="2,169.44,734.22,11.95,10.80" target="#b14"> 15] </ref>or iso-surfaces <ref type="bibr" coords="2,238.64,734.22,13.74,10.80" target="#b16">[17]</ref>. The visualization stage of our system performs single-pass ray-casting, detecting the visibility of small blocks on-the-fly. This is also done by the Gigavoxels <ref type="bibr" coords="2,340.98,251.14,10.45,10.80" target="#b5">[6] </ref>and CERA-TVR <ref type="bibr" coords="2,412.56,251.14,10.45,10.80" target="#b6">[7] </ref> systems. In contrast to our virtual memory scheme, however, these systems perform explicit octree traversal using the kd-restart algorithm <ref type="bibr" coords="2,428.12,271.07,9.52,10.80" target="#b8">[9]</ref> . The data resolution is refined or coarsened by iteratively changing the set of nodes/bricks that are resident in node/brick pools stored in GPU memory. This requires holding the entire path from every leaf to the root in GPU memory, and can result in large numbers of updates per frame. Our system avoids both of these drawbacks. Detailed comparisons of our system with the approaches of these systems are given in Section 8. Clipmaps <ref type="bibr" coords="2,520.56,330.84,14.94,10.80" target="#b27">[29] </ref>are an approach for rendering very large mipmaps that essentially also uses a virtual memory space. However, clipmaps have to use a fixed toroidal updating scheme. In contrast, our architecture can address small 3D blocks that are packed arbitrarily into a larger cache texture. This packing is similar to adaptive texture maps <ref type="bibr" coords="2,455.09,380.66,13.74,10.80" target="#b17">[18]</ref> , but with fully dynamic updates. Virtual 2D texturing approaches have been proposed for adaptive shadow map rendering <ref type="bibr" coords="2,413.38,400.58,13.74,10.80" target="#b21">[22]</ref>, as well as for state-of-the-art game engines <ref type="bibr" coords="2,337.08,410.55,13.74,10.80" target="#b28">[30]</ref> . In contrast to our system, these approaches combine virtual memory management with a tree structure. Another class of large-scale volume rendering systems is purely CPU-based, in order to avoid GPU memory limitations altogether. Much research has been devoted to volume rendering on large supercomputers <ref type="bibr" coords="2,477.98,450.40,9.71,10.80" target="#b4">[5,</ref><ref type="bibr" coords="2,489.59,450.40,11.21,10.80" target="#b15"> 16,</ref><ref type="bibr" coords="2,502.70,450.40,10.65,10.80"> 26]</ref>. This is especially useful in the context of in-situ visualization of large-scale simulations, where the visualization is computed on the same machine as the data, avoiding the need to move large data. However, this is not a feasible approach for microscopy data. Our data streams do not originate from large-scale simulations, but from acquisition setups that are not directly connected to a supercomputer. Our system streams data to the GPU-based visualization, but only as required by actual visibility. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SYSTEM OVERVIEW</head><p>Figure 2 depicts an overview of our system. Although image data propagate from left to right, the majority of the pipeline (<ref type="figure" coords="2,493.05,564.04,19.60,10.80" target="#fig_0">Fig. 2</ref>, right half) is visualization-driven by the actual visibility of small 3D blocks (32 3 voxels) determined during ray-casting, which is propagated from right to left. After introducing basic terminology, we give an overview of each pipeline stage from left to right. The subsequent sections then discuss each stage in reverse order, following the visualization-driven nature starting on the right with visualization and going backwards. Terminology. Our system is inspired by standard virtual memory architecture <ref type="bibr" coords="2,330.42,644.55,13.74,10.80" target="#b12">[13]</ref> , and throughout the paper we use similar terminology (see <ref type="figure" coords="2,318.05,654.51,19.96,10.80">Fig. 3</ref>). We virtualize 3D volumes by subdividing them into small 3D blocks (e.g., 32 3 voxels). Only the working set of currently required blocks is resident in a large 3D cache (texture), which is updated dynamically. The original volume becomes a virtual volume that is accessed via a page table: a 3D index texture where each voxel is a page table entry that maps the corresponding block's position in the cache, or is flagged as unmapped, i.e., not resident in the cache. The same approach can be used to virtualize page tables, referring to the top-level page table in the resulting hierarchy as the page directory. <ref type="figure" coords="3,31.50,227.30,19.06,9.87">Fig. 3</ref>. Virtual memory architecture and visualization-driven pipeline. A virtual multi-resolution volume comprises a hierarchy of resolution levels`(levels` levels`(left, horizontal), each of which is virtualized via a hierarchy of page tables (vertical). Ray-casting accesses virtual multi-resolution addresses (`, p) (center right), performing on-the-fly translation to addresses in the block cache via the multi-resolution page directory and the page table cache (center left). Accesses to blocks in virtual memory that are unmapped, i.e., not mapped to a cache block, generate cache misses (center right). These enable visualization-driven construction of volume data (right), as well as updating page table cache and block cache only for visible blocks. Data acquisition (Section 7). The microscope deposits each acquired image tile (e.g., 12, 000 ⇥ 12, 000 pixels) into the acquisition archive. This archive stores the acquired raw data together with additional meta information including magnification, position, and orientation (the alignment matrix) of acquired image tiles, and is either co-located with the microscope or is a central shared file system. Raw tile processing (Section 6). This stage continuously polls the acquisition archive for new image tiles, and automatically processes each new tile for storage in the visualization archive. This can be the same actual storage used for acquisition, but for organizational reasons it is often better to separate the two archives. Processing comprises construction of a 2D mipmap for each tile, subdivision of each mipmap level into smaller sub-tiles for optimized disk access, and optional image compression. Each new raw image tile is processed immediately, independent of tile registration/alignment and visualization. Registration. Computing the alignment of raw image tiles is an independent component outside the scope of this paper that asynchronously updates the alignment matrices associated with raw image tiles. However, in order to facilitate coarse-to-fine registration, this component can access the 2D tile mipmaps stored in the visualization archive. No image data are changed by registration. Actual stitching of tiles is performed only on-demand in the volume construction stage of our pipeline. Updates of alignment matrices are picked up by the input stage of raw tile processing and are propagated forward. Visualization-driven volume data construction (Section 5). This stage is driven entirely by the visualization stage, which requests voxel data for visible 3D blocks from a resolution level matching the current display resolution. In order to fulfill these requests, first all 2D image sub-tiles that intersect the 3D target block are determined and fetched. The requested 3D voxel data are then created by stitching and resampling these 2D sub-tiles directly into the 3D target grid and resolution. Stitching is determined by the alignment matrix associated with each image tile. Fast stitching and resampling to any target resolution is facilitated by the 2D tile mipmaps stored in the visualization archive. Visualization (Section 4). The visualization component of our pipeline performs GPU-based ray-casting. However, its design differs from previous systems in several important aspects. Instead of creating and traversing a tree structure—such as an octree or a kD tree— our system employs a multi-level, multi-resolution virtual memory architecture (<ref type="figure" coords="3,73.61,674.44,20.81,10.80">Fig. 3</ref>) that scales well to extremely large volume sizes. Volume space comprises a virtual multi-resolution volume that is sampled directly during ray-casting (Section 4.2). Missing data generate cache misses at the granularity of small 3D blocks, which by definition are visible data. These cache misses generate requests for data that are propagated backwards in the pipeline, triggering the visualizationdriven construction of volume data from 2D image tiles (Section 5). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multi-Resolution Page </head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">VISUALIZATION</head><p>The visualization stage of our pipeline has been designed to operate in a fully virtualized volume space, which is a crucial design goal of our system. We achieve this by considering the 3D bounding box of the tissue block to be imaged to comprise a virtual multi-resolution volume. This structure is similar to a virtualized 3D mipmap. However, the down-sampling ratio between successive resolution levels can be different for each axis in order to accommodate anisotropic voxel aspect ratios. We access this virtual volume space via an efficient multi-level, multi-resolution virtual memory management architecture. Compared to a traditional octree or kD tree multi-resolution representation, using a virtual multi-resolution volume has the following main advantages: @BULLET It is more efficient for deep resolution hierarchies. No tree traversal is required, and no tree structure needs to be maintained. Maximum efficiency is achieved for any desired resolution when all visible data of that resolution are resident in the cache. Rendering arbitrary slices also becomes a straightforward operation. </p><p>@BULLET Any sample can be fetched directly from any resolution level. This enables jumping between resolutions without constructing intermediate lower resolutions, which greatly helps to reduce the latency incurred by on-demand volume construction (Section 5). @BULLET The down-sampling ratio between resolution levels can be arbitrary . For the anisotropic voxel aspect ratios of most EM data, this avoids the problem of an octree becoming unbalanced when the resolution is not decreased along all three axes in every level. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Virtual Multi-Resolution Volume Representation</head><p>In order to determine a 3D reference space for our entire pipeline, the extents of the 3D tissue block to be imaged are queried from the electron microscope at startup. This space then constitutes virtual volume space, which is addressed via normalized floating-point coordinates p = (x, y, z) 2 <ref type="bibr" coords="3,346.86,608.71,9.45,8.97">[0,</ref><ref type="bibr" coords="3,357.31,607.15,6.97,10.80" target="#b0"> 1] </ref>3 . Furthermore, this space is extended to form a virtual multi-resolution volume by introducing a hierarchy of resolution levels (<ref type="figure" coords="3,337.31,627.08,21.00,10.80">Fig. 3</ref>left, horizontal). This facilitates addressing voxels of a desired size via a virtual multi-resolution address (`, p), where the integerìsintegerìs the resolution level. During ray-casting, samples are fetched at positions (`, p), computing`fromcomputing`computing`from the desired level of detail (Section 4.2). However, before actual voxel data can be accessed, (`, p) must be translated to a coordinate in cache (texture) space, which is done on the fly using a hierarchy of page tables (<ref type="figure" coords="3,474.37,686.85,20.12,10.80">Fig. 3</ref>left, vertical). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Resolution Hierarchy</head><p>The virtual multi-resolution volume is comprised of discrete resolution levels, from`=from`from`= 0 (highest resolution) tò = ` max (coarsest resolution). <ref type="figure" coords="3,294.12,734.22,20.46,10.80">Fig. 3</ref> (left) depicts this hierarchy horizontally. In contrast to a mipmap or an octree, our hierarchy does not enforce a fixed down-sampling ratio between levels. Every resolution level can be imagined as comprising its own volume in the normalized <ref type="bibr" coords="4,156.15,72.66,9.45,8.97">[0,</ref><ref type="bibr" coords="4,166.59,71.10,6.97,10.80" target="#b0"> 1] </ref>3 volume space, but without constraining the amount of voxels to be any particular fraction of the next finer level. Addressing any voxel via a normalized coordinate p is straightforward when the resolution of each level in voxels is known. Being able to choose an arbitrary resolution for each level enables arbitrary resolution reduction between levels. This would also facilitate the efficient representation of sampled scale space, such as with a hybrid pyramid scheme <ref type="bibr" coords="4,103.46,140.84,13.74,10.80" target="#b23">[24]</ref>. There, the scale parameter increases by less than a factor of two between levels, and the grid resolution is only reduced (halved) every cumulative increase of scale by a factor of two. Access to resolution levels. The volume corresponding to a leveì can be accessed by using virtual multi-resolution addresses (`, p). The access is performed via the page table hierarchy of leveì. An important trait of our architecture is that, although any leveì can be accessed directly, the only multi-resolution structure that is required to do this is the small multi-resolution page directory described below. Apart from this structure, the individual volumes comprising the resolution hierarchy are fully virtualized and only represented implicitly. Resolution reduction. We start with the full resolution, and choose each axis in the next level to be either half or the same resolution, depending on voxel anisotropy, so that anisotropy is gradually reduced. <ref type="figure" coords="4,22.50,280.93,20.86,10.80">Fig. 3</ref>(left) illustrates this, where the depicted anisotropy is 1 : 2 from {x, y} : z in`=in`in`= 0, which is reduced to 1 : 1 from`=from`from`= 1 onward. This is achieved by simply using the same resolution in z for`=for`for`= 0 and`=and`and`= 1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Page Table Hierarchy</head><p> The individual virtualized volumes comprising the resolution hierarchy described above are accessed via a hierarchy of page tables, which is depicted vertically in 37: until early ray termination or volume exit 38: end function <ref type="figure" coords="4,22.50,723.45,18.91,9.87">Fig. 4</ref>. Address translation and ray-casting. Each virtual multi-resolution address (`, p) is translated to a block cache texture coordinate on-the-fly. taining indices for addressing small voxel blocks (e.g., 32 3 ) stored in the 3D block cache (<ref type="figure" coords="4,359.52,61.14,19.37,10.80">Fig. 3</ref>, center) with a single page table entry. The block cache is implemented as a 3D texture that serves as " physical " memory in the virtual memory scheme. In addition to the index, each page table entry can be marked as either unmapped or empty (see below ). However, for very large volumes, the page table itself becomes too large. We therefore apply the basic concept recursively, obtaining a hierarchy of page tables with t levels, where all levels except the root of the hierarchy (top row of <ref type="figure" coords="4,388.92,130.88,20.22,10.80">Fig. 3</ref>, left) are also virtualized. We call this root page table the multi-resolution page directory. Multi-resolution page directory. Since the page directory is not virtualized, it is always completely resident in GPU memory. For a virtual multi-resolution address (`, p), the parameter`determinesparameter`parameter`determines which resolution level should be accessed. Each directory entry references a block of page table entries in the page table cache (<ref type="figure" coords="4,484.13,190.74,19.90,10.80">Fig. 3</ref>), which stores blocks of the same size from any hierarchy or resolution level. Page tables. Each page table entry references either another block of page table entries in the hierarchy level below it, which is then also stored in the page table cache, or a block of voxels in the block cache. The former case is only relevant if there are more than two page table hierarchy levels (t &gt; 2), i.e., more than the page directory and the page table below it. <ref type="figure" coords="4,338.73,260.56,30.14,10.80">Figure 3</ref>shows only two hierarchy levels (t = 2). Page table entry flags. Every page table entry has a flag field that can be set to either one of two special values (see also <ref type="figure" coords="4,480.53,280.56,19.76,10.80">Fig. 4</ref>): Unmapped entries correspond to blocks in the virtual multiresolution volume that are not mapped to a block in the block cache. (Mapped blocks simply have the flag cleared.) If such a page table entry is accessed during ray-casting, a cache miss is generated. Additionally , the extent of the block will either be skipped over as empty space, or a lower resolution will be selected dynamically (Section 4.2.3). The cache miss then results in a request for the volume construction stage (Section 5) to asynchronously construct the block's data. After the data have arrived at the visualization stage, the page table entry will be mapped. This resets the unmapped flag. If, however, the volume construction stage instead replies that the data for the requested block do not exist (yet), the unmapped flag will instead be changed to empty. Empty entries correspond to blocks in the virtual multi-resolution volume that are known to be empty. Blocks can be classified as empty for two different reasons: (1) The voxel data of the block are either all zero or do not exist, and will thus be classified as empty irrespective of the current transfer function. This case is reported by the volume construction stage (Section 5). (2) The block's data are available, but currently invisible (transparent) given the current transfer function . This case is identified whenever the transfer function changes. Ray-casting performs empty space skipping for empty blocks (Section 4.2.3). However, no cache miss will be reported for empty blocks, because they never need to be mapped to a block in the block cache. 4.1.3 Address Translation <ref type="figure" coords="4,285.12,532.34,30.09,10.80">Figure 3</ref>(center) illustrates the individual steps of translating a virtual multi-resolution address (`, p) to a physical address in the block cache using the page table hierarchy. The implementation is described by the pseudo code in <ref type="figure" coords="4,342.06,562.22,20.11,10.80">Fig. 4</ref>. We show this process for two hierarchy levels (t = 2), but the extension to more levels is straightforward. Due to anisotropic down-sampling, the multi-resolution page directory cannot be stored as a regular mipmap. Instead, we pack all resolution levels`2levels`levels`2 <ref type="bibr" coords="4,345.21,603.72,28.80,9.95">[0,` max ] </ref>into a single 3D texture texPageDir (<ref type="figure" coords="4,509.66,602.16,19.37,10.80">Fig. 4</ref>). The origin of each level is retrieved from a small array pageDirBase. In order to compute look-up indexes from normalized coordinates p, we use the following constants: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.4 Page Table and Cache Management </head><p>The multi-resolution page directory, the page table cache, and the block cache are each implemented with one 3D texture whose content is managed by the CPU using a standard least/most-recently used (LRU/MRU) scheme <ref type="bibr" coords="4,361.93,724.25,13.74,10.80" target="#b12">[13]</ref>. However, updates are initiated by the cache misses reported by the ray-caster (Section 4.2.2). For each cache miss, the CPU first checks if it can be fulfilled from the CPU block cache, which is simply a larger version in CPU memory of the block cache in GPU memory (<ref type="figure" coords="5,96.97,71.10,19.40,10.80" target="#fig_0">Fig. 2</ref>). If the required block is resident in the CPU block cache, it is downloaded into the GPU block cache, and the page directory and page table cache are updated accordingly. Otherwise, a request for the block of 3D volume data is issued asynchronously to the volume data construction stage (Section 5). In this case, the download of block data, as well as the corresponding page table updates, are deferred until the 3D block constructed by that stage has arrived. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Ray-Casting Virtual Multi-Resolution Volumes</head><p>The pseudo code in <ref type="figure" coords="5,103.42,157.87,20.86,10.80">Fig. 4</ref>illustrates the major parts of the ray-casting loop for a given view ray. The ray-caster marches along the ray from sample to sample, performing hierarchical address translation for each sample as described above. The sample position on the ray is given by the corresponding normalized coordinate p in virtual volume space. In order to obtain a virtual multi-resolution address (`, p), a suitable resolution leveì must be chosen. A good choice of`dependsof`of`depends on the desired level of detail, i.e., the resolution level to be sampled. Computing a floating-point level of detail value lod(p) for each sample can be done using existing strategies, e.g., estimating the projected screen space size of the corresponding voxel <ref type="bibr" coords="5,222.62,257.50,9.52,10.80" target="#b5">[6]</ref>. The integer resolution leveì can then either be determined from lod(p) by rounding to the nearest integer, and sampling a single resolution level with tri-linear interpolation, or computing the two adjacent resolution levels , sampling both, and interpolating linearly in-between. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Exploiting Spatial Coherence for Page Table Look-Ups</head><p> Many successive samples along a ray will map to the same page directory/table entries. The corresponding look-up overhead can therefore be reduced significantly by exploiting this spatial coherence. The closer a page table entry is to the root of the hierarchy (the page directory ), the less frequently it needs to be fetched. For example, for b pt = b vox = 32 and t = 2, for an axis-aligned ray the page table is accessed only every 32 voxels, the page directory every 1024 voxels. The ray-casting loop tracks the indices of the last used page directory/table entries. When the next sample along a ray maps to the same entry, the result of the look-up from the previous sample is re-used instead of fetching the entry again (see <ref type="figure" coords="5,164.60,421.14,19.53,10.80">Fig. 4</ref>). <ref type="figure" coords="5,193.33,421.14,26.90,10.80">Figures</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Cache Miss and Usage Reporting</head><p>The ray-caster reports cache misses for accessed page table entries that are unmapped. A cache miss simply consists of a block ID that uniquely identifies the voxel block that caused the miss. Depending on the desired maximum virtual volume size, this ID is either a 32-bit or a 64-bit integer. For small blocks of 32 3 voxels, 32-bit IDs are sufficient to address up to 128 teravoxels. Using 64-bit integers enables scaling up to the exascale. In our implementation, every ray tracks cache misses from front to back only up to a limit of M cache misses (e.g., M = 4). Cache misses farther back the ray are simply not reported in the same frame. This strategy not only makes cache miss reporting scalable, but it also distributes cache misses and the corresponding updates over multiple frames, which overall leads to smoother frame rates. As soon as arriving block data and the corresponding page table update fulfill a cache miss, no further miss will be reported for this block, and the next ray-casting pass will report cache misses farther back. This strategy also ensures that blocks will be updated in approximately front to back order. The list of cache misses is cleared before every frame, which prevents data requests from becoming stale. Cache miss hash tables. Each ray stores cache miss block IDs into a hash table shared with other rays, using atomic writes. We allocate one hash table for each pixel tile of size N ⇥ N in screen space (e.g., N = 64). Each hash table is implemented as an array with a fixed maximum number of entries per row. When a target row is already full, the cache miss will simply be dropped. As before, this distributes cache misses over multiple frames. Dropped misses will simply be reported in a later frame if the corresponding block is still visible. Cache usage reporting. In order to allow the LRU caching strategy to track which cache blocks are in use, the ray-caster also tracks an in use bit for every block in the block cache. The required number of bits is equal to the number of available blocks in the block cache, which is independent of the volume resolution and thus scalable. Per-frame read-back. The cache miss hash tables and the cache usage are read back from the GPU to the CPU once per rendering frame. Due to the comparatively small size, the corresponding performance impact is very small. Our current implementation reads back 300 KB of state for a screen resolution of 1024 ⇥ 1024 and a block cache size of 1 GB, which takes less than 1 ms on our test system. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Dynamic Resolution Hierarchy Traversal</head><p>Our system targets displaying volume data at exactly the desired level of detail, with respect to the display resolution, instead of substituting data of lower resolution. This goal is facilitated by being able to access any virtual multi-resolution volume address (`, p) directly. However, in the following cases, we adapt the choice of`dynamicallyof`of`dynamically. Handling unmapped blocks. When an address (`, p) is accessed whose corresponding page table entry is unmapped, we employ one of two user-selectable strategies: (1) The block is simply skipped as though it would be empty. It will be displayed as soon as the corresponding data have been constructed and the block has been mapped. </p><formula>(2) </formula><p>The resolution leveì is increased dynamically, in turn testing each successively lower resolution whether the corresponding block is mapped. The maximum number of steps for this strategy is limited to a small number k, e.g., k = 4, assuming that higher resolution reductions than 2 k do not benefit the user. This scheme greatly improves the user experience, especially during zoom-ins. On the other hand, the associated performance impact is small, because we exploit spatial coherence as described above, re-using the reduced leveì + i with i  k for all subsequent samples that map to the same page table entry. Exploiting empty blocks. For empty blocks, we maximize the amount of empty space that can be skipped with a single step as follows . If the page table entry at (`, p) is empty, coarser levels`+levels`levels`+ i are accessed iteratively from i = 1, increasing i as long as the entry at (` + i, p) is also empty. The empty space that can be skipped is then determined by`+by`by`+ i 1, which is the largest block surrounding (`, p) that is known to be empty. The performance overhead of this strategy is at most one unnecessary increase of i, because all other increases improve performance by skipping larger empty areas. Dynamic data streaming. In order to handle dynamically streaming data, the raw tile processing stage notifies all later stages whenever new data have arrived, or data have been modified, which includes the change of alignment matrices. The visualization stage then unmaps the corresponding blocks if they are mapped. They will then simply be requested again, which ensures that they contain the correct data. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">VISUALIZATION-DRIVEN VOLUME DATA CONSTRUCTION</head><p>The main responsibility of this pipeline stage (<ref type="figure" coords="5,468.87,515.67,20.38,10.80" target="#fig_0">Fig. 2</ref>, center) is the visualization-driven construction of 3D volume blocks via on-the-fly stitching and resampling when the visualization stage requests them. These requests originate from cache misses during ray-casting that cannot be fulfilled from the caches in the visualization stage itself. Our system is driven by the visualization because it (1) constructs 3D volume blocks only when they are visible, and (2) directly constructs 3D blocks only at the requested resolution. Instead of performing stitching and resampling at a higher resolution and then down-sampling to a lower resolution, we resample directly to the grid and resolution of the requested 3D volume block. This approach is possible because our virtual memory architecture does not require lower (or higher) resolutions to be available (<ref type="figure" coords="5,351.69,635.22,20.67,10.80">Fig. 3</ref>)—in contrast to octree-based systems <ref type="bibr" coords="5,511.37,635.22,9.71,10.80" target="#b5">[6,</ref><ref type="bibr" coords="5,523.32,635.22,6.47,10.80" target="#b6"> 7]</ref>. Efficient resampling of the 2D image tiles stored in the visualization archive is facilitated by retrieving only the sub-tiles intersecting the 3D target block, from a resolution level matching the target resampling resolution (<ref type="figure" coords="5,356.48,675.33,19.30,10.80">Fig. 5</ref>). A request for volume data is fulfilled in four main steps: (1) all 2D sub-tiles that intersect the 3D target block are determined. (2) for each sub-tile, the mipmap level matching the desired resampling resolution is chosen. (3) for each 2D slice comprising the 3D target block, the corresponding 2D sub-tile images are resampled directly into the corresponding location in the 3D target grid. (4) the resampled 3D block is transmitted to the visualization stage. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">2D Sub-Tile Fetching</head><p>In order to quickly determine the 2D sub-tiles that intersect the 3D target block, we maintain an index structure to find all 2D image tiles comprising a z-slice in the final volume in O(log 2 N), where N is the number of slices. The problem of finding all 2D tiles intersecting the 3D target block, and then all sub-tiles, is thus reduced to a 2D problem. Efficiently retrieving the sub-tiles overlapping the 3D target block requires a compact index structure that easily fits into main memory and can still be searched efficiently. Since some of the 2D sub-tiles are potentially empty, we first compute 2D coordinates per sub-tile. Then we traverse these sub-tile coordinates in Morton order (z order) <ref type="bibr" coords="6,255.70,154.96,13.74,10.80" target="#b24">[25]</ref>, and perform a run-length encoding on the indices, thus exploiting spatial coherence. Since only entry-and exit-points of a space-filling curve into a contiguous area are stored, the memory consumption of this data structure is only O( p k), for k sub-tiles per tile. Retrieving a specific set of sub-tile indices is then implemented efficiently by first expanding indices by skipping non-contributing runs, followed by a single read from the visualization archive for all relevant sub-tiles. The index structure is updated via notifications sent by the raw tile processing stage (Section 6). In case of an update event, the associated alignment matrix is read, the associated bounding rectangle is computed, and the index structure is updated accordingly. This does not require actual image data. These are only fetched when the visualization requests a 3D block. The same notification mechanism is also used whenever the alignment matrix of an image tile has changed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">3D Block Stitching and Resampling</head><p>Stitching and resampling are performed directly on the 3D target grid of the requested block. In order to avoid aliasing when resampling, we have to apply a 3D pre-filter <ref type="bibr" coords="6,138.43,345.78,13.74,10.80" target="#b11">[12]</ref>. Because of the 2D nature of our source data, we consider a separable 3D filter and convolution over a neighborhood x i of a voxel x, using a tensor product kernel W x,y ⌦W z consisting of a 2D filter W x,y in the (x, y) plane, and a 1D filter W z along the z axis. We define the pre-filtered 3D volume I 3d as: </p><formula>I 3d (x) = Â i W x,y ⌦W z (x x i ) · S 3d 2d ⇣ ( ˜ T 1 , I 2d 1 ),...,( ˜ T N , I 2d N ) ⌘ (x i ). (1) </formula><p>The operator S 3d 2d performs stitching of the N required 2D source image tiles I 2d k into the 3D grid of I 3d , where the pre-filter is then evaluated . This implicitly includes the reconstruction filter necessary for resampling at an arbitrary position x i . The˜TThe˜ The˜T k perform the affine transformations for tile alignment. In our current implementation, the operator S 3d 2d chooses pixels according to their Euclidean distance to the center of the corresponding image tile (see below). We enable this in Eq. (1) by using 2-vector images I 2d k , which are built from the scalar source images I 2d k as I 2d k (x) = </p><formula>I 2d k (x), D 2d k (x) </formula><p>, where D 2d k (x) is the distance between x and the center of tile I 2d k . In order to make stitching followed by pre-filtering fast enough for visualization-driven processing, we split up Eq. (1) into a full-resolution pre-processing step for the pre-filter W x,y , and a <ref type="figure" coords="6,22.50,704.74,19.92,9.87">Fig. 5</ref>. Visualization-driven stitching and resampling. Only visible 3D blocks in the virtual multi-resolution volume are stitched and resampled, computing the result at the requested resolution (` 2 <ref type="bibr" coords="6,204.92,723.90,15.70,9.52">[0, m]</ref>). Only the few coarsest resolutions (` &gt; m) are down-sampled after stitching leveì = m. visualization-driven step for evaluation of S at the requested target resolution . Instead of applying W x,y in the volume construction stage, we apply it to each source image tile in the raw tile processing stage to compute the levels of a 2D mipmap, which is then stored in the visualization archive. We compute these pre-filtered 2D images˜Iimages˜ images˜I 2d k as: </p><formula>˜ I 2d k (x) = Â i W x,y (x x i ) I 2d k (x i ). </formula><formula>(2) </formula><p> The volume construction step then only has to perform stitching of prefiltered image tiles, followed by application of the 1D pre-filter W z : </p><formula>I 3d (x) = Â i W z (p z (x x i )) · S 3d 2d ⇣ ( ˜ T 1 , ˜ I 2d 1 ),...,( ˜ T N , ˜ I 2d N ) ⌘ (x i ), (3) </formula><p>where p z means projection onto the z-coordinate and the x i now range over a 1D neighborhood of x in z-direction. ˜ I 2d k is computed from˜I from˜ from˜I 2d k as described above. This approach only approximates the result of Eq. (1), because Eq. (2) applies the pre-filter W x,y before stitching is performed in Eq. (3), instead of afterward. However, it decouples image stitching from pre-filtering and sub-sampling input image tiles. In principle, an arbitrary filter W z can be used as long as one is willing to perform 2D stitching of all required input slices followed by 1D pre-filtering. Our current implementation uses a box filter of size one for W z , i.e., nearest-neighbor interpolation along the z axis in Eq. (3). This allows a 3D target block to be resampled by simply stitching the image sub-tiles in 2D without performing actual 3D filtering, and storing the result into the correct 3D location. However, the general formulation above allows additional pre-filters to be integrated, which could even include the interpolation of intermediate slices in order to reduce the quality degradation caused by highly anisotropic data. Implementation. In order to avoid inefficient disk accesses of small size, we request and construct 3D blocks larger than 32 3 voxels, from which the actual 32 3 blocks are then extracted. We currently construct 3D blocks of size 512 ⇥ 512 ⇥ 32 (see Sections 8.1.3 and 8.4.1). Resampling is performed using texture mapping and fragment shaders. After fetching all required sub-tiles from the correct resolution level of the 2D image tile mipmaps, each sub-tile is downloaded into a pool of 2D texture maps that is sampled by the fragment shader. As reconstruction filter we either use GPU bi-linear filtering, or a higher-order filter implemented in the fragment shader. Stitching is performed during resampling using a GPU-based method akin to Hoff et al.'s Voronoi computation <ref type="bibr" coords="6,474.11,437.02,13.74,10.80" target="#b13">[14]</ref>. In regions where multiple tiles overlap, our domain experts prefer a selection of one actual measurement value over a blend between all valid values. A heuristic commonly used in this context is to select the pixel with the minimum distance to its respective tile center. We use the alignment matrix as texture matrix and render all contributing sub-tiles to an offscreen buffer. Then we set the depth of each fragment to the distance from the respective tile's center and perform a depth test. Stitched and resampled 3D blocks are then transmitted to the visualization stage, which fulfills its block request. If the volume construction and visualization stages are running on two separate nodes, the construction stage also caches resampled 3D blocks in memory, and optionally on fast local SSD storage as well (<ref type="figure" coords="6,462.55,556.57,19.23,10.80" target="#fig_0">Fig. 2</ref>). Strategy for coarse resolution levels. Although the resolutions of our target data result in deep resolution hierarchies (<ref type="figure" coords="6,470.98,576.49,24.13,10.80" target="#tab_1">Table 1</ref>), the tip of the hierarchy always corresponds to coarse resolutions. We define the corresponding resolution levels as`2as`as`2 <ref type="bibr" coords="6,424.22,597.98,30.67,9.95">[m,` max ]</ref>, as depicted in <ref type="figure" coords="6,512.09,596.42,20.05,10.80">Fig. 5</ref>. We currently choose m such that it corresponds to the resolution of one sub-tile times the number of image tiles comprising the full volume. For all levels`&gt;levels`levels`&gt; m, we then use a different strategy. In order to fulfill a 3D block request, we first compute the entire leveì = m via stitching and resampling as described above. The block for`&gt;for`for`&gt; m is then computed via simple down-sampling. The resulting hybrid strategy is similar in spirit to clipmaps <ref type="bibr" coords="6,384.25,666.16,13.74,10.80" target="#b27">[29]</ref>, where the coarsest mipmap levels are always kept in memory, whereas only a clipped area of each finer level is resident. However, our goal in this stage is dynamic stitching and resampling of multiple image tiles, not rendering a single clipmap. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RAW IMAGE TILE PROCESSING</head><p>Our pipeline generates 2D mipmaps for the image tiles emitted by the EM as soon as they arrive, by continuously polling the acquisition 2): min = 2, avg = 2.9, max = 8; image (c) encodes the number of visited octree nodes for the same view using kd-restart <ref type="bibr" coords="7,535.64,170.34,8.86,9.87" target="#b8">[9] </ref>as used by <ref type="bibr" coords="7,72.10,179.81,8.86,9.87" target="#b5">[6,</ref><ref type="bibr" coords="7,83.18,179.81,5.91,9.87" target="#b6"> 7]</ref>: min = 11, avg = 21.9, max = 77; image (d) uses kd-shortstack <ref type="bibr" coords="7,310.34,179.81,13.29,9.87" target="#b14">[15] </ref>with a stack size of four: min = 11, avg = 11.9, max = 25. archive. Each image tile has an affine transformation matrix attached to it which corresponds to the movement of the EM. This matrix can be iteratively refined by an external registration process to reflect image tile alignment both in 2D and 3D. The image tiles are chopped into 128 ⇥ 128 sub-tiles. This allows for more efficient disk storage, as well as more efficient resampling in the volume construction stage (Section 5), since the image tiles emitted by the EM are rather large (Section 7). Sub-tiles are optionally compressed using JPEG at 2bpp and stored in the visualization archive. Furthermore, they inherit the transformation matrix from the image tile (stored only once), augmenting it by an offset. Note that this stage is completely independent of registration, which we regard as an external process, and subsequent image alignment and stitching. It can thus be fully interleaved with both dynamic registration and data acquisition by the EM. Only meta data are forwarded to the volume construction stage. Actual data are only transmitted in case the volume construction stage forwards an actual request from the visualization stage. Processing in this stage is fast enough to keep up with the acquisition rate of the EM (Section 8.4.2). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">IMAGE DATA ACQUISITION</head><p>The image tiles acquired by the EM are stored on a shared file system archiving all acquired raw data. Our neuroscience collaborators use a Scanning EM (SEM) apparatus with the following specifications. Tiles comprising 12, 000 ⇥ 12, 000 luminance pixels at 8bit precision are emitted every 15 seconds (⇡10 Mpixels/s). The SEM traverses a section of the physical data sample in a scan-line fashion with 6%– 15% overlap between tiles. Both positional and rotational jitter are artifacts of the apparatus. Positional jitter is on the order of a few dozens of pixels, while rotational jitter does not exceed ±5 . Both can be safely assumed to be normal-distributed. The overlap between tiles is a requirement for the registration. In the future, our collaborators would like to reach a scanning speed of first 20, and then 40 Mpixels/s. The evaluation in Section 8.4.2 shows that our processing of raw image tiles (Section 6) matches even these expected future numbers. For testing different parameters of our system, we have implemented an EM simulator to simulate continuous image acquisition without requiring access or changes to the microscope setup. The simulator reads already stitched and registered sections measured by the EM. From these sections, rotated and translated tiles with mutual overlap as per the above specifications are cut out and forwarded to subsequent stages of our pipeline. The EM Simulator also supports simulation of registration updates. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">EVALUATION, COMPARISON, AND DISCUSSION</head><p> This section evaluates our system and compares it to previous approaches. Our ray-caster uses a GLSL fragment shader where each fragment casts a single ray, together with the NV shader buffer store extension for writing out cache misses and usage. Tile processing also uses CUDA, OpenMP, and multithreading . Our test setup are three 12-core dual-CPU 3 GHz machines, 48 GB, with NVIDIA Quadro 6000. The visualization stage and GUI were running on the first machine, the volume construction stage on the second one, and the raw tile processing stage, as well as the EM simulator, on the third one. The communication between stages is implemented via TCP/IP and Winsocks2, on a 1Gb network. The block cache was a 1 GB texture, and the page table cache a 64 MB texture. Comparison to other systems. Our system is the first one that targets interactive volume visualization and constructs 3D blocks of volume data dynamically from high-resolution image streams. Our visualization stage is most similar to the following two previous systems: The Gigavoxels system of Crassin et al. <ref type="bibr" coords="7,458.86,236.46,10.45,10.80" target="#b5">[6] </ref>performs ray-guided streaming of voxel data, which only downloads voxel blocks to the GPU when they become visible. However, these blocks have to come from a pre-computed octree. Its main target are entertainment applications , for rendering opaque (voxelized) surfaces or pre-defined opacity distributions such as static clouds. The interactive use of transfer functions is not supported, and empty space skipping is only possible for pre-determined homogeneous areas. The newer Siemens CERA-TVR system by Engel <ref type="bibr" coords="7,356.44,316.16,10.45,10.80" target="#b6">[7] </ref>uses an approach similar to <ref type="bibr" coords="7,470.60,316.16,9.52,10.80" target="#b5">[6]</ref> , but supports dynamic transfer functions and the corresponding empty space skipping. It targets teravoxel volumes, but also requires a pre-computed octree, and its efficiency decreases for anisotropic voxel aspect ratios. Both systems perform octree traversal during rendering, using the kd-restart algorithm <ref type="bibr" coords="7,331.11,365.97,9.52,10.80" target="#b8">[9]</ref> . In the following sections, we perform in-depth comparisons of our system with octree traversal approaches, for which we have implemented both kd-restart and kd-shortstack <ref type="bibr" coords="7,483.85,385.90,13.74,10.80" target="#b14">[15]</ref>. This shows that our system scales much better to deep resolution hierarchies. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Scalability Analysis and Comparison</head><p>This section discusses and compares the major scalability aspects of our system: scalability of the representation itself, scalability of traversal during rendering, and scalability of cache updates and usage. <ref type="figure" coords="7,294.12,471.03,26.62,10.80" target="#tab_1">Table 1</ref> illustrates the scalability of our multi-resolution virtual memory scheme. We first consider the resolution hierarchy. For a </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.1">Scalability of Volume Representation</head><formula>ume with (r x , r y , r z ) voxels, and relative voxel dimensions (s x , s y , s z ), </formula><p>for the following computations we define r v = max i (r i s i ), to correctly take into account arbitrary voxel anisotropy. For a volume resulting from a microscope pixel resolution of 5 nm and a slice thickness of 40 nm, s x = s y = 1 and s z = 8. We choose a voxel block size of b vox , and computè max = dlog 2 (r v /b vox )e. The page table hierarchy is determined by choosing a small number of hierarchy levels t, and a page table block size b pt . The corresponding page directory size of resolution leveì then is: </p><formula>r pd (`) = ⌃ dr v (`)/b vox e /b pt t1 ⌥ , where r v (`) </formula><p>is the size of resolution leveì. A choice of t = 2 or at most t = 3 is sufficient for extremely large volumes, due to the extreme logarithmic scaling (essentially base b pt ). This leads to easily manageable page directory sizes. <ref type="figure" coords="7,351.67,612.46,26.55,10.80" target="#tab_1">Table 1</ref>illustrates this scalability for example volume sizes and different choices of b vox , b pt , and t. Following the same argument , and the fact that the maximum number of voxels in the view frustum is independent of the full volume resolution, small page table cache sizes are sufficient as well. Our implementation can reference a visible frustum of 2, 048 2 ⇥ 16, 384 with a 64 MB texture. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.2">Scalability of Volume Traversal</head><p>In an octree-based scheme, locating a voxel in resolution leveì = 0 requires O(` max ) traversal time from the root, which is logarithmic in r v . In contrast, in our scheme any resolution leveì can be accessed by going directly (O(1) time) to the page directory of`,of`, and traversing the page table hierarchy in O(t) time. Although this can also be considered to be logarithmic in r v , since the choice of t depends logarithmically on the volume resolution, t ⌧ ` max . Moreover, since very small t are sufficient for extremely large volumes, we consider t to be a system constant that is chosen for the largest possible volume size. Page table hierarchy traversal time then becomes O(1). In practice, we keep the constant factor small by exploiting spatial coherence. These differences in scalability also show up clearly in practice, see the view depicted in <ref type="figure" coords="8,97.55,217.19,23.31,10.80" target="#fig_4">Fig. 6.</ref><ref type="figure" coords="8,124.06,217.19,20.20,10.80">Fig. 7</ref>(a) compares the behavior of octree traversal vs. our approach in practice for increasing visible resolution. For octree traversal, we compare against kd-restart <ref type="bibr" coords="8,208.54,237.12,9.52,10.80" target="#b8">[9]</ref> , as well as kd- shortstack <ref type="bibr" coords="8,61.58,247.08,13.74,10.80" target="#b14">[15]</ref>. The former is used in the systems of <ref type="bibr" coords="8,214.02,247.08,9.71,10.80" target="#b5">[6,</ref><ref type="bibr" coords="8,225.97,247.08,6.47,10.80" target="#b6"> 7]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.3">Scalability of Cache Updates and Usage</head><p> Figs. 7(b,c,d) illustrate and compare the number of required cache updates and the cache usage of our system vs. octree approaches. When the cache needs to be filled for a completely new view, cache usage and updates are the same. Our system requires page table block updates in the page table cache, voxel block updates in the block cache, and 3D block construction requests issued to the volume construction stage (Section 5). Octree-based systems have to update the nodes in the node pool, and the voxel blocks (bricks) in the brick pool <ref type="bibr" coords="8,250.59,345.96,9.71,10.80" target="#b5">[6,</ref><ref type="bibr" coords="8,263.17,345.96,6.47,10.80" target="#b6"> 7]</ref>. Our system needs to perform a much smaller number of updates for each of these caches. For resolution leveì = 0 and the view in <ref type="figure" coords="8,249.80,365.89,19.73,10.80" target="#fig_4">Fig. 6</ref>, our approach updates 2146 voxel blocks, whereas the octree requires 2768 updates. This difference becomes much more critical when 3D blocks have to be constructed dynamically. For disk access efficiency, instead of requesting individual 32 3 voxel blocks, we request blocks of 512 ⇥ 512 ⇥ 32 from the volume construction stage. The view in <ref type="figure" coords="8,252.29,415.70,20.60,10.80" target="#fig_4">Fig. 6</ref>requested 18 such 3D blocks with our approach, but 36 with an octree. Considering the time it takes to construct each block (Section 8.4.1), this constitutes a significant reduction in the latency perceived by the user. In the page table cache, our system requires only a few page table blocks (32 3 ) for this zoom-in. For leveì = 0, we have to update between 1 and 4 blocks, whereas the octree approach must update around 5, 000 nodes. Although each octree node requires less storage <ref type="bibr" coords="8,252.81,485.44,9.71,10.80" target="#b5">[6,</ref><ref type="bibr" coords="8,265.41,485.44,7.47,10.80" target="#b6"> 7] </ref>than a page table block, updating the octree node pool with thousands of individual texture downloads constitutes a significant bottleneck. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Virtual Memory vs. Octree Traversal</head><p>Our approach and octree traversal differ significantly in the kind of volume data for which either of the two approaches is efficient. Here, we discuss these differences in theory. Section 8.3 and <ref type="figure" coords="8,227.45,554.43,27.09,10.80" target="#tab_2">Table 2</ref>then illustrate the corresponding frame rate differences for real data. Octree traversal is efficient when: (1) Large subvolumes can be treated identically, i.e., they are either empty, homogeneous, or are rendered at a lower resolution. (2) The hierarchy is not too deep, i.e., ` max is not too large. The main reason for this is that tree traversal always starts at the root (` = ` max ) and goes down the tree to smaller`.smaller`. This means that rendering low resolutions is much more efficient than rendering high resolutions. This problem increases linearly with`maxwith`with`max . For empty space skipping, this means that detecting large empty subvolumes is efficient, because they are detected with a few traversal steps. Conversely, detecting small empty subvolumes is inefficient. Virtual memory access is most efficient when: (1) Only small subvolumes can be treated identically, i.e., data are either dense, or empty space forms only small clusters. (2) Data should be rendered at high resolution. (3) The hierarchy can be very deep (` max is large). This is true because any desired resolution leveì can be accessed directly in O(1) time, and ray-casting directly accesses thè corresponding to the screen resolution. The efficiency of virtual memory access decreases when dynamic traversal of the resolution hierarchy is required (Section 4.2.3). Nevertheless, even the worst case of going all the way tòtò max is a O(` max ) operation. However, octree traversal can be more efficient in this case due to a lower constant overhead per traversal step. In practice, however, reducing the resolution by too many levels is not useful for scientists. When the reduction in resolution is limited and`maxand`and`max is large, virtual memory access is more efficient than octree traversal even when dynamic resolution traversal is required. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Ray-Casting Performance</head><p> Our ray-casting performance primarily depends on the amount of visible data, which is mainly determined by the transfer function and the view. It does not depend significantly on the full volume resolution. <ref type="figure" coords="8,285.12,182.30,27.22,10.80" target="#tab_2">Table 2</ref> (column 'our') gives typical average frame rates for rendering`=ing`ing`= 0 of microscopy volumes (D1-D3), as well as an industrial CT volume for comparison (D4), to a 1024 ⇥ 768 viewport. D1-D3 are very dense and do not allow or require a lot of empty space skipping. D4 was used in <ref type="bibr" coords="8,312.53,222.15,10.45,10.80" target="#b6">[7] </ref>and contains a lot of empty space. A typical view of D4 that we measured contained 22, 058 32 3 voxel blocks, of which 61% were classified as empty. Skipping this empty space as described in Section 4.2.3 increased performance from 6 fps to the listed 30 fps (TF #2). <ref type="figure" coords="8,285.12,262.01,20.05,10.80">Fig. 7</ref>(c) plots frame rates over an animation sequence of volume D1. For comparison, column 'tree' in <ref type="figure" coords="8,416.34,272.54,26.46,10.80" target="#tab_2">Table 2</ref> gives frame rates for rendering using kd-restart traversal as in <ref type="bibr" coords="8,420.78,282.50,9.71,10.80" target="#b5">[6,</ref><ref type="bibr" coords="8,432.68,282.50,6.47,10.80" target="#b6"> 7]</ref>. Our frame rates for D1-D3 are consistently better, as expected. For D4, tree traversal in principle has the empty space skipping advantages described above. However , in our comparisons our approach (Section 4.2.3) was still always faster. At least for this test volume, the empty areas are still not large enough for tree traversal to leverage its theoretical advantages. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Data Processing</head><p> This section evaluates the visualization-driven construction of 3D volume blocks, and the EM-driven processing of raw image tiles. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4.1">3D Block Construction</head><p> This stage comprises the following steps: (1) retrieve required subtiles from the visualization archive, (2) optional image decoding, (3) data download to the GPU for stitching and resampling, and (4) readback of the stitched data to the CPU. The optional JPEG encoder at a compression of 4:1 reads (and decodes) more than 300 Mpixels/s from a standard hard disk. To measure the performance of this stage, we have issued a large number of requests for 512 2 cross-sections of the volume, varying the slice number requested to evaluate the 3D construction. We measured the minimum, average, and maximum latency in two scenarios. A worst-case scenario, for which we forced our implementation to execute steps 1–4 single-threaded and serialized to give an upper bound on the latency to be expected. The second scenario runs steps 1–3 interleaved. Our findings are summarized in <ref type="figure" coords="8,285.12,534.79,26.07,10.80" target="#tab_3">Table 3</ref>. For the minimum latency, data has been cached by the OS and resides in CPU memory, while for the maximum latency data has to be retrieved first. With increasing leveì, data locality improves and therefore also the latency. Since the number of 128 2 sub-tiles required to form the construction varies due to the overlapping input data, so does the latency. We thus measure numbers normalized per sub-tile as follows: Optional JPEG-decoding takes 0.12ms, while transferring data to the GPU and rendering takes around 0.02ms per sub-tile. The <ref type="figure" coords="8,285.12,624.11,23.99,9.87" target="#tab_2">Table 2</ref>. Test volumes and frame rates <ref type="bibr" coords="8,415.06,624.05,14.57,10.37">[fps]</ref> . Frame rates are almost independent of resolution, depending more on the transfer function. TF #1: linear ramp. TF #2: semi-transparent (see <ref type="figure" coords="8,434.05,643.03,24.60,9.87">Fig. 1).</ref><ref type="figure" coords="9,31.50,154.32,19.18,9.87">Fig. 7</ref>. Hierarchy traversal complexity and cache update/usage evaluation and comparison. (a) Log-scale traversal statistics (max, min, avg) over all rays in a 1024 ⇥ 768 image for a zoom-in from`=from`from`= 10 tò = 0 (see <ref type="figure" coords="9,266.74,163.79,18.93,9.87" target="#fig_4">Fig. 6</ref>): Page table hierarchy entries accessed (t = 2), vs. octree nodes visited (kd-restart compares with <ref type="bibr" coords="9,125.98,173.25,8.86,9.87" target="#b5">[6,</ref><ref type="bibr" coords="9,137.50,173.25,5.76,9.87" target="#b6"> 7]</ref>). (b) Cache update/usage for voxel blocks, page table blocks, and 3D blocks requested for construction, vs. the equivalent requests for an octree. Each resolution level was measured individually. (c,d): Statistics over a sequence of 30 animation frames with cache re-use from frame to frame: Frame 1–11: zoom-in; frame 12–27: pan.  GPU-to-CPU read-back is independent of the amount of sub-tiles rendered and takes around 0.68ms. The worst case latency (interleaved) to retrieve a fully constructed 512 2 ⇥ 32 block was around 1.7s (6.8ms / 32 3 voxels), while a block is typically constructed in less than 0.3s (1.2ms / 32 3 voxels). A fresh start from empty caches takes up to 15s. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4.2">Raw Image Tile Processing</head><p>The data set depicted in Figs. 1 and 6 (<ref type="figure" coords="9,173.00,283.31,24.82,10.80" target="#tab_2">Table 2</ref>: D1) comprises 11,689 image tiles of size 12, 000 ⇥ 12, 000 in the acquisition archive. We used the EM simulator to generate these from 1, 850 slices of size 21, 494 ⇥ 25, 790 each from the original data set. After raw image tile processing, this data occupies 210 GB for voxel data and 13.3 MB for index structures in our visualization archive. It is thus perfectly feasible to keep the index data structure resident in CPU memory even for data sets in the petabyte range. Further, our raw image tile processor achieves a sustained performance of 85 Mpixels/s. It is thus significantly faster than the current measurement apparatus (yielding 10 Mpixels/s <ref type="bibr" coords="9,68.52,382.93,10.08,10.80" target="#b3">[4]</ref> ) and is able to keep pace with the future plans of our neuroscience collaborators (40 Mpixels/s), as well as our current implementation of the EM Simulator, which achieves a sustained throughput of 45 Mpixels/s on our test machine. All disk transfer is included in the performance reported. The start-up latency for both the simulator and the raw image tile processor is on the order of a few seconds. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Discussion and Limitations</head><p>Our system strives to enable neuroscientists to navigate and explore petascale EM volumes in 3D. However, instead of thinking of it as a " typical " volume renderer, we view it as being similar to a Google maps approach, albeit for dense 3D volumes instead of for 2D maps. Limitations. Our system targets always rendering data corresponding to the full screen resolution. This approach incurs two main drawbacks . The first one is the latency until a complete image is generated from the desired data resolution. The rendering frame rate, as given in <ref type="figure" coords="9,31.50,540.34,25.72,10.80" target="#tab_2">Table 2</ref>, is completely decoupled from the time it takes until missing data have been constructed and downloaded into the GPU cache textures . When all visible data have arrived, a correct image is rendered at high frame rates. However, this does not consider how long it takes until a correct image is visible. Overall latency varies significantly, and ultimately depends on the number of new 3D blocks that must be constructed for a new frame in addition to already cached data. Our system design strives to minimize this number and thus the latency, as illustrated in <ref type="figure" coords="9,80.42,620.04,20.57,10.80">Fig. 7</ref>(c), and often requires fewer—and never more— blocks to be constructed than when tree traversal is used. Nevertheless , the worst case latency (Section 8.4.1) multiplied by the number of required 3D blocks (<ref type="figure" coords="9,117.44,649.92,19.93,10.80">Fig. 7</ref>(c)) can be several seconds until a fully <ref type="figure" coords="9,31.50,665.60,25.71,9.87" target="#tab_3">Table 3</ref>. Times for stitching and resampling to construct a 512 ⇥ 512 cross-section from a given resolution leveì of volume D1 (correct image is rendered when all caches are empty. Missing blocks or blocks rendered with lower resolution can optionally be color-coded for visual feedback on the current correctness of the rendered image. The second drawback is that our system assumes that the current working set, i.e., all visible data of the desired resolution, always fits into the block cache. If this is not the case, a correct image cannot be rendered. This problem can be handled by using distributed rendering on multiple GPUs <ref type="bibr" coords="9,360.62,285.35,9.52,10.80" target="#b0">[1]</ref>, or by performing multiple rendering passes <ref type="bibr" coords="9,531.80,285.35,9.52,10.80" target="#b6">[7]</ref>. Both of these drawbacks can be mitigated by using a global level of detail bias to force lower-resolution rendering. This is also supported by our system, but has not been used for the results reported here. Our design goal was to avoid reducing rendering quality for interactivity. Volume rendering of EM data. Our data are very dense and noisy, as well as highly anisotropic. They thus do not easily facilitate highquality volume rendering, hindering the perception of connected structures in 3D. Solving this problem is outside the scope of this paper. However, neuroscientists at minimum require rendering arbitrarily oriented slicing planes whose position and orientation can be changed interactively , and the infrastructure required for this is almost the same as for volume rendering, using a fully opaque " transfer function. " </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="2,22.50,195.44,513.00,10.37;2,22.50,204.95,513.00,9.87;2,22.50,214.42,510.54,9.87"><head>Fig. 2. </head><figDesc>Fig. 2. System overview. Petascale volumes are acquired as a stream of image tiles from the microscope. Each raw image tile is processed individually in the input stream. Everything else is visualization-driven: Ray-casting operates in virtual volume space, detecting cache misses for visible volume blocks. Only these blocks are then constructed in 3D by stitching and resampling the corresponding tiles from the 2D input stream. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="4,110.31,350.47,162.57,10.80;4,22.50,360.43,250.38,10.80;4,29.39,377.93,127.42,9.74;4,29.39,386.90,133.74,9.74;4,29.39,395.86,72.12,9.60;4,29.39,404.83,190.48,9.74;4,29.39,413.79,6.20,9.60;4,60.00,414.46,163.68,9.09;4,29.39,422.76,6.20,9.60;4,60.00,423.68,143.56,8.40;4,29.39,431.73,37.00,9.74;4,29.39,440.69,104.60,9.60;4,29.39,449.66,199.65,9.74;4,27.22,458.63,10.19,9.60;4,61.81,459.30,154.73,9.07;4,27.22,467.59,10.19,9.60;4,72.27,468.26,187.01,9.09;4,27.22,476.56,10.19,9.60;4,72.27,477.48,179.34,8.40;4,27.22,485.53,10.19,9.60;4,61.81,486.19,16.86,9.07;4,27.22,494.49,10.19,9.60;4,61.81,495.41,81.37,8.40;4,27.22,503.46,10.19,9.60;4,61.81,504.13,179.50,9.07;4,27.22,512.42,10.19,9.60;4,72.27,513.09,189.70,9.09;4,27.22,521.39,10.19,9.60;4,72.27,522.31,149.13,8.40;4,27.22,530.36,10.19,9.60;4,61.81,531.03,10.84,9.07;4,27.22,539.32,10.19,9.60;4,72.27,539.99,194.11,9.07;4,27.22,548.29,10.19,9.60;4,61.81,548.96,16.86,9.07;4,27.22,557.26,34.98,9.74;4,27.22,566.22,10.19,9.60;4,61.81,566.89,174.68,9.07;4,27.22,575.19,40.99,9.74;4,27.22,584.16,126.15,9.74;4,27.22,593.12,10.19,9.60;4,61.81,593.79,159.94,9.07;4,27.22,602.09,10.19,9.60;4,61.99,603.01,93.78,8.40;4,27.22,611.06,40.99,9.74;4,27.22,620.02,66.71,9.74;4,27.22,628.99,51.07,9.74;4,27.22,637.95,157.97,9.74;4,27.22,646.92,214.70,9.74;4,27.22,655.89,42.98,9.74;4,27.22,664.85,10.19,9.60;4,61.81,665.52,174.84,9.07;4,27.22,673.82,10.19,9.60;4,61.81,674.74,137.47,8.40;4,27.22,682.79,10.19,9.60;4,61.99,683.71,170.11,8.40;4,27.22,691.75,10.19,9.60;4,61.81,692.42,120.84,9.07"><head></head><figDesc>Fig. 3 (left). The basic idea is to virtualize a large volume for out-of-core visualization using a 3D page table != UNMAPPED &amp;&amp; pagingFlag != EMPTY then 10: if !PAGETABLEINDEXSAMEASPREVIOUS( `, p ) then 11: int3 pTableAddress = pDirEntry.xyz + ( p * r pt (`).xyz ) % b pt .xyz; 12: pTableEntry = texture3D( texPageTableCache, pTableAddress ); 13: end if 14: pagingFlag = pTableEntry.w; 15: if pagingFlag != UNMAPPED &amp;&amp; pagingFlag != EMPTY then 16: int3 voxelAddress = pTableEntry.xyz + ( p * r v (`).xyz ) % b vox .xyz; </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="4,399.93,632.04,135.58,11.88;4,285.12,642.01,250.39,11.51;4,285.12,651.97,250.38,11.51;4,285.12,661.93,250.38,10.80;4,285.12,671.89,239.19,11.51;4,285.12,683.60,11.96,11.10"><head></head><figDesc>r pd (`) is the total number of entries in the page directory for resolution leveì. r pt (`) is the total number of entries in the virtualized page table of leveì. r v (`) is the total number of voxels in the virtualized volume of leveì. Each page table block comprises b pt entries, and each voxel block comprises b vox voxels. 4.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3" coords="5,222.31,421.14,59.56,10.80;5,31.50,431.10,250.38,10.80;5,31.50,441.06,222.47,10.80"><head></head><figDesc>6 and 7 illustrate that this simple optimization in practice indeed reduces the required number of page table accesses per ray to a very small amount. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4" coords="7,31.50,160.82,513.00,10.37;7,31.50,170.34,513.00,9.87;7,31.50,179.81,489.72,9.87"><head>Fig. 6. </head><figDesc>Fig. 6. Hierarchy traversal complexity. For the view (` = 0) in (a), image (b) encodes the number of page table entries accessed by each ray in the page table hierarchy (t = 2): min = 2, avg = 2.9, max = 8; image (c) encodes the number of visited octree nodes for the same view using kd-restart [9] as used by [6, 7]: min = 11, avg = 21.9, max = 77; image (d) uses kd-shortstack [15] with a stack size of four: min = 11, avg = 11.9, max = 25. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5" coords="9,31.50,154.27,513.00,10.37;9,31.50,163.79,48.95,9.87;9,81.67,165.21,6.19,13.83;9,89.08,163.79,455.42,9.87;9,31.50,173.25,513.00,9.87;9,31.50,182.72,513.00,9.87;9,31.50,192.18,513.00,9.87;9,31.50,201.64,512.29,9.87"><head></head><figDesc>Fig. 7. Hierarchy traversal complexity and cache update/usage evaluation and comparison. (a) Log-scale traversal statistics (max, min, avg) over all rays in a 1024 ⇥ 768 image for a zoom-in from`=from`from`= 10 tò = 0 (see Fig. 6): Page table hierarchy entries accessed (t = 2), vs. octree nodes visited (kd-restart compares with [6, 7]). (b) Cache update/usage for voxel blocks, page table blocks, and 3D blocks requested for construction, vs. the equivalent requests for an octree. Each resolution level was measured individually. (c,d): Statistics over a sequence of 30 animation frames with cache re-use from frame to frame: Frame 1–11: zoom-in; frame 12–27: pan. Frame 18: the transfer function changes to more transparency. Total for each frame vs. new to previous frame. (c) 3D block construction requests. (d) Voxel block and page table updates vs. node pool updates [6, 7]. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false" coords="7,30.75,26.18,518.00,719.89"><figDesc coords="7,294.12,651.19,250.38,10.37;7,294.12,660.71,250.38,10.41;7,294.12,670.17,247.24,10.41">Table 1. Scalability of the page table hierarchy. Page directory resolutions resulting from b vox = 32, voxel anisotropy 1:8, and choices of b pt = 16 or 32, respectively. We suggest the highlighted configurations.</figDesc><table coords="7,305.18,685.70,228.26,60.36">volume resolution 
vol sizèsizè max + 1 
t = 2 
t = 3 
16 
32 
16 
32 

32, 768 2 ⇥ 4, 096 
4 TB 
11 
64 
32 
4 
1 
120, 000 2 ⇥ 15, 000 
196 TB 
13 
235 
118 
15 
4 
512, 000 2 ⇥ 64, 000 
15 PB 
15 
1,000 
500 
63 
16 
2, 000, 000 2 ⇥ 250, 000 
888 PB 
17 
3,907 
1,954 
245 
62 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false" coords="8,291.10,643.03,244.76,98.55"><figDesc coords="8,461.33,643.03,74.17,9.87">D4 only for reference.</figDesc><table coords="8,291.10,657.61,244.76,83.97">data set 
resolution 
size [GB] 
TF 
our 
tree 

D1: mouse cortex 
21, 494 ⇥ 25, 790 ⇥ 1, 850 
955 
#1 
75 
61 
#2 
12 
9 

D2: hippocampus 1 
18, 000 ⇥ 18, 000 ⇥ 304 
92 
#1 
77 
63 
#2 
19 
15 

D3: hippocampus 2 
14, 176 ⇥ 10, 592 ⇥ 308 
43 
#1 
72 
58 
#2 
22 
13 

D4: rotation sensor 
2, 048 ⇥ 2, 048 ⇥ 2, 048 
8 
#1 
55 
44 
#2 
30 
25 1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
0 
10 

0 

10 

1 

10 

2 

resolution level l 

traversal complexity: log(#look−ups) 

0 
5 
10 
15 
20 
25 
30 
0 

500 

1000 

1500 

2000 

2500 

3000 

3500 

voxel block updates 
page table block updates 

voxel block updates 
node pool updates 

our system: 

octree: 

50 

10 

20 

30 

40 

update complexity: cache usage 

resolution level l 

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
0 

voxel blocks/100 
page table block updates/100 
3D block construction requests 

voxel blocks/100 
node pool updates/100 
3D block construction 
requests 

our system: 

octree: 

0 

max 
min 
avg 

max 
min 
avg 

max 
min 
avg 

our system: 

kd−restart: 

kd−short stack: 

0 
5 
10 
15 
20 
25 
30 
0 

10 

20 

30 

40 

50 

60 

70 

frame number 

resident constructed 3D blocks 
3D block construction requests 

resident constructed 3D blocks 
3D block construction requests 

resolution level l 

fps 

our system: 

octree: 

frame number 
3D block construction requests 
update complexity: cache trac 

(a) 
(b) 
(c) 
(d) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true" coords="9,54.57,675.07,213.10,67.68"><figDesc coords="9,238.26,675.07,29.41,9.87">Table 2).</figDesc><table coords="9,54.57,687.12,204.25,55.63">serial performance 
interleaved performancèperformancè 
min 
avg 
max 
min 
avg 
max 

0 
5.50ms 
9.69ms 
59.82ms 
4.41ms 
9.42ms 
54.01ms 
1 
5.80ms 
9.70ms 
45.56ms 
4.57ms 
8.88ms 
40.01ms 
2 
6.49ms 
9.32ms 
30.59ms 
5.13ms 
6.83ms 
25.73ms 
3 
5.63ms 
7.12ms 
14.25ms 
4.58ms 
4.58ms 
9.72ms 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSIONS AND FUTURE WORK</head><p>We have illustrated that the two major design choices of our system for the first time enable the interactive exploration of petascale electron microscopy data streams via: (1) visualization-driven 3D data construction, and (2) a novel virtual memory scheme. The former decouples the multi-resolution hierarchy required for visualization from data acquisition. This decoupling is crucial to achieving scalability to the petascale for our target data streams. The latter decouples the resolution hierarchy from the hierarchy for volume sampling during ray-casting. This enables scaling to dense, anisotropic petascale volumes that cannot be handled by previous systems. The latter have to traverse the resolution hierarchy in logarithmic time, which becomes a significant bottleneck for deep hierarchies. We essentially have different goals than previous systems: instead of favoring lower fall-back resolutions and large clusters of empty space, we directly access any target resolution in O(1) time. Data of (limited) lower resolution are only used as a fall-back when the desired resolution is not yet available , but searching from high to low resolutions instead of vice versa. In the future, we want to fully integrate our pipeline with the microscopy setup of our collaborators at the Harvard Center for Brain Science. We are also working on integrating distributed rendering into our system <ref type="bibr" coords="9,335.62,629.10,9.52,10.80" target="#b0">[1]</ref>, which we consider to be orthogonal to the approaches presented here. Finally, upcoming GPU hardware features, such as partially resident textures <ref type="bibr" coords="9,391.59,649.03,10.45,10.80" target="#b1">[2] </ref>might allow tighter integration of our system with GPU memory management. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS </head><p>We would like to thank Jens Schneider and Thomas Theussl for their contributions, Klaus Engel and Florian Link for their valuable input, Mark Matten for narrating the video, and our collaborators at the Harvard Center for Brain Science. The project was partially supported by the Vienna Science and Technology Fund (WWTF) through project ICT08-040, NSF grant OIA 1125087, Intel ISTC-VC, Google, and NVIDIA. Data set D4 courtesy of Siemens Healthcare, Components and Vacuum Technology, Imaging Solutions. </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct coords="10,40.76,72.62,232.12,9.60;10,40.76,82.08,232.12,9.60;10,40.76,91.55,232.12,9.60"  xml:id="b0">
	<analytic>
		<title level="a" type="main">Distributed terascale volume visualization using distributed shared virtual memory</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Beyer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hadwiger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schneider</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W.-K</forename>
				<surname>Jeong</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Pfister</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Posters at Large-Data Analysis and Visualization</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,101.01,232.12,9.60;10,40.76,110.48,232.12,9.60;10,40.76,119.94,232.12,9.60;10,40.76,129.41,232.12,9.60;10,40.76,138.87,71.06,9.60"  xml:id="b1">
	<monogr>
		<title level="m" type="main">AMD GPU technical publications: Partially resident textures (PRT) in the Graphics Core Next</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Bilodeau</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Sellers</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Hillesland</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>2012. . Accessed on 31/03</note>
</biblStruct>

<biblStruct coords="10,40.76,148.34,232.12,9.60;10,40.76,157.80,232.12,9.60;10,40.76,167.27,17.93,9.60"  xml:id="b2">
	<monogr>
		<title level="m" type="main">Multiresolution Volume Visualization with a Texture-Based Octree. The Visual Computer</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Boada</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Navazo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Scopigno</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="185" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,176.73,232.12,9.60;10,40.76,186.20,232.12,9.60;10,40.76,195.66,232.12,9.60;10,40.76,205.12,33.87,9.60"  xml:id="b3">
	<analytic>
		<title level="a" type="main">Network anatomy and in vivo physiology of visual cortical neurons</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Bock</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W.-C</forename>
				<surname>Lee</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Kerlin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Andermann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Hood</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Wetzel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Yurgenson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Soucy</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
				<surname>Kim</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">C</forename>
				<surname>Reid</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="issue">7337</biblScope>
			<biblScope unit="page" from="471177" to="182" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,214.59,232.12,9.60;10,40.76,224.05,232.12,9.60;10,40.76,233.52,188.27,9.60"  xml:id="b4">
	<analytic>
		<title level="a" type="main">A scalable, hybrid scheme for volume rendering massive data sets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Childs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Duchaineau</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K.-L</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Symposium on Parallel Graphics and Visualization</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="153" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,242.98,232.12,9.60;10,40.76,252.45,232.12,9.60;10,40.76,261.91,232.12,9.60;10,40.76,271.38,41.84,9.60"  xml:id="b5">
	<analytic>
		<title level="a" type="main">Gigavoxels: Rayguided streaming for efficient and detailed voxel rendering</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Crassin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Neyret</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Lefebvre</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Eisemann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2009 Symposium on Interactive 3D Graphics and Games</title>
		<meeting>2009 Symposium on Interactive 3D Graphics and Games</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,280.84,232.12,9.60;10,40.76,290.30,232.12,9.60;10,40.76,299.77,124.29,9.60"  xml:id="b6">
	<monogr>
		<title level="m" type="main">CERA-TVR: A framework for interactive high-quality teravoxel volume visualization on standard PCs. In Posters at Large-Data Analysis and Visualization</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Engel</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,309.23,232.12,9.60;10,40.76,318.70,232.12,9.60;10,40.76,328.16,224.02,9.60"  xml:id="b7">
	<analytic>
		<title level="a" type="main">Large data visualization on distributed memory multi-GPU clusters</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Fogal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Childs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Shankar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Krüger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">D</forename>
				<surname>Bergeron</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Hatcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of High Performance Graphics 2010</title>
		<meeting>High Performance Graphics 2010</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,337.63,232.12,9.60;10,40.76,347.09,228.48,9.60"  xml:id="b8">
	<analytic>
		<title level="a" type="main">Kd-tree acceleration structures for a GPU raytracer</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Foley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sugerman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Hardware 2005</title>
		<meeting>Graphics Hardware 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,356.56,232.12,9.60;10,40.76,366.02,232.12,9.60;10,40.76,375.49,170.97,9.60"  xml:id="b9">
	<monogr>
		<title level="m" type="main">A single-pass gpu ray casting framework for interactive out-of-core rendering of massive volumetric datasets. The Visual Computer</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Gobbetti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Marton</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Guitan</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="797" to="806" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,384.95,232.12,9.60;10,40.76,394.41,231.89,9.60"  xml:id="b10">
	<analytic>
		<title level="a" type="main">Advanced Techniques for High-Quality Multi- Resolution Volume Rendering</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Guthe</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Strasser</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="51" to="58" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,403.88,232.12,9.60;10,40.76,413.34,105.60,9.60"  xml:id="b11">
	<analytic>
		<title level="a" type="main">Survey of texture mapping</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Heckbert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="56" to="67" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,422.81,232.12,9.60;10,40.76,432.27,179.53,9.60"  xml:id="b12">
	<monogr>
		<title level="m" type="main">Computer Architecture: A Quantitative Approach</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L</forename>
				<surname>Hennessey</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">A</forename>
				<surname>Patterson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
	<note>fifth. edition</note>
</biblStruct>

<biblStruct coords="10,40.76,441.74,232.12,9.60;10,40.76,451.20,232.12,9.60;10,40.76,460.67,162.12,9.60"  xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast computation of generalized Voronoi diagrams using graphics hardware</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">E</forename>
				<surname>Hoff</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Keyser</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Lin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Manocha</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Culver</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH</title>
		<meeting>SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="277" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,470.13,232.12,9.60;10,40.76,479.59,232.12,9.60;10,40.76,489.06,37.86,9.60"  xml:id="b14">
	<analytic>
		<title level="a" type="main">Interactive k-d tree GPU raytracing</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Horn</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sugerman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Houston</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Hanrahan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Interactive 3D Graphics and Games</title>
		<meeting>Interactive 3D Graphics and Games</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,498.52,232.12,9.60;10,40.76,507.99,232.12,9.60;10,40.76,517.45,232.12,9.60;10,40.76,526.92,17.93,9.60"  xml:id="b15">
	<analytic>
		<title level="a" type="main">MPI-hybrid Parallelism for Volume Rendering on Large, Multi-core Systems</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Howison</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Bethel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Childs</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Symposium on Parallel Graphics and Visualization (EGPGV)</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,536.38,232.12,9.60;10,40.76,545.85,232.12,9.60;10,40.76,555.31,188.51,9.60"  xml:id="b16">
	<analytic>
		<title level="a" type="main">Kd-jump: a path-preserving stackless traversal for faster isosurface raytracing on GPUs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Hughes</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">S</forename>
				<surname>Lim</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1555" to="1562" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,564.78,232.12,9.60;10,40.76,574.24,72.03,9.60"  xml:id="b17">
	<analytic>
		<title level="a" type="main">Adaptive texture maps</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kraus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Hardware</title>
		<meeting>Graphics Hardware</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,583.70,232.12,9.60;10,40.76,593.17,232.12,9.60;10,40.76,602.63,71.44,9.60"  xml:id="b18">
	<analytic>
		<title level="a" type="main">Tuvok -an architecture for large scale volume rendering</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Krüger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Fogal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Vision</title>
		<meeting>the 15th Vision</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,612.10,232.12,9.60;10,40.76,621.56,232.12,9.60"  xml:id="b19">
	<analytic>
		<title level="a" type="main">Acceleration Techniques for GPU-based Volume Rendering</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Krüger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Westermann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>. of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="287" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,631.03,232.12,9.60;10,40.76,640.49,232.12,9.60;10,40.76,649.96,86.34,9.60"  xml:id="b20">
	<analytic>
		<title level="a" type="main">Multiresolution Techniques for Interactive Texture-Based Volume Visualization</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Lamar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Hamann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Joy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>. of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="355" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,659.42,232.12,9.60;10,40.76,668.88,184.16,9.60"  xml:id="b21">
	<analytic>
		<title level="a" type="main">Resolution-matched shadow maps</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Lefohn</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Sengupta</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Owens</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="23" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,678.35,232.12,9.60;10,40.76,687.81,205.42,9.60"  xml:id="b22">
	<analytic>
		<title level="a" type="main">The big and the small: Challenges of imaging the brain&apos;s circuits</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">W</forename>
				<surname>Lichtman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Denk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">334</biblScope>
			<biblScope unit="issue">6056</biblScope>
			<biblScope unit="page" from="618" to="623" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,697.28,232.12,9.60;10,40.76,706.74,232.12,9.60;10,40.76,716.21,36.53,9.60"  xml:id="b23">
	<monogr>
		<title level="m" type="main">Real-time scale selection in hybrid multiscale representations</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Lindeberg</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Bretzner</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,725.67,232.12,9.60;10,40.76,735.14,169.00,9.60;10,285.12,52.10,250.38,9.60;10,303.38,61.56,232.12,9.60;10,303.38,71.03,136.25,9.60"  xml:id="b24">
	<analytic>
		<title level="a" type="main">A computer oriented geodetic data base and a new technique in file sequencing</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Morton</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ltd</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Peterka</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Yu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K.-L</forename>
				<surname>Ross</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel volume rendering on the IBM Blue Gene/P Eurographics/ACM SIGGRAPH Symposium on Parallel Graphics and Visualization</title>
		<imprint>
			<date type="published" when="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,80.49,232.12,9.60;10,303.38,89.96,232.12,9.60;10,303.38,99.42,56.01,9.60"  xml:id="b25">
	<analytic>
		<title level="a" type="main">Stackless kd-tree traversal for high performance gpu ray tracing</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Popov</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Günther</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H.-P</forename>
				<surname>Seidel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Slusallek</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,108.89,232.12,9.60;10,303.38,118.35,232.12,9.60;10,303.38,127.82,204.97,9.60"  xml:id="b26">
	<analytic>
		<title level="a" type="main">Interactive editing of massive imagery made simple: Turning Atlanta into Atlantis</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Summa</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Scorzelli</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P.-T</forename>
				<surname>Bremer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Pascucci</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">307</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,137.28,232.12,9.60;10,303.38,146.74,232.12,9.60"  xml:id="b27">
	<analytic>
		<title level="a" type="main">The clipmap: a virtual mipmap</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">C</forename>
				<surname>Tanner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">J</forename>
				<surname>Migdal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">T</forename>
				<surname>Jones</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;98</title>
		<meeting>SIGGRAPH &apos;98</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,156.21,232.12,9.60;10,303.38,165.67,232.12,9.60;10,303.38,175.14,79.70,9.60"  xml:id="b28">
	<analytic>
		<title level="a" type="main">id tech 5 challenges: From texture virtualization to massive parallelization</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">M P</forename>
				<surname>Van Waveren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Talk in Beyond Programmable Shading course</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,184.60,232.12,9.60;10,303.38,194.07,232.12,9.60;10,303.38,203.53,177.18,9.60"  xml:id="b29">
	<analytic>
		<title level="a" type="main">Level-Of-Detail Volume Rendering via 3D Textures</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Weiler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Westermann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Hansen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zimmerman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposium on Volume Visualization</title>
		<meeting>. of IEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
