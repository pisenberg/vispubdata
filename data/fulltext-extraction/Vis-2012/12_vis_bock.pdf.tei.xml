<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.1" ident="GROBID" when="2016-09-09T15:00+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Coherency-Based Curve Compression for High-Order Finite Element Model Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Alexander</forename>
								<surname>Bock</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Erik</forename>
								<surname>Sundénsund´sundén</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Bingchen</forename>
								<surname>Liu</surname>
								<roleName>Burkhard W ¨ Unsche, Member, Ieee</roleName>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Timo</forename>
								<surname>Ropinski</surname>
								<roleName>Member, Ieee</roleName>
							</persName>
						</author>
						<title level="a" type="main">Coherency-Based Curve Compression for High-Order Finite Element Model Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Fig. 1. Application of our visualization approach to a multi-parametric FE model of the left ventricle of a human heart. The images show volumetric renderings of different strain directions defined over the FE model: radial strain, circumferential strain, longitudinal strain as well as the three former combined (left to right). The presented approach allows for interactive data exploration by changing the transfer function and other relevant rendering parameters. Abstract—Finite element (FE) models are frequently used in engineering and life sciences within time-consuming simulations. In contrast with the regular grid structure facilitated by volumetric data sets, as used in medicine or geosciences, FE models are defined over a non-uniform grid. Elements can have curved faces and their interior can be defined through high-order basis functions, which pose additional challenges when visualizing these models. During ray-casting, the uniformly distributed sample points along each viewing ray must be transformed into the material space defined within each element. The computational complexity of this transformation makes a straightforward approach inadequate for interactive data exploration. In this paper, we introduce a novel coherency-based method which supports the interactive exploration of FE models by decoupling the expensive world-to-material space transformation from the rendering stage, thereby allowing it to be performed within a precomputation stage. Therefore, our approach computes view-independent proxy rays in material space, which are clustered to facilitate data reduction. During rendering, these proxy rays are accessed, and it becomes possible to visually analyze high-order FE models at interactive frame rates, even when they are time-varying or consist of multiple modalities. Within this paper, we provide the necessary background about the FE data, describe our decoupling method, and introduce our interactive rendering algorithm. Furthermore, we provide visual results and analyze the error introduced by the presented approach. Index Terms—Finite element visualization, GPU-based ray-casting.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p> The finite element (FE) method is a computational technique frequently applied in science, medicine, and engineering to solve partial differential and integral equations <ref type="bibr" coords="1,175.05,528.63,13.74,8.45">[39]</ref>. The technique enables the discretization of complicated domains into arbitrarily shaped elements , in which material properties can be defined using nodal parameters together with potentially high-order interpolation functions. Thus, it becomes possible to incorporate material properties at every point rather than a limited number of sample points. Possible applications include simulations of physical processes, derivation of new information from measured data, for example, computation of material strain from displacement data, or analyses and comparisons of data defined over objects with similar topology. All of these applications involve large amounts of multi-dimensional and multi-parametric data defined over arbitrary shaped grid structures. A prominent application example from bioengineering, in which FE visualization is essential, is the strain analysis of the human heart. An understanding of the full 3D strain tensor, represented by a symmetric matrix at each point, is necessary to identify unusual behavior of the heart muscle's deformation and to detect common patterns indicating developing diseases. Since there is little knowledge available about the exact behavior, interactive exploration plays an important role in the quest for new discoveries. By providing immediate visual feedback through rapid image generation , interactivity enables a rapid response to human input. In our case, it should be possible to interactively change all relevant visualization parameters, for example, parameter mapping and view orientation , such that the latency does not hinder the volumetric exploration process. While interactive surface-based visualizations of FE models are well established, volumetric visualization techniques supporting the interactive analysis of the entire structure are rare <ref type="bibr" coords="1,496.18,677.61,13.74,8.45" target="#b33">[35]</ref>. This is largely due to the fact, that accessing the materials defined over highorder basis functions, which needs to be done for each sample in a volumetric visualization approach, involves high computational com- plexity. </p><p> In this paper, we introduce an interactive volumetric ray-casting To enable interactive ray-casting of curvilinear FE models, we exploit a multi-stage preprocessing approach. In the first step, we compute representative curved rays in material space, which are represented as splines and transformed in the second step into a common coordinate system. To reduce the amount of data for the subsequent rendering stage, we apply a rotation invariant curve clustering in the third step. The resulting data is then passed to the GPU-based rendering stage, where ray marching is performed. gorithm for FE models that exploits ray coherency. When ray-casting FE models, viewing rays are straight lines in world space, but bent to curves in material (or ξ ) space. Consequently, each sample point on a straight viewing ray must be transformed during rendering onto the corresponding curve in material space before the FE data can be fetched. To avoid this computationally complex transformation, we exploit ray coherency within a curve clustering approach, and thus precompute a view-independent proxy representation of the curved rays that can be accessed efficiently during rendering. The workflow of our approach is shown in <ref type="figure" coords="2,99.20,325.02,28.69,8.45" target="#fig_0">Figure 2</ref> . In the first step we compute a representative subset of curved rays in material space, which are represented by splines. This subset is then reduced through clustering within the second curve compression step to obtain a lower number of curves, to which we refer as proxy rays. Assuming that the proxy rays sufficiently represent the coherent curves of a FE model, we can access them in the third step, the rendering step, where we can omit the expensive world-to-material space transformation. This allows us to enable volumetric FE model visualization of potentially multi-parametric FE models on modern graphics processing units (GPUs) at interactive frame rates (see <ref type="figure" coords="2,85.19,424.65,30.12,8.45">Figure 1</ref> ). As we achieve this interactivity by exploiting preprocessing algorithms and data structures accessed during rendering. The costs of our approach are increased precomputation times as well as memory consumption, which are discussed in more detail in Sections 7.3 and 7.4. While our current implementation is constrained to hexahedral FE models, we will discuss the implications for other cell types within Section 6. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p> Interactive high-quality rendering of FE models, incorporating the interior of the elements, is a demanding task. Often, the elements are resampled to lie on a common regular uniform grid <ref type="bibr" coords="2,213.53,536.59,13.74,8.45" target="#b33">[35]</ref>. While this enables a direct visualization using standard volume rendering algorithms , it also results in sampling-based errors as well as a loss of the easy access to element boundaries. As a consequence, many researchers have investigated rendering techniques that enable a more direct FE visualization by maintaining the relationship between the world and the material coordinate system. Wünsche introduced an isosurface-based approach for the visualization of biomedical tensor field data <ref type="bibr" coords="2,165.79,616.43,13.74,8.45">[37]</ref>, which has been applied to strain analysis. Another technique for rendering isosurfaces was presented by <ref type="bibr" coords="2,72.59,636.36,47.35,8.45">Nelson et al. </ref> in which they considered spectral highorder FE meshes and introduced the idea of an error budget <ref type="bibr" coords="2,255.71,646.32,13.74,8.45" target="#b25">[26]</ref>. Schroeder et at. developed a framework for isosurface rendering by tessellating the basis functions into simpler forms which improves the mesh quality <ref type="bibr" coords="2,71.77,676.21,13.74,8.45">[30]</ref>. Meyer et al. chose an approach based on particle systems to render isosurfaces efficiently <ref type="bibr" coords="2,167.86,686.17,13.74,8.45" target="#b22">[23]</ref>. An alternative to the isosurface-based method was presented by Brasher et al. <ref type="bibr" coords="2,73.73,706.24,10.45,8.45" target="#b3">[4] </ref>and Nelson et al. <ref type="bibr" coords="2,151.33,706.24,13.74,8.45" target="#b24">[25]</ref>, in which cut planes through the high-order finite element data are evaluated. Rose and Ertl proposed a texture-based mesh reduction approach in order to render surface representations of large FE models at interactive frame rates <ref type="bibr" coords="2,255.70,736.13,13.74,8.45" target="#b28">[29]</ref>. Other authors have proposed algorithms which exploit a conversion into a tetrahedral mesh representation <ref type="bibr" coords="2,422.87,245.32,14.19,8.45" target="#b27">[28,</ref><ref type="bibr" coords="2,439.41,245.32,11.21,8.45" target="#b19"> 20,</ref><ref type="bibr" coords="2,452.97,245.32,11.95,8.45" target="#b9"> 10] </ref> which, in comparison with regular grid sampling, allow for adaptivity. To improve rendering quality ray-casting approaches have been proposed . Garrity was one of the first to introduce ray-casting for rendering of unstructured meshes <ref type="bibr" coords="2,384.16,285.17,9.52,8.45" target="#b7">[8]</ref> . The technique is suitable for FE models as it tracks numerous entry and exit points of a ray from the cells which are stored in a hierarchical data structure. Hong and Kaufman incorporated the projection approach into ray-casting to speed up the ray traversal and interpolation <ref type="bibr" coords="2,394.89,325.02,13.74,8.45" target="#b13">[14]</ref>. They later improved their method by employing a projection of the elements' faces onto the image plane, which allowed them to compute ray intersection points for the ray traversal more efficiently <ref type="bibr" coords="2,380.41,354.91,13.74,8.45" target="#b14">[15]</ref> . A similar strategy for finding intersection points was used by Farias et al., who applied a space sweeping approach <ref type="bibr" coords="2,320.73,374.83,9.52,8.45" target="#b6">[7]</ref> . Grimm et al. performed the intersection point computation on the GPU <ref type="bibr" coords="2,353.06,384.79,13.74,8.45" target="#b10">[11]</ref>. Their hybrid CPU/GPU approach performs a layer peeling on the GPU while the actual ray-traversal is performed on the CPU. Martin et al. utilize a special representation of curvilinear space for transformation between physical space and computational space using a linear approximation <ref type="bibr" coords="2,412.37,424.64,13.74,8.45" target="#b20">[21]</ref>. Moreland and Angel presented a method based on a partial preintegration of the volume rendering integral and achieved interactive frame rates when rendering linear tetrahedral meshes <ref type="bibr" coords="2,475.23,454.53,13.74,8.45" target="#b23">[24]</ref>. Wiley et al. demonstrated a technique to perform ray-casting on quadratic curved elements, but did so without regard to interactivity <ref type="bibr" coords="2,469.70,474.45,13.74,8.45">[36]</ref>. This method could achieve interactive results on current machines but is limited to quadratic elements, which simplifies the inversion of the necessary coordinate transform. More recently, ¨ Uffinger et al. have presented a distributed visualization approach that allows volumetric visualization of models to be defined through high-order polynomials <ref type="bibr" coords="2,423.12,534.23,13.74,8.45" target="#b32">[34]</ref>. As in ours their approach is also based on ray-casting but, in contrast, they circumvent computation of the world-to-material space transformation by transforming the FE solution into a Cartesian reference space with barycentric coordinates . The FE interpolation is then replaced by a compact monomial representation, which the ray-casting kernel can use during sampling in physical space. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CURVILINEAR FINITE ELEMENT MODELS</head><p>While the concepts presented are, in theory, applicable to any FE model, they unfold their full potential when applied to FE models where the material space is defined through high-order basis functions. The curvilinear element examples presented in this paper employ cubic interpolation functions in each dimension, resulting in an interpolation function that is a degree-9 polynomial. In several domain areas, as for instance in bioengineering <ref type="bibr" coords="2,404.89,684.86,14.19,8.45" target="#b17">[18,</ref><ref type="bibr" coords="2,421.43,684.86,10.65,8.45"> 38]</ref>, the number of FE elements is relatively low and high-order interpolation functions are used. FE models are defined through two coordinate systems. The world coordinate system provides the position and orientation of the elements in space by defining a set of nodal points, x (e j ) , for each element e j . These nodal points can be arbitrarily oriented in space. The (a) world space (b) ξ space (c) world → ξ </p><formula>ξ i (1) = x (e j ) </formula><p>2,i , i = 1, 2, 3 be such that any point in the domain has a world coordinate x with an associated ξ coordinate . This association is provided by a set of mapping functions, φ i (ξ ). The dependent variables are almost always expressed in ξ coordinates, since ξ coordinates are independent of the element geometry and thus support the analysis of multi-parametric data and the comparison of different FE models. Thus, the dependent variables and the FE interpolation functions are defined in ξ space while the nodal points are defined in world space. This combination allows us to exploit the interpolation functions in order to compute variable values for all world space coordinates lying inside the model. The relevant mathematical concepts for FE modeling used in this paper are described in more detail in <ref type="bibr" coords="3,62.88,430.33,14.19,8.45">[38,</ref><ref type="bibr" coords="3,79.32,430.33,6.72,8.45" target="#b2"> 3,</ref><ref type="bibr" coords="3,88.28,430.33,11.21,8.45" target="#b31"> 33,</ref><ref type="bibr" coords="3,101.73,430.33,11.21,8.45" target="#b29"> 31,</ref><ref type="bibr" coords="3,115.18,430.33,10.65,8.45" target="#b15"> 16]</ref>. When visualizing such models world coordinates are usually more convenient to use, as they define the position and orientation of the elements. As soon as the dependent variables have to be accessed however, the ξ coordinates need also be taken into account as the dependent variables can only be accessed through transformation into ξ space. Thus, the world coordinate system can be used for finding ray intersection points with the elements, while the actual ray traversal is performed in ξ space. As can be seen in <ref type="figure" coords="3,178.99,510.66,29.10,8.45">Figure 3</ref>, this transformation affects the geometry of the viewing rays, which can end up as curves in ξ space. While the transformation from ξ space to world space can be computed fairly easy as x(ξ ) = ∑ n i=1 x i φ i (ξ ), for n nodal coordinates , x i , and basis functions, φ i , the inverse transformation required during ray-casting is computationally much more demanding. Numerical methods, for example the multi-dimensional Newton method <ref type="bibr" coords="3,264.71,570.44,13.74,8.45" target="#b26">[27]</ref>, which are often applied to perform this transformation, involve high computational complexity and thus are not feasible in an interactive context. Therefore alternative approaches are necessary to avoid the computational complexity of the world to ξ space transformation in the rendering stage of the visualization pipeline. different for each element within one FE model, elements are treated individually during preprocessing and rendering. Finding the desired dense and omnidirectional proxy ray population for an element can be performed in two ways. It can either be done adaptively, by analyzing the actual ray distribution within each element to find areas of high importance and create more rays for these areas, or in a uniform way over each element. As our algorithm is based on the inter-and intra-element coherency the latter distribution is sufficient since we assume a continuity between neighboring rays without high frequency changes. To obtain such a proxy ray distribution we exploit the intra-element coherency, which is the result of a high similarity between rays in ξ space that enter and exit an element through adjacent coordinates. Therefore we compute a dense and uniform distribution, P, of potential entry and exit points on the surface of each element. While these points should be distributed over the entire surface of an element, the requirements with respect to the uniformity of P are rather loose due to the intra-element coherency. We distribute the potential entry and exit points by performing an equidistant subdivision of all faces of an element. In this step the subdivision parameter, s f , controls the number of points equidistantly positioned along the u and the v coordinates of a face. Thus the density of P can be directly controlled by changing the subdivision parameter, s f . To reduce the number of initially generated proxy rays it would also be an option to vary s f based on the extents of a face in world space. In cases where an element is strongly deformed however, such that one face is much smaller than other faces, this usually indicates strong variations in the FE simulation which makes a higher sample density in world space necessary. Therefore we have decided to choose a constant, but sufficiently high, s f for the proxy ray generation. The actual proxy rays are then computed based on the resulting point distribution, P. To obtain proxy rays from P we consider all pairwise combinations (p , p ), with p , p ∈ P. During rendering a ray intersecting p and p would be a line in world space and a curve in ξ space. <ref type="figure" coords="4,64.25,392.74,30.05,8.45">Figure 3</ref>shows an example of 9 rays going from one point of a face to all points of the opposite face. When connecting p and p with a straight line, representing a viewing ray in world space, the proxy ray in ξ space can be obtained by sampling along the straight line and transforming each sample's position into ξ space. While this sampling is performed with a fixed but sufficiently high sampling rate s r , it should be pointed out that it does not represent or determine the sampling rate used later during rendering. s r is only used to obtain the geometry of the proxy rays, whereas the sampling rate used for the compositing during ray-traversal in the rendering step can still be chosen independently. As the set of proxy rays, R, has to be dense its size is obviously a limiting factor. Assuming that our subdivision parameter, s f , would result in n points along the u and the v coordinate of an element's face, we would have n 2 grid points on each face. Thus we would have n 2 · |F| grid points in total, assuming that each element has |F| faces. This would result in r t = (n 2 |F|) 2 proxy rays to be precomputed . Though we have kept s f constant to allow a less complex implementation of the ray-casting process, we have other possibilities to reduce the size of R. To achieve this reduction we exploit properties of the standard volume rendering integral which is used in the rendering stage: </p><formula>L(x, ω o ) = L 0 · e − x x 0 κ(x )dx + x x 0 c(x ) · e − x x κ(x )dx dx </formula><p>where c(x ) represents the emissive color at sample x and e </p><formula>− x x 0 κ(x )dx </formula><p>represents the exponential falloff between x 0 and x. When exploiting this rendering integral the same observations hold as when applying the integral within the context of regular volume rendering. For a ray cast through a medium the application of this integral results in an exponential falloff, i. e., when the ray is cast from one start point, x 0 , to one end point, x n , the samples in the regions surrounding x 0 will have considerably more influence on the image than those around x n . In extreme cases where structures with a high degree of opacity are rendered, samples close to x n do not have any influence at all. To select an optimal proxy ray subset during the precomputation stage we can take this observation into account. Therefore, we can use two different point distribution densities for entry and exit points, which is achieved by replacing s f with s f and s f . Thus we obtain a point distribution of higher density, representing ray entry points, and a point distribution of lower density, representing exit points. When considering all entry and exit points of these two distributions in a pairwise manner, we achieve an importance-based ray sampling, where rays are more accurately represented when being close to the entry points. In comparison with the r t rays computed with the uniform proxy ray distribution , the importance-driven ray reconstruction approach results in </p><formula>r i = (n f · |F|) · (n b · |F|) </formula><p>rays, where n f and n b represent the number of precomputed entry and exit points. This results in a decreased number of proxy rays, where the proxy ray set R is more dense towards the respective entry points and thus better complies with the exponential falloff which occurs during ray-casting. This works best for rather homogeneous parameters, while in cases where all features of interest are located close to the faces a uniform proxy ray distribution is beneficial. As s f should be high but independent of the sampling rate used during rendering, it is unfeasible to store the proxy rays based on the precomputed samples. Under the assumption that the proxy rays are well-behaved and at least C 1 continuous, we can reduce the memory footprint by storing the proxy rays as parametric curves facilitating a lower number of control points than the original sampling density, s f . We will present the ramifications of different numbers of control points for the error in Section 7. Due to the requirements regarding interpolation of the control points, local control, numerical stability, and non-complex evaluation, Catmull-Rom splines <ref type="bibr" coords="4,453.77,353.81,10.45,8.45" target="#b4">[5] </ref>are a natural choice for this parametric representation. Furthermore Catmull-Rom splines have built-in C 0 and C 1 continuity, thus being continuous in position as well as tangent vector, leading to a smooth curve. Additionally, Catmull-Rom splines allow us to obtain and interpolate the start and end tangent of the curved rays directly. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Curve Clustering</head><p>The curve compression, which is used to obtain a manageable set of proxy rays during rendering, first increases the similarity of the proxy rays by exploiting orientation and scaling invariance, before computing a representative subset using a clustering algorithm, whereby the increased similarity of the proxy rays allows us to compute a smaller subset of proxy rays while maintaining the same quality of compres- sion. Curve similarity. In the previous subsection, we have described how to obtain a densely populated set of proxy rays that are represented as parametric curves in ξ space. As this set is too large to be considered during rendering we will eliminate proxy rays from within this set by taking into account the following three observations which increase the similarity. First, a curve does not have a pre-defined entry and exit point order. As the ray traversal and the compositing are performed in the rendering stage we do not need to distinguish between two proxy rays with swapped entry and exit coordinates, if both rays are the same. The second helpful observation refers to the orientation of proxy rays in ξ space. As a proxy ray represents only the traversal path but not the dependent variables accessed during a traversal, we do not need to distinguish between two proxy rays which have the same overall geometry but are differently oriented in ξ space. As long as we know the entry and the exit point of a proxy ray we can orient the proxy ray's geometry such that it is correctly aligned in ξ space. This property is also related to the third observation, the length invariance, which we also exploit to increase the similarity during curve compression. As soon as we know the coordinates of the entry and the exit points we can not only adapt the orientation of a proxy ray but also its scaling. Therefore we do not have to distinguish between proxy rays which have the same geometry but differ only in the scaling factor along their principle axis. We exploit the three observations stated above in order to achieve a higher degree of similarity during the subsequent clustering-based curve compression. To do so we transform the proxy rays into a common coordinate frame without compromising the uniqueness of each proxy ray as they comply to orientation and scaling invariance. The transformation is done in such a way that the entry point and the exit point lie on the z-axis, with the proxy ray's principal axis aligning with the same axis (see <ref type="figure" coords="5,99.94,112.87,29.18,8.45">Figure 4</ref>). To be further able to define the rotation around this axis we take into account the first control point, c i , that is not colinear with the start and end points and transform the proxy ray such that c i lies in the yz-plane. If there is no such point, the proxy ray is a straight line so that it can be rotated to coincide with the z axis. After this transformation, M trans , has been applied all proxy rays lie in the same coordinate system as shown in <ref type="figure" coords="5,201.83,172.65,29.51,8.45">Figure 4</ref>, and thus the comparison performed during clustering produces a higher degree of similarity. While this transformation into a common coordinate system indirectly reduces the number of rays, it requires us to store the angle of rotation, θ , for each proxy ray. This is necessary as θ is required to be able to compute M trans −1 , which is needed during rendering to correctly orient the precomputed proxy rays. Curve clustering. To reduce the size of R we exploit the inter-and intra-element coherency discussed above. This allows us to perform clustering in order to obtain a representative subset of R, called R . Several algorithms have been proposed for clustering curves and we have decided to exploit the approach proposed by Abraham et al. <ref type="bibr" coords="5,269.18,282.79,9.52,8.45" target="#b0">[1]</ref>. As this approach applies the clustering to the curve coefficients instead of the control points, it can be proven that the derived cluster representatives are optimal candidates. As we have previously increased the curve similarity of the set of proxy rays, R, by transforming them into a common coordinate system, we can use a lower number of cluster representatives when using the clustering method. This reduces the data size as well as computation time needed for the clustering. We will show in Section 7 how the number of clusters affects the achieved quality of the clustering. Abraham et al. state that the comparison metric used during the clustering is the most crucial part, as it directly defines the similarity of two curves <ref type="bibr" coords="5,85.61,402.89,9.52,8.45" target="#b0">[1]</ref>. Inspired by their work we use the spanned area between two proxy rays as a metric. To compute the spanned area, we equidistantly sample the proxy rays with a high sampling rate, and generate a triangle strip between the sampling points. The similarity can then be expressed by a Riemann sum of the triangle areas. If we have two proxy rays, a and b, with their sampled points, a 1 ,...,a n and b 1 ,...,b n , where due to the transformation M trans , a 1 = b 1 and a n = b n holds true, we can calculate the approximate area between the rays. If x i y j denotes the vector from x i to y j , then the similarity of a and b is proportional to: </p><formula>2 · d(x, y) = a 1 a 2 × a 2 b 2 + n−2 ∑ i=2 a i a i+1 × a i b i + b i b i+1 × b i+1 a i+1 + a n−1 a n × a n−1 b n−1 , </formula><p>Although we could have used the closed solution for the two curves and compute the analytically correct solution, we wanted to use the same metric for non-parametric curves as well. The same metric presented here will be used in the error analysis, where no closed solution for the bent ray is available. For the actual clustering we exploit the k-means clustering algorithm which was originally presented by Hartigan <ref type="bibr" coords="5,211.23,646.47,13.74,8.45" target="#b12">[13]</ref> . It has the benefit that it is robust even with large high-dimensional data, and only needs the number of final clusters and a metric as parameters. Unfortunately the number of clusters is not known a priori and, in fact, there might be no definite answer as to which is the best number in general. To deal with this problem we have evaluated the impact of different numbers of clusters in Section 7. Alternatively, one could apply algorithms for finding an optimal number of clusters, such as for instance k-fold cross-validation, which is often used together with k-means. As output, k-means provides the desired number of representative proxy rays, one for each of the clusters. Besides the obtained cluster representatives we need to store for each proxy ray the cluster ID as well as the angle θ The cluster ID is used to determine the cluster to which it belongs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">BENT RAY-CASTING</head><p>While Section 4 gives a comprehensive overview of the preprocessing steps needed to obtain the proxy ray set, R, and the clustered set, R , the actual rendering process is discussed in detail within this section. We perform GPU-based ray-casting by exploiting the data generated during the preprocessing stage, i.e., all cluster representatives as well as a list, for each proxy ray, storing the associated cluster ID and the rotation angle θ . As the elements are treated individually we need a way to be able to associate ray segments with the elements. Thus the rendering stage is divided into three substages. First element peeling which allows us to obtain the entry and exit points for each element. Second ray marching, where a ray in ξ space is reconstructed from the preprocessed data before it is traversed. Third ray interpolation, which is used to be able to deal with less dense proxy ray sets R. These three substages are discussed in the following three subsections. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Element Peeling</head><p>As the FE models consist of several elements they will, in general, overlap in image space. Therefore mechanisms are needed to determine which sequence of proxy rays best represents a specific pixel. To obtain this sequence of proxy rays we employ a modified depth peeling approach <ref type="bibr" coords="5,329.72,316.54,13.74,8.45" target="#b18">[19]</ref>. With this approach we can peel away, layer-by-layer, from the rendered FE model by using an additional depth comparison. When using depth peeling however, it is crucial to be able to distinguish between different fragments solely based on their depth values. Unfortunately, in our case this is not possible. As a FE model consists of several adjacent and touching elements, coinciding depth values are common and need to be handled robustly. As illustrated in <ref type="figure" coords="5,511.64,376.31,29.50,8.45">Figure 5</ref>, two cases of depth coincidence occur. Point coincidences occur at the corners of adjacent elements (top) and surface coincidences occur where two adjacent elements' surfaces are touching (bottom). To deal with this issue we have implemented multi-layer depth peeling, where we take advantage of several attributes to resolve the depth coincidences without introducing errors. <ref type="figure" coords="5,432.81,436.09,29.97,8.45" target="#fig_4">Figure 6</ref>shows the information employed next to the color coded ξ and world space coordinates of the first two layers of a FE model. Besides the depth values we also take into account the current element's ID, as well as the ID of the current face in our peeling approach. Thus we can resolve the described coincidence cases and retrieve the entry and exit points for the current view ray segment. This allows us to fetch the cluster representative for this pair (see Section 6) and perform the ray marching. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Ray Marching</head><p>Once we know which proxy ray information needs to be accessed, we can reconstruct its ray geometry by retrieving the spline coefficients for the obtained cluster ID. The reconstructed spline is then transformed back from the canonical orientation along the z-axis by applying M trans −1 , such that the spline lies between the entry-and the <ref type="figure" coords="5,310.20,696.23,3.32,8.60">5</ref>. Two cases of depth coincidence can occur, as illustrated (left), when rendering adjacent polygons. Point coincidence occurs at the corners of adjacent elements (top), while surface coincidence occurs at the touching elements' surfaces (bottom). All coincidences can be avoided (right). (a) Precomputed proxy rays with s f = 2 (b) Precomputed proxy rays with s f = 10 <ref type="figure" coords="6,22.50,427.99,19.18,8.60">Fig. 7</ref>. Results of our approach with two different parameter sets. The first row shows a precomputation with a grid parameter of s f = 2 and the second with s f = 10. Within each row we show the application of standard ray interpolation (left) as well as intra-and inter-ray interpolation (right). As shown in the close-ups, intra-and inter-ray interpolation reduces noticeable artifacts. Artifacts are still noticeable with 2 × 2 proxy rays, as shown in (a, right). exit-point of the actual viewing ray in world coordinates. Although the reconstructed spline is similar for pixels in a local neighborhood, the specific path is different because it is fitted to the specific entry and exit-point combination of the viewing ray. Once the proxy ray has been transformed back into its original location we can march along it and perform the actual bent ray-casting by fetching the dependent variables from the ξ space using our spline representation. The expensive world-to-material transformation that would be necessary in the straightforward approach is replaced by an evaluation of the precomputed spline representation. To ensure that we consider possible high-frequencies in the material data, we need to ensure an equidistant sampling along the reconstructed ray in material space in order to obtain optimal results. The proxy rays, however, are parameterized by the parameter value t ∈ <ref type="bibr" coords="6,35.09,654.28,9.45,11.66">[0,</ref><ref type="bibr" coords="6,45.54,656.43,6.97,8.45" target="#b0"> 1] </ref>in world coordinates which does not take the shape of the ray in ξ space into account, i.e., given a spline s, </p><formula>s(x) − s(y) = x − y. </formula><p>That means that an equidistant sampling in world space will result in sampling points that are not equidistant along the curve in ξ space. As illustrated in <ref type="figure" coords="6,82.67,696.28,29.19,8.45" target="#fig_6">Figure 8</ref>(a), we address this problem by using an arc length parametrization as presented by Guenter and Parent <ref type="bibr" coords="6,236.31,706.24,13.74,8.45" target="#b11">[12]</ref>. This leads to a function t → t . If the sampling is done using t instead of t, the sampled values will be equidistant along the curve in ξ space. To ensure accuracy w.r.t. the rendering integral, we employ the equidistant spacing in ξ space to access the dependent variables, but use the distance in world space for the opacity computation. The subdivision of a curve ray penetrating the whole FE model into segments, based on the penetrated FEs, requires an appropriate border handling scheme. If we sample the ray equidistantly, in a na¨ıvena¨ıve way, the last point on the ray, which lies on the exit face of a FE, will, in general, not coincide with an intended sampling point. Special consideration is needed when handling a ray, a, that is divided into two segments, r and s, in such a way that r n = s 0 , i. e., the last sample point of r is the first sample point of s. In this situation we would have an equidistant sampling rate of |a i − a i+1 | = δ for the two rays. However, the na¨ıvena¨ıve implementation will result in |r n−1 − r n | = δ . To remedy this, we do not sample the last point on each ray but save the distance |r n−1 − r n | instead and use it as an offset for the first sampling point in the next ray segment (see <ref type="figure" coords="6,408.12,193.38,29.01,8.45" target="#fig_6">Figure 8</ref>(b)). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Ray Interpolation</head><p>In order to improve the image quality of our ray-casting approach, we introduce two specialized interpolation schemes: inter-ray interpolation and intra-ray interpolation. With the inter-ray interpolation we use the four nearest proxy rays instead of the " nearest-neighbor " proxy ray for a given pixel position, and interpolate between them. This interpolation is carried out by using bilinear interpolation at every sample position along the viewing ray. The interpolation factors for these bilinear interpolations are based on the factors derived for the entry and the exit face. The intra-ray interpolation, instead, employs swapping of entry and exit points in order to obtain a mirrored copy of the current ray. Thus we can interpolate between the original ray at position t and the mirrored ray at position t = 1 − t while traversing the initially obtained ray. Both of these interpolation schemes improve the image quality in situations where only a low resolution is available, as we show in <ref type="figure" coords="6,337.69,368.77,29.02,8.45">Figure 7</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">IMPLEMENTATION</head><p> In this section, we explain all relevant implementational details regarding concepts mentioned previously. Proxy Ray Generation. In order to have a consistent memory layout we will use the same data structure to store the computed control points here as we will use later in the rendering stage. There are two demands on the data structure: given the parameters for the stored value, access should be in O(1) and it should have a rectangular structure to be efficiently usable at GPU level. The parameters necessary for describing each proxy ray uniquely are </p><formula>(e, f s , f e , p s , p e )</formula><p> , with e being the element number, p s the position on the entry face, f s , and p e the position on the exit face, f e . Let |E| denote the total number of elements and |F| be the number of faces per element. Furthermore, recall that s f and s f , as defined in Section 4.1, are the subdivision parameters that control the number of points on the entry and exit face respectively. It then holds true that To achieve equidistant sampling along a ray in ξ space (top), an arc length parametrization is applied resulting in a non-uniform sampling in world space (bottom). (b) Rays penetrating multiple elements must be processed such that constant sampling step sizes are obtained at the borders. The overshoot, e, of the first element can be used to offset the first sampling point in the next element. <ref type="figure" coords="7,31.50,136.51,19.61,8.60">Fig. 9</ref>. Memory layout used to gain access to the precomputed proxy ray information. To retrieve the information required during rendering in constant time, a hierarchical subdivision is used. For each proxy ray, we store the cluster ID as well as the rotation angle θ . <ref type="figure" coords="7,31.50,178.02,30.83,8.45">Figure 9</ref> shows the memory layout that we have chosen for this setting . At the highest level of the hierarchy we arrange the data based on f s along the x-axis and e along the y-axis. Thus we obtain |F| · |E| cells which contain the precomputed information for rays entering e through f s . Each of these cells is partitioned based on the f e along the x-axis, such that the resulting cells contain only the information for those rays exiting through f e . We again partition the cells based on the number, s f , of precomputed points on the entry face. Finally the obtained cells are partitioned based on the number, s f , of precomputed points on the exit face. The memory layout depicted here is represented by the two following equations which allows us to store all data in a rectangular manner: </p><formula>p f ∈ [0, s f ] and p e ∈ [0, s f − 1]. </formula><formula>p x = (f s · (s f · s f · |E|)) + ( f e · (s f · s f )) + (p s,x · s f ) + p e,x (1) p y = (e · (s f · s f )) + (p s,y · s f ) + p e,y (2) </formula><p>Curve Similarity. The first step here is to increase the similarity of the stored proxy rays in such a way, that the subset, R , is as small as possible. Three transformations are performed after which each proxy ray fulfills three traits. 1. The starting point, x 0 , is at (0, 0, 0). 2. The first non-colinear point x i lies in the yz-plane. 3. The end point, x n , is at (0, 0, 1). We apply three matrices M t , M rot , and M s to all control points, where M t is a translation by −x 0 , M s is a scaling by 1/(x n .z), and M rot is a rigid-body transformation that will rotate the points such that x n is on the z axis and the non-colinearity is fulfilled. The multiplication M s · M rot · M t is equal to M trans as mentioned previously. Thus we get new control points </p><formula>x = M s · M rot · M t · </formula><p>x with a higher degree of similarity between proxy rays. By enforcing that x i lies in the yz-plane we lose the rotational angle w.r.t. the z-axis. We will store this angle θ for each proxy ray separately so that we can access it together with the cluster id. Curve clustering. In order to reduce the number of proxy rays which need to be stored on the graphics card, we apply a clustering algorithm such that multiple rays are represented by a single representative. Finding a good number of iterations for the applied K-means algorithm a priori is a hard problem, so we investigated multiple strategies. The simplest, and already feasible, strategy to use is a fixed number of iterations (see <ref type="figure" coords="7,80.06,556.55,33.32,8.45" target="#fig_12">Figure 13</ref>(b)). Another possible solution is to trace the percentage of splines that change clusters in a single iteration, based on the assumption that this number decreases asymptotically to 0. A CPU implementation using C++ and OpenMP was used to generate the measurements presented in Section 7. The clustering was performed on 8 threads and it was found that the hard disk access, as well as the computing power, are bottle necks for faster execution times. Additionally , an OpenCL-based implementation was tested that keeps the cluster representatives for the current iteration in local memory and fetches the splines from global memory. Ray Marching. The rendering step starts with a depth peeling step to get the entry-and exit points for each view ray. In general we set the additional depth test to accept all fragments which have a greater depth than or equal to that of the current fragment. To resolve the two coincidence cases, as presented in Section 5.1, we ensure that each pair of entry-and exit-points has the same element ID. This, together with ensuring different face IDs, is enough to correctly resolve the point and the surface coincidence (see <ref type="figure" coords="7,152.58,726.17,29.47,8.45">Figure 5</ref> ). This additional information also leads to a more stable algorithm w.r.t. the available accuracy of the depth buffer. We tested depth buffer accuracies of 16 and 24 bits but found no noticeable visual differences. The approach also works for several situations where the entry and exit points lie on the same surface, as these points in general have unequal depth values thereby making the test for face inequality unnecessary. In the case of a silhouette edge, where two fragments coincide in the same depth value and originate from the same element, we do not perform a depth peeling but transform only the entry point and obtain a single sample. The geometry representation of the FE models contains 4 values for each node; the three color channels provide the ξ value (see <ref type="figure" coords="7,529.56,433.22,14.95,8.45;7,294.12,443.18,21.19,8.45" target="#fig_4">Fig- ures 6</ref>(b) and (g)) and the alpha channel stores the element for which the nodal value is defined (see Figures 6(d) and </p><p>(i)). Based on this information, all free parameters for Equations 1 and 2 can be derived. Thus, the cluster can be fetched for this entry-exit point pair and the ray marching can be performed on the spline. Element Generalization. The examples in this paper all use elements with cuboidal parent elements. In order to apply the technique to differently shaped elements, e.g., tetrahedral elements, methods must be implemented for depth peeling and sampling the element faces. This is straight forward. In fact, the current implementation already works for differently shaped elements, e.g. where multiple vertices of the parent element are mapped to the same vertex in world coordinates. This is the case for the apex of the left ventricular model, where the resulting elements have a curved wedge-like shape. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS</head><p> To assess the quality and the performance of the proposed visualization technique we have applied it to different data sets. Below we discuss the visual results, the introduced errors and, the performance of our approach as well as the memory requirements. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Visual Results</head><p>To demonstrate the visual outcome of the proposed concepts, we have applied them to different FE models which all consist of elements with curvilinear boundaries. These vary with respect to the number of cells and the order of the used interpolation functions. Although we include only interpolation functions of a degree-7 or 9 polynomial, our method is not limited to any specific order as long as the requirements, as stated in Section 4, are fulfilled. In the following paragraphs we describe these models and the visual results achieved. Breast model. We have applied our approach to a deformation model of a breast data set, consisting of 60 tricubic elements, acquired from an MRI scan. The dependent variables in this case are the actual intensities of the MRI field, and the FE modeling has been applied to predict the supine shape of the data set originally acquired in the prone position. <ref type="figure" coords="8,59.10,356.05,35.52,8.45" target="#fig_8">Figure 10</ref> shows a comparison of the supine position rendered with our interactive volumetric approach, (b), as compared with a standard surface based representation, (a). Tongue model. Furthermore we have applied our approach to a model of a human tongue, consisting of 64 tricubic elements, with simulated tissue densities and muscle fiber directions. In this case each node stores one coordinate vector, and seven derivatives and mixed derivatives for the tensor product of the cubic Hermite interpolation functions in all three coordinate directions. The results, as compared with a polygonal representation, are shown in <ref type="figure" coords="8,176.43,445.82,34.16,8.45" target="#fig_10">Figure 11</ref>. In this case in particular, the multi-parametric capabilities of our algorithm are beneficial as the tongue model contains a relatively high number of parameters . When one would apply resampling to all of these parameter volumes instead, this would result in an unmanageable amount of data for a reasonable resolution. Heart model. A heart data set, which consists of 16 bicubic-linear elements (i.e. two interpolation functions are of cubic order, the other one is linear), where the strain values for each point have been computed from displacements obtained from tagged MRI data, serves as the third example (see <ref type="figure" coords="8,72.59,545.56,29.35,8.45">Figure 1</ref> ). For our visualization we have taken into account the three principal strain directions, which are the eigenvalues of the tensor. The principle strains include the maximum and minimum deformation and the corresponding eigenvectors give the direction of these deformations. These directions are circumferential, longitudinal and radial. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Error Analysis</head><p> Our rendering approach contains several steps which potentially introduce visual errors. First, the proxy ray generation explained in Subsection 4.1 introduces an error based on the number of actual proxy rays. The visual impact of this error is analyzed in <ref type="figure" coords="8,181.50,656.43,28.61,8.45">Figure 7</ref>. In the two rows, different numbers of proxy rays have been computed. In the top row a very low number, with 2 × 2 proxy rays, per element face has been chosen whereas the bottom row uses 10 × 10 proxy rays. As can be seen, the error introduced by a low number of proxy rays is clearly visible . However, when using 10 × 10 proxy rays no artifacts are visible when using the proposed ray interpolation mechanism. As the clustering itself also introduces an error, we have analyzed the impact in <ref type="figure" coords="8,22.50,736.13,33.05,8.45" target="#fig_12">Figure 13</ref>(b), which shows the error for a varying number of clusters. </p><p> (a) straightforward ap- proach (b) our approach (c) visual difference (emphasized 10 times) It is obvious that the error becomes smaller if we use more clusters. The number of clusters can, depending on data set, be quite low in relation to the number of proxy rays as seen in <ref type="figure" coords="8,461.13,247.29,33.41,8.45" target="#fig_12">Figure 13</ref>(c). While these two analyses show the error for the proxy ray computation and the clustering separately, we have also compared the results achieved by our algorithm with the ground truth, a straightforward raycaster as described in Section 4, which evaluates the world-to-ξ transformation during each sample step. We chose this method as a comparison, because it produces the smallest error by itself and is thereby suited to demonstrate the error introduced by our method. As can be seen in <ref type="figure" coords="8,285.12,326.99,32.98,8.45" target="#fig_0">Figure 12</ref>, the visual error is rather low, as only a tenfold exaggeration of the generated error image makes it noticeable. We described in Section 4.1 that we can use a varying number of control points to represent the proxy ray. This, of course, is an approximation of the original bent ray we get by using the straightforward implementation. Therefore we analyze the effect of this parameter has the error introduced by the representation. <ref type="figure" coords="8,464.04,387.30,34.45,8.45" target="#fig_12">Figure 13</ref>(a) shows this error, computed by comparing the spline representation to the ray where each sample point is transformed. We sampled every ray at a sufficiently high rate of 1024 points and computed the area metric as described in Section 4.2. The abscissa shows the number of control points representing the proxy ray, where 2 points denote a straight line. For easier comparison, all error values were normalized with respect to this value. As the error is dependent on the shape of the FE, we computed the error for all proxy rays in the Heart and Tongue models. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Performance Analysis</head><p> We have to differentiate between the precomputation and the rendering step in the performance analysis. Although the time used for precomputation is dependent on both the proxy ray computation and the clustering, the latter takes more time than the former. In our <ref type="figure" coords="8,285.12,564.49,25.67,8.60" target="#tab_1">Table 1</ref>. Performance analysis (in fps) of our technique for different grid sizes compared with a straightforward (SF) implementation. The setups match the first three subfigures in <ref type="figure" coords="8,439.40,583.42,29.35,8.60">Figure 1</ref>: images showing radial strain, circumferential strain, and longitudinal strain. (a) Error introduced by approximating the bent ray by a spline (b) Error introduced by clustering (c) Image error measured for varying cluster sizes shows the error for varying numbers of clusters depending on the number of iterations after which the k-means algorithm has stopped. Based on the heart data set with a grid resolution of 5 × 5, which resulted in 360.000 rays. (c) shows the normalized absolute pixel error (background pixels are neglected) plotted against the percentage of clusters relative to the total amount of curves. The calculations have been performed on the subfigures of <ref type="figure" coords="9,454.59,248.69,28.11,8.60">Figure 1</ref>, thus varying the transfer function and strain direction. All error values were normalized w.r.t. the respective highest error. </p><p>mized CPU implementation, the clustering for a 5 × 5 proxy ray setup with 8192 clusters takes roughly 4-6 hours, while a 15 × 15 setup with 8192 clusters takes approximately 72-84 hours of time. We managed to reduce this time with an unoptimized OpenCL implementation by an order of magnitude to about 20-25 minutes for the 5 × 5 proxy ray setup with 8192 clusters, which is in line with former works <ref type="bibr" coords="9,248.01,340.01,13.74,8.45" target="#b21">[22]</ref>. The clustering and all performance tests were executed on an Intel Xeon Quad-Core 3.06 GHz with 6 GB of working memory, equipped with a Geforce 580 card with 1 GB of memory. <ref type="figure" coords="9,41.46,380.78,26.23,8.45" target="#tab_1">Table 1</ref> shows the rendering performance of the presented volumetric FE visualization technique, as compared with the straightforward volumetric GPU implementation. As can be seen, the performance of our technique is affected by image resolution and independent of the number of clusters and proxy rays. The rendering quality is thus affected by a trade-off between the number of proxy rays used during the precomputation and the number of clusters used during the curve compression. In the worst case tested our technique provides above 7 fps instead of 0.4 fps. While the 14.81 fps achieved with our method in the best tested case enabled full interactivity, the 7 fps also resulted in an interactive experience. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Memory Requirements</head><p> A limiting factor of the presented method is the memory that is required to store the proxy rays, angles and cluster IDs. Besides the computational time, the available graphics memory is the only limitation to the number of elements, grid resolution, and number of clusters. In this section, we will consider the impact of each of these factors on the memory requirements using the same definitions as in Section 6 with the addition of c as the number of clusters. The total number of rays per element is given by </p><formula>r t = (s f · s f · |F|) 2 which leads to e · r t · s r </formula><p>points that have to be transformed and stored. It should be noted that this data does not need to fit on the graphics card and is only an termediate result. The required memory after the clustering has been performed can be estimated by: </p><formula>c · s r + e · r t · 2. </formula><p>The first part of the equation is the storage necessary for the clustered control points of the representatives. The second part is the lookup table as described in Section 5.1 and needs to store both the cluster ID as well as the angle. A significant restriction on our method is obvious in the latter formula . The second term grows linearly in the number of elements and poses, therefore, a limitation on the mesh sizes we are able to render. Example values for the heart are given in <ref type="figure" coords="9,449.58,369.90,26.07,8.45" target="#tab_2">Table 2</ref>, when we assume float precision, i.e., every point will occupy 12 bytes of memory, and 5 stored points per cluster. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="2,22.50,174.92,513.02,8.60;2,22.50,184.39,513.00,8.60;2,22.50,193.85,513.00,8.60;2,22.50,203.31,383.50,8.60"><head>Fig. 2. </head><figDesc>Fig. 2. Workflow. To enable interactive ray-casting of curvilinear FE models, we exploit a multi-stage preprocessing approach. In the first step, we compute representative curved rays in material space, which are represented as splines and transformed in the second step into a common coordinate system. To reduce the amount of data for the subsequent rendering stage, we apply a rotation invariant curve clustering in the third step. The resulting data is then passed to the GPU-based rendering stage, where ray marching is performed. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="3,31.50,163.45,250.38,10.36;3,31.50,173.73,250.38,8.60;3,31.50,182.38,249.37,10.36;3,31.50,192.66,250.38,8.60;3,31.50,202.13,224.25,8.60"><head>Fig</head><figDesc>Fig. 3. Transforming straight rays given in world space, (a), to ξ space, (b), causes these rays to be curved. View rays that are parallel and similar in world space, (c,left), will be projected to similar curves in ξ space, (c,right). The dots show the points used for calculating the proxy rays shown, with the dotted lines emphasizing the relevant face. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="5,294.12,696.23,250.38,8.60;5,294.12,705.70,250.37,8.60;5,294.12,715.16,250.38,8.60;5,294.12,724.62,250.38,8.60;5,294.12,734.09,23.03,8.60"><head>Fig. </head><figDesc>Fig. 5. Two cases of depth coincidence can occur, as illustrated (left), when rendering adjacent polygons. Point coincidence occurs at the corners of adjacent elements (top), while surface coincidence occurs at the touching elements' surfaces (bottom). All coincidences can be avoided (right). </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4" coords="6,22.50,192.00,250.38,8.60;6,22.50,200.64,250.38,10.36;6,22.50,210.92,250.38,8.60;6,22.50,220.39,250.38,8.60;6,22.50,229.85,18.69,8.60"><head>Fig. 6. </head><figDesc>Fig. 6. Depth peeling is used to extract the layers of the FE model during rendering. The images show the world coordinates, the ξ coordinate, its depth, the element ID, and the face ID (from left to right). The first row shows the first depth layer and the second row shows the second depth layer. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6" coords="6,285.12,685.83,250.38,10.36;6,285.12,696.12,250.38,8.60;6,285.12,705.58,250.38,8.60;6,285.12,715.05,250.38,8.60;6,285.12,724.51,250.38,8.60;6,285.12,733.98,172.97,8.60"><head>Fig. 8. </head><figDesc>Fig. 8. (a) To achieve equidistant sampling along a ray in ξ space (top), an arc length parametrization is applied resulting in a non-uniform sampling in world space (bottom). (b) Rays penetrating multiple elements must be processed such that constant sampling step sizes are obtained at the borders. The overshoot, e, of the first element can be used to offset the first sampling point in the next element. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8" coords="7,294.12,282.79,250.39,8.60;7,294.12,292.26,250.38,8.60;7,294.12,301.72,250.39,8.60;7,294.12,311.19,47.40,8.60"><head>Fig. 10. </head><figDesc> Fig. 10. FE breast model with MRI material space rendered as surface representation showing the deformed and the undeformed surface (a), and showing the deformed volume with our interactive volumetric approach (b). </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10" coords="8,22.50,264.62,250.38,8.60;8,22.50,274.09,198.96,8.60"><head>Fig. 11. </head><figDesc>Fig. 11. FE tongue model rendered as a polygonal representation, (a), and with our interactive volumetric approach, (b) and (c). </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11" coords="8,285.12,165.84,250.38,8.60;8,285.12,175.31,250.39,8.60;8,285.12,184.77,250.38,8.60;8,285.12,194.24,75.43,8.60"><head>Fig. 12. </head><figDesc>Fig. 12. Visual error as obtained when applying our technique. A straightforward volumetric approach (a) and our interactive volumetric approach (b) have been compared, which results in the error image exaggerated tenfold (c). </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12" coords="9,31.50,210.83,513.00,8.60;9,31.50,220.29,513.00,8.60;9,31.50,229.76,513.01,8.60;9,31.50,238.40,513.00,10.36;9,31.50,248.69,513.00,8.60;9,31.50,258.15,364.41,8.60"><head>Fig. 13. </head><figDesc>Fig. 13. Error measurements. (a) shows the error introduced by the approximation of the correct bent ray by sampling a spline. The abscissa shows the number of control points used to construct the spline, where 2 points represent a straight line. (b) shows the error for varying numbers of clusters depending on the number of iterations after which the k-means algorithm has stopped. Based on the heart data set with a grid resolution of 5 × 5, which resulted in 360.000 rays. (c) shows the normalized absolute pixel error (background pixels are neglected) plotted against the percentage of clusters relative to the total amount of curves. The calculations have been performed on the subfigures of Figure 1, thus varying the transfer function and strain direction. All error values were normalized w.r.t. the respective highest error. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false" coords="3,31.50,163.45,250.39,154.53"><figDesc coords="3,41.47,163.45,240.42,10.36;3,31.50,173.73,250.38,8.60;3,31.50,182.38,249.37,10.36;3,31.50,192.66,250.38,8.60;3,31.50,202.13,224.25,8.60;3,54.80,288.25,3.49,6.57;3,58.78,283.10,7.90,11.66;3,66.68,288.25,3.49,6.57;3,70.67,283.10,7.90,11.66;3,78.57,288.25,3.49,6.57;3,84.93,283.10,196.95,11.66;3,31.50,295.21,250.39,8.45;3,31.50,308.38,80.91,9.60">. 3. Transforming straight rays given in world space, (a), to ξ space, (b), causes these rays to be curved. View rays that are parallel and similar in world space, (c,left), will be projected to similar curves in ξ space, (c,right). The dots show the points used for calculating the proxy rays shown, with the dotted lines emphasizing the relevant face. 1 , ξ 2 , ξ 3 ∈ [0, 1] as basis for a right-handed coordinate system. The world and material coordinate systems are connected by requiring each element, e j , with</figDesc><table coords="3,31.50,233.28,250.38,61.47">second coordinate system is the the material, or ξ , coordinate system 
which defines elements using simple geometric shapes, such as tetra-
hedra, prisms, pyramids, or unit cubes, which are decoupled from the 
actual geometry. The examples in this work are constructed based on 
unit cubes. In this case, the material coordinate system is cartesian 
with ξ </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true" coords="9,31.50,642.55,250.39,88.68"><figDesc coords="9,31.50,642.55,250.39,8.60;9,31.50,652.01,240.86,8.60">Table 2. Memory consumption of data structures during rendering for varying grid resolutions and number of clusters on the heart dataset.</figDesc><table coords="9,56.18,672.33,201.01,58.90">s f 
Without 
With Certain Number of Clusters 
Clustering 
512 
2048 
4096 
3 
2.7 MB 
0.39 MB 
0.47 MB 
0.82 MB 
8 
135 MB 
18 MB 
18.1 MB 
18.5 MB 
10 
329 MB 
43.9 MB 
44.0 MB 
44.1 MB 
15 
1.62 GB 
222.5 MB 222.6 MB 222.9 MB 

</table></figure>

			<note place="foot" n="4"> COHERENCY-BASED CURVE COMPRESSION In this section we present the basis for a novel ray-casting based algorithm for the interactive exploration of curvilinear FE models. The straightforward approach for ray-casting FE models would be to march along a ray in world space and transform each world space sample coordinate, x, into its corresponding material coordinate, ξ , before accessing the dependent variables. As shown in Table 1, this approach is computationally very demanding and therefore cannot, in general, be performed at interactive frame rates. By using our approach we are able to shift this, originally view-dependent, computation from the rendering stage into the data processing stage of the visualization pipeline. Thus, we can reduce the computational load during rendering and achieve interactive frame rates when volume rendering curvilinear FE models. To perform the desired shift from the rendering stage into the data processing stage, we exploit the following key observations about the degree of coherency of curvilinear FE models. FE method grids are designed to minimize approximation errors in the solution and to ensure convergence. In particular the Jacobian of the world-to-material coordinate mapping must not contain any singularities, and the grid resolution needs to be high enough that variations of the unknown variables can be approximated adequately with the underlying FE basis functions [17]. This implicit smoothness constraint is exploited in our technique since it also limits the shape variations of neighboring rays in world coordinates mapped into ξ space, i. e., we can assume some degree of intra-element coherency between adjacent rays. Because the Jacobian does not contain singularities we can employ the Newton method, or similar solvers, to compute the inverse of the world-to-material coordinate mapping. Many FE applications also require some degree of inter-element compatibility, and some degree of symmetry and self-similarity. These characteristics result in a FE mesh with clusters of similar elements, and hence some degree of inter-element coherency. Figure 3 (c) illustrates this coherency as it shows the shape of rays in ξ space (right), which adjacently traverse world space (left). In addition, coherency is supported as most models in practical applications need well-behaved elements, i.e. low distortion and an aspect ratio close to one, in order to result in a stable numerical simulation . The approach presented uses precomputation, which is performed within two preprocessing steps as shown in Figure 2. In the first step, we compute a high number of proxy rays in ξ space. These proxy rays act as a view-and resolution-independent spline representations of the actual viewing rays that are cast through the ξ space during rendering. In the second step, we exploit inter-and intra-element coherency to reduce the vast number of proxy rays to a representative subset, which is then used during GPU-based ray-casting in the third step. By exploiting the precomputed data FE models can be explored interactively by changing the transfer function and other rendering parameters . The following two subsections describe the two preprocessing steps, while the GPU-based ray-casting is discussed in Section 5. 4.1 Proxy Ray Generation To be able to compute a complete set, R, of proxy rays, it is essential that it covers all parts of the FE model. This means that both the world and the ξ space are densely populated with straight and curved rays, respectively. However, since the view direction used during rendering affects the ray traversal direction and the proxy rays are directional, it is not sufficient that all positions within an element are close to a single proxy ray; they must also be close to proxy rays having different directions . As the interpolation functions in ξ space can, in principle, be Fig. 4. To achieve a higher degree of similarity during the curve clustering we exploit the orientation invariance of the proxy rays and transform them into a common coordinate system where the principal curve axis coincides with the z-axis. Furthermore we exploit scale invariance to align all exit points.</note>

			<note place="foot" n="8"> CONCLUSIONS &amp; FUTURE WORK In this paper we have presented a ray-casting based approach that enables the interactive exploration of high-order FE models. By shifting the computationally complex world-to-material transformation from the rendering stage into a preprocessing stage we are able to achieve interactive frame rates and thus allow for an interactive, in-detail, multi-parametric inspection of FE models using transfer functions and other parameters on standard GPUs. We have demonstrated the outcome of the presented approach by applying it to several real-world data sets and analyzing the errors introduced by our approach. Furthermore , we have discussed the rendering performance gain as well as the memory requirements. There are several opportunities to further improve the presented concepts in the future. When precomputing the proxy rays we currently use a equidistant layout for the generation of the set, P, of uniformly distributed start and end points. In comparison with such an equidistant layout more elaborate sampling schemes, as used in many areas of computer graphics, might lead to an improved quality with the same number of proxy rays. While our approach currently supports scalar data only, in the future we plan to use the proposed method to display vector and tensor data defined over ξ space. ACKNOWLEDGMENTS We thank all reviewers for their fruitful comments which helped to greatly improve this paper. We would also like to thank Martyn Nash, Poul Nielsen, and Alistair Young for providing the data sets we used in this work, and Matt Cooper for proof reading. This work was partly supported by grants from the Swedish Research Council (VR, grant 2011-4113), the Excellence Center at Linköping and Lund in Information Technology (ELLIIT) and the Swedish e-Science Research Centre (SeRC). The presented concepts have been realized using the Voreen open source visualization framework (www.voreen.org).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct coords="10,40.76,75.57,232.12,7.51;10,40.76,84.88,232.12,7.66;10,40.76,94.50,60.00,7.51"  xml:id="b0">
	<analytic>
		<title level="a" type="main">Unsupervised curve clustering using b-splines</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Abraham</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Cornillion</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Matzner-Løer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Molinari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scandinavian Journal of Statistics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="581" to="595" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,103.96,232.12,7.51;10,40.76,113.27,232.12,7.66;10,40.76,122.89,65.30,7.51"  xml:id="b1">
	<analytic>
		<title level="a" type="main">Geometric modeling of the human torso using cubic hermite elements</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bradley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Pullan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Hunter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Biomedical Engineering</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="111" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,132.35,232.12,7.51;10,40.76,141.67,214.14,7.66"  xml:id="b2">
	<analytic>
		<title level="a" type="main">Rendering planar cuts through quadratic and cubic finite elements</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brasher</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Haimes</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="409" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,151.13,232.12,7.66;10,40.76,160.59,100.72,7.66"  xml:id="b3">
	<analytic>
		<title level="a" type="main">A class of local interpolating splines</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Catmull</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Rom</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<date type="published" when="1974" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,170.21,232.12,7.51;10,40.76,179.52,232.12,7.66;10,40.76,188.99,132.91,7.66"  xml:id="b4">
	<analytic>
		<title level="a" type="main">Zsweep: an efficient and exact projection algorithm for unstructured volume rendering</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Farias</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">S B</forename>
				<surname>Mitchell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Volume Visualization</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="91" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,198.45,232.12,7.66;10,40.76,207.92,105.06,7.66"  xml:id="b5">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">P</forename>
				<surname>Garrity</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,217.53,232.12,7.51;10,40.76,226.85,232.12,7.66;10,40.76,236.31,120.32,7.66"  xml:id="b6">
	<analytic>
		<title level="a" type="main">A generic and scalable pipeline for gpu tetrahedral grid rendering</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Georgii</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Westermann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1345" to="1352" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,245.93,232.12,7.51;10,40.76,255.39,232.12,7.51;10,40.76,264.86,232.12,7.51;10,40.76,274.32,17.93,7.51"  xml:id="b7">
	<monogr>
		<title level="m" type="main">Parallel peeling of curvilinear grids</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Grimm</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Meissner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Kanitsar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">E</forename>
				<surname>Gröller</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,283.79,232.12,7.51;10,40.76,293.10,155.07,7.66"  xml:id="b8">
	<analytic>
		<title level="a" type="main">Computing the arc length of parametric curves</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Guenter</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Parent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.75,302.56,193.21,7.66"  xml:id="b9">
	<monogr>
		<title level="m" type="main">Clustering Algorithms</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Hartigan</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1975" />
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,312.18,232.14,7.51;10,40.76,321.49,232.12,7.66;10,40.76,331.11,33.87,7.51"  xml:id="b10">
	<analytic>
		<title level="a" type="main">Accelerated ray-casting for curvilinear volumes</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Hong</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Kaufman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Visualization &apos;98</title>
		<meeting>the conference on Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="247" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,340.57,232.13,7.51;10,40.76,349.89,232.12,7.66;10,40.76,359.35,165.03,7.66"  xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast projection-based ray-casting algorithm for rendering curvilinear volumes</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Hong</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">E</forename>
				<surname>Kaufman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="322" to="332" />
			<date type="published" when="1999-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,368.82,232.12,7.66;10,40.76,378.28,119.88,7.66"  xml:id="b12">
	<monogr>
		<title level="m" type="main">Spectral/hp Element Methods for CFD</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">E</forename>
				<surname>Karniadakis</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">J</forename>
				<surname>Sherwin</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,387.74,232.12,7.66;10,40.76,397.21,88.87,7.66"  xml:id="b13">
	<monogr>
		<title level="m" type="main">Remarks on mesh quality</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">M</forename>
				<surname>Knupp</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>American Institute of Aeronautics and Astronautics</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,406.82,232.12,7.51;10,40.76,416.29,232.13,7.51;10,40.76,425.60,232.12,7.66;10,40.76,435.07,203.90,7.66"  xml:id="b14">
	<analytic>
		<title level="a" type="main">Breast image registration by combining finite elements and freeform deformations</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">W C</forename>
				<surname>Lee</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">A</forename>
				<surname>Schnabel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Rajagopal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">M F</forename>
				<surname>Nielsen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">P</forename>
				<surname>Nash</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Workshop on Digital Mammography</title>
		<meeting>the 10th International Workshop on Digital Mammography</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="736" to="743" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,444.68,232.12,7.51;10,40.76,454.00,232.12,7.66;10,40.76,463.61,72.61,7.51"  xml:id="b15">
	<analytic>
		<title level="a" type="main">Transparency and antialiasing algorithms implemented with the virtual pixel maps technique</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Mammen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Graph. Appl</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="43" to="55" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,473.08,232.12,7.51;10,40.76,482.39,232.12,7.66;10,40.76,491.85,232.12,7.66;10,40.76,501.32,89.88,7.66"  xml:id="b16">
	<analytic>
		<title level="a" type="main">Recent advancements in raytracing based volume rendering techniques</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marmitt</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Friedrich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Slusallek</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 10th International Fall Workshop -Vision, Modeling, and Visualization (VMV) 2005</title>
		<meeting>10th International Fall Workshop -Vision, Modeling, and Visualization (VMV) 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="131" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,510.93,232.12,7.51;10,40.76,520.25,232.12,7.66;10,40.76,529.71,77.28,7.66"  xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient rendering of extrudable curvilinear volumes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Martin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H.-W</forename>
				<surname>Shen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Samtaney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization Symposium</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.76,539.33,232.12,7.51;10,303.38,53.65,232.12,7.66;10,303.38,63.12,103.48,7.66"  xml:id="b18">
	<monogr>
		<title level="m" type="main">Efficient Acquisition and Clustering of Local Histograms for Representing Voxel Neighborhoods</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Meß</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ropinski</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="117" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,72.73,232.12,7.51;10,303.38,82.05,232.12,7.66;10,303.38,91.51,177.74,7.66"  xml:id="b19">
	<analytic>
		<title level="a" type="main">Particle systems for efficient and accurate high-order finite element visualization</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Meyer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Kirby</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Whitaker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,101.13,232.12,7.51;10,303.38,110.44,232.12,7.66;10,303.38,119.90,30.77,7.66"  xml:id="b20">
	<analytic>
		<title level="a" type="main">A fast high accuracy volume renderer for unstructured data</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Moreland</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Angel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Volume Visualization and Graphics</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,129.52,232.12,7.51;10,303.38,138.83,232.12,7.66;10,303.38,148.30,142.76,7.66"  xml:id="b21">
	<analytic>
		<title level="a" type="main">Gpu-based interactive cut-surface extraction from high-order finite element fields</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Haimes</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Kirby</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,157.91,232.13,7.51;10,303.38,167.23,232.12,7.66;10,303.38,176.69,122.98,7.66"  xml:id="b22">
	<analytic>
		<title level="a" type="main">Ray-tracing polymorphic multidomain spectral/hp elements for isosurface rendering</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Kirby</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,186.16,232.12,7.66;10,303.38,195.62,232.12,7.66;10,303.38,205.24,38.74,7.51"  xml:id="b23">
	<monogr>
		<title level="m" type="main">Numerical Recipes in C -The Art of Scientific Computing</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">H</forename>
				<surname>Press</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">T</forename>
				<surname>Vetterling</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">A</forename>
				<surname>Teukolsky</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">P</forename>
				<surname>Flannery</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,214.70,232.12,7.51;10,303.38,224.17,232.13,7.51;10,303.38,233.48,232.12,7.66;10,303.38,243.09,187.68,7.51"  xml:id="b24">
	<analytic>
		<title level="a" type="main">Hardware assisted volume rendering of unstructured grids by incremental slicing</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Reed</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Yagel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Law</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P.-W</forename>
				<surname>Shin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Shareef</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 symposium on Volume visualization, VVS &apos;96</title>
		<meeting>the 1996 symposium on Volume visualization, VVS &apos;96<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page">55</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,254.78,232.12,7.51;10,303.38,264.10,232.12,7.66;10,303.38,273.56,117.33,7.66"  xml:id="b25">
	<analytic>
		<title level="a" type="main">Interactive visualization of large finite element models</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Rose</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Vision, Modelling, and Visualization VMV &apos;03</title>
		<meeting>the Workshop on Vision, Modelling, and Visualization VMV &apos;03</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="585" to="592" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,283.18,232.12,7.51;10,303.38,292.64,232.12,7.51;10,303.38,301.95,232.12,7.66;10,303.38,311.42,136.70,7.66"  xml:id="b26">
	<analytic>
		<title level="a" type="main">Methods and framework for visualizing higher-order finite elements</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Schroeder</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Bertel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Malaterre</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Thompson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pebay</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">O</forename>
				<surname>Bara</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Tendulkar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="446" to="460" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,320.88,232.12,7.66;10,303.38,330.50,17.93,7.51"  xml:id="b27">
	<monogr>
		<title level="m" type="main">p-and hp-Finite Element Methods</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Schwab</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,339.81,232.12,7.66;10,303.38,349.43,17.93,7.51;10,285.12,357.16,33.49,9.24;10,314.41,358.89,221.09,7.51;10,303.38,368.21,232.12,7.66;10,303.38,377.82,17.93,7.51"  xml:id="b28">
	<analytic>
		<title level="a" type="main">Finite Element Analysis Interactive high-quality visualization of higher-order finite elements</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Szabó</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Babuska</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">¨</forename>
				<surname>Uffinger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Frey</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<publisher>Wiley-Interscience</publisher>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="337" to="346" />
			<date type="published" when="1991" />
			<publisher>Wiley-Interscience</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,387.29,232.13,7.51;10,303.38,396.60,232.12,7.66;10,303.38,406.22,17.93,7.51"  xml:id="b29">
	<analytic>
		<title/>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wihelms</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Challinger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Alper</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Ramamoorthy</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Vaziri</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Direct volume rendering of curvilinear volumes. SIGGRAPH</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="41" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,415.68,232.12,7.51;10,303.38,424.99,232.12,7.66;10,303.38,434.46,51.46,7.66"  xml:id="b30">
	<analytic>
		<title level="a" type="main">Ray casting curvedquadratic elements</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Wiley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Childs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Hamann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Joy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,444.07,232.12,7.51;10,303.38,453.39,124.63,7.66"  xml:id="b31">
	<analytic>
		<title level="a" type="main">A toolkit for visualizing biomedical data sets</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Wünsche</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GRAPHITE &apos;03</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="167" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,463.00,232.12,7.51;10,303.38,472.32,232.12,7.66;10,303.38,481.78,189.38,7.66"  xml:id="b32">
	<analytic>
		<title level="a" type="main">The visualization and measurement of left ventricular deformation using finite element models</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">C</forename>
				<surname>Wünsche</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">A</forename>
				<surname>Young</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JVLC -Biomedical Visualization for Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="326" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,491.40,232.12,7.51;10,303.38,500.86,232.12,7.51;10,303.38,510.17,232.12,7.66;10,303.38,519.79,17.93,7.51"  xml:id="b33">
	<analytic>
		<title level="a" type="main">Dell&apos;Italia. Left ventricular mass and volume: Fast calculation with guide-point modeling on MR images</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">A</forename>
				<surname>Young</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">R</forename>
				<surname>Cowan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Thrupp</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Hedley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">J</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Radiology</title>
		<imprint>
			<biblScope unit="volume">216</biblScope>
			<biblScope unit="page" from="597" to="602" />
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
