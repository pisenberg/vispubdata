<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithm Visualization For Distributed Environments</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoram</forename><surname>Moses</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zvi</forename><surname>Polunsky</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ayellet</forename><surname>Tal</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Applied Math Dept. of Applied Math Dept. of Electrical Engineering The Weizmann Inst. of Science</orgName>
								<orgName type="institution">The Weizmann Inst. of Science Technion -Israel Institute of Technology Leonid Ulitsky</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Applied Math The Weizmann Inst. of Science</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Algorithm Visualization For Distributed Environments</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>visualization of algorithms</term>
					<term>program visualization</term>
					<term>algorithm animation</term>
					<term>visualization in education</term>
					<term>distributed algorithms</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper investigates the visualization of distributed algorithms. We present a conceptual model and a system, VADE, that realizes this model. Since in asynchronous distributed systems there is no way of knowing (let alone, visualizing) the &quot;real&quot; execution, we show how to generate a visualization which is consistent with the execution of the distributed algorithm. We also present the design and implementation of our system. VADE is designed so that the algorithm runs on the server&apos;s machines while the visualization is executed on a web page on the client&apos;s machine. Programmers can write animations quickly and easily with the assistant of the VADE&apos;s libraries.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Algorithm visualization can assist in the design of algorithms, in the debug process, and while teaching algorithms to students and colleagues. When distribution is added to the environment, the importance of visualization is further increased. Distributed algorithms are difficult to understand due to the added complexity of the interprocess communication and synchronization. Many activities occur concurrently at the various sites. Moreover, the activities depend on each other in many ways. Each state depends not only on the individual process, but also on the messages arriving from other processes.</p><p>Users can use a visualization in order to convey information about the way an algorithm might work. Programmers can use a visualization to debug their code; most standard debuggers do not support distributed programming in natural ways. Students can get a better insight into the algorithm and understand the way distribution is handled.</p><p>Visualization has been added to various phases of distributed computing <ref type="bibr" target="#b12">[13]</ref>. It was added to parallel debuggers (e.g., <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>), as well as to performance and monitoring tools (e.g., <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>). Algorithm animation systems aim to visualize higher-level abstract events than those of debuggers and monitors. This is in the case of sequential algorithms (e.g., <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b22">[23]</ref>), as well as in case of distributed and parallel algorithms (e.g., <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>).</p><p>Work has been supported by the Israeli Ministry of Science Grant 8544-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3-97</head><p>y yoram@wisdom.weizmann.ac.il z ayellet@ee.technion.ac.il, http://www.ee.technion.ac.il/ayellet</p><p>x ulitsky@cs.weizmann.ac.il http://www.cs.weizmann.ac.il/ulitsky</p><p>In asynchronous distributed systems there is no way to know what the "real" execution is. Each process in the system can "remember" only its own actions during the execution of the algorithm. It can also gain knowledge of actions performed by other processes through interprocess communication. It cannot, however, compute the relative timing of the actions performed by different processes. The visualization system, being a part of the distributed asynchronous system, is no exception. The goal of an algorithm animation system for distributed environments is thus to produce a visualization which reflects as closely as possible the real execution of the algorithm.</p><p>As a result, a basic problem in visualizing distributed processes on a single display is that the display is constantly in danger of showing a picture that is locally consistent but globally inconsistent. The algorithm being visualized changes dynamically and the algorithm animation system needs to receive updates of the state from different sites. Since an immediate snapshot is impossible in an asynchronous distributed system ( <ref type="bibr" target="#b15">[16]</ref>), a "possible" snapshot should be constructed. This snapshot should be consistent with the execution of the distributed algorithm. It should present a possible state of the system consistent with the state in which the snapshot started and with the algorithm state in which the snapshot construction was completed.</p><p>There exist several algorithm visualization systems for parallel algorithms. For instance, in PARADE <ref type="bibr" target="#b25">[26]</ref> the events of interest are ordered according to time-stamps. In the Animation Choreographer component of the PARADE system <ref type="bibr" target="#b13">[14]</ref>, it is also possible to manipulate the order of the display events by choosing a suitable ordering scheme. PAVANE <ref type="bibr" target="#b19">[20]</ref> operates on the shared-memory tuple space architectures. In VISTOP <ref type="bibr" target="#b1">[2]</ref>, the "happened before" relation is utilized through either global breakpoints or traces. We propose to base the ordering of events upon the notion of causality consistency.</p><p>We present in this paper our conceptual model for an algorithm animation system for distributed algorithms. We also present a system, VADE (Visualization of Algorithms in Distributed Environments), which realizes the model. VADE is constructed so that the algorithm runs on the server's machines while the visualization is executed on a web page on the client's machine. End-users can thus watch the algorithm animation in a natural setting. The VADE architecture has several benefits. First, the algorithm code is protected. Second, the communication is very low, since only high-level operations are being sent over the network. Third, the framework provides a large degree of accessibility. The client need not have the resources needed for running the distribute algorithm. Fourth, it allows overcoming Java applets' restrictions on communication capabilities, without sacrificing security. Finally, this architecture supports the enclosures of animations in online documents.</p><p>Programmers can write animations quickly and easily with the assistant of the VADE's libraries, without having to be concerned either with the visual aspects of the animation or with the consis-tency maintenance.</p><p>The rest of the paper is organized as follows. In section 2 we define the notion of algorithm visualization causality consistency and present our model. In section 3 we discuss the system's architecture. In section 4 we describe VADE from the end-user's perspective. In section 5 we describe VADE from the programmer's perspective. We conclude in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">VISUALIZATION CONSISTENCY</head><p>A visualization system cannot be expected to represent the run exactly. We require, however, that it will be consistent with the run. In this section we define the formal notions of algorithm visualization consistency. We assume that: (1) The communication network is reliable. In other words, any message sent will eventually reach its destination. (2) Messages sent by a single process arrive in the same order they were sent. <ref type="formula">3</ref>The network is asynchronous. Every process has its own clock, but there is no universal clock.</p><p>Our goal is to produce a visualization that reflects the real execution as closely as possible. However, since the visualization process is just another process in the distributed environment, it cannot know the relative order of the execution of every two actions performed by different processes. A common way to work around this problem is to use the definition of potential causality or happened before relation <ref type="bibr" target="#b15">[16]</ref> 3. There exists an action b such that a 0 ; b and b ; a 00 . The disadvantage of potential causality is that it might be the case that actions performed in a single process can be done in a different order without changing the semantics of the algorithm. In an algorithm animation setting, where the semantics of the algorithm is to be extracted, rather than the specific execution, it is useful to be able to present the algorithm in a different order. For instance, it is not necessary to postpone the animation of the actions performed after a send action until the latter is animated. Thus, we define below the causality relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2 For two actions a 0</head><p>and a 00 we say that a 0 causes a 00 , denoted as a 0 ! a 00</p><p>, if one of the following holds:</p><p>1. a 0 and a 00 are on the same process, a 0 occurs before a 00</p><p>, and their order of execution cannot be changed without altering the algorithm semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">a 0</head><p>and a 00 are on two different processes connected by a communication line, a 0 is a send message action and a 00</p><p>is the corresponding receive message for the same message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">There exists an action b such that a 0 ! b and b ! a 00</head><p>. The difference between this relation and the potential causality relation lies in the first condition. If a 0 occurs before a 00</p><p>, it does not necessarily mean that a 0 causes a 00</p><p>. While potential causality can be identified automatically, causality cannot. We thus need to assume that there exists an external knowledge regarding causality. It is the responsibility of the programmer to supply this information.</p><p>The process actions are modeled as events. The initial local state of process p is denoted by s p 0 . The local state s p t of process p at time t is modeled by a sequence of events that occur until time t. We will use a slightly different model than the usual one by allowing actions that take more than one time unit. This is more suitable for modeling animations, since an animation might take more than one</p><p>round. An action a is modeled by two events: ae is the execution of the action, while ac is its completion.</p><p>An execution of the algorithm by a process p is modeled by a sequence S p of the process local states S p = s p 0 ; s p 1 : : : . The modeling of the execution of the entire algorithm is done by arranging the set of actions of all participants on a global time scale, so that there is no contradiction with the causality relation between the actions. The events occurring in the algorithm processes are reported to the algorithm animation system. The animation system can store the event reports and build a "model of the algorithm execution" E. This allows the system to build an animation based not only on the last event reported, but also on a set of previously received reports.</p><p>The animation system need not always build an animation segment as a result of an event report. Sometimes the animation system saves them and animates them later. Sometimes the report serves as a tool for synchronizing the animation, and the event itself is not animated. A number of frame elements, triggered by different algorithm events can have the same frame number, reflecting the simultaneous execution of the algorithm by different processes.</p><p>Let S p be an execution of the algorithm by a process p. We can build another possible execution of the algorithm S p 1 by rearranging the sequence of events such that it is consistent with respect to the causality relation, i.e., in the resulting sequence:</p><p>for every action, its execution event must precede its completion event.</p><p>for every two actions a and b such that a ! b, ac must precede be.</p><p>Note that this definition not only allows us to rearrange the events, but also allows us to model simultaneous execution of events, when other events are allowed to appear between the execution and completion events of an action. We require that the animation represents a sub-sequence of a member in the set of consistent runs of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.3 Let r be a run representing the real execution of the algorithm. Let</head><p>Rr be the set of all consistent runs. Let F = F 0; F 1; : : : ; F t be an animation of this run. Let E = E0; E 1; : : : ; E t be the sequence of models used to build the animation frames F. The animation F is said to be consistent with the algorithm run r if and only if the sequence E is identical to a sub-sequence of global states of a run r 0 that is a member of the set of runs Rr produces by r.</p><p>It is left to show how to achieve visualization consistency. Let a and b be two interesting events of the algorithm. Let Ana and Anb be the animation segments of the events a and b, respectively. We say that an animation Ana precedes an animation Anb, denoted as Ana Anb, if Ana completes before Anb starts. We claim the following: Thus, to ensure the consistency of the visualization with the algorithm execution, we have to ensure that for any two algorithm events a and b, if a ! b then Ana Anb. This requirement is a special case of the requirement for casual ordering of events <ref type="bibr" target="#b2">[3]</ref>. The casual ordering is respected if the following condition holds: In the algorithm animation context, we can substitute the display of Ana from a report of an event a by the "receival" of action a. The causality relation between two such receive operations is equivalent to the precedes relation between the animation segments. Moreover, we can regard the execution of an event in the algorithm as a "send" of the event to the visualization system. Thus, the visualization ordering requirements is transformed into the causal event ordering requirement.</p><formula xml:id="formula_0">If sendm1;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Implementation of Casual Ordering</head><p>To implement the visualization ordering requirement, it is enough to implement it for pairs related by immediate causality. The transitivity guarantees that it will hold for the general causality case. This claim is true if all the events are reported to the visualization system. Note, however, that not all the events need to be reported, but rather only those that need to be animated and all the send and receive actions.</p><p>In VADE, when two events occur in the same process, and the events are reported to the algorithm animation system, the first event is animated before the second by default. If one event is a send and the other is the corresponding receive, we ensure the animation ordering requirement in one of two ways: send synchronization and receive synchronization. Unlike some other systems (e.g, <ref type="bibr" target="#b2">[3]</ref>  <ref type="bibr" target="#b18">[19]</ref> [22]), we need not add any additional information regarding the history. We elaborate below.</p><p>Send Synchronization: In this scheme, the report on the send is sent to the visualization system before the actual action takes place. Then the process waits for a confirmation from the algorithm animation system. Only when the confirmation arrives, the actual send can be performed. The report on the receive event is sent to the animation system after the actual message is received, thus assuring that the animation of the receive event is performed after the animation of the send event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.5 In the Send Synchronization scheme, Ansend</head><p>Anreceive.</p><p>The disadvantage of the method is that the actual execution of the algorithm is altered by the fact that it is being visualized. This might be a problem when visualization is used for monitoring and debugging. However, when the system is used merely as an aid for explaining an algorithm, send synchronization is a satisfying solution.</p><p>Receive Synchronization: In this scheme, the actual synchronization of the animation with the algorithm events is performed in the animation system. The reports of the send and receive events are sent to the animation system immediately after the actions take place and there is no delay in the execution of the algorithm. However, the animation of the receive event is delayed in the animation system until the corresponding send event has been animated. To support this scheme, the animation system needs to provide tools for suspending the execution of certain events until other events occurred.</p><p>The scheme is implemented as follows. Two counters are maintained for each communication channel -one for the send actions, and the other for the receive actions. When a send report arrives, it is animated immediately. When the animation is completed, the counter of the send actions is incremented. When a receive report arrives, the animation system checks the counters of both the send actions and the receive actions for a given channel. The animation starts only if the number of send actions is larger than the number of the receive actions. Otherwise, the animation is delayed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.6</head><p>In the Receive Synchronization scheme, Ansend Anreceive.</p><p>The major advantage of the receive synchronization scheme is that the execution of the algorithm is not being changed. The disadvantage of the method is that it may require queuing many reports.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SYSTEM ARCHITECTURE</head><p>There exist various models for sequential algorithm visualization systems over the Internet <ref type="bibr" target="#b0">[1]</ref>. The X model provides the basic client-server mechanism. The visualization program runs on the remote machine and interacts with the X server on the local user's machine. The Java model allows the execution of the animation on the user's machine after the code has been transferred. The Mocha model <ref type="bibr" target="#b0">[1]</ref> bridges between the two models by exporting the interface code, while executing the algorithm on a server. We follow the latter approach, while extending it to support distributed computing.</p><p>The architecture of VADE is illustrated in <ref type="figure" target="#fig_1">Figure 1</ref>. The algorithm is executed on the provider's (server's) machines, while the animation and the GUI are executed on the user's (client's) machine. The client-side processes run at a WWW browser. In <ref type="figure" target="#fig_1">Figure  1</ref>, the '!' relation indicates communication, and the '' relation indicated forking the processes as threads.</p><p>The various processes are written in Java. The processes on the server side are Java applications, while the processes on the client side are Java applets. Their code is down-loaded by the WWW browser over the Internet, compiled and run within the browser. This allows Internet users to watch the animation in their browsers. The communication between the server processes and the client processes are performed with the TCP/IP protocol.</p><p>When the end-user opens a web page on the client side, the main client process threads a GUI process, which is in charge of animating the algorithm. The main client informs the main server of the type of the algorithm to be animated. Upon receiving a reply from the server, and according to the data received, it threads the required number of animation processes. This number matches the number of algorithm processes. The GUI process, which is in charge of executing the animation, gets requests from the animation processes to animate the interesting events of the algorithm, and modifies the screen accordingly.</p><p>All the animation processes run on the same host on the client side, as concurrent threads. As a result, scheduling is performed by the operation system, and no special handling is needed by the visualization system in order to allow simultaneous display of different events. This is different from the algorithm processes which run on different machines.</p><p>The main server is in charge of executing the algorithm. Upon receiving a request from the client, which includes the type of the algorithm to execute, the main server threads the processes which are necessary for executing the algorithm. In order to determine the nodes on which the algorithm should run, the main server maintains a table of the available hosts on the server side. It also maintains a dynamic table containing information regarding the processes and their hosts. When an algorithm process terminates, it informs the server, and the process table is being updated. The server attempts to thread the processes, so that they are distributed over the available hosts..</p><p>The task of the algorithm processes is to execute the algorithm. Before an algorithm process starts running the algorithm, it needs The above architecture has a few benefits. First, the algorithm code of the provider is protected. It is only the animation code that is being down-loaded by the client. Second, the communication is very low, since only high-level operations are being sent over the network, rather than the detailed frame description of the animation. Third, the framework provides a large degree of accessibility. The client need not have the resources needed for running the distribute algorithm. Fourth, this scheme overcomes Java applets' restrictions on communication capabilities. Java applets, for security reasons, avoid the creation of new processes on other machines, as well as the ability to update files. These, however, are necessities in distributed environments. Finally, utilizing the web makes it possible to support enclosures of animations in online documents -an invaluable tool for illustrating the functioning of novel algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">END-USER PERSPECTIVE</head><p>This section describes how VADE might be used. In order to run an algorithm and watch its animation, the end-user should open a web page and select a specific algorithm. Each algorithm has its own dedicated page. An algorithm web page displays a view, or multiple views, of the algorithm animation, along with a couple of panels that support the interaction with the animation, as illustrated in <ref type="figure" target="#fig_2">Figure 2</ref>. (See also the color plate.)</p><p>A control panel enables the user to play the animation, pause it at any point during its execution, and resume its execution. The user can also choose a node which starts the execution, by pressing the Starting node button.</p><p>A configuration panel makes it possible to build new configurations of the network by adding or removing nodes and communi-cation channels. With the Select configuration button the user can either select a default configuration, in which case the system generates a configuration, or build configuration, which allows the user to build a network configuration using the Add node and Add edge buttons. <ref type="figure" target="#fig_2">Figure 2</ref> displays snapshots from an animation of the snapshot algorithm <ref type="bibr" target="#b7">[8]</ref>. This algorithm builds a snapshot of the network. Since an immediate snapshot is impossible, a "possible", consistent, snapshot is constructed. In our example, the nodes randomly exchange data. Any node can start the snapshot algorithm either randomly or after receiving a marker from a neighbor. From this point on, the node proceeds with its standard message exchanging algorithm while saving the values of all messages arriving. The messages on each communication channel are saved until a marker is received on that channel. The node completes the snapshot when markers are received on all the channels.</p><p>In our example, each animation web page consists of three views. The first (i.e., upper) view displays the detailed execution of the algorithm. The nodes are displayed as squares with their values in the center. The colors encode the state of the node. A node is colored red if it does not participate in the snapshot algorithm. Its color is changed to blue after it received the first marker (that is, participates in the algorithm). Finally, the color of the node changes to green after that node completed the snapshot. At the end of the algorithm, all the snapshot nodes should be colored green. The communication channels are displayed as lines connecting the nodes. The messages are represented as circles, and the markers as arrows. Both the messages and the markers travel along the communication channels.</p><p>The second (i.e., middle) view displays the state of snapshot, built by the algorithm. Before any node started the algorithm execution, this view is empty. When the node enters the snapshot algorithm, its value is added to this view. Similarly, when the node receives a message, the message is added to the snapshot and to this view.</p><p>The third view shows the sum of the "money" in the snapshot. It consists of two squares. The first square displays the total sum in the system before the algorithm started to run. The second square displays the sum accumulated during the snapshot. When the snapshot is completed, the two numbers should be equal.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PROGRAMMER PERSPECTIVE</head><p>Following the event-driven approach <ref type="bibr" target="#b3">[4]</ref>, common in algorithm animation systems, strategically important points of the algorithm are augmented with interesting events. Animations for these events should be produced.</p><p>The task of animating a distributed algorithm is thus divided into four steps. First, the interesting events should be identified. Second, the algorithm should be implemented and annotated with the interesting events. Third, the code should be augmented with calls to the animation system's synchronization functions (i.e., send and receive events should be reported). Finally, the animation needs to be implemented.</p><p>In our framework, a large portion of the final step, that of creating the animation, is left for the animation system. Our system provides the GUI and a few libraries which facilitate the creation of animations, as described below. In addition, the programmer need not be concerned with maintaining the consistency of the animation, which is automatically done by the animation system. As long as the communication events are reported, the system guarantees the visualization causality consistency, as discussed in Section 2. In our web setting, the programmer needs also create a web page that contains the views of the animation. VADE provides the basic web page which contains the control panel and the configuration panel, as described in Section 4. The page can be modified to accommodate any number of views, as well as adding algorithm-specific options to the control panel and to the configuration panel.</p><p>The animation of the events should be written in Java. <ref type="figure" target="#fig_4">Figure  3</ref> summarizes the VADE class tree. The classes contained in the tree build up the animations, and their visualization is supported by VADE. Derived classes are at the right. They inherit the fields and the methods of the classes they are derived from. We elaborate below.</p><p>The main class that describes the network is the NetGraph. It includes nodes (the NetNode class), communication channels (the NetLink class) and various types of tokens (the NetToken class) that can be exchanged by the nodes on the communication channels. The NetToken class includes messages (NetMessage), markers (Net-Marker), or other types of tokens (NetUserToken). To accommodate other objects, relevant for the animation of the algorithm, the user can use the class NetUserObject.</p><p>A major principle we follow is that what the animation presents should be distinguished from how it does it. In other words, there should be a clear distinction between the contents of the animation and its visual appearance on the screen (its style). For instance, suppose that the user wishes to animate a "send" event. It can be visualized in various ways -nodes can be displayed in various colors and shapes, communication channels can be drawn in different line thicknesses, the messages can travel fast or slowly etc. While NetNode, NetLink, and NetToken contain the information about the contents of the animation (i.e., a message X travels on a channel Y from a node A to a node B), the style of the animation should contain the information about the actual visualization (shape, color, etc.). Default values for the style parameters are set by the system. In order to visualize a certain event, the programmer can quickly generate a prototype animation by specifying only the information regarding the contents of the animation. At later stages, the programmer can experiment with various animations by modifying the style classes, without altering the network classes. Note the dashed lines in <ref type="figure" target="#fig_4">Figure 3</ref> that mark the style information.</p><p>The style of the animation is stored in two classes: the Global-Style class and the ObjectStyle class. While the GlobalStyle class defines the global visual appearance of the animation, the Object-Style class defines the shape of a particular object. For instance, the GlobalStyle class specifies the shape, the size, and the color of the objects of a specific class (e.g., all messages are red rectangles of a certain size ). The GlobalStyle class also specifies the global aspects of the animation which are not related to the objects, such as the background color and the number of frames used for animating each of the interesting events of the algorithm. The Ob-jectStyle class specifies the style of a specific object. For example, in the ObjectStyle, it is possible to state that a message M should be displayed as a red polygon (or a blue circle, etc.). Each of the possible shapes has its own paint method. Note that a node can be displayed, in addition to the simple geometric shapes, as an image, or as a complex shape which is built out of simpler shapes.</p><p>To better demonstrate the difference between ObjectStyle and GlobalStyle, suppose that the nodes were defined in the Global-Style as red rectangles. If the user changes the shape and the color in the GlobalStyle to a green triangle, all the nodes will be repainted as green triangles. However, if only a specific ObjectStyle is to be changed to a green triangle, that specific node will be repainted as a green triangle, while the rest of the nodes will remain red rectangles.</p><p>To summarize, VADE facilitates the task of creating a visualization by providing classes (and their methods) prevalent in distributed applications. It also supplies support for creating a web page for the animation. By distinguishing between the contents and the style of the animation, it becomes easy to quickly generate a prototype animation, which is often sufficient (for instance, for debugging purposes). Should a fancier animation be desired, it can be easily done by modifying the style classes, without altering the contents of the animation. Finally, VADE frees the programmer from having to be concerned with maintaining the consistency of the visualization with the algorithm executed. It provides synchronization methods that maintain consistency, based on the causality relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Distributed algorithms can be very difficult to grasp, and hard to implement and debug. Visualization can assist in all these tasks. We presented in this paper a system, VADE, and a conceptual model, for visualizing algorithms in a distributed environment.</p><p>With VADE, distributed algorithm animations can be produced quickly and easily. The system provides libraries that facilitate the generation of visualizations. There is a clear distinction between the contents of the animation and its visualization attributes. This allows the user to experiment with various animations for the same running algorithm. Moreover, VADE automatically maintains the consistency of the picture presented with the algorithm executed. To do it, we developed a model for algorithm visualization consistency.</p><p>End-users can view the animation in the current natural environment -the web. A control panel enables the users to control the execution of the animation, while a configuration panel allows the users to interact with the system by constructing various distributed configurations.</p><p>VADE is designed so that the algorithm is executed on the server's machines, while the animation and the GUI are executed on the client's machine, as Java applets. This architecture allows a large degree of accessibility, code protection, and a low communication load. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 2 . 4</head><label>24</label><figDesc>An animation is consistent with the execution of the algorithm if and only if for any two algorithm events a and b, such that a ! b also Ana Anb.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>The VADE architecture to establish a connection with the corresponding animation process. During execution, upon reaching an interesting event, it sends a message, containing the relevant information regarding the event, to its related animation process. Interesting events are either events of the algorithm, or communication events (i.e., send and receive). Both synchronous communication and asynchronous communication are supported. Recall that if all the send and receive events are reported to the animation processes, the animation consistency is automatically maintained by VADE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 (</head><label>2</label><figDesc>a) displays the state of the system (the nodes, the com-(a) Before the snapshot algorithm (b) During the snapshot algorithm (1) (c) During the snapshot algorithm (2) (d) The result of the snapshot algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Snapshots from the visualization of the snapshot algorithm munication channels, the messages and the markers) before the snapshot algorithm has begun.Figures 2(b)-2(c) demonstrate the state of the system during the algorithm. Finally,Figure 2(d)illustrates the state of the system after the snapshot algorithm terminated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>The structure of the animation classes</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Algorithm animation over the World-Wide Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Liotta</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Visualization of message passing parallel programs with the TOPSYS parallel programming environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bemmerl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Braun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="118" to="128" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reliable communication in the presence of failures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Birman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Joseph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="76" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Algorithm animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Zeus: a system for algorithm animation and multi-view editing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="177" to="186" />
			<date type="published" when="1992-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Collaborative active textbooks: a web-based algorithm animation system for an electronic classroom</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Najork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SRC Research Report</title>
		<imprint>
			<biblScope unit="volume">142</biblScope>
			<date type="published" when="1996-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Techniques for algorithm animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sedgewick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="28" to="39" />
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Distributed snapshots: Determining global states of distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="75" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The visual display of parallel performance data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Malony</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Rover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="21" to="28" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Parallel performance visualization: From practice to theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Malony</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Rover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Parallel Distrib. Tech</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="44" to="60" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Performance visualization of a distributed system: A case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jakiela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="30" to="36" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Monitoring distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Joyce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lomow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Slind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Unger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="150" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The visualization of parallel systems: an overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kraemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="105" to="117" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Toward flexible control of the temporal mapping from concurrent program events to animations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kraemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Parallel Processing Symposium</title>
		<meeting>the 8th International Parallel Processing Symposium</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="902" to="908" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Creating an accurate portrayal of concurrent executions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kraemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Concurrency</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="36" to="46" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Time, clocks and the ordering of events in a distributed system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communication of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Debugging concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Mcdowell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Helmbold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="593" to="622" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Models for visualization in parallel debuggers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Pancake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Utter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Supercomputing &apos;89</title>
		<meeting>Supercomputing &apos;89</meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="627" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The casual ordering abstraction and a simple way to implement it</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raynal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Toueg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="343" to="350" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pavane: a system for declarative visualization of concurrent computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G.-C</forename><surname>Roman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Plun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Visual Languages Comput</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="161" to="193" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Performance visualization and prediction of parallel supercomputer programs: An intern report</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Sarukkai</surname></persName>
		</author>
		<idno>318</idno>
		<imprint>
			<date type="published" when="1990" />
			<pubPlace>Bloominton</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Indiana University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A new algorithm to implement casual ordering. Third International Workshop on Distributed Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eggli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sandoz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">393</biblScope>
			<biblScope unit="page" from="219" to="232" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Visualization of geometric algorithms in an electronic classroom. Visualization &apos;97</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shneerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="455" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Graphical views of parallel programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Socha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Baily</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Notkin</forename><surname>Voyeur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="206" to="215" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tango: a framework and system for algorithm animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="1990-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A methodology for building application-specific visualizations of parallel programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kraemer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distributed Comut</title>
		<imprint>
			<biblScope unit="issue">18</biblScope>
			<biblScope unit="page" from="258" to="264" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Visualization of geometric algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Dobkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="194" to="204" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
