<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Using Difference Intervals for Time-Varying Isosurface Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">W</forename><surname>Waters</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">S</forename><surname>Co</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
						</author>
						<title level="a" type="main">Using Difference Intervals for Time-Varying Isosurface Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present a novel approach to out-of-core time-varying isosurface visualization. We attempt to interactively visualize time-varying datasets which are too large to fit into main memory using a technique which is dramatically different from existing algorithms. Inspired by video encoding techniques, we examine the data differences between time steps to extract isosurface information. We exploit span space extraction techniques to retrieve operations necessary to update isosurface geometry from neighboring time steps. Because only the changes between time steps need to be retrieved from disk, I/O bandwidth requirements are minimized. We apply temporal compression to further reduce disk access and employ a point-based previewing technique that is refined in idle interaction cycles. Our experiments on computational simulation data indicate that this method is an extremely viable solution to large time-varying isosurface visualization. Our work advances the state-of-the-art by enabling all isosurfaces to be represented by a compact set of operations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Visualization of time-varying data continues to present challenges to the scientific community, primarily due to large data size. Modern computational fluid dynamics simulations can produce massive timevarying data sets, usually orders of magnitude greater than the size of main memory. In such scenarios, memory and processing limitations mandate an out-of-core approach. Developing an efficient solution for exploring this data on workstation class hardware is one of the most challenging problems in scientific visualization.</p><p>Existing methods for time-varying isosurface extraction have focused on methods that treat the entire data set as a 4D object, exploiting temporal and spatial coherence by merging cells in the data. Doing so reduces the amount of runtime computation necessary to identify active cells-cells containing the isosurface. While these methods allow random access to any isosurface at any time step, one can achieve better performance by tailoring an algorithm to watch a single isosurface progress through time. Many active cells in one time step remain active in neighboring time steps. We take advantage of this temporal coherence by encoding the difference between isosurfaces in much the same way video is encoded. These differences are encoded as operations that can be extracted efficiently in the same manner that active cells are extracted from non-time-varying data. Operations indicate changes necessary to update isosurface geometry from a neighboring time step to reflect isosurface geometry for the current time step.</p><p>The major contribution of our work is a system that generates a small set of operations between two time steps that compactly encode changes for all isosurfaces. We describe a novel isosurfacing method that classifies operations (and not cells) in span space <ref type="bibr" target="#b4">[5]</ref>, thereby enabling efficient out-of-core visualization of time-varying data. These operations encode how isosurfaces move through time and are classified in span space using difference intervals. The generation and use of difference intervals is the key to our approach and is covered in Section 3. We develop these concepts into algorithms and data structures that maintain accurate active cell lists throughout the visualization. In Section 4, we describe a point-based method for rendering previews of the time-varying data. Full exploration of time-varying isosurfaces requires random access to the isosurface at any time step. Our system supports this random access by incorporating the notion of keyframes, which we describe in Section 5. In Section 6, we outline temporal compression techniques used to reduce disk storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Methods for modern isosurface extraction can be split into two major classes, geometric-space and value-space methods. Geometric-space methods <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15]</ref> use information about the position of each cell in the volume to accelerate the determination of active cells. Value-space methods <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14]</ref> work only on the intervals of values each cell contains. This work is a value-space method. Early geometric-space methods marched through every cell of the data set to discover which cells are active <ref type="bibr" target="#b6">[7]</ref>. Wilhelms et al. <ref type="bibr" target="#b14">[15]</ref> improved on this by applying an octree data structure with value interval information to facilitate the location of active cells. The temporal branch-on-need (T-BON) tree is a geometric-space method for timevarying data developed by Sutton and Hansen <ref type="bibr" target="#b10">[11]</ref> that extends this  octree data structure. For each time step, Sutton and Hansen create an independent branch-on-need octree, and isosurfaces are fully extracted from the structure for each time step. The scalar values associated with cells in the isosurface are loaded allowing the isosurface to be rendered using traditional marching cubes techniques. T-BON does not exploit any temporal coherence in the underlying data set. The method of Gregorski et al. <ref type="bibr" target="#b3">[4]</ref> accomplishes time-varying isosurface visualization by making local updates to a tetrahedral mesh based on diamonds over time. Their adaptive multiresolution mesh makes use of a data layout scheme that allows mesh refinement to be spatially and temporally coherent.</p><p>Span space methods <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14]</ref> belong to the class of value-space techniques. The span space is a 2D logical space developed by Livnat et al. <ref type="bibr" target="#b4">[5]</ref>. Every cell is classified by the range of scalar values it contains. Each cell's minimum, a, and maximum, b, values form an interval [a, b], which is thought of as a point (a, b) on the plane. Cells which are active for an isovalue q will be those in the rectangular region (−∞, q) × (q, ∞). If a cell is in this region, then a ∈ (−∞, q) and b ∈ (q, ∞) thus a &lt; q &lt; b and the cell is active. Likewise cells not in this region will not be active. The problem of isosurface extraction is thus reduced to the problem of 2D range searching in span space, see <ref type="figure">Figure 1</ref>. Livnat et al. <ref type="bibr" target="#b4">[5]</ref> use a k-d tree to solve the range searching problem. The ISSUE technique by Shen et al. <ref type="bibr" target="#b9">[10]</ref> uses a lattice to classify cells plotted in span space into discrete bins, solving the range searching problem by processing only cells inside bins intersected by the isovalue.</p><p>The temporal hierarchical index tree (THITree) created by Shen <ref type="bibr" target="#b8">[9]</ref> is a value-space method for time-varying data based on ISSUE <ref type="bibr" target="#b9">[10]</ref>. A binary "time tree" is created, where the root node represents all time steps, and the leaf nodes represent individual time steps. Every node has an associated span space which is searched using ISSUE. Cells which are temporally stable over a series of time steps are entered into the node of the time tree over which the cell is stable, exploiting temporal coherence. An isosurface is extracted by walking down the time tree to the current time step collecting active cells at every node. The THITree, like ISSUE and most value-space methods, does not compress the data spatially. The THITree has recently been extended by using interval trees <ref type="bibr" target="#b12">[13]</ref>.</p><p>Isosurfaces can be rendered in several ways. The most common approach is to extract triangle geometry <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14]</ref> approximating the surface and render the resulting triangles using rasterization hardware. More recently, the visualization community has been adopting point-based techniques to render isosurfaces. Surface splatting techniques have been applied to render point-sampled isosurfaces <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b11">12]</ref>. Livnat and Tricoche <ref type="bibr" target="#b5">[6]</ref> use a two-pass rendering approach to compute a lit surface from points lacking surface normals. Vrolijk et al. <ref type="bibr" target="#b12">[13]</ref> adapt the point-based ShellSplatting technique <ref type="bibr" target="#b0">[1]</ref> to render timevarying isosurfaces.</p><p>In our system, we use span space extraction data structures and algorithms in two ways. First, we build extraction data structures for select time steps of the data. These keyframes store cell information and are capable of extracting complete isosurfaces without neighboring time step data. Second, we build extraction data structures between time steps of the data. These structures store operations and are capable of producing isosurfaces from neighboring time steps by applying only the minimum number of necessary changes. In both cases, instances of the same span space data structure are used for extraction, even though they store different types of information. To reduce storage requirements, we adapt a temporal compression technique similar to that of the THITree method <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13]</ref>. For previewing, we employ a point-based method that renders a single point splat for each active cell, as in the iso-splatting <ref type="bibr" target="#b2">[3]</ref> and span-triangle <ref type="bibr" target="#b11">[12]</ref> techniques. Inspired by the work of Livnat and Tricoche <ref type="bibr" target="#b5">[6]</ref>, we use a two-pass rendering approach to estimate lighting characteristics. The effectiveness of our system is demonstrated by visualizing large time-varying isosurfaces from simulation data. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DIFFERENCE INTERVALS</head><p>We wish to visualize isosurfaces from a time-varying data set consisting of n time steps t 0 , . . . ,t n−1 . At runtime, the user specifies an isovalue q corresponding to an isosurface of interest. For an isovalue q, let A (t 0 ), . . . , A (t n−1 ) be the set of active cells for each of the n time steps. Our system begins by extracting A (t 0 ) for the first time step t 0 . To obtain A (t 1 ) for the second time step t 1 , we update A (t 0 ) using operations extracted from an operation set between the two time steps. The operations indicate when to add and remove cells from the active cell list. We motivate the use of these operations by examining a single cell as its interval changes over time. Consider a single cell C(t i ) at time step t i and its associated interval [s min (t i ), s max (t i )] corresponding to the minimum and maximum scalar values over C(t i ). Change in interval values corresponds to movement in the span space as shown in <ref type="figure" target="#fig_1">Figure 2a</ref>. Let</p><formula xml:id="formula_0">C(t 0 ) = [s min (t 0 ), s max (t 0 )] = [b, d] and C(t 1 ) = [s min (t 1 ), s max (t 1 )] = [a, c]. Al- though C(t 0 ) and C(t 1 )</formula><p>are plotted as two different points in the span space, they represent the same geometric cell. Observe that the two points split the span space into five intervals on the min = max line. We identify the following cases:</p><p>1. If q ∈ (−∞, a] the cell is inactive in both time steps.</p><p>2. If q ∈ (a, b] the cell is inactive in t 0 and active in t 1 .</p><p>3. If q ∈ (b, c) the cell is active in both time steps. These five intervals, which we call difference intervals, correspond to five cases indicating whether the cell should be added to or removed from the active cell list, or if no change is necessary. Since the state of the cell remains the same in cases 1, 3 and 5, the active cell list does not need to be modified. We refer to these cases as stable intervals. In case 2, the cell becomes active in t 1 , so the cell must be added to the active cell list. Likewise, in case 4, the cell becomes inactive in t 1 , so the cell must be removed from the active cell list.</p><p>In summary, we define an operation to be an add/remove action, a cell, and a difference interval. The action specifies whether the cell should be added or removed from the current active cell list. The operation is valid over the span of the difference interval. The change in every isosurface can be represented in only two operations per cell. We note that the operation does not contain the intensity values for a cell. If a cell is active over a series of time steps, we will only see a single add operation and a single remove operation to represent that cell over the whole of the time steps that that cell is active. Also, at preprocess time we cannot determine which remove operation will correspond to a particular add operation because this is dependent on the particular isovalue that the user is viewing. Thus, an operation cannot contain the intensity values for a cell. If intensity values are required they must be read from disk separately; however, we provide a rendering method which minimizes the need for them.</p><p>At runtime, we need to determine which operations must be performed to transition the isosurface from t 0 to t 1 . Consider the add operation corresponding to case 2 in <ref type="figure" target="#fig_1">Figure 2</ref>. This operation is valid over the interval <ref type="bibr">(a, b]</ref>. In other words, if the user is examining an isosurface q ∈ (a, b], this add operation needs to be performed in order to maintain an accurate active cell list. By considering the interval of the operation in span space, it becomes clear that a range search with query value q can be performed to collect this operation, see case 2 in <ref type="figure" target="#fig_1">Figure 2b</ref>. A similar argument exists for the remove operation corresponding to case 4. The set of operations necessary to update all the cells between time steps is called an operation set. Thus, if we store the operation set in a span space extraction data structure (where operations are stored according to their associated difference intervals), we can efficiently identify the operations that need to be applied between time steps. Stable intervals result in no changes to the active cell list and, as such, do not need to be stored. Our system uses an out-of-core isosurface extraction algorithm for searching developed by Nuber et al. <ref type="bibr" target="#b7">[8]</ref>, although other methods can be used.</p><p>In a preprocessing step, we compute the n−1 operation sets, storing the add/remove operations in a span space extraction data structure. In total, 11 cases for classifying cell movement arise in the preprocessing that affect what operations are stored in the operation sets, see <ref type="figure" target="#fig_2">Figure  3</ref>. The distance and direction a cell moves determines which case is applicable. If a cell's min and max intensity both decrease and its intervals overlap then the movement is classified as 1S, alternately if the intervals are disjoint the cell is classified as 1L. Cases 9S and 9L are differentiated similarly. Construction of our search structure proceeds as follows. For each pair of successive time steps we compute the difference intervals induced by the cell movement and store the operation into our existing span space search structure. The changes between t i and t i+1 are encoded into the operation set D i . Each adjacent pair of time steps gets its own structure, and the points in these structures represent the operations that can be used to obtain the new isosurface from the previous one.</p><p>At runtime, time-varying isosurface extraction is achieved through incremental updates between time steps. To get from isosurface q for t i to isosurface q for t i+1 , we perform an interval search on D i us-ing q as our search value. For every interval found in the search, we add or remove the specified cell from the list of cells for isosurface t i . We repeat the process for each pair of time steps continuously to visualize the time-varying isosurface. Reverse playback is possible by treating add operations as remove operations and remove operations as add operations. In other words, to get from t i+1 to t i , we perform an interval search on D i , and for every add operation we remove the corresponding cell, and for every remove operation we add the cell. In main memory the active cells are stored in a hash table, this provides O(1) insertion, O(1) removal, and O(n) traversal.</p><p>Difference intervals minimize disk reads at the expense of computation time and disk storage space. Since disk bandwidth is the limiting factor for current out-of-core time-varying isosurfacing methods, this trade off is appropriate and allows us to visualize larger datasets. By using a modern out-of-core isosurface extraction algorithm, which operates with very little over read, to retrieve our operations, we need only be concerned with the number of operations retrieved in each update, and not the size of the operations sets themselves. In the worst case, where no active cells are stable, we read in two operations per active cell. However, in the average case, where many active cells are stable, we read dramatically less from disk, leading to improved performance. It is the creation of difference intervals and using them to get incremental updates from a non-time-varying isosurface extraction algorithm, without modification, that differentiates this from our previous work <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PREVIEW RENDERING</head><p>Operation sets help maintain an accurate active cell list when traversing the sequence of time steps. Standard isosurface rendering techniques require the position and intensity values of each cell in order to compute the final image with lighting. It is possible however to compute an approximate rendering of the isosurface given the cell positions alone, precluding the need to retrieve intensity values. The positions of the cells provide a rough outline for the geometry of the isosurface. For lighting calculations, we adopt a point-based method inspired by Livnat and Tricoche <ref type="bibr" target="#b5">[6]</ref>. Their method estimates normals in screen space using a two-pass approach.</p><p>In the first rendering pass, we render a single view-aligned circular splat at the center of each active cell. The radius of the splat is computed to be the radius of the sphere that is centered at the cell center and completely contains the cell geometry. This gives us an unlit view of the isosurface. In the second rendering pass, we perform central differencing on the values in the depth buffer to estimate normals for the isosurface. We use these normals to light the rendered surface. <ref type="figure" target="#fig_3">Figure  4</ref> illustrates our two-pass preview rendering technique. Our current implementation of the preview renderer is implemented in software, although a hardware implementation can be used as well.</p><p>This preview rendering is used in our system to support interactive playback of the isosurface. When the user pauses playback to look at a single isosurface or change the isovalue, the intensity values for each active cell are retrieved to compute a higher quality rendering. In our implementation, we extract triangles for the higher quality rendering. <ref type="figure" target="#fig_5">Figure 5</ref> illustrates examples of the two rendering methods employed in our application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">KEYFRAMES</head><p>The system we have developed thus far assumes that we have an initial isosurface for t 0 and that the user does not change the isovalue. We determine an initial isosurface by using a static extraction data structure for t 0 . When the user wants to watch this isosurface evolve over time, we retrieve the update operations from D 0 and apply them to obtain the isosurface for t 1 . This process is applied repeatedly until all the time steps have been visualized. Under these conditions, if the user wishes to jump to a random time step, several operation sets must be traversed to apply the changes necessary to produce the correct image. Likewise, if the user wishes to view a different isosurface at an arbitrary time step, the new isosurface must be re-extracted from t 0 , and again several operation sets must be traversed to apply the necessary changes. We incorporate the notion of keyframes into our system to accelerate random access to isosurfaces at arbitrary time steps. A keyframe in our system consists of a full isosurface extraction data structure placed at select locations in the time-varying data. The existence of keyframes reduces the number of operation sets that need to be traversed, since an initial isosurface can be obtained from the keyframe nearest to the target time step. Only the operations sets between the keyframe and the target time step need to be traversed to obtain the desired isosurface at the target time step.</p><p>Therefore, to extract isosurface q for time step t j , we look for the nearest keyframe, say at time step t i . Then we extract a complete isosurface from the keyframe for time step t i and apply the changes from D i . . . D j−1 (assuming i &lt; j) to get an isosurface for t j . (A similar process applies when j &lt; i.) <ref type="figure" target="#fig_6">Figure 6</ref> illustrates the relationships between time steps of the data, operation sets, and keyframes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">TEMPORAL COMPRESSION</head><p>We adapt temporal compression in an attempt to further reduce disk storage and bandwidth requirements. The compression is performed as a preprocessing step and does not affect the construction of or the extraction from the operation sets. Our method is similar to that of the THITree approach by Shen <ref type="bibr" target="#b8">[9]</ref>.</p><p>The process begins with a user-specified error threshold ε. The compression considers the movement of the cell in span space throughout the entire time series. When cells in consecutive time steps are confined to a box no larger than ε × ε, they are coalesced into a single cell whose position in span space is the upper left-hand corner of that box, see <ref type="figure" target="#fig_7">Figure 7</ref>. In other words, the interval coordinates assigned to all points inside the box are given by the smallest minimum intensity value and the largest maximum intensity value of the box. This reduces the number of distinct cells to the number of boxes, thus de-  creasing the number of operations that need to be stored in operation sets. The side effect is that false positives may appear at runtime during incremental extraction. That is for any time step t i and isovalue q, cells with intervals of the form <ref type="bibr">[u, v]</ref> with u &lt; q and v &gt; q will be active, but some intervals where u &lt; q + ε or v &gt; q − ε may be reported as active even though they are not.</p><formula xml:id="formula_1">t 0 t 1 t 2 t 3 t 4 D 3 D 2 D 1 D 0 k 0 k 3</formula><p>Consider a single cell's path through the span space, where the intervals can be viewed as the 2D points p 0 . . . p n−1 corresponding to time steps t 0 . . .t n−1 . We start by creating a box containing only the point p 0 . Then we walk along the cell's path expanding the box to contain each additional point as necessary. If the point p i does not fit in the current box and expanding it to contain p i would make it larger than ε × ε, we destroy the current box. Before destroying the box, the coordinates of each point p 0 . . . p i−1 are replaced with the upper lefthand corner of the box containing them. A new box containing only p i is then created, and the process repeats until all points have been accounted for, and the last time step has been reached.</p><p>This compression is more flexible than the compression the THITree provides. The THITree uses a lattice of buckets to track when a cell has remained stable enough to be compressed. Our sliding window approach allows cells to be compressed independent of where any one bucket would begin or end. Additionally the THITree uses a binary tree to classify where one box would begin and end. This restricts boxes to containing a power of two number of frames starting on an integer multiple of the number of frames in the box. These two differences allow for greater control over the error of individual cells, which results in better compression at equivalent epsilons.</p><p>For efficiency, we perform temporal compression and operation set creation simultaneously. In a naive implementation, temporal compression would be performed in one pass through the timevarying data, and operation set creation would subsequently be performed. Furthermore, the naive implementation would process each cell through all time steps individually. Instead of processing one cell at a time, we deal with all cells of a time step simultaneously as we step through the dataset one time step at a time. We track the path of all the cells as boxes are created and destroyed. For each box, we keep its coordinates and the time step t b in which it was created in memory. When a box is destroyed, we output the point only into time step t b . During construction, cells which have not been given a value in a particular time step are considered stationary and thus create no operations. When the last time step is reached, we output the remaining points and destroy the remaining boxes. If a single time step and the boxes for each cell are too large to fit in memory, we split the volume into bricks of cells and temporally compress each brick separately. Because we desire the results to be the same no matter how you arrive at an extraction for a dataset the keyframes must be generated for post compressed data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">IMPLEMENTATION ISSUES</head><p>A value-space isosurface extraction algorithm or interval search structure is necessary to implement our system, since the method uses instances of this structure to determine active cells for keyframes and to extract operations from operation sets. We use an out-of-core isosurface extraction algorithm developed by Nuber et al. <ref type="bibr" target="#b7">[8]</ref>, although other methods such as the I/O optimal interval trees <ref type="bibr" target="#b1">[2]</ref> could also be used without modifying the system. In an out-of-core context, our algorithm's running time is dominated by the time required to retrieve sets of intervals from disk. The data storage requirements of our system is bounded by a constant factor. The value of this constant depends on the settings used for temporal compression, keyframe placement, and the out-of-core extraction method employed. In the absence of temporal compression, the size of each operation set is upper-bounded by twice the size of a single time step, although it rarely ever reaches this size in practice. Each keyframe occupies an amount of space proportional to a single time step. In general, out-of-core extraction methods incur a constant factor storage overhead.</p><p>Keyframe placement and temporal compression can be tuned to balance performance, quality, and storage limitations. In our current im-  plementation, we place a keyframe for every third time step, so that at most one incremental update is performed to obtain the isosurface for a time step chosen randomly at runtime. It is important to note that keyframes do not impact the performance of incremental extraction. Using fewer keyframes reduces storage requirements, while increasing the cost of random access during playback. Temporal compression can greatly reduce the storage requirements of the operation sets. However, the introduction of false positives results in increased visual error in the preview rendering. (We note that temporal compression only affects preview rendering and has no affect on the higher quality rendering used when playback is paused.) Since accurate renderings are provided by our system when playback is paused, and most computational data sets have very high resolution, our experience indicates that the storage benefit far outweighs the cost in accuracy.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RESULTS</head><p>In order to test the performance of our system, we ran experiments on a pair of datasets produced by computational fluid dynamics. The first data set shows the evolution of a bubble of argon gas after it has undergone an initial shock. This data set consists of 131 time steps, where each time step contains a 640 × 256 × 256 grid of samples with values on the range [0.5, 11] and occupies 20.4GB of storage. Our second data set shows five jets of fluid in a quincunx pattern turning on and progressing to their steady state. The 5jet data set consists of 1000 time steps on a grid of 128 × 128 × 128 samples and occupies 7.81GB of storage. Our experiments were run on a dual Xeon 3.06 GHz processor with 4 GB of main memory.</p><p>We generated three levels of compressed operation sets, for each dataset. Higher compression levels result in less cell movement between time steps, thereby reducing the amount of storage required by operation sets. For the same reason, higher compression levels also reduce the total time required for the preprocessing phase. <ref type="table">Table 1</ref> summarizes the preprocessing time and the storage required by our data structures.</p><p>In order to collect performance information and examine the effects of temporal compression, we extracted several isosurfaces from each dataset. In the argon bubble dataset five representative isosurfaces, q ∈ {1.5, 1.75, 2, 2.5, 3}, over the time intervals where those isosurfaces are meaningful where chosen. We picked ten isosurfaces in the 5jet dataset with equally spaced isovalues. Information was collected regarding extraction time, the number of active cells extracted, and the error. <ref type="figure" target="#fig_12">Figure 10</ref> shows extraction time for the five representative isosurfaces tracked in the argon bubble timing experiment for each temporal compression level. Peaks in extraction time correspond directly to isosurfaces consisting of a large number of active cells, which were on the order of half a million active cells at its highest. <ref type="table">Table 2</ref> summarizes the average extraction performance, the average number of extracted active cells, and the relative error reported as the percentage of false positives. Naturally, higher levels of compression result in greater error evidenced as a higher percentage of false positives and a higher average number of active cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSIONS AND FUTURE WORK</head><p>We have described an efficient system for visualizing isosurfaces from time-varying data sets in an out-of-core fashion. The advantage of our  system is that changes for all isosurfaces are compactly represented by a small set of operations. Our method exploits temporal coherence by encoding differences an isosurface undergoes over time as operations that update the surface. These operations are classified in the span space using difference intervals, which are indicative of cell movement over time. The operations are retrieved efficiently at runtime using the same data structures and algorithms used to identify active cells. In order to support random access, we associate keyframe data structures with select time steps. The keyframes allow full isosurface extraction. A point-based preview method reduces bandwidth requirements between disk and main memory, thereby increasing overall performance. We further employ temporal compression techniques to reduce disk storage requirements. For cell and operation extraction at runtime, our system uses existing out-of-core isosurface extraction methods. We hope to improve our method in future work. The temporal compression reduces storage requirements by reducing the number of operations in each operation set. Performance is not improved by this compression because the average number of operations extracted remains roughly the same for each incremental update, despite the reduced size of the operation set. We wish to develop a temporal compression method that reduces both the size of each operation set and the number of operations retrieved during each search. Development of such a compression technique will allow us to come closer to truly interactive frame rates.</p><p>We would also like to extend our method. To improve performance, we wish to exploit spatial compression in addition to temporal compression. Such compression could reduce data sizes and storage requirements. Our method assumes that the cell layout for the timevarying data is the same for each time step. While this simplifying assumption is made by many methods for time-varying data visualization, we hope to extend our technique to handle data sets where each time step has a unique cell layout. Our system takes input parameters for temporal compression and keyframe placement. While the optimal tuning of these parameters is data-specific, we would like to perform a study investigating the most appropriate values for the parameters.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>t)) = [c, d) add(C(t)) = (a, b]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>The creation of add and remove operations. (a) The movement of a single cell from time step t 0 to time step t 1 plotted in span space produces five distinct intervals called difference intervals on the min = max line. (b) The five intervals correspond to five cases indicating whether the cell should be added to the active cell list, removed from the active cell list, or if the status of the cell remains stable. (c) The operation to add or remove can itself be plotted in the span space. Along the min = max line, filled dots represent endpoints that are included in the interval, and hollow dots represent endpoints that are not included in the interval.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Case table for constructing active cell list operations. The black arrow indicates cell movement induced by changes in the cell's interval from t i to t i+1 . To compute operations, the case corresponding the cell's movement is retrieved. This case dictates whether the operation should be an add (shown in green) or a remove (shown in red) and what difference interval coordinates should be assigned to the operation. Along the min = max line, filled dots represent endpoints that are included in the interval, and hollow dots represent endpoints that are not included in the interval.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4 .</head><label>4</label><figDesc>If q ∈ [c, d) the cell is active in t 0 and inactive in t 1 . 5. If q ∈ [d, ∞) the cell is inactive in both time steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Illustration of our two-pass preview rendering method. In the first pass, a single point splat for each active cell is rendered, resulting in an unlit view of the surface and depth values. In the second pass, normals estimated using the depth buffer are combined with the unlit image to produce the isosurface preview.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Examples of the two rendering modes used in our system. (a) Standard triangle-based rendering techniques are used when playback is paused. (b) A point-based preview rendering method is used to facilitate real-time playback.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Illustration of the data structures associated with every time step t i . The operation sets D i encode the changes between time steps t i and t i+1 , enabling efficient playback. The keyframes k i encode the entire isosurface for their time steps, allowing random access and isovalue changes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Illustration of a single cell traveling through the span space through all of the time steps. The locations of the cell, shown as black dots, trace out a path, drawn here in gray. Overlaid on top of the path is our compression filter, a box. All the points in each box are replaced with their temporal extreme shown as red dots. These red dot points are subsequently used to compute difference intervals and operations in the preprocessing phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>ε = 0.100 compressed (c) Error between (a) and (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .</head><label>8</label><figDesc>The effect of temporal compression on preview rendering. Temporal compression can result in false positives reported in incremental extractions used for preview rendering. The additional cells resulting from false positives produce minor visual artifacts seen in (c) a difference image between preview renderings of (a) uncompressed and (b) compressed versions of the data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 8illustrates the effect of temporal compression on preview rendering.It is important to pay close attention to boundary conditions for the difference intervals.Recall that active cells for an isovalue q are those in the rectangular region (−∞, q) × (q, ∞), two open intervals. Consider the example of Figure 2a when q = b at time step t 0 . Although q = b, the cell C(t 0 ) = [b, d] is not a member of A (t 0 ) for time step t 0 because the query range consists of open intervals, i.e., b ∈ (−∞, b). When the interval values for the cell change to C(t 1 ) = [a, c], the cell becomes active in t 1 and must be added to the current active cell list. Similarly, consider the same case when q = a at time step t 0 . The cell C(t 0 ) = [b, d] is still not a member of A (t 0 ) for time step t 0 . When</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9 .</head><label>9</label><figDesc>A typical isosurface from the 5jet dataset. This frame is from late in the dataset where the flow is nearly in it's steady state. the interval values for the cell change to C(t 1 ) = [a, c], the cell remains inactive even though q = a, again because the query range consists of open intervals, a ∈ (−∞, a). Further analysis on all 11 cases reveals that difference intervals can be either open or half-open, see Figure 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Extraction times for the argon bubble data set for each temporal compression level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>•</head><label></label><figDesc>Kenneth W. Waters is with the Institute for Data Analysis and Visualization at the University of California, Davis, E-mail: kwwaters@gmail.com.</figDesc><table><row><cell>Span Space</cell><cell>Geometric Space</cell></row><row><cell>(a)</cell><cell>(b)</cell></row><row><cell>m a x</cell><cell></cell></row><row><cell>=</cell><cell></cell></row><row><cell>m i n</cell><cell></cell></row><row><cell cols="2">Active Cells</cell></row><row><cell>q</cell><cell></cell></row><row><cell>max</cell><cell></cell></row><row><cell>min</cell><cell></cell></row><row><cell></cell><cell>(c)</cell></row><row><cell cols="2">Isosurface</cell></row></table><note>• Christopher S. Co is with the Institute for Data Analysis and Visualization at the University of California, Davis, E-mail: co@cs.ucdavis.edu.• Kenneth I. Joy is with the Institute for Data Analysis and Visualization at the University of California, Davis, E-mail: joy@cs.ucdavis.edu Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.Contouring Fig. 1. Span space and isosurface extraction. Span space is a 2D space used to extract active cells from a data set. Cells are represented as points positioned by the cell's minimum and maximum intensity value. In this space, the problem of active cell determination becomes a 2D range search problem. Contouring of the active cells creates geometry that represents the desired isosurface.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .Table 2 .</head><label>12</label><figDesc>Summary of preprocessing results. The timing results include both temporal compression and difference interval calculations. Summary of results from the timing experiment.</figDesc><table><row><cell></cell><cell>ε</cell><cell cols="3">Argon Bubble Dataset Total size of operation sets Build time</cell></row><row><cell></cell><cell>0.025 0.050 0.100</cell><cell>7496 MB 4873 MB 2821 MB</cell><cell cols="2">83 min 75 min 65 min</cell></row><row><cell></cell><cell>ε</cell><cell cols="3">5jet Dataset Total size of operation sets Build time</cell></row><row><cell></cell><cell>50 100 200</cell><cell>11574 MB 8078 MB 5422 MB</cell><cell cols="2">96 min 75 min 57 min</cell></row><row><cell>ε</cell><cell cols="3">Argon Bubble Dataset Average incremental Average number extraction time of active cells</cell><cell>Percentage of false positives</cell></row><row><cell>0.025 0.050 0.100</cell><cell></cell><cell>437.11 ms 443.31 ms 434.38 ms</cell><cell>255,932 271,588 315,582</cell><cell>3.34 % 9.74 % 27.54 %</cell></row><row><cell>ε</cell><cell cols="3">5jet Dataset Average incremental Average number extraction time of active cells</cell><cell>Percentage of false positives</cell></row><row><cell>50 100 200</cell><cell></cell><cell>134.31 ms 129.46 ms 127.72 ms</cell><cell>43,845 45,460 49,668</cell><cell>2.94 % 6.73 % 16.61 %</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported by the National Science Foundation under contracts ACR 9982251 and ACR 0222909, through Lawrence Livermore National Laboratory under contract B523818, and by Lawrence Berkeley National Laboratory. We thank the members of the Visualization and Graphics Group of the Institute for Data Analysis and Visualization (IDAV) at UC Davis. The time-varying argon bubble data set was provided by the Center for Computational Sciences and Engineering at the Lawrence Berkeley National Laboratory. We thank Kwan-Liu Ma for providing the 5jet data set to use. We especially thank Christof Nuber for the use of his out-of-core range searching code.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">ShellSplatting: Interactive Rendering of Anisotropic Volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">P</forename><surname>Botha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Data Visualisation 2003</title>
		<editor>G. P. Bonneau, S. Hahmann, and C. D. Hansen</editor>
		<meeting>the Symposium on Data Visualisation 2003<address><addrLine>Aire-la-Ville, Switzerland, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>Eurographics Association</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="105" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">I/O Optimal Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>R. Yagel and H. Hagen</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1997-10-19" />
			<biblScope unit="page" from="293" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Iso-splatting: A Point-Based Alternative to Isosurface Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh Pacific Conference on Computer Graphics and Applications</title>
		<meeting>the Eleventh Pacific Conference on Computer Graphics and Applications<address><addrLine>Pacific Graphics</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10-08" />
			<biblScope unit="page" from="325" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Adaptive Extraction of Time-Varying Isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gregorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Senecal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="683" to="694" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Near Optimal IsoSurface Extraction Algorithm Using the Span Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Interactive Point-Based Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tricoche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>H. Rushmeier, G. Turk, and J. J. van Wijk</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2004-10-10" />
			<biblScope unit="page" from="457" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Marching Cubes: A high resolution 3D surface reconstruction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGGRAPH 1987</title>
		<editor>M. C. Stone</editor>
		<meeting>ACM SIGGRAPH 1987</meeting>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive Visualization Of Very Large Datasets Using An Out-of-Core Point-Based Approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Nuber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Bruckschen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the High Performance Computing Symposium 2003 (HPC 2003)</title>
		<editor>I. Banicescu</editor>
		<meeting>the High Performance Computing Symposium 2003 (HPC 2003)<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Isosurface Extraction in Time-Varying Fields Using a Temporal Hierarchical Index Tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Isosurfacing in Span Space with Utmost Efficiency (ISSUE)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="287" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Isosurface Extraction in Time-Varying Fields Using a Temporal Branch-on-Need Tree (T-BON)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>D. Ebert, M. Gross, and B. Hamann</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1999-10-24" />
			<biblScope unit="page" from="147" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient Point-Based Isosurface Exploration Using the Span-Triangle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Von Rymon-Lipinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Hanssen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ritter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Keeve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<editor>H. Rushmeier, G. Turk, and J. J. van Wijk</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2004-10-10" />
			<biblScope unit="page" from="441" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast Extraction and Rendering of Isosurfaces from 4D Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vrolijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">P</forename><surname>Botha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th annual conference of the Advanced School for Computing and Imaging</title>
		<editor>J. J. van Wijk, J. W. J. Heijnsdijk, K. G. Langendoen, and R. Veltkamp</editor>
		<meeting>the 10th annual conference of the Advanced School for Computing and Imaging</meeting>
		<imprint>
			<publisher>ASCI</publisher>
			<date type="published" when="2004-06" />
			<biblScope unit="page" from="281" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Isosurface Extraction using Fixed-Sized Buckets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">W</forename><surname>Waters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroVis 2005</title>
		<editor>K. Brodie, D. Duke, and K. I. Joy</editor>
		<meeting>EuroVis 2005</meeting>
		<imprint>
			<date type="published" when="2005-03" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Octrees for Faster Isosurface Generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
