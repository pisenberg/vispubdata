<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Isosurface Extraction and Spatial Filtering Using Persistent Octree (POT)</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Qingmin</forename><surname>Shi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Fellow, IEEE</roleName><forename type="first">Joseph</forename><surname>Jaja</surname></persName>
						</author>
						<title level="a" type="main">Isosurface Extraction and Spatial Filtering Using Persistent Octree (POT)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>scientific visualization</term>
					<term>isosurface extraction</term>
					<term>indexing</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We propose a novel Persistent OcTree (POT) indexing structure for accelerating isosurface extraction and spatial filtering from volumetric data. This data structure efficiently handles a wide range of visualization problems such as the generation of viewdependent isosurfaces, ray tracing, and isocontour slicing for high dimensional data. POT can be viewed as a hybrid data structure between the interval tree and the Branch-On-Need Octree (BONO) in the sense that it achieves the asymptotic bound of the interval tree for identifying the active cells corresponding to an isosurface and is more efficient than BONO for handling spatial queries. We encode a compact octree for each isovalue. Each such octree contains only the corresponding active cells, in such a way that the combined structure has linear space. The inherent hierarchical structure associated with the active cells enables very fast filtering of the active cells based on spatial constraints. We demonstrate the effectiveness of our approach by performing view-dependent isosurfacing on a wide variety of volumetric data sets and 4D isocontour slicing on the time-varying Richtmyer-Meshkov instability dataset.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Isosurface extraction is an important tool for visualizing multidimensional scalar fields. It exposes contours of a constant scale value, thus providing an effective way to discover the embedded structures such as the boundaries between different types of tissues, the shockwave in a fluid dynamics experiment, or the changing of 3D contours in time-varying data sets obtained from physical simulations.</p><p>Since the introduction of the Marching cubes algorithm <ref type="bibr" target="#b14">[15]</ref>, much of the research effort has been put on reducing the amount of data touched for the extraction of the isosurface. A number of efficient techniques have been developed such that the cost of the extraction is more sensitive to the size of the isosurface than to the size of the complete data set <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>More aggressive approaches have been proposed in recent years to only extract the relevant portion of the isosurface needed for visualization. For example, in 3-D isosurface visualization, the view-dependent approach <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b18">19]</ref> and the ray-tracing approach <ref type="bibr" target="#b17">[18]</ref> extract only the visible part of the isosurface. For multi-dimensional data, visualization is possible only for its 3D slices <ref type="bibr" target="#b28">[29]</ref>. Thus only isosurfaces in such slices need to be extracted. We call the extraction of relevant portion of the isosurface spatial filtering.</p><p>In the context of scalar fields sampled on a structured grid, the data set consists of a set of cubes (cells) with sampled scalar values associated with their vertices. We call a cell active if its value range covers the specified isovalue. We call a cell relevant if it contains the isosurface patches that need to be rendered. The problem of identifying active cells can be viewed as the range stabbing query of computational geometry. The type of problem involved in identifying relevant cells depends on the type of the spatial filtering operation. For example, in view-dependent isosurfacing, it is to single out only the visible cells for triangulation and rendering. In ray tracing, it is to find the cells that the rays shooting from the view point first encounter. And in 4D isocontour slicing, it is to find the cells that are cut by a 4D hyperplane.</p><p>• Qingmin <ref type="bibr">Shi</ref>  In isosurface extraction with spatial filtering, the extraction part is basically a query in the scalar value space and the filtering part is a query in the spatial grid space. The problem is to develop a structure that efficiently supports simultaneous queries both in the value space and in the spatial space.</p><p>A straightforward approach to handle the space filtering is to first identify the active cells using existing algorithms (e.g. <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b3">4]</ref>) and then pick among these active cells the relevant ones. However, this approach may waste a significant amount of time on identifying and then discarding irrelevant cells, as these algorithms produce no particular spatial ordering among the active cells initially identified. Another approach is to use data structures based on spatial partitioning such as the well known min-max octree <ref type="bibr" target="#b29">[30]</ref>. This approach is not efficient either since such data structures are not optimal in terms of performing value based queries.</p><p>In this paper, we provide a data structure called the Persistent Octree (POT) that enables very efficient identification of cells that are simultaneously relevant and active. It possesses the properties of both the interval-tree based isosurface extraction schemes, which are known to be efficient in extracting active cells, and the octree-based schemes (notably the Branch-On-Need Octree (BONO) <ref type="bibr" target="#b29">[30]</ref>), which are well suited for spatial filtering. In fact, POT is provably optimal in terms of asymptotic bounds for both space and query time for identifying active cells. It achieves the worst case time complexity of O(log N + K) for active cell identification, where N is the number of cells in the data set and K is the number of active cells, and requires O(N) space. At the same time, for each possible isovalue, the corresponding active cells are already encoded a priori in a compact octree. Such an inherent hierarchical structure enables very efficient spatial filtering for identifying active cells that are also relevant.</p><p>We demonstrate the effectiveness of POT by applying it to viewindependent and view-dependent isosurface extraction and 4D isocontour slicing. Our algorithm for view-dependent isosurface extraction follows the general approach of Livnat and Hansen <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>, but improves upon theirs in that we visit in a view-dependent way a compact octree consisting ONLY active cells. Our techniques can also be combined with the idea of implicit occluders <ref type="bibr" target="#b18">[19]</ref> to only traverse the visible part of the compact octree without actually rendering any isosurface. Our 4D isocontour slicing algorithm deals with timevarying data and handles a more general problem than those discussed in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b8">9]</ref> in that it allows visualizing not only the isosurface at individual timesteps but also the change of the isosurfaces across timesteps.</p><p>We conduct experimental comparison of our approach for view-dependent isosurface extraction with BONO, which is considered one of the most efficient data structures for isosurface extraction <ref type="bibr" target="#b25">[26]</ref>. Results show that our data structure consistently performs better than BONO. In particular, we measure the number of tree nodes visited by POT and BONO for the same view-dependent isosurface extraction queries and show that POT saves a significant amount (as much as 70%) of node visits compared with BONO. We also test our 4D isocontour slicing algorithm on a subset of the Richtmyer-Meshkov instability data set <ref type="bibr" target="#b16">[17]</ref> that consists of 35 GB of time-varying data and are able to perform the isosurface extraction, slicing and rendering very fast (for example less than 15 seconds along the spatial dimensions). The remainder of this paper is organized as follows. We describe the concept of the persistent data structure and its application in range stabbing queries in Section 2. The POT structure and its traversal are presented in Sections 3. In Section 4, we show how POT can accelerate spatial filtering in the cases of view-dependent isosurface extraction and 4D contour slicing. Implementation issues are discussed in Section 5. Our experimental results are reported in Section 6. We discuss limitations of our approach in Section 7 and conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PERSISTENT DATA STRUCTURES</head><p>The notion of the persistent data structure was first introduced by Driscoll et al. <ref type="bibr" target="#b4">[5]</ref> as a space-efficient mechanism for maintaining the evolution history of dynamic data structures. It has been used to provide optimal solutions to a number of intersection problems in computational geometry (see for example <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b23">24]</ref>). A recent paper by Edelsbrunner et al. <ref type="bibr" target="#b5">[6]</ref> applied this technique to compute the Reeb graph. In this section, we give its properties and explain its application in handling range stabbing queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Properties</head><p>Suppose we have an ephemeral data structure, which may be modified due to the insertion or deletion of data elements. Each such modification is associated with a version number. The problem is to maintain all the versions of the ephemeral data structure such that, given a version number, the corresponding version can be easily accessed.</p><p>Persistent data structure is an elegant technique that provides a compact representation of all the versions of a so-called linked structure, which consists of a set of nodes with a fixed number of pointers. In particular, Driscoll et al. <ref type="bibr" target="#b4">[5]</ref> showed that, if an ephemeral tree structure requires only a constant number of node changes for each insertion or deletion, then it can be made persistent such that each version of the tree can be queried with the same asymptotic time bound as the ephemeral version and a persistent tree structure obtained as a result of N insertions/deletions requires only O(N) space.</p><p>The basic idea of making a tree structure persistent is to augment its nodes with additional pointers so that a node can have pointers to different versions of sub-trees. As a result, a new version of a node does not need to be created until enough changes have been made to its successors. The cost of an insertion or a deletion, which possibly includes the creation of new versions of several nodes, thus can be amortized over a long sequence of update operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Handling Range Stabbing Queries</head><p>In the context of isocontour generation, assume that we have already computed the minimum and maximum values for each cell. We sort the extreme values in increasing order and employ a value sweep from the smallest extreme value to the largest. In the process, we maintain a data structure D to store the cells whose value ranges are "stabbed" by the current sweeping value. A cell is inserted into D when its minimum value is encountered and removed when its maximum value is reached. Each such update operation creates a new version of D with the version number being the current sweeping value. <ref type="figure" target="#fig_0">Figure 1</ref> illustrates the sweeping process. It is easy to see that, given a particular isovalue v, the most recent version of D no later than v stores the exact set of active cells corresponding to v, which means that determining active cells is as simple as traversing this particular version of D. Of course, our task is not simply to find the active cells. We need to determine the cells that are both active and relevant. To this end, we want D to be a data structure that can efficiently filter out irrelevant cells. To achieve optimality in terms of reporting active cells, we want the size of D to be linear in the number of active cells it stores. And finally, to make it persistent without introducing additional space in an asymptotic sense, addition or deletion operations on D are allowed to incur only a constant number of node changes. In the next section, we introduce the Persistent OcTree (POT), which satisfies all the above requirements.</p><p>We shall note that, while the fact that a dynamic binary search tree can be made persistent in a space efficient way has long been established (see <ref type="bibr" target="#b4">[5]</ref>), making a octree persistent is not trivial and generally is not possible without introducing non-linear space (we will give such a "bad" case in Section 3.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PERSISTENT OCTREES (POTS)</head><p>In this section, we will first describe an ephemeral data structure called the compact octree to index the active cells for a particular isovalue, which allows efficient search and update operations. We then show how it can be made persistent to yield an efficient data structure to handle the isosurface extraction with spatial filtering. Our description assumes that the dimension of the data set is three. But exactly the same technique can be applied to higher dimensional data sets as well. In the rest of the paper, we will call the the space occupied by the entire data set a volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Compact Octrees</head><p>A classic octree is based on hierarchical regular partitioning. The root represents the entire volume. A node u has 8 children, each getting one octant of the subvolume of u. For data resolutions other than powers of two, we adopt the strategy of BONO <ref type="bibr" target="#b29">[30]</ref> by viewing the hyperoctree as a complete one but avoiding allocating nodes for empty subtrees. A node at the lowest level of the tree represents a cell and is colored black if the cell is active and white otherwise. A node at a higher level is assigned one of the three colors: black, white, and gray. A black (resp. white) node indicates that the entire subvolume it represents consists of only black (resp. white) cells. A gray node corresponds to a subvolume that contains both black cells and white cells. <ref type="figure" target="#fig_1">Figure 2</ref> gives a 2D illustration of the octree. One problem with such an octree is that an update operation may require up to O(log N) node changes, where N is the size of the current octree. This prevents the octree from being made persistent in a spaceefficient way. In fact, consider the case when no value ranges of any two cells overlap. Each insertion or deletion operation would require O(log N) nodes to be modified, resulting in a persistent data structure of size O(N log N).</p><p>In a compact octree, we store only black and gray nodes, and replace pointers to white nodes with NULL pointers. In addition, we "collapse" subtrees where each node has only one child. Formally, consider a path Π from the root to a leaf node and let u 1 , u 2 , . . . , u k be a subpath of Π such that i) u 1 is not the root and thus has parent u 0 ; ii) u 0 either is a root node or has more than two gray or black children; iii) u i is the only gray or black child of u i−1 for i = 2, . . . k; and iv) u k is either a black node or has at least two gray or black children. We then replace the pointer in u 0 which points to u 1 with a jumper, which points to u k and stores the path from u 0 to u k . The subvolume of a node w is uniquely determined by the path from the root to w. <ref type="figure" target="#fig_2">Figure 3</ref> shows the compact octree derived from the one shown in <ref type="figure" target="#fig_1">Figure 2</ref>(b). Since each node in the compact octree, except for the root, has at least two children and each leaf node represents at least one active cell, the size of the tree structure is obviously linear in the number of active cells it stores and so is the time it takes to traverse the tree to report these active cells. Furthermore, we can show that the compact octree requires only an amortized constant number of node changes for each insertion or deletion when applied to our particular problem (see Section 4.1 of <ref type="bibr" target="#b24">[25]</ref> for details). This is due to the fact that, during the value sweeping process, each cell will be inserted into and removed from the compact octree exactly once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Making a Compact Octree Persistent</head><p>In a compact octree, each internal node has exactly 8 (possibly NULL) jumpers. To make such a tree persistent, we allow a node to hold k additional jumpers, where k is a small constant. Each of the 8 + k jumpers is associated with a version number and a path.</p><p>An update operation with a new version number v is always performed on the latest version of the POT. New nodes are created as necessary. When we need to change a jumper in a node u, we first try to find an empty slot in u. If there is one, then the new jumper is added to u along with the version number of the update operation. Otherwise, we create a copy u of u. The initial 8 jumpers of u are set to be their latest values in u and are assigned the version number v. Note that we also need to add a jumper to u to the latest parent of u . Thus, this jumper copying step will be propagated towards the root until a node with a free slot is reached or the root itself is copied. An update operation with the latest existing version number will replace jumpers rather than copying them. <ref type="figure" target="#fig_3">Figure 4</ref> illustrates a POT using a 1D example. We have a grid of 8 1D "cubes" (segments) each of which is labeled by a 3-bit string. In <ref type="figure" target="#fig_3">Figure 4</ref>(a), these segments are represented by vertical stripes separated by vertical lines with their labels shown at the bottom of the respective stripes. The numbers on the left are the scalar values. The vertical extent of the shaded rectangles represents the value ranges of the corresponding segments. For a particular isovalue, the active segments are indexed by a compact binary tree. <ref type="figure" target="#fig_3">Figure 4(b)</ref> gives the persistent binary tree, in which each node has three available slots for jumpers. The label Ln or Rn tells whether a jumper corresponds to a left branch or a right branch as well as the associated version number. The numbers above the root nodes are their version numbers and the binary string beside each of the remaining nodes indicates the subvolume it represents. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Constructing a POT</head><p>To construct POT, we first collect all the cells, and temporarily keep two copies for each of them. One copy uses the minimum value as its key and the other uses the maximum value. We sort the cells using their keys in increasing order and then scan through the sorted list. For each cell c we encounter, if its key is its minimum value, we insert c into the current version of the compact octree. Otherwise we delete c from the current version. If this value is larger than the most recent version number, a new version is created. Since an insertion or a deletion on a compact octree requires only O(1) node changes, the POT is linear in the total number of cells in the data set. To further reduce the size of the POT, we do not actually store a node w if it is a leaf for all the versions of the POT it belongs to. Such omission is recorded by repointing any jumper to w to the node where that jumper is stored.</p><p>Sorting the 2N cells requires O(N log N) time. The construction of the POT itself is also O <ref type="figure">(N log N)</ref> because each insertion or deletion may touch a single path in the POT from the root to a leaf whose length is at most O(log N).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Traversing A POT</head><p>To traverse the version of a POT corresponding to a particular isovalue v, we first identify the root with the largest version number smaller than or equal to v. To report all the active (but not necessarily relevant) cells, we simply traverse an appropriate version of the POT by following the latest jumpers no later than v. For example, in <ref type="figure" target="#fig_3">Figure 4(b)</ref>, the portion of the POT colored in red and connected by bold edges is the active version corresponding to isovalue 4. Once we reach a leaf node, we report all the cells within its corresponding subvolume. It is easy to see that the complexity of reporting all the active cells is O(log M + K), where M is the number of roots in the POT and K is the number of active cells. The O(log M) term reflects the fact that we may have to find the appropriate version of the root using a binary search. M ≤ N and typically is small enough (in the order of tens in all of our experiments) to be considered a constant. Consequently, the complexity of reporting active cells using a POT depends solely and linearly on the number of active cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SPATIAL FILTERING OF ACTIVE CELLS USING POT</head><p>A more attractive feature of the POT is that each version of the POT provides a spatial partitioning of the active cells, which enables very efficient spatial filtering. we now discuss it in the context of viewdependent isosurface extraction and 4D contour slicing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">View-dependent isosurface extraction</head><p>A view-dependent isosurface extraction avoids triangulating and rendering invisible portions of the isosurface. The most commonly used data structures for the occlusion test are based on the octree. The nodes in the octree are visited in a front-to-back order based on the view point. An occlusion mask is maintained against which the visibility of the octree nodes are tested. Only visible nodes and their descendants are examined further.</p><p>Using a standard octree (or octree for short), as long as there is an active cell ν in the corresponding subvolume, a node will be active. This means a long list of nested nodes containing ν may have to be examined, since nodes at higher level (thus corresponding to larger subvolumes) are more likely to be determined as visible even if the patch of the isosurface in it only occupies a tiny portion of the subvolume. Worse yet, that patch may not even be visible. On the other hand, in POT we can follow the jumpers to get to a small active subvolume ν very quickly and determine if the isosurface patch inside it is visible. <ref type="figure" target="#fig_4">Figure 5</ref> illustrates such a case. In <ref type="figure" target="#fig_4">Figure 5</ref>, the active cells are colored in gray. There are three sections of the isosurface: A, B, and C. Part of A and B are visible and the entire section of C are occluded by A. In order to determine the visibility of the cell that contains C, an octree will have to examine eight nodes in the upper-left quarter of the data space (four children of the node w corresponding to the left-top quarter and four grand children of w, including the one containing C). Using POT, only the node containing C needs to be checked against the occlusion mask. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">4D isocontour slicing</head><p>In 4D isocontour visualization, we want to slice the 4D isocontour using a 4D hyperplane to generate a 3D isosurface. POT provides a simple and efficient way to identify the active cells that are also cut by the hyperplane. At each node u of the version of POT that corresponds to the isovalue, we check each jumper to see if the subvolume of the node w it points to is cut by the hyperplane. If this is not the case, then the subtree rooted at w will not be visited. Notice again that using jumpers allows us to quickly get to a node representing a small active subvolume without having to access a long list of nested subvolumes at higher levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION ISSUES</head><p>We implemented the internal-memory view-dependent isosurface extraction algorithm using POT as the underline indexing structure. The overall scheme is similar to the one described in <ref type="bibr" target="#b10">[11]</ref>. We use a hierarchical set of occlusion masks to keep track of the screen pixels that are covered by previously extracted isosurface patches. Each pixel of an occlusion mask at a certain level corresponds to an 8 × 8 array of pixels at the next level. Precomputed binary coverage masks are used to quickly determine the pixels covered by the newly generated isopatches and to update the occlusion masks at the lowest level. Triage coverage masks <ref type="bibr" target="#b7">[8]</ref> are used to speedup the update of the occlusion masks as well as the occlusion tests at higher levels. Like <ref type="bibr" target="#b11">[12]</ref>, the update of the occlusion mask is performed from bottom up, thus restricting the propagation of the change to a limited number of levels. The bounding rectangle of the projection of a node is used to conservatively test its visibility.</p><p>As suggested in <ref type="bibr" target="#b13">[14]</ref>, our POT is built not on individual cells, but on a small cube of cells (4 × 4 × 4 in our implementation) called supercells. Using supercells not only reduces the size of the indexing structure but also avoids excessive visibility tests, which usually are not justifiable at very low levels of the structure. Once we have identified an active and visible supercell, we search it using the standard Marching Cubes algorithm to identify the active cells and perform triangulation on them without performing the visibility test. <ref type="figure" target="#fig_5">Figure 6</ref> shows a view dependent rendering of the MRbrain data set, a side view of the visible portion of the isosurface and the final occlusion mask.</p><p>For 4D isocontour slicing, the size of the data set is often too big to fit in memory and therefore has to reside on disk. We choose the size of a supercell to be approximately the same as a disk block size (16 × 16 × 16 in our experiment) so that it can be loaded into memory using one I/O access. When searching the POT, we maintain the path from the root to every leaf node we reach. This path provides sufficient information for locating the corresponding supercell on disk and loading it into memory for further processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTAL RESULTS</head><p>We conducted two sets of experiments to evaluate the performance of POT. In the first set, we compared the POT to the classic BONO structure in the case of view-independent and view-dependent isosurface extraction for 3D volumetric data. In the second set of experiments, we studied the performance of POT for 4D isocontour slicing of timevarying data.</p><p>System setup Our experiments were performed on a PC with dual 3.0 GHz Xeon processors, 8 GB main memory, 140 GB local disk with around 50 MB/sec I/O peak transfer rate, and one NVidia6800 Ultra GPU card with a bi-directional 1 Gbps data transfer rate to memory via PCI-Express (x16) Bus. It runs Linux 2.4.21-27.ELsmp. Only one processor was used.</p><p>Data description Four sets of data were used in our test. The complete Richtmyer-Meshkov instability (R-M) data set consists of 274 timesteps, each consisting of a 3D grid of 2048 × 2048 × 1920 8-bit scalar values. We downsampled each timestep by a factor of 2 in each dimension. For 4D isocontour slicing we used every 8th timestep starting from timestep 0. The resulting data set consisted of 35 timesteps and the overall size of the data set was about 35 GB. For view-dependent isosurface extraction we only used timestep 248. A summary the other three data sets along with a single timestep in the Richtmyer-Meshknov data set is given in <ref type="table">Table 1</ref>. The construction times of the POTs for these data sets are reported in <ref type="table">Table 2</ref>. <ref type="figure" target="#fig_7">Figure 8</ref> gives some views of these data sets. As a base for comparison, we also implemented the BONO algorithm. At each internal node of the BONO, we stored a single pointer to its first child and a bit mask stating which children actually exist. As in our POT implementation, the BONO was also built on 4 × 4 × 4  <ref type="table">Table 2</ref>. Construction time of the POTs.</p><p>supercells. <ref type="table">Table 3</ref> compares the sizes of the POTs and BONOs. POT requires more space than BONO by a factor of 1.6 to 4, which is not surprising, considering the fact that our BONO implementation is almost pointerless and POT stores a number of pointers at each node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">View-independent and view-independent isosurface extraction</head><p>We compare the performance of BONO and POT in terms of search efficiency for view-independent and view-dependent isosurface extraction. The comparison of index searching time for view-independent isosurfacing is reported in <ref type="table">Table 4</ref>. The screen size was 512 × 512. We note that the actual execution time also includes the time to search the supercells, perform triangulation, and render the isosurface, which is identical for both BONO and POT. Except for the Stanford bunny data set, POT was able to achieve a significant speedup relative to BONO. Its search time is 34% less than that of BONO for the R-M data set, 18% for the MRbrain set, and 16% for the Head Aneuyrism set.</p><p>The performance comparison of these two data structures for viewdependent isosurface extraction is given in <ref type="table">Table 5</ref>. Unlike viewindependent isosurface extraction where all active cells are extracted before the other steps take place, the surface extraction, triangulation, and rendering steps are intertwined in view-dependent isosurface extraction. It is very difficult to accurately measure the index search time. Therefore, we instead report the number of nodes visited and the overall execution time. However, we must point out that, as explained before, the latter is not an appropriate measurement of the effectiveness of the index structure. The number of tree nodes visited is a more accurate comparison benchmark for two reasons. First, it is implementation independent. Second, since for the same isovalue and view point, the number of active and relevant active cells for both POT and BONO are exactly the same, this benchmark more accurately reflects how efficiently each data structure is searched.</p><p>It can be seen that POT performs much better than BONO for all the data sets in terms of the number of nodes visited. The number for POT is only 30% to 73% that of BONO. This is consistent with our argument that POT locates active and relevant cells more efficiently. We also observe that the overall execution time of POT is also consistently better than that of BONO, albeit in a lesser degree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">4D isocontour slicing</head><p>In this experiment, we demonstrate the efficiency of our scheme in computing the slices of the 4D isosurfaces along different axes, especially the X, Y, and Z axes, in which case the slices reflects the change of the isosurface across time steps.</p><p>Constructing the 4D POT for the 35 time steps of the R-M data set took about 68 minutes, a majority of which was spent on collecting the extreme values. The construction of the POT itself took only 2 minutes. The resulting indexing structure occupies 106 MB of memory.</p><p>We measure the performance of our algorithm using different combinations of isovalues and cutting planes. <ref type="figure">Figures 7(a)</ref>, (b) and (c) show the execution time of our program as a function of the isovalue for three different cutting hyperplanes as well as its decomposition into five computation steps. We also give the number of triangles generated in each case in <ref type="figure">Figure 7(d)</ref>.</p><p>It can be seen that the number of triangles varies from 26 million for isovalue 210 to 146 million for isovalue 70. We were able to extract and render the most complicated cuts (along the T-axis) in less than 100 seconds, and much faster for other cuts. Searching the POT is very fast in all the cases. Even for the most time-consuming slicing along the T-axis, it only took 0.26 seconds on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>We now briefly discuss the limitations of our technique. First, the data sets we used are from discrete fields, and hence the number of possible versions is limited. This presents a unique opportunity to avoid storing the cells with constant values, since they are inserted and removed during the update of a single version of the POT. This may not be the case if the data sets are from continuous fields, which could lead to larger indexing structure size. However, we do not expect the increase in storage to be significant since changes of the isosurface between versions would be smaller, which allows better node sharing between versions.</p><p>A second possible limitation is that the construction time of a POT is typically longer than that of a BONO. However, we intend this technique to ultimately be used for interactive exploration of the data sets and hence the preprocessing time is less important.</p><p>Finally, for view-dependent rendering, our scheme, similar to the well known BONO/Grid Tree based scheme <ref type="bibr" target="#b10">[11]</ref>, requires the front-toback generation of the triangles in order to update the coverage mask. This may lead to inefficient I/O operation for large data sets residing on disk. One possible solution is to use the technique of Implicit Occluders <ref type="bibr" target="#b18">[19]</ref> to first generate the coverage mask and then perform a traversal of the visible part of the octree. This approach requires further exploration.   <ref type="table">Table 5</ref>. Performance comparison of view-dependent isosurface extraction. The same set of isovalues as in the <ref type="table">Table 4</ref> are used. (c) Cutting hyperplane: T = 264.</p><p>(d) # of triangles generated for different cuttings <ref type="figure">Fig. 7</ref>. Performance measurements for 4D isocontour slicing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have presented a novel POT data structure to accelerate the isosurface extraction with spatial filtering. It is asymptotically optimal in terms of space and search time. The set of active cells for an isovalue naturally form a compact octree that allows the active cells to be filtered based on certain spatial criteria very quickly. In particular, we demonstrate the effectiveness of this technique by applying it to view-dependent isosurface extraction and 4D isocontour slicing. Our experiments show that for view-dependent isosurface extraction, our data structure performs consistently better than the widely used BONO structure. For 4D isocontour slicing, our tests on the Richtmyer-Meshkov data set show that POT enables very fast search and that the overall algorithm can perform simultaneous isocontouring and slicing in a very efficient manner.</p><p>Because of the inherent hierarchical structure associated with the active cells for any isovalue, POT can be used to improve the performance of other visualization schemes such as ray tracing <ref type="bibr" target="#b17">[18]</ref> and multi-resolution isosurface rendering, since they also rely on the hierarchical pruning of the data volume.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Handling range stabbing queries using value sweeping.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>A 2D illustration of the octree. (a) A set of active cells. (b) The corresponding octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>A 2D illustration of the compact octree. Each jumper is associated with a path, which is represented by a list of 2-bit strings. NULL pointers are omitted. Each 2-bit string gives the YX encoding of the branch index of the corresponding edge in the original octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>A 1D illustration of the POT. Each node has three slots for jumpers. (a) The evolution of active segments for different isovalues. (b) The resulting POT. An edge with a bar underneath it represents a NULL jumper.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>A 2D illustration of the pruning of the POT for view-dependent isosurface extraction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>View dependent rendering of the MRbrain data set. Left: the normal view of the MRbrain data set; Center: a side view of the visible part of the isosurface; Right: the final occlusion mask at the lowest level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>(a) A normal view of the Richtyer-Meshkov instability data set (b) A close view of the Head Aneuyrism data set. (timestep = 240; isovalue = 190). (isovalue=55) (a) A normal view of the Stanford terra-cotta bunny. (b) A top view of the MRbrain data. (isovalue = 1750) (isovalue = 1750) Views of the data set used. (a) Isovalue: 100; Cutting hyperplane: X = 500. (b) Isovalue: 100; Cutting hyperplane: Z = 650.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Slices of 4D isocontours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and Joseph JaJa are with the Institute for Advanced Computer Studies and the Department of Electrical and Computer Engineering at the University of Maryland, College Park, E-mail: {qshi,joseph}@umiacs.umd.edu Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 .Table 4 .</head><label>34</label><figDesc>Storage requirements for BONO and POT (index only). Performance comparison of view-independent isosurface extraction.</figDesc><table><row><cell cols="2">data set isovalue BONO index search time (ms) POT index search time (ms) Speedup of index searching time relative to BONO</cell><cell cols="2">R-M Standford Bunny MRbrain Head Aneuyrism 190 1750 1750 55 710 64 17 22 401 61 14 15 1.77 1.05 1.21 1.47</cell></row><row><cell>BONO POT Speedup relative to BONO</cell><cell>data set # of Nodes Visited Execution Time (ms) # of Nodes Visited Execution Time (ms) # of Nodes Visited Execution Time</cell><cell>R-M 212,992 10,877 142,157 9,511 1.50 1.14</cell><cell>Standford Bunny MRbrain Head Aneuyrism 19,897 7,318 17,260 1,130 614 938 6,076 5,368 6,467 1,040 602 806 3.27 1.36 2.67 1.09 1.02 1.16</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank Mark Duchaineau for making the Richtmyer-Meshkov instability data set available to the University of Maryland through Amitabh Varshney, and Amitabh Varshney for getting us interested in this problem and for his gracious help at various stages of this research. The Standford terra-cotta bunny data set and the MRbrain data set were obtained from the Stanford Volume Data Archive (http://graphics.stanford.edu/data/voldata/). The</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Head Aneuyrism data set was obtained from the data archive at the Wilhelm Schickard Institute for Computer Science GRaphical-Interactive Systems, University of Tübingen (http://www.gris.unituebingen.de/areas/scivis/volren/datasets/new.html). This work was supported in part by the NSF Research Infrastructure Grant CNS-04-03313.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Space efficient fast isosurface extraction for large datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Bordoloi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;03</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="201" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Persistency in computational geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Boroujerdi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Moret</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Canadian Conf. Comp. Geometry (CCCG 95)</title>
		<meeting>7th Canadian Conf. Comp. Geometry (CCCG 95)<address><addrLine>Québec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="241" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactive out-of-core isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Speeding up isosurface extraction using interval trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="170" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Making data structures persistent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Driscoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sarnak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sleator</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="86" to="124" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Timevarying reeb graphs for continuous space-time data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCG&apos;04: Proceedings of the twentieth annual symposium on computational geometry</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="366" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Span filtering: an optimization scheme for volume visualization of large finite element models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;91: Proceedings of the 2nd conference on Visualization &apos;91</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hierarchical polygon tiling with coverage masks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Greene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-GRAPH &apos;96: Proceedings of the 23rd annual conference on Computer graphics and interactive techniques</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interactive view-dependent rendering of large isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gregorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;02</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="475" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Further results on generalized intersection searching problems: counting, reporting, and dynamization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Janardan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Smid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="282" to="317" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">View dependent isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="175" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Dynamic view dependent isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<idno>UUSCI-2003-004</idno>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>Salt Lake City, UT 84112, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Scientific Computating and Imaging Institute, University of Utah</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using the span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="84" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interactive point-based isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tricoche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;04</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="457" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Marching Cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGGRAPH Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Encoding volumetric grids for streaming isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd International Symposium on 3D Data Processing, Visualization and Transmission</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="665" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Very high resolution simulation of compressible turbulence on the IBM-SP system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Mirin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">R</forename><surname>Woodward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Shieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Dannevik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Dimits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Eliason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 ACM/IEEE Conference on Supercomputing (CDROM)</title>
		<meeting>the 1999 ACM/IEEE Conference on Supercomputing (CDROM)</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for isosurface rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-P</forename><surname>Sloan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="233" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Implicit occluders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pesco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedigns of the IEEE Symposium on Volume Visualization and Graphics</title>
		<meeting>eedigns of the IEEE Symposium on Volume Visualization and Graphics<address><addrLine>Austin, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="47" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Planar point location using persistent search trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sarnak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="669" to="679" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Isosurface extraction in time-varying fields using a temporal hierarchical index tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A fast volume rendering algorithm for time-varying fields using a time-space partition (TSP) tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="371" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Isosurfacing in span space with utmost efficiency (ISSUE)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="287" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Optimal and near-optimal algorithms for generalized intersection reporting on pointer machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jaja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="382" to="388" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Efficient isosurface extraction for large scale timevarying data using the persistent hyperoctree (phot)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jaja</surname></persName>
		</author>
		<idno>CS-TR-4776</idno>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
		<respStmt>
			<orgName>Institute of Advanced Computer Studies (UMIACS), University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A case study of isosurface extraction algorithm performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Joint Eurographics-IEEE TCCG Symposium on Visualization</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="259" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Isosurface extraction in time-varying fields using a Temporal Branch-on-Need Tree (T-BON)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="147" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Isosurface extraction using fixedsized buckets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">W</forename><surname>Waters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROGRAPHICS -IEEE VGTC Symposium on Visualization</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="207" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Extracting iso-valued features in 4-dimensional scalar fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Weigle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Banks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 IEEE Symposium on Volume Visualization</title>
		<meeting>the 1998 IEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="103" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
