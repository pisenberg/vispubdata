<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Trajectory-Preserving Synchronization Method for Collaborative Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lewis</forename><forename type="middle">W F</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frederick</forename><forename type="middle">W B</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rynson</forename><forename type="middle">W H</forename><surname>Lau</surname></persName>
						</author>
						<title level="a" type="main">A Trajectory-Preserving Synchronization Method for Collaborative Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Collaborative visualization</term>
					<term>network latency</term>
					<term>motion synchronization</term>
					<term>distributed synchronization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In the past decade, a lot of research work has been conducted to support collaborative visualization among remote users over the networks, allowing them to visualize and manipulate shared data for problem solving. There are many applications of collaborative visualization, such as oceanography, meteorology and medical science. To facilitate user interaction, a critical system requirement for collaborative visualization is to ensure that remote users will perceive a synchronized view of the shared data. Failing this requirement, the user&apos;s ability in performing the desirable collaborative tasks will be affected. In this paper, we propose a synchronization method to support collaborative visualization. It considers how interaction with dynamic objects is perceived by application participants under the existence of network latency, and remedies the motion trajectory of the dynamic objects. It also handles the false positive and false negative collision detection problems. The new method is particularly well designed for handling content changes due to unpredictable user interventions or object collisions. We demonstrate the effectiveness of our method through a number of experiments.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Collaborative visualization <ref type="bibr" target="#b9">[10]</ref> allows geographically separated users to access a shared virtual environment to visualize and manipulate datasets for problem solving without physical travel. Example works include fluid dynamics visualization <ref type="bibr" target="#b26">[27]</ref>, volume visualization <ref type="bibr" target="#b0">[1]</ref> and medical data visualization <ref type="bibr" target="#b25">[26]</ref>. In contrast to those working individually with standalone visualization applications, research studies have found that users working in groups through collaborative visualization applications can often work out a better solution for a given problem <ref type="bibr" target="#b16">[17]</ref>. To facilitate collaborative dataset manipulation for visualization, CSpray <ref type="bibr" target="#b20">[21]</ref> was designed to comprise a "spray-paint can metaphor" for users to edit a dataset in a graphical way. A control mechanism is provided for users to modify the dataset in a mutually exclusive manner. If a user changes the dataset, updates of the dataset will be broadcasted to remote users. However, the system does not address the inconsistency problem of dynamic objects due to network latency. Hence, if we conduct visualization on a time-dependent dataset <ref type="bibr" target="#b8">[9]</ref>, such as thunderstorms and tornados, synchronization of the dataset among remote users would be difficult. First, as this type of dataset changes continuously over time, it is difficult to guarantee that each of these changes will be reported timely to the remote users throughout the collaboration session. Second, as different users may be connected to each other or to the server via different network routes, they may perceive different amounts of network latency, and hence delay, in receiving the update messages. Although it is possible to introduce a further delay for the updated information to be presented to the users at a synchronized moment <ref type="bibr" target="#b6">[7]</ref>, it will substantially affect the interactivity of the collaboration.</p><p>Recently, we have developed a method to support global-wise synchronization for collaborative applications <ref type="bibr" target="#b13">[14]</ref>. The method runs a reference simulator for each dynamic object on the application server. Each of the clients interested in the object, including those that access the objects as well as the owner of the object, will execute a gradual synchronization process on the local copy of the object to align its motion to that of the reference simulator running at the server. Our results show that the method effectively reduces the network latency by half and quickly align the motion of the replicated object to that of the original dynamic object. However, the method still suffers from a high error during the period when an interaction has just occurred and before the interaction message has reached the client, causing the users to make inappropriate decisions. It may also leads to the false positive and false negative collision problems as discussed later.</p><p>In this paper, we present a trajectory-preserving synchronization method, which significantly extends our previous work <ref type="bibr" target="#b13">[14]</ref> to support collaborative visualization. It considers how spatial changes and interactions of dynamic objects are affected by network latency. A set of procedures have been developed to correct the motion trajectory of the dynamic objects. In addition, solutions have also been provided to handle the false positive and false negative collision detection problems. To demonstrate the effectiveness of our method, we have conducted experiments on a prototype system for flow visualization <ref type="bibr" target="#b24">[25]</ref>. With this prototype, users may manipulate dynamic objects with the CyberGloves, which are electronic gloves for sensing hand and finger motions, to intervene the flow of a dataset for visualization. The dynamic and interactive nature of this prototype provides an efficacious testbed for verifying the effectiveness of the new method.</p><p>The rest of the paper is organized as follows. Section 2 briefly summarizes related work. Section 3 outlines the foundation of our method. Section 4 presents in detail our trajectory-preserving synchronization method. Section 5 shows how the new method handles object collisions. Section 6 studies the performance of the proposed method with a number of experiments. Finally, Section 7 briefly concludes the work presented in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Collaborative Applications</head><p>A unique characteristic of collaborative applications is the need to distribute state updates to remote sites over the network to update the states of the shared objects at these sites. Because of network latency, different remote sites may receive the updates after different amounts of delay, causing the view discrepancy problem at these sites. Nevertheless, traditional applications such as <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b11">[12]</ref>  because these applications typically have a large time gap between any two consecutive updates as compared with the network latency. As such, the network latency becomes insignificant and the users can implicitly perceive synchronized application content at all times. However, collaborative applications that involve time-dependent data and continuous user interaction may be different from the above applications. The state update events in these applications are continuous <ref type="bibr" target="#b17">[18]</ref> in nature. In order for users to interact with the system based on the same updated view of the data, the updates need to be presented to the remote users either without any delay or at least within a very short period of time. However, this is not trivial to achieve. An early attempt to explore the discrepant views among remote users on shared data due to network latency was done in DEVA3 <ref type="bibr" target="#b21">[22]</ref>, which claimed that inconsistency may be tolerated if latency is small enough. Some works have been conducted to study how the delay in delivering state updates will affect the interactivity of collaborative applications <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b20">21]</ref>. To cope with the latency problem, adaptations could be performed at either the user or the system side. For user side adaptation, <ref type="bibr" target="#b23">[24]</ref> proposes to explicitly disclose delay information to the users and let the users adjust their behavior by themselves to cope with the state discrepancy problem. Unfortunately, this arrangement is subjective to different users and would heavily slow down the user interaction.</p><p>For system side adaptation, a popular approach is to use dead reckoning <ref type="bibr" target="#b15">[16]</ref>. With this approach, the controlling client of a dynamic object runs a motion predictor for the object. Other clients accessing the object also run the same motion predictor to drive the motion of the local copies of the object. The controlling client is required to keep track of the error between the actual and predicted motions of the object, and sends the updated motion information to the other clients when the error is higher than a given threshold. Although this approach is very simple, it does not guarantee that the state of a shared object could be synchronized among all the remote clients.</p><p>In <ref type="bibr" target="#b17">[18]</ref>, a local-lag mechanism is proposed to address this problem. When the controlling client issues a state update of the dynamic object, the update will be sent to the remote clients immediately but not to the sender itself until a local-lag period is expired. This is to reduce the discrepancy between the sender and the receivers. However, as different pairs of clients may suffer from different amounts of latency, a single value of local-lag can only be used to synchronize two clients, the sender and the receiver, but not among a number of clients. In <ref type="bibr" target="#b2">[3]</ref>, users make use of the reference state information from the server to correct the states of their local copies of the dynamic objects. Again, there is no control mechanism to guarantee that the states generated at a client would be synchronized with those at other clients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Clock Synchronization</head><p>The synchronization problem has also been studied by researchers working on clock synchronization. In particular, Network Time Protocol (NTP) <ref type="bibr" target="#b18">[19]</ref> has been adopted as a standard for computers connected via the Internet to synchronize their clocks to within 10ms of error. It relies on selecting and filtering time information from a set of time servers. On the other hand, there are also different strategies proposed in adjusting the local clock when the correct time information is received <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b19">20]</ref>. Backward correction <ref type="bibr" target="#b10">[11]</ref> and forward correction <ref type="bibr" target="#b22">[23]</ref> are two approaches, which make a backward or a forward adjustment on the clock value, respectively. Undesirably, they introduce a time discontinuity problem to the clock. <ref type="bibr" target="#b12">[13]</ref> addresses this problem by speeding up or slowing down a clock to synchronize it against a reference clock. However, it incurs a severe run-time overhead as it needs to adjust the time once at every clock tick. Hence, it generally requires hardware support. To reduce the overhead, <ref type="bibr" target="#b14">[15]</ref> proposes an adaptive method for clock synchronization. It uses a time server to propagate time information to the clients via a re-synchronization process for the clients to determine their clock drift rates. The time between two consecutive re-synchronization processes will be shortened or lengthened based on the drift rate of a client clock. It is set inversely proportion to clock drift rate. At the client, clock correction is performed by extrapolating the clock continuously with the newest clock drift rate determined in the latest re-synchronization process. Although methods used in clock synchronization appear to address the synchronization problem in collaborative visualization, it is difficult to apply them directly to address the problem. First, the time value in clock synchronization is only a parameter with a single degree-of-freedom, while the motion parameters of the datasets for visualization may have three or higher degrees-of-freedom. Second, the clock information is periodic, i.e., the occurrence of a time event is predictable. This simplifies the synchronization problem. In contrast, the motion of the datasets for visualization is likely unpredictable, especially when user interactions or object collisions are possible. Third, in clock synchronization, the time server is the prime reference for all clocks, which only need to synchronize to the changes from the time server. In collaborative visualization, however, any user may initiate its own actions to manipulate a dataset and such actions need to be synchronized among all the users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FOUNDATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Consistency Control Model</head><p>In <ref type="bibr" target="#b13">[14]</ref>, we proposed a relaxed consistency control model to synchronize the object states among remote clients in collaborative applications. We observed that application users would likely pay more attention on the state trajectory of a dynamic object, i.e., the continuous sequence of state changes of the object, rather than on the individual states of the object in order for them to determine their actions to respond. Hence, we proposed to relax the strict timedependent consistency control requirement on individual states of a replicated object among all relevant clients to allow the state trajectories of the replicated object among the relevant sites to deviate from that of the correct one by an acceptable amount. Formally speaking, given that the states of a replicated object at two remote sites at time t are s i (t) and s j (t), the state discrepancy D of the object between the two sites during any time period T a and T b should be smaller than an application specific tolerance, ξ . Therefore,</p><formula xml:id="formula_0">∫ &lt; − = b a T T j i dt t s t s D ξ | ) ( ) ( | (1)</formula><p>This relaxed model could be reverted back to the original strict time-dependent consistency control model if we shorten the time period so that T a = T b and set tolerance ξ = 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Gradual Synchronization</head><p>To implement the consistency control model, we have developed a gradual synchronization method <ref type="bibr" target="#b13">[14]</ref> to trade accuracy of individual states of a dynamic object for the preservation of the state trajectory of the object. We assume that a collaborative application has a clientserver architecture. The server runs a simulator, called a reference simulator, for each dynamic object. This reference simulator serves as a standard reference for synchronizing the motion of all copies of the object at different remote clients. Each client interested in an object will also run a simulator as a local copy of the object. This method effectively reduces the latency of a client to obtain the updated state of an object from a double round-trip time delay to a single one.</p><p>To simulate object motions, we need to apply appropriate motion equations <ref type="bibr" target="#b7">[8]</ref> to drive the motion of the objects. For example, we may apply a first-order predictor (or a more advanced method <ref type="bibr" target="#b4">[5]</ref>) to drive an object when it is under the user's control:</p><formula xml:id="formula_1">V t p p new × + = (2)</formula><p>where p is the current position of the dynamic object, t is the time difference between p and p new , and V is the motion vector of the object. When we need to simulate object interactions and responses, we may apply a second-order predictor instead:</p><formula xml:id="formula_2">2 2 At Vt p p new + + = At V V new + = (3) (4)</formula><p>where A is the acceleration vector of the dynamic object, and t is the time difference between V and V new . For the simulation of flows, such as water, smoke or fire, we may apply appropriate motion equations according to their behaviors <ref type="bibr" target="#b5">[6]</ref>.</p><p>During run-time, two motion timers T s and T c are maintained at the server and the client, respectively. They are the virtual clocks indicating how long a dynamic object has been performing certain movement as perceived by the server and by the client. Hence, they represent t in Eq. <ref type="formula">2</ref>to <ref type="bibr" target="#b3">(4)</ref>. When a dynamic object changes its motion, each interested client will gradually align the motion of its local copy of the object to that of the reference simulator at the server by adjusting the increment rate of T c of the object. The simulator of the object at the client and the reference simulator of the object at the server are said to be synchronized when T c = T s .</p><p>In general, this method successfully maintains the consistency of dynamic objects in collaborative applications, except between the period when an interaction has just occurred and before the update message reaches the remote client. During this period, the two sites can have a very high discrepancy. Although this discrepancy will be settled shortly after the update message is received at the remote client, it still produces a high visual error during this period. This can be serious if the interactions occur frequently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">TRAJECTORY-PRESERVING SYNCHRONIZATION</head><p>The new synchronization method extends our earlier method <ref type="bibr" target="#b13">[14]</ref> by considering how interactions are perceived by the remote users or the server in the existence of network latency. It includes separate mechanisms for handling client-server and client-client synchronizations. To simplify our discussion, Figures 1 to 3 help illustrate our method graphically. We assume that client A initiates a motion change to a dynamic object, which can be a user controlled object or a primitive object of a dataset in flow simulation. A motion command is then generated as a result of the motion change and sent to the server to update the motion of the corresponding reference simulator S. Concurrently, client B is visualizing the change of the object and needs to gather updates of the object from the reference simulator running at the server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Client-Server Synchronization</head><p>As shown in <ref type="figure">Figure 1</ref>, before a new motion occurs at P init , the motions of the dynamic object at client A and of its reference simulator S are synchronized. When the object is driven to move in a new direction V new by a script, by a user interaction or by an object collision, a motion command is generated. However, as it will take time for this motion command to reach the server, S will continue to move in its current direction until P start , when the server receives the motion command. This discrepant motion is represented as the expected motion vector V r , and its motion would last for the time duration of a half round-trip delay.</p><p>To remedy the state discrepancy problem during motion change, we propose to adjust the motion of the dynamic object at A gradually to align with that of S. This motion remediation method helps minimize the state discrepancy raised during a motion change while preserving the motion trajectory as much as possible. It is shown by the blue arrows in <ref type="figure">Figure 2</ref>. First, instead of driving the dynamic object at A solely with V new , we let it move in the direction of the vector sum of V new and V r for the time duration est S A T − , where est S A T − is the estimated latency between client A and the server collected from recent statistics <ref type="bibr" target="#b13">[14]</ref>. Note that est S A T − is used instead of the real latency (half round-trip time) T A-S , since the most updated T A-S is not currently available at the client. After that, we set the motion of the dynamic object to move in the direction of V new . Once the server has received the new motion command from A, it will reply the client by sending it the values of P start and T s . Upon the reception of such information, A will evaluate the residual state discrepancy V dis as the vector difference between P curr of the object at the server and the current position of the object at A, where P curr = P start + (T A-S + T s ) × V new and T A-S is the most updated latency. With the value of V dis , we may further remedy the motion of the dynamic object at A to move in the direction of the vector sum of V new and V dis . Hence, such motion could eventually be synchronized with that of S at P sync . Finally, we again resume the motion of the object at A to move in the direction of V new .  <ref type="figure" target="#fig_2">Figure 3</ref> shows our motion remediation process to address the state discrepancy problem in client-client communications. Using the same scenario and notation as in the client-server synchronization example, we consider the situation that client B is interested in the motion of the dynamic object driven by client A. Hence, the server needs to propagate the motion information of the object to B. Before the object is driven to move in a new direction, the motions of S at the server and the local copy of the object at B are synchronized at P start . Assuming that S is driven to move in a new direction V new when an interaction occurs, V new will then be propagated to B. Again, it will take time for this motion command to arrive at B. Thus, the local copy of the object at B is expected to continuous moving in its current direction until client B receives V new . Then, B will estimate the state discrepancy V dis as the vector difference between P curr of the object at the server and the current position of it at B, where T − is the estimated latency between client B and the server collected from recent statistics. With V dis , we may amend the motion of the object in B to move in the direction of the vector sum of V new and V dis such that it could eventually be closely synchronized with that of S at P sync . At this point, we resume the motion of the local copy of the object to move in the direction of V new . This adjusted client motion is shown as brown arrows in <ref type="figure" target="#fig_2">Figure 3</ref>. Hereafter, when client B receives the most updated latency T S-B , it will adjust the increment rate of T c using T S-B , which is the gradual synchronization process for client B to remedy any residual state discrepancy <ref type="bibr" target="#b13">[14]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Client-Client Synchronization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Synchronization at an Arbitrary Moment</head><p>One important advantage of the new method is that a prior synchronized state between a dynamic object and its reference simulator is not required before a new synchronization cycle could be taken place. Hence, our method can synchronize new motion commands generated at any arbitrary moment, including during motion remediation. We explain this with the example shown in <ref type="figure" target="#fig_3">Figure 4</ref>. While client A is executing a motion remediation process, it sends out another motion command to indicate that the motion of the dynamic object has been changed to V new . Although the previous object motion command at A has still not been synchronized with the reference simulator at the server, we may start a new client-server synchronization process for the new motion command by applying the new motion on the object immediately. Instead of moving in V new , the dynamic object at A moves in the direction of the vector sum of V new and V r for the time duration of est S A T − , followed by the direction of V new until the client has received P start and T s from the server. Upon receiving such information, the client evaluates the residual state discrepancy V dis as the vector difference between P curr of the object at the server and the current position of the object at A, in the same way as described in Section 4.1. With V dis , we may further amend the motion of the object at A to move in the direction of the vector sum of V new and V dis such that this motion and that of S could eventually be synchronized at P sync . Finally, we resume the motion of the object at A to move in the direction of V new . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">HANDLING OF OBJECT COLLISIONS</head><p>Another critical issue in collaborative visualization is to assert a consistent view among remote users in object collisions. This issue typically does not exist in a standalone visualization application, since updated states of dynamic objects are maintained and presented within a single client, where delay can be neglected. However, because of network latency and since each user may suffer from a different amount of network latency, object collision information may be presented to different users at different time moments. This may lead to inconsistent object collision results. This problem is still an open research topic. To our knowledge, <ref type="bibr" target="#b19">[20]</ref> is the only work that attempts to address this problem. It uses dead reckoning to guide the motions of dynamic objects and addresses the inconsistency problem as follows. First, when a client needs to detect possible collisions between two remote objects or between one remote object and one static object, it uses the local state information of these objects to compute a temporary collision result for visual presentation. The collision result may then be overridden by an updated one from the remote client when it is available. This may, however, introduce temporary inconsistency on the collision results among remote users. Second, when a client predicts that a collision will likely occur between its own controlled object and a remote object, the system would instruct the remote client to propagate the state of the remote object more frequently to this client. This helps decrease the error in evaluating the collision detection result at the client. This unfortunately would increase the network loading. In addition, the false positive and false negative collision results, which will be discussed next, are not considered in this method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The Collision Problem</head><p>In our method, when an object collision occurs, we evaluate and interpret the collision response as motion commands according to the reactions of the colliding objects. The motion commands would then be fed as input to the motion predictors of the objects to update the object motions. In this way, our synchronization method could natively support the global-wise consistency of object collisions among the participants, i.e., the participating clients and the server. However, because of network latency, the new motion commands will still be received and interpreted by each participant at a different time moment. This may lead to a false positive or a false negative collision detection result, which corresponds to an invalid or a missing collision instance of an object, respectively. We have identified all possible false positive and false negative collision detection results as shown in <ref type="table">Table 1</ref>. We assume that the roles of the clients and of the server are the same as those mentioned in Section 4. From <ref type="table">Table 1</ref>, there are mainly two reasons leading to the collision problem. First, when an object in client A changes its motion during motion remediation, i.e., same situation as Section 4.3, the motion of this object at client A and that of the reference simulator at the server will be different temporarily. Second, as it takes time for the motion commands to be delivered to client B, the motion of the object in B will also be different from that of the reference simulator at the server. In both cases, inconsistent collision results may be produced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The Algorithm</head><p>To address the collision problem, we follow our reference simulator scheme, where the motion of a dynamic object maintained at a client only needs to be synchronized with that of the reference simulator at the server. Thus, if we could resolve the collision problem between each client (either client A or client B) with the server, we would then have handled the problem globally among all participants. Based on this observation, we convert the collision problem shown in <ref type="table">Table 1</ref> into two simpler problems, involving only two parties: client A -server <ref type="table">(Table 2</ref>) and client B -server <ref type="table" target="#tab_2">(Table 3)</ref>. To address the collision problem, we may just handle individual cases shown in <ref type="table" target="#tab_2">Tables 2 and 3</ref> as follows:</p><p>• Cases (a), (d), (e) and (h): As the collision problem does not exist, no actions are required.</p><p>• Cases (c) and (g): A false positive collision occurs at the server. When a dynamic object changes its motion, the server will send an update message to client B to update the state of the object at B. To trade transient discrepancy of client A for global consistency, the collision event detected at the server will be sent to both clients A and B to override the object motion there so that they will both have the same object state.</p><p>• Case (b): A false negative collision result occurs at the server.</p><p>Since the server does not detect a collision, it will not send out a collision event, causing an inconsistency with client A. This problem only occurs when client A issues a new motion command during motion remediation, which leads to a collision.</p><p>To trade transient discrepancy of client A for global consistency, we inhabit client A to perform collision detection until the motion remediation process has finished, which typically takes a round-trip time.</p><p>• Case (f): A false positive collision result occurs at client B. This happens only while the server is sending a motion command to client B but the original motion of the object at B has already led to a collision. This problem could not be avoided but could be quickly corrected by the new motion command from the server, and the inconsistent state could only last for a half round-trip time. As in case (b), to maintain global consistency, we inhabit client B to perform collision detection until the motion remediation process has finished. This situation would last for another half round-trip time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS AND DISCUSSIONS</head><p>To study the performance of our method, we have developed a prototype to support flow visualization and dynamic user interaction. We have tested it on a set of PCs with a P4 2.0GHz CPU, 1GBytes RAM and a GeForce4 Ti4200 graphics card. Each client machine has a CyberGlove with a 3D tracker connected to it to capture the user's hand gesture and position. The CyberGlove allows a user to manipulate the objects in an intuitive way inside the prototype environment, where each unit of spatial distance is defined as 1m. The user may apply force to an object and use the object to intervene a flow simulation. In addition, we have connected the machines through TCP connections, which handle the packet lost problem automatically, and use timestamps to ensure message ordering. <ref type="figure" target="#fig_5">Figure 5</ref> shows a series of screenshots from one of our experiments on flow visualization.</p><p>Before the experiments, we first collected the latency statistics of different network connections as show in <ref type="table" target="#tab_1">Table 4</ref>. (Connection Overseas 1 measures the latency between Hong Kong and US, while Overseas 2 is created to model a long latency connection.) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experiment 1</head><p>This experiment compares the performance of the new method with our original synchronization method <ref type="bibr" target="#b13">[14]</ref> and dead reckoning <ref type="bibr" target="#b15">[16]</ref> in terms of accuracy. It measures the object position discrepancy experienced by relevant machines when two users are connected via an overseas link with a network latency of roughly 160ms as shown in <ref type="figure" target="#fig_4">Figure 6</ref>. In the experiment, we use first-order and second-order polynomials to model the motion of the object when it is being grasped to move and thrown out by a user, respectively. To simplify the discrepancy measurement without loss of generality, we observe in this experiment the motion of a selected object, which is spherical in shape. The users have a full control on the motion of this object and use the object to intervene a flow simulation. However, to simplify this experiment, we have confined the motion of all the tiny particles of the flow so that they do not affect the motion of the selected object. During the experiment, a user (client A) is asked to pick up the selected object and move it around arbitrarily with a velocity of 1 m/s. After around 4 seconds, the user throws the object out with a velocity of 3m/s under 9.8m 2 /s gravity, it hits the floor and bounces up and down several times. The elastic coefficient of the object is 0.7. Such interaction is observed by a remote user (client B). We have measured the position discrepancy of the object between client A -server ( <ref type="figure" target="#fig_4">Figure 6(a)</ref>), server -client B <ref type="figure" target="#fig_4">(Figure 6(b)</ref>), and client A -client B <ref type="figure" target="#fig_4">(Figure 6(c)</ref>) during a fixed period of time. The position discrepancies exhibited by our original method, and the new method, and dead reckoning are shown in each of the three diagrams.</p><p>We assume that the positions of the object in the three machines are synchronized at 1s. As the user sudden changes the motion of the object, we can see that there is an increase in discrepancy in all three diagrams of <ref type="figure" target="#fig_4">Figure 6</ref>. In <ref type="figure" target="#fig_4">Figure 6</ref>(a), as dead reckoning does not perform any correction until when the server receives the update <ref type="table">Table 2</ref>. Client A and server collision problems message from client A, the discrepancy rises much more rapidly. In addition, it also lasts for longer as dead reckoning does not send out an update message to the server until the error between the actual and the predicted motions is high enough. With our previous method, when the object at client A changes motion, A would send out an update message to the server immediately and move the object at a reduced speed to minimize its discrepancy with the server. Hence, its discrepancy rises much slower than dead reckoning. The method that we propose here is even more aggressive. It modifies the motion of the object at client A to anticipate for the latency existed between A and the server. Hence, its discrepancy is further reduced. When the server has received and applied the update to the object, the object discrepancy using dead reckoning drops immediately. This happens at around 1.2s. For our original and the new methods, we receive the update message at around 1.16s, after 160ms of latency. The reason for our methods to receive the update message slightly earlier than dead reckoning is that we do not need a thresholding process. Our original method would also have a sudden drop as we update the object position at the server to the actual position where the object started to change motion at client A. However, the discrepancy would not drop to zero as the object in client A has already moved some distance. This discrepancy will be further reduced as the object in client A continues to move in a reduced speed than that of the server until they are synchronized. With the new method, the discrepancy gradually reduces to zero (approximately) as we continue to correct the object motion at client A until it is synchronized with that in the server.</p><formula xml:id="formula_3">Case Client A Server (a) × × (b) O × (c) × O (d) O O</formula><p>In <ref type="figure" target="#fig_4">Figure 6</ref>(b), the discrepancy of dead reckoning suddenly increases as the server suddenly correct the object location when it receives the update message from client A. This discrepancy continues to increase as the object in client B continues to move in its current direction until B receives the update message from the server. Then, the discrepancy suddenly drops to zero as B applies the update to the object. With our original method, the rise in discrepancy is similar to dead reckoning except that here it happens earlier at about 1.16s instead of 1.2s and drops earlier at about 1.32s. However, the discrepancy would not drop to zero as we move the object at client B to the location where the object started to change motion at the server. This discrepancy will be further reduced as the object in client B speeds up until it catches up with the object at the server. With the new method, the discrepancy gradually reduces to zero as we continue to correct the object motion at client B.</p><p>At about 4s, client A throws the object out, which hits the floor and bounces up and down several times. This leads to a series of object collisions. We discuss the performance of our method when we apply it to collision detection in the next experiment. In general, we may observe from <ref type="figure" target="#fig_4">Figure 6</ref> that although the dead reckoning method is very simple, it produces high discrepancy during motion changes. Our original method is successful in reducing the discrepancy. However, through motion adjustment as well as using the server as a reference, the new method not only further reduces the discrepancy but also shorten the duration of discrepancy, as observed in <ref type="figure" target="#fig_4">Figure 6</ref>(c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Experiment 2</head><p>In this experiment, we follow similar settings as in Experiment 1 but focus more on the accuracy of the new method in handling object collisions under different types of network connection as shown in <ref type="table" target="#tab_1">Table 4</ref>. The experiment is conducted by 4 users, clients A to D.</p><p>Each of the users is connected to the server with a different network connection and takes turn to act as the controller, who throws the selected object out to initiate collisions, and the other three users would be the observers, who monitor the motion of the selected object. When throwing the object, the controller simply throws the object up to the sky and let it fall down on to the floor. Then, the object will bounce up and down a few times before it rests on the floor. During the experiment, we record the position discrepancy of the object between each of the users and the server. The results are shown in <ref type="figure" target="#fig_6">Figure 7</ref>, with each user taking turn to be the controller. Since the controller throws out the selected object at around 0.3s, we can see from the four diagrams of <ref type="figure" target="#fig_6">Figure 7</ref> that the position discrepancy between the controller and the server suddenly increases at 0.3s in all four diagrams. In <ref type="figure" target="#fig_6">Figure 7</ref>(a), as client A (the controller) has a rather low network latency with the server, it can quickly synchronize with the server and the discrepancy begins to drop until around 0.6s when the object reaches its highest point in the sky. Other observers will gradually synchronize with the server depending on their network latencies with the server. Once the server has received the message that the object has been thrown out from the controller's hand, the simulation program running in the server will take over the motion of the object. At 0.6s, the simulation program determines that the object should begin to fall down and accelerates as it falls due to gravity. Due to the error in the measured network latency as well as the fluctuation (or jittering) of the latency, which is further magnified by the acceleration of the object, the discrepancies between the four clients and the server gradually increase again until about 1.2s when the object hits the floor and rebounds. <ref type="figure" target="#fig_6">Figures 7(b)</ref>, 7(c) and 7(d) exhibit similar behavior, except that their observers' discrepancies with the server start at a later time after the controller has thrown the object out. This is due to the increase in network latency between the controller and the server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION AND FUTURE WORK</head><p>In this paper, we have proposed a synchronization method to support collaborative visualization. It considers how interaction with dynamic objects is perceived by application participants under the existence of network latency, and remedies the motion trajectory of the dynamic objects. It also handles the false positive and false negative collision detection problems. The new method is particularly well designed for handling content changes due to unpredictable user interventions or object collisions. Experimental results show that our method could effectively provide a good consistency control to support collaborative visualization. Despite the merits of our proposed method, it does have some limitations. For example, it assumes using connection-oriented network protocols and message loss is not considered. We would like to address this as our future work. In addition, as haptic interfaces are becoming popular and it may widen the application of collaborative visualization by providing user with force feedback, we would also like to extend our work to handle haptic rendering as well.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>The state discrepancy problem during motion change. Motion remediation in client-server synchronization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Motion remediation in client-client synchronization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Motion remediation at an arbitrary moment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Position discrepancies of the three methods, observed between: (a) client A and the server, (b) the server and client B, and (c) client A and client B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Screen shots of our prototype for collaborative visualization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Position discrepancies, during object collisions, of the four clients relative to the server when (a) client A, (b) client B, (c) client C, or (d) client D, is acting as the controller.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 4 .</head><label>4</label><figDesc>Latency information for different network connections</figDesc><table><row><cell>Category</cell><cell cols="2">Latency (ms)</cell><cell></cell></row><row><cell></cell><cell>Mean</cell><cell>Max.</cell><cell>Min</cell></row><row><cell>LAN (within a department)</cell><cell>5</cell><cell>7</cell><cell>0</cell></row><row><cell>Intranet (within a university)</cell><cell>40</cell><cell>57</cell><cell>32</cell></row><row><cell>Overseas 1 (modeling two nearby countries)</cell><cell>160</cell><cell>186</cell><cell>132</cell></row><row><cell>Overseas 2 (modeling two distant countries)</cell><cell>325</cell><cell>537</cell><cell>294</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Server and Client B collision problems Before the new motion command arrives at client B, the motion of the object at B leads to a collision. False positive collision occurs. issues a new motion command during motion remediation, which does not lead to a collision. However, such command causes a false positive collision when it reaches the server.</figDesc><table><row><cell></cell><cell cols="4">Table 1. Possible false positive and false negative collision problems (× indicates no collision and O indicates a collision)</cell></row><row><cell>Client A</cell><cell>Server</cell><cell>Client B</cell><cell cols="2">Collision Problem and Its Causes</cell></row><row><cell>×</cell><cell>×</cell><cell>×</cell><cell cols="2">No collisions occur. The collision problem does not exist.</cell></row><row><cell>×</cell><cell>×</cell><cell>O</cell><cell></cell></row><row><cell cols="5">× Client A × O × O Client A issues a new motion command during motion remediation, which does not lead to a collision, while O client B inherits the same state from the server. False positive collision occurs.</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Client A issues a new motion command during motion remediation, which leads to a collision. However, this</cell></row><row><cell>O</cell><cell>×</cell><cell>×</cell><cell cols="2">command does not cause a collision when it reaches the server, while client B inherits the same state from the</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">server. False negative collision occurs.</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Client A issues a new motion command during motion remediation, which leads to a collision. However, the</cell></row><row><cell>O</cell><cell>×</cell><cell>O</cell><cell cols="2">new command does not cause a collision when it reaches the server. False negative collision occurs. On the other hand, before the new command arrives at client B, the motion of the object at B leads to a</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">collision, which does not correspond to the one at client A. False positive collision occurs.</cell></row><row><cell>O</cell><cell>O</cell><cell>×</cell><cell cols="2">Client B does not receive the state update in time. False negative collision occurs.</cell></row><row><cell>O</cell><cell>O</cell><cell>O</cell><cell cols="2">Collision is detected correctly at all parties. No collision problems arise.</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Case</cell><cell>Server</cell><cell>Client B</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(e)</cell><cell>×</cell><cell>×</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(f)</cell><cell>×</cell><cell>O</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(g)</cell><cell>O</cell><cell>×</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(h)</cell><cell>O</cell><cell>O</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank the reviewers for their valuable comments and suggestions. The work described in this paper was partially supported by two CERG grants from the Research Grants Council of Hong Kong (Ref. Nos.: PolyU 5188/04E and CityU 1133/04E).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Distributed and Collaborative Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Anupam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Baja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="37" to="43" />
			<date type="published" when="1994-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Concurrency Control in Distributed Database Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="185" to="221" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bernier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Game Developers Conference</title>
		<meeting>of the Game Developers Conference</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Transforming a Surgical Robot for Human Telesurgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Butner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ghodoussi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Robotics and Automation</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="818" to="824" />
			<date type="published" when="2003-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Notion Prediction for Caching and Prefetching in Mouse-Driven DVE Navigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Internet Technology</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="91" />
			<date type="published" when="2005-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Elements of Nature: Interactive and Realistic Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Deusen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 2004 Course Note #31</title>
		<imprint>
			<date type="published" when="2004-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Distributed Architecture for Multiplayer Interactive Applications on the Internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Diot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Gautier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Networks Magazine</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="6" to="15" />
			<date type="published" when="1999-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">IEEE Standard for Distributed Interactive Simulation -Application Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dis Steering Committee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Standard</title>
		<imprint>
			<biblScope unit="volume">1278</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">CAVEvis: Distributed Real-Time Visualization of Time-Varying Scalar and Vector Fields Using the Cave Virtual Reality Theater</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="301" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Introduction to Collaborative Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Elvins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGGRAPH</title>
		<meeting>of ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="1998-05" />
			<biblScope unit="page" from="8" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Clock Synchronization in Distributed Real-Time Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kopetz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ochsenreiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="933" to="940" />
			<date type="published" when="1987-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Time, Clocks, and the Ordering of Events in a Distributed System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Synchronizing Clocks in the Presence of Faults</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Melliar-Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="52" to="78" />
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Supporting Continuous Consistency in Multiplayer Online Games</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Multimedia</title>
		<meeting>of ACM Multimedia</meeting>
		<imprint>
			<date type="published" when="2004-10" />
			<biblScope unit="page" from="388" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Experience with an Adaptive Globally-Synchronizing Clock Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SPAA</title>
		<meeting>of ACM SPAA</meeting>
		<imprint>
			<date type="published" when="1999-06" />
			<biblScope unit="page" from="106" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">NPSNET: A Network Software Architecture For Large Scale Virtual Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Macedonia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zyda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zeswitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Presence: Teleoperators and Virtual Environments</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="265" to="287" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Do Four Eyes See Better Than Two? Collaborative Versus Individual Discovery in Data Visualization Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kobsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Information Visualization</title>
		<meeting>of IEEE Information Visualization</meeting>
		<imprint>
			<date type="published" when="2002-07" />
			<biblScope unit="page" from="249" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Local-lag and Timewarp: Providing Consistency for Replicated Continuous Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mauve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vogel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Hilt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Effelsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Multimedia</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="57" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Internet Time Synchronization: the Network Time Protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Communications</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1482" to="1493" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Improving Collision Detection in Distributed Virtual Environments by Adaptive Collision Prediction Tracking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ohlenburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE VR</title>
		<meeting>of IEEE VR</meeting>
		<imprint>
			<date type="published" when="2004-03" />
			<biblScope unit="page" from="83" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Collaborative Visualization with Cspray</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wittenbrink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="32" to="41" />
			<date type="published" when="1997-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">DEVA3: Architecture for a Large-Scale Distributed Virtual Reality System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pettifer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>West</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM VRST</title>
		<meeting>of ACM VRST</meeting>
		<imprint>
			<date type="published" when="2000-10" />
			<biblScope unit="page" from="33" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimal Clock Synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Srikanth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Toueg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="626" to="645" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Coping with Inconsistency due to Network Delays in Collaborative Virtual Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Vaghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Greenhalgh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Benford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM VRST</title>
		<meeting>of ACM VRST</meeting>
		<imprint>
			<date type="published" when="1999-12" />
			<biblScope unit="page" from="42" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Flow Visualization with Surface Particles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="24" />
			<date type="published" when="1993-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Collaborative Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Brodlie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="253" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cooperative Visualization of Computational Fluid Dynamics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gerald-Yamasaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Eurographics</title>
		<meeting>of Eurographics</meeting>
		<imprint>
			<date type="published" when="1993-09" />
			<biblScope unit="page" from="497" to="508" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
