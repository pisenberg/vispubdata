<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Progressive Volume Rendering of Large Unstructured Grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
							<email>stevec@sci.utah.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Louis</forename><surname>Bavoil</surname></persName>
							<email>bavoil@sci.utah.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
							<email>pascucci@acm.org</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Cláudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
							<email>csilva@sci.utah.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Progressive Volume Rendering of Large Unstructured Grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Volume Rendering</term>
					<term>Large Unstructured Grids</term>
					<term>Client-Server</term>
					<term>Progressive Rendering</term>
					<term>Level-of-Detail</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We describe a new progressive technique that allows real-time rendering of extremely large tetrahedral meshes. Our approach uses a client-server architecture to incrementally stream portions of the mesh from a server to a client which refines the quality of the approximate rendering until it converges to a full quality rendering. The results of previous steps are re-used in each subsequent refinement, thus leading to an efficient rendering. Our novel approach keeps very little geometry on the client and works by refining a set of rendered images at each step. Our interactive representation of the dataset is efficient, lightweight , and high quality. We present a framework for the exploration of large datasets stored on a remote server with a thin client that is capable of rendering and managing full quality volume visualizations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Unstructured grids (e.g., tetrahedral meshes) are common in simulation domains such as computational fluid dynamics and structural mechanics. Because of the constantly improving algorithms and computational power, the scale of these simulations has continued to grow at a rate faster than visualization techniques can explore them. Specialized graphics clusters have been developed to visualize large datasets in parallel and on large displays. However, the availability of these clusters is often limited. More recently, many techniques have been developed to visualize volumetric data on commodity PCs using graphics hardware <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23]</ref>. This provides a solution that allows researchers to perform their visualizations locally when other resources are unavailable. However, due to the limitations of storage and memory with most desktop machines or laptops, this solution does not scale well for extremely large datasets.</p><p>As an example, consider a scientist working remotely who would like to visualize a large dataset on his laptop computer. A reduced representation of the data (e.g., simplification <ref type="bibr" target="#b11">[12]</ref>) may not be appropriate if a high quality visualization is required for analysis. Complicating matters even further, the laptop may not have capacity on the hard disk or in memory to keep the dataset. The problem is compounded if you consider that the scientist may only want to browse through a series of datasets quickly, requiring the download of each dataset before visualization.</p><p>In this paper, we present a client-server architecture for hardwareassisted, progressive volume rendering. The main idea is to create an effect similar to progressive image transmission over the internet. A server acts as a data repository and a client (i.e., a laptop with programmable graphics hardware) acts as a renderer that accumulates the incoming geometry and displays it in a progressively improving manner (see <ref type="figure" target="#fig_0">Figure 1</ref>). Our progressive strategy is unique because it only requires the storage of a few images on the client for the incremental refinement. For interactivity, a small portion of the mesh is stored on the client using a bounded amount of memory. Furthermore, the progressive representation provides a natural means for level-of-detail exploration of very large datasets without an explicit simplification step that may be difficult and costly. Because the geometry is rendered in steps, the user can stop a progression and change the view without penalty, thus facilitating exploration. Our algorithm is robust, memory efficient, and provides the ability to create and manage approximate and full quality volume renderings of unstructured grids too large to render interactively at full resolution.</p><p>Our contributions include:</p><p>• We introduce a client-server architecture and interface for rendering large datasets and managing the resulting visualizations;</p><p>• We detail a server that acts as a data repository by streaming a tetrahedral mesh in partial visibility order to one or more clients;</p><p>• We describe a client that uses hardware-assisted, progressive volume rendering to provide an interactive approximation, progressive refinement, and full-quality rendering of large datasets;</p><p>• We provide experimental results of our algorithm and include a discussion on the benefits and limitations of our approach.</p><p>The rest of the paper is outlined as follows. Section 2 provides an overview of related research. Section 3 describes an overview of our client-server architecture. More detail is provided about the server in Section 4 and about the client in Section 5. In Section 6, we outline our experimental results, in Section 7 we include a discussion of the tradeoffs of our algorithm, and in Section 8, we provide brief discussion of our algorithm and our conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PREVIOUS WORK</head><p>Hardware-Assisted Volume Rendering. Volume rendering on a commodity PC has been the subject of much research recently, due to the steady increase in processing power on graphics processing units (GPUs) and the advent of programmable shaders. Here we summarize the state-of-the-art for hardware-assisted volume rendering of unstructured grids; for more detail we refer the reader to a recent survey <ref type="bibr" target="#b21">[22]</ref>. For unstructured grids, volume rendering algorithms generally fall into two categories: ray-casting and splatting. Recently, Weiler et al. <ref type="bibr" target="#b22">[23]</ref> proposed an algorithm to perform ray-casting completely on the GPU by storing the mesh and traversal structure in GPU memory. This algorithm was made more efficient and extended to handle non-convex meshes in subsequent work by Weiler et al. <ref type="bibr" target="#b23">[24]</ref> and Bernardon et al. <ref type="bibr" target="#b1">[2]</ref>. These algorithms benefit from low latency because they avoid CPU to GPU data transfers. However, the limited memory of GPUs prevents these algorithms from rendering even moderately sized datasets. Pioneering work on tetrahedral splatting by Shirley and Tuchman <ref type="bibr" target="#b20">[21]</ref> introduced the Projected Tetrahedra (PT) algorithm. For each viewpoint, PT decomposes a tetrahedron into one to four triangles that can be rendered efficiently in hardware. Unfortunately, compositing of the triangles requires an explicit visibility ordering that is implicit to ray-casting. Many algorithms have been proposed to perform the visibility ordering in object-space (e.g., <ref type="bibr" target="#b25">[26]</ref>). More recent work by Callahan et al. <ref type="bibr" target="#b5">[6]</ref> introduced the Hardware-Assisted Visibility Sorting (HAVS) algorithm which sorts in objectspace and image-space. The HAVS algorithm is fast, efficient, and flexible enough to handle dynamically changing geometry <ref type="bibr" target="#b0">[1]</ref>. In this paper, we exploit these benefits to provide a client renderer that handles streaming geometry in a progressive form. A more detailed overview of the algorithm is provided in Section 5.</p><p>Level-of-Detail. Hardware-accelerated volume rendering algorithms allow the interactive rendering of moderately sized datasets. However, multiresolution or level-of-detail (LOD) techniques <ref type="bibr" target="#b16">[17]</ref> are still essential to render large datasets interactively. Unlike structured grids, the area is relatively new and not well studied for unstructured grids. For this reason, initial algorithms applied techniques for structured grids on unstructured grids by sampling them uniformly <ref type="bibr" target="#b14">[15]</ref>. A drawback with this type of approach is that the resulting resampled meshes are larger than the original by at least an order of magnitude. A more efficient algorithm proposed by Museth et al. <ref type="bibr" target="#b18">[19]</ref> uses a hierarchy of splats to render culled, opaque geometry that can be explored with the use of CSG cuts. For direct volume rendering, Cignoni et al. <ref type="bibr" target="#b7">[8]</ref> present a hierarchy of simplification steps that can be traversed to a desired LOD for interactive visualization. In general, these algorithms are not suitable for streaming in a client-server architecture due to a combination of increased data size, inability to display a full-quality volume rendering, or the difficulty of traversing the levels-of-detail dynamically. More recently, Callahan et al. <ref type="bibr" target="#b4">[5]</ref> introduced sample-based simplification for dynamic LOD on unstructured grids. The algorithm samples the geometry by importance and determines the number of elements to render at each pass based on the frame-rate of the previous pass. Our algorithm uses a similar idea to create an approximate volume rendering from the portion of the geometry that has arrived from the server.</p><p>Client-Server Visualization. The problem of remotely visualizing large datasets has been the subject of research for many years. The most widely recognized solutions perform the visualization task on large clusters using software algorithms <ref type="bibr" target="#b19">[20]</ref> or with hardware-assisted algorithms <ref type="bibr" target="#b17">[18]</ref> through the use of specialized graphics hardware <ref type="bibr" target="#b12">[13]</ref>. Typically, an image is created using the cluster, then compressed for transmission to the client, where it is decompressed and displayed to the user <ref type="bibr" target="#b9">[10]</ref>. Systems such as Vizserver <ref type="bibr">1 1</ref> are available from vendors for performing client-server visualization in this manner. The Visapult system <ref type="bibr" target="#b2">[3]</ref> was developed to push more of the burden onto the client. This is done by rendering blocks of the data from the server in a distributed system and compositing the results on the client. A less restrictive class of algorithms performs the visualization on more limited resources by assuming a simple server (e.g., a web server). To this end, Lippert et al. <ref type="bibr" target="#b15">[16]</ref> introduced a system in which the server stores compressed wavelet splats that are transmitted to the client for rendering. As the splats are received by the client, the image is progressively refined. Another approach by Engel et al. <ref type="bibr" target="#b8">[9]</ref> describes a progressive isosurface visualization algorithm for use on the web. This is done by allowing the server to compute a hierarchy of isosurfaces that are transmitted to the client progressively. For efficiency, only the difference between two successive levels of the hierarchy is sent across the network. More recently, the client-server architecture provided by Kaehler et al. <ref type="bibr" target="#b13">[14]</ref> performs visualization of Adaptive Mesh Refinement (AMR) data that is stored remotely on a server and adaptively rendered locally on a client by interpolating the hierarchical structure of the grids. Our algorithm is similar to this latter class of algorithms, but for the more difficult case of unstructured grids. We assume a limited server that prepares the geometry and streams it to the client in a series of progressive steps that avoid redundant transmission and unnecessary storage. This allows the client to receive the non-overlapping geometry and refine the image with assistance of the GPU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SYSTEM OVERVIEW</head><p>Our client-server system architecture is depicted in <ref type="figure" target="#fig_1">Figure 2</ref>. The server acts as a data repository and geometry processor. The data is stored on the server hierarchically for efficient traversal and iterative object-space sorting. The client keeps the boundary triangles for an Interactive Mode and requests geometry from the server in a Progressive Mode. In the Progressive Mode, the client uses hardware-assisted LOD volume rendering to refine the image using the results of the previous progressive step. Upon completion of the progressive volume rendering, the client saves a copy of the image for later browsing in a Completed Mode. Viewing changes in any of the client steps causes the progressive renderer to stop and return to the Interactive Mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">THE SERVER 4.1 Geometry Processing</head><p>Overview. The server acts as a data repository that sorts and streams triangles. However, sorting large datasets in one pass may be cumbersome. For the client to remain interactive, it should begin receiving nearly-sorted faces immediately from the server. Furthermore, the client should be able to interrupt the streaming of the faces at any time to keep the exploration interactive.</p><p>To keep the processing of the datasets to a minimum, we perform a one-time preprocessing of the datasets to extract the unique triangle faces and vertices and store them in a binary format that we read when starting the server. Then, we use the server to process the faces of the mesh into an octree structure that can be traversed by depth ranges, from front to back. For every packet of faces requested from the client, the server first culls faces outside the current depth range, sorts the remaining faces, and sends them to the client. Subsequent packets use incremented depth ranges. This has the effect of distributing the sorting burden between each step of the progression. It also prevents unused geometry from being sorted. Depth-range culling. For a given depth range, we cull the associated geometry using a depth-range octree. Our octree is a geometric partition of the faces, according to their centroids. Our depth-range octree is similar to the octree from <ref type="bibr" target="#b24">[25]</ref> for isosurface extraction. However, instead of using scalar values, our octree uses dynamically changing depth ranges to cull the geometry outside the current depth range. Each octree node contains an array of face indices. The depth range of a node is the minimum and maximum distance from the eye to the bounding box corners of the node. To find the faces matching a given depth range, the octree nodes are culled hierarchically by traversing nodes that may contain triangles in the given depth range. Next, the collection of triangles in the matching octree nodes are culled according to their distance from the viewpoint. The remaining triangles are then inserted into an array for sorting. We use a radix sort on the face centroids, as in <ref type="bibr" target="#b5">[6]</ref>. The triangles are then sent as a vertex array for direct rendering on the client.</p><p>To increment the depth range on each pass, we uniformly divide the range of the minimum and maximum distance from the eye to the bounding box of the mesh. This has the unfortunate side effect that the number of triangles per slice can vary in size. We address this issue by collecting packets on the server and only transmitting them to the client when a user-specified target triangle count is reached. This results in good performance since the sorting and network transfers are more efficient for larger packets.</p><p>View-frustum culling. When interactively exploring regions of the mesh in detail, often many of the faces are outside of the viewfrustum. These faces should not be transmitted to the client. Therefore, in addition to the depth range test, we also perform view-frustum culling for each node of the octree. The left, right, bottom and top planes of the frustum are computed from the modelview-projection matrix sent by the client. This results in significant performance improvements for zoomed-in views of the dataset (see <ref type="figure" target="#fig_4">Figure 5</ref>).</p><p>Compression. Network transfers become a bottleneck for clientserver systems with high bandwidth. To reduce the bandwidth, we compress the transmitted vertex arrays using the open-source zlib library <ref type="bibr" target="#b21">22</ref> based on Huffman codes, which is fast and robust. We use the maximum level of compression for our client-server data transfers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Network Protocol</head><p>The following description assumes a single client per server, and can be extended for multiple clients by storing the context of the stream on each client.</p><p>The server understands three types of commands: NEW CAMERA, NEXT BOUNDARY, and NEXT INTERNAL.</p><p>New Camera. Each new client initializes the stream by sending a NEW CAMERA command, containing a frame ID and the camera information. The frame ID is an integer initialized to 0 and incremented by the client for every NEW CAMERA command.</p><p>Next Boundary. Upon connection, the client requests boundary faces from the server using the NEXT BOUNDARY command. The server incrementally sends the boundary faces in a BOUND-ARY DATA packet consisting of an unsorted triangle soup (i.e., a sequence of vertex coordinates) for the client to use during interactive rendering. By sending the boundary in chunks, the client can request only the portion that it can retain in memory. If the client is limited and can only use a portion of the boundary during interaction, the NEXT BOUNDARY command can be used at the beginning of the progressive rendering to fill in the missing boundaries before the internal faces are transmitted.</p><p>Next Interior. To avoid unnecessary sorting when the camera is moving, the server does not sort the faces until it receives a NEXT INTERNAL command from the client. The server culls the geometry by depth and frustum, sorts by centroid, and sends back a chunk of the interior faces in an INTERNAL DATA packet.</p><p>Synchronization issues. We use a TCP/IP socket to transmit our data. Unlike UDP, TCP guarantees that the data packets sent from the server arrive in the same order they were sent and without error. Since the client can change the camera at any time, the state of the client and the server need to be synchronized. This is necessary to avoid issues when the camera moves and the client is receiving data asynchronously, or the server is processing data. All the packets from the client or from the server contain a frame ID. Before processing a packet, the client and the server check that the frame ID from the packet is the same as the current frame ID. Packets with obsolete frame IDs are ignored by the server and the client. In addition, when the client receives an obsolete packet, it resets the stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">THE CLIENT</head><p>The main function of the client is as a progressive volume renderer. Because the client may be limited in disk space as well as memory (e.g., a laptop), the goal is to minimize the data stored on the machine at each progressive step. Therefore, the client acts as a stream rendererit receives geometry transmitted from the server and renders it directly with the GPU. This requires a volume renderer capable of handling dynamic data in an efficient manner. In addition, our algorithm requires an approximation technique for partial geometry as well as a means of keeping previously computed information for subsequent refinement steps.</p><p>To leverage GPU efficiency, we extend the Hardware-Assisted Visibility Sorting (HAVS) 33 algorithm of Callahan et al. <ref type="bibr" target="#b5">[6]</ref> to perform progressive volume rendering. The HAVS algorithm operates in both object-space and image-space to sort and composite the triangles that compose a tetrahedral mesh. In object-space, the triangles are sorted by their centroids using a linear-time radix sort for floating-point numbers. This provides a partial order for the triangles. Upon rasterization, the fragments are sorted again in image space using a fixed size A-buffer <ref type="bibr" target="#b6">[7]</ref> implemented with programmable shaders called the kbuffer. For each pixel of the resulting image, k entries (scalar value v and depth d) are stored in textures on the GPU. An incoming fragment is compared to entries in the k-buffer to find the two closest to the current viewpoint (for front-to-back compositing). These entries are then used to look up the color and opacity for the volume gap in a pre-integrated table by using the front scalar, back scalar, and distance between the entries. This color and opacity are then composited to the framebuffer, the front entry is discarded, and the remaining entries are written back into the k-buffer. For more detail on the HAVS algorithm, see <ref type="bibr" target="#b5">[6]</ref>. Our progressive renderer uses the HAVS algorithm as a basis for sorting and compositing. The server handles the object-space sorting, while the client handles the fixed-size image-space sorting and compositing.</p><p>The k-buffer is implemented in hardware using multiple render targets (MRTs), which allows the reading and writing of multiple offscreen textures in each pass. Currently, hardware limits the number of MRTs to four, which limits the size of k to six (one texture for an off-screen framebuffer and three textures for k-buffer entries). In OpenGL, the simplest access to multiple render targets is in the form of Framebuffer Objects (FBOs). An FBO is a collection of logical buffers such as color, depth, or stencil. Multiple color buffers (up to four) can be attached to an FBO for off-screen rendering. FBOs make it possible (and efficient) to swap attached buffers between rendering passes. Currently, this is faster than switching between multiple FBOs. The ability to render into a subset of buffers in multiple passes is at the heart of our progressive algorithm.</p><p>The progressive volume rendering works by using five different render targets for each pass, represented as four channel, 32-bit floatingpoint textures. The textures are used as follows:</p><p>T pro : An off-screen framebuffer for the progressive image</p><formula xml:id="formula_0">(R p , G p , B p , A p ).</formula><p>T k12 : k-buffer entries 1 and 2 (</p><formula xml:id="formula_1">v 1 ,d 1 ,v 2 ,d 2 ).</formula><p>T k34 : k-buffer entries 3 and 4 (</p><formula xml:id="formula_2">v 3 ,d 3 ,v 4 ,d 4 ).</formula><p>T k56 : k-buffer entries 5 and 6 (</p><formula xml:id="formula_3">v 5 ,d 5 ,v 6 ,d 6 ).</formula><p>T approx : A temporary framebuffer for the approximation of the portion of the mesh not yet received (R a , G a , B a , A a ).</p><p>A combination of these textures is used for each step of the progressive volume rendering. The contents of all the textures except T approx are reused in subsequent progressive passes.</p><p>Our progressive volume rendering is separated into three modes of operation. Interactive Mode is used during camera events such as rotation, pan, or zoom. Progressive Mode is used when interaction stops to stream triangles from the server to the client in chunks. The Progressive Mode can be interrupted at any time if the user begins interaction again or the stream finishes. When a complete image is generated with the Progressive Mode, Completed Mode automatically stores the image for future browsing. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Interactive Mode</head><p>A reduced representation of the original mesh is often necessary when considering large datasets. Our interactive mode has two requirements. First, it is fast enough to render at interactive rates (e.g., 10 fps). Second, the results of the interactive mode can be used as a first step in the progressive volume rendering. Because of the second requirement, level-of-detail techniques that require simplification hierarchies <ref type="bibr" target="#b7">[8]</ref> are not feasible. Instead, we use a similar approach to Callahan et al. <ref type="bibr" target="#b4">[5]</ref>, where a subset of the original geometry is used to create a reduced representation. In particular, Callahan et al. noticed that an efficient approximation of the dataset can be created by computing the volume rendering integral between only the boundary fragments of the mesh. We use a more robust version of this approximation that can be used in future progressive steps.</p><p>Upon connection with the server, the client receives some initial data to begin the progressive rendering process. First, mesh parameters such as maximum edge length and scalar range are transferred for creating a pre-integrated lookup table. Immediately following these parameters, the boundary triangles of the mesh are transferred to the client. These boundary triangles are placed in arrays on GPU memory and remain there for the duration of the client-server connection. If the entire boundary cannot be maintained in memory, a subset of the boundary can be used instead.</p><p>During user interaction (i.e., rotation, panning, or zooming), the following steps take place to create an approximate image.</p><p>1. Buffer T k12 is attached to the FBO as well as a depth buffer. The depth buffer is cleared and set to GL LESS for a first pass on the boundary geometry. The depth buffer is then cleared again and set to GL GREATER for a second pass at the boundary geometry. This has the same effect as depth-peeling <ref type="bibr" target="#b10">[11]</ref> the front and back fragments and placing them in the k-buffer.</p><p>2. Buffers T approx and T k12 are attached to the FBO and a screenaligned plane is rendered. Color and opacity for the ray-gaps between the front and back fragments from the boundary are looked up from T k12 and composited into T approx .</p><p>3. Buffer T approx is displayed to the screen.</p><p>These steps are repeated for every view change. When the user stops interacting, the entries in T k12 are used for the progressive steps. The importance of using this depth-peeling approach instead of the k-buffer directly is discussed in more detail in Section 5.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Progressive Mode</head><p>After the boundary has been drawn in Interactive Mode, the internal triangles of the mesh are streamed in an approximate front-to-back order based on their centroids. For each portion of the geometry that arrives from the server, the progressive volume renderer takes the following steps:</p><p>1. Buffer T approx is cleared.</p><p>2. Buffers T pro , T k12 , T k34 , and T k56 are attached to the FBO and the incoming internal geometry is rendered. The k-buffer is used to sort the fragments and composite the results into T pro . This step is similar to HAVS, but with only a portion of the geometry.</p><p>3. Buffer T approx is attached to the FBO, T k12 , T k34 and T k56 are bound as a read-only textures, and a screen-aligned plane is drawn. The fragment shader finds the k-buffer entry f closest to the current view and the entry b farthest from the current view, looks up the color and opacity for the ray gap between f and b, and composites the result into T approx .</p><p>4. Buffers T pro and T approx are attached to the FBO and a screenaligned plane is drawn. The fragment shader composites T pro into T approx .</p><p>5. Buffer T approx is displayed to the screen.</p><p>The k-buffer entries and progressive buffer T pro are then ready to be used in the next rendering pass. <ref type="figure" target="#fig_2">Figure 3</ref> illustrates the textures used during a progressive step. This process is repeated until all the geometry has been streamed from the server. When rendering the last portion of geometry from the server, an additional step is taken to flush the kbuffer entries into the T pro by rendering k − 1 screen-aligned planes after the second step. After which, the T pro buffer contains the full quality volume rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Completed Mode</head><p>Once the stream of geometry has terminated and the progressive volume rendering is completed, we capture the T pro buffer and save it for subsequent browsing as shown if <ref type="figure" target="#fig_3">Figure 4</ref>. Our progressive volume renderer allows the user to browse any previously completed visualizations by selecting the corresponding thumbnail. Capturing this data for the user has important benefits. First, it prevents the user from losing important visualizations through interactions that could reset the results of the previous stream. Second, it allows a user to specify a set of camera positions to the progressive volume renderer so the user can easily capture an animation of the exploration process. This tool is useful for exploring previously generated results while the current view is being progressively rendered off-screen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Considerations</head><p>The k-buffer algorithm efficiently handles streaming geometry because it simultaneously reads and writes from textures at each pass. Due to the highly parallel nature of GPU architectures, this may result in a race condition for overlapping triangles. Because the HAVS algorithm sends geometry sorted by centroid, it effectively layers the geometry in the depth direction and thus avoids these errors. However, since the depth compexity of the boundary is generally small and we want to keep the interaction as fast as possible, we do not sort the boundary faces in object-space before rendering. This may result in some noticeable artifacts in the first pass that would remain in subsequent progressive steps. Therefore, we perform the depth-peeling of the front and back fragments before inserting them into the k-buffer. This resolves the race condition, improves the quality of the rendering, and maintains interactive rates (see Section 6). The depth-peeling as described has the unfortunate side-effect that it removes any non-convexities in the boundary. This can propagate through the progressive steps and cause the empty space to be composited into the final image. Since storing the back fragments in the kbuffer effectively reduces k by one during the progressive steps, storing all boundary information for non-convex objects can severely impact sorting capabilities. A solution to this problem is to transmit boundary and internal faces during progressive steps. This would introduce redundant fragments only in the front and back and allow other boundary fragments to be used in the progression steps to avoid compositing empty space, as in <ref type="bibr" target="#b5">[6]</ref>. To completely remove the storage overhead of the back boundary in the k-buffer, an extra texture can be used to store the back fragments during Interactive Mode and can be bound as a read-only texture during Progressive Mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>Our experimental results were measured on a thin client (IBM T41 laptop) running Windows with a 1.7 GHz Pentium M processor, 1.5 GB RAM, and an ATI Mobility Fire GL T2 graphics card with 128 MB RAM. The server machine was running Linux with two Dual core Opteron 2.25 GHz processors, 8 GB RAM, and an NVidia GeForce 7800 GTX graphics card. Performance timings are measured with a 512 × 512 viewport on a 100 Megabit/sec ethernet network with regular network load. Our experiments include timing results for the progressive rendering with local and remote configurations, as well as  <ref type="table">Table 2</ref>. Performance analysis of the preprocessing and one step of the progressive volume rendering. Measurements were obtained for a client running on the server (Local) and on a laptop over the network (Ethernet).</p><p>error measurements for the progressive images. <ref type="table">Table 1</ref> shows the tetrahedra count of our test datasets, the one-time penalty to reformat them into our binary format used by the server, and the resulting size of the binary files.</p><p>Our timing measurements are shown in <ref type="table">Table 2</ref> for four large meshes. The Fighter and F16 datasets are simulations of jets, the SF1 dataset is an earthquake simulation, and the STP dataset is a simulation of a sphere going through a plate. The measurements can be broken into four important sections: server preprocessing, server, data transfer from the client to the server, and client. The preprocessing step occurs on the server and includes loading the file from disk, and building an octree, and transferring the mesh information to the client. By extending our binary file format to include the octree structure, the server preprocessing time could be decreased even further. The timing results for the server, client, data transfer, and total time represent one progressive rendering of the dataset from views that include the whole mesh. In addition, for the larger datasets, we chose a view showing only 25% of the mesh, which takes advantage of frustum culling (see <ref type="figure" target="#fig_4">Figures 5, 7, and 8</ref>). Because our client uses a thread for rendering and another for fetching data from the server, much of the data transfer and rendering work is done in parallel. Therefore, we measure data transfer as the total client time for a progressive step minus the rendering time. In our experiments, the interactive manipulation of our progressive renderer was able to achieve interactive rates for all but the largest dataset on the thin client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Stream Size</head><p>Local Since data transfer over the network is one of the main bottlenecks of our progressive renderer, we generated experiments to tune the stream parameters. One important consideration is the latency of the network. Several settings on the server effect the round-trip latency of the system -the time for the client to send a packet and receive a response. An obvious consideration is the compression of the geometry during transmission. For our network rendering, we used full compression of the stream and achieved about a 60% compression rate, which dramatically improved performance. Other important considerations include the octree resolution and stream size (number of triangles sent on each progressive step). Finer octree resolution and higher stream size improves performance, but decreases the number of progressive steps and increases memory usage on the client. <ref type="table">Table 3</ref> shows the effects of these parameters on the latency for the Fighter dataset. For our experiments with the thin client (see <ref type="table">Table 2</ref>), we were limited to a stream size of 100K triangles and an octree resolution of 1K triangles per octree node.</p><p>Our final experiment was to analyze the quality of the progressive steps. To measure this metric, we used root mean squared (RMS) error to compare incremental steps with the final rendering for all of our experimental datasets. <ref type="figure" target="#fig_5">Figure 6</ref> shows a plot of these errors as the progression refines. Since the quality of the approximation is directly related to the transfer function, we used the transfer functions shown in our figures that highlight the more relevant portions of the data. These results show that the image quality steadily converges to the full quality image, which is important for allowing the user to explore the dataset efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>Our progressive volume rendering system is unique because it efficiently handles data of arbitrary size on a thin client. This is done using a novel technique which keeps only image data and boundary geometry in GPU memory on the client for each step. The amount of memory used on the client can be bounded by adjusting the stream size and the size of the boundary. In our experiments, the boundary was not large enough to adversely effect performance or expend memory constraints. In fact, even with a 25 million tetrahedron dataset, the boundary can be volume rendered with our algorithm on a thin client in Interactive Mode at about two frames-per-second. This interactivity depends heavily on the boundary complexity of the dataset. If a dataset has a boundary too large to fit in GPU memory or render at acceptable rates, our algorithm would work efficiently by using only a random subset of the boundaries for an approximate rendering during interaction. This would have the effect of lightening the general appearance of the approximation. The remaining boundary triangles could then be streamed before the rest of the internal faces.</p><p>An important consideration for a progressive renderer is the depth complexity and structure of the dataset. The client rendering is fillbound and thus depends more on the view selected or screen size then on the depth complexity. However, the depth complexity of the dataset may adversely affect performance of our geometry processing on the server because more culling and sorting passes are required. Our approach for culling by depth on the server assumes an even distribution of triangles. For most of the experimental datasets, this results in few triangles selected in some ranges and many in others. This is balanced by accumulating triangles on the server until a target packet size is reached. A better approach may be to avoid using fixed depth ranges by traversing the octree incrementally from the front to the back, rather than doing a hierarchical culling. In our experiments, the aspect ratio or depth complexity of the dataset seems to impact overall performance only slightly if the server parameters are properly selected (number of depth ranges and minimum packet size).</p><p>A client-server progressive volume renderer is advantageous because it allows the data to be stored in a central repository, while the rendering can be performed with the help of graphics hardware on a client. This efficiently splits the load of the client and server for datasets that may be too large to render locally. Since processing power continues to increase rapidly for both CPUs and GPUs, it is becoming increasingly important to develop algorithms that efficiently harness the computational power without being limited by memory constraints. Our algorithm uses this approach by acting as a stream renderer and allowing the interactive exploration of a dataset with only a portion of the geometry.</p><p>The main disadvantage of using this paradigm is that data transfer over the network incurs a substantial penalty. We reduce this penalty partially with the use of lossless compression of the stream. If some loss in quality is acceptable, quantization techniques could also be applied to reduce the bandwidth of the geometry. Because data transfer is a limiting factor in quickly visualizing a full quality rendering, the quality of the approximation is important. Unlike naïve approaches that render only an opaque boundary mesh or outline, our initial approximation gives excellent results with little overhead. With only a few iterations, our progressive volume renderer converges to the final image which facilitates dynamic exploration. We find this aspect useful because often in the exploration process, the user will not wait for the entire progressive volume rendering before moving on to another viewpoint. Because only the geometry within the current view frustum is transferred, efficiently exploring details of the dataset becomes easy. This feature also makes rapid transfer function exploration possible. With each update of the transfer function, the stream can be reset and the progression started. For datasets with more important features in the center, the boundary may not give a good approximation. A more advanced technique that uses multiple k-buffers could be employed to render several advancing progressions at once which results in an increased rendering overhead. A simpler approach would be the addition of user-controlled cutting planes that could cull geometry on the server, thus reducing the amount of data sent to the client and allowing the rapid visualization of internal structures. Along with the image capturing system, which keeps previously computed results, these features would provide a powerful data exploration tool for large datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS AND FUTURE WORK</head><p>Our algorithm provides a progressive volume rendering system for interactively exploring large unstructured datasets. We use a novel ap- proach of balancing the load of the client and server while minimizing the memory constraints of the client. In fact, our algorithm can bound the memory usage of the client machine to allow a wide variety of client devices. We have introduced a novel progressive algorithm that efficiently uses the GPU to incrementally refine the visualization by retaining only image data. An interactive mode can be efficiently computed with the addition of boundary triangles that can be kept in GPU memory. To further improve interaction, our system keeps previously computed visualizations that can be interactively browsed while progressively rendering the visualization. Finally, we have provided detailed experiments and discussed the trade-offs of a client-server approach for volume rendering unstructured grids.</p><p>In the future, we would like to explore more efficient methods of reducing the data size for transmission from server to client. In particular, geometry compression algorithms (e.g., <ref type="bibr" target="#b3">[4]</ref>) could alleviate bandwidth constraints. We would also like to add a more advanced depth culling algorithm to avoid manual parameter tuning and add user-controlled cutting planes to facilitate exploration further. Another area of future research is to extend our system to render isosurfaces and to explore the visualization of time-varying data in a progressive manner. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>A sequence of progressive volume rendering steps for the SF1 dataset with about 14 million tetrahedra. Starting from an interactive mode that uses only the boundary (left), the algorithm progressively refines the image using incoming geometry as well as the results of the previous refinement until the full-quality rendering is achieved (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>The client-server architecture. Communication between the client and the server is shown with annotated arrows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>The progressive volume renderer on the client. A progressive buffer is maintained between steps and an approximate buffer is created to fill the unknown region of the mesh.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>A snapshot of the interaction with the Completed Mode for the SF1 dataset. Upon completion of a full quality rendering, the image is automatically stored for future browsing by selecting the icons at the bottom of the window. The user may also save intermediate steps with a keystroke.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>A zoomed-in view of the STP dataset (about 25M tetrahedra) during interaction. Significant performance improvements are made by frustum-culling the geometry on the server. Here, 50% of the geometry is culled during the progression.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Root Mean Squared Error (RMS) of the progressive images going from only the boundaries (0%) to the full quality (100%).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>A zoomed-in portion of the F16 dataset (about six million tetrahedra) shown progressively at (a) 0%, (b) 12%, (c) 61%, and (d) 100%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>A zoomed-in portion of the Fighter dataset (about 1.4 million tetrahedra) shown progressively at (a) 0%, (b) 14%, (c) 29%, (d) 43%, (e) 57%, (f) 71%, (g) 86%, and (h) 100%. View-frustum culling on the server removed 75% of the original geometry for this view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Table 3. Latency analysis of different server settings on the Fighter dataset with an octree depth of seven, a 802.11 wireless network at 54 Mbps, and an ethernet network at 100 Mbps.</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Ethernet Wireless</cell></row><row><cell>1K Triangles</cell><cell>0.082 s</cell><cell>0.050 s</cell><cell>0.051 s</cell></row><row><cell>10K Triangles</cell><cell>0.085 s</cell><cell>0.090 s</cell><cell>0.130 s</cell></row><row><cell cols="2">100K Triangles 0.574 s</cell><cell>1.042 s</cell><cell>1.893 s</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11">http://www.sgi.com/products/software/vizserver</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22">http://www.zlib.net</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="33">http://havs.sourceforge.net</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was performed under the auspices of the U.S. DOE by LLNL under contract no. W-7405-Eng-48. The authors acknowledge Neely and Batina (NASA) for the Fighter dataset, Tremel (EADS-M) for the F16 dataset, O'Hallaron and Shewchuk (CMU) for the SF1 dataset, and the Army Research Laboratory (ARL) for the STP dataset. The authors also thank the reviewers for insightful comments and suggestions. Steven P. Callahan, Louis Bavoil, and Cláudio T. Silva are funded by the National Science Foundation (grants CCF-0401498, EIA-0323604, OISE-0405402, IIS-0513692, and CCF-0528201), the Department of Energy, an IBM Faculty Award, Sandia National Laboratories, Lawrence Livermore National Laboratory, the Army Research Office, and a University of Utah Seed Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Volume rendering of unstructured grids with time-varying scalar fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">F</forename><surname>Bernardon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L D</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Symposium on Parallel Graphics and Visualization</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="51" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">GPUbased tiled ray casting using depth peeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">F</forename><surname>Bernardon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Pagot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L D</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<idno>UUSCI-2004- 006</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Graphics Tools</title>
		<imprint/>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>to appear. Also available as SCI Institute</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Using high-speed wans and network data caches to enable remote and distributed visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bethel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Tierney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing &apos;00</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page">28</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tetstreamer: Compressed back-to-front transmission of delauney tetrahedra meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Bischoff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Compression Conference</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive rendering of large unstructured grids using dynamic level-of-detail</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L D</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;05</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="199" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hardware-assisted visibility sorting for unstructured volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ikits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="285" to="295" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The A-buffer, an antialiased hidden surface method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proceedings of ACM SIGGRAPH)</title>
		<imprint>
			<date type="published" when="1984-07" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="103" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Selective refinement queries for volume visualization of unstructured tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">D</forename><surname>Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="45" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Progressive isosurfaces on the web. Late Breaking Hot Topics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Sommer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A framework for interactive hardware accelerated remote 3D-visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Sommer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EG/IEEE TCVG Symposium on Visualization (VisSym)</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Interactive order-independent transparency. White paper, NVIDIA Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Everitt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Quadric-based simplification in any dimension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2005-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Chromium: a stream-processing framework for interactive rendering on clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ahern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;02</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="693" to="702" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Visualization of time-dependent remote adaptive mesh refinement data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaehler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Prohaska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hutanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;05</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="175" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interactive visualization of unstructured grids using hierarchical 3d textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Volume Visualization and Graphics</title>
		<meeting>IEEE Symposium on Volume Visualization and Graphics</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Compression domain volume rendering for distributed environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lippert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kurmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="95" to="107" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Level of Detail for 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Huebner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Morgan-Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sort-last parallel rendering for viewing extremely large data sets on tile displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moreland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wylie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pavlakos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 2001 symposium on parallel and large-data visualization and graphics</title>
		<meeting>the IEEE 2001 symposium on parallel and large-data visualization and graphics</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="85" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Tetsplat: Real-time rendering and volume clipping of large unstructured tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Museth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lombeyda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="433" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for isosurface rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-P</forename><surname>Sloan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="233" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of San Diego Workshop on Volume Visualization</title>
		<meeting>San Diego Workshop on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A survey of GPU-based volume rendering of unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L D</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">F</forename><surname>Bernardon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brazilian Journal of Theoretic and Applied Computing (RITA)</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="9" to="29" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hardware-based ray casting for tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;03</title>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="333" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Texture-Encoded Tetrahedral Strips</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Mallón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Symposium on Volume Visualization</title>
		<meeting>Symposium on Volume Visualization</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transaction on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Visibility-ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
