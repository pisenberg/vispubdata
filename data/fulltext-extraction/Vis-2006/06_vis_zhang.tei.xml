<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Point-based Isosurface Exploration and High-quality Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haitao</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Fellow, IEEE</roleName><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
						</author>
						<title level="a" type="main">Interactive Point-based Isosurface Exploration and High-quality Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Isosurface</term>
					<term>point-based visualization</term>
					<term>isosurface extraction</term>
					<term>hardware acceleration</term>
					<term>GPU acceleration</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present an efficient point-based isosurface exploration system with high quality rendering. Our system incorporates two point-based isosurface extraction and visualization methods: edge splatting and the edge kernel method. In a volume, two neighboring voxels define an edge. The intersection points between the active edges and the isosurface are used for exact isosurface representation. The point generation is incorporated in the GPU-based hardware-accelerated rendering, thus avoiding any overhead when changing the isovalue in the exploration. We call this method edge splatting. In order to generate high quality isosurface rendering regardless of the volume resolution and the view, we introduce an edge kernel method. The edge kernel upsamples the isosurface by subdividing every active cell of the volume data. Enough sample points are generated to preserve the exact shape of the isosurface defined by the trilinear interpolation of the volume data. By employing these two methods, we can achieve interactive isosurface exploration with high quality rendering.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>One way to understand a volume data is by isosurface exploration, in which the user interactively changes the isovalue and/or the view, trying to find useful information by examining the isosurfaces of various isovalues. An isosurface exploration system should support an interactive rate, including isosurface extraction and rendering. In addition, the rendering quality should be guaranteed, so that the user can clearly examine the isosurface under any view.</p><p>Many isosurface extraction approaches have been proposed, including the well known Marching Cubes (MC) method <ref type="bibr" target="#b18">[19]</ref>, which generates triangles in every active cell to approximate the isosurface. When the size of the volume data becomes large, a huge number of small triangles is generated, making it very inefficient to represent and render the isosurface by triangles. Thus, the point primitive becomes a better alternative. Points are generated inside the active cells <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b24">25]</ref>, and surface splatting is used for rendering. Usually, there is an overhead when the isovalue is changed in the isosurface exploration. Besides, using a fixed number of points to represent the isosurface cannot guarantee high quality rendering especially under closeup view.</p><p>In this paper, we present edge splatting, a point-based method for interactive isosurface exploration, which directly generates points on the isosurface. In a volumetric data, an edge is defined by two neighboring voxels (6-connectivity is assumed). The edge is active when the isovalue is between the two corresponding voxel values. Along each active edge, a point is placed at the location where the isosurface goes through. We send the active edges directly to the graphics hardware, and incorporate point generation in the hardware-accelerated rendering to avoid the overhead when changing the isovalue. Under a closeup view, the points may become sparse on the image plane, and artifacts may appear in the rendering. In order to solve this problem, we introduce an edge kernel method, which is a view-dependent approach for generating enough points to preserve the exact shape of the isosurface defined by the trilinear interpolation of the volume data. We implement the edge splatting and the edge kernel method in our point-based isosurface exploration system for interactive exploration and high quality rendering.</p><p>The main contribution of this paper is the edge-based approach to generate points for isosurface extraction and rendering, including: • The use of volume edge to generate points on the exact isosurface.</p><formula xml:id="formula_0">•</formula><p>• The design of an edge kernel for isosurface upsampling based on cell subdivision, with a complexity of O(n 2 ).</p><p>• The integration of point generation in GPU-based rendering.</p><p>Section 2 is a brief review of the related work. The edge splatting and the edge kernel methods are presented in Section 3 and Section 4, respectively. Section 5 shows the results of our experiments conducted using our point-based isosurface exploration methods. We conclude and discuss the future work in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Unlike MC <ref type="bibr" target="#b18">[19]</ref>, the extended Marching Cubes method <ref type="bibr" target="#b13">[14]</ref> detects and preserves the sharp features inside the active cells by comparing the normals of the intersection points. Dual contouring methods <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13]</ref> create one vertex inside each active cell and the four vertices corresponding to the four cells around an active edge form a quad. Ray casting <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27]</ref> can also be used for isosurface extraction and rendering by finding the ray-isosurface intersection.</p><p>Isosurface extraction can be sped up by some data structures, such as span space <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b23">24]</ref> or interval trees <ref type="bibr" target="#b4">[5]</ref>. Volume cells are sorted by their extreme values, and only those cells whose value intervals contain the isovalue are visited, making the extraction time proportional to the size of the isosurface, instead of the volume data size. Another kind of approach to improve the isosurface extraction efficiency is view-dependent extraction <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b19">20]</ref>. This saves the time of visiting the invisible active cells, and the size of the visible isosurface determines the extraction time.</p><p>When the volume data is very large, many of the generated triangles are projected to sub-pixel size on the image plane. Consequently, the point becomes a better choice for isosurface representation and rendering. The Dividing Cubes (DC) method <ref type="bibr" target="#b5">[6]</ref> might be the first pointbased isosurface extraction and rendering method, although it intends to generate high quality rendering when the projection of the active cell is larger than one-pixel size. In the DC method, each active cell is recursively subdivided until the screen projection is within one pixel size. The resulting sub-cells that intersect with the isosurface are rendered using the point primitive. In our edge kernel method, we use a similar idea and design an edge kernel for cell subdivision to generate enough points on the isosurface for high quality rendering.</p><p>There are usually two steps in the point-based isosurface exploration: point generation and rendering. Different algorithms are proposed for point generation. Iso-splatting <ref type="bibr" target="#b6">[7]</ref> generates one point inside each active cell and find its approximate projection on the isosurface defined by trilinear interpolation of the volume data. Co et al. <ref type="bibr" target="#b7">[8]</ref> also propose a point-based method for generating smooth isosurface from multiblock data using the MC algorithm and a projection operator. Livnat and Tricoche <ref type="bibr" target="#b17">[18]</ref> propose a view dependent isosurface extraction method. Points are used under a far view while triangles are used in a close view. Rymonlipinski et al. <ref type="bibr" target="#b24">[25]</ref> present a span-triangle data structure for efficient isosurface extraction. In order to achieve interactive rate in isosurface exploration, they use the centers of the active cells for isosurface approximation. Waters et al. <ref type="bibr" target="#b25">[26]</ref> design a span space representation using fixed-size buckets, which supports incremental isosurface extraction when the isovalue increases or decreases. Nearly all the existing methods use surface splatting <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b27">28]</ref> for the rendering, which can be accelerated by using the programmability of modern GPUs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b28">29]</ref>. In surface splatting, each point generates a footprint on the image plane to fill the gaps among points and blend neighboring points together to get a hole-free smooth surface. These isosurface exploration methods separate point generation from rendering, creating the overhead in the isosurface exploration when the isovalue is changed. In contrast, in our edge splatting method, we use a span space data structure similar to the span-triangle <ref type="bibr" target="#b24">[25]</ref>, but apply it to the volume edges. In this way, we can efficiently generate points which are exactly on the isosurface. Besides, instead of feeding the GPU with points, we send the volumetric information and incorporate point generation in the GPU-based rendering to avoid any overhead when changing the isovalue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EDGE SPLATTING</head><p>For the point-based isosurface exploration, usually one point is placed inside each active cell for isosurface representation and rendering. This point can be generated on the isosurface through projection <ref type="bibr" target="#b6">[7]</ref>, which is an expensive operation, resulting in overhead when changing the isovalue. Alternatively, the centers of the active cells can be used for efficient point generation <ref type="bibr" target="#b24">[25]</ref>. Using the points on the exact isosurface creates a better rendering than the active cell centers, especially when the point density on the image plane is low.</p><p>In our edge splatting method, points on the isosurface are efficiently generated and rendered. Instead of finding the active cells, we find the active edges for isosurface extraction. The active edges are guaranteed to intersect with the isosurface, and the intersection points are used for exact isosurface representation and rendering. These intersection points are the same vertices in the triangular mesh generated by the MC method. We integrate point generation into the GPU-based rendering with a goal to avoid any overhead when changing the isovalue in the exploration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Edge Data Structure</head><p>Similar to the volume cell, a volume edge has a minimum and a maximum value. Those data structures that speed up active cell query can also be extended to edges. Since we are concerned with interactive exploration rate, we want to store the volume edge information in such a way that after locating the active edges, the data can be sent directly to the GPU for rendering without any further processing on the CPU. Thus, we adopt the span-triangle data structure <ref type="bibr" target="#b24">[25]</ref> and apply it to the volume edges.</p><p>By using the span-triangle, our edge data structure includes a base array, a span array and an edge information array. Given an exploration isovalue range [v min , v max ], all the edges whose two values are not the same and whose value interval intersects with [v min , v max ] are sorted by the minimum value, then by the span (the difference between the maximum and minimum value) for the edges with a same minimum value. The edge attributes of these sorted edges are stored linearly in the edge information array. The base array (corresponding to the minimum value) and the span array contain the array indices for efficient query, which are created in a way similar to <ref type="bibr" target="#b24">[25]</ref>.</p><p>In the edge information array, we need to store the attributes needed for point generation and rendering. To find the intersection between an edge and the isosurface, the edge position and orientation, minimum and maximum values should be known. The normal is also needed for rendering. The position is stored as the position of the edge endpoint with the minimum value, and the normal is approximated by the volume gradient at the edge center. There are six possible edge orientations for the positive and negative directions of the three axes: X + , X − , Y + , Y − , Z + and Z − . The minimum and maximum values of the edge are implicitly stored in the data structure. All the active edges with a same minimum value are continuously stored together, with their maximum values in increasing order. In the active edge query, it is very efficient to obtain the starting and ending indices of the edges with the same minimum value, but need to access more data to find out the maximum value. Thus, we also store the maximum value in the edge information array. For each entry of the edge information array, three 16-bit integers are used for position, one 16-bit integer for maximum value, three bytes for the quantized normal, and one byte for the orientation, totaling 12 bytes. Actually, fewer bytes can be used, for example, storing the position as the corresponding voxel index using a 32-bit integer, using 3-bit for the orientation, and storing it in the unused bits of other attributes (such as position), using 2 bytes for normal, and omitting the maximum value and getting it from the edge data structure. This is a tradeoff between memory and efficiency.</p><p>The edge information array is stored in the system memory as a vertex array. In the isosurface exploration, given an isovalue, the starting and ending array indices of the active cells are computed for each minimum value not exceeding the isovalue using the base array and the span array, and the corresponding edges are sent to the GPU as vertex array data for rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Point Generation and Rendering</head><p>After sending the edge position, normal, orientation, and values of the active cells to the GPU, the points are generated in the vertex shader as the intersections between the edges and the isosurface. Below is part of the vertex shader written in Cg for point generation:  Surface splatting is used for rendering. For each point, we need a radius for the size of the region of influence. Since there is no connectivity information available for the generated points, we simply use a fixed radius large enough to avoid holes in the isosurface. The value is set to √ 3, the cell diagonal length. The splat kernel in the surface splatting determines the rendering quality and speed. Per-pixel shading <ref type="bibr" target="#b0">[1]</ref> is used in the shading pass, whose running time (1 ms in our experiments) is independent of the volume data. <ref type="figure" target="#fig_1">Fig. 1</ref> compares our edge splatting with the rendering using the centers of the active cells <ref type="bibr" target="#b24">[25]</ref> under the square kernel and the EWA kernel <ref type="bibr" target="#b27">[28]</ref>. Apparently, our edge splatting method generates better results. For example, holes appear in <ref type="figure" target="#fig_1">Fig. 1</ref>(e) because the surface is approximated by a set of oriented disks centered at the active cell centers, many of which deviate slightly from the isosurface. This can be prevented using our edge splatting method <ref type="figure" target="#fig_1">(Fig. 1(f)</ref>), where the generated disks are on the exact isosurface.</p><formula xml:id="formula_1">//</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EDGE KERNEL METHOD</head><p>In our edge splatting, the extracted isosurface is represented and rendered by a point primitive. When EWA kernel is used in surface splatting, the isosurface is actually represented by a set of oriented disks. Contrary to the triangular mesh, this is not a watertight surface representation. Under closeup view, or when the volume data has a low resolution, there will be noticeable artifacts, especially in the regions with high curvature <ref type="figure" target="#fig_2">(Fig. 2(a)</ref>). <ref type="figure" target="#fig_2">Fig. 2</ref>(a) also looks flat under perpixel shading because of the low point resolution with the use of a fixed splat radius. In order to get smooth shading, the splat radius should be increased to guarantee that there are more than one splat projecting to any position on the isosurface, which would further increase the artifacts in the regions with high curvature. Under these conditions, generating points along the volume edges is not enough, and we need to increase the point density to avoid the artifacts.</p><p>Subdividing the active cells can increase the isosurface resolution, such as in DC <ref type="bibr" target="#b5">[6]</ref>. We can also subdivide the active cells to a certain resolution before our edge splatting method to avoid the possible artifacts. Because it is view-dependent, the subdivision should be performed on-the-fly. The challenge is how to efficiently classify the resulting sub-cells as active or not, and incorporate this classification into the rendering. Instead of applying the edge splatting on the subcell level, we design an edge kernel to generate enough sample points inside every active cell, which are the same points generated by edge splatting after subdivision. In our edge kernel method, the point generation and rendering are also integrated together, and implemented on the GPU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Edge Kernel</head><p>For an active cell with center position p c , Equation 1 computes the maximum possible projected size (in the unit of pixel sidelength) on the image plane under perspective view, assuming the aspect ratio of the field of the view is the same as the image aspect ratio:</p><formula xml:id="formula_2">S(p c ) = − √ 3 z n w ((M p c ) z + √ 3/2)(r x − l x )<label>(1)</label></formula><p>where M is the modelview matrix, w is the image width, l x and r x are the coordinates for the left and right clipping planes, z n is the distance from the camera to the near clipping plane. After subdividing the active cell into k × k × k sub-cells, where k = ceil(S(p c )) is the projection size of the cell, all the sub-cells project within one pixel size. There are 3k 3 sub-edges from the subdivision (the sub-edges on the three outer cell faces are excluded, which would be taken care of by the neighboring cells). Applying our edge splatting method to these sub-edges would generate enough sample points under the view, which preserve the exact shape of the isosurface defined by trilinear interpolation. As the isosurface inside an active cell is defined by the trilinear interpolation of the eight surrendering voxels, for all k sub-edges on the same axis-aligned line, there is at most one intersection with the isosurface. By making use of this property, we design an edge kernel and apply it directly to the active cell for point generation.</p><p>An edge kernel E k with size k consists of 3k 2 edges evenly distributed inside a unit cell. Each edge starts on one face of the cell and ends at the corresponding position on the opposite face. <ref type="figure" target="#fig_3">Fig. 3</ref> shows three edge kernels with size 1, 2 and 3, respectively. It is equivalent  </p><formula xml:id="formula_3">w = v − v s v f − v s (3) (a) E 1 (b) E 2 (c) E 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation</head><p>Our edge kernel method is a view-dependent point-based isosurface extraction and rendering method. Any data structure <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref> for efficient active cell query can be used. After passing the view frustum culling, an edge kernel of size k is determined for each active cell using Equation 1, and E k is applied for point generation inside the cell. Since the generated points are adequately sampled, for each pixel belonging to the isosurface on the image plane, there is at least one point mapping to it. The isosurface can be easily rendered by using the OpenGL point primitive with depth enabled and setting pointsize to 1.</p><formula xml:id="formula_4">v s v f p i x = 0 x = 1 s = 2/3 t = 1/3 v 0 v 1 v 3 v 2 v 4 v 5 v 7 v 6</formula><p>We integrate the point generation in the rendering and implement it on the GPU. First, a small change is made in the edge kernel representation. The edge representation for E k is changed from &lt; c, s,t &gt; to &lt; c, s * k,t * k &gt;. In this way, for two edge kernels E a and E b with a &lt; b, the edges of E a are the first 3a <ref type="bibr" target="#b1">2</ref> edges of E b . Then, only one edge kernel with the largest possible size is needed, because it includes all the edge kernels with smaller sizes. In our implementation, we set the largest kernel size to 1000, which is enough for nearly any view in the rendering. Under this new representation, all the values are integers. A 16-bit integer array is created to store E 1000 , with 6MB total size. Each edge representation can be thought of as a 3D vertex, and this "vertex" array is stored on the GPU memory using the vertex buffer objects extension.</p><p>In the rendering, the CPU determines the kernel size k for each active cell, sends the 8 voxel values of the cell and the kernel size to the GPU, and asks the GPU to render the first 3k 2 "points" of the vertex array. In the vertex shader, the local coordinates for the edge endpoints are recovered by dividing the kernel size, and the point is generated as the intersection between the edge and the isosurface. If there is no intersection, an out-of-view-frustum position is set to cull away this point.</p><p>For per-point shading, the normal of the trilinear-interpolated sur- face inside the active cells is used as the point normal for shading, which can be easily computed on the GPU ( <ref type="bibr" target="#b19">[20]</ref> for the equation for this normal computation). Because of C0 continuous between neighboring cells under trilinear interpolation, this method cannot get smooth shading across the cells <ref type="figure" target="#fig_2">(Fig. 2(d)</ref>). Alternatively, we can use per-pixel shading by adding a shading pass to get the point normals from the original volume data, which is quite similar to <ref type="bibr" target="#b11">[12]</ref>. The point positions in the volume space are rendered to a texture with floating point precision. If the volume size is not large, a gradient map of the volume is pre-computed using the central difference and stored on the GPU as a 3D texture. In the shading pass, the corresponding point normals are fetched from this texture using trilinear interpolation. When the data is too large to fit in the GPU memory, we read out the point positions from the GPU, compute the normals and shade the pixels on the CPU. This per-pixel shading method generates smooth shading everywhere on the isosurface <ref type="figure" target="#fig_2">(Fig. 2(e)</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Comparison</head><p>Compared with the point-based surface upsampling method <ref type="bibr" target="#b10">[11]</ref>, our edge kernel method is more suitable for the isosurface exploration, because in the surface upsampling method, the extra points are generated from the existing sample points, which may not reside on the exact isosurface. Besides, the surface-based upsampling method usually requires point neighborhood information, which is expensive to get on-the-fly from the value-sorted volume data structures, such as the span-triangle used in our isosurface exploration system. <ref type="figure" target="#fig_5">Fig. 5</ref> compares the isosurfaces generated by the edge kernel method with those of edge splatting and the MC method inside one or two neighboring active cells. The isosurface from the MC method is flat inside the cells and C0 continuous between the cells. For our edge kernel method, we get a C1 smooth isosurface inside the active cells and also C0 continuous between the cells. <ref type="figure" target="#fig_2">Fig. 2</ref> shows a closeup view of the Cello data using edge splatting, the MC method, MC with adaptive subdivision, edge kernel with per-point shading and per-pixel shading, with the rendering speed (in fps) listed under each image. When the projection size of the triangles generated from the MC method is large <ref type="figure" target="#fig_2">(Fig. 2(b)</ref>), the MC method, by sacrificing image quality, can be much faster than the edge kernel method. Smooth shading can be applied to the MC method, which requires the triangle connectivity information to obtain the vertex normal. This connectivity information is expensive to get from the valuesorted volume data. To minimize the flat geometry inside the triangles, adaptive subdivision can be used before the MC method. In <ref type="figure" target="#fig_2">Fig. 2(c)</ref>, the active cells are adaptively subdivided until all the triangle projections are within 10 pixel size. The resulting rendering is similar to the edge kernel method with per-pixel shading, but with a much slower rendering speed. This is because the complexity of MC with adaptive subdivision is O(n 3 ), while the edge kernel method is O(n 2 ). In order to eliminate the flatness inside the triangles, the cells should be subdivided down to sub-pixel size. Then, it is better to directly use point for the isosurface representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>We have implemented our edge splatting and the edge kernel method in our point-based isosurface exploration system. The user can choose which method to use. Edge splatting is very efficient, and generates an image with good quality when the point density is not too low on the image plane. If the point density becomes too low, especially under closeup view, the edge kernel method can be used to generate high quality rendering with the price of a relatively slower speed. One strategy we implemented is to let the system choose the method automatically. During the exploration, when the user continuously changes the isovalue and/or the view, edge splatting is used for interactive rate. When the user pauses during the exploration, the system switches to the edge kernel method if the point projection on the image plane is above a threshold, so that the user can clearly examine the details of the isosurface. Because all points have the same radius, the point projection size is estimated using the nearest corner of the volume data bounding box from the viewpoint. In order to avoid extra data storage, the edge data structure for edge splatting is also used for active cell query in the edge kernel method. For an active edge, the four neighboring cells must be active. A bitmap is used to avoid duplicate rendering of the active cells.</p><p>We use a 3.59GHz PC with an NVIDIA Quadro FX 4500 graphics card to conduct the experiments for our isosurface exploration system. All the vertex/fragment shaders are written in Cg language. The rendered image size in the experiments is 800 × 800. <ref type="table" target="#tab_1">Table 1</ref> lists the volume data size we used in the experiments, the corresponding edge data structure size and creation time. The Stored Edge Percentage column shows the percentage of the number of stored edges to the number of total edges in the volume data, including the edges with the same value at the endpoints, and the edges outside the exploration isovalue range, if any. For large volume data especially with more than 8-bit precision, we assume that the regions outside the region of interest (ROI) are clipped away, or the isovalue range of the ROI is known, so that we can save memory for the ROI. When applying the span-triangle data structure to the edges, on average, the number of the sorted edges is two times of the number of the cells, if cell data structure is created <ref type="bibr" target="#b24">[25]</ref>. In edge splatting, the accurate isosurface points are efficiently generated with the price of this extra data storage. Compared with the texture-based isosurface rendering methods <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27]</ref>, our method requires more memory, which may be too large to fit in current GPU memory. <ref type="table" target="#tab_2">Table 2</ref> shows the active cell/edge counts and the rendering speed of edge splatting with the corresponding images in <ref type="figure" target="#fig_6">Figs. 6 and 7</ref>. The number of the active edges is roughly the same as the number of the active cells. The number of the active edges is the number of quads in the dual method of MC, and the number of the vertices of these quads is the number of active cells. Under a regular volume grid, a vertex is usually shared by four quads, making the number of the quads (active edge count) be roughly the same as the number of vertices (active cell count). Thus, compared with the use of active cell centers <ref type="bibr" target="#b24">[25]</ref>, our edge splatting has a similar point density, but provides better point placement for the isosurface representation   and rendering. Given a volume data, the isosurface rendering speed is determined by the isovalue (for the number of points) and the view (for the image plane projection size and visibility), and is independent of the isovalue in the previous frame. The rendering speed of edge splatting ranges from 16Mpoint/s to 100Mpoint/s for the square kernel (ESS) and 3.4Mpoint/s to 29Mpoint/s for the EWA kernel (ESE).</p><p>In our experiments, there is no noticeable difference in the rendering speed between our method and <ref type="bibr" target="#b24">[25]</ref>, because the only difference is in the vertex shader where edge splatting has a few more instructions to compute the edge-isosurface intersection.</p><p>The edge kernel method is much slower (about 1 to 4 fps) when a large number of rendering primitives is generated. The per-pixel shading pass for the edge kernel method is fast if implemented on the GPU (2 ms), and ranges from 15 ms to 60 ms on the CPU, depending on the number of pixels to be shaded. <ref type="figure">Fig. 7</ref> shows the isosurfaces of the Head MRT Angiography data rendered by ESS, ESE, and the edge kernel method. Under far view (first row of <ref type="figure">Fig. 7)</ref>, except for the noisy regions, there is little difference in the renderings of the three methods. When we move closer (second row of <ref type="figure">Fig. 7</ref>), artifacts appear in ESS, and ESE is still comparable with the edge kernel method. Under closeup views (last row of <ref type="figure">Fig. 7</ref>), ESE displays unacceptable artifacts, while our edge kernel method still preserves high quality rendering. The edge kernel method is relatively slower, which cannot reach interactive rate if too many active cells are inside the view frustum. Thus, in the isosurface exploration, the system should choose the method according to the view to achieve the best speed/quality combination, namely, ESS for far away views, ESE for mid range views, and the edge kernel method for closeup views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FUTURE WORK</head><p>In this paper, we present an interactive isosurface exploration system with high quality rendering. Two point-based methods are used: the edge splatting and the edge kernel method. In edge splatting, points on the isosurface are efficiently generated along the active edges. In the edge kernel method, an edge kernel is used to generate enough sample points for high quality rendering under any view. Both methods incorporate the point generation and rendering together and implement them on the graphics hardware for interactive isosurface exploration.</p><p>In our edge splatting method, all the active edges are sent to the GPU for visualization, which is inefficient when the volume data is very large (for example, the Visible Human dataset is well over 1GB). The projections of many active edges would be within one pixel size, making it unnecessary to get the exact isosurface positions along the edges. Our edge kernel method is relatively slow when there are too many active cells inside the view frustum. In our future work, we plan to design a hierarchical data structure to decrease the number of rendering primitives and to select suitable rendering methods for the different parts of the model. The lower resolution data can be stored in the GPU memory, and the higher resolution data is sent to the GPU only when necessary. We also plan to conduct a more through comparisons with the ray-casting methods <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27]</ref>, including image quality, memory requirement, and efficiency.</p><p>Besides the large number of rendering primitives, there are two reasons for the slow speed of our edge kernel method: (1) It is not an exclusive GPU implementation but requires the CPU to determine the edge kernel size; (2) Point primitive with 1-pixel size is used, which cannot fully utilize the parallelism of the fragment shader on the GPU. These two limitations might be solved on the next generation GPU with Geometry Shader: multiple primitives (sample edges in the edge kernel) can be generated from one input primitive (active cell), leading to a more efficient GPU implementation.</p><p>Currently, our isosurface exploration methods work for volume data with an isotropic grid. In the future work, we plan to extend them to an anisotropic grid, which is common in medical data from MRT and CT scanning. For the edge kernel method, it is rather simple: the spacing between the edges in the edge kernel is adapted to the spacing of the volume data for evenly distributed sampling. For the the edge splatting, we might use either an asymmetric splat kernel or an edge kernel to subdivide the rectangular cells into near-cubic ones.  <ref type="figure">Fig. 7</ref>. Isosurfaces of the Head MRT Angiography data rendered by edge splatting using square kernel (ESS) and EWA kernel (ESE), and the edge kernel method (EK). The isovalues for row one, two and three are 142, 183, and 234, respectively. (a) to (h) render the point normal encoding directly, while (i) and (j) are shaded using the normal.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>vertex input struct appin { //xyz: position; w: max_value. float4 position : POSITION; //xyz: normal; w: orientation (0-5). float4 normal : COLOR; //x: min_value; y: isovalue-min_value. float2 v1ISO : TEXCOORD0; }; //vertex output struct appout { float4 HPOS : POSITION; ... }; appout main ( appdata IN, uniform float4x4 ModelViewProj : state.matrix.mvp, uniform float3 Orientation[6] = { { 1, 0, 0}, {-1, 0, 0}, { 0, 1, 0}, { 0,-1, 0}, { 0, 0, 1}, { 0, 0,-1} } ) { appout OUT; float4 exactPos; //intersection float interp; //compute interpolant interp = (IN.v1ISO.y) / (IN.position.w-IN.v1ISO.x); exactPos.xyz = IN.position.xyz + interp * Orientation[IN.normal.w * 5]; exactPos.w = 1; OUT.HPOS = mul(ModelViewProj, exactPos); ... return OUT; }(a) 26,044 points (b) 26,042 points (c) 26,044 points (d) 26,042 points (e) 368,296 points (f) 370,122 points</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Isosurface rendering. Left column: point-based rendering using the centers of the active cells; Right column: edge splatting, using the intersections between active edges and the isosurface. (a) and (b) are using the square kernel for surface splatting, while the rest are using the EWA surface splatting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Comparison of edge splatting, MC, MC with adaptive subdivision, and the edge kernel method with per-point and per-pixel shading of the Cello data under a closeup view. For the MC with adaptive subdivision, MC is applied after the active cells are adaptively subdivided until all the triangle projections on the image plane are within 10 pixel size.to subdividing the cell into k × k × k sub-cells, and forming an edge by combining every k sub-edges that are on the same line. These 3k 2 edges are classified into three groups according to their orientations: X-oriented edges, which start from x = 0 face and finish on x = 1 face. Y -oriented and Z oriented edges are defined similarly. Each edge is represented by three values: &lt; c, s,t &gt;, where c is the edge orientation, and (s,t) is the local coordinate of the edge endpoint on the starting face (the local coordinate on the finishing face is the same). Thus, an edge kernel E k is:E k = {&lt; c, s,t &gt; |c = 0, 1, 2; s,t = 0, 1/k, 2/k,..(k − 1)/k} (2)where c = 0, 1, 2 denote X-oriented, Y -oriented and Z-oriented, respectively.For each active cell with center position p c , an edge kernel E k is applied to generate adequate number of sampled points. The edge kernel size k is determined by the number of pixels covered by the cell (k = ceil(S(p c ))). If an edge in E k intersects with the isosurface, the intersection point is computed by interpolation. For example,Fig. 4 shows an edge &lt; 0, 2/3, 1/3 &gt; which starts on x = 0 face and ends on x = 1 face. v s and v f are the values associated with the endpoints of the edge, bilinearly interpolated from the corresponding voxel values using the local coordinate (2/3, 1/3). If the isovalue v is inside the interval [v s , v f ], this edge intersects with the isosurface. The local coordinates of the intersection point p i inside the cell are (2/3, 1/3, w), where:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Edge kernels with size 1, 2 and 3, respectively. The number of edges in an edge kernel with size k is 3k 2 . These edges are classified into three groups according to the edge orientation. The edges with different orientations are shown in different colors (red, green and blue).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>p i is the intersection between edge &lt; 0,2/3,1/3 &gt; and the isosurface. v s and v f are the values associated with the endpoints of the edge, which are the bilinear interpolations of the corresponding voxel values. If the isovalue v is between v s and v f , p i is found by interpolating along the edge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Isosurfaces from edge splatting, Marching Cubes, and the edge kernel method. Two individual active cells are shown in (a) to (f). In (g) and (h), the isosurfaces inside two neighboring active cells are depicted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Isosurfaces from CT Head (first row) and Foot (second row) data. (a) and (b): isovalue=840; (c) and (d): isovalue=1405; (e) to (g): isovalue=36; (h) and (i): a closeup view of isovalue=70, rendered by ESE and the edge kernel method (EK), respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Haitao Zhang and Arie Kaufman are with Stony Brook University, E-mail: haitao,ari@cs.sunysb.edu.</figDesc><table /><note>Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Experiment data size, edge data structure size, creation time with corresponding exploration range.</figDesc><table><row><cell>Volume Data</cell><cell>Size</cell><cell>Exploration Isovalue Range</cell><cell>Total Cells</cell><cell>Total Stored Edges</cell><cell>Stored Edge Percentage</cell><cell>Edge Data Structure Creation Time (s)</cell></row><row><cell>CT Head</cell><cell>256 × 256 × 226 (12-bit)</cell><cell>200-4095</cell><cell>5,444,366</cell><cell>14,831,403</cell><cell>30%</cell><cell>6.4</cell></row><row><cell>Foot</cell><cell>128 × 128 × 128 (8-bit)</cell><cell>0-255</cell><cell>658,399</cell><cell>1,069,804</cell><cell>17%</cell><cell>0.4</cell></row><row><cell>Head MRT Angiography</cell><cell>416 × 512 × 112 (10-bit)</cell><cell>20-1023</cell><cell>2,063,817</cell><cell>2,954,384</cell><cell>4%</cell><cell>3.5</cell></row><row><cell>(a) ESS (162 fps)</cell><cell cols="2">(b) ESE (19.1 fps)</cell><cell cols="2">(c) ESS (135 fps)</cell><cell cols="2">(d) ESE (15.2 fps)</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>The active cell and active edge counts, rendering frame rate (fps) with certain isovalues for edge splatting.</figDesc><table><row><cell>Volume Data</cell><cell>Isovalue</cell><cell>Active Cells</cell><cell>Active Edges</cell><cell cols="2">Frame Rate ESS ESE</cell></row><row><cell>CT Head</cell><cell>840 1405</cell><cell>385,470 422,244</cell><cell>388,754 426,749</cell><cell>162 135</cell><cell>19.1 15.2</cell></row><row><cell>Foot</cell><cell>36 70</cell><cell>32,504 32,248</cell><cell>33,534 34,990</cell><cell>641 458</cell><cell>133 96.8</cell></row><row><cell>Head MRT</cell><cell>142</cell><cell>592,982</cell><cell>600,928</cell><cell>168</cell><cell>47.5</cell></row><row><cell>Angiography</cell><cell>183</cell><cell>138,864</cell><cell>138,013</cell><cell>641</cell><cell>123</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This work has been partially supported by NSF grant CCR-0306438. The CT Head, Foot, and Head MRT Angiography data are courtesy of University of North Carolina, the Visible Human Project, and Institute for Neuroradiology, German, respectively.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">High-quality surface splatting on today&apos;s GPUs. Symposium on Point-Based Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hornung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zwicker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">High-quality point-based rendering on modern GPUs. Pacific Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="335" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spernat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<title level="m">Phong splatting. Symposium on Point-Based Graphics</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient high quality rendering of point sampled geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wiratanaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics Workshop on Rendering</title>
		<imprint>
			<biblScope unit="page" from="53" to="64" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Speeding up isosurface extraction using interval trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="170" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Two algorithms for the three-dimenstional reconstruction of tomograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorenson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ludke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Teeter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Medical Physics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="320" to="327" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Iso-splatting: A point-based alternative to isosurface visualization. Pacific Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="325" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Meshless isosurface generation from multiblock data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Porumbescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE-TCVG Symposium on Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="273" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Using distance maps for accurate surface reconstruction in sampled volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gibson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Symposium on</title>
		<imprint>
			<biblScope unit="volume">Visualization</biblScope>
			<biblScope unit="page" from="23" to="30" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Deferred splatting. Eurographics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Guennebaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Paulin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="653" to="660" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Interpolatory refinement for real-time processing of point-based geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Guennebaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Paulin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics</title>
		<imprint>
			<biblScope unit="page" from="657" to="666" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Real-time ray-casting and advanced shading of discrete isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Scharsach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bühler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics</title>
		<imprint>
			<biblScope unit="page" from="303" to="312" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dual contouring of hermite data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Losasso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH</title>
		<imprint>
			<biblScope unit="page" from="339" to="346" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Featuresensitive surface extraction from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">P</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Schwanecke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH</title>
		<imprint>
			<biblScope unit="page" from="57" to="66" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Improving progressive view-dependent isosurface propagation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="218" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">View dependent isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Visualization</title>
		<imprint>
			<biblScope unit="page" from="175" to="180" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using the span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="84" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Interactive point-based isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tricoche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Visualization</title>
		<imprint>
			<biblScope unit="page" from="457" to="464" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Marching cubes: A high resolution 3D surface construction algorithm. SIGGRAPH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for isosurface rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-P</forename><surname>Sloan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Visualization</title>
		<imprint>
			<biblScope unit="page" from="233" to="238" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zwicker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">V</forename><surname>Baar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<title level="m">Surfels: Surface elements as rendering primitives. SIGGRAPH</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="335" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Object space EWA surface splatting: A hardware accelerated approach to high quality point rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zwicker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics</title>
		<imprint>
			<biblScope unit="page" from="461" to="470" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<title level="m">QSplat: A multiresolution point rendering system for large meshes. SIGGRAPH</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="343" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Isosurfacing in span space with utmost efficiency (ISSUE)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="287" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient point-based isosurface exploration using the span-triangle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">V</forename><surname>Rymon-Lipinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Hanssen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ritter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Keeve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Visualization</title>
		<imprint>
			<biblScope unit="page" from="441" to="448" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Isosurface extraction using fixedsized buckets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">W</forename><surname>Waters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE-VGTC Symposium on Visualization</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="207" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
		<title level="m">Efficiently using graphics hardware in volume rendering applications. SIGGRAPH</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="169" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zwicker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Baar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<title level="m">Surface splatting. SIGGRAPH</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="371" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Perspective accurate splatting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zwicker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rásánen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dachsbacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pauly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
