<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Data Servers for Large Multivariate Volume Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Student Member, IEEE</roleName><forename type="first">Markus</forename><surname>Glatter</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Colin</forename><surname>Mollenhour</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Jian</forename><surname>Huang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Jinzhu</forename><surname>Gao</surname></persName>
						</author>
						<title level="a" type="main">Scalable Data Servers for Large Multivariate Volume Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Parallel and distributed volume visualization</term>
					<term>large Data Set Visualization</term>
					<term>multi-variate Visualization</term>
					<term>volume Visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Volumetric datasets with multiple variables on each voxel over multiple time steps are often complex, especially when considering the exponentially large attribute space formed by the variables in combination with the spatial and temporal dimensions. It is intuitive, practical, and thus often desirable, to interactively select a subset of the data from within that high-dimensional value space for efficient visualization. This approach is straightforward to implement if the dataset is small enough to be stored entirely in-core. However, to handle datasets sized at hundreds of gigabytes and beyond, this simplistic approach becomes infeasible and thus, more sophisticated solutions are needed. In this work, we developed a system that supports efficient visualization of an arbitrary subset, selected by range-queries, of a large multivariate time-varying dataset. By employing specialized data structures and schemes of data distribution, our system can leverage a large number of networked computers as parallel data servers, and guarantees a near optimal load-balance. We demonstrate our system of scalable data servers using two large time-varying simulation datasets.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Today's scientific research frequently involves large datasets that are hundreds of gigabytes or more. In order for visualization to adequately handle datasets of that scale, techniques targeting specific applications are often needed. In this work, we would like to focus on large multivariate volume visualization, in which the variables may either come directly from the simulation or be subsequently derived from the simulated variables. This application is important due to its utility to basic scientific research. It is also interesting because it brings forth a grand challenge for today's computing infrastructure.</p><p>The community already faces a growing disparity between the available bandwidth in the computing infrastructure and the total amount of data to be processed for visualization. Introducing k variables on each voxel further exacerbates the disparity by a linear factor of k. As a real-world example, a recent astrophysics simulation of supernova generates a 300 time step dataset of a spatial resolution of 864 <ref type="bibr" target="#b2">3</ref> . This size is already considered large by current standards. However, with research questions of significance in astrophysics simultaneously involving variables such as velocity, tangential velocity, angular momentum, entropy, and various derivatives of those variables, there are indeed few existing systems that can adequately support the ensuing visualization needs.</p><p>In designing our system, we leverage two basic approaches: parallelism and data culling. To handle datasets on the scale of hundreds of gigabytes, parallelism with excellent scalability seems to be the most plausible approach. In addition, our undertaking aims to intelligently reduce the required amount of data processing and be able to do so as early during the visualization pipeline as possible, i.e. effective data culling.</p><p>Our main design concept is to develop parallel data culling on the granularity of individual voxels. The data culling process is driven by compound boolean queries. Very recently, researchers have demonstrated the great potential of this design and reported early successes in using compound queries in the context of multivariate volume visualization <ref type="bibr" target="#b19">[20]</ref>. However, they have not yet extended their system to operate in parallel and handle very large datasets.</p><p>We explore methods to use a large number of networked but independent computers as parallel data servers to support efficient visualization, with two conceptual steps: (i) a selection module in the form of compound boolean range queries to cull unnecessary data processing early in the visualization pipeline and (ii) any visualization approach to finally render the relevant voxels.</p><p>After all voxels relevant to specified queries have been "selected" through parallel data culling, there could be several potential ways to visualize or render the selected voxel data. As an example, we have implemented hardware accelerated splatting <ref type="bibr" target="#b5">[6]</ref> with a procedural transfer function module and parallel coordinate visualization <ref type="bibr" target="#b22">[23]</ref>. Both techniques, in their classic forms, had difficulty dealing directly with large datasets. Other uses of our scalable parallel data servers could include, for instance, support for procedurally defined highdimensional transfer functions, first proposed by Kniss et. al. <ref type="bibr" target="#b9">[10]</ref>. In that context, we could easily adapt our system to handle procedural Gaussian transfer functions. All that is needed is to add a selection step to query all voxels in the rectangular domain of each high-dimensional Gaussian function and then use the Gaussian functions to assign color and opacity to voxels on the fly.</p><p>As for the actual data management, the entire dataset is distributed among all data servers according to space filling curve order in the high-dimensional attribute space. Load-balancing among data servers can be achieved, independent of the types of compound boolean range queries. Each data server leverages a data structure similar to B-tree to maintain all voxels distributed to it. As a result, we achieve a very compact structure of meta data (usually less than 0.5% in size, as compared to the size of the entire dataset). A client can query the data servers and receive queried results over the network. We refer to the selected voxels as relevant voxels. Regardless of dataset size and query type, we achieve a query rate of 4.2 million relevant voxels/second across a local area network.</p><p>Since our focus here is to handle large multivariate data, the main results presented are from visualizing the supernova simulation we described earlier. Specifically, our visualization runs involve eleven variables per voxel, with 864 × 864 × 864 spatial resolution, over 6 time steps. The entire set used is over 100 GB in size. In order to demonstrate that the scalability of our system is not dataset-sensitive, we also included results obtained from a 1024 × 1024 × 960 version of the well-known Richtmyer-Mevhkov Instability (RMI) simulation done at Lawrence Livermore National Lab.</p><p>We discuss previous works in Section 2 and then present our system in Section 3. In Section 4 we describe the deployment requirements of our system, followed by our testing results. We conclude with a discussion of future work in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>Query-driven data visualization is still a relatively new approach in visualization research, yet much potential has already been demonstrated with this approach <ref type="bibr" target="#b19">[20]</ref> for the intuitive interface it offers for facilitating understanding of complex multivariate datasets. In an effort to handle larger datasets in parallel, we find previous works in volume rendering (particularly sparse volume rendering), parallelism and search data structures most relevant to our research. We now summarize those works below.</p><p>Volume rendering has been widely studied, primarily targeting datasets with a single scalar variable. To date, a variety of algorithms have been proposed to render a volume, including raycasting <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22]</ref>, splatting <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b14">15]</ref>, 3D texture hardware based rendering <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">8]</ref> and shearwarp <ref type="bibr" target="#b10">[11]</ref>. Among those, ray-casting, splatting and 3D texture based rendering offer the best rendering quality, with each being most efficient for specific scenarios <ref type="bibr" target="#b13">[14]</ref>.</p><p>Splatting is most efficient when only a sparse subset of an entire dataset is non-transparent. This is advantageous for all applications that are primarily concerned with features composed of interval volumes as shown in <ref type="bibr" target="#b7">[8]</ref>. Unfortunately, a shortcoming with previous splatting algorithms stems from its lack of well-studied methods to dynamically construct the sparse volume on the fly, which hinders its application in volume rendering systems requiring dynamic user interactions. However, with the support of advanced query-based techniques like the ones demonstrated by Stockinger et. al. in <ref type="bibr" target="#b19">[20]</ref> and our work presented here, splatting is an ideal front-end renderer to run on client machines.</p><p>In order to handle large datasets efficiently, parallelism is indispensable. Many previous researchers in parallel visualization resorted to partitioning large datasets into volume blocks or bricks; a block is the finest level of granularity of parallel I/O <ref type="bibr" target="#b24">[25]</ref>, parallel rendering <ref type="bibr" target="#b8">[9]</ref>, data culling <ref type="bibr" target="#b3">[4]</ref> and multi-resolution data management <ref type="bibr" target="#b17">[18]</ref>. Although block-based data organization has already significantly improved memory efficiency when handling large data, we have found that for our system, using blocks as a unit of data processing can still be too expensive. In this paper, we address this issue by delivering only the voxels relevant to a user-input query on the fly. Due to this, we choose to use hardware accelerated splatting instead of 3D texture-memory based rendering techniques. After all, the size of texture memory on today's graphics boards is still quite limited.</p><p>Although few previous works have focused on interactive volume rendering of datasets having 8 to 10 variables, efficient searching within a two-variable space formed by the min/max values of each voxel cell has been well studied and used predominantly to accelerate isosurface extraction. Near optimal performance can be achieved with methods such as span space, interval tree, extremal graph <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b6">7]</ref>, etc. While these methods can be efficient in execution time, the storage needs incurred is often high. For instance, as reported in <ref type="bibr" target="#b2">[3]</ref>, an interval tree may require 4 times the storage of the scalar volume itself.</p><p>These widely used data structures are predominately based on the binary tree and its extensions to spatial and temporal dimensions. Examples include interval tree <ref type="bibr" target="#b2">[3]</ref>, k-d tree, quad-tree, octree <ref type="bibr" target="#b16">[17]</ref>, branch-on-demand octree <ref type="bibr" target="#b20">[21]</ref>, etc. The binary tree has been favorable for reasons including: (i) simplicity and (ii) optimal asymptotic performance while balanced. Unfortunately, the storage overhead is a major technical hurdle against its use for handling large numbers of attributes. For instance, in the case of 10 attributes, to perform a binary partition in all dimensions, there are 2 <ref type="bibr" target="#b9">10</ref> cases. The total storage for the pointers to the 2 10 cases increases exponentially as the depth of the tree increases. This occurs whether these partitions are simultaneous, as in the case of octree for three dimensions, or interleaved, as with k-d tree. Given that each pointer requires four bytes of memory, any 32-bit computer will be overwhelmed by a tree of depth three. In addition, with a tree of such complexity, balancing the entire tree would be a grand challenge. But without a balanced tree, optimal performance cannot be guaranteed. Thus it is not feasible to use a binary tree based data structure in our system.</p><p>Methods that are not based on trees to accelerate searches have also been proposed, such as bitmap indexing used in <ref type="bibr" target="#b19">[20]</ref>. However, the use of bitmap indexing in visualization is still relatively new, has not yet been extended to operate in parallel, and seems to work best if the complete dataset as well as the meta data used for searching fits entirely within main memory.</p><p>In this work we design a parallel system configuration and a spaceefficient server-side data structure to support parallel multi-variate data visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OUR SYSTEM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design Considerations</head><p>Large, multivariate, time-varying datasets sized at hundreds of gigabytes are increasingly common. Such datasets are too large to be held in a single machine's main memory on most computers. Since the transfer rates offered by local disk storage are considerably slower than today's high speed networks, it is often advantageous to stream data from networked data servers which hold a portion of a large dataset in main memory for fast data retrieval.</p><p>We present a scalable system of parallel data servers that provide efficient parallel data culling on large quantities of data. In our system, the data is distributed among a system of parallel data servers, each of which holds a part of the data in main memory. The system achieves high throughput by employing specialized, efficient data structures and load-balancing schemes on the server side. The user's queries to the servers consist of compound boolean range queries where multiple ranges can be defined per data variable. Please note that time and spatial coordinates of voxels are not treated differently from other attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Data Distribution and Preprocessing</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Attribute-Space Hilbert Curve</head><p>For our system, we chose individual voxels to be the targeted level of granularity. A voxel is identified by its attributes. These attributes include all the variables, such as density or entropy, on the voxel as well as the time step t and coordinates (x, y, z) of the voxel. In any dataset, no two voxels will have all of the attributes being exactly the same, because (x, y, z,t) already uniquely identifies a voxel. However, voxels with a subset of attributes being of the same values would still be common.</p><p>All attributes are stored as unsigned shorts through a binning process, or quantization, process. This allows 2 <ref type="bibr" target="#b15">16</ref> different bins for each attribute. Thus, data with a precision of 16 bits or lower can be converted without a loss of precision, while data with a greater precision will have to be scaled to match the range of the unsigned short datatype.</p><p>Our system could easily switch to use unsigned integer as the precision of the binning process. However, we have found 16-bit fixed point precision to be sufficient for most scenarios. With 11 attributes (i.e. 7 simulated or later derived variables, 3 spatial coordinates and 1 time step id), a voxel is referred to as a data item, which requires 22 bytes of storage.</p><p>A selection is composed of compound boolean range queries and constitutes specific criteria for data culling. Each range corresponds to a particular attribute of interest. To process a "selection", we must quickly search for voxels with the corresponding attributes within the specified ranges. To do so, all data items residing on a server are sorted by each voxels attributes, with the first attribute being the most significant value, and each following attribute being less significant than its predecessor. For instance, a data item with three attributes (1, 2, 3) is sorted in front of a data item containing (1, 2, 4), but behind a data item (1, 1, 2). Upon sorting, all data items are indexed by a search data structure similar to B-tree.</p><p>The storage overhead of the search structure is typically only a very small fraction, e.g. 0.5%, of the entire dataset's storage space. This storage need is, however, independent on the dataset's size. (see 3.3 for details). By making use of this adapted data structure we achieve very low overhead during searching and data culling, so that both querying and visualization are greatly accelerated.</p><p>A straightforward way to distribute data items to parallel data servers is to do so randomly. However, randomness does not necessarily ensure good load-balancing in all scenarios. Since a selection is most likely to query for data items with similar values, we would like the data items' distribution to satisfy the following requirement: If the attributed values of two data items do not differ significantly, they should be distributed on different servers.</p><p>This heuristic implies that data items adjacent to each other in the attribute space should be distributed to different servers. We implement this heuristic by traversing the attribute space in a localitypreserving manner, and apply a round-robin distribution scheme during the traversal. This way, we minimize the problem of data items with similar attribute values "piling up" on a few servers.</p><p>In particular, we traverse the high dimensional space by discrete Hilbert space-filling curve, which comes close to achieving optimal locality <ref type="bibr" target="#b4">[5]</ref>. As demonstrated in <ref type="bibr" target="#b15">[16]</ref>, the great locality of Hilbert space-filling curves can indeed be leveraged to achieve great performance when handling a high-dimensional space in visualization.</p><p>A traversal along Hilbert curve can be considered as mapping, or serializing, k-dimensional vectors of integer values into a 1-D space. Here k is the number of attributes per voxel (including time step, spatial dimensions, and all original and derived data attributes). Assuming 16-bit precision per attribute, such a Hilbert curve will be of an exponential length (2 16 k ), i.e. (65536 k ). For practical reasons, instead of traversing through such a long curve, we sort all data items using the inverse function of Hilbert curve, which computes the order on the Hilbert space-filling curve between any two data items. This sorting step must be implemented as an external algorithm due to the large quantity of data involved.</p><p>Because the Hilbert curve only comes close to optimal locality, it would be hard to prove that our data distribution scheme based on Hilbert curve in k-dimensional attribute space is optimal. However, as we will show in <ref type="table" target="#tab_0">Table 1 (Section 4.</ref>3), our data distribution method manages to achieve a close approximation to a perfectly load-balanced system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Data Preprocessing</head><p>In addition to computing attributes in parallel, there are more time consuming tasks to prepare a large multi-variate data visualization. Particularly, in our system it is a time-consuming process to organize data, originally indexed by temporal and spatial coordinates, according to order in attribute space. For hundreds of gigabytes of data, external sort algorithms implemented on hard-drives still can not offer sufficient performance.</p><p>In our system, we preprocess the input data utilizing a group of networked computers in parallel. In fact, it is exactly the same set of networked computers that will later be used as the parallel data servers. From this perspective, the external mergesort is computed in situ.</p><p>As illustrated in <ref type="figure" target="#fig_1">Figure 1</ref>, (1) the dataset is initially partitioned and stored on the file system as spatial blocks arranged according to time steps. <ref type="formula">2</ref>We then distribute the volume blocks to all networked computers in a round-robin fashion. (3) Each computer then locally computes all derived attributes (e.g. gradients, etc.) and sorts all data items it has into Hilbert curve order. At the end of this process, each computer, C i , holds a different linear list of sorted data items.</p><p>After each data server is ready, (4) the client machine, acting as the orchestrator of an external mergesort, requests the first 32 MB from the linear list stored on each networked computer. <ref type="formula">5</ref>The client machine then starts an internal mergesort. <ref type="formula">6</ref>The resulting sorted list is then re-distributed in a round-robin fashion to all the networked computers. All network communication is buffered, in order to reduce overhead of small messages. There is a separate 32MB buffer on the client for each networked computer.</p><p>Operations 4, 5 and 6 take place concurrently on all computers. After those three operations complete, each networked computer will have received an equal share of the entire dataset. <ref type="formula">7</ref>Each of these computers will then act as a data server. The data items are then organized locally on each server using a our special search data structure (detailed in Section 3.3). No additional data movement is necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Server-side Data Structure</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Design Goals</head><p>After each data server has received its portion of the data, an efficient data structure is needed to maintain those data items. A selection request, or data culling (the inverse of selection), is formally specified by</p><formula xml:id="formula_0">{∀x|lb(i) ≤ x(i) ≤ ub(i), i ∈ [0, k − 1] ⊂ N}</formula><p>Here lb and ub are the lower and upper bounds for each attribute, respectively. k is the number of attributes in each data item. We would like to support scenarios where k ≥ 5, using a space-efficient data structure while offering fast runtime performance. In addition, we would like the performance to be dependent on the number of relevant voxels, but independent of the size of the entire dataset. This property would be greatly advantageous since visualization algorithms usually focus on iso-ranges or intervals based on different variables. Such is the case with isosurface extraction and volume rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Design of Data Structure</head><p>Our primary design concept is to use an M-ary balanced search tree of depth N. A practical combination could be M = 256 and N = 3; in all situations, M should always be significantly larger than N. This is one of the primary differences between this search data structure and previous data structures, such as interval tree, k-d tree, quadtree and octree.</p><p>The M-ary search tree ( <ref type="figure" target="#fig_2">Figure 2</ref>) is a classic concept which we have adapted for use in multivariate visualization. In the tree, each tree node contains a list of keys and pointers to its children. From the list of keys stored in a tree node, the child containing a given target search key can be quickly identified. The M-ary tree provides meta data to guide a search process. Due to the large branching factor, M, the Mary search tree requires little storage space. Actual data items are not stored in the tree, but in a linear list sorted by a key function, described in Section 3.3.3. The leaf nodes of the tree only store pointers to the respective records in a sorted linear list.</p><p>M-ary search trees, like binary search trees, have been used in other disciplines. The most noteworthy example is B-trees used frequently in database systems. Our use of the M-ary search trees has several unique aspects <ref type="bibr" target="#b23">[24]</ref>. First, most disciplines use search trees in situations where records are dynamically inserted and deleted, requiring complex operations to keep the entire search tree balanced. The overhead of operations such as tree node adoption, rotation, etc., are fairly significant. Fortunately, with multivariate visualization, runtime insertion and deletion are not often necessary. Therefore, our algorithms for tree construction and maintenance are simpler and handle gigabyte sized volume data more efficiently. Second, we have discovered that conventional methods for record access by traversing the tree are too expensive, both in terms of the large number of addressing operations and caching performance. To address this, we use a novel method to accelerate range searches in an M-ary tree for assistance (detailed in Section 3.4.1), optimized specifically for multivariate datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Tree Construction</head><p>While general methods for mapping arbitrary multi-field records to a single numeric key do not exist, it is quite straightforward when dealing with multivariate visualization data that has been quantized. We avoid using scalar valued hash functions to obtain keys; rather, we directly use attributes of each data item as the "key function". This allows a much larger range of possible keys than using only single scalar values as the key. To determine the order between two compound keys, attribute a 0 is the most significant, while a k−1 is the least significant.</p><p>For any given dataset, the tree is a static data structure that can be pre-computed in a one-time preprocessing step. After each data server has received all data items, we compute the key for each voxel and sort the data items into an array based on the key. On a typical 2.8 GHz P4 processor, quicksort, as part of the standard C library can finish sorting 32 million voxels within 40 seconds. This overhead as a onetime preprocessing cost is quite reasonable.</p><p>From the sorted list, we can efficiently construct the tree. Given a combination of M and N values, the total number, T n , of leaf nodes is equal to M N . In the case of M = 256, N = 3, T n is 16 million. Then, the average number of voxels to be stored in each leaf node, to ensure a balanced tree, can be conveniently obtained as 1/T n of the whole set of data items.</p><p>In <ref type="figure" target="#fig_2">Figure 2</ref>, a tree of M = 6, N = 1 is illustrated, with the sorted array of data items shown at the bottom. The array is partitioned into M N consecutive runs. The data item separating two neighboring runs is then used as the key in the corresponding leaf node. For instance, the run started by element v j should have elements with keys valued between k 2 and k 3 . v j should be the data item with the smallest key larger than k 2 , while v k has the smallest key larger than k 5 . In a bottomup fashion, we sequentially build the leaf nodes in left to right order and recursively fill in key values in intermediate nodes based on the range of key values within each child node.</p><p>Our experiments on the tradeoff between search performance and storage overhead have shown that keeping the number of data items pointed to by a leaf node on the order of 10 to 100 is close to optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Query Handling and Complexity of Query 3.4.1 Server Side Query Handling</head><p>Traditionally, one accesses all entries in a search tree by first referencing the root node. While this might be sufficient for querying single items, we have found this conventional approach to be quite expensive for querying many relevant voxels from a large dataset at the same time. A large portion of the incurred overhead is due to addressing operations and cache misses during tree traversal.</p><p>To achieve maximal performance, we designed a special scheme to search through the M-ary tree. At the core of the entire process, we use a multi-digit counter with a carrying mechanism. For instance, we illustrate k attributes in <ref type="figure" target="#fig_3">(Figure 3)</ref>. The 1 st attribute is the most significant, and the k th is the least significant. For each attribute a range is specified, shown as the non-empty region in each column. The  bottom of <ref type="figure" target="#fig_3">Figure 3</ref> is the same array of sorted data items in <ref type="figure" target="#fig_2">Figure 2</ref>. In the array, the leftmost data item has the lowest key value, and the values of compound keys monotonically increase from left to right.</p><p>In the attribute space, the query is specified by the lower bound, lb i , and upper bound ub i . From the first (leftmost) element of the array, we search for data items meeting the compound query. Specifically, we start by searching for the lower bound lb i in the M-ary tree. The first set of relevant voxels should correspond to a consecutive run, e.g. run A in <ref type="figure" target="#fig_3">Figure 3</ref>. We traverse run A until we encounter a voxel with its compound key a i falling out of the specified range. To determine which data item to search next, we use the method described in <ref type="figure" target="#fig_4">Figure 4</ref> to increase the key a i "back into" the specified range via a "carrying" mechanism.</p><p>We note here that the resulting key, a i , may or may not exist in the data. But we search for it in the M-ary tree regardless. If the key a i does exist, the M-ary tree will identify its location in the array, and provide the starting point of the next consecutive run of relevant voxels, e.g. run B in <ref type="figure" target="#fig_3">Figure 3</ref>, meeting the boolean query. If not, the M-ary tree points to the next immediate data item with a compound key larger than a i . We then repeat the above process to know whether or not this data item is in the bound. The entire process is iterative until the whole dataset has been searched.</p><p>In essence, our search mechanism performs a linear search on the sorted voxel list, and uses the M-ary tree only to skip voxels that are out of the specified range. While traversing a linear list in contiguous blocks is efficient, the M-ary tree also provides great cache coherence, because of its compact size and shallow tree-depth. In contrast, traditional tree traversal may incur a much higher overhead. Without know-ing a priori how many data items would exist in a range, or whether such data items exist at all, one would need to make an overwhelming ∏ k−1 i=0 r i number of individual queries, where r i is the size of the range of a i .</p><p>As a side note, the pseudo code described in <ref type="figure" target="#fig_4">Figure 4</ref> can be adapted to handle floating point data. All that is needed is to set the "carry" variable to the smallest unit of floating point in the dataset. Finally, if a user is solely querying the last attribute, a k−1 , those runs shown in <ref type="figure" target="#fig_3">Figure 3</ref> could contain as few as just one voxel. This will cause each search in the M-ary tree to generate just one data item, and thus reduce efficiency. Fortunately, by leveraging user's domain knowledge and putting attributes queried less often as the last few attributes in our system, efficiency of the system can generally be maintained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Query Handling on Client Side</head><p>A user query consists of compound boolean range queries entered via an interactive user interface on the client side. The client then simultaneously sends request to all data servers which send the query results back to the client upon data retrieval. During the data retrieval process on the server side, the data items are further reduced in size by simply sending only data parts necessary to render the current query on the client. For example, if the client's transfer function only uses a single value from the data item to determine color and opacity of a voxel, then only that will be sent, along with the inevitable spatial coordinates and first degree gradients. This reduces the data to be sent over the network to little more than 10 bytes per voxel. After the client has gathered all incoming data, it can then use any volume visualization approach, e.g. splatting, to display the result to the user. Additionally, queries will be cached locally at the client, so that recurrent requests can be dealt with locally by obtaining the data from the cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">The Communication Interface</head><p>The server/ client interface has been designed to keep communication overhead low by using several different protocols depending on what information needs to be communicated.</p><p>In our system, a server opens a TCP port and starts listening for a client to connect to it. Upon establishing a connection, the first few bytes sent by the client indicate what kind of task it needs the server to perform. The server refers to its look-up table of functions to find the appropriate component and hands over control to it. From that moment on, the client communicates with the appropriate component directly. Different components implement different protocols where needed. For instance, the "QUERY" component, responsible for retrieving the data matching a client's query, sends back most of its data as a plain memory copy of what it finds in the server's data storage. There is no need for additional tags or other overhead as the client agreed upon the selected protocol by calling that particular server function.</p><p>This interface design has another advantage. As the actual core of the server simply decides what component needs to be activated, it can fork off a process to run the component and close the socket right away. This enables the server to handle multiple connections simultaneously, e.g. for the use of multi-display devices, where more than one client needs to connect to a server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SYSTEM DEPLOYMENT AND RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Deployment / Requirements</head><p>Our system is relatively easy to deploy on networked commodity computers, whether part of a cluster or not. One computer will function as a rendering client, and the rest as data servers. The necessary number of parallel data servers depends on the size of the dataset. As long as more computers are available to serve as data servers, our system could be scaled to handle larger and larger datasets.</p><p>However, we do have a couple minimal requirements if interactive visualization is desired. First, all data servers combined must have enough main memory to hold the entire preprocessed data in-core. Our system is still operable without meeting this requirement, however, the additional out-of-core overhead incurred by each data server would hamper the query performance. Second, the client machine should be able to hold the queried data in-core locally. In fact, any standard PC with 2GB of memory easily meets this requirement for most practical queries. Our client software also includes a cache to avoiding retransmission of recurrent requests. Even with the cache resident in memory on the rendering client, most queries in our experiment still did not exceed the limit of local memory.</p><p>In all experiments, our data servers and the rendering client are commodity computers of the same configuration (Dual AMD Opteron 1.6 GHz, 2GB RAM), connected by a Quadrics Elan3 network offering a theoretical single-direction bandwidth of 400MB per second. No additional special hardware or software was used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Datasets and Pre-Processing</head><p>Our system has made it feasible to examine more variables interactively within the same framework than previously possible. For experimental evaluation, we use two datasets: the TSI dataset and the RMI dataset.</p><p>The TSI dataset is the main testing dataset, since it is inherently multivariate, with time-varying density, pressure, and flow velocity simulated on each voxel. The spatial resolution is 864 × 864 × 864. In astrophysics research, density and pressure are often converted to a more useful variable, entropy. Besides commonly-used attributes such as gradients of various degrees, application scientists are also interested in tangential velocity and angular momentum. The angular momentum with respect to a chosen origin for a given vector field (denoting velocity and direction of velocity) is given by L = v × r, at every point where r is denoting the vector from the chosen origin to the current point, and v is the vector from the velocity field.</p><p>In our experiments, there are 11 attributes visualized for the TSI dataset: time step id, entropy, magnitudes of tangential velocity, angular momentum gradient, entropy gradient, first derivative of entropy in x-, y-, and z-directions, and x, y and z coordinates. This is also the order (significance) of the attributes, when the server side M-ary tree is constructed, with entropy being the most significant. The spatial and temporal coordinates are needed, because application scientists routinely do clipped or cut-away views of their data. Our tests used six time steps of the TSI dataset totaling 105GB of data.</p><p>The most expensive overhead incurred during data preprocessing (3.2.2) is not to construct the search data structure, but actually to compute and coalesce the attributes of a volume partition into one common file, with each voxel stored in 22 contiguous bytes (11 attributes). This step is a one-time process which takes 5 to 8 hours in our experiments, since some computation needs to take place outof-core. Nonetheless, this step could be significantly accelerated with more sophisticated parallel computing software, which is out of scope for our research.</p><p>The one-time process that distributes the whole dataset onto multiple, e.g. 20, parallel servers is the sort in Hilbert curve order and the construction of the M-ary tree <ref type="figure" target="#fig_1">(Figure 1</ref>), which only takes about 2 hours.</p><p>For scalability experiments, we have also used 3 time steps of the larger RMI simulation data. However, since the RMI data only contains a single variable, it is not the ideal dataset for multivariate visualization. We use this data strictly for scalability evaluation. The version of RMI data we used is of 1024 × 1024 × 960 spatial resolution. Again, we included 11 attributes in the following order: time step id, density (the original variable in the dataset), correlation between directly neighboring voxels in the +z direction, correlation between voxels that are one voxel apart in the +z direction, norm of density gradient, first derivative of density in x-, y-, and z-directions, and x, y and z coordinates.</p><p>Although it is well-known that the RMI dataset is highly turbulent, we were able to find some rather interesting views of the dataset <ref type="figure">Figure 5</ref>. Rendering results of the TSI dataset is provided in Section 4.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Timing Results</head><p>After preprocessing, including binning and discarding uninteresting voxels such as empty space, we end up with about 20GB of data items with the TSI dataset. We experimented with the TSI dataset using <ref type="figure">Fig. 5</ref>. Two imagery results of RMI dataset. The top 3% range of density, with RGB channels of transfer function modulated by (left) correlation between directly neighboring voxels and (right) density gradient in ydirection. In both views, a query selects a single time step, which is then clipped to a slab with x-coordinate between 0 ∼ 140. configurations of 20, 30 and 40 data servers, respectively. With the 20-server configuration, each server holds roughly 980MB of data in memory. In 30-and 40-server configurations, that in-core amount of data decreases to 653MB and 490MB, accordingly.</p><p>The RMI dataset is larger and also has a much smaller portion of data constituting empty space. After preprocessing, each of 40 servers still holds about 1.6GB of data. For that reason, we did not have scalability results of the RMI data using 20-or 30-server configuration.</p><p>Running queries locally on a single data server, we are able to retrieve between 4 and 13 million data items per second. The variance is caused by the significance levels of the attributes when the M-ary tree is constructed. If a user primarily queries on the least significant (the last) attribute, 4 million data items is the maximal rate. When the most significant attributes are targeted, the rate of data retrieval increases to 13 million data items per second.</p><p>We have found in the parallel system, however, that the network is the bottleneck regardless of which attributes are being queried (see <ref type="figure">Figure 6</ref>). Due to the balanced workload among servers (shown in <ref type="table" target="#tab_0">Table 1</ref>), the total local querying capability amounts to 80 ∼ 260, 120 ∼ 390, and 160 ∼ 520 million data items per second, with 20, 30 and 40 data servers operating in parallel, respectively. Generally, the local query time accounts for only a fraction of the total latency, even if a server has to search through more than 1.5GB of data to find voxels matching the query.</p><p>When a query only results in a small number of relevant voxels, smaller messages are sent across the network, thus a generally lower level of performance is obtained. As the size of queries increases, the obtained query rate approaches 9 million data items per second, which corresponds to a 144 MB/sec sustained bandwidth on the network (only 16 of the 22 bytes are transmitted per data item, see 3.4.2), which is considerably less than the local query rate. Thus, the network transfer time accounts for most of the total latency.</p><p>In a separate experiment, we have run the same test using a standard Gigabit Ethernet as the interconnect. There, the obtained maximal query rate in our system is 4.2 million data items per second (roughly a 536Mbits per second sustained bandwidth).</p><p>From <ref type="figure">Figure 6</ref>, we see that the system's performance is rather stable even with differing numbers of servers. We attribute the relatively lower throughput when using 40 servers to the fact that more concurrent TCP streams are on the network, with smaller messages being sent. While the RMI dataset has almost double the amount of data for the system to handle, the achieved throughput was not reduced significantly.</p><p>In <ref type="table" target="#tab_0">Table 1</ref>, we recorded the exact number of data items found to be relevant for queries resulting in varying number of relevant voxels. Although perfect load-balancing between data servers cannot be theoretically proven, we find the measured load imbalance negligible. The load imbalance ranged between a mere 0.012% to 0.155% for medium and large queries. For very small queries (10 − 10, 000) the load imbalance increased to a reasonable 4%, since load-balancing tends to be more important for large scale queries. When more data servers are used, e.g. 30 or 40, the relative levels of load imbalance is similar to those shown in <ref type="table" target="#tab_0">Table 1</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Rendering Results</head><p>All images shown in this section have been rendered using our interactive query renderer, obtained typically within a few minutes of user interaction to refine a query. Our client software enables the user to select compound ranges on the fly, while the transfer function can be procedurally controlled from a GUI similar to that in <ref type="bibr" target="#b9">[10]</ref>. Only queried relevant voxels are rendered.</p><p>Our front-end sparse volume renderer uses hardware accelerated splatting, where each fragment undergoes two texture mapping operations (one to modulate the alpha channel using a footprint, and the other to implement the transfer function). In addition, each splat is composited onto the framebuffer. Due to those reasons, hardware accelerated splatting is usually fill-limited. On an nVidia QuadroFX 1000, a consistent rate of 3 million splats per second can be achieved, whereas on an nVidia GeforceFX 5900 card, the rate drops to 2.1 million per second.</p><p>Latency is another metric of performance. It is a measurement of the time between when a user inputs a query and when an image is rendered on the screen of the client machine. In our system, latency = query overhead +time to render one f rame. Since querying rates are often faster than rendering rates, the latencies we observe during experiments are predominantly rendering costs. This is espe-  cially true with queries resulting in 10 million relevant voxels or more.</p><p>Please note that our system enables a user to interactively examine different combinations of various attributes. This unique advantage allows users to interactively "pick and choose" among 10 or more attributes. In addition, our systems efficiency allows us to render a parallel coordinate display with volume rendered images without too much cluttering. In <ref type="figure" target="#fig_5">Figure 7</ref>, we display a parallel coordinate style graphical user interface along with the volume rendered image to aid the user in finding interesting ranges for each attribute.</p><p>By allowing simulated variables and coordinates to be queried indifferently, clipping becomes a convenient operation. <ref type="figure" target="#fig_6">Figure 8</ref> (left) shows a very thin slice of the x-dimension at the dataset's center. One can clearly recognize several layers of shockwaves at the outer boundary as well as other internal structures in the upper half of the image where the shockwave folds in. In <ref type="figure" target="#fig_6">Figure 8</ref> (right) we selected a medium range for entropy and color voxels by the norm of angular momentum. This way we can identify several levels of subsurfaces inside the outer shockwave.</p><p>In <ref type="figure" target="#fig_7">Figure 9</ref> (left), we query for voxels with medium range of gradient strength and highlight two time steps (red and violet). Analyzing the image we can see how the dataset evolves over time. On the lefthand side of the image the outside surface moves inward with time (the violet voxels are closer to the center than the red ones), and on the upper right-hand side the shockwave moves outward with the yellow voxels being the outer layer followed by green and then blue layers on the inside. In <ref type="figure" target="#fig_7">Figure 9</ref> (right), we show the same query on medium tangential velocity from six contiguous time steps, but this time using the same transfer function for all time steps.</p><p>At last, one can also combine multiple independent queries in the same visualization. For instance in <ref type="figure" target="#fig_1">Figure 10</ref>, two queries are shown.  One is bottom 15% range of tangential velocity from the 5th time step, assigning color channels (a rainbow type of color map) with entropy values. The other is medium range of entropy from the 1st time step, with the same color map indexed by angular momentum. We do not understand the physical meaning of this rendering, if there is any. This image is meant only to demonstrate the functionality of our system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION AND FUTURE WORK</head><p>By maintaining a nearly optimal load-balance for almost all types of compound queries, our system is efficient and scalable. It relies on external sorting according to a high-dimensional space filling curve order in attribute space, and an efficient M-ary search tree to efficiently skip irrelevant voxels in the dataset. These enabling techniques make it feasible to use more attributes than before by simply increasing the number of servers when required. As long as a sufficient number of servers are available, the amount of data that can be handled is rather straightforward.</p><p>For a user of our system, e.g. an application scientist, it is common to interact with the dataset of a simulation to verify correctness or to explore newly formulated hypotheses. To this end, one should be able to navigate not only in time and space, but also in the high-dimensional attribute space. By treating simulated and derived variables, as well as temporal and spatial coordinates, uniformly as attributes, some types of queries (e.g. <ref type="figure" target="#fig_6">Figures 8, 9</ref>) that have not been widely used in current visualization production are now convenient operations. Additionally, in a way, every server in our system accepts queries in the same way that web servers function. This allows parallel servers to operate persistently, while the client can dynamically start, stop or simply shutdown.</p><p>In the future, we plan to parallelize the rendering capabilities to support the use of multi-display devices, e.g. powerwalls. Also, we would like to adapt our server system to be run on distributed computing fa-cilities, and to make use of certain characteristics of the underlying system structure. For example, we plan to utilize parallel I/O capabilities on a cluster system hosting a parallel file system to further reduce the amount of time spent for preprocessing.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Markus Glatter is with The University of Tennessee, E-mail: glatter@cs.utk.edu. • Colin Mollenhour is with The University of Tennessee, E-mail: mollenho@cs.utk.edu. • Jian Huang is with The University of Tennessee, E-mail: huangj@cs.utk.edu. • Jinzhu Gao is with Oak Ridge National Lab, E-mail: gaoj@ornl.gov. Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>In-situ Preprocessing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>An illustrated M-ary search tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>An illustration of server-side query handling using an M-ary search tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Pseudo code describing how an out-of-bound compound key is "carried" back into range.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Illustration to demonstrate flexibility of visualization: parallel coordinate style interface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>(Left) Slice of the dataset colored by entropy. (Right) Medium range entropy colored by angular momentum.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 .</head><label>9</label><figDesc>(Left) Medium gradient strength over time, red and violett time steps highlighted. (Right) A query on medium tangential velocity on six contiguous time steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Two simultaneous queries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Load imbalance for different queries from TSI data (6 time steps, 864 × 864 × 864, 11 attributes per voxel) in a configuration with 20 data servers.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Querying Rates</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>12</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>million relevant voxels per second</cell><cell>2 4 6 8 10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell>10</cell><cell>12</cell><cell>14</cell><cell>16</cell><cell>18</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">million relevant voxels per query</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>TSI-20</cell><cell>TSI-30</cell><cell>TSI-40</cell><cell>RMI-40</cell><cell></cell><cell></cell></row><row><cell cols="11">Fig. 6. Measured rates of query using queries of different numbers of</cell></row><row><cell cols="2">relevant voxels.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">voxels</cell><cell></cell><cell></cell><cell cols="3">voxels per server</cell><cell cols="4">load imbalance</cell></row><row><cell cols="3">per query</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">abs. relative</cell></row><row><cell></cell><cell cols="2">228, 838</cell><cell></cell><cell cols="3">11, 464 ± 178</cell><cell cols="4">356 0.155%</cell></row><row><cell cols="3">1, 335, 685</cell><cell></cell><cell cols="7">66, 968 ± 533 1, 066 0.079%</cell></row><row><cell cols="3">6, 099, 624</cell><cell></cell><cell cols="7">304, 957 ± 825 1, 650 0.027%</cell></row><row><cell cols="3">7, 737, 111</cell><cell></cell><cell cols="7">386, 964 ± 863 1, 726 0.022%</cell></row><row><cell cols="3">9, 688, 584</cell><cell></cell><cell cols="7">484, 541 ± 936 1, 872 0.019%</cell></row><row><cell cols="3">10, 989, 382</cell><cell></cell><cell cols="7">549, 588 ± 1, 100 2, 200 0.020%</cell></row><row><cell cols="3">12, 837, 754</cell><cell></cell><cell cols="7">642, 000 ± 1, 361 2, 722 0.021%</cell></row><row><cell cols="3">17, 700, 906</cell><cell></cell><cell cols="7">885, 162 ± 1, 711 3, 422 0.019%</cell></row><row><cell cols="3">19, 241, 715</cell><cell></cell><cell cols="7">962, 156 ± 1, 713 3, 426 0.017%</cell></row><row><cell cols="11">20, 304, 821 1, 015, 461 ± 1, 549 3, 098 0.015%</cell></row><row><cell cols="11">22, 330, 131 1, 116, 666 ± 1, 614 3, 228 0.014%</cell></row><row><cell cols="11">23, 565, 859 1, 178, 372 ± 1, 804 3, 608 0.015%</cell></row><row><cell cols="11">24, 467, 368 1, 223, 571 ± 1, 416 2, 832 0.011%</cell></row><row><cell cols="11">28, 021, 080 1, 401, 034 ± 1, 749 3, 498 0.012%</cell></row><row><cell cols="11">30, 085, 660 1, 504, 109 ± 1, 932 3, 864 0.012%</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported in part by DOE Early Career PI grant DE-FG02-04ER25610, NSF grant ACI-0329323, and in part by the DOE MICS Office, under contract DE-AC05-00OR22725 and DE-FG02-04ER25651. The TSI data provided by John Blondin, at North Carolina State University, and Anthony Mezzacappa, at Oak Ridge National Lab, under the auspices of the DOE SciDAC Terascale Supernova Initiative. The RMI data provided by Mark Duchaineau at Lawrence Livermore National Lab.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast isocontouring for improved interactivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Volume Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="39" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM Symposium on Volume Visualization&apos;94</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Speeding up isosurface extraction using interval trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="170" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Distributed Data Management for Large Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Atchley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Kohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;05</title>
		<meeting>IEEE Visualization &apos;05</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="183" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The metric properties of discrete spacefilling curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lindenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="794" to="797" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fastsplats: Optimized splatting on rectilinear grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;00</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="219" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic isosurface propagation using an extrema graph and sorted boundary cell lists</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="319" to="327" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive volume rendering using multi-dimensional transfer functions and direct manipulation widgets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;01</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="255" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interactive texture-based volume rendering for large data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mcpherson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Painter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Keahey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="52" to="61" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Gaussian transfer functions for multi-field volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Premoze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ikits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Praun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;03</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="65" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast volume rendering using a shear-warp factorization of the viewing transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lacroute</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH94</title>
		<meeting>SIGGRAPH94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="451" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using the span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="84" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A practical evaluation of the four most popular volume rendering algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Meissner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM Symposium on Volume Visualization&apos;00</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">High-quality splatting on rectilinear grids with efficient culling of occluded voxels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="116" to="135" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Global static indexing for real-time exploration of very large regular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Conference on Supercomputing (SC&apos;01)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="2" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The design and analysis of spatial data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<pubPlace>New York, Addison Wesley</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A fast volume rendering algorithm for time-varying fields using a time-space partitioning (tsp) tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;99</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="371" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Isosurfacing in span space with utmost efficiency (ISSUE)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="287" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Query-driven visualization of large data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Stockinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bethel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;05</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Accelerated isosurface extraction in timevarying fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="98" to="107" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">High quality rendering of attributed volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Tiede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schiemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Hoehne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="255" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A parallel coordinates style interface for exploratory volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Tory</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Potts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="71" to="80" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiss</surname></persName>
		</author>
		<idno>ISBN 0-201-36122-1</idno>
		<title level="m">Data Structures and Algorithm Analysis in C++</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>2 edition</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A parallel visualization pipeline for terascale earthquake simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE Conference on Supercomputing (SC&apos;04)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page">49</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
