<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mesh Layouts for Block-Based Caches</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Sung-Eui</forename><surname>Yoon</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Mesh Layouts for Block-Based Caches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Current computer architectures employ caching to improve the performance of a wide variety of applications. One of the main characteristics of such cache schemes is the use of block fetching whenever an uncached data element is accessed. To maximize the benefit of the block fetching mechanism, we present novel cache-aware and cache-oblivious layouts of surface and volume meshes that improve the performance of interactive visualization and geometric processing algorithms. Based on a general I/O model, we derive new cache-aware and cache-oblivious metrics that have high correlations with the number of cache misses when accessing a mesh. In addition to guiding the layout process, our metrics can be used to quantify the quality of a layout, e.g. for comparing different layouts of the same mesh and for determining whether a given layout is amenable to significant improvement. We show that layouts of unstructured meshes optimized for our metrics result in improvements over conventional layouts in the performance of visualization applications such as isosurface extraction and view-dependent rendering. Moreover, we improve upon recent cache-oblivious mesh layouts in terms of performance, applicability, and accuracy.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Many geometric algorithms utilize the computational power of CPUs and GPUs for interactive visualization and other tasks. A major trend over the last few decades has been the widening gap between processor speed and main memory access speed. As a result, system architectures increasingly use caches and memory hierarchies to avoid memory latency. The access times of different levels of a memory hierarchy typically vary by orders of magnitude. In some cases, the running time of a program is as much a function of its cache access pattern and efficiency as it is of operation count <ref type="bibr" target="#b9">[10]</ref>.</p><p>One of the main characteristics of memory hierarchies is the use of block fetching whenever there is a cache miss. Block fetching schemes assume that there is high spatial coherence of data accesses that allow repeated cache hits. Therefore, to maximize the benefit of block fetching, it is important to organize and access the data in a cache-coherent manner. There are two standard techniques for minimizing the number of cache misses: computation reordering and data layout optimization. Computation reordering is performed to improve data access locality, e.g. using compiler optimizations or application specific hand-tuning. On the other hand, data layout optimization reorders the data in memory so that its layout matches the expected access pattern. In this paper, we focus on computing cache-coherent layouts of polygonal and polyhedral meshes, in which vertices and cells (e.g. triangles, tetrahedra) are organized as linear sequences of elements.</p><p>Many layouts and representations (triangle strips <ref type="bibr" target="#b7">[8]</ref>, space-filling curves <ref type="bibr" target="#b23">[24]</ref>, stream <ref type="bibr" target="#b13">[14]</ref> and cache-oblivious <ref type="bibr" target="#b29">[30]</ref> layouts) have been proposed for cache-coherent access. However, previous layouts have either been specialized for a particular cache <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13]</ref> or application <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">17]</ref>, including graph and sparse matrix computations <ref type="bibr" target="#b5">[6]</ref>, or are constructive <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref> with no measure of global layout quality needed to establish optimality, relative ranking among layouts, and criterion for driving more general optimization strategies. Furthermore, while prior metrics may be suitable for their intended applications, they are not particularly good estimators of layout quality in the context of block-based caching.</p><p>Main Results: We propose novel metrics and methods to evaluate and optimize the locality of mesh layouts. Based on a general I/O model, we derive cache-aware and cache-oblivious metrics that corre- <ref type="figure">Fig. 1</ref>. Layouts and Coherence Measures for a 16×16 Grid: a and g correspond to the arithmetic and geometric mean index difference of adjacent vertices; c denotes the cut, or number of edges that straddle cache blocks. Each block except the last contains 27 vertices. MLA is known to minimize a, and β Ω is near-optimal with respect to g for grids. Our new cache-oblivious measure, g, correlates better than a with the cut and, hence, the number of cache misses.</p><p>late well with the number of cache misses when accessing a mesh in a reasonably coherent, though not specific manner. Using these metrics, we employ a multi-level recursive optimization method to efficiently compute cache-coherent layouts of massive meshes consisting of hundreds of millions of vertices. We also observe that recursively constructed layouts, regardless of additional ordering criteria, in general have good locality according to our metric.</p><p>Benefits: Our approach offers the following advantages over the current state of the art:</p><p>• Generality: Our algorithm is applicable to any data set whose expected access pattern can be expressed in a graph structure.</p><p>• Simplicity: Our metrics are concise and easy to implement.</p><p>• Accuracy: Our derived metrics correlate well with the observed number of runtime cache misses. Hence our metrics are useful for constructing good layouts.</p><p>• Efficiency: Our metrics can quickly quantify the quality of a given layout. If according to the metric a layout already is coher-ent, no further work is needed to reorganize it, which saves time and effort when dealing with very large meshes.</p><p>• Performance: Computed layouts optimized for our metrics show performance improvements over other layouts.</p><p>We apply our cache-coherent layouts in two applications: isosurface extraction from tetrahedral meshes and view-dependent rendering of polygonal meshes. In order to illustrate the generality of our approach, we compute layouts of several kinds of geometric models, including a CAD environment, scanned models, an isosurface, and a tetrahedral mesh. We use these layouts directly without having to modify the runtime application. Our layouts reduce the number of cache misses and improve the overall performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Cache-efficient algorithms have received considerable attention over last two decades in theoretical computer science and in the compiler literature. These algorithms include models of cache behavior <ref type="bibr" target="#b27">[28]</ref> and compiler optimizations based on tiling, strip-mining, and loop interchanging; all of these algorithms have shown to reduce cache misses <ref type="bibr" target="#b3">[4]</ref>. Cache-efficient algorithms can be classified as computation reordering and data layout optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Computation Reordering</head><p>Computation reordering strives to achieve a cache-coherent order of runtime operations in order to improve program locality and reduce the number of cache misses. This is typically performed using compiler optimizations or application-specific hand tuning.</p><p>At a high level, computation reordering methods can be classified as either cache-aware or cache-oblivious. Cache-aware algorithms utilize knowledge of cache parameters, such as cache block size <ref type="bibr" target="#b27">[28]</ref>. On the other hand, cache-oblivious algorithms do not assume any knowledge of cache parameters <ref type="bibr" target="#b9">[10]</ref>. There is a considerable amount of literature on developing cache-efficient computation reordering algorithms for specific problems and applications, including numerical programs, sorting, geometric computations, matrix multiplication, FFT, and graph algorithms. More details are given in recent surveys <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">28]</ref>. In visualization and computer graphics, out-of-core algorithms are designed to handle massive models using finite memory, typically by limiting access to a small, cached subset of a model. A recent survey of these algorithms and their applications is given in <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data Layout Optimization</head><p>The order in which data elements are stored can have a major impact on runtime performance. Therefore, there have been considerable efforts on computing cache-coherent layouts of the data to match its anticipated access pattern. The following possibilities have been considered.</p><p>Graph and Matrix Layouts: Graph and matrix layout problems fall in the class of combinatorial optimization problems. Their main goal is to find a linear layout of a graph or matrix that minimizes a specific objective function. Well known minimization problems include linear arrangement (sum of edge lengths, i.e. index differences of adjacent vertices), bandwidth (maximum edge length), profile (sum of maximum per-vertex edge length), and wavefront (maximum front size; see also <ref type="bibr" target="#b13">[14]</ref>). This work has been widely studied and an extensive survey is available <ref type="bibr" target="#b5">[6]</ref>. While potentially improving data coherence, these layouts are not optimal-or necessarily good-for blockbased caching, as we shall see later.</p><p>Rendering Sequences: Modern GPUs maintain a small buffer to reuse recently accessed vertices. In order to maximize the benefits of vertex buffers for fast rendering, triangle reordering is necessary. This approach was pioneered by Deering <ref type="bibr" target="#b4">[5]</ref>. The resulting ordering of triangles is called a triangle strip or a rendering sequence. Hoppe <ref type="bibr" target="#b12">[13]</ref> casts the triangle reordering as a discrete optimization problem with a cost function dependent on a specific vertex buffer size. Several techniques improve the rendering performance of view-dependent algorithms by computing rendering sequences not tailored to a particular cache size [3, 7, 17, 30].</p><p>Processing Sequences: Isenburg et al. <ref type="bibr" target="#b14">[15]</ref> proposed processing sequences as an extension of rendering sequences to large-data processing. A processing sequence represents an indexed mesh as interleaved triangles and vertices that can be streamed through main memory <ref type="bibr" target="#b13">[14]</ref>. Global mesh access is restricted to a fixed traversal order; only localized random access to the buffered part of the mesh is supported as it streams through memory. This representation is mostly useful for offline applications (e.g., simplification and compression) that can adapt their computations to the fixed ordering.</p><p>Space-Filling Curves: Many algorithms use space-filling curves <ref type="bibr" target="#b23">[24]</ref> to compute cache-friendly layouts of volumetric grids or height fields. These layouts are widely used to improve the performance of image processing <ref type="bibr" target="#b26">[27]</ref> and terrain or volume visualization <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b22">23]</ref>. A standard method of constructing a mesh layout based on space-filling curves is to embed the mesh or geometric object in a uniform structure that contains the space-filling curve. Gotsman and Lindenbaum investigated the spatial locality of space-filling curves <ref type="bibr" target="#b11">[12]</ref>. Motivated by searching and sorting applications, Wierum <ref type="bibr" target="#b28">[29]</ref> proposed using a logarithmic measure of edge length, resembling one of our new metrics, for analyzing space-filling curve layouts of regular grids. Our results, however, indicate that space-filling curve embedding does not work well for meshes that have an irregular distribution of geometric primitives. Recently, Yoon et al. proposed methods for cache-coherent layout of polygonal meshes <ref type="bibr" target="#b29">[30]</ref> and bounding volume hierarchies <ref type="bibr" target="#b30">[31]</ref>. These methods are constructive in nature and require making a sequence of binary decisions without relying on a global measure of locality. Hence, these methods depend on a particular optimization framework and cannot be used to judge the quality of a layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">COMPUTATION MODELS</head><p>In this section we describe an I/O model for our cache representation. We also propose both a graph representation and probability model to capture the likelihood of accessing mesh elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">I/O Model</head><p>Most modern computers use hierarchies of memory levels, where each level of memory serves as a cache for the next level. Memory hierarchies have two main characteristics. First, lower levels are larger in size and farther from the processor, and hence have slower access times. Second, data is moved in blocks of many elements between different memory levels. Data is initially stored in the lowest memory level, typically the disk. A transfer is performed whenever there is a cache miss between two adjacent levels of the memory hierarchy. Due to this block fetching mechanism, cache misses can be reduced by storing in the same block data elements that are accessed together.</p><p>We use a simple two-level I/O-model defined by Aggarwal and Vitter <ref type="bibr" target="#b0">[1]</ref> that captures the two main characteristics of a memory hierarchy. This model assumes a fast memory called "cache" consisting of M blocks and a slower infinite memory. The size of each cache block is B; therefore, the total cache size is M × B. Data is transferred between the levels in blocks of consecutive elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Graph Representation</head><p>Our layout algorithm requires the specification of a directed graph that represents the anticipated runtime access pattern, and in which each node represents a data element (e.g., mesh vertex or triangle). A directed arc (i, j) between two nodes indicates an expectation that node j may be accessed immediately after node i. We chose directed graphs to represent access patterns, in contrast to the undirected graphs used in Yoon et al. <ref type="bibr" target="#b29">[30]</ref>, as we do not necessarily assume symmetry in node access patterns.</p><p>Let G = (N, A) be a directed graph, where N is a set of nodes and A is a set of directed arcs. The layout problem reduces to computing the one-to-one mapping ϕ : N → {1, ..., |N|} of nodes to positions in the layout that minimizes the expected number of cache misses.</p><p>We also require probabilities (as weights) for each node and arc that represent the likelihood of accessing them at runtime. We derive these probabilities here based on the graph structure by considering an infinite random walk over the graph. For each directed arc, (i, j) ∈ A, let Pr( j|i) denote the probability of accessing node j next, given that i was the previously accessed node. We define P to be a probability transition matrix whose (i, j)th element equals Pr( j|i). Furthermore, let Pr(i) denote the probability of accessing node i among all nodes N, and let x be the n-by-1 column vector whose ith component equals Pr(i). Given an initial state of node access probabilities, we update each node's probability in x by traversing the node's outgoing arcs, each with probability of access Pr( j|i). This update is equivalent to premultiplying x by P T . If applied repeatedly, x will ultimately converge to a stable equilibrium</p><formula xml:id="formula_0">x = P T x<label>(1)</label></formula><p>of node access probabilities, and we are interested in finding this configuration. It should be clear that a vector x that satisfies this criterion is an eigenvector of P T with a corresponding eigenvalue equal to one. Finally, we define Pr(i, j) to be the probability of accessing a node j from another node i in the equilibrium state (i.e. the probability of accessing the arc (i, j) among all arcs A):</p><formula xml:id="formula_1">Pr(i, j) = Pr(i) × Pr( j|i)<label>(2)</label></formula><p>Specialization for Meshes: We specialize the probability computations for meshes by assuming that given a mesh vertex i we are equally likely to access any of its neighboring vertices via traversal of an out-going arc. Therefore, Pr( j|i) = 1 deg(i) if i and j are adjacent, and equals zero otherwise. Here deg(i) is the out-degree of vertex i (for meshes the in-degree equals the out-degree). Using eigenanalysis we can then show that Pr(i) = deg(i)</p><p>|A| (see Appendix A). That is, the probability of accessing a vertex is proportional to its degree. As a result, according to Eq. (2) we have Pr(i, j) = 1</p><p>|A| . In other words, each edge in the mesh is equally likely to be accessed.</p><p>A mesh layout consists of a pair of independent linear sequences of vertices and cells. The vertex layout requires a directed graph, G = (N, A), where N is the set of mesh vertices and A is a set of arcs representing a likely access pattern. For simplicity, we choose A to be the set of mesh edges in our applications. For applications such as collision detection that require geometric coherence, we may optionally include additional arcs that join spatially nearby elements. The layout of cells can be constructed in a similar manner, e.g. by considering the edges in the dual graph. From here on, we use the term layout to refer to the vertex layout for the sake of clarity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CACHE-AWARE LAYOUTS</head><p>In this section we derive cache-aware metrics based on our computation models and describe an efficient layout algorithm. Our goal is to compute the expected number of cache misses when accessing a node by traversing a single arc. Since in our framework arcs are equally likely to be accessed, this measure generalizes trivially to any number of accesses. We consider two cases of this problem: the cache consists of exactly one block (M = 1), or of multiple blocks (M &gt; 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Single Cache Block, M = 1</head><p>Since the cache can only hold one block, a cache miss occurs whenever a node is accessed that is stored in a block different from the cached block. In other words, a cache miss is observed when we traverse an arc, (i, j), and the block containing node j is different from the block that holds i. Therefore, the expected number of cache misses, ECM B 1 (ϕ), of a layout, ϕ, for a single-block cache with block size B nodes can be computed as:</p><formula xml:id="formula_2">ECM B 1 (ϕ) = ∑ (i, j)∈A ϕ B (i) =ϕ B ( j) Pr(i, j) = 1 |A| ∑ (i, j)∈A S(|ϕ B (i) − ϕ B ( j)|)<label>(3)</label></formula><p>where</p><formula xml:id="formula_3">ϕ B (i) = ϕ(i) B</formula><p>denotes the index of the block in which i resides and S(x) is the unit step function S(x) = 1 if x &gt; 0 and S(x) = 0 otherwise. Intuitively speaking, ECM B 1 (ϕ) is the number of arcs whose two nodes are stored in different blocks, i.e. the cut, divided by the total number of arcs in the graph.</p><p>Layout algorithm: Constructing a layout optimized for ECM <ref type="bibr">B</ref> 1 (ϕ) reduces to a k-way graph partitioning problem. Each directed arc has a constant weight, <ref type="bibr" target="#b0">1</ref> |A| , and we partition the input graph into k = n B different sets of vertices. Since graph partitioning is an NP-hard problem, we rely on heuristics. One good heuristic is the multi-level algorithm implemented in the METIS library <ref type="bibr" target="#b17">[18]</ref>. Once the directed graph is partitioned, the ordering among blocks and the order of vertices within each block do not matter in our I/O model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Multiple Cache Blocks, M &gt; 1</head><p>We now assume that the cache holds multiple blocks. As in the singleblock case, a cache miss can occur only when we traverse an arc, (i, j), that crosses a block boundary, i.e., ϕ B (i) = B i = B j = ϕ B ( j). However, unlike the single-block case, block B j may already be stored in the cache when we access j. Therefore, to compute the expected number of cache misses for a multi-block cache, we must also consider the probability, Pr cached (B j ), that B j is cached among the M blocks.</p><p>In theory, Pr cached (B j ) can be computed by exhaustively generating all possible access patterns for which B( j) is already cached when we access j from i. Such block access patterns take on the form</p><formula xml:id="formula_4">(B j , . . . , B i , B j ),</formula><p>where at most M different blocks are accessed before B j is accessed the second time. Then, the expected number of cache misses, ECM B M (ϕ), for M &gt; 1 cache blocks of a layout, ϕ, is:</p><formula xml:id="formula_5">ECM B M (ϕ) = ∑ (i, j)∈A ϕ B (i) =ϕ B ( j) Pr(i, j)(1 − Pr cached (ϕ B ( j))<label>(4)</label></formula><p>Approximation: Unfortunately, generating all possible block access patterns is prohibitively expensive because of its exponential combinatorial nature. Furthermore, we found that it is not feasible to approximate Pr cached (B j ) within an error bound without considering a very large number of access patterns. However, we conjecture that there is strong correlation between ECM B 1 (ϕ) and the observed number of cache misses, OCM B M , for multiple blocks, which ECM B M (ϕ) is designed to capture. To support this conjecture, we computed ten different layouts of a uniform grid ( <ref type="figure">Fig. 4</ref>) and measured the number of cache misses incurred in a LRU-based cache during a random walk between neighboring nodes. We performed walks long enough until the observed number of cache misses, OCM <ref type="bibr">B</ref> 1 , for a single-block cache correlated well (R 2 &gt; 0.99) with our estimate ECM B</p><p>1 . In this case, the correlation between ECM B 1 and OCM B M , for a multi-block cache (M = 5 and M = 5 2 ) was observed to be very high (R 2 = 0.97).</p><p>Note that there is, however, a pathological case that suggests that our conjecture is not always valid. To illustrate this, we first compute a spectral layout, ϕ spectral , and a cache-aware layout, ϕ aware , optimized for a single block. We modify ϕ aware to produce a new layout, ϕ random , by performing a series of random swaps of two adjacent nodes from different blocks until ϕ random has the exact same edge cut as ϕ spectral . Although the two layouts, ϕ spectral and ϕ random , have the same value for ECM <ref type="bibr">B</ref> 1 , we observed that ϕ random results in many fewer cache misses for multi-block caches. We attribute this result to the fact that it does not take many local swaps to rapidly boost the edge cut. However, these swaps do not adversely affect locality since they generally increase only the connectivity between already adjacent cache blocks (i.e. blocks spanned by crossing arcs) that are likely to be cached together in a multi-block cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CACHE-OBLIVIOUS LAYOUTS</head><p>A cache-oblivious layout allows good performance across a wide range of block and cache sizes, which is important due to the hierarchical nature of most cache systems, as well as for portability across platforms with different cache parameters. In this section we present our cache-oblivious metric that measures the expected number of cache misses for any block size B. For a single-block cache, we derive two metrics: one with no restriction on B, and one that restricts B to be a power of two. We conclude by briefly discussing multi-block caches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Single Cache Block, M = 1</head><p>We now relax the assumption of B being a particular block size and consider metrics optimized for many (even an infinite number of) block sizes. We first assume that the cache holds only a single block.</p><p>In Sec. 4.1, we derived a cache-aware metric ECM B 1 for a singleblock cache with fixed block size B. We here generalize this metric by considering all possible block sizes B, each with its own likelihood w(B) of being employed in an actual cache. Clearly w(B) is difficult to estimate in practice, but we will consider some reasonable choices below. We then express our single-block cache-oblivious metric, ECM 1 , in terms of the cache-aware metric, ECM <ref type="bibr">B</ref> 1 :</p><formula xml:id="formula_6">ECM 1 (w, ϕ) = t ∑ B=1 w(B) ECM B 1 (ϕ) = 1 |A| ∑ (i, j)∈A t ∑ B=1 w(B) S(|ϕ B (i) − ϕ B ( j)|)<label>(5)</label></formula><p>where t is the maximum block size considered.</p><p>Assumptions: For simplicity, we will assume that a layout may start anywhere within a block with uniform probability. <ref type="bibr" target="#b0">1</ref> Hence we replace the binary step function S(x) with the probability Pr cross ( i j , B) that an arc (i, j) of length i j = |ϕ(i) − ϕ( j)| crosses a block boundary. We have (see Appendix B):</p><formula xml:id="formula_7">Pr cross ( , B) = 1 if B ≤ B otherwise<label>(6)</label></formula><p>Eq. (5) then becomes:</p><formula xml:id="formula_8">ECM 1 (w, ϕ) = 1 |A| ∑ (i, j)∈A i j ∑ B=1 w(B) + t ∑ B= i j +1 w(B) i j B ≈ 1 |A| ∑ (i, j)∈A i j 0 w(B) dB + t i j w(B) i j B dB<label>(7)</label></formula><p>where we have used integrals to approximate summations in order to simplify the math. One can show that this approximation introduces a negligible error. Finally, we will attempt to present our metrics in their simplest form, e.g. scaling or addition of constants can be factored out without affecting the relative ranking among layouts reported by a metric. More generally, we consider ECM and f (ECM) equivalent metrics as long as f is monotonically increasing, i.e. ECM(ϕ) &lt; ECM(ϕ ) ⇒ f (ECM(ϕ)) &lt; f (ECM(ϕ )) Note that we make such simplifications only to the final metric value of ECM and not to terms like and w that make up a metric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Arithmetic Progression of Block Size</head><p>Without further information, perhaps the most natural choice for w is to assume that each block size is equally likely, i.e. w a (B) = 1 t . Stated differently, we assume that the block size is drawn uniformly from an arithmetic sequence B ∈ {k} t k=1 . We have:</p><formula xml:id="formula_9">ECM 1 (w a , ϕ) ≈ 1 |A|t ∑ (i, j)∈A i j 0 dB + t i j i j B dB = 1 |A|t ∑ (i, j)∈A i j (1 + logt − log i j )<label>(8)</label></formula><p>As t grows, 1 + logt − log i j approaches logt. After proper scaling, we arrive at our arithmetic cache-oblivious metric, COM a : Note that COM a is the arithmetic mean arc length, or equivalently the metric for linear arrangement. Therefore, the optimal layout COL a for this metric is the well-known minimum linear arrangement (MLA) <ref type="bibr" target="#b5">[6]</ref>.</p><formula xml:id="formula_10">COM a (ϕ) = 1 |A| ∑ (i, j)∈A i j<label>(9)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Geometric Progression of Block Size</head><p>The assumption that all block sizes are equally likely and should be weighed uniformly is questionable. First, this diminishes the importance of small block sizes since we may include arbitrarily many large block sizes by increasing t. Second, the hierarchical relationship between nested cache levels is often geometric, which suggests that we should optimize for cache block sizes at different scales, and not particularly for every possible block size. Indeed, most block sizes employed in practice are a power-of-two bytes (e.g., 32B for L1, 64B for L2, 4KB for disk blocks). We thus consider block sizes drawn uniformly from a geometric sequence B ∈ {2 k } lgt k=0 :</p><formula xml:id="formula_11">ECM 1 (w g , ϕ) ≈ 1 |A| lgt ∑ (i, j)∈A lg i j 0 dk + lgt lg i j i j 2 k dk = 1 |A| logt ∑ (i, j)∈A i j 1 1 B dB + t i j i j B 2 dB = 1 |A| logt ∑ (i, j)∈A log i j + 1 − i j t<label>(10)</label></formula><p>We note that our restriction on block size is equivalent to using a weight function w g (B) = 1 B over all block sizes. As t grows, we reach our geometric cache-oblivious metric, COM g :</p><formula xml:id="formula_12">COM g (ϕ) = 1 |A| ∑ (i, j)∈A log i j = log ∏ (i, j)∈A i j 1 |A|<label>(11)</label></formula><p>The right-hand side expression is the logarithm of the geometric mean arc length. Since log x is monotonic, we may optionally use the geometric mean directly as cache-oblivious metric, as is done in <ref type="figure">Fig. 1</ref>. From here on, we will however include the logarithm when evaluating COM g . For simplicity of presentation, we here consider only powerof-two-byte blocks and single-byte nodes, however one can show that any geometric sequence B ∈ {b k /m} k with base b and node size m leads to the same metric COM g . <ref type="figure">Fig. 2</ref> shows how the metrics COM a and COM g change as a function of arc length for a single arc. This graph shows that COM g puts a big premium on very short arcs, and does not excessively penalize long arcs. This is justified by the fact that once an arc in a layout is long enough to cause a cache miss, lengthening it will not drastically increase the probability of cache misses. We note that COM g and COM a are instances of the power mean,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Properties</head><formula xml:id="formula_13">M p = lim q→p 1 |A| ∑ (i, j)∈A q i j</formula><p>1/q , with p = 0 and p = 1, respectively.</p><p>Equivalently, our new measure, COM g , can be viewed as an extension of the well-known p-sum <ref type="bibr" target="#b15">[16]</ref> family of graph theoretic measures that includes linear arrangement (p = 1), discrete spectral sequencing (p = 2), and bandwidth (p = ∞) <ref type="bibr" target="#b5">[6]</ref>. Although the case 0 &lt; p &lt; 1 is considered in <ref type="bibr" target="#b20">[21]</ref>, we are not aware of prior work for which p = 0. Arithmetic CO layout Geometric CO layout <ref type="figure">Fig. 3</ref>. Cache Misses vs. Cache Block Size: We simulated LRU-based caching for several block sizes and measured the number of cache misses during random walks between adjacent vertices of the dragon mesh using layouts optimized for our two metrics. The arithmetic layout results in better performance for block sizes between 196KB and 8MB, or 97% of the full range of block sizes considered here. On the other hand, the geometric layout causes fewer cache misses in 73% of all tested power-of-two-byte block sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Validation</head><p>We derived two cache-oblivious metrics for different assumptions on cache block sizes. To determine whether the two metrics correlate with the actual number of cache misses, we performed a validation test on the dragon model. First we computed two different layouts: an arithmetic layout, COL a , and a geometric layout, COL g , optimized for our two metrics. Then, we performed random walks on the mesh and measured the number of cache misses for a range of block sizes. As can be seen in <ref type="figure">Fig. 3</ref>, COL g results in fewer actual cache misses over most (73%) of the tested power-of-two block sizes, although the range of block sizes over which COL a performs better is much wider (97%). (This is not readily evident from <ref type="figure">Fig. 3</ref> due to the logarithmic scale.) Hence, when considering also all possible non-power-of-two block sizes, we expect COL a to perform better on average. Because cache block sizes employed in practice are often nested powers-of-two bytes, a layout optimized for COM g is likely to be useful in practice.</p><p>As an additional sanity check, we evaluated our COM g metric on several layouts of a uniform grid <ref type="figure">(Fig. 4)</ref>. We computed β Ωindexing <ref type="bibr" target="#b28">[29]</ref>, Hilbert, Z-curve <ref type="bibr" target="#b23">[24]</ref>, H-order <ref type="bibr" target="#b21">[22]</ref>, MLA <ref type="bibr" target="#b8">[9]</ref>, row-byrow, and diagonal-by-diagonal layouts of a 256 × 256 uniform grid (see also <ref type="figure">Fig. 1)</ref>. We measured the actual number of cache misses during random walks for a 4KB single-block cache. We found strong correlation, R 2 = 0.98, between the value of COM g and the observed number of cache misses for this experiment.</p><p>According to COM g , layouts with increasing space-filling structure have better locality. We exhaustively searched for the layout of a 4 × 4 grid that minimizes COM g and found the β Ω space-filling curve <ref type="bibr" target="#b28">[29]</ref> to be the optimum, closely followed by the Hilbert curve, confirming conventional wisdom. For an 8 × 8 grid, we had to restrict our exhaustive search to recursive layouts due to combinatorial explosion of the search space. Here again we found β Ω to be optimal; for all 2 n × 2 n grids investigated we have not found any other space-filling layout with lower COM g . By considering non-recursive layouts produced by an alternative (non-exhaustive) optimization method, we have however found layouts slightly better than β Ω for 8 × 8 and larger grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Layout Algorithms</head><p>To construct layouts optimized for COM a , we may use existing MLA layout algorithms. The MLA problem is known to be NP-hard and its decision version is NP-complete <ref type="bibr" target="#b10">[11]</ref>. However its importance in many applications has inspired a wide variety of approximations based on heuristics, including spectral sequencing <ref type="bibr" target="#b15">[16]</ref>. A more direct, multi-level algorithm for MLA is presented in <ref type="bibr" target="#b18">[19]</ref>. Since layouts minimizing COM a are not practically useful for our purpose, we do not further consider them here.</p><p>To minimize COM g , we propose using a minor variation on the multi-level recursive layout algorithm from <ref type="bibr" target="#b29">[30]</ref> that is based on graph partitioning and local permutations. This algorithm recursively partitions a mesh into k (e.g., k = 4) vertex sets using METIS <ref type="bibr" target="#b17">[18]</ref> and computes the locally best ordering of these k sets among all k! permutations. The process is repeated until each set contains a single vertex.</p><p>Note that contrary to the layouts in <ref type="bibr" target="#b29">[30]</ref>, which depend on a particular constructive algorithm, our global metrics allow us to apply other optimization methods, e.g. based on simulated annealing, genetic algorithms, steepest decent, etc. We have, however, found the multi-  level recursive method to be quite effective for minimizing COM g , which can be explained by this metric's goal to measure locality at different scales. That is, optimally partitioning a mesh into k sets amounts to computing a cache-aware layout for a block size n k . Indeed, even when not applying any local permutations, i.e. by randomly ordering nodes within each set, we observed that the resulting layouts yield only 5% more cache misses than layouts locally optimized for COM g .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Multiple Cache Blocks, M &gt; 1</head><p>We can derive a multi-block cache-oblivious metric ECM M based on the corresponding cache-aware metric ECM B M as we did for the singleblock case. But since evaluating ECM B M is computationally infeasible, we again must resort to using the single-block metric ECM 1 as an approximation. As evidenced by <ref type="figure">Fig. 4</ref>, we obtain good correlation (R 2 = 0.81) between COM g and the observed number of cache misses when using a cache with multiple blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATING LAYOUTS</head><p>In this section we propose two simple ways of evaluating the quality of layouts using our metrics. If a layout is deemed to be good, it can be used without expensive reordering, which is especially useful for massive meshes with millions of vertices. While our cache-aware and geometric cache-oblivious metrics allow ranking different layouts of a graph or mesh, it is not obvious how to map the numerical values they report for a single layout to some notion of absolute quality or closeness to optimality. If a tight lower bound for either of these two metrics is known for a graph, we can compare this bound with the metric value of the layout to determine its quality. Unfortunately, no such bound for general graphs or meshes is known. However, empirical evidence suggests that for optimized layouts of unstructured triangle and tetrahedral meshes with bounded vertex degrees, COM g depends only on the average vertex degree and not on mesh size. For ten benchmark triangle meshes, spanning 35K to 880K vertices and optimized for COM g , we observed the geometric mean edge length to fall in the narrow range 4.48-4.87. While pathological cases can be constructed for which this measure is unbounded with respect to mesh size, we hypothesize that mesh layouts with geometric mean close to the average degree are sufficiently near optimal to be quite useful in practice. Future work is needed to investigate this hypothesis in more detail.</p><p>An alternative, albeit more expensive, approach to measuring layout quality, is to compare a given layout, ϕ, with the optimized layout, ϕ * , constructed by our cache-aware or cache-oblivious layout methods. Since the goal of this comparison is primarily to avoid lengthy optimization, we limit the evaluation to a small subgraph, G , extracted from the input graph, G, and optimize only the layout ϕ * for G . We present our algorithm for constructing G below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Algorithm</head><p>We compute a small subgraph, G = (N , A ), of an input graph, G = (N, A), with N ⊆ N and A = {(i, j) ∈ A : i, j ∈ N }. Our algorithm requires at most two parameters: a ratio, p = We measured the performance of isosurface extraction from unstructured tetrahedral meshes. Using our cache-oblivious layout of the Spx volume mesh with 140K vertices, we were able to reduce cache misses by 5%-50% compared to other layouts. Moreover, our cache-oblivious layout yields only less than 2% fewer cache misses compared to our cache-aware layout.</p><formula xml:id="formula_14">|N | |N| , that specifies</formula><p>the target subgraph size |N |, and for the cache-aware case the block size, B. For efficiency, p should be small, e.g., 0.1%-1%.</p><p>Our evaluation algorithm has two major steps: 1) sampling the input graph and 2) constructing an optimized layout of the sampled subgraph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Sampling the input graph:</head><p>We first randomly select a start node in the input graph and add it to the subgraph. In order to obtain a subgraph that well reflects the quality of the full layout, ϕ, and that allows capturing the cache behavior of a probable sequence of successive accesses to the graph, we construct connected subsets of G via breadth-first region growing from the start node and add all visited nodes to the subgraph. We also add to the subgraph all the arcs from A that join nodes in N . We continue growing until the total number of nodes in the subgraph is about k times (e.g., k = 5) the block size, B. If B is not specified, as in the cache-oblivious case, we simply set B to be 8KB, which is commonly used for large page sizes of virtual memory.</p><p>Once the region growing stops, we add for each node i ∈ N all other nodes that map to the same cache block as i. We do this to avoid having to account for intra-block "holes" in the layout that might otherwise be unfairly utilized in the optimized layout. This also ensures that we do not accidentally miss cut edges between sampled blocks with respect to the cache-aware metric. We do, however, allow for holes due to unsampled blocks since for incoherent layouts there could be arbitrarily many such blocks. We then repeat step 1, randomly selecting a new start node, until the number of nodes |N | is close to p|N|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Constructing an optimized layout of the subgraph: We apply our cache-aware or cache-oblivious layout algorithm to construct a new layout, ϕ * , of the subgraph and evaluate the chosen metric for ϕ * and ϕ. We simply use these numbers to approximate the expected numbers of cache misses of the input layout and the optimized layout for the full graph. If there is big difference between these estimates for the subgraph, it is likely beneficial to compute an improved layout of the full graph using our layout algorithm.</p><p>We used this approach to quickly evaluate the original layouts of our benchmark models. Even for the largest meshes, our approximate method takes less than 10 seconds. We found that we are able to predict the metric values of these full layouts within 15% error using subgraphs of only 6K-40K vertices, even though the original meshes have as many as tens of millions of vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS</head><p>In this section we highlight the performance improvements obtained using our cache-coherent layouts in two different applications: isosurface extraction and view-dependent rendering. We implemented our layout computation algorithm on a 2.8GHz Pentium-4 PC with 1GB of RAM. We used the METIS graph partitioning library <ref type="bibr" target="#b17">[18]</ref> to compute our cache-aware and cache-oblivious layouts. Also, our metric has been integrated into OpenCCL, an open source library for the layout computation. Our current unoptimized implementation of the out-of-core layout computation, based in large part on the method  <ref type="bibr" target="#b23">[24]</ref> COML <ref type="bibr" target="#b29">[30]</ref> COLg CAL <ref type="figure">Fig. 6</ref>. Comparison with Different Layouts in Iso-Surface Extraction: We compared our cache-aware (CAL) and cache-oblivious (COL g ) layouts with breadth-first (BFL), depth-first (DFL), Z-curve, spectral (SL), cache-oblivious mesh (COML), and geometrically sorted layout along the X-axis. We simulated a LRU-based cache with a block size of 4KB and measured cache misses during isosurface extraction from the Spx model shown in <ref type="figure" target="#fig_1">Fig. 5</ref>. We also measured the out-of-core running time of extracting the surface from disk (OoC) and a second time from memory (IC). Due to the different scales, each quantity is normalized to the unit interval. We observe that our geometric cache-oblivious metric has strong correlation with both cache misses and running time. CMR indicates cache miss ratio.</p><p>in <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32]</ref>, processes about 15K triangles per second, which is comparable in speed to other out-of-core layout methods <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b29">30]</ref>.</p><p>Inducing a Layout: In order to reduce the layout computation time, we compute only one of the vertex and triangle layouts and induce the other layout rather than computing the layouts separately. First, we construct a vertex layout since the number of vertices is typically smaller than the number of triangles. Hence, the processing time of a vertex layout is smaller than that of a triangle layout. Then, as we access each vertex of the vertex layout, we sequentially store all triangles incident on the vertex that have not already been added to the triangle layout. We found that using the induced layouts at runtime causes a minor runtime performance loss-in our benchmark, less than 5%-compared to using layouts that are computed separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Isosurface Extraction</head><p>The problem of extracting an isocontour from an unstructured dataset frequently arises in geographic information systems and scientific visualization. Many efficient isosurface extraction methods employ seed sets <ref type="bibr" target="#b25">[26]</ref> to grow an isosurface by traversing only the cells intersecting the isosurface. The running time of such an algorithm is dominated by the traversal of the cells intersecting the contour. We efficiently extract an isosurface from a seed cell by making a depth-first traversal, thereby accessing the volume mesh in a reasonably cache-coherent manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Comparison with Other Layouts</head><p>We compared the performance of the isosurface extraction algorithm on the Spx volume mesh <ref type="figure" target="#fig_1">(Fig. 5</ref>) consisting of 140K vertices and 820K tetrahedra. We stored the volume mesh using eight different layouts (see <ref type="figure">Fig. 6</ref>). We measured cache misses during two invocations of the same isosurface extraction. During the first extraction, we ensured that no part of the model was cached in main memory; therefore, loading the data from disk was the major bottleneck. During the second extraction of the same isosurface, all the data was already loaded into main memory; therefore, L1 and L2 cache misses dominated. As seen in <ref type="figure">Fig. 6</ref>, we observe strong correlations between our geometric cacheoblivious metric and both cache misses and running times of the isosurface extraction. Moreover, our cache-oblivious layout yields only a slight performance decrease compared to our cache-aware layout optimized for a block size of 4KB. Our layouts furthermore result in up to two times speedup over the other layouts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">View-dependent rendering</head><p>View-dependent rendering is frequently used for interactive display of massive models. These algorithms precompute a multiresolution hierarchy of a large model, and at run time dynamically simplify the model as long as the desired pixels of error (PoE) tolerance in image space is met. We use the clustered hierarchy of progressive meshes (CHPM) representation from <ref type="bibr" target="#b31">[32]</ref> for view-dependent rendering. The CHPMbased view-dependent method is fast and most of the frame time is spent rendering the simplified model. We precomputed different layouts and compared their cache performance for three different models, including a CAD environment of a power plant consisting of 12 million triangles, the Stanford bunny model, and a subset of the LLNL Richtmeyer-Meshkov isosurface model consisting of 100M triangles.</p><p>To compare the cache performance of different layouts during viewdependent rendering, we use the average cache miss ratio (ACMR), which is defined as the ratio of the number of vertex cache misses to the number of rendered triangles for a particular vertex cache size <ref type="bibr" target="#b12">[13]</ref>.</p><p>To verify the cache-oblivious nature of our layouts, we also simulated a FIFO vertex cache of configurable size and measured the ACMR as a function of cache size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Comparison with Other Layouts</head><p>We compared our cache-oblivious layout with universal rendering sequences (URS) <ref type="bibr" target="#b2">[3]</ref>, Hoppe's rendering sequences (HRS) <ref type="bibr" target="#b12">[13]</ref>, embedding using a Z-order space-filling curve, and Yoon et al.'s cacheoblivious mesh layouts (COML) <ref type="bibr" target="#b29">[30]</ref>. HRS is considered a cacheaware layout since it is optimized for a given cache size and replacement policy. On the other hand, the Z-curve, URS, and COML are considered cache-oblivious layouts since they do not take advantage of any cache parameters. <ref type="figure">Fig. 7</ref> shows ACMRs of different rendering sequences for the Stanford bunny model. Since the number of triangles in the model is roughly twice the number of vertices, the ACMR is within the interval [0.5, 3]. Moreover, it is possible to compute a lower bound 0.5 + O( 1 k ) on the ACMR, where k is the size of vertex cache <ref type="bibr" target="#b2">[3]</ref>. As can be seen, the ACMRs of our layout are close to the lower bound and consistently lower than those of URS and COML among all tested cache sizes. Although our layout yields more cache misses at cache size 16 than HRS, which is optimized for this size, our layout shows superior performance at cache sizes 8 and 64. This is greatly due to the cacheoblivious nature of our layouts, which achieve good performance over a wide spectrum of cache sizes rather than one particular size. These observed results also correlate with cache miss estimates reported by our COM g metric, which for the bunny model predict our layout to be 5%, 17%, and 31% better than COML, HRS, and URS, respectively. We observed similar results on the isosurface model. <ref type="figure">Fig. 8</ref> shows ACMRs for rendering the power plant model, which has a very irregular geometric distribution, using our layout and others, including the Z-curve. Since space-filling curves mainly retain locality between mesh elements if their geometric distribution is regular, we would not expect the Z-curve layout to result in good performance on this irregular mesh. As evidenced, our layout consistently yields better performance than the Z-curve and the other layouts. This is correctly predicted by our COM g metric, which estimates our layout to be 5%, 29%, and 241% better than COML, HRS, and the Z-curve, respectively.</p><p>Finally, we measured ACMRs of COL g and HRS at a cache size of 32 as we decreased the resolution of the mesh by "subsampling" vertices and triangles via edge collapse operations. The relative positions of surviving elements were retained in the simplified meshes. Since our COL g layout maintains locality at multiple scales, it is likely to be coherent in the simplified mesh. As expected, <ref type="figure" target="#fig_3">Fig. 9</ref> shows our layout to be more robust to simplification than HRS, which is optimized only for the finest mesh resolution.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Comparison with COML</head><p>The cache-oblivious mesh layouts (COML) proposed by Yoon et al. <ref type="bibr" target="#b29">[30]</ref> bear many similarities with ours, in particular with respect to performance. Whereas we consistently achieve modest performance improvements over COML, our main motivation for extending their work was their lack of a global measure of layout coherence, which manifests itself as a number of limitations. COML makes use of a local probabilistic measure of coherence that allows making decisions whether a local permutation of a small number of vertices is likely or not to reduce the number of cache misses. This measure does not extend to a whole mesh, and it does not satisfy transitivity. Suppose that a local permutation, A, is deemed better than another local permutation, B, and B is better than another a permutation, C. However, according to the COML measure, A is not necessarily better than C. For these two reasons, the COML measure cannot be used to evaluate and compare the quality of layouts. On the other hand, our new measure is global and transitive, and furthermore correlates with expected cache misses. And because this measure is global and easy to compute, it can be easily integrated into layout computation frameworks other than the one presented here. Finally, we started from a general I/O model from which both cache-aware and cache-oblivious measures emerged. It is not obvious that COML lends itself to computing cache-aware layouts since it fundamentally does not incorporate cache parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Limitations</head><p>While in many respects an improvement over COML, our new approach still has several limitations. Our layout quality estimation technique considers only a subset of a mesh, and may not be indicative of quality for unsampled portions. The greedy and recursive multi-level method we use for mesh layout is not likely to find a true optimum, and may not even compute a layout better than the input layout. Moreover, our multi-level method relies heavily on the METIS graph partitioning algorithm, which itself is based on heuristics. Therefore, the partitioning results may be far from optimal, as evidenced for example when applied to a uniform grid. Here the cache-oblivious layouts produced with METIS and our metric result in up to 60% more cache misses than achieved by space-filling curves, which in a sense provide optimal partitions of such grids. Our layouts furthermore help performance primarily in applications where the running time is dominated by data access. Finally, we require the specification of a graph to represent a typical access pattern. Whereas the connectivity structure of a mesh can often be used to define this graph, certain applications may need a different set of nodes, arcs, or access probability assignments than those automatically generated by our method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head><p>We have presented novel cache-aware and cache-oblivious metrics for evaluating the layout quality of unstructured graphs and meshes. We based our metrics on a two-level I/O model. Our cache-aware metric is reduced to counting the number of arcs whose nodes are stored in different cache blocks. For the cache-oblivious case, we derived two different metrics based on different assumptions on what cache block sizes may be used for caching. When applied equally to all possible block sizes, our cache-oblivious metric reduces to the graph-theoretic metric for minimum linear arrangement. When only power-of-two block sizes are considered, our cache-oblivious metric is a function of logarithmic arc length. Equivalently, these metrics correspond to arithmetic and geometric mean arc length. We show that there is good correlation between our metrics and the number of observed cache misses for two different visualization applications. Moreover, we improve the performance of these applications by 5%-100% over several other common layouts. There are many avenues for future work. In addition to addressing some of the limitations of our current approach, we are working on mesh compression schemes to further reduce expensive I/O access time. One major challenge is to design a compression method that both preserves the mesh layout and supports random access so that a mesh can be accessed using a coherent but not predetermined traversal. Another challenge would be to extend our current approach to support maintaining coherent layouts of non-static mesh connectivity, e.g. due to animation, simplification, or refinement. There is considerable room for exciting theoretical work on the properties of our new, simple cache-oblivious metric, such as proving what layouts are optimal for 2D and 3D grids, and whether our metric produces similar "space-filling" optimal layouts for unstructured meshes. Finally, we expect our metric to have uses in applications other than visualization, such as acceleration of shortest path and other graph computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A EIGENANALYSIS FOR MESHES</head><p>Let x be a column vector with ith component</p><formula xml:id="formula_15">x i = Pr(i) = deg(i) |A| . Then,</formula><p>x is an eigenvector of the probability transition matrix, P T , since: Therefore, x i is the stationary probability Pr(i) that node i is accessed.</p><formula xml:id="formula_16">(P T x) i = ∑</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B EXPECTED EDGE CUT</head><p>Consider an edge of length . The two nodes of the edge are always stored in different blocks when B ≤ , irrespective of where within a block the layout starts. Now consider the case B &gt; . There are different positions for which the edge crosses a block boundary, and B different positions at which the layout may start. Therefore, the probability Pr cross ( , B) that the edge crosses a block boundary is B .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We would like to thank Ajith Mascarenhas for his isosurfacing codes; Martin Isenburg for his out-of-core mesh decomposition code; Fabio Bernardon, Joao Comba, and Claudio Silva for their unstructured tetrahedra rendering program; and Dinesh Manocha and the anonymous reviewers for their useful feedback. The bunny and dragon models are courtesy of Stanford University. The spx model is courtesy of Bruno Notrosso (Electricite de France). The power plant model is courtesy of an anonymous donor. This work was supported by the LOCAL LLNL LDRD project (05-ERD-018) and was performed under the auspices of the U.S. Department of Energy by the University of California, Lawrence Livermore National Laboratory under Contract No. W-7405-Eng-48.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5 .</head><label>5</label><figDesc>Isosurface Extraction:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 9 .</head><label>9</label><figDesc>ACMRs of Different Resolutions: These curves correspond to ACMRs for our cache-oblivious layout and Hoppe's rendering sequences over several mesh resolutions for a cache size of 32. The horizontal axis indicates the fraction of triangles relative to the full resolution mesh.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>j∈N</head><label></label><figDesc>Pr( j|i) Pr( j) = ∑ j : ( j,i)∈A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>These curves show the per-arc penalty as a function of arc length. Our geometric metric, COM g , places a large premium on very short arcs while de-emphasizing small differences in long arcs, whereas our arithmetic metric, COM a , prefers layouts with a more uniform arc length.</figDesc><table><row><cell>Normalized Arc</cell><cell>Length Penalty</cell><cell>0 0 0.5 1</cell><cell>2000</cell><cell>4000</cell><cell>6000 Geometric CO metric 8000 10000 Arithmetic CO metric</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Arc length</cell></row></table><note>Fig. 2. Arc Length Dependence of Cache-Oblivious Metrics:</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>We computed ten layouts of a 256 × 256 grid and measured the values of COM g and COM a and the number of cache misses incurred during random walks on the grid. We found that COM g and the number of cache misses for a single-block and multi-block (M = 5) cache correlated well, with correlation coefficients R 2 = 0.98 and R 2 = 0.81, respectively. COM a , on the other hand, did not predict cache misses well, with R 2 = −0.19 and R 2 = −0.32, respectively. For this parallel-coordinates plot we linearly mapped each quantity to the interval [0, 1]. In the row-by-row and diagonalby-diagonal layouts, uniindicates that we traverse each row/diagonal from left to right; biindicates that we alternate direction. CMR denotes cache miss ratio.</figDesc><table><row><cell>Uni-diag</cell></row><row><cell>Bi-diag</cell></row><row><cell>Uni-row</cell></row><row><cell>Bi-row</cell></row><row><cell>MLA [21]</cell></row><row><cell>COLg</cell></row><row><cell>Z-curve [24]</cell></row><row><cell>H-order [22]</cell></row><row><cell>Hilbert [24]</cell></row><row><cell>BetaO [30]</cell></row></table><note>Fig. 4. Correlation between Cache Misses and Our Metrics:</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>The ACMRs of our cacheoblivious layout (COL g ) are close to the lower bound on ACMR. COL g consistently outperforms universal rendering sequences (URS), cache-oblivious mesh layout (COML), and Hoppe's rendering sequences (HRS) at cache sizes 8 and 64; HRS is optimized for a cache size in the range 12-16.</figDesc><table><row><cell>Avg. cache</cell><cell>misses per</cell><cell>triangle (ACMR)</cell><cell>0.6 0.8 1</cell><cell></cell><cell>URS [3] HRS [13] COML [30] COLg Lower bound [3]</cell></row><row><cell></cell><cell></cell><cell></cell><cell>8</cell><cell>16</cell><cell>32</cell><cell>64</cell></row><row><cell cols="6">Vertex cache size Fig. 7. View-Dependent Rendering of Bunny Model:</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>View-Dependent Rendering of Power Plant Model:</head><label></label><figDesc>Our new cacheoblivious layout (COL g ) consistently performs better than the Z-curve, Hoppe's rendering sequences (HRS), and Yoon et al.'s cache-oblivious mesh layout (COML) on the power plant model, which has an irregular geometric distribution.</figDesc><table><row><cell>Avg. cache</cell><cell>misses per</cell><cell>triangle (ACMR)</cell><cell>8 1 1.2 1.4 1.6 1.8</cell><cell>16</cell><cell>32</cell><cell>64</cell><cell>Z-curve [24] HRS [13] COML [30] COLg Lower bound [3]</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Vertex cache size</cell><cell></cell></row><row><cell cols="8">Fig. 8. 100% 75% 50% 25% 10% 0.6 0.7 0.8 0.9 1 Avg. cache misses per HRS [13] COML [30] triangle (ACMR) COLg</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Resolution</cell><cell></cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">This is not unrealistic; e.g. a call to malloc may return an address not aligned with a memory page or lower level cache block. Furthermore, we can show that this assumption is not needed if the mesh is large enough.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The input/output complexity of sorting and related problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1116" to="1127" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Cache Oblivious Data Structures. Handbook on Data Structures and Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Brodal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fagerberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Universal Rendering Sequences for Transparent Vertex Caching of Progressive Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bogomjakov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="page" from="137" to="148" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tile Size Selection using Cache Organization and Data Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Coleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mckinley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="279" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Deering</surname></persName>
		</author>
		<title level="m">Geometry Compression. ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Survey of Graph Layout Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Diaz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Petit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Serna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="356" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Constrained Strip Generation and Management for Efficient Interactive 3D Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Diaz-Gutierrez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhushan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gopi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics International</title>
		<imprint>
			<biblScope unit="page" from="115" to="121" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimizing Triangle Strips for Fast Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Skiena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="319" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Optimal linear arrangement of a rectangular grid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fishburn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tetali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Winkler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">213</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="123" to="139" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cacheoblivious algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Frigo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Prokop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramachandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="page" from="285" to="297" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Some simplified NP-complete graph problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="237" to="267" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the metric properties of discrete space-filling curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lindenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="794" to="797" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Optimization of mesh locality for transparent vertex caching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>ACM SIGGRAPH</publisher>
			<biblScope unit="page" from="269" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<title level="m">Streaming Meshes. IEEE Visualization</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="231" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Large Mesh Simplification using Processing Sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="465" to="472" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimal linear labelings and eigenvalues of graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Juvan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mohar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="153" to="168" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient compression and rendering of multi-resolution meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Karni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bogomjakov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="347" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multilevel k-way partitioning scheme for irregular graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="page" from="96" to="129" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Multi-scale Algorithm for the Linear Arrangement Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes In Computer Science</title>
		<imprint>
			<biblScope unit="volume">2573</biblScope>
			<biblScope unit="page" from="296" to="309" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Visualization of Large Terrains Made Easy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="363" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Optimal numberings of an N × N array</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mitchison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Durbin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM journal on Discrete and Algebraic Methods</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="571" to="582" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Towards optimal locality in mesh-indexings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Niedermeier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Reinhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="211" to="237" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Global Static Indexing for Real-time Exploration of Very Large Regular Grids. Supercomputing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Frank</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Space-Filling Curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sagan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Out-Of-Core Algorithms for Scientific Visualization and Computer Graphics. IEEE Visualization Course Notes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Correa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Contour Trees and Small Seed Sets for Isosurface Traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Oostrum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Computational Geometry</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="212" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Digital halftoning with space filling curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Velho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>De Miranda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gomes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<publisher>ACM SIGGRAPH</publisher>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">External Memory Algorithms and Data Structures: Dealing with MASSIVE Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="page" from="209" to="271" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-M</forename><surname>Wierum</surname></persName>
		</author>
		<title level="m">Logarithmic Path-Length in Space-Filling Curves. 14th Canadian Conference on Computational Geometry</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="22" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Cache-Oblivious Mesh Layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-E</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="886" to="893" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Cache-Efficient Layouts of Bounding Volume Hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-E</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Quick-VDR: Interactive View-Dependent Rendering of Massive Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-E</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Salomon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gayle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="131" to="138" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
