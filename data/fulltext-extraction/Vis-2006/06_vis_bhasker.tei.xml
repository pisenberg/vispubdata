<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Asynchronous Distributed Calibration for Scalable and Reconfigurable Multi-Projector Displays</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ezekiel</forename><forename type="middle">S</forename><surname>Bhasker</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pinaki</forename><surname>Sinha</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditi</forename><surname>Majumder</surname></persName>
						</author>
						<title level="a" type="main">Asynchronous Distributed Calibration for Scalable and Reconfigurable Multi-Projector Displays</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Multi-projector displays</term>
					<term>projector-camera systems</term>
					<term>geometric and color calibration</term>
					<term>distributed algorithms</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Centralized techniques have been used until now when automatically calibrating (both geometrically and photometrically) large high-resolution displays created by tiling multiple projectors in a 2D array. A centralized server managed all the projectors and also the camera(s) used to calibrate the display. In this paper, we propose an asynchronous distributed calibration methodology via a display unit called the plug-and-play projector (PPP). The PPP consists of a projector, camera, computation and communication unit, thus creating a self-sufficient module that enables an asynchronous distributed architecture for multi-projector displays. We present a single-program-multiple-data (SPMD) calibration algorithm that runs on each PPP and achieves a truly scalable and reconfigurable display without any input from the user. It instruments novel capabilities like adding/removing PPPs from the display dynamically, detecting faults, and reshaping the display to a reasonable rectangular shape to react to the addition/removal/faults. To the best of our knowledge, this is the first attempt to realize a completely asynchronous and distributed calibration architecture and methodology for multi-projector displays.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Large high-resolution displays created by tiling multiple display units in a 2D array <ref type="bibr" target="#b25">[26,</ref><ref type="bibr">6,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b9">10]</ref> are used regularly for many applications like visualization, training, simulation and collaboration. Projectors are usually preferred over LCD panels in such applications since the bezels bordering the LCD panels make them incapable of generating one seamless image. However, projection based tiled displays suffer from two other problems <ref type="figure">(Figure 3c</ref>). (a) The image is not geometrically matched across the projector boundaries. (b) The color and brightness of the image is non-uniform due to overlap in the projected area of adjacent projectors on the screen which appears doubly bright, and also due to varying color/brightness within and across projectors.</p><p>In the early days of tiled displays, prohibitive cost of projectors and driving engines limited the number of projectors to a handful allowing manual geometric alignment and color balancing of the display. With the advent of commodity projectors and PC clusters to drive them, displays with a large number of projectors are very affordable today. But, manual calibration methods are both infeasible and unscalable for such large displays. So, several camera-based calibration techniques have been devised to calibrate these displays automatically, repeatably and inexpensively <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr">11,</ref><ref type="bibr">3,</ref><ref type="bibr">25,</ref><ref type="bibr">4,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b28">29]</ref>.</p><p>All existing camera-based calibration techniques have a centralized architecture where one central machine/process bears the sole responsibility of achieving the geometric/color calibration by capturing specific projected patterns using a camera, analyzing them to generate the correction parameters, applying correction to different parts of the image to compensate for each projector's unique geometric and color artifacts, and finally shipping these images to the projectors to create a seamless display <ref type="figure" target="#fig_1">(Figure 1</ref>). The advantage of centralized calibration is in having a common global reference frame to address the pixel geometry and color. Thus, managing multiple display units to create a global seamless image is relatively easy.</p><p>However, centralized calibration is not scalable (increasing the number of projectors making up the display) or reconfigurable (changing the shape, aspect ratio and resolution of the display). Further, it is intolerant to faults, especially in the central server. In addition, deploying a centralized multi-projector display demands an educated user to set up the computers, projectors and camera appropriately, input the right parameters to the central server and maintain the whole set-up periodically.</p><p>Projectors today are affordable. Thus, building mammoth displays with billions of pixels by tiling hundreds of projectors is not unthinkable. At the other end of the spectrum, smaller, mobile and flexible "pack-and-go" displays are very much desired for applications like map and troop-movement visualization on the battlefield. They can even be used in public venues like schools and museums. A centralized calibration architecture inhibits the realization of the full potential of using projectors in these kinds of scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Main Contribution</head><p>In this paper we propose asynchronous distributed calibration of multi-projector displays where no central process/computer needs to know the number of projectors, their configuration, and the geometric/photometric relationship between the projectors a priori to create a seamless display. Our main contributions in this paper are the following.</p><p>1. First, we identify the minimal self-sufficient unit to realize the distributed asynchronous calibration -a plug-and-play projector (PPP). This consists of a projector, camera, computation and communication unit.</p><p>2. We formalize the architecture and capabilities of a display realized by the PPPs via a distributed asynchronous calibration process.</p><p>3. Finally, we propose an asynchronous distributed methodology that includes methods to (1) detect the number of neighbors of a PPP, (2) find the position of a PPP in a large display, (3) achieve geometric calibration and photometric blending in a distributed manner, (4) add and remove projectors from the display dynamically for flexibility, and (5) tolerate faults for robustness. Unique to these methods is the importance of camera-based communication -the use of visual feedback from the PPP's camera as a mode of communication.</p><p>Our distributed asynchronous calibration via plug-and-play projectors can be instrumental in using projectors for building mobile, flexible and easily deployable displays. One can imagine a layman user creating a display by just setting a few PPPs side by side without worrying anything about calibrating them. He can also rearrange the PPPs in a different configuration or add/remove PPPs to the existing configuration to create a display of different aspect ratio without bothering about calibration. The PPPs self-calibrate to display seamless imagery in all scenarios. In fact, this can spark and foster new paradigms of interaction, especially for collaboration and visualization. Each person can carry his own plug-and-play projector since they are cost-effective and light-weight. When more than one person meet for collaboration, their respective devices can be put together to create a seamless tiled display. Even in display walls made of a large number of PPPs, when one or more PPPs fail, the display can automatically reconfigure, recalibrate and function at a limited capability (lower resolution). In summary, our work enables self-calibrating tiled displays liberating the user from the responsibility of set-up or maintenance.</p><p>In the rest of the paper, we first give an overview of our system (Section 2). Then we describe the basic distributed methodology that would run asynchronously on the PPPs making up a multiprojector display, followed by descriptions of its advanced features: addition/removal of PPPs and fault tolerance (Section 3). We conclude by discussing the potential of our distributed calibration in realizing ubiquitous pixels (Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SYSTEM OVERVIEW</head><p>In this section we give an overview of the system and compare it with existing work. We first describe the plug-and-play projector, followed by the distributed calibration architecture, capabilities and assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Plug and Play Projectors (PPP)</head><p>Pixels, being the generalized purveyors of information, have been a critical commodity in any workspace with several functionalities including collaboration, visualization and interface. The particular form of pixels provided by projectors, i.e. photons cast onto an arbitrary surface from a distance, provides a unique flexibility and mobility to this useful commodity by liberating them from the spatial constraints imposed by other displays like CRT or LCD panels <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b27">28]</ref>. However, when used in isolation, projectors act like passive digital illumination devices, pixels from which cannot provide us the desired highend functionality, flexibility and mobility desired in a workspace. So, many researchers have proposed a marriage between projectors and cameras to provide 'intelligent' pixels <ref type="bibr">[25,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr">2,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr">1]</ref>. The display unit we propose next is largely inspired by such previous works. We propose a display unit consisting of a projector, a camera, and embedded computing and communication hardware <ref type="figure" target="#fig_2">(Figure 2</ref>). We call this networked and intelligent projector, the plug-and-play projector (PPP). Thus each PPP is a self-sufficient unit with the capacity to sense environmental changes (through the camera), adapt/react to those changes (through the computation unit) and share those changes with other PPPs if required (through the communication unit). We envision the use of these units like 'plug-and-play' lego pieces to create a scalable and reconfigurable display. Though inspired by other previous work, our PPP has some novel features. First, unlike previous smart projectors, the projector display and camera capture processes in our PPP need not be synchronized with each other. Second, this is the first time the complete potential of camera-based communications is harnessed, not only to calibrate but even to decide the position/configuration/neighborhood of each PPP in the display enabling a self-calibrating tiled display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Architecture</head><p>In a distributed architecture, we expect every PPP to take complete control of the part of the display it is responsible for <ref type="figure" target="#fig_1">(Figure 1</ref>). Each PPP can act like a client and request the appropriate part of the data from a traditional data server, that can itself be distributed. This data server is oblivious to the fact that the clients (the PPPs) requesting data are in reality display units. The PPPs are treated just like any other data-requesting client. Thus distributed methodologies are used in all aspects of multi-projector display including calibration, data handling and rendering.</p><p>Existing distributed rendering architectures like Chromium <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref> and SAGE <ref type="bibr">[27]</ref> use distributed methodologies only for rendering the pixels and use centralized architecture for calibration and data handling. This is the essential difference between these systems and our proposed system. In Chromium or SAGE, the user defines in the central server, the total number of display units and the relationship of the image projected by each unit with respect to the large image they are creating together. The centralized unit finally streams the appropriate data to the dumb display units or projectors.</p><p>The second advantage of our proposed system is asynchronous communication between different PPPs and also between the capture and projecting processes within the same PPP. This enables each PPP to start off as a lone unit in the display and then discover other PPPs in the environment and their configurations. However, note that during display of application data synchronization of the rendered frames is necessary. Since each display unit is just like a standard data requesting client, standard distributed synchronization approaches can be used for this purpose.</p><p>Capabilities: The proposed distributed asynchronous architecture provide the following capabilities. (a) The PPPs calibrate themselves geometrically and photometrically to create a seamless imagery without any input from the user -neither the total number of PPPs making up the display and their configurations (number of rows and columns) nor the number neighbors each PPP have and their identities. (b) Any PPP can be added to or removed from the pool of PPPs dynamically to scale/reshape/reconfigure the display. (c) In case of faults in PPPs, the display reconfigures itself automatically to a reasonable shape.</p><p>Assumptions: Following are the assumptions we make about the projector-camera setup in the PPP. (a) The camera of the PPP has a wider field-of-view(FOV) than the projector. Thus, the camera can see the image projected by its projector completely and also parts of the images projected by the neighboring PPPs. We assume that the camera can see about <ref type="bibr">1</ref> 3 of the FOV of the projectors in neighboring PPPs. (b) Since each camera captures a small part of the display, we use a low-resolution (640 × 480) inexpensive VGA video camera. (c) The camera and projector coordinate systems of a PPP and its neighbors are rotated by less than 45 degrees with respect to each other, a reasonable assumption for a rectangular array of PPPs on a planar display. (d) The cameras need not be synchronized with the projector in the PPP. However, following Nyquist sampling criteria, the frame rate of the camera should be double of that of the projector to assure that a pattern projected by the PPP or the adjacent PPP is not missed by the camera. If this criterion is not satisfied, projectors have to project their calibration patterns for more than one frame during calibration.</p><p>Role of Camera Based Communication: Since each PPP can sense changes in its neighbors via its own camera, a sensor/camera based communication mode is established between adjacent PPPs via analysis of the captured image. This communication channel enables critical capabilities like discovering local topology of the PPPs in the display array and detecting addition/removal of neighboring PPPs.</p><p>Camera-based communication can be used to communicate any information with no network overhead and hence can completely replace network-based communication channel. However, camera-based communication is compute-intensive. So, we retain a low bandwidth wireless communication unit on each PPP to allow network-based communication for tasks that would otherwise require complex computeintensive image processing. Thus we use network-based and camerabased communication effectively to balance the compute and network resources of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ASYNCHRONOUS DISTRIBUTED CALIBRATION</head><p>The asynchronous distributed calibration methodology follows a single-program multiple-data (SPMD) model in which every PPP executes the exact same program. In this section we describe our method for a display consisting of a fixed number of projectors. We augment this basic algorithm with more advanced capabilities in Section 3.4.</p><p>Each PPP runs two asynchronous processes, Capture and Compute <ref type="figure" target="#fig_2">(Figure 2</ref>), that communicate via a shared queue of images, Q, and a shared boolean CALIB. The Capture process captures images from the camera and enqueues them in Q. It only stores the images that reflect a change when compared to the last image enqueued in Q. The Compute process dequeues images from Q, analyzes them, and computes different configuration and calibration parameters. It is assumed that when the Compute process sends an image to be displayed on the projector, it keeps it projected unless and until asked to display another one. CALIB is used to denote the state of the PPP. A PPP can be in two states, (a) the calibration state when it calibrates itself and (b) the stable state when it projects application data on the display. Capture and Compute thus act like Producer-Consumer processes traditionally used in a distributed computing environment, and are assured mutual exclusion while accessing shared data structures.</p><p>Following are the SPMD algorithms for these processes. Parts of these programs handle addition/removal of PPPs and faults that are explained in Section 3.4.</p><p>Algorithm Process-Capture Image-Queue Q; Boolean CALIB; begin 1. I = Capture Image from Camera; 2. if CALIB then 3.</p><p>if (I is different from previous image in Q) then 4.</p><p>Enqueue I in Q; 5.</p><p>endif; 6. else 7.</p><p>Addition Request Data from Server; 9.</p><p>Correct and Project Data; 10.</p><p>Addition-Removal-Handling-for-Compute</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">endif; end</head><p>The Compute process is the core of our method. Our asynchronous distributed method starts running as soon as the projector is powered on and involves three steps. <ref type="figure">Figure 3</ref> illustrates the perception of each PPP about the presence of other PPPs in the environment and its configuration at the end of each of these steps.</p><p>1. Neighbor Discovery: In this stage each PPP checks for the existence of left, right, top or bottom neighbor using camera-based communication with adjacent PPPs.</p><p>2. Configuration Identification: Next, PPPs find the dimensions of the display array, their own coordinates in the array, and the IP addresses of all PPPs in the display. Camera-based communication between adjacent PPPs and network broadcast are used for this purpose.</p><p>3. Alignment: In this step, a seamless image is generated by calibrating the display geometrically and photometrically using networkbased communication. For geometric alignment a distributed homography tree technique is used. Intensity blending is used in the overlapping regions to achieve photometric seamlessness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Neighbor Discovery</head><p>The neighbor discovery starts with the assumption that none of the four neighbors (left, right, top or bottom) of a PPP exist. Each PPP projects a pattern consisting of clusters of colored blobs. The image captured by the camera of a PPP contains clusters from its own and part of the neighbor's projected pattern. The patterns are designed such that the colors and locations of the clusters can be analyzed to detect the presence/absence of the four neighbors. Following is the detailed description of the pattern used and the algorithm.</p><p>The Pattern: The pattern contains four clusters, each made of 5x5 array of square blobs <ref type="figure">(Figure 4</ref>). The locations of these clusters are optimized to avoid overlap of the clusters projected by adjacent PPPs and determine the maximum allowable overlap between adjacent PPPs. Our pattern allows a maximum of 200 pixels overlap (20% of the projector's resolution). Each cluster has a different color -red, green, blue or white respectively in top-left, top-right, bottom-left and bottom-right corners of the image. This allows a PPP to differentiate the clusters projected by itself from those projected by its neighbors. Following is the algorithm that generates the neighborhood information (Pseudocode Neighbor-Discovery-In-Compute in Appendix).</p><p>Identifying Location of the Clusters: First, we identify the centers of the blobs using standard blob detection techniques <ref type="bibr" target="#b23">[24,</ref><ref type="bibr">11]</ref>. Next, we spatially group the detected blobs into an array of clusters. We use a hierarchical agglomerative clustering approach <ref type="bibr">[8]</ref> that has time complexity of O(n 2 ln(m) ), where n is the total number of blobs in the image and m is the dimension of each cluster (5 in our case). This method does not need as input the total number of blobs present in the image and hence can handle asynchronous display of patterns from adjacent PPPs (Pseudocode Spatial-Cluster-in-Neighbor-Discovery in Appendix).</p><p>Identifying Color of the Clusters: Next, the color of each cluster is determined in three steps. (a) First, the color of each blob is detected by applying chromatic filters centered at the blob centers. The detected colors, being in the camera's color space may not coincide with the projected colors due to variations between the camera and projector color gamuts. So, we assign to each blob the projected color that has the minimum angular deviation with the detected color, in RGB space. (b) Due to small gamut variations across the projector and camera, all blobs in a cluster may not be assigned the same color. So cluster color is determined by majority voting of the colors of component blobs. (c) Next, each PPP creates a Chromatic Blob <ref type="table">Table (</ref>CBT) for each color. The CBT lists the centers of all detected blobs in the camera coordinate along with the id, color, and center of the cluster they belong to.</p><p>Identifying Owners of the Clusters: Any cluster detected by the PPP in the previous step either belongs to itself or to its adjacent PPP. We identify the owner of each cluster using the following three steps. We consider four connected neighbors and do all computations on the centers of clusters. (a) Since each PPP is guaranteed to see its own pattern before or along with the pattern of adjacent PPPs, first an axis-aligned bounding rectangle enclosing the PPPs own clusters is deciphered <ref type="figure">(Figure 4d</ref>). This can be done by finding the minimum x from the red and blue, maximum x from the green and white, maximum y from the blue and white and minimum y from the red and green CBTs.  <ref type="figure">Figure 4d</ref> shows the centers of the chromatically classified clusters and labels these centers to denote their ownership. The first letter of the labeling denotes the color (RGBW) and second letter denotes the ownership (S for self, and LRBT for its four neighbors). The CBT is also updated to include the owner of each cluster. Further, for each PPP, its neighborhood information is also resolved during this process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Configuration Identification</head><p>In the configuration identification step, each PPP finds the display array's dimensions, its own coordinates in it, and the IP addresses of all the PPPs in the display. Binary coded bit patterns embedded in the cluster of blobs are used to convey each PPP's beliefs about where it is in the display, and the total dimensions of the display. Every PPP starts by believing that it is the only node in a display of dimension 1 by 1. Multiple rounds of camera-based communication between adjacent projectors follow when each PPP updates its own row(r) and column(c), and the total rows(m) and columns(n). Update rules enable propagation of these parameters to all the PPPs in the display. This results in convergence to the correct configuration at each PPP. This is followed by a network-based communication step where each PPP gathers the IP address of all other PPPs in the display. Following is the detailed description of the pattern and process (Pseudocode Configuration-Identification-in-Compute in Appendix).</p><p>Pattern: The pattern for this step is derived by binary encoding all the clusters similarly. Each blob denotes 1 when off and 0 when on. The first two rows are used to encode the row r and column c of the PPP, and the third and fourth rows are used to encode the total number of rows and columns, m and n respectively. The last row is used to denote five status bits -the first four bits denote if r, c, m and n have converged to the final correct values on this PPP. The final bit isdone is turned on when all of the four status bits are set to denote the completion of the configuration identification process on this PPP. <ref type="figure" target="#fig_5">Figure 5</ref> shows an example of the binary encoding. Finding Display Dimensions and PPP Coordinates: Each PPP starts configuration identification by setting its (r, c) and (m, n) to (1, 1) and all its status bits to False, and projecting an image representing this state. Then, each PPP performs the following steps in an iterative manner till isdone is set indicating its convergence to the correct values of (r, c) and (m, n). Finding IP addresses of all PPPs: Next, each PPP broadcasts its coordinates in the 2D array along with its associated IP address over the network. On receiving this broadcast message, each PPP updates a table that maintains the coordinates of every PPP in the display along with the associated IP addresses. This step enables network communication between adjacent PPPs during alignment. Note that this step can be done before discovering the total number of display units and their configurations via a standard communication protocol like UPnP or Apple's Bonjour/ex-Rendez-Vous/ZeroConf. However, using a standard protocol does not allow a seamless integration of this step with the rest of the calibration methodology.</p><p>Handling Race Conditions: In an asynchronous system, it is possible that a neighbor of a PPP is performing its neighbor discovery step while the PPP is in its configuration identification step. This situation is detected by identifying appearances of new blobs in the captured image that are not present in the CBT. To handle this race condition, the PPP aborts its current step and goes back to the neighbor discovery step where it lets its neighbor know of its presence. It indicates this abortion by turning off its convergence bits which enables propagation of this information to other non-adjacent PPPs. This also allows all the PPPs in the display to stall their convergence until information from the new PPP propagates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Alignment</head><p>In this step the PPPs find their exact geometric relationship with each other (amount of overlap, relative alignment of images) and use it for geometric alignment and photometric blending. First, each PPP uses the Hungarian method to detect correspondence between the blobs in the CBTs with those in the projected pattern and computes the local homography with each neighbor. This, in turn, is used to compute the overlap with its neighbors and blend it photometrically. To align the images geometrically, we design a distributed homography tree technique that aligns the images from all PPPs with respect to one reference PPP to achieve a seamless display. Following is a detailed description of the process (Pseudocode in Appendix).</p><p>Correspondence Detection Using Hungarian Method: Previous methods would correspond detected blobs in the camera space with the projected blobs in two different ways. (a) <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b27">28]</ref> binary code the blobs and project them in a time sequential manner. (b) <ref type="bibr">[11,</ref><ref type="bibr">3]</ref> project all blobs in one frame and then determine some distance parameters to walk along the blobs in a scan-line order in projector coordinate space. Usually additional patterns are projected to calibrate these parameters. Both methods use multiple patterns for correspondence detection. In an asynchronous distributed system as ours, tracking multiple frames from each PPP is not viable. So, we devise a novel way to detect correspondences using the Hungarian method.</p><p>The Hungarian method is a strongly-polynomial combinatorial optimization algorithm due to Kuhn <ref type="bibr" target="#b16">[17]</ref> and later revised by Munkres <ref type="bibr">[22]</ref>. It is used to solve bipartite matching (i.e., the assignment problem). The spatial clustering that generates the clusters in the neighbor discovery stage does not impose any order to the clustered blobs. To find the order, we generate a generic template by finding the axisaligned bounding rectangle for the detected cluster and populating it with a 5×5 array of indexed blobs. Then, a cost matrix is computed by taking the Euclidean distance between every detected-template blob pair. Each element represents the "error" induced when suggesting that particular assignment. The Hungarian algorithm then operates on this matrix to find the assignment of detected-blobs to template-blobs that minimizes total assignment error (the sum of the square of all distances). Thus, we order the blobs robustly and automatically. From the known order and color of the blobs we can find the exact correspondence of blobs between the camera and projector coordinates.</p><p>The Hungarian method however is applicable only in scenarios where the cameras and projectors of adjacent PPPs are rotated by less than 45 degrees with respect to each other. This is a reasonable assumption for rectangular planar display. However, for more general arrangements of projectors, the color coding of the clusters can be used to provide more information to this method, so that larger relative angles between the cameras can also be tolerated.</p><p>Local Homography Calculation: Next, the correspondences are used to calculate homographies, a linear relationship tying the different device coordinates. Let the projector of a PPP be denoted by P and the camera by C. The homography between two devices A and B is denoted by H(A → B). Each PPP calculates the self homography relating the PPPs own projector and camera, H(C r,c → P r,c ). It also computes the local homography to each neighbor, H(P (r+k),(c+k) → P r,c ) where k ∈ {−1, 0, 1}, as H(P (r+k),(c+k) → C r,c ) × H(C r,c → P r,c ).</p><p>Local Photometric Blending: Using local homographies, each projector finds the overlap with its neighbor and applies a linear or cosine blending (in the horizontal or vertical direction) to the RGB colors in this region <ref type="bibr" target="#b28">[29]</ref>.</p><p>Distributed Geometry Alignment: We design a distributed methodology for the homography tree technique <ref type="bibr">[3]</ref> to achieve geometric alignment. This starts with election of a PPP close to the center of the display as the root of the homography tree. All other PPPs align themselves with respect to the root. The homography tree is built in a breadth-first fashion in O(ln(mn)) steps using networkbased communication across adjacent PPPs. The process is initiated by the root. Each PPP sends its homography-to-root to all its neighbors who augment this with their local homographies to generate their own homography-to-root. This augmentation-propagation continues until all nodes have computed their homography-to-root. Note that just as in centralized homography tree technique, errors can accumulate along the paths from the root creating larger errors at PPPs which are further away from the root. In our system, we experience a maximum error of 2-3 pixels. However due to limitations in human perception, this error is only visible in special patterns like grids or checkerboards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Advanced Features</head><p>Of the five capabilities mentioned in Section 2.2, till now we have achieved a − c. Now, we present advanced capabilities d − e to realize truly scalable reconfigurable displays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Adding and Removing Projectors</head><p>We design methods to handle addition and removal of PPPs to a calibrated display (in stable state). The PPP cameras detect addition/removal of neighboring PPPs automatically and broadcast the information to all the existing PPPs. Upon receiving this broadcast, all PPPs switch to the calibration phase in order to reconfigure the display (Pseudocode in Appendix).</p><p>Detecting Addition/Removal: Each PPP uses its local homographies to segment the image into regions corresponding to non-overlap areas, neighbor overlap areas, and empty areas (where no PPP has projected). This segmentation can be done apriori during the alignment step of calibration. In the stable state, an addition is signaled by detection of non-black pixels in an empty region (using simple image processing techniques). Similarly, a removal is signaled by detection of a completely black neighbor region. When a PPP detects an addition or removal, it broadcasts a re-calibrate message to all other PPPs.</p><p>Reshaping the Display: In the case of addition, a simple recalibration achieves reshaping of the display. However, since a removal creates a hole in the display, some PPPs need to be deactivated to reshape the display. For this, the message broadcasted during removal contains the coordinates of the deleted PPP. Using this information, the PPPs who are on the path to the nearest vertical and/or horizontal boundary from the removed PPP deactivate themselves. The other PPPs then recalibrate to reshape the display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Handling Faults</head><p>We envision hundreds of PPPs making a tiled display, especially in a public venue. In such scenarios it is a desirable to handle faults allowing the display to run at a lower capability even when the fault is being attended to. So, in this section, we handle the most common fault of bulb outage.</p><p>If the fault occurs in the stable state, it is handled exactly like removal of a PPP. If the fault occurs after the configuration identification step of calibration, we devise the following mechanisms to advance all the PPPs to the stable state where this is handled as a removal. Two cases occur as follows. (a) If the faulty PPP is not the root, all the PPPs proceed to stable state automatically. (b) If the faulty PPP is the root, the alignment stalls. We handle this using the invariant that Q must be empty after completion of Identification (since no change in patterns happen). So, the faulty root is detected by the neighboring PPPs by the existence of a non-empty Q. These PPPs broadcast a message asking everyone to advance to stable state. On receiving this message, all PPPs comply and move to the stable state.</p><p>A fault during or before the configuration identification step can be detected from the the IP-Address Table in the following manner. (a) If the top-left PPP initiating the forward propagation fails, a conflict results in the IP-Address-Table with more than one PPPs having (r, c) = (1, 1). 2. If any other PPP fails, it is detected as a hole in the IP-Address- <ref type="table">Table i</ref>.e a possible (r, c) pair is absent. Both the conflict and the hole can be resolved by deactivating some PPPs as in removal of PPPs in stable state. However, in this case, instead of recalibration, the other PPPs will predict the removals and update their configuration parameters (r, c, m, n) and the IP-Address-Table appropriately to instrument the reshaping in the subsequent alignment step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Implementation and Results</head><p>We simulate a distributed asynchronous system on a 3x3 array of 9 projectors. We augment each projector with a small video camera and a networked computer to simulate a PPP. For initial algorithm design and testing we decided to work with a simulation where we mimic the asynchronous environment by choosing the PPPs at random and the part of the SPMD code to be executed on the chosen PPP at a random granularity. This process repeats till all PPPs complete the execution of their SPMD program. Our calibration takes less than a minute assuming all PPPs have comparable speeds. <ref type="figure" target="#fig_7">Fig 6 demonstrates</ref> addition/removal of projectors. Our supplemental video shows live results of the entire system at work. In most of the video, we deliberately slow down the calibration process by a factor of six to eight to aid better understanding. A high quality version of the video can be found at ¡http://www.ics.uci.edu/ psinha/visvideo.htm¿.</p><p>The current implementation of our method can be made more robust. For example, the current prototype is unable to detect slight movements in the PPPs to trigger a recalibration. It can also be confused by spurious lighting in the display surroundings detecting it as addition of a PPP. Further, a black frame in one of the PPPs can be detected as removal by the adjacent PPP. However, these can be easily improved by a advanced image processing, simple network-based communications or inexpensive augmented hardware. For example, looking for the neighbor discovery patterns in the newly lighted display surroundings can easily differentiate the addition of a PPP from spurious lightings. The removal detection can be made robust by communication and processing "I am alive" messages across PPPs. This is a common approach to detect faulty nodes in distributed systems. Similarly, slight movements in the PPPs can be handled if each PPP is augmented with an inexpensive motion sensor. Note that using more than one of different types of sensors while generating such a smart device has been common in previous works. Examples include a tilt sensor in the iLamps <ref type="bibr">[25]</ref> and more than one camera in the projector bricks of <ref type="bibr" target="#b4">[5]</ref>. Augmentation of PPPs by such devices does not reduce the effectiveness of our framework and prototype in any way. Our PPP is the minimal intelligent display unit that can provide the hot plug-and-play feature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSION</head><p>There has been a plethora of work on automatic calibration of multiprojector displays in the last decade. Yet, such displays are still not commonplace, the biggest inhibition being the complexity of setting them up. Our asynchronous distributed calibration methodology has the potential to remove this final barrier and make multi-projector displays truly commodity products. To the best of our knowledge, this is the first work for distributed calibration.</p><p>Some areas we would like explore in immediate future are as follows. (a) Homography tree technique calibrates every PPP to a root PPP and is prone to inaccuracies. <ref type="bibr">[3]</ref> refers to a centralized error diffusion method to address this method that is not amenable for distributed methodologies. We are currently working on local geometric calibration methodologies that can work without relying on a root PPP. (b)We would like to address the photometric non-uniformity within and across projectors beyond blending the overlap region by designing distributed versions of the existing more rigorous photometric calibration methods like <ref type="bibr" target="#b19">[20]</ref>. This would involve addressing the varying dynamic range and color gamut of the sensors. (c) We would like to design an embedded hardware that can efficiently implement our distributed asynchronous method in each PPP. (d) We would also like to extend the method to existing display infrastructures which may not have a camera for every projector, by addressing the more general problem of calibrating m projectors using and n cameras, where m = n, in a distributed fashion.</p><p>Moving Towards Ubiquitous Pixels: Distributed calibration can have a bigger impact than just for scalable displays. Ubiquitous pixels -pixels anywhere and everywhere -have been envisioned by contemporary researchers as a critical component of any future workspace <ref type="bibr">[7,</ref><ref type="bibr" target="#b13">14]</ref>. Other critical components of future workspaces like large scale data generation and processing, ubiquitous computing, high performance networking, rendering and resource management middleware has seen significant work supported by national initiatives like TeraGrid and OptIPuter <ref type="bibr">[16,</ref><ref type="bibr">15,</ref><ref type="bibr" target="#b8">9]</ref>. However, ubiquitous pixels are yet to be realized by today's display technology. The key challenges are to develop methodologies to handle non-planar, non-Lambertian and non-white surfaces. We believe that our asynchronous distributed calibration via PPPs is the first step in that direction, and has tremendous potential in realizing such ubiquitous pixels "flooding" our workspaces.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>All authors are with Department of Computer Science, University of California, Irvine, E-mail: {ebhasker,psinha,majumder}@ics.uci.edu. Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Centralized (left) and distributed (right) system architecture for multi-projector displays.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Left: A Plug-and-Play Projector (PPP); Right: The processes on a PPP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>A multi-projector display made of 9 PPPs, if allowed to project data (a) at power on would display the entire data since it thinks it is the lone display unit responsible for data display; (b) at the beginning of Configuration Identification process when it is aware that other PPPs would share the responsibility of data display, but thinks that it's position is (1, 1) and displays the first 1024 × 768 part of the image; (c) after Configuration Identification step would display the right part of the image, but geometrically and photometrically uncalibrated; and (d) finally, after Alignment would project the seamless image. (d) is the only image that the user would see, rest are used for illustration. (a) The pattern projected by the projector of a PPP in Neighbor Discovery step. (b) The pattern seen by the camera of a PPP when all its adjacent projectors, and itself are projecting the pattern in (a). (c) The pattern seen by the camera of a PPP when only two of its neighbors and itself are projecting the pattern. Due to the asynchronous nature of the system, there is no guarantee that all the PPPs project their pattern at the same time and this situation is likely to occur. (d) blob cluster centers and bounding rectangle used to determine cluster ownership.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>(b) Next each cluster is assigned its closest corner in the rectangle. (c) Finally, based on the color of the cluster and its associated rectangle corner, the ownership of the cluster is resolved. For example, three clusters, red, green, and white, associated with the top right corner of the rectangle belong to the right neighbor, self, and top neighbor respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>The binary encoded grids with (r, c) = (1, 3), (m, n) = (2, 3), (r s , c s ) = (True, True) and (m s , n s , isdone) = (False, False, False) (left) and (r, c) = (2, 3), (m, n) = (3, 3), (r s , c s ) = (True, True) and (m s , n s , isdone) = (Ture, True, True) (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(a) First, the PPPs capture the image of the encoded bit patterns and decipher the (r, c), (m, n) and the status bits of the neighbors from the image captured by the camera. This is done by analyzing the presence or absence of blobs at the blob centers stored in the CBTs. (b) Next, this information is used to update its own (r, c) and (m, n) and status bits following some update rules (Pseudocode Update-IDsin-Configuration-Identification in Appendix). (c) Finally, the PPP changes the embedded binary coding in its clusters and projects an updated image representing the new state.The above steps on each PPP result in propagation of the values of the encoded parameters in the following way. (a) The PPP with no left and top neighbor (top-left PPP in the array) initiates the process and indicates that its (r, c) of (1, 1) has converged by setting appropriate status bits. (b) Each PPP updates its (r, c) parameters from the top or left neighbor. This process continues and the row and column changes propagate from the top-left of the display to the bottom-right in a breadth-first manner, where PPPs in the same level of the tree perform updates in parallel. This front propagation of (r, c) completes in O(ln(mn)) steps. (c) When the bottom right projector detects convergence of its (r, c) parameter, it sets the (m, n) to be the same as its (r, c) and turns on its isdone status bit to indicate convergence to the correct configuration parameters. (d) Each PPP now updates its (m, n) and isdone from the bottom or right neighbor, leading to a back propagation of parameters from the bottom-right to top-left of the display, again in a breadth-first manner in O(ln(mn)) steps. Thus each PPP discovers the correct configuration parameters using only camera-based communication between adjacent projectors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Two projectors are added to a 2 × 2 PPP display (a) to make it a 2 × 3 PPP display (b). When one projector is removed from a 3 × 3 PPP display (c), the display reshapes itself by switching off the appropriate rows and columns to generate a 2 × 2 PPP display (d).</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>Algorithm Neighbor-Discovery-in-Compute begin 1. Project Pattern; 2. I = Dequeue image from non-empty Q; 3. Find all clusters in I; (Spatial Clustering) 4. Find color, owner and centroid of each cluster; 5. Create global Chromatic Blob <ref type="table">Tables (CBT)</ref> for red, green, blue and white; 6. Update neighborhood information; end Algorithm Alignment-in-Compute begin 1. Root = FALSE; 2. forall neighbors = φ do 3.</p><p>Compute Local Homography to Neighbor; 4.</p><p>Find Overlap with Neighbor and Apply Blending; 5. endfor 6. if (I am the center PPP) then 7.</p><p>Root = TRUE; Homogrphy-to-Root = I; 8. else 9.</p><p>(H, S) = Recieve Homography H and sender ID S from non-empty Msg-Buf; 10.</p><p>Homography-to-Root = H× Homography-to-S; 11. endif 12. Send MSG(Homography-to-Root, myID) to all neighbors; 13. Clean Up Msg-Buf to delete unused homographies; end Algorithm Configuration-Identification-in-Compute begin</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Access grid: Immersive group-to-group collaborative visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Disz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Olson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Udeshi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Immersive Projection Technology</title>
		<meeting>Immersive Projection Technology<address><addrLine>Ames, Iowa</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A flexible projector-camera system for multi-planar displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ashdown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Flagg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sukthankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Rehg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Computer Vision and Pattern Recognition (CVPR)</title>
		<meeting>Computer Vision and Pattern Recognition (CVPR)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalable alignment of large-format multi-projector displays using camera homography trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sukthankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic alignment of high-resolution multi-projector displays using an uncalibrated camera</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Housel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Adaptive instant displays: Continuously calibrated projections using per-pixel light control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cotting</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ziegler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Eurographics</title>
		<meeting>of Eurographics</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="705" to="714" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Surround-screen projection-based virtual reality: The design and implementation of the CAVE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cruz-Neira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Sandin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Defanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Siggraph</title>
		<meeting>ACM Siggraph</meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Ubiworld: An environment integrating virtual reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Disz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Heterogeneous Computing Workshop</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Pattern Classification and Scene Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Duda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hart</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973" />
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Grid: Blueprint for a New Computing Infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kesselman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Introduction to building projectionbased tiled display systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hereld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Judson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Dottytoto: A measurement engine for aligning multi-projector display systems. Argonne National Laboratory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hereld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">R</forename><surname>Judson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<idno>preprint ANL/MCS-P958-0502</idno>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Wiregl: A scalable graphics system for clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Everett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Chromium : A stream processing framework for interactive rendering on clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ahem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Klosowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions of Graphics</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The interactive workspaces project: Experiences with ubiquitous computing rooms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johanson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Winograd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Pervasive Computing Magazine</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient resource description and high quality selection for virtual grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-S</forename><surname>Kee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Logothetis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Chien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Cluster Computing and the Grid (CCGrid)</title>
		<meeting>the IEEE Conference on Cluster Computing and the Grid (CCGrid)</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Orcutt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Smarr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leigh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kilb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Renambot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Venkataraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Defanti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fialko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hidley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hutches</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<title level="m">The optiputer: a new approach to volume visualization of large seismic datasets. Ocean Technology Conference</title>
		<imprint>
			<date type="published" when="2004-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The hungarian method for solving the assignment problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Naval Research Logistics Quarterly</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="83" to="97" />
			<date type="published" when="1955" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Early experiences and challenges in building and using a scalable display wall system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Damianakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Essl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shedd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tzanetakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Achieving color uniformity across multi-projector displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Majumder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Towles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Welch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Color nonuniformity in projection-based displays: Analysis and solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Majumder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2003-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Perceptual photometric seamlessness in tiled projection-based displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Majumder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2005-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Algorithms for the assignment and transportation problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Munkres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of SIAM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="32" to="38" />
			<date type="published" when="1957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The everywhere displays projector: A device to create ubiquitous graphical interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pinhanez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Ubiquitous Computing</title>
		<meeting>Ubiquitous Computing<address><addrLine>Georgia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Multi projector displays using camera based registration. Proceedings of IEEE Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Towles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Seales</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Forlines. ilamps: Geometrically aware and self-configuring projectors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Baar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Beardsley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Willwacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The office of the future: A unified approach to image based modeling and spatially immersive display</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Raskar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Welch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cutts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Stesin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Siggraph</title>
		<meeting>ACM Siggraph</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Sage: the scalable adaptive graphics environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Renambot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Krishnaprasad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vishwanath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chandrasekhar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Spale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leigh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WACE</title>
		<meeting>WACE</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Pixelflex: A reconfigurable multi-projector display system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gotz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hensley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Towles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Camera based calibration techniques for seamless multi-projector displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Majumder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2005-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Grids and Project ID Pattern</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>I = Dequeue</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Update r,c,m,n and the status; (Update-IDs) 12. else // New neighbor is detected 13</title>
		<imprint/>
	</monogr>
	<note>Project Neighbor Discovery Pattern</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Find new grids in I and add to CBTs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Update neighborhood information</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Reset (r, c, m, n) to 1 and status bits to FALSE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>= C S = T Rue; Isdone</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
	<note>if (I am the top left PPP) then 18</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Msg(</forename><surname>Broadcast</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ip</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Receive Msg from non-empty Msg-Buf</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Update</forename><surname>Create</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ip</surname></persName>
		</author>
		<imprint>
			<publisher>Address-Table</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fault-Handling</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m">end Algorithm Update-IDs-in-Configuration-Identification begin 1. (r, c) = (max(r(L), r(T ) + 1), max(c(L) +</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">m, n) = (max(r, m(B), m(R)), max(c, n(B)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Output: An array Cluster such that if Blob[i] and Blob[ j] belong to same cluster</title>
	</analytic>
	<monogr>
		<title level="m">Algorithm Spatial-Cluster-in-Neighbor-Discovery (Blob) Input: An array Blob of (x, y) coordinates of the blobs</title>
		<imprint/>
	</monogr>
	<note>then Cluster[i] = Cluster[ j]. i][j] = dist(Blob[i],Blob[j]) (d[i][j] ¡ threshold) AND (Cluster[i] ¿ Cluster[j]) 14. Cluster [i] = Cluster [j</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Algorithm Addition-Removal-Handling-for-Compute begin</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Recv Msg from non-empty Msg-Buf</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Calib = T Rue</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">DELETE-Msg) 5. (nr, nc) = row and column extracted from Msg</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">if (r between nr and closest vertical boundary to nr) or (c between nc and closest horizontal boundary to nc ) then 7</title>
		<imprint/>
	</monogr>
	<note>Deactivate myself</note>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Update (r, c, m, n) to reflect the new configuration</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Algorithm Addition-Removal-Handling-for-Capture begin</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Process I to detect add or removal</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Broadcast MSG(Add/Removal, r, c)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Calib = T Rue</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
