<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Out-of-Core Remeshing of Large Polygonal Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minsu</forename><surname>Ahn</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Igor</forename><surname>Guskov</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Seungyong</forename><surname>Lee</surname></persName>
						</author>
						<title level="a" type="main">Out-of-Core Remeshing of Large Polygonal Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We propose an out-of-core method for creating semi-regular surface representations from large input surface meshes. Our approach is based on a streaming implementation of the MAPS remesher of Lee et al. [18]. Our remeshing procedure consists of two stages. First, a simplification process is used to obtain the base domain. During simplification, we maintain the mapping information between the input and the simplified meshes. The second stage of remeshing uses the mapping information to produce samples of the output semi-regular mesh. The out-of-core operation of our method is enabled by the synchronous streaming of a simplified mesh and the mapping information stored at the original vertices. The synchronicity of two streaming buffers is maintained using a specially designed write strategy for each buffer. Experimental results demonstrate the remeshing performance of the proposed method, as well as other applications that use the created mapping between the simplified and the original surface representations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Modern 3D acquisition technology can easily produce huge surface meshes with high precision and fine detail. The medical visualization and computational simulation applications can also be sources of extremely large surface meshes. Data structures needed for efficient and complex processing of such meshes may not always fit into the main memory and a special class of out-of-core mesh processing algorithms has been introduced in the recent years. These include outof-core approaches for rendering, simplification, and compression of large meshes <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b13">14]</ref>. In addition, approaches for external generalpurpose mesh data structures were proposed <ref type="bibr" target="#b2">[3]</ref>. These out-of-core processing tools work for arbitrary surface meshes with irregular connectivity. For regular connectivity meshes, such as terrains, more efficient algorithms can be developed in general <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b22">23]</ref>.</p><p>The benefits of regular and semi-regular mesh connectivity and sampling have been shown for rendering and compression applications <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b20">21]</ref>. Semi-regular surface remeshing algorithms convert an irregular connectivity mesh into a semi-regular surface representation that consists of a number of regularly sampled patches forming a subdivision connectivity mesh. A number of semi-regular remeshing algorithms has been proposed for in-core meshes <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b23">24]</ref>. There are also a number of irregular mesh remeshing approaches that improve the sampling and connectivity properties of a given input mesh without producing a structured representation <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b25">26]</ref>. Often, the goal is to produce a mesh optimal to use in a finite-element simulation.</p><p>Many of the huge surface meshes found in practical applications are relatively smooth and can therefore benefit from conversion into a semi-regular form. Unfortunately, most of the currently available remeshing procedures cannot deal with extremely large meshes. In this paper, we introduce an out-of-core approach to remeshing.</p><p>As is common in many other semi-regular remeshing approaches, our out-of-core remeshing algorithm builds a base mesh which serves as the coarsest level of the multiresolution output mesh, and parameterizes the input mesh so that each input vertex corresponds to a point on the base mesh. Our approach is based on the MAPS algorithm of Lee et al. <ref type="bibr" target="#b17">[18]</ref>. We use a streaming mesh strategy to enable out-of-core processing of large input meshes. That is, an out-of-core streaming mesh and the accompanying mapping information file are maintained in-sync during the simplification stage of the MAPS algorithm in order to build the parameterization map. The final resampling stage uses the parameterization map to produce a semi-regular surface mesh approximating the input surface.</p><p>Contributions Our main contribution is to introduce an out-ofcore semi-regular surface remeshing algorithm that can establish a correspondence between a coarse base domain and a very large input surface mesh. We test our out-of-core remeshing procedure on a number of large meshes and explore the approximation and compression performance of our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK 2.1 Out-of-Core Algorithms</head><p>There exist several approaches for out-of-core mesh processing, such as cutting the mesh into pieces, clustering mesh vertices, using external memory mesh data structures, and processing stream data.</p><p>The mesh cutting is a straightforward approach for out-of-core mesh processing. It divides a large mesh into pieces small enough to be kept in main memory and then processes each piece separately while maintaining the cut boundaries among the pieces. Many techniques based on mesh cutting have been presented to simplify <ref type="bibr" target="#b11">[12]</ref> and compress <ref type="bibr" target="#b9">[10]</ref> out-of-core meshes. However, this approach typically lowers the quality of the output, especially around the boundaries of pieces.</p><p>Lindstrom <ref type="bibr" target="#b18">[19]</ref> proposed an efficient mesh simplification algorithm using a vertex clustering technique <ref type="bibr" target="#b21">[22]</ref>. While reading triangles of a given mesh, vertices in the data are accumulated in a voxel grid whose complexity is independent from that of an input mesh. The output mesh complexity should be capable of being stored in-core and depends on the size of the voxel grid. A non-uniform clustering technique has been proposed in <ref type="bibr" target="#b24">[25]</ref> but the output mesh complexity is still bounded by the size of main memory.</p><p>Another approach for processing large meshes uses external memory data structures. Cignoni et al. <ref type="bibr" target="#b2">[3]</ref> use an octree-based external memory mesh to simplify large models with a sequence of edge contractions. At run-time, only the selected leaf nodes are loaded dynamically in main memory while most nodes are stored on a disk. Similarly, Isenburg and Gumhold <ref type="bibr" target="#b12">[13]</ref> compress an out-of-core mesh based on region growing. However building external memory data structures is expensive in time and space.</p><p>Recent out-of-core surface processing approaches use streaming representations formalized by Isenburg and Lindstrom <ref type="bibr" target="#b14">[15]</ref>. These approaches combine the efficiency of vertex clustering with the explicit connectivity of an external memory data structure. The basic idea of a streaming algorithm is that the input meshes stream from the input files without reading backward and a partial input mesh fits in the main memory. Wu and Kobbelt <ref type="bibr" target="#b27">[28]</ref> simplify massive meshes by streaming a coherent triangle-soup <ref type="bibr" target="#b18">[19]</ref> into a limited-size triangle</p><formula xml:id="formula_0">Domain Buffer B d Map Buffer Bm Input Read Write Input Mesh Input Map Output Mesh Output Map File F l d File F l m File F l−1 d File F l−1 m Simplify End M l−1 is small Yes No Yes No Can read vertices from Update Map Write Read enough? F l m ? Next level (l ← l−1) Next level (l ← l−1) Fig. 1</formula><p>. Overall parameterization process operates on the simplified domain mesh and the vertex file storing the parametric mapping information. We repeat three steps in each buffer; read, simplify, and write partial meshes in the domain buffer and read, update, and write the mapping information in the map buffer.</p><p>buffer, in which they perform edge collapses. Our approach also uses streaming, and the main challenge here is the synchronization of the two meshes (original and simplified) which are at two different levels of resolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Remeshing Algorithms</head><p>Over the past ten years, several semi-regular remeshing algorithms have been proposed. Many of these algorithms follow the general pipeline established by Eck et al. <ref type="bibr" target="#b4">[5]</ref>: first, the structure of the base domain is established, then the parameterization mapping the original mesh onto the base domain is constructed, and finally, the output semi-regular mesh is produced by the resampling stage.</p><p>There are two popular approaches for producing the base domain: the Voronoi diagram approach and the simplification approach. The original paper of Eck et al. <ref type="bibr" target="#b4">[5]</ref> introduced the discrete Voronoi diagram as a way of constructing the charts for the input surface. A number of seeds are placed onto the mesh, and a flooding approach is used to produce the Voronoi tile structure. A triangle mesh of the base domain is obtained by creating the dual of the tile graph.</p><p>The simplification approach for constructing the base domain was introduced in the MAPS algorithm <ref type="bibr" target="#b17">[18]</ref>. This approach has been used in many remeshing algorithms since it can incorporate user-specified feature lines into parameterization. The MAPS approach is also inherently multi-resolution and can serve as a basis for building efficient surface resampling algorithms, such as <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b23">24]</ref>, which construct semi-regular meshes that satisfy some additional requirements (e.g., global smoothness).</p><p>The MAPS simplification not only builds the structure of the base domain but also constructs the parametric mapping for the input mesh vertices. As noted by Khodakovsky et al. <ref type="bibr" target="#b15">[16]</ref>, the resulting parameterization has low distortion if the base domain is sufficiently fine. When a very coarse base mesh is required, some additional steps need to be taken to ensure non-distorted parameterization <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b23">24]</ref>. For large fine input meshes used in practice, the remeshing process can be split into two stages: the out-of-core MAPS parameterization from the huge input mesh onto a sufficiently fine intermediate base domain and an additional parameterization step that maps this intermediate base domain onto a desired coarse base domain using an in-core semiregular or even regular parameterization method, such as geometry images <ref type="bibr" target="#b6">[7]</ref>.</p><p>Geometry image is a completely regular representation for approximating the geometry of an irregular mesh. Geometry images and their extensions can be efficiently rendered using current graphics hardware and have good compression properties <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>Irregular remeshing methods have a goal of producing meshes with good triangle quality and approximation properties. Alliez et al. proposed the remeshing algorithm which uses a series of 2D maps in the parametric space <ref type="bibr" target="#b1">[2]</ref>. Using these maps, this algorithm can apply operations such as signal processing and half-toning. Surazhsky and Gotsman <ref type="bibr" target="#b25">[26]</ref> presented a remeshing scheme applying a series of efficient local operations, instead of processing on a global parametric domain. Area-based smoothing controls triangle quality and resampling over the mesh. To perform local modifications, this technique uses dynamic overlapping parameterization. Alliez et al. <ref type="bibr" target="#b0">[1]</ref> presented an anisotropic remeshing method, which uses curvature direction to drive the remeshing process. Lines of minimum and maximum curvatures are used to determine adequate edges.</p><p>All of the techniques described in this section are the remeshing algorithms for in-core meshes which assume that input meshes are sufficiently small to fit into the main memory. Our goal is to produce an out-of-core remeshing procedure for very large input meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OVERALL PROCESS</head><p>Our out-of-core semi-regular remeshing technique is based on the MAPS algorithm <ref type="bibr" target="#b17">[18]</ref>. However, we cannot directly apply this algorithm for remeshing when a given mesh M is an out-of-core mesh that cannot fit into the main memory. Since the data structures for M and its parameterization information cannot be stored in memory, we have to revise each step of the MAPS algorithm. For simplification, we adapt a streaming-based approach <ref type="bibr" target="#b27">[28]</ref> where a mesh can be simplified iteratively with a fixed-size buffer and a streaming file. To maintain and update the parametric mapping information, we store the information in another file and stream it through a buffer in a synchronized way with simplification. The vertex position resampling for a semi-regular mesh is achieved by traversing the parameterization stored in the final mapping information file. <ref type="figure">Fig. 1</ref> illustrates the overall process for obtaining the parameterization. In the process, the original mesh M = M L is successively simplified to a series of homeomorphic meshes M l with 0 ≤ l ≤ L until the base mesh M 0 is derived. For simplification and parameterization information updates, we use two buffers: the domain buffer and the map buffer. The domain buffer is used to contain a partial mesh of M l when we simplify M l to M l−1 using mesh streaming. The map buffer is used to store and update the parameterization information for the part of M l which is being simplified.</p><p>We assume that M is a 2-manifold mesh with triangle faces. Each simplified mesh M l is stored in a mesh file F l d . The parameteriza-tion information that maps the vertices of M onto the surface of M l is stored in a map file F l m . The following steps summarize the process of simplifying a mesh M l to M l−1 . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Read the faces of mesh</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Repeat all the previous steps until we finish simplifying the mesh</head><formula xml:id="formula_1">M l to M l−1 .</formula><p>As a result of the parameterization process, the mapping information from the given mesh M onto the base mesh M 0 is stored in the file F 0 m . In the resampling process, we first determine the vertex set and connectivity of a semi-regular mesh by recursively subdividing the base mesh M 0 . The vertex positions of the semi-regular mesh are obtained by resampling the shape of M using the mapping information. More details of the resampling process will be explained in Sec. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PARAMETERIZATION 4.1 Parametric Domain Creation</head><p>To generate a parametric domain, we simplify an input mesh to the base mesh. Many techniques for mesh simplification have been proposed <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b5">6]</ref>. In this paper, we perform a sequence of half-edge collapses (hecols) to simplify the given mesh. Using a priority queue of edges, we choose and remove the candidate edge with the lowest quadric error metric <ref type="bibr" target="#b5">[6]</ref>.</p><p>Additionally, we use the triangle quality <ref type="bibr" target="#b15">[16]</ref> to achieve a better quality of triangle shapes in the base mesh. Before we apply hecol to a candidate edge, we estimate the quality of triangles which will be modified by the hecol. If one of the triangles has a lower quality than the user-defined threshold, then we do not apply hecol to this edge. We also consider the normals of the vertices that are connected by the candidate edge. We do not apply hecol to an edge if the angle between the normals is larger than the threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Update of Parameterization Information</head><p>Similar to MAPS <ref type="bibr" target="#b17">[18]</ref>, we represent the parameterization of a vertex in the given mesh M as a mapping information (i, α), where i is a face index in the current simplified mesh M l and α is the barycentric coordinates in the face. Initially, the parameterization is the identity; each vertex of M = M L is mapped onto itself. When we perform an hecol operation to simply the mesh M l to M l−1 , we should update the parameterization of the vertices around the collapsed edge. That is, we should compute the mapping of the vertices onto the surface of M l−1 from the mapping onto M l which we have had before the hecol.</p><p>For the parameterization update, we follow the strategy proposed in MAPS <ref type="bibr" target="#b17">[18]</ref>, where a conformal map is used to build a bijection map in 2D between the 1-ring neighborhood of a vertex and its retriangulation after vertex removal. However, we should adapt the strategy to out-ofcore processing because the mapping information for all the vertices of M cannot be kept in the main memory. This is the reason why we use the map buffer B m to keep and process parts of the mapping information in a streaming fashion, as mentioned in Sec. 3.</p><p>When we perform an hecol operation, the buffer B m may not contain all the vertices that are mapped onto the faces modified by the hecol because some of the vertices may be read after performing hecol. For example, it is possible that the maximum vertex count of the buffer B m is smaller than the number of vertices which are mapped onto the faces in the buffer B d . In this case, we should store the conformal map of the removed vertex and use it later to update the vertices that will be read after hecol. Hence, we maintain a hash table H 2D that contains the conformal maps for hecol operations, where H 2D is accessed by the face indices involved in hecol. When hecol is performed, we store the corresponding conformal map in H 2D with the count of vertices in M that are mapped onto the faces of M l modified by the hecol. As the vertices of M are read into buffer B m , we update the mapping information of the vertices using the conformal maps stored in H 2D and decrease the counts associated with the conformal maps by the numbers of vertices updated. When the count of a conformal map becomes zero, we can remove it from H 2D .</p><p>Similarly the domain buffer B d contains only a part of the simplified mesh M l . When we read a vertex v m of M into the map buffer B m , we may not find the face of M l onto which v m is mapped in the domain buffer B d . This occurs when the face has not yet been read or has been removed by hecol. If the face has not yet been read, we keep the vertex v m in B m until we read the face. If the face has been removed by hecol, we can update the mapping information of v m using the conformal map stored in the hash table H 2D . To check whether a face of M l has been removed, we maintain the indices of removed faces in a hash table H f .</p><p>We also keep the indices of removed vertices of M l in a hash table </p><formula xml:id="formula_2">H v . Suppose that a vertex v</formula><formula xml:id="formula_3">1. v m is identically mapped onto a vertex v d ∈ M l and v d / ∈ H v : • v d ∈ B d : Since v d</formula><p>is not removed by hecol on level l, nothing needs to be done. We simply write the mapping information of v m as the identity to the file F l−1 m . Blue vertices in <ref type="figure" target="#fig_3">Fig. 2</ref> belong to this case. </p><formula xml:id="formula_4">• v d / ∈ B d :</formula><formula xml:id="formula_5">• f d ∈ B d :</formula><p>In this case, nothing needs to be done. We simply write the current mapping information to the file F l−1 m without change. Yellow vertices in <ref type="figure" target="#fig_3">Fig. 2</ref> belong to this case.</p><p>• f d / ∈ B d : In this case, we keep the vertex v m in the buffer B m for later processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">v m is mapped onto a face f d ∈ M l and f d ∈ H f :</head><p>First we find the conformal map that contains the face f d from the hash table H 2D . Using the conformal map, we can compute the new mapping face and the barycentric coordinates to obtain the new map information (i , α ), which is written to the file F l−1 m . If the count associated with the conformal map decreases to zero, we remove the map from H 2D and remove f d from H f . Orange vertices in <ref type="figure" target="#fig_3">Fig. 2</ref> belong to this case. When we write the updated mapping information for v m to the map file F l−1 m , we also remove v m from the map buffer B m . After the writing, we mark the vertex or face in the domain buffer B d onto which v m is mapped in the updated information as irremovable in the further simplification of M l to M l−1 . With the marking, we can guarantee the vertex or face in B d to be output to the mesh file F l−1 d . In addition, for the consistency of the conformal maps stored in the hash table H 2D , faces that have been generated by hecols are not further modified in simplifying M l to M l−1 .</p><p>In summary, to update the parameterization information with the buffers B d and B m , we use three hash tables, H 2D , H f , and H v , that keep track of conformal maps, removed faces, and removed vertices, respectively. The hash tables temporarily store the information related to an hecol operation until it is completely used to update mapping of vertices affected by the operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">BUFFER MAINTENANCE</head><p>In the parameterization process, we use two limited-size buffers, the domain and map buffers. For the iteration of the process that simplifies the mesh M l to M l−1 , we read a partial mesh and mapping information from two streaming files, F l d and F l m , to the two buffers and write the simplified mesh and updated mapping information to the files, F l−1 d and F l−1 m , respectively. In this section, we explain how to maintain vertices and faces in these two buffers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Write Condition</head><p>After applying a sequence of hecols and updating the associated mapping information, we write the related faces and vertices to the files and remove them from the buffers to obtain free spaces. However, we cannot write and remove faces in an arbitrary order. A face f in the domain buffer B d cannot be written and removed until we completely update the mapping information for the vertices of M which are mapped onto f . Therefore, we should be able to know when the mapping information related to a face in B d is fully updated.</p><p>If each face f in M l has a list of input vertices in M which are mapped onto it, we can easily decide when f can be written to the file F l−1 d . However, we cannot keep this possibly large vertex list in the limited-size main memory. When a simplified mesh M l is much smaller than the input out-of-core mesh, a large number of input mesh vertices may be mapped onto a face of M l . Instead of the input vertex list, in this paper, each face f has a map count and an update count. Using these counts, we can check whether the mapping information on f has been completely updated or not. The map count of a face f is the number of vertices in M which are mapped onto f . The update count of f is initially zero and is increased by one whenever we update the mapping information of a vertex that is mapped onto f . We call the face whose update count equals the map count a writable face and write only writable faces to the file F l−1 d . To keep track of the map count in the parameterization process, a face is stored with its map count in a mesh file F l d . Suppose that a vertex v r has been removed by an hecol and let F a be the set of faces that remain after the hecol among the 1-ring faces of v r . Although the map count of each face f a ∈ F a should be changed, we cannot determine the map count until we update the mapping information of all vertices that were previously mapped onto the 1-ring faces of v r . On the other hand, we need the map counts for the faces in F a to decide when the faces become writable.</p><p>To resolve this problem, we sum the previous map counts of the 1ring faces of v r and use the sum as the virtual map counts for the faces in F a . When we update the map information of a vertex that was previously mapped onto one of the 1-ring faces of v r , we increase the virtual update counts of all faces in F a by one. Consequently, after the mapping information has been updated for all vertices previously mapped onto the 1-ring faces of v r , all of the faces in F a become writable and are written to the file F l−1 d . At this time, we can obtain the true map counts of the faces in F a and store the true counts to the file F l <ref type="bibr">−1 d</ref> . Notice that the vertex count associated with the conformal map stored in the hash table H 2D is equal to the difference between the virtual map count and the virtual update count of a face in F a .</p><p>Unlike the write condition for a face in the domain buffer B d , the write condition for a vertex in the map buffer B m is simple. Each vertex in B m can be written to the file F l−1 m after we have updated its mapping information for M l−1 , as described in Sec. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Synchronization between Two Buffers</head><p>If no vertex in the map buffer B m finds its mapping face in the domain buffer B d and no face in B d is writable, then we can neither remove any vertex nor face from the buffers. In this case, other vertices and faces cannot be read from the files and the parameterization process cannot be continued. To prevent this situation, we have to synchronize the two buffers.</p><p>For the synchronization between two buffers, we manage the mesh parts contained in the buffers to overlap each other. If the mesh parts in the buffers have some overlapping regions, a vertex in B m will find the mapping face in B d for the mapping information update, which helps the faces in B d become writable.</p><p>The mesh parts contained in the buffers depend on the orders of vertices and faces stored in the streaming files. Hence, we can synchronize the parts of meshes in the buffers by arranging the orders of vertices and faces in the two files. Initially, the order of vertices in the map file F L m is the same as that of vertices in the mesh file F L d , and the vertex order in F L m is related to the face order in F L d . The order of faces in the file F l−1 d is determined by the writing order of faces when we process the mesh M l .</p><p>To determine the order of faces written to the file F l−1 d , we use a priority queue of faces in terms of the minimum index among the vertices that are mapped to a face. Here, the index of a vertex is determined by the writing order of the vertices in B m , which is the same as the stored order of the vertex in the file F l−1 m . Using the priority queue, we can arrange the faces in file F l−1 d in the order related to the order of vertices in F l−1 m .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESAMPLING</head><p>After the parameterization process, we can obtain a semi-regular mesh by recursively subdividing the base mesh M 0 and resampling the positions of new vertices from the given mesh M. However, since the mesh M cannot fit into the main memory, we need an out-of-core algorithm for resampling the new vertex positions. For resampling, we first convert the mesh M into a triangle soup. The three vertices of each triangle are mapped onto three positions on the surface of the base mesh M 0 by the mapping information obtained in the parameterization process. If a triangle does not belong to a single face of M 0 , we split the triangle and retriangulate the segments so that each triangle is contained in one face of M 0 . In <ref type="figure" target="#fig_4">Fig. 3</ref>, the large triangle represents a face in M 0 and the two small triangles are from M.</p><p>After creating the triangle soup, we externally sort the triangles to decompose them into sets T i of triangles that are contained in the same faces f i ∈ M 0 . Also in each set T i , triangles are sorted in terms of the minimum v-coordinate of the bounding box, where u and v are the first two components of the barycentric coordinates α of a vertex. If two triangles have the same minimum v, we give a higher priority to the triangle whose bounding box has the smaller u-coordinate. In <ref type="figure" target="#fig_4">Fig. 3</ref>, triangle f 1 has a higher priority than f 2 . The sorted triangle soup is stored in a file F t . Similarly we sort the vertices of the semi-regular mesh, which are determined by recursive subdivision, in terms of the faces of M 0 and the vand u-coordinates inside a face. The sorted vertices are stored in a queue Q p .</p><p>In the resampling process, we repeat the following steps until the queue Q p is empty. The process is similar to the merge sort that combines the queue Q p and the file F t . We use a buffer B t to keep the triangles that have been read from the file F t .</p><p>1. We pop a vertex v r of the semi-regular mesh from Q p .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>We check each triangle t in the buffer B t with the vertex v r .</p><p>• If the index of the face in M 0 which contains triangle t is smaller than the index of the face that contains vertex v r , we remove triangle t from the buffer B t . • If the maximum v-coordinate of the bounding box of t is smaller than the v-coordinate of v r in the face of M 0 , we also remove t from B t . • If t contains v r , we evaluate the 3D position of v r on the input mesh M using the 3D coordinates of the vertices of t.</p><p>3. If we do not find a triangle in B t which contains vertex v r , we read triangles from the file F t until we find a triangle containing v r . When we read a triangle from F t , we keep it in B t only if the maximum v-coordinate of its bounding box is larger than the v-coordinate of v r in the face of M 0 .</p><p>Another way to view the resampling process would be to say that we scan convert each triangle of the original mesh onto the regular grid in the parametric space of each regular patch, and use the bounding box to accelerate the process. Thus, in <ref type="figure" target="#fig_4">Fig. 3</ref>, the triangle f 1 at the current resolution will produce the red vertex of the output patch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTAL RESULTS AND APPLICATIONS</head><p>We implemented the proposed remeshing algorithm and explored its applications in processing of large meshes. For each input mesh, we used the breadth-first vertex sort to create a binary streaming file <ref type="bibr" target="#b14">[15]</ref>. The streaming file was used as the input for our out-of-core parameterization procedure. The following sections will describe various experimental results and applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Semi-Regular Remeshing</head><p>We first explore the semi-regular remeshing performance of our algorithm on several models. The largest models which were used in previous techniques have about 600,000 vertices <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">16]</ref>. However the method proposed in this paper is shown to handle meshes with up to 14 million vertices. <ref type="figure" target="#fig_6">Fig. 5</ref> shows the remeshed models with zoomedin details showing the structures of the resulting semi-regular meshes at level 4, with each regular patch individually colored. For all of the examples, although the resulting parameterization is not globally smooth, we achieve good visual approximation quality and a bijective mapping. <ref type="table">Table 1</ref> presents the key statistics of the input models with the remeshing time, output semi-regular mesh complexity, and errors measured by the Metro tool <ref type="bibr" target="#b3">[4]</ref> for semi-regular remeshing on level 5. For the three largest models, we could not run the Metro tool because of memory shortage. Instead, we implemented a simple out-of-core error measure routine, similar to the one used in <ref type="bibr" target="#b20">[21]</ref>, to measure the errors for the models. If desired, our algorithm can also produce a finer remeshing output at a higher level of the semi-regular hierarchy.</p><p>The number of "simplification passes" in <ref type="table">Table 1</ref> corresponds to the number of simplification and remapping passes of our algorithm. Notice that while the complexity of the base mesh is significantly smaller than that of the input mesh, we are not interested in decreasing the base face count because this may result in distortion coming from the MAPS reparameterization. Further simplification of the base domain can be easily performed in a separate parameterization stage as is shown in the next section. <ref type="table">Table 1</ref> also shows the computation times for the parameterization and the resampling processes. In the parameterization process, approximately a half of the computation time is spent for the file I/O. In the resampling process, the external sorting takes most of the computation time. The timing data were measured on a Pentium IV 3.4 GHz PC with 2GB RAM.</p><p>Our streaming algorithm has the sizes of the main memory buffers as parameters. In all of our experiments, we set the maximum face count for the domain buffer B d , Max f (B d ), to be 400K and the maximum vertex count for the map buffer B m , Max v (B m ), to be 10K. Our method with these sizes of buffers used less than 230MB of RAM for all of our experiments. <ref type="figure">Fig. 4</ref> shows the memory footprint for the Lucy model. In <ref type="figure">Fig. 4</ref>, we used only 31MB of RAM with Max f (B d ) = 50K and Max v (B m ) = 10K. If the sizes of the main memory buffers are extremely small, our algorithm may not be guaranteed to run properly despite the synchronization between the buffers. To experiment with an extreme condition, we set the maximum vertex count of the map buffer B m as one   <ref type="table">Table 1</ref>. Statistics for the remeshed models: The first seven columns are the model name, the number of vertices in the original mesh, the number of vertices in the base domain, the parameterization time, the resampling time, the number of simplification passes, and the L 2 error of the remeshed model (w.r.t. the bounding box diagonal of the original model). The remesh data are reported for the level five of the output semi-regular mesh. The last three columns show the compression statistics using the progressive (semi-regular) geometry coder <ref type="bibr" target="#b16">[17]</ref>; both the archive size and the bit per vertex are shown, followed by the relative L 2 error of the decompressed model (w.r.t. the bounding box diagonal). The default compression settings with 12 bit-planes were used in the PGC software <ref type="bibr" target="#b16">[17]</ref> with Butterfly wavelets. and the maximum face count of the domain buffer B d as 30K. With this setting, we could successfully remesh the Lucy model, which has 28 million faces, using about 20MB of memory for the buffers. When we increased the vertex count of B m to 3K, we could reduce the face count of B d to 12K for remeshing the Lucy model, where the total memory used for the buffers is less than 9MB. These experiments demonstrate that our remeshing algorithm would have no problem in handling arbitrarily large meshes in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Map Conversion</head><p>As mentioned in Sec. 2.2, for a very large input model, the parameterization process can be split into two stages. In this section, we describe our implementation of this idea to create spherical parameterizations of large input meshes. In order to do so, we first run our out-of-core parameterization procedure on the large input mesh and create an intermediate base mesh together with a mapping between the intermediate mesh and the original input mesh. Then, we use an in-core spherical parameterization procedure to parameterize the intermediate base mesh onto the sphere.</p><p>The resampling procedure can first create a set of samples on the intermediate base mesh and then use the out-of-core map to find the corresponding positions on the original input surface. In <ref type="figure" target="#fig_7">Fig. 6</ref>, we generate a geometry image and a normal-map image of the given outof-core mesh by the spherical parameterization <ref type="bibr" target="#b20">[21]</ref>. The two images are generated by sequentially reading each face of the input model and drawing it in the image plane. <ref type="figure" target="#fig_7">Fig. 6</ref> shows a remeshed model with the geometry image and its normal-map image. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">User-Defined Features</head><p>In order to preserve the original surface features, we use the vertex normal information during the simplification stage. We also implement an additional feature preservation functionality which was originally proposed by the MAPS paper <ref type="bibr" target="#b17">[18]</ref>. This is especially important if the base domain is significantly simpler than the original mesh (which is the case for most of our examples, as can be seen from <ref type="table">Table 1)</ref>.</p><p>We allow the user to select feature elements which will be preserved during simplification. Unlike the in-core algorithm, we cannot choose them in the given large polygonal mesh immediately. Instead of the input mesh, the user can select features in one of the simplified meshes M l or its portion. The user-defined features are maintained intact during simplification and parametric domain construction, in a manner similar to MAPS <ref type="bibr" target="#b17">[18]</ref>. <ref type="figure" target="#fig_9">Fig. 7(a)</ref> shows an example in which the features have disappeared during the simplification, so that the Lucy's fingers merged into a single surface patch. <ref type="figure" target="#fig_9">Fig. 7(b)</ref> shows an example obtained after the feature selection. We set the end of each finger as a feature, and as a result, these features are better approximated in the resulting semiregular mesh.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">User-Guided Mesh Editing</head><p>The created correspondence between the original and the base domain meshes can be used for simple editing of the surface. In particular, the user can remove parts of the base mesh and have the corresponding parts of the original surface removed as well. We apply this method to user-guided removal of noisy parts. Many out-of-core meshes are obtained from laser scan data and they often contain geometric or topological noise. For example, <ref type="figure">Fig. 8(a)</ref> shows the artifacts unrelated to the input shape, which have been generated inside David's head. In this application, we focus on removing artifacts of the acquisition process to improve the final remeshed model. As mentioned in Sec. 4.1, to preserve the features, we do not apply hecol to an edge if the normal variation at the end vertices is large. Since artifacts have noisy geometry with non-smooth normals, they usually remain in the domain mesh M 0 as small triangles or bad shaped triangles, such as shown in <ref type="figure">Fig. 8(b)</ref>. The areas of these small and poorly shaped triangles are usually less than 1% of other triangle areas. Therefore, we can remove them without changing the global shape of the scanned data. Since we have a bijection between the original mesh M and its parametric domain M 0 , we can remove the artifacts in the scanned data as well, as shown in <ref type="figure">Fig. 8(c)</ref>.</p><p>(a) (b) (c) <ref type="figure">Fig. 8</ref>. Noise removal: The noisy region is shown in the original mesh on the left (a) and in the simplified mesh in the middle (b). After the region in the simplified mesh has been removed, it can also be removed from the original mesh as shown on the right (c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Shape Compression</head><p>One of the principal reasons for creating a semi-regular remesh of an input surface is the significant compression performance of the wavelet-based semi-regular coders, first introduced by Khodakovsky et al. <ref type="bibr" target="#b16">[17]</ref>. This outstanding performance comes from both the structured connectivity and smooth parameterization of the resulting surface representations. We use the progressive geometry compression method from <ref type="bibr" target="#b16">[17]</ref> to convert our output semi-regular meshes into archives that can be used for storage and transmission. We also use the Touma-Gotsman coder <ref type="bibr" target="#b26">[27]</ref> for the base mesh compression. <ref type="figure" target="#fig_10">Fig. 9</ref> and <ref type="table">Table 1</ref> present the compression results for several of our models. Since our method is a derivative of the MAPS approach, we expect to achieve similar compression performance which is confirmed by <ref type="figure" target="#fig_10">Fig. 9</ref>. Therefore, we can proceed from the huge irregular input mesh to a small compressed archive storing an approximation of the same surface with low error.</p><p>Limitation Our remeshing procedure does not produce a globally smooth mesh parameterization such as the one introduced in <ref type="bibr" target="#b15">[16]</ref>, which may reduce its amenability to semi-regular compression. For rendering applications, the reduced smoothness of the parameterization is not important, as long as sufficiently good surface approximation is achieved. Moreover, the correspondence created between the input and the base domain can be used as a starting point for an improved surface parameterization procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head><p>In this paper, we have presented the first out-of-core method for semiregular remeshing of large polygonal models. It proceeds in a manner similar to the MAPS approach, first constructing a base domain by simplification, and then resampling the surface using the created parameterization. Our method is implemented in a streaming framework and proceeds by synchronously streaming the input and the simplified version of the same surface. Our synchronization strategy relies on explicit writing conditions for the output streaming mesh representation.</p><p>Our remeshing algorithm works best for creating a mapping between a huge input mesh and its simplified version. Many processing operations on the simplified version of the mesh can then be "transported" by the stored map to the corresponding operations on the orig- inal surface. We illustrated our approach for semi-regular and spherical remeshing, simple mesh editing for noise removal, and shape compression. Additional functionality that can be implemented using our approach includes the transfer of texture and morphing information.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Minsu Ahn is with Pohang University of Science and Technology (POSTECH), E-mail: atom@postech.ac.kr. • Igor Guskov is with University of Michigan, E-mail: guskov@eecs.umich.edu. • Seungyong Lee is with Pohang University of Science and Technology (POSTECH), E-mail: leesy@postech.ac.kr. Manuscript received 31 March 2006; accepted 1 August 2006; posted online 6 November 2006. For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3 . 5 . 1 m</head><label>351</label><figDesc>M l from the file F l d and insert them into the domain buffer B d . The partial mesh in B d maintains both geometry and connectivity. 2. Perform a sequence of half-edge collapses to simplify the part of M l in B d (Sec. 4.1). Read vertices from F l m and add them to the map buffer B m . Each vertex has the mapping information onto the surface of M l . 4. Update the mapping information of the vertices in B m which are mapped onto the part of M l stored in B d (Sec. 4.2). The updated information determines the mapping of the vertices onto the surface of M l−1 . Write the vertices in B m with their updated mapping information to the file F l−and remove them from B m . The vertices whose mapping information has not been updated remain in B m . 6. Repeat from Step 3 to Step 5 until we evaluate the mapping information for all vertices that are mapped onto the part of M l stored in B d or we cannot read vertices into the buffer B m anymore. 7. Write the writable faces in B d to the file F l−1 d and remove them from B d (Sec. 5.1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>m of M is mapped onto a vertex v d of M l by the mapping information. In this case, v m and v d are the same vertex, which implies that no hecol is applied to the vertex in the simplification process up to M l . If the domain buffer B d does not currently contain v d , v d has been removed by hecol in M l or v d has not been read into B d . In the former case, we should update the mapping information for v m , while in the latter case, we keep v m in the map buffer B m until v d is read into B d . Now we describe the details of the mapping information update. Each vertex v m ∈ B m is classified into one of the following categories;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Update of parameterization information after hecols: Blue faces in the domain buffer B d have been retriangulated by hecols. Dot lines represent the original edges before the retriangulation. For red and orange vertices, we have to recompute the parameterization information.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Resampling of vertex positions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 × 10 8 2 × 10 8 Fig. 4 .</head><label>884</label><figDesc>WriteSimplifyRead ReadMax f (B d ) = 400K Max f (B d ) = 200K Max f (B d ) = 50Kbytes Memory footprint for the Lucy model with the different sizes of the domain buffer B d and the map buffer size of Max v (B m ) = 10K: Each curve shows the peak memory usages in a single parameterization pass.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Remesh examples: The output semi-regular models at level four are shown together with zoomed-in surface details showing the structures of the output semi-regular meshes. The three images at the bottom-right corner show the shaded versions of the Lucy remesh for the levels three, four, and five.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>David head: geometry image (257x257), normal-map image (512x512), and normal-mapped reconstruction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>User-defined features: (a) remesh without feature; (b) remesh with features</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 .</head><label>9</label><figDesc>Rate-distortion curves: PSNR<ref type="bibr" target="#b16">[17]</ref> is shown on the vertical axis vs. file size in 10K bytes on the horizontal axis. The curves at the top-left corner show our result compared to the Normal Mesh<ref type="bibr" target="#b8">[9]</ref> results with Butterfly and Loop wavelet transforms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>We keep the vertex v m in the buffer B m for later processing because we have not read the vertex v d into the buffer B d .2. v m is identically mapped onto a vertexv d ∈ M l and v d ∈ H v :In this case, v d has been removed by hecol and would not be included in the mesh M l−1 . When we remove a vertex in M</figDesc><table /><note>l , we compute a new mapping information (i , α ) and store the information in the hash table H v . Hence, we can find the mapping information for v m from H v and write it to the file F l−1m directly. After that, we remove v d from H v because the information for v d is not needed anymore. Red vertices in Fig. 2 are contained in this case.3. v m is mapped onto a face f d ∈ M l and f d / ∈ H f :</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors would like to thank the anonymous reviewers for their valuable comments. The models are courtesy of the Stanford Graphics Laboratory. This research was supported in part by the BK21 program, the ITRC support program, and KOSEF (F01-2005-000-10377-0). Igor Guskov was supported in part by NSF (CCR-0133554), and by the NSF ERC-RMS (award EEC-9529125).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Anisotropic polygonal remeshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Alliez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen-Steiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Devillers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="485" to="493" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interactive geometry remeshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Alliez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="347" to="354" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">External memory management and simplification of huge meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Metro: measuring error on simplified surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="167" to="174" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-GRAPH 1995</title>
		<meeting>ACM SIG-GRAPH 1995</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH 1997</title>
		<meeting>ACM SIGGRAPH 1997</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Gortler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Geometry images. ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="355" to="361" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hybrid meshes: multiresolution using regular and irregular refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Guskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Khodakovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on Computational geometry 2002</title>
		<meeting>Symposium on Computational geometry 2002</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="264" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Normal meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Guskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vidimče</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Compressing large polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kriegman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="357" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<title level="m">Progressive meshes. Computer Graphics (Proc. SIGGRAPH &apos;96)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Smooth view-dependent level-of-detail control and its application to terrain rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Out-of-core compression for gigantic polygon meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="935" to="942" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Large mesh simplification using processing sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="465" to="472" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Streaming meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isenburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization 2005</title>
		<meeting>IEEE Visualization 2005</meeting>
		<imprint>
			<date type="published" when="2005-10" />
			<biblScope unit="page" from="231" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Globally smooth parameterizations with low distortion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Khodakovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Litke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="350" to="357" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Progressive geometry compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Khodakovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">MAPS: Multiresolution adaptive parameterization of surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schroder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cowsar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Out-of-core simplification of large polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH 2000</title>
		<meeting>ACM SIGGRAPH 2000</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="259" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Global static indexing for real-time exploration of very large regular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Super Computing</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Spherical parametrization and remeshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="340" to="349" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multi-resolution 3d approximations for rendering complex scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Geometric Modeling in Computer Graphics</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Spatial Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Inter-surface mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schreiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Asirvatham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="870" to="877" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient adaptive simplification of massive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="127" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Explicit surface remeshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Surazhsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics Symposium on Geometry Processing</title>
		<meeting>Eurographics Symposium on Geometry essing</meeting>
		<imprint>
			<date type="published" when="2003-06" />
			<biblScope unit="page" from="17" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Triangle mesh compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graphics Interface &apos;98</title>
		<meeting>Graphics Interface &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A stream algorithm for the decimation of massive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graphics Interface</title>
		<meeting>Graphics Interface</meeting>
		<imprint>
			<date type="published" when="2003-06" />
			<biblScope unit="page" from="185" to="192" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
