<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">3D IBFV: Hardware-Accelerated 3D Flow Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandru</forename><surname>Telea</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Technische Universiteit Eindhoven</orgName>
								<address>
									<country key="NL">the Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarke</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Technische Universiteit Eindhoven</orgName>
								<address>
									<country key="NL">the Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">3D IBFV: Hardware-Accelerated 3D Flow Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation-Display Algorithms Flow Visualization</term>
					<term>Hardware Acceleration</term>
					<term>Texture Advection</term>
					<term>OpenGL</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present a hardware-accelerated method for visualizing 3D flow fields. The method is based on insertion, advection, and decay of dye. To this aim, we extend the texture-based IBFV technique presented in [van Wijk 2001] for 2D flow visualization in two main directions. First, we decompose the 3D flow visualization problem in a series of 2D instances of the mentioned IBFV technique. This makes our method benefit from the hardware acceleration the original IBFV technique introduced. Secondly, we extend the concept of advected gray value (or color) noise by introducing opacity (or matter) noise. This allows us to produce sparse 3D noise pattern advections, thus address the occlusion problem inherent to 3D flow visualization. Overall, the presented method delivers interactively animated 3D flow, uses only standard OpenGL 1.1 calls and 2D textures, and is simple to understand and implement.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Visualization of two and three dimensional vector data produced from application areas such as computational fluid dynamics (CFD) simulations, environmental sciences, and material engineering is a challenging task. Although not a closed subject, 2D vector field visualization can now be addressed by a comprehensive array of methods, such as hedgehog and glyph plots, stream lines and surfaces, topological decomposition, and texture-based methods. The last class of methods produces a "dense", texture-like image representing a flow field, such as spot noise and line integral convolution (LIC). For a comprehensive survey of these methods, see <ref type="bibr" target="#b3">[Hauser et al. 2002]</ref>.</p><p>Texture-based techniques have a number of attractive features. First, they produce a continuous representation of a flow quantity which covers every dataset point. In comparison, discrete methods, such as streamlines and glyph plots, sample the datset, leaving to the user the interpolation of the visualization from the drawn samples. Secondly, most texture methods relieve the user from the tedious task of deciding where to place the data to be advected, e.g. the streamline seed points. Finally, recent texture-based methods employ graphics hardware, to render animated visualizations of the flow field at interactive rates, thereby using motion to effectively convey the impression of flow.</p><p>However effective and efficient in 2D, texture-based techniques are not still extensively used for visualizing 3D flow. Indeed, 3D flow visualization exhibits a number of problems, some of them related to the use of texture-based techniques, others inherent to the extra spatial dimension. The main problem inherent to 3D flow visualization is the occlusion by the depth dimension. This problem is even more obvious in case of dense visualizations, such as produced by texture-based techniques, as compared to discrete methods, such as streamlines. Another important problem of texture-based 3D flow visualizations is the difficulty of quickly producing and rendering changing volumetric images that would convey the motion impression.</p><p>Recently, Image-Based Flow Visualization (IBFV) has been proposed for 2D flow fields <ref type="bibr" target="#b7">[van Wijk 2001]</ref>. Based on a combination of noise injection, advection, and decay, IBFV is able to produce insightful and accurate animated flow textures at a very high frame rate, is simple to implement, and runs on consumer-grade graphics hardware. In this paper, we extend the IBFV technique and make it suitable to render 3D vector fields. In this extension, we keep IBFV's main features: a high frame rate, implementation simplicity, and independence on specialized hardware. Moreover, we address the issue of depth occlusion in 3D by extending the texture noise model the original IBFV introduces. Specifically, we add an opacity (or matter) noise to the gray value (or dye) noise already present in the IBVF. This gives a simple but powerful framework for tuning the visualization density without sacrificing the overall contrast.</p><p>Section 2 overviews the existing texture-based visualization methods for 3D flow, with a focus on hardware-accelerated methods. Section 2.1 presents the 2D IBFV method we dwell upon. In Section 3, we introduce the main concepts and the implementation of our method. Section 4 presents several results obtained with our method and discusses parameter settings. Finally, Section 5 draws the conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>As mentioned in Sec. 1, a number of texture-based methods have been developed for visualizing 3D flow. In this section, we give a brief overview of these methods. We focus on the hardwareaccelerated ones, as our aim is to produce animated 3D flow imagery at an interactive rate.</p><p>One of the first papers to address the dense visualization of 3D vector data was published in 1993 by <ref type="bibr" target="#b1">Crawfis et al. [1993]</ref>. Here, splats are used, following the line integral convolution (LIC) technique, to show the direction of the field.</p><p>More recently, in 1999, <ref type="bibr" target="#b0">Clyne and Dennis [1999]</ref> and <ref type="bibr" target="#b2">Glau [1999]</ref> presented volume rendering techniques for time-dependent vector fields which make use of parallel computing, respectively 3D texture on SGI Onyx machines. In the same year, <ref type="bibr" target="#b6">Rezk-Salama et al. [1999]</ref> present a method based on 3D LIC textures. In this work, the impression of flow is given by animating a precomputed LIC texture via cycling colors in the hardware color tables. Additionally, clipping surfaces can be interactively adjusted to specify the user's volume of interest. The method achieves, on an SGI machine, 20 frames <ref type="bibr">IEEE Visualization 2003</ref><ref type="bibr">, October 19-24, 2003</ref>, Seattle, Washington, USA 0-7803-8120-3/03/$17.00 ©2003 IEEE per second (fps) without clipping and 3-4 fps when complex clipping surfaces are used. However effective, the method can not interactively address time-dependent fields, as this would involve recomputing the LIC texture. Moreover, the method uses OpenGL 3D textures, which are not yet hardware accelerated by consumer-grade graphics cards.</p><p>In contrast to the above, Weiskopf et al. propose a method for rendering time-varying vector fields as animated flow textures <ref type="bibr" target="#b9">[Weiskopf et al. 2001]</ref>. The principle is the same as for IBFV, namely the method injects and advects a texture. However, less attention is dedicated to the noise generation as in the IBFV method <ref type="bibr" target="#b7">[van Wijk 2001]</ref>. Special programmable per-pixel operations of the nVidia GeForce card family are used to offset, or advect, a texture image TI , as function of another texture TV that encodes the vector field. Specifically, the authors use the offset and dot product texture shaders of the GeForce cards, as well as multitexturing capabilities to combine several textures in a single pass. However, as the authors mention, the method would be applicable to 3D fields only when the needed per-pixel operations are supported for 3D textures by the GeForce cards. For 3D fields, a similar method is proposed that uses 3D textures, per-pixel texture extensions of SGI's VPro graphics cards, and the SGI-specific post-filtering bias and scale image operations. Given this specialized hardware, the method achieves 4 fps for an image of 320 2 pixels of a 3D flow dataset of 128 3 cells.</p><p>The previous method has been extended one year later by Reck et al. to handle 3D curvilinear grids <ref type="bibr" target="#b5">[Reck et al. 2002]</ref>. However, the dye injection and advection process that drives the visualization remains the same, which means that the method handles 3D fields only using specialized SGI hardware. Given the extra overhead of handling curvilinear grids, this method achieves only 5 fps for a field of 16 3 cells, when an accelerating cell clustering technique that trades accuracy for speed is used. Without clustering, the method needs 7 seconds per frame.</p><p>Visualizing 3D flow with dense imagery is difficult, as outlined in Sec. 1, due to the inherent occlusion problem. This problem is addressed by <ref type="bibr" target="#b4">Interrante and Grosch [1989]</ref>. Essentially, a number of strategies for computing effective LIC textures is given, such as using region-of-interest (ROI) functions to limit the rendered volume, using sparse noise for the LIC to limit the volume fill-in, using 3D halos to give a shadow effect to the LIC splats, and using oriented fast LIC <ref type="bibr" target="#b8">[Wegenkittl and Gröller 1997]</ref> to convey directional information by using assymetric filter kernels. However, these techniques trade speed for visual quality, and thus cannot generate interactive flow animations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">2D IBFV</head><p>As described above, an essential limitation of 3D texture-based flow visualizations is that they cannot be generated interactively, at least not on consumer-grade graphics cards. In the next section, we introduce our 3D image-based flow visualization method, or 3D IBFV for short, which addresses this issue. To better understand the method, we first overview 2D IBFV that serves as a basis for our method.</p><p>Consider an unsteady 2D vector field v(x, t) ∈ R 2 , defined for t ≥ 0 and x ∈ Ω, where Ω ⊂ R 2 is typically a rectangular region. v represents typically a flow field. However, other vector fields can be considered too.</p><p>The trajectory of a massless particle in the field, or a pathline, is the solution p(t) of the ordinary differential equation:</p><formula xml:id="formula_0">dp dt = v(p(t), t),<label>(1)</label></formula><p>given a start position p(0). Integrating the above equation by the Euler method gives the well known</p><formula xml:id="formula_1">pn+1 = pn + v(pn, t)∆t<label>(2)</label></formula><p>Take now a 2D scalar property A(x, t) advected by the flow, such as the color of advected bye. A will be, by definition, constant along pathlines defined by Eqn. 1. Thus, in a first order approximation, we have A(pn+1, n + 1) = A(pn, n), if pn ∈ S, else 0</p><p>(3) However, one needs to initialize the dye advection by inserting dye into the flow. For this, we take a convex combination of the advection, as defined by Eqn. 3, and the dye injection, defined by a scalar image G, as follows</p><formula xml:id="formula_2">A(pn, n) = (1 − α)A(pn−1, n − 1) + αG(pn, n)<label>(4)</label></formula><p>Equation 4 is the essence of the IBVF, as it describes the advection, insertion, and decay of ink as function of time and space. The blending parameter α specifies the decay to injection ratio. In the original IBFV method, α was taken constant for all points in S.</p><p>initialize textures A and {G n } build warped polygon mesh P while (true) { draw mesh P textured with A select noise texture G from {G n } draw polygon S textured with G and blend factor α } In terms of implementation, IBFV maps Eqn. 4 to OpenGL operations, as outlined by the pseudocode in <ref type="figure" target="#fig_0">Fig. 1</ref>. The domain S, representing the flow dataset, is modeled by a polygon mesh P , onto which the dye image A is textured. The advection of A is modeled by warping the textured polygon's vertices in the direction of the vector field with a small distance corresponding to the time step ∆t. The ink image G is modeled by a set of noise textures G n for the time instants t = n∆t. Gn's intensity is periodic in time, in order to achieve coherent pattern motion along pathlines. The ink injection, i.e. combination of A and G, is done by alpha blending the mesh P with a single polygon of the size of S textured with the noise Gn at the current time n. Finally, Equation 4 is made explicit in A by copying the warped and noise-injected image in the current frame buffer into the texture image A for the next frame. Overall, only OpenGL 1.1 operations are used, which makes the method simple and extremely fast.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">3D IBFV</head><p>To extend 2D IBFV to 3D, three main problems are to be taken care of. First, a way must be found to perform ink advection in 3D. Secondly, 2D IBFV, as described in Sec. 2.1, produces an opaque image. If we are to extend the method to 3D, we must somehow be able to see the inside of the flow volume. We do this by varying both the noise sparsity and the opacity of the rendered volume. Finally, an efficient way must be found to render the 3D flow volume. These problems are discussed in the next sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Advection in 3D</head><p>The main problem in implementing advection in 3D along the lines of the original IBFV method is that there is no direct 3D analogue to the hardware-accelerated textured mesh warping in 2D. Although 3D meshes can be warped and 3D texture is supported by some graphics hardware, there is no volumetric graphics primitive equivalent to the 2D textured polygon. It is thus not possible to straightforwardly extend the 2D IBFV algorithm shown in <ref type="figure" target="#fig_0">Fig. 1</ref> to 3D. We follow here another route, as described next.</p><p>We consider, for simplicity of the exposition, that the flow volume is aligned with the coordinate axes and that it is discretized as a regular grid p ijk = (i∆x, j∆y, k∆z), i.e. the grid cells have all sizes ∆x, ∆y, and ∆z. We take now a 2D planar slice S parallel to the XY plane, at distance k∆z measured along the Z axis <ref type="figure" target="#fig_1">(Fig. 2 a)</ref>. Consider now a point p on slice S k and three consecutive slices in the Z direction: S− at z = (k−1)∆z; S; and S+ at z = (k+1)∆z. If the advection time step ∆t used for integrating Eqn. 1 is small enough compared to the Z sampling distance ∆z and maximal Z velocity component max(vZ ), i.e. if |vZ |∆t &lt; ∆z, then the advection that reaches S k at p can come only from the volume between S+ and S−. We distinguish two situations: if vZ &lt; 0, the Z advection reaching S comes from S+. If vZ &gt; 0, the Z advection reaching S comes from S−. If vZ = 0, there is no advection along the Z axis, so we subsume this case to any of the two former ones, e.g. consider the case vZ ≥ 0. Consider first the case vZ &lt; 0. With the above assumptions, the advection at the grid point p ijk comes from the point q = p ijk − v(p ijk )∆t located between S and S+. To simplify notation, without loss of generality, assume that i = j = k = 0 and that vx &lt; 0 and vy &lt; 0. The quantity A is advected by the flow, so A(p000, t + ∆t) = A(q, t). We can evaluate A(q) by trilinear interpolation of the eight vertices of the cell containing q (see <ref type="figure" target="#fig_1">Fig. 2</ref> </p><formula xml:id="formula_3">b) A(q) = (1 − z)(1 − y)(1 − x)A000 +z(1 − y)(1 − x)A001 + (1 − z)y(1 − x)A010 +zy(1 − x)A011 + (1 − z)(1 − y)xA100 +z(1 − y)xA101 + (1 − z)yxA110 +zyxA111 (5)</formula><p>where x, y, and z are the local cell coordinates of point q, i.e. x = −vx∆t, y = −vy∆t, and z = −vz∆t, and A ijk are the values of A at the cell corner points p ijk . Denote by A k the sum of the terms in Eqn. 5 that have a factor (1 − z), i.e.</p><formula xml:id="formula_4">A k = (1 − y)(1 − x)A000 +y(1 − x)A010 + (1 − y)xA100 +yxA110<label>(6)</label></formula><p>and similarly by A k+1 the sum of the terms that have a factor z</p><formula xml:id="formula_5">A k+1 = (1 − y)(1 − x)A001 +y(1 − x)A011 + (1 − y)xA101 +yxA111<label>(7)</label></formula><p>We can thus rewrite Eqn. 5 as</p><formula xml:id="formula_6">A−(p) = A(q) = (1 − z)A k + zA k+1<label>(8)</label></formula><p>where A−(p) is the advection at p if vZ (p) &lt; 0. The terms A k and A k+1 allow a special interpretation. Indeed, A k is the 2D advection caused by v XY , the projection of v, onto the plane S, in the 2D rectangular cell (p000, p100, p110, p010). Similarly, A k+1 is the planar 2D advection caused by vXY in the 2D cell (p001, p101, p111, p011). Finally, Eqn. 8 denotes the advection of A from point p001 to point p000 along the Z axis, i.e. in the field vZ which is the projection of v onto Z. Recall that the above held for vZ &lt; 0. If vZ ≥ 0, we deduce a similar relation to Eqn. 8, i.e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A+(p)</head><formula xml:id="formula_7">= A(q) = (1 − z)A k + zA k−1<label>(9)</label></formula><p>where A+(p) is the advection at p if vZ (p) ≥ 0. The only difference here is that we consider the plane S− instead of S+, i.e. the Z advection brings information on the plane S from the opposite direction as in the former case vZ &lt; 0. Combining the two equations Eqn. 8 and Eqn. 9, we obtain the total advection A(p)</p><formula xml:id="formula_8">A(p) = A−(p) + A+(p)<label>(10)</label></formula><p>Summarizing, the advection of the scalar quantity A from q to p in the field v can be decomposed in a series of 2D advection processes in the planes S, S+, and S−, followed by a 1D advection along the Z axis from S− to S for those points p having vZ (p) ≥ 0 and a 1D advection along the Z axis from S+ to S for the points having vZ (p) &lt; 0.</p><p>In the next section, the implementation of Eqn. 10 is presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Advection implementation</head><p>As explained in the previous section, we decompose the 3D advection of a scalar property A in a series of slice planar advections and a series of Z-axis aligned advections. Following this idea, the global 3D advection procedure for a single time step on a volume consisting of a set Si of slices, i = 0..N − 1, is given by the pseudocode in <ref type="figure">Fig. 3</ref>:</p><formula xml:id="formula_9">for i = 0 to N-1 { if (i&gt;0) do 1D Z-axis advection from S i-1 to S i if (i&lt;N-1)</formula><p>do 1D Z-axis advection from S i+1 to S i do 2D IBFV-based advection in the slice S i } The planar advection terms of the type AXY in Eqns. 8 and 9 can be directly computed by applying the 2D IBFV method considering the projection vXY of v to the plane S (step 3 of the algorithm). Denote now by A k the value of A over all points of S k , for a given slice k. Similarly, denote by v Zk the velocity Z component over the points of S k . From Eqn. 8, step 1 of the algorithm becomes (for ∆t taken to be 1):</p><formula xml:id="formula_10">A k := (1 − max(v Zk−1 , 0))A k + max(v Zk−1 , 0)A k−1 (11) Similarly, step 2 becomes A k := (1 − max(−v Zk+1 , 0))A k + max(−v Zk+1 , 0)A k+1 (12)</formula><p>In the above, the max function is used to consider the two cases vZ &lt; 0 and vZ ≥ 0 explained in Sec. 3.1. Note that we evaluate the component vZ in the slices S k−1 and S k+1 to perform the advection. Alternative schemes can be used, e.g. evaluate vZ as the average, or linear interpolation, of the velocity v Zk in the current plane S k and the velocities v Zk−1 and v Zk+1 in the planes S k−1 and S k+1 . Similarly, the planar and Z-advections (steps 1,2,3 in <ref type="figure">Fig. 3</ref>) can be done in different orders, leading to different integration schemes. Given that we require |vZ |∆t &lt; ∆z, the chosen scheme in <ref type="figure">Fig. 3</ref> performed well for all our datasets. Moreover, this scheme minimizes the number of drawing operations (see also <ref type="figure">Fig. 9</ref> in Sec. 3.5).</p><p>In the above scheme, the order of the planar and Z-advections is, however, important. Consider, for example, a laminar diagonal flow (vx, vy, vz) = (1, 0, 1) and a property A (e.g. ink) nonzero in some area S0 and zero elsewhere ( <ref type="figure" target="#fig_3">Fig. 4</ref> sketches this as seen along the Y axis). The advection should carry the 'inflow' value A from S0 diagonally along the slices S k , leading to the situation in <ref type="figure" target="#fig_3">Fig. 4</ref> b. This is the result delivered by the algorithm in <ref type="figure">Fig. 3</ref>. If, however, we did, for each slice, first the 2D IBFV advection and then the Zadvection, to name one of the other possible orders, we would get the obviously wrong result in <ref type="figure">Fig. 3</ref> c after one time step.</p><p>Let us look closer at Eqns. 11 and 12 which describe the algorithm steps 1 and 2. In essence, one performs a convex combination of the property A k (planar advection) over consecutive slices, using the value z which represents the velocity Z component at grid points. As explained above, z is always greater or equal to zero. To generalize this for all points over a slice S k , i.e. for other points than mesh points, we bilinearly interpolate z over the slice S k from the z values at the mesh points.</p><p>If we were able to implement the above Z advection using hardware acceleration, then the complete 3D advection algorithm would be hardware accelerated, since the 2D IBFV method obviously is so. The next section describes how this can be done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Hardware accelerated Z advection</head><p>We start by evaluating, for all mesh points i,j of all slices S k , the quantities</p><formula xml:id="formula_11">v +Zijk =max( v Zijk , 0) v −Zijk =max(−v Zijk , 0)<label>(13)</label></formula><p>where v +Zijk and v −Zijk are the absolute values of the Z velocity components in the direction, respectively in opposite direction of the Z axis, on slice S k . For simplicity of notation, we drop the indices i and j, i.e. use v +Zk instead of v +Zijk , and similarly for v −Zk . For every slice k, we encode the above as two OpenGL 2D luminance textures. All textures we use are named textures, as this ensures a fast access to texture data. The luminance textures store one component (luminance) per texel. The texture type (as passed to the OpenGL call glTexImage2D) is either GL INTENSITY8 or GL INTENSITY16. This gives 8, respectively 16 bits resolution for the velocity Z component. Since two separate textures are used for v +Zk and v −Zk , an effective range of 9, respectively 17 bits is used for the velocity Z component. For all our applications, 16 bit textures have delivered good results, whereas the 8 bit resolution caused undersampling artifacts for vector fields with a high Z value range. Note also that the framebuffer resolution, used to accumulate the results, is also important for the overall computation accuracy. The spatial (X,Y) texture resolutions determine a tradeoff between representation accuracy and memory use. As a simple rule, these textures shouldn't be larger than the vector dataset's XY resolution, since this is the complete Z velocity information to be encoded. Practically, resolutions of 64 2 and 128 2 have given very good results. Now we can simply rewrite the Z advection equations (11) and (12) as</p><formula xml:id="formula_12">A k :=(1 − v +Zk−1 )A k + v +Zk−1 A k−1 (14) A k :=(1 − v −Zk+1 )A k + v −Zk+1 A k+1 (15)</formula><p>where :=, in the above, denotes assignment. Similarly, we implement the property A k as a set of 2D RGBA textures, one for every slice plane S k . The XY resolution of the property textures is exactly analogous to the resolution of the single RGB texture used 2D IBFV. Remark, however, that we need a texture alpha channel, whereas 2D IBFV did not. The use of this channel is explained in Sec. 3.5. The velocity-coding textures allow us to efficiently implement the above equations using graphics hardware. Equation 14 is implemented by the OpenGL code in <ref type="figure" target="#fig_4">Fig. 5</ref>. The OpenGL GL TEXTURE ENV MODE value passed to the glTexEnv function is always GL REPLACE, i.e. we do not use mesh vertex colors for the textures. All effects are obtained by varying the blending modes via the glBlendFunc function. A similar code is needed to implement Eqn. 15. Just as in the 2D IBFV case, the textures are created with GL LINEAR values for the GL TEXTURE MIN FILTER and the GL TEXTURE MAX FILTER parameters of glTexParameter, to ensure bilinear interpolation. The function drawQuad draws a single textured quadrilateral that covers the whole image. The variable temp is one RGBA texture used as a temporary workspace. The viewing parameters are such that there is a one to one mapping of the slices S k to the viewport.</p><p>Overall, our advection uses five textured quad drawing operations and two glCopyTexImage2D operations per slice and per advection direction, done into P-buffers, for speed reasons. This has the extra advantage of not needing an on-screen window showing the inner working of the advection process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Noise injection: Preliminaries</head><p>The last section has shown how 3D advection can be implemented using hardware acceleration. The second important question is now which scalar property to advect. We follow 2D IBFV, i.e. inject a spatially random, temporally periodic noise signal (see <ref type="bibr" target="#b7">[van Wijk 2001]</ref> for a detailed analysis). In the following, denote by An = (AIn, Aαn) a 2D image at moment t = n∆t, consisting of an intensity component AIn and an alpha (opacity) component Aαn. The original 2D IBFV equation (4) becomes now, for every 3D slice:</p><formula xml:id="formula_13">An = (1 − α)An−1 + αGn<label>(16)</label></formula><p>(we drop the spatial pn parameter for conciseness). Here, Gn is a 2D texture modelling the noise injected at time step n, consisting of an intensity GIn and an opacity Gαn component. Just as in the 2D IBFV case, the noise should be periodical in time, as this creates the impression of color continuity along streamlines. In our 3D case, we add an extra spatial dimension, i.e. the Z axis, to the noise. Just as for the temporal dimension, the noise must be a continuous, periodic signal along the Z axis, to minimize high frequency artifacts. For a full discussion hereof, see the original paper <ref type="bibr" target="#b7">[van Wijk 2001]</ref>. In 2D IBFV, both Aαn and Gαn were identically one (i.e. opaque) everywhere. More precisely, the actual 2D IBFV implementation used RGB, and not RGBA, textures. Hence, if we directly implement Eqn. 16 in the 3D case, we obtain a fully opaque flow volume consisting of gray value ink. Although 'correct', this result is useless for visualizing the flow. A first idea to tackle this problem is to use the texture alpha channel to model transparency, i.e. to use a Gαn which is not identically 1, but a noise signal similar to GIn. Texels with a low alpha would correspond to 'transparent' noise, i.e. holes in the texture slices, through which one could see deeper into the flow volume. Unfortunately, this method produces visualizations which have a poor contrast and which, after a while, tend to fill up the volume with texels having the same (average) transparency. When rendered by alpha compositing (see Sec. 3.6), little is seen in the depth of the flow. <ref type="figure" target="#fig_5">Figure 6</ref> a (see also Color Plate) shows this for a vortex flow in which red ink has been injected to trace a streamline. Discarding lower alpha values by using OpenGL alpha testing improves the results somewhat. However, the red streamline is still not visible <ref type="figure" target="#fig_5">(Fig. 6 b)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>a b d c</head><p>Parameter tuning can produce only mild improvements, as the following analysis shows. If an α close to zero is used, in order to diminish the noise injection, then the 'holes' in the noise have no chance to show up, and the visualization becomes quickly blurred. If a high α is used, to make the noise more prominent, then this will erase the current information (second term). The 'ink decaying' effect diminishes, and one sees only the noise variation in time. If one uses a sparse noise pattern, i.e. a Gαn which has mostly (very) low values, in conjunction with an average (0.5) to high (0.9..1) α, then the occlusion effect diminishes indeed. However, the method may now easily fall into the other extreme, where too little ink is injected, and the injected 'holes' quickly erase it.</p><p>Overall, we have found that it is very hard to get a parameter setting which produces a high-contrast visualization, both in terms of injected noise color and transparency. The visualization quickly tends to get blurred and produce low-contrast slices in the alpha channel. Although such visualizations do convey some insight into the flow, due to their animated nature, we need a better solution for the contrast problem. This is described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Noise injection in 3D</head><p>The key to producing a high-contrast 3D flow visualization is to refine Eqn 16. The main problem of this model is that it is not able to express what to inject (i.e. ink or 'holes') and where to inject it in the volume independently. Instead of the original formulation, we propose to use</p><formula xml:id="formula_14">An = (1 − Hn)An−1 + HnGn (17)</formula><p>Here, we replace the constant α parameter from Eqn. 16 with a noise function Hn. In other words, we use now two noise signals Gn and Hn instead of a single one. Both signals are periodic functions of Z position and time, as before, so they are stored as two sets of 2D textures, two textures per Z slice. The noise signal Hn is a single-channel alpha-texture. It describes where to inject the noise. If Hn = 1 at some point, it means we inject the noise signal in Gn at that point. If Hn = 0, we inject nothing at that point. The signal Gn may be a luminance-alpha (LA) or RGBA signal, depending whether we wish to inject gray, respectively colored noise. It describes what to inject at a given point, both in terms of the color (L or RGB) and the 'hole' or 'matter' injection (the A channel). Although we have experimented with color noise of random hue, monochrome noise (whether gray or color) has given the best results.</p><p>Using two noise signals instead of one allows us to specify what and where we inject independently. To inject fully transparent holes at a few locations, we use a Gn having texels with a zero alpha and a Hn sparsely populated with high values. In comparison with the model given by Eqn. 16, we can now inject a fully transparent hole close to a fully opaque ink spot or a location where no injection at all takes place. <ref type="figure" target="#fig_5">Figure 6</ref> c and d clearly show that this approach delivers a more transparent, but still highly contrasting visualization. Now the red streamline inside the flow is clearly visible.</p><p>We next describe the design of the Gn and Hn noise signals. Just as for the 2D IBFV, we compute the noise Hn at a moment t and spatial position x, y, and slice k, by using a periodic 'transfer function' h, phase-shifted with t, from a start moment given by a white noise signal N :</p><formula xml:id="formula_15">H(x, y, k, t) = h((N (x, y, k) + t) mod T )<label>(18)</label></formula><p>where T = tN ∆t is the time period of tN different moments. The noise components GIn and Gαn are computed analogously, using two more functions gI and gα. Note also that the phase offset (i.e. N signal) used to compute H is different than the one used for G. If it were the same, the two noises G and H would be in phase, which would create visible artifacts. We choose the functions h,gI , and gα as follows (see also <ref type="figure" target="#fig_6">Fig. 7)</ref>. For h we propose</p><formula xml:id="formula_16">h(t) = 0, t &lt; τ h t, t &gt; τ h<label>(19)</label></formula><p>In other words, nothing is injected for t &lt; τ h , whereas strong injection takes place for t &gt; τ h . For gI , we can use a similar function, controlled by a parameter τI . However, we found the step function</p><formula xml:id="formula_17">gI (t) = 0, t &lt; τI 1, t &gt; τI<label>(20)</label></formula><p>better. This would inject black ink for t &lt; τI and white ink otherwise. Since the variable opacity already modulates the noise blending, we found the above ink injection to be sufficient, i.e. we didn't make use of gray ink. Finally, for gα we propose</p><formula xml:id="formula_18">gα(t) = 0, t &lt; τα t−τα 1−τα , t &gt; τα<label>(21)</label></formula><p>Hence, holes are injected for t &lt; τα. For t &gt; τα, ink is injected, its color being given by gI . The above gα produces asymmetric advection patterns, thinner in the sense of the flow and thicker in the opposite direction. This may serve as an indication of the flow sense. Choosing</p><formula xml:id="formula_19">gα(t) = 0, t &lt; τα 1−t 1−τα , t &gt; τα<label>(22)</label></formula><p>will reverse the orientation of the flow patterns. For concrete settings for the τ h , τI , and τα parameters, and a summary of all parameters, see Sec. 4. The noise injection modelled by Eqn 17 can be efficiently implemented using graphics hardware. For this, we actually precompute and store the signals Hn and Qn = GnHn as 2D textures. As in the original 2D IBFV, these textures may be smaller than the property textures A, to save memory and rendering time. Texture repeat and stretch operations are used to map the H and Q textures' size P QN to the size AN of the textures A. Moreover, we store only textures for tN time instants and HQZN values of the Z coordinate (slice index k) and then repeat them periodically, both in Z direction and time (see Eqn. 18). Normally, HQZN &lt; ZN , where ZN is the number of Z slices. Overall, we store thus HQZN tN pairs of H and Q textures.</p><p>The noise injection algorithm for a given Z slice k is shown in <ref type="figure" target="#fig_7">Fig. 8</ref>. Here, we denote the noises G and H at time step n in slice k by G kn and H kn respectively. As noise injection is done after the Z advection and 2D IBFV steps, the drawable contains the signal A k when the injection starts. Recall also that, when alpha-textures are used in the GL REPLACE mode of glTexEnv, they only affect the destination alpha channel (e.g. step 1 of the code in <ref type="figure" target="#fig_7">Fig. 8)</ref>. Overall, the noise injection we propose uses just two textured quad draws, as compared to the original 2D IBFV which used one similar operation. for (k = 0; k&lt;Z N ; k++) // initialization { for (n=0; n&lt;t N ; n++) precompute noise textures H kn and Q kn = G kn H kn build warped polygon mesh P k create texture A k } while(true) // execution { for(k = 0; k&lt;Z N ; k++) { clear drawable perform the Z advection from slice k−1 to k perform the Z advection from slice k+1 to k draw mesh P k textured with current drawable inject noise using textures Q kn and H kn copy drawable to texture A k } display results (draw textures A k back to front) } <ref type="figure">Figure 9</ref>: Complete IBFV 3D method Putting it all together, we obtain the complete 3D IBFV method, shown in pseudocode in <ref type="figure">Fig. 9</ref>. The method has two phases, just like in the 2D IBFV case (compare <ref type="figure" target="#fig_0">Fig. 9 with Fig. 1</ref>). In the initialization phase, the noise and property textures (H kn , Q kn , and A k ) as well as the warped polygon meshes P k are built for all Z slices k (and all time instants n, for the noise textures). In the execution phase, the method is structurally similar to the 2D IBFV case, except for the new Z advection step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Rendering</head><p>As the 3D IBFV method is running, we visualize its results by drawing, in back to front order, the RGBA texture slices A k . Blending is enabled and the glBlendFunc function's source and destination factors are, as usually for this technique, set to GL SRC ALPHA and GL ONE MINUS SRC ALPHA. An important enhancement is obtained by enabling the OpenGL alpha test and cutting off all alpha values below a given αcut. Setting αcut between 0.01 and 0.1 allows one to quickly 'coarsen' the flow volume by discarding the almost transparent texels. Although not visible in separate slices, such texels can accumulate in the back to front blend and increase the overall opacity. <ref type="figure" target="#fig_0">Figure 11</ref> shows a flow volume rendered for three different αcut values, from three viewpoints. Clearly, the higher αcut values allow more insight in the flow.</p><p>We should remark that the choice of the Z slicing direction is, so far, arbitrary. For a regular dataset, an efficient choice is to minimize the Z slices count, i.e. choose Z as the axis having the least cell count from the three axes. Visualizing the back-to-front rendered slices (Sec. 3.6) will definitely produce poor results if the slicing direction is orthogonal to the line of sight, as we then tend to look through the slices. Still, for the various flow volumes we visualized, this didn't seem to be a major hindrance for the users. If desired, as usually done in many volume rendering applications, the method can detect this situation and change the slicing direction interactively, as the viewpoint changes.</p><p>A considerably better rendering can be obtained if 3D textures are used. In this case, the 2D textures A k can be slices in a single 3D texture volume. The whole 3D IBFV method stays the same. However, a visibly improved rendering can be done by drawing, back to front, a number of 2D polygons parallel to the viewport, that use the 3D texture. This is exactly what most volume rendering methods do. Remark that the use of 3D texture is, in this case, strictly needed for rendering the 3D IBFV results, not for producing them. Our main problem here was that (reasonably large) 3D textures are seldom present with hardware acceleration in the graphics cards we availed of (GeForce 2 and 3). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>We shall discuss now the parameter settings and the method's performance and memory requirements. Compared to 2D IBFV, the 3D method introduces several new parameters. Here follows the complete parameter list of 3D IBVF (see Sec. 3.5 for details): • τ h : noise injection strength (see Sec. 3.5)</p><formula xml:id="formula_20">•</formula><p>• τα: ink to hole injection ratio</p><p>• τI : black to white noise ink ratio</p><formula xml:id="formula_21">• αcut: alpha test threshold</formula><p>The visualization is strongly affected by the last four parameters (explained in Sec. 3.5). τ h controls how much noise, consisting of holes and/or ink, is injected. Good values for τ h range from 0.01 to 0.1. Higher values tend to produce too noisy images. τα is the ink to hole injection ratio. If close to 1, holes are injected, i.e. matter is 'carved out' of the flow volume. If close to 0, ink is injected. Good values for τα are 0.9 or higher, in order to produce a sparse flow volume. τI controls the ink luminance. If close to 0, more white ink is used. If close to 1, more black ink is used. Good values range around 0.1, to favor white ink.</p><p>As for the 2D IBFV, we can inject ink at chosen locations to trace streamlines. <ref type="figure" target="#fig_0">Figure 10</ref> shows a helix flow in which red ink was injected close to the back plane's center. Besides color, we set the ink's alpha to 1 (opaque). Using a high αcut discards most of the noise but keeps the opaque ink <ref type="figure" target="#fig_0">(Fig. 10 d)</ref>. Another idea is to set, for the noise injected close to the inflow's center, a high alpha. This alpha is advected into the helix core, which becomes opaque. Next, we set a high αcut and discard all outside the core <ref type="figure" target="#fig_0">(Fig. 10 b)</ref>. If low alpha noise is used instead, we 'carve out' the core <ref type="figure" target="#fig_0">(Fig. 10 c)</ref>. Another effective option is to inject strong noise for a few steps <ref type="figure" target="#fig_0">(Fig. 10 a)</ref> and then turn it off by setting τP to zero. This creates a more pleasant, smoother visualization <ref type="figure" target="#fig_0">(Fig. 10 e)</ref>. This technique was used also for the flow in <ref type="figure" target="#fig_0">Fig. 11</ref>.</p><p>As 2D IBFV, we are aware that our 3D method is limited in the range of velocities it can display. Specifically, both the maximum values for the XY and Z velocities must be smaller than the XY and Z cell sizes divided by the time step. In practice, we handle this by either using a small time step or by clamping the higher velocities.</p><p>We consider now the total memory (in bytes) our method needs to store the textures and polygon meshes: This just fits into our 64 MB GeForce cards. If M exceeds the graphics card memory, transfer to the normal memory takes place, which severely degrades the rendering performance. The rendering time is, as expected, proportional with the texture sizes, the number of slices Z N , and the mesh resolution XN YN . For the GeForce 2 and GeForce 3 Ti 400 cards, the mesh resolution XN YN was by far the dominant factor in the rendering time. This was much less severe for the standard GeForce 3 cards, where the dominant factor seems to be the texture resolution AN . A few rendering timings are shown in <ref type="figure" target="#fig_0">Fig. 12</ref>. We preferred using smaller ZN than XN and YN values as this delivered higher performance, as expected. Besides XN , YN , and AN , all configurations use the settings described for the memory estimation above, and run on a Pentium III PC at 800 MHz with Windows 2000. Given that the 2D IBFV produced 60 frames per second on the same hardware and that we render 50 Z slices, 3D IBFV delivers, so to speak, more throughput per rendered slice. Another discussion point is the usage of the velocity-encoding luminance textures (Sec. 3.3). An alternative approach would be to encode the Z velocities as 2D mesh vertex colors. In this case, the Z advection would be done by drawing the textured mesh with the GL MODULATE mode of the glTexEnv OpenGL function, instead of blending two textures, as we do now. This approach (which we tried first) has several disadvantages. First, storing a N 2 quad mesh is much more expensive than storing a N 2 luminance texture. Even if mesh coordinates are somehow shared, we must still store a full RGBA value per vertex, as OpenGL 1.1 does not allow storing only vertex luminance values. Using velocity textures, we store just the luminance values. Secondly, we found out that, on several nVidia GeForce 2 and 3 cards, drawing a single quad with a N 2 texture is much faster than drawing an N 2 quad mesh with vertex colors. Note, however, that the two approaches are functionally identical.</p><formula xml:id="formula_22">M = 2ZN (6XN YN + 2A 2 N + 2v 2 N ) +</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>3D IBFV is a method for visualizing 3D fluid flow as moving texture patterns using consumer graphics hardware. As its 2D counterpart, 3D IBFV offers a framework to create several flow visualizations (stream 'tubes', LIC-like patterns, etc), high frame rates, and a simple OpenGL 1.1 implementation, without 3D textures. However, while 2D IBFV easily handles instationary fields, 3D IBFV currently handles only the time independent case, as instationary fields require a continuous update of the velocity textures. 3D IBFV produces higher frame rates on less specialized hardware than other 3D flow visualization methods. We extend the 2D IBFV noise concept by adding 'opacity noise'. Combined with alpha testing, we get a simple and interactive way to examine flow volumes in the depth dimension. We present the implementation and parameter settings in detail, so that one can readily apply it. We see several extensions of 3D IBFV. New noise and/or ink injection designs can produce 3D flow domain decompositions, stream surfaces, curved arrow plots, and many other visualizations. Secondly, using 3D texture, as these become more widely available, may lead to a simpler, more accurate 3D IBFV. Finally, using DirectX floating-point textures may provide better accuracy. We plan to investigate these options in the near future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>2D IBFV algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2</head><label>2</label><figDesc>: a) Slicing the volume. b) Decomposing 3D advection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 3: Advection procedure</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Effect of operation order: a) test configuration. b) correct advection. c) incorrect advection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>OpenGL code implementing Z advection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Noise injection: a) and b) 2D IBFV noise mode. c) and d) 3D IBFV improved noise</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Transfer functions for a) Hn, b) GIn, and c) Gαn</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>OpenGL code implementing noise injection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>3D flow rendered with αcut = 0.01 (top), αcut = 0.02 (middle), and αcut = 0.05 (bottom)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Parameter settings for 3D IBFV</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>AN : resolution of the (4 bytes, RGBA) property textures A k • ZN : number of Z slices • vN : resolution of the velocity (2 byte, alpha) textures • HQN : resolution of textures H (1 byte, luminance) and Q (2 bytes, luminance alpha) • HQZN : Z resolution of the noise textures H and Q • tN : time resolution of noise textures • XN ,YN : resolution of meshes (12 bytes per vertex)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>3HQZN HQN tN (23) Given the settings: AN = 512, XN = YN = ZN = 50, vN = HQN = HQZN = 64, and tN = 32, we obtain M = 59 MBytes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>3D IBFV timings, frames per second</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Interactive direct volume rendering of time-varying data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clyne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dennis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE VisSym &apos;99</title>
		<editor>E. Gröller, H. Loffelmann, W. Ribarsky</editor>
		<meeting>IEEE VisSym &apos;99</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Volume rendering of scalar and vector fields at llnl</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Supercomputing &apos;93</title>
		<meeting>IEEE Supercomputing &apos;93</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="570" to="576" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Exploring instationary fluid flows by interactive volume movies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Glau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE VisSym &apos;99</title>
		<editor>E. Gröller, H. Loffelmann, W. Ribarsky</editor>
		<meeting>IEEE VisSym &apos;99</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="277" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">State-of-theart report 2002 in flow visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Laramee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
		<idno>TR-VRVis-2002-003</idno>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>VRVis Research Center, Vienna, Austria</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Visualizing 3d flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Interrante</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="49" to="52" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hardware accelerated visualization of curvilinear vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Reck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rezk-Salama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Grosso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Greiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VMV &apos;02</title>
		<editor>T. Ertl, B. Girod, G. Greiner, H. Niemann, H.P. Seidel</editor>
		<meeting>VMV &apos;02<address><addrLine>Stuttgart</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="228" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Interactive exploration of volume line integral convolution based on 3d texture mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rezk-Salama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hastreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Christian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;99</title>
		<editor>D. Ebert, M. Gross, B. Hamann</editor>
		<meeting>IEEE Visualization &apos;99</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="233" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Image based flow visualization. Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;01)</title>
		<meeting>SIGGRAPH &apos;01)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="263" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast oriented line integral convolution for vector field visualization via the internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wegenkittl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;97</title>
		<meeting>IEEE Visualization &apos;97</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="119" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Hardware-accelerated visualization of time-varying 2d and 3d vector fields by texture advection via programmable per-pixel operations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VMV &apos;01</title>
		<editor>T. Ertl, B. Girod, G. Greiner, H. Niemann, H.P. Seidel</editor>
		<meeting>VMV &apos;01<address><addrLine>Stuttgart</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="439" to="446" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
