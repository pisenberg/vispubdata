<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Chameleon: An Interactive Texture-based Rendering Framework for Visualizing Three-dimensional Vector Fields</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guo-Shi</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Udeepta</forename><forename type="middle">D</forename><surname>Bordoloi</surname></persName>
							<email>bordoloi@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
							<email>hwshen@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Chameleon: An Interactive Texture-based Rendering Framework for Visualizing Three-dimensional Vector Fields</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques-Interaction techniques; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Color</term>
					<term>shading</term>
					<term>shadowing</term>
					<term>and texture 3D flow visualization</term>
					<term>vector field visualization</term>
					<term>volume rendering</term>
					<term>texture mapping Vector field Advection + Texture Generation Noise Vector field Advection + Voxelization Dependent Texture Lookup Volume Renderer Output Volume Trace Volume Appearance Texture Volume Renderer Processing Stage Viz Viz Rendering Stage</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Tornado dataset rendered with different appearance textures. (a) with LIC texture pre-generated from straight flow. (b) with a color tube texture. Lighting is used to enhance the depth perception. (c) with a 2D paintbrush texture.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Vector fields play an important role in many scientific, engineering and medical disciplines. Many visualization techniques have been proposed to assist observers in comprehending the behavior of the vector field. They can be loosely classified into two categories: geometry-based and texture-based methods. Geometrybased methods (such as glyph, hedgehog, streamline, stream surface <ref type="bibr" target="#b8">[Hultquist 1992</ref>], flow volume <ref type="bibr" target="#b12">[Max et al. 1993]</ref>, to name a few) use shape, color, and motion of geometric primitives to convey the physical characteristics in the proximity of a certain point in the vector field. Texture-based methods, such as spot noise <ref type="bibr" target="#b19">[van Wijk 1991]</ref>, line integral convolution (LIC) <ref type="bibr" target="#b1">[Cabral and Leedom 1993]</ref>, and IBFV <ref type="bibr" target="#b20">[van Wijk 2002]</ref>, shade every pixel in the visualization using manipulated textures which express structural information of the vector field.</p><p>In two-dimensional vector fields or flows across a surface in three dimensions, the texture-based methods are capable of offering a clear perception of the vector field since the directions of the vector field can be seen globally in the visualization. For three-dimensional vector fields, however, the effectiveness is significantly diminished due to the loss of information when the threedimensional data is projected onto a two-dimensional image plane. <ref type="bibr">IEEE Visualization 2003</ref><ref type="bibr">, October 19-24, 2003</ref>, Seattle, Washington, USA 0-7803-8120-3/03/$17.00 ©2003 IEEE This drawback can be mitigated to some extent by providing additional visual cues. For example, lighting, animation, silhouettes etc. can all provide valuable information about the three-dimensional structure of the dataset. Comparing visualizations with different appearances also helps in understanding the anatomy of the vector field. Unfortunately, the high computational cost of 3D texturebased algorithms severely impedes the interactive use of visual cues. In fact, 3D vector field visualizations by current visual cueenhanced texture-based techniques are mostly generated in batch mode. Another issue for 3D vector field renderings is occlusion, which significantly hinders visualization of internal structures of the volume. Interactivity becomes very important as a result: the user needs to be able to experiment freely with textures of different patterns, shapes, colors and opacities, and view the results at interactive speeds. Keeping the above desirables in mind, we present a flexible and high-speed approach for three-dimensional vector field visualization.</p><p>The relative inflexibility of existing texture-based methods is a result of the tight coupling between the vector field processing step and output texture generation step. For example, in LIC, streamline advection and output pixel value generation are done simultaneously. As a result, the look of the rendering result cannot be changed on the fly. We address this issue by decoupling the visualization pipeline into two disjoint stages. First, streamlines are generated from the 3D vector data. Various geometric properties of the streamlines are then extracted and converted into a volumetric form which we will refer to as the trace volume. In the second phase, the trace volume is combined with a desired appearance texture at run-time to generate both informative and aesthetic representations of the underlying vector field.</p><p>The two-phase method provides a general framework to modify the appearance of the visualization intuitively and interactively without having to re-process the vector field every time the rendering parameters are modified. Just by varying the input appearance texture, we are able to create a wide range of effects at run time. A myriad of existing visualization techniques, including geometrybased and texture-based, can also be emulated. Using consumerlevel PC platform graphics hardware with dependent textures and per-fragment shading functionality, visualizations with enhanced structural perception using various visual cues can be rendered in real time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Researchers have proposed various vector field visualization techniques in the past. In addition to the more traditional techniques such as particle tracing or arrow plots, there are algorithms that can provide a volumetric representation of the underlying threedimensional fields. Some research has been directed towards integrating texture or icons into a volume rendering of the flow. [Crawfis and <ref type="bibr" target="#b2">Max 1992</ref>] developed a 3D raster resampling technique where the volume rendering was built up in sheets oriented parallel to the image plane. These sheets were composited <ref type="bibr" target="#b13">[Porter and Duff 1984]</ref> in a back-to-front order. The authors modified the volume integral to include the rendering of a tiny cylinder within a small neighborhood. A further refinement of this concept was to embed the vector icons directly into the splat footprint <ref type="bibr" target="#b3">[Crawfis and Max 1993]</ref> used for volume rendering. Here, small billboard images are overlapped and composited together to build up the final image. By placing a small icon within the billboard image, and orienting the image such that it lies both perpendicular to the viewing ray, and parallel to the projected vector direction at the splat's center point, a volume rendered image is produced.</p><p>Line Integral Convolution, or LIC <ref type="bibr" target="#b1">[Cabral and Leedom 1993]</ref>, has been perhaps the most visible of the recent flow visualization algorithms. The algorithm takes a scalar field and a vector field as input, and outputs another scalar field. By providing a white noise image as the scalar input, an output image is generated that correlates this noise function along the direction of the input vector field. While LIC is effective in visualizing 2D vector fields, it is quite computationally expensive. <ref type="bibr" target="#b18">[Stalling and Hege 1995]</ref> proposed an extension to speed up the process. <ref type="bibr" target="#b17">[Shen et al. 1996]</ref> proposed the advection of dyes in LIC computation. <ref type="bibr" target="#b11">[Kiu and Banks 1996]</ref> used noises of different frequencies to distinguish between regions with different velocity magnitudes. <ref type="bibr" target="#b16">[Shen and Kao 1998]</ref> proposed UFLIC for unsteady flow, and a level of detail approach was proposed by <ref type="bibr" target="#b0">[Bordoloi and Shen 2002]</ref>. <ref type="bibr" target="#b9">[Interrante and Grosch 1997]</ref> introduced the use of halos to improve the perceptual effectiveness when visualizing dense streamlines for 3D vector fields. <ref type="bibr" target="#b14">[Rezk-Salama et al. 2000]</ref> proposed a volume rendering algorithm to make LIC more effective in three dimensions. A volume slicing algorithm that utilizes 3D texture mapping hardware is explored to quickly adjust slice planes and opacity settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Chameleon Rendering Framework</head><p>The primary goal of our research is to develop an algorithm with greater interactivity and flexibility. The traditional texture-based algorithm such as LIC is known for its high computation cost when applied to three-dimensional data. This high computational complexity makes it difficult for the user to change the output's visual appearance such as texture patterns and frequencies at an interactive speed. Although in the past researchers have proposed various texture-based rendering techniques for visualizing threedimensional vector fields, there is no common rendering framework that allows a mix-and-match of different visual appearances on the fly when exploring three-dimensional vector data. In this paper, a novel rendering framework is presented to address this issue. In the following, we first give an overview of our algorithm, and then provide the details of various stages in our algorithm. <ref type="figure">Figure 2</ref> depicts the fundamental difference between our algorithm and the more traditional texture-based algorithm such as LIC. In LIC or similar texture-based algorithms, visual information is conveyed to the user through the correlation between the final voxel values. Texture synthesis is performed in a manner that the luminance of each pixel or voxel is computed and used as the rendering attribute. Once the process is completed, information about the vector field cannot be recovered from the resulting texture. If the user decides to alter the visual appearance, such as changing the frequency or the distribution of the noise, the entire texture synthesis process needs to be performed again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithm Overview</head><p>To allow flexible run-time visual mapping, we devise an algorithm that decouples the processing of the vector field and the mapping of visual attributes. To establish visual coherence for the voxel along the flow direction, we store, in each voxel, a few attributes which are highly correlated along the flow direction. The attributes associated with each voxel will be referred to as the trace tuple. Trace tuples from the voxels collectively constitute a volume called the trace volume. At run time, the correlation between neighboring trace tuples will be translated to coherent visual properties along the flow direction. Specifically, the attributes stored in the trace tuple are used as the texture coordinates to look up an input texture, which we will refer to as the appearance texture. The appearance texture contains pre-computed 2D/3D visual patterns, which will be warped and animated along the streamline directions to create the visualization. The appearance texture can be freely specified by the user at run time. For instance, it can be a pre-computed LIC image, or can be textures with different characteristics such as line <ref type="figure">Figure 2</ref>: Visualization pipelines for LIC (above), and Chameleon (below). The Chameleon decouples the advection and texture generation stages. Once the trace volume is constructed, any suitable appearance texture can be used to generate varied visualizations of the same vector dataset.</p><p>bundles, particles, paint-brush strokes, etc. Each of these can generate a unique visual appearance. Our algorithm can alter the visual appearance of the data interactively when the user explores the underlying vector field, and hence is given the name Chameleon.</p><p>Rendering of the trace volume requires a two stage texture lookup. Here we give a conceptual view of how the rendering is performed. Given the trace volume, we can cast a ray from each pixel from the image plane into the trace volume to sample the voxels. At each step of the ray, we sample the volume attribute, which is an interpolated trace tuple. This sampled vector is used as the texture coordinates to fetch the appearance texture. Visual attributes such as colors and opacities are sampled from the appearance texture and blended into the final image. Although here we use the ray casting algorithm to illustrate the idea, in our implementation, we use graphics hardware with per-fragment shaders and dependent textures to achieve interactivity.</p><p>In the following sections, we elaborate each step of our algorithm in detail. We will focus on the topics of trace volume construction, including voxelization (sec.3.2), trace tuple assignment (sec.3.3), anti-aliasing (sec.3.4), and interactive rendering (sec.3.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Trace Volume Creation</head><p>The trace volume is created by voxelizing the input streamlines. Since the trace volume will be a texture input to the 3D texture mapping hardware (described later), it is defined on a 3D Cartesian grid. For the underlying vector fields, there is no preferred grid type because the trace volume is created from a dense set of streamlines but not the vector field. We use the method proposed by <ref type="bibr" target="#b10">[Jobard and Lefer 1997</ref>] to control the density and the length of streamlines. The seeds are randomly selected, and the streamlines are generated by the fourth-order Runge-Kutta method. An adaptive step size based on curvature <ref type="bibr" target="#b5">[Darmofal and Haimes 1992]</ref> is used. The advection process is stopped whenever the advected streamline gets too close to each other. This is to ensure that the thick lines discussed in sec.3.4 do not intersect with each other. Otherwise, the trace tuples will be overwritten during voxelization, which would result in undesirable dependent texturing artifacts in the rendering stage.</p><p>To voxelize the streamlines, a hardware-assisted slice sweeping algorithm, inspired by the CSG voxelization algorithm proposed by <ref type="bibr" target="#b6">[Fang and Liao 2000]</ref>, is designed to achieve faster voxelization speed. The input to our voxelization process is a set of streamlines S = {s i }. Each streamline s i is represented as a line strip with a sequence of vertices P = {p j }. Each vertex p j in the streamline s i is assigned a trace tuple for the identification and parametrization of the streamline. The trace tuple for each streamline vertex is specified as a color for the vertex during our voxelization process. In this section, we focus on the trace volume scan conversion. More details about the trace tuple are provided in the next section. Using graphics hardware, our algorithm creates the trace volume by scan-converting the input streamlines onto a sequence of slices with a pair of moving clipping planes. For each of the X, Y, and Z dimensions, we first scale the streamline vertices by V /L, where V is the resolution of the trace volume in the dimension in question, and L is the length of the corresponding dimension in the underlying vector field, or a user-specified region of interest. Then we render the streamlines orthographically using a sequence of clipping planes. The viewing direction is set to be parallel to the z axis, and the distance between the near and far planes of the view frustum is always one. Initially, the near and far clipping planes are set at z = 0 and z = 1, respectively. When each frame is rendered, the frame buffer content is read back and copied to one slice of the trace volume. As the algorithm progresses, the locations of the clipping planes are shifted by 1 along the Z axis incrementally until the entire vector field is swept. <ref type="figure" target="#fig_0">Figure 3</ref>(a) illustrates our algorithm. Positions for the near and far clipping planes for two different slices are shown.</p><p>The performance of the voxelization depends on the rendering speed of the graphics hardware for the input streamline geometry. To reduce the amount of geometry to render, streamline segments are placed into bins according to their spans along the Z direction. During the voxelization, only the segments which intersect with the current clipping volume are sent to the graphics pipeline. The performance for constructing the trace volume can be further increased by reading the slicing result directly from the frame buffer to the 3D texture memory. This can be done using OpenGL's glCopyTexSubImage3D command.</p><p>Sometimes it is possible that some of the streamline segments are perpendicular to the Z = 0 plane. For orthographic projection, these segments will degenerate into a point. In certain graphics APIs, such as OpenGL, the degenerate points are not drawn, which will create unfilled voxels in the trace volume. To avoid this problem, such segments are collected and processed separately in another pass, where the viewing direction and the sweeping of the clipping volume is set to be along the X-axis.</p><formula xml:id="formula_0">(u 1 ,v 11 ) (u 1 ,v 12 ) (u 2 ,v 21 ) (u 2 ,v 22 ) (0,0) (1,0) (0,1) (1,1) v 11 v 12 u 1 u 2 v 22 v 21</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Trace Volume Attributes Generation</head><p>As mentioned earlier, the set of attributes assigned to the voxels in a trace volume is referred to as the trace tuple. It stores two components: the streamline identifier, which differentiates individual streamlines, and the streamline parametrization, which parameterizes the voxels along the streamline. The dimensions of the trace tuple depend on the dimensions of the appearance texture. When a two dimensional appearance texture is used, the trace tuple is a two-dimensional vector, denoted as (u, v). The first component (u) is used to distinguish between different streamlines, and the second component (v) stores the parametrization of the voxels along the streamline. For example, in figure 4, the two streamlines have distinct u coordinates, which will be mapped to different vertical strips in the appearance texture. Along each streamline, the voxels are parameterized by v, which corresponds to a change in the texture coordinates along the vertical direction. When a three-dimensional appearance texture is used, the trace tuple is a three dimensional vector <ref type="bibr">(u, v, w)</ref>, where w is used to parameterize the streamline and a two-dimensional vector (u, v) is used to differentiate the streamlines. We encode the trace tuples into the trace volume during the voxelization process using graphics hardware. Without loss of generality, here we assume that a three-dimensional appearance texture is used. Given an input streamline, we assign the trace tuple <ref type="bibr">(u, v, w)</ref> as colors (red, green, blue) to the vertices of streamline segments. When we slice the streamlines during voxelization, the graphics hardware will interpolate the colors, and thus the trace tuples, for the intermediate voxels between the streamline vertices. Since all vertices along the same streamline share the same streamline identifiers, the interpolation will assign the same value for all intermediate voxels. The graphics hardware will interpolate the streamline parametrization linearly, which allows the appearance texture to map evenly across the streamline.</p><p>The precision limitation in the graphics hardware, however, poses a problem when using a color channel to parameterize the streamline, i.e., representing the w coordinate. In the current graphics hardware, colors and alpha values are represented by fix point numbers (8 bits per channel on most architectures). When we use an 8-bit number to represent the texture coordinate, the quality of the texture lookup result can suffer from quantization artifacts.</p><p>The goal of parameterizing the streamline and using the result as a texture coordinate to look up the appearance texture is to establish the visual correlation between the voxels along the streamline. However, we observe that it is sufficient to maintain only the local <ref type="figure">Figure 5</ref>: Construction of the thick line. A mask is swept along the central streamline. Points on the mask are used to generate vertices for the satellite lines. The parametrization for the lines in the bundle is the same as the central streamline. The satellite lines are assigned identifier values which map to adjacent texels in the appearance texture.</p><formula xml:id="formula_1">p 0 p i m k m j</formula><p>coherence within a nearby vicinity for the voxels along a streamline to depict the flow direction. It is similar to the fixed-length convolution kernel in the LIC. Therefore, to solve the limited precision problem when using a color channel to represent the last component of the trace tuple, we can divide the streamline into multiple segments, and then map the full range of the texture coordinate, i.e., [0,1] onto each segment. In addition, we can have the appearance texture wrap around in the dimension that corresponds to the flow direction. We have found that this solution produces satisfactory rendering result.</p><p>The process of assigning streamline identifiers to different streamlines is dependent on the type of appearance texture being used. For LIC or line-bundle textures, for example, streamlines are randomly assigned identifier values in the range [0,1]. For textures containing a well defined solid structure, as in glyphs, it is important that adjacent voxels are assigned texture coordinates <ref type="bibr">(u, v, w)</ref> which map to adjacent texels in the texture space. Otherwise the 3D structure present in the appearance texture would break down after texture mapping. As will be explained in the next section, we model streamlines as a set of lines surrounding a central line. This central line gets an identifier (u, v) which maps to the center of the 3D structure in the appearance texture. The outer lines are mapped to a close vicinity in the appearance texture. <ref type="figure" target="#fig_0">Figure 3(b)</ref> shows the voxelization results for such a collection of lines where (u, v) values are encoded in the red and green channels, and w is stored in the blue channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Anti-Aliasing</head><p>When the resolution of the trace volume is limited, the above voxelization algorithm will produce jaggy results. In 2D, anti-aliasing lines can be achieved by drawing thick lines <ref type="bibr" target="#b15">[Segal and Akeley 2001]</ref>. The opacities of the pixels occupied by the thick lines correspond to the coverage of their pixel squares. Since line anti-aliasing is widely supported by graphics hardware, one might attempt to use it when slicing through the streamlines during our hardwareaccelerated voxelization process. However, we have found that this doesn't generate the desired effect since no anti-aliasing is performed across the slices of the trace volume. Hence, to achieve streamline anti-aliasing in the voxelization process, one needs to model the thick lines and properly assign the opacities.</p><p>We model the 3D thick line as a bundle of thin lines surrounding a central line. During advection, the streamlines are generated as a set of line segments. After the advection stage, each line segment is surrounded by a bundle of satellite lines, denoted as B = {b k }, where b k is the kth satellite line in the bundle. The line bundle is created by extruding a mask M = {m k } along the streamline during the advection process. Each point m k on the mask corresponds to a vertex of the satellite strip. <ref type="figure">Figure 5</ref> shows two such points on the mask. The distance between two adjacent strips should be small enough to avoid any vacant voxels within the thick line in the trace volume. Initially, the center of the mask is placed at the first vertex of the streamline. Then the mask is swept along the streamline as the advection proceeds. During the sweep, the mask is always positioned perpendicular to the tangential direction of the streamline. When the advection of the medial streamline completes, we construct the line strip b k by connecting the vertices from the corresponding points in the mask along the sweep trace.</p><p>All the lines in the bundle are assigned the same streamline parametrization as the central streamline. As discussed in the previous section, the streamline identifiers of the lines are assigned in a way that maps them to adjacent texels of the appearance texture. Any solid structure present in the appearance texture is preserved after the trace volume is texture mapped. In addition, we assign an opacity value to each vertex on the line bundle so that anti-aliasing can be performed in the rendering stage(sec. 3.5). It is stored in the alpha channel of the vertex attribute. The opacity value is assigned in a way that the vertices near the surface and the endpoints of the thick line receive lower values to simulate the weighted area sampling algorithm <ref type="bibr" target="#b7">[Foley et al. 1990]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Real-Time Rendering Using Dependent Textures</head><p>Today volumetric datasets can be rendered at interactive speeds using texture mapping hardware. In the hardware based volume rendering methods, the volume data is stored as a texture in the graphics hardware. A stack of polygons are textured with the corresponding slices from the volume data and blended together in a back-to-front order to form the final image. If the graphics hardware only supports 2D textures, the volume dataset is represented as three stacks of 2D textures and the slice polygons are axis-aligned. If 3D texture-mapping is supported, the dataset can be represented as a single 3D texture and view-aligned slicing polygons can be rendered.</p><p>In our algorithm, rendering the trace volume requires a two-step texture lookup. The first texture lookup involves the usual slicing through the trace volume, where every fragment of the slicing polygon receives a color. This color represents the trace tuple, which is then used as the texture coordinates to look up the appearance texture to get the final color and opacity for the fragment. This twostep texture lookup can be performed in real time by employing the dependent texture capability provided by the NV_TEXTURE_SHADER extension on nVidia Geforce4 GPUs. <ref type="figure">Figure 6</ref> shows the texture shader setting for the fragment processing stage using the nVidia Geforce4 GPUs. The trace volume is represented by a RGBA 3D texture(Tex0) on the graphics hardware. With the texture coordinates (s,t, r) coming from the sliced polygon, an RGBA texel is fetched from the trace volume. It contains the trace tuple <ref type="bibr">(u, v, w)</ref>, as well as the opacity value α for the purpose of anti-aliasing described in section 3.4. The appearance texture is set to be the second texture, i.e., Tex1. The dependent texture shader is configured to use the trace tuple as the texture coordinates to sample Tex1. The anti-aliasing is done by using the register combiner (NV_REGISTER_COMBINER) to modulate α from Tex0 with the opacity value from Tex1 (figure 10). The normal volume, shown as Tex2 in figure 6, is used for various depth cuing effects and will be discussed in the section 4.2. The last texture shader stage is assigned with a 2D texture (Tex3) which servers as the opacity modulation function and will be discussed later in section 4.3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tex1</head><p>Apperance Texture <ref type="bibr">(u,v,w)</ref> stage 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEPENDENT_TEXTURE_3D</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tex2</head><p>Normal  <ref type="figure">Figure 6</ref>: Texture shader configuration. The trace volume, the appearance texture, the and normal volume are represented as 3D color textures and assigned to the 1st, 2nd and 3rd texture units (GL TEXTURE0 ARB, GL TEXTURE1 ARB, and GL TEXTURE2 ARB), respectively. The 1st and the 3rd texture units receive the texture coordinates interpolated from those specified by glMultiCoord3f(), then the 2nd and the 4th texture units take their results to perform dependent texturing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Appearance Control</head><p>In this section, we show the use of different appearance textures and various visual cues in our algorithm. We also provide some additional implementation details that are not described in the previous sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Appearance Textures</head><p>Our chameleon rendering framework allows the user to experiment with different visual mappings at run time when exploring the underlying vector field. To demonstrate the utility of our algorithm, we have created several appearance textures. Each of them presents a different look and feel. <ref type="figure">Figure 1(a)</ref> shows a LIC-like visualization using a 96 3 tornado dataset. The appearance texture was generated using a 2D LIC texture precomputed from a straight flow, which can be computed very efficiently. We also generated a visualization using a texture that simulates streamtubes with illumination and saturated colors, as shown in <ref type="figure">figure 1(b)</ref>. When using opaque surface-like textures, a better depth cue can be obtained. <ref type="figure" target="#fig_3">Figure 7</ref>(a) presents a visualization with an input appearance texture simulating the line bundle technique( <ref type="bibr" target="#b4">[Crawfis et al. 1994]</ref>). Similar to the LIC texture, the short strokes in the line bundle texture were generated using a straight flow. The tails of the strokes are made more transparent than the heads to emphasize the flow direction. When local glyphs are desired, the user can input a simple voxelized glyphs, such as the arrowhead-shaped solid shown in figure 7(b). All the visualizations were created from the same trace volume, which was created only once, in real time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Depth Cues</head><p>Additional depth cues can be used to enhance the perception of the spatial relationship between flow traces. In our rendering framework, we can incorporate various depth cues such as lighting, silhouette, and tone shading. To achieve these effects, we need to supplement the trace volume with a normal vector for each voxel. Although normal vectors are typically associated with surfaces and not uniquely defined for line primitives, when using 3D thick lines for anti-aliasing as described in section 3.4, the normal vector n j i = (n x , n y , n z ) for jth vertex m j i on strip i can be defined as m j i − v j , where v j is the center of the extruding mask. Alternatively, when the light vector L is fixed, the normal vector can be defined as the one lying on the L − T plane, where T is the tangential vector. This is the technique used by the illuminated streamline algorithm <ref type="bibr" target="#b21">[Zöckler et al. 1996]</ref>.</p><p>Like trace tuples, normal vectors can be assigned to vertices along the thick lines as colors and scan converted during the voxelization process. Since a normal vector is a 3-tuple and the number of color channels is not sufficient to represent both the trace tuple and the normal vector simultaneously, we employ a second voxelization pass to process the streamlines with normal vectors as the colors. Because each component of a normalized normal vector n j i is in the range of [−1, 1], they are shifted and scaled into the [0, 1] range in order to be stored into the fixed-point color channels.</p><p>The normal volume is specified to the second texture unit (Tex2) in the texture shader program ( <ref type="figure">Figure 6</ref>). The same trace tuple fetched from Tex0 to look up Tex1 is also used as the texture coordinates to sample the normal volume. The fetched normal vector is then fed to the register combiner stages on the nVidia GeForce4 GPU to perform various depth cue operations in a single rendering pass. In the following, we provide more details about creating the depth cues lighting, silhouette, and tone shading. Due to space constraints, we only provide the combiner settings for lighting in <ref type="figure" target="#fig_5">Figure 10</ref>.</p><p>Lighting The lighting equation for each voxel in the trace volume is defined as:</p><formula xml:id="formula_2">C = C decal × k di f f × (N • L) +C spec × (N • H) k s )</formula><p>where N, L, H are the normal vector, light vector, and halfway vector, respectively. C decal and C spec are the colors fetched from the appearance texture, and the color of the specular light. k di f f is a constant to control the intensity of the diffuse light. The intensity of the specular light is controlled by the magnitude of C spec , and k s is the shininess of the specular reflection. <ref type="figure" target="#fig_5">Figure 10</ref> shows the configurations of the register combiner stages. Since the normal vector is scaled and shifted in the normal volume as discussed above, we use the EXPAND_NORMAL_NV input mapping functionality of the register combiner (shown as E.N. boxes in <ref type="figure" target="#fig_5">Figure 10</ref>) to map it back to the original [-1,1] range before the dot-product operation. The input mapping UNSIGNED_IDENTITY_NV (shown as U.I. boxes in  Silhouette The spatial relationship between streamlines in the trace volume can be enhanced by using silhouettes to emphasize the depth discontinuity between distinct streamlines. We use the following formula to depict the silhouette of thick lines:</p><formula xml:id="formula_3">C = C decal × (N • E) p +C s × (1 − (N • E) p )</formula><p>where E is the eye vector and C s is the silhouette color. Constant p is to control the thickness of the silhouette. The larger the p, the thicker the silhouette. An example of silhouette-enhanced rendering is given in Figure9(a).</p><p>Tone Shading Unlike lighting, which only modulates the pixel intensity, tone shading varies the colors of the pixels to depict the spatial structure of the scene. Objects facing toward the light source are colored with warmer tones, while the opposite are in cooler tones. We achieve the tone shading effect with the following formula:</p><formula xml:id="formula_4">C = C w ×C decal × (N • L) +C c × (1 − (N • L))</formula><p>where C w is the warmer color such as red or yellow and C c is the cooler color such as blue or purple. <ref type="figure" target="#fig_4">Figure 8(b)</ref> shows the rendering supplemented by tone shading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Interactive Volume Culling</head><p>Clipping planes and opacity functions can be used to remove uninteresting regions from the trace volume. In our algorithm, since the trace volume is rendered using textured slicing polygons, we can easily utilize OpenGL's clipping planes to remove polygon slices outside the region of interest <ref type="figure" target="#fig_6">(Figure 9(a)</ref>). We can also employ a transfer function T based on the velocity magnitude of the vector field to modulate the opacity of the trace volume. The final opacity value of the voxel becomes α × T (v mag ), where α is the opacity value of a voxel described in section 3.4, and v mag is the velocity magnitude at that voxel normalized by the maximum velocity magnitude in the vector field. A simple transfer function, T , that we have used is shown in <ref type="figure" target="#fig_6">Figure 9(b)</ref>.</p><p>We implement the transfer function lookup and opacity modulation using texture shader and register combiners. Recall that Tex2 in <ref type="figure">Figure 6</ref> is an RGB 3D texture which stores the normal vectors used in various depth cuing techniques. We store the normalized velocity magnitude v mag in the alpha channel of Tex2 and assign the transfer function T to the third texture unit Tex3. Although T is essentially a 1D function hence can be realized by 1D dependent texture lookup, we construct Tex3 as a 2D texture with identical rows because currently only 2D/3D dependent texture lookups are supported by the Geforce4 GPU. The shading operation in stage3 is then configured as DEPENDENT_AR_TEXTURE_2D_NV, which uses the alpha and red components of the texel fetched from Tex2 as the texture coordinates to lookup the transfer function bound as Tex3. In the register combiners, we modulate the opacity described in section 3.4 with the value fetched from Tex3( <ref type="figure" target="#fig_5">Figure 10)</ref>. The user can interactively modify the opacity transfer function and render the trace volume in real time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Animation</head><p>For non-directional textures (like a LIC texture), animation provides a way to visualize the flow direction. Using the chameleon algorithm, one can easily create animations by looping through a series of appearance textures, which can be generated easily by continuously shifting the appearance texture along the flow direction in the local texture space. Alternatively, an additional stage in the texture shader program can be introduced to translate the texture coordinates, represented by the trace tuples, along the streamline direction at run time when rendering the trace volume. The advantage of this approach is that multiple appearance textures need not be loaded when producing animations. When the 2D trace tuple (u, v) is used, this translation can be achieved by multiplying (u, v, 1) with the following 2 × 3 matrix M:</p><formula xml:id="formula_5">M = 1 0 0 0 1 δ</formula><p>where δ is the translation amount along the streamline direction and is incremented at each animation step. The translated trace tuple (u, v + δ ) is then used as the texture coordinates to sample the appearance texture. We implement this by assigning the trace tuple (u, v) for each vertex on the streamline as color <ref type="bibr">(u, v, 1)</ref>, and perform the matrix multiplication by the DOT_PRODUCT_NV and DOT_PRODUCT_TEXTURE_2D_NV texture shader operation. To show the effectiveness of our algorithm, we have generated several animations showing the results of our work on the supplementary files accompanying this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Performance</head><p>We implemented our chameleon algorithm on a standard PC using OpenGL (for rendering) and MFC (for creating user interface) li-resolution # of lines 128 3 256 3 7350 2.813 5.718 14700 3.891 7.671 22050 4.641 9.093 <ref type="table">Table 1</ref>: Trace volume construction time (in seconds). The number of lines (first column) includes the satellite lines as well as the central streamlines used for constructing anti-aliased streamlines (sec. 3.4).</p><p>Image Resolution 600 x 600 800 x 800 128 3 volume 17.07 14.95 256 3 volume 14.31 12.13 <ref type="table">Table 2</ref>: Trace volume rendering speed(frames/second).</p><p>braries. The machine is equipped with a single Pentium4 2.0GHz PC with 768MB RAM and nVidia Geforce4 Ti4600 GPU (128MB video RAM). <ref type="table">Table 1</ref> shows the performance of constructing 128 3 and 256 3 trace volumes for the 96 3 tornado data set. The timings include the advection and rendering of the streamlines, as well as transferring the voxelization results from the frame buffer to the 3D texture memory for all the 128 or 256 slices. The construction time increased as we increased the number of streamlines. However, rendering and frame buffer transfer are all done using graphics hardware. Therefore, we are able to construct the trace volumes very efficiently. The number of lines in the first column includes the satellite lines as well as the central streamlines used for constructing anti-aliased streamlines (sec. 3.4).</p><p>Once the construction of the trace volume is completed, the rendering speed is independent from the streamline geometries. Since Chameleon performs hardware texture-based volume rendering, which is essentially fill-rate limited, the rendering speed is only dependent on the resolution of the trace volume as well as the size of the viewport. <ref type="table">Table 2</ref> shows the speeds for rendering 128 3 and 256 3 trace volumes. Using graphics hardware, we are able to perform interactive rendering of the trace volumes at a speed of more than ten frames per second. This allows the user to explore the vector field interactively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Future Work</head><p>We have presented an interactive texture-based technique for visualizing three-dimensional vector fields. By decoupling the calculation of streamlines and the mapping of visual attributes into two disjoint stages in the visualization pipeline, we allow the user to use various appearance textures to visualize the vector field with enhanced visual cues. We plan to extend our work to achieve level of detail by using multi-resolution trace volumes and next-generation graphics hardware which provides full programmability in the rasterization stage. With the support of the floating-point datatype on the new hardware, the image quality can be further improved. Many traditional volume rendering techniques can also be incorporated into the Chameleon framework.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>(a) The slice sweeping voxelization algorithm. The near and far clipping planes are translated along the Z axis. At each position of the clipping planes, the streamlines are rendered to generate one slice of the trace volume. (b) A trace volume containing a thick anti-aliased streamline. The streamline parametrization is stored in the blue channel, while the streamline identifiers are stored in the red and green channels (sec.3.3, sec.3.4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>The use of trace tuples as texture coordinates. Left: Trace tuples are assigned to streamlines and stored in the color channels. Right : Trace tuples in the texture space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Different appearance textures. (a) Line bundles. (b) Glyphs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Different depth cuing techniques. (a) Lighting. (b): Tone shading.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 10 )</head><label>10</label><figDesc>clamps any negative dot product result to zero.Figure 8(a)shows the effect of using lighting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Interactive Volume Culling. (a) culling with clipping plane and opacity modulation. Rendered with silhouette enhancement. (b) opacity transfer function T (v mag )</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head><p>This work is supported in part by NSF grant ACR 0222903, NASA grant NCC-1261, Ameritech Faculty Fellowship, and Ohio State</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Register Set</head><p>Seed Grant. We thank Dr. Roger Crawfis for his help. We also thank the anonymous reviewers for their insightful comments.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Hardware accelerated interactive vector field visualization: A level of detail approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">D</forename><surname>Bordoloi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Eurographics &apos;02</title>
		<meeting>Eurographics &apos;02</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="605" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Imaging vector fields using line integral convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 93</title>
		<meeting>SIGGRAPH 93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Direct volume visualization of threedimensional vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1992 workshop on</title>
		<meeting>the 1992 workshop on</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="55" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Texture splats for 3d vector and scalar field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;93</title>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="261" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Graphics and Applications</title>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="50" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Visualization of 3-d vector fields: Variations on a stream</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Darmofal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AIAA 30th Aerospace Science Meeting and Exhibit</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast csg voxelization by frame buffer pixel mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Liao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 IEEE symposium on Volume visualization</title>
		<meeting>the 2000 IEEE symposium on Volume visualization</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="43" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Feiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Hughes</surname></persName>
		</author>
		<title level="m">Computer graphics: principles and practice</title>
		<imprint>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
	<note>2nd ed.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Constructing stream surfaces in steady 3d vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hultquist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="171" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Strategies for effectively visualizing 3d flow with volume lic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Interrante</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;97</title>
		<meeting>Visualization &apos;97</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="421" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Creating evenly-spaced streamlines of arbitrary density</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jobard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lefer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eight Eurographics Workshop on visualization in scientific computing</title>
		<meeting>the eight Eurographics Workshop on visualization in scientific computing</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multi-frequency noise for lic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-H</forename><surname>Kiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Banks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Visualization &apos;96</title>
		<meeting>the conference on Visualization &apos;96</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="121" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Flow volumes for interactive vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;93</title>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="19" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Compositing digital images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th annual conference on Computer graphics and interactive techniques</title>
		<meeting>the 11th annual conference on Computer graphics and interactive techniques</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1984" />
			<biblScope unit="page" from="253" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interactive volume on standard pc graphics hardware using multi-textures and multi-stage rasterization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rezk-Salama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Greiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2000 SIG-GRAPH/EUROGRAPHICS workshop on on Graphics hardware</title>
		<meeting>2000 SIG-GRAPH/EUROGRAPHICS workshop on on Graphics hardware</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The OpenGL Graphics System: A Specification (Version 1.3). OpenGL Architecture Reference Board</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Segal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Akeley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A new line integral convolution algorithm for visualizing time-varying flow fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Visualizing vector fields using line integral convolution and dye advection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1996 Symposium on Volume Visualization</title>
		<meeting>1996 Symposium on Volume Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast and resolution independent line integral convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stalling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;95, ACM SIGGRAPH</title>
		<meeting>SIGGRAPH &apos;95, ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="249" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Spot noise: Texture synthesis for data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="309" to="318" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Image based flow visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th annual conference on Computer graphics and interactive techniques</title>
		<meeting>the 29th annual conference on Computer graphics and interactive techniques</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="745" to="754" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Interactive visualization of 3d-vector fields using illuminated stream lines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zöckler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stalling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Visualization &apos;96</title>
		<meeting>the conference on Visualization &apos;96</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
