<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visibility based methods and assessment for detail-recovery</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Tarini</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Scopigno</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Istituto di Scienza e Tecnologie dell&apos;Informazione -Consiglio Nazionale delle Ricerche</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">ISTI-CNR</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Visibility based methods and assessment for detail-recovery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.7 [ Three-Dimensional Graphics and Realism]: Color</term>
					<term>shading</term>
					<term>shadowing</term>
					<term>and texture-; simplification</term>
					<term>texture mapping</term>
					<term>detail recovery</term>
					<term>normal mapping</term>
					<term>texture for geometry</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper we propose a new method for the creation of normal maps for recovering the detail on simplified meshes and a set of objective techniques to metrically evaluate the quality of different recovering techniques. The proposed techniques, that automatically produces a normal-map texture for a simple 3D model that &quot;imitates&quot; the high frequency detail originally present in a second, much higher resolution one, is based on the computation of per-texel visibility and self-occlusion information. This information is used to define a point-to-point correspondence between simplified and hires meshes. Moreover, we introduce a number of criteria for measuring the quality (visual or otherwise) of a given mapping method, and provide efficient algorithms to implement them. Lastly, we apply them to rate different mapping methods, including the widely used ones and the new one proposed here.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A common solution to efficiently represent small scale geometric details on a surface is to use bump or normal maps. For years the use of bump maps has been a common practice in high quality, non-interactive renderings. Low-cost consumer graphics hardware that is able to efficiently perform the hardware accelerated rendering of surface with normal and texture maps <ref type="bibr" target="#b12">[Kilgard 2000</ref>] has recently become common; therefore the use of this technique is becoming more and more common among interactive 3D applications like games <ref type="bibr" target="#b3">[Blasco 2002]</ref>, or in the visualization of complex object like the one obtained by range scanning <ref type="bibr" target="#b2">[Bernardini et al. 2001]</ref>.</p><p>There are two main techniques to produce normal maps: artistic and automatic. The first one is the classical artistic approach where a talented professional illustrator paints, by hand, the small scale reliefs of a surface in gray scale tones. Usually this bump map is then automatically converted in a normal map for efficient rendering. In the latter approach, the automatic way, we suppose that there exists, in some form, a digital high resolution representation <ref type="figure">Figure 1</ref>: The concept of detail recovery: a low resolution mesh M L is sampled and for each point p i we search the corresponding point F(p i ) on the high res mesh M H ; using a texture, the detail found in F(p i ) is mapped onto p i .</p><p>of the object and some automatic tool that is able to convey as much information as possible from this model onto the surface of a low resolution model.</p><p>The first one, the artistic approach, is very well suited if we consider painting as a part of the modelling process, or if the small scale features represent mainly a kind of information that is more qualitative than precise and exact. For example this approach works well for drawing the scales of a monster or to add a scar on the face of a character.</p><p>The second one, the automatic approach, also known as detail recovery <ref type="bibr" target="#b8">[Cohen et al. 1998;</ref><ref type="bibr" target="#b13">Krishnamurthy and Levoy 1996]</ref>, has been introduced recently and is becoming more and more common for two reason: a) it allows to efficiently represent with just a small number of polygons objects that seems quite complex <ref type="figure" target="#fig_4">(Fig 7/8</ref>), b) high resolution version of the same object are often available for various reasons; e.g. in games high res models are used for the creation of prerendered introductive cutscene animations. In visualization scenarios often we can have data at a resolution much higher than we are able to interactively visualize, consider for example the interactive display of high resolution 3D scanning of Cultural Heritage objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Detail recovery</head><p>The typical detail recovery phase (see <ref type="figure">Fig. 1</ref>) uses, as input, the following data:</p><p>• a complex high resolution 3D mesh M H (e.g. the result of a 3D scan or of a modeler), provided with some implicit or explicit detail function D returning for each 3D point over M H the "detail", in some form, to be recovered;</p><p>• a much simpler, low resolution mesh M L (e.g. automatically obtained by simplification or created by hand by a talented low-poly modeler) with a good texture parameterization of its surface.</p><p>The function D(p) that defines the "detail" of M H , depends on the application: it can return the normal direction of p on M H , or a shading performed according to that normal in a fixed lighting conditions, or a color defined in M H either per vertex or via textures, <ref type="bibr">IEEE Visualization 2003</ref><ref type="bibr">, October 19-24, 2003</ref>, Seattle, Washington, USA 0-7803-8120-3/03/$17.00 ©2003 IEEE or even other things as a value for the accessibility of p in M H , or a self-shadowing bit of p for M H , or even a parametric color value defined by the position of p (e.g. for simulation of the wood appearance), or a combination of some of the above elements. It does not matter, as long as D is defined for any point p ∈ M H and returns values which can be stored in textures (the parameter p can be identified, for example, by a face pointer and two barycentric coordinates relative to that face). The detail recovery phase constructs a texture T for M L as follows:</p><p>for each face f of M L , for each texel t of the texture space assigned to f , let p ∈ M L be the 3D point corresponding to t, choose a suitable 3D point F(p), in M H store D(F(p)) in t Note that we explicitly need a point-to-point mapping function F that gives, for each point of the low res mesh M L , a corresponding point of the high resolution mesh M H .</p><p>The mesh M L , enriched with the ad-hoc texture T , is much more manageable and convenient in terms of rendering time and size with respect to the original mesh M H , but still appears quite similar to it. The quality of the final result of this detail recovery process depends, at least, on three factors, some of which represent a compromise of cost/benefit: • the quality and the severity of the simplification: the smaller the M L model the larger will be the difference from the original one M H ; • the quality of the texture parametrization and the size of the texture used to store the recovered details simplification; • the nature of the mapping F, i.e. how we choose for each point of M L the corresponding point of M H .</p><p>The first two items have been subject of very intensive research and will not be discussed here further. This paper focuses instead on the point-to-point mapping F.</p><p>Paper organization: First, we will present three different classes of approaches to define and perform the mapping F (Section 3).</p><p>Two of them are already known, and one is a novel contribution of this paper. For these approaches, we also discuss some implementation issues, optimizations, and some problems to be solved in order to get a robust and efficient implementation.</p><p>In order to have a comparative analysis, we introduce in Section 4 a new set of measures and tools designed to rate the performance of a given mapping F used over a given model pair M H , M L .</p><p>Then we show in Section 5 comparative performance results of the various technique described, both visually and reporting the results of the above-described tools.</p><p>Novel contributions: First, the definition of an alternative way to perform the mapping F that uses the notion of average visibility direction, including some variants and details about how it can be efficiently implemented; second, the definition of the new set of automatic measures and tools to rate a performance of an given application of any mapping F; lastly, the application of the latter to the former, and a comparison with other know mappings F, that shows that our solution for F is indeed a valid one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>A simplified model with a good texture parameterization on it is required to perform detail recovery. Much work has been done in the field of (semi-)automatic u-v mapping generation; an overview of the major contributions in this field can be found in <ref type="bibr" target="#b10">[Desbrun et al. 2002]</ref>. We will just assume that a complete u-v mapping is given for the mesh M L , seamlessly or not, providing per-wedge texture coordinate for each triangle in it, and therefore assigning some texture space for each face. Similarly, mesh simplification <ref type="bibr" target="#b11">[Garland 1999</ref>] can be used to automatically obtain M L from M H instead of hand modeling it. We will not make any assumption of how we have obtained M L but we will rely only on the fact that M L and M H are sufficiently similar and they share the same coordinate system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Detail recovery</head><p>To our knowledge the first paper explicitly proposing this approach was <ref type="bibr" target="#b13">[Krishnamurthy and Levoy 1996]</ref> where bump maps are applied to a nurbs model in order to catch the appearance of a high resolution scanned model. The first approach that was able to manage detail recovery for triangular meshes was presented by <ref type="bibr" target="#b8">[Cohen et al. 1998</ref>]. In this paper the simplified model M L must be obtained from M H by using a constrained simplification algorithm that explicitly construct the mapping function F during the simplification process itself. As a drawback, this approach forces the adoption of a particular simplification algorithm, preventing a vast majority of cases where users want to use a different simplification or to model the simplified mesh directly (the standard way of creating the low-poly models used in gaming environments). The first general approach in which the detail recovery is explicitly de-coupled from the simplification strategy was proposed in by <ref type="bibr">[Cignoni et al. 1998a]</ref>. This is more widely applicable; moreover the function F, used only in the detail recovery phase, can be chosen freely.</p><p>In <ref type="bibr">[Cignoni et al. 1998a</ref>] the use of both a proximity and raycasting along normal strategies are discussed and the first one is proposed (see Sec. 3.1) for robustness reasons explained in <ref type="bibr" target="#b7">[Cignoni et al. 1999]</ref>. A hybrid approach based on a ray-casting along normal strategy (see Sec. 3.2) coupled with nearest point selection in case of ray-miss (see Sec. 3.2) has been proposed in <ref type="bibr" target="#b16">[Sander et al. 2000]</ref>.</p><p>Given the wide diffusion of consumer graphics hardware able to perform normal map shading, some hardware producers are endorsing diffusing this kind of techniques in technical conferences <ref type="bibr" target="#b15">[Maughan 2003</ref>] in order to encourage a better exploitation of hardware capabilities. The approaches presented there fall in the category of normal based ones (see Sec. 3.2 later).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Measuring accuracy and visibility computation</head><p>The idea of taking objective measurements for quality assessment for simplification algorithms for 3D meshes has been presented in <ref type="bibr">[Cignoni et al. 1998b;</ref><ref type="bibr">Cignoni et al. 1998c]</ref> where the Hausdorff distance has been chosen to measure the difference between the original and the simplified meshes. More recently <ref type="bibr" target="#b14">[Lindstrom and Turk 2000]</ref> a image-space measure has been proposed to measure the difference among M L and M H by comparing the rendered images of the two meshes from a small set of fixed viewpoints. This measure can drive the simplification process in order to obtain simplified models that are visually very similar. This approach has been extended in <ref type="bibr" target="#b17">[Zhang and Turk 2002]</ref> by introducing the concept of visibility of a surface point as a scalar quantity measuring its accessibility from outside. This quantity can be used to weight the simplification process so that less visible parts are discarded early. Note that while these approach use visibility as a scalar quantity (the extent to which a given region is on average visible),in our case we are more interested in average visibility as a vector quantity (from which direction a given region is on average seen) and, to a smaller extent, visibility variance (the variance of that vector average).</p><p>1. proximity based: pick the p ∈ M H closest to p according to Euclidean distance;</p><p>2. ray-casting along normal: pick as p the closest intersection between M H and the ray starting from p and going along the</p><formula xml:id="formula_0">normal direction n(p) of p in M L ;</formula><p>3. visibility based: pick as p the closest intersection between M H and the ray starting from p and going along the average</p><formula xml:id="formula_1">visibility direction v(p), in M L , of p;</formula><p>In a further subsection, we will also present and discuss an hybrid of the latter two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Proximity based</head><p>Choosing the closest point has been used in <ref type="bibr">[Cignoni et al. 1998c]</ref>. Proximity based approaches have the advantage of being very robust (they do not even require a normal to be defined over M L ).</p><p>Moreover, F tend to be continuous, more than in other cases. A caveat is that when M H presents two close surfaces, it can happen to pick a point of the wrong one. In practical cases, this can be partially helped, discarding any candidate points p ∈ M H with a negative n(p) • n(p ) dot product.</p><p>Implementation issues Closest point research can be taxing. In our prototype (as in <ref type="bibr">[Cignoni et al. 1998c]</ref>), all the faces of M H are first spread into cells of a regular grid <ref type="bibr" target="#b0">[Akman et al. 1989</ref>]: a pointer to that face is replicated in all the touched cells. To find the closest point of p, first we compute the distance from p to each face present in the cell to which p belongs, than we check neighbors cells at increasing distance only until the closest non-checked cell is further than the minimal distance found up to that point (usually less than 6 cells need to be checked). To minimize the number of triangle-to-point distance computations, we adopt an incremental marking scheme on faces, so that the same face is not checked twice in the same search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Ray-casting along normal direction</head><p>Following the ray along the normal direction is another common approach (e.g. <ref type="bibr" target="#b15">[Maughan 2003;</ref><ref type="bibr" target="#b16">Sander et al. 2000]</ref>). The rationale is that in mesh M L point p will be well visible when seen orthogonally to the view direction, and therefore during the texture construction we should optimize for that case.</p><p>In order to avoid unneeded discontinuities in function F at the edges of M L , the normal field n(p) has to be continuous over p ∈ M L ; therefore n(p) is found interpolating the normal vectors stored at vertices (a-la Phong shading), rather than using the normal of the face including p.</p><p>Managing ray misses Using ray-casting, F is not guaranteed to be defined over all M L : ray casting (differently from closest point search) can "miss" M H altogether. In some application, this does not represent a problem when occurs in proximity of borders of M L : when F(p) fails, the texel t corresponding to p is filled with a blank (e.g. black or a transparent α = 0 color value).</p><p>Unfortunately F can also fail far from any border (actually, even if M L and M H are closed, see <ref type="figure">Figure 2</ref>). A similar case is when the ray hits M H , but very far from p, even tough a much closer point exists in M H . More specifically, if the distance between p and F(p) exceeds an used defined upper limit dist max , the ray cast is to be considered a miss as well.</p><p>Note that those cases can happen even if M H and M L are close in proximity of p, especially if p lies near convex edges of M L .</p><p>When one of the cases above is detected for a point p, a good strategy is to switch to a proximity based approach for just that <ref type="figure">Figure 2</ref>: If F is implemented as a raycast, it can miss M H . point (as proposed in <ref type="bibr" target="#b16">[Sander et al. 2000]</ref>). This, however, can occasionally produce unneeded discontinuities when switching from a method to the other one. Another approach is to leave the affected texels blank and fill them in a second pass expanding values from neighbors texels.</p><p>Ray orientation Given a point p, p = F(p) can be both below or above the face of M L where p is (unless some assumptions are done on the simplification algorithm used to obtain M L ). Therefore, rather than a single ray, we would need to cast two rays, both starting from p and going toward n(p) and −n(p) respectively. If both rays hit a valid face of M H , precedence should be given to the one going outward, to reflect the proper occlusion order.</p><p>Implementation issues Again, sorting pointers to the faces of the input mesh M H into cells greatly improves performance. Similarly to many other ray-casting approaches, we also need a grid traversal algorithm <ref type="bibr" target="#b1">[Amanatides and Woo 1987]</ref> that identifies all the cell touched by the ray. In this way, it is also easy to stop the search as soon as threshold distance dist max has been traversed along the ray without hitting any valid face.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Visibility based</head><p>Using average visibility direction on M L represents a novel contribution of this paper. The strategy looks promising: the expectance is that the average visibility direction v(p) at point p is a good predictor to the specific viewing direction from which p will be seen at rendering time, reducing the visual difference between the rendering of the textured M L and the original M H .</p><p>Many considerations that are valid for the raycasting along normal approach, and in particular the problem of the misses, the ray orientation, and the implementation issues (sec. 3.2), are valid also for this approach.</p><p>In addition, new issues arise, concerning the definition of the visibility direction. In fact, we need an estimation v(p) of the average visibility direction at a point p of the surface. That estimate can be computed per face, per vertex or per texel.</p><p>The averaged visibility direction is recovered in a way similar to <ref type="bibr" target="#b17">[Zhang and Turk 2002]</ref>. We are looking for the average visibility direction</p><formula xml:id="formula_2">v(p) = Avg p visible from d i (d i )<label>(1)</label></formula><p>We perform a series of probe renderings of M L as seen from a number n of directions d 1 ..d n well distributed over the normal sphere (a good value for n is around 2 9 , see <ref type="bibr" target="#b17">[Zhang and Turk 2002]</ref> for a more detailed analysis). The rendering are performed using orthogonal projections (so that the viewing direction is kept constant for all pixels in the image), while the z-buffer takes naturally in account any self occlusion.</p><p>At each rendering, we get the video buffer and we record for each element whether and to which extent that element was visible from that direction, finding the average of all such directions.</p><p>Per face A intuitive strategy is to assign to each face of M L an average visibility direction. To do this, we color each face with an unique color identifier, constant over the face. For each nonbackground pixel found in the rendering done under direction d i , we add d i to the (initially zeroed) average visibility directions of the face corresponding to that color. Note that since this is done for each pixel, the contribution of a probe view direction d i to the averaged visibility direction of a particular face is proportional to the extent to which that face is visible from that direction.</p><p>As for the normal direction case, we need the directions v to be continuous over M L . Therefore the visibility directions computed at faces are not used directly, but first averaged at vertices, and then interpolated again for each internal point (the per vertex is angleweighted).</p><p>This strategy implies an averaging and a spreading of the computed visibility directions: since this seemed excessive, especially for meshes M L with small (order of hundreds) of faces, we developed the two following additional strategies.</p><p>Per vertex Visibility directions can also be computed per vertex of M L . This, however, cannot be done by directly recording, for each vertex, the directions for which that vertex is visible: since vertices in M L are supposed to be sparse, many times they are not visible even if the adjacent faces are. A better algorithm consists in performing two renderings for each view direction: the first to identify the face (as before), the other to identify the position of the seen pixel inside that face. For the second rendering, we use the same color scheme for all faces: each wedge is color-coded differently (using pure colors), so that it is easy to reconstruct form the interpolated color the barycentric coordinates of the point relative to the belonging face. Each barycentric coordinate is used to weight the term d i to the visibility direction computed for the respective vertices, so that a given pixel of a probe rendering affects close vertices more than distant ones.</p><p>In this way the direction field v will still be continuous (for each point p ∈ M L it is interpolated from values defined at vertices), but the artificial averaging and spreading of computed visibility vectors is sensibly reduced.</p><p>Per texel For an even finer grade estimation of the averaged visibility direction over M L , we can also compute it relatively to each texel. In this case, the probe renderings are performed displaying M L with the same texture coordinate as the final texture to be constructed, but color-coding differently each texel (this is possible in a single pass, since we have around 2 20 ..2 24 different texels, for a typical 1024..4096 squared texture, and, including the α channel , 2 32 different color values).</p><p>At each texel we sum together all the directions d i under which that texel was spotted in the corresponding probe rendering.</p><p>Still, this generates three problems. First, some texels will not be visible from any point of view. Second, the resulting visibility directions will be far more noise plagued, as we are distributing the same number of samples (each non-empty pixel is a visibility sample) over a much wider set of buckets (the texels). Third, in correspondence of mesh edges (especially convex ones) discontinuities of visibility direction arise.</p><p>To solve all three problems, we apply, in a second pass, a smoothing filter to the resulting visibility direction field in texture space. The filter is actually applied before averaging: during visibility computation for each texel we record both the (not normalized) total vector sum v of all visible directions v and their number k. The smoothing filter consist simply in summing in each texel both v and k of neighbors texels. This way, void texel are filled, and averaged visibility directions computed from many samples are weighted more than the ones computed from a few ones.</p><p>A unresolved problem is that, for the filter to work, the texture must be seamless, or, else, a smart scheme of texel neighborhood must be adopted that takes in account the texture coordinate scheme (to assign to border texels "neighbors" that are such only in object space, rather than in texture space).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Hybrid using variance</head><p>Comparing results coming from the application of the last two strategies (raycasting along normal or along visibility direction), it emerged that in some locations the former performed better, in other ones the latter. Therefore an hybrid approach could be introduced: since they are both ray-casting based approach, to hybridize them it is just a matter of using, as a ray direction for point p, an interpolation of normalized vectors n(p) and v(p).</p><p>To find the interpolation weight we use the standard deviation σ (p) of the set of directions from which p is visible. In fact, if the variance of visibility σ (p) is low, it means that point p on M L , whenever it is visible, it is such from a predictable point of view; in this case it makes perfect sense to use that direction for texture reconstruction purposes. On the contrary, high variance σ (p) 2 signals that point p will be seen from many different directions, therefore the average visibility direction v(p) will be, on one hand, less significant, and on the other, its use will improve the rendering of M L at point p only in a few cases, making more appealing to resort to the normal directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation issues</head><p>The computation of the standard deviation of the set of visibility can be performed almost for free. In fact, σ (p) 2 can be defined as follows:</p><formula xml:id="formula_3">σ (p) 2 = Avg p visible from d i (d 2 i ) − Avg p visible from d i (d i ) 2<label>(2)</label></formula><p>The first average equals to 1 (as d i are normalized), and the second element is just v(i) 2 . Therefore:</p><formula xml:id="formula_4">σ (p) = 1 − v(p) 2</formula><p>(3)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Measuring tools</head><p>In the previous section we listed several different approaches to perform the mapping F from points in M L to the ones in M H . Which method is to be preferred? One natural way to answer the question is to visually compare the results. We show a comparison in the Results section. However it helps to rate the results also with some measurable and less subjective way. For this reason we developed a small set of automatic measuring tools aimed at that purpose, which we present in this section.</p><p>Namely, three tools measure the result of a given application of F under three different consideration:</p><p>• "object space" distance, a view depended measure of the discrepancy between the textured M L and M H ;</p><p>• "image space" distance, a view depended measure of discrepancy between renderings of M L and M H , or equivalently a measure of the self coherence of the textured M L (this measure can be either normalized or not, see below);</p><p>• the uniformity of the resulting sampling.</p><p>For all the three notions of quality we are able not only to find an overall quality value for a model with a texture resulting from a particular choice of F, but also to plot a distribution of that value over the surface of M L (see <ref type="figure" target="#fig_2">Figure 5</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">View dependent object space distance</head><p>This measurement (and the next one) is a view dependent one: the total quality estimation will be a sum of contributions relative to the conditions recorded from different point of views. Therefore we choose a number (around 512) of well distributed point of views around M L to be used for measurement purposes.</p><p>Consider a textured rendering of M L (see The visual difference along a given ray (that is, at a given pixel of the rendered image) will be therefore the difference between the renderings of details associated in M H to the two different points p H and p H , that is D(p H ) and D(p H ). For sake of generality, we want to decouple our measure of F from any particular D associated to M H ; therefore we just use the Euclidean distance between p H and p H (which for values smaller than topological features size of the mesh is a good approximation of the geodesic distance); that quantity, squared and integrated over all rays and the sampled view directions, gives a measure of how good F is. Note that the measure is view dependent, because such is the correlation between p L and p H .</p><p>In the cases when ray r i misses M H or M L , then of course the problem is not in the texture but in the geometry alone, and therefore that ray is to be ignored. Implementation This measurement algorithm needs to test over a great quantity of rays (in our prototype, order of 10 8 rays). Luckily the implementation will take advantage of graphical acceleration.</p><p>To implement the measurement tool, we first of all need to build a probe texture for M L , in the standard way, using the F we want to test. As for D, as we have seen we don't want to use any particular detail function but rather, for generality sake, a simple mapping from R 3 to color space (using as boundaries the bounding box of</p><formula xml:id="formula_5">M L and M H ), so that D differentiate every point of M H .</formula><p>Then, it will be enough to compare, for each view direction we want to test, pixel per pixel, a rendering of M L texture with the probe texture, to a rendering of M H , colored per vertex, assigning <ref type="figure">Figure 4</ref>: A color coding of the per-texel average visibility direction (on the left, vector pointing left, right and down are colored red, blue and green respectively) and the visibility variance (on the right, mapped from dark blue -lower, to dark green -highest). The original dataset visible in <ref type="figure" target="#fig_4">Figure 7.</ref> to each vertex v i the color D(v i ). Naturally both renderings will be done using the same point of view. In both renderings care must be taken to disable lighting, anti-aliasing, mipmapping and anything that would affect the rendered colors. Also, for non-closed models, back oriented faces must be displayed with background color, so that they will be present as occlusors but otherwise ignored by the algorithm. Then, for each pair of non-background pixels at the same position in the two rendering, we just apply D −1 to both and find the Euclidean distance between the two results. The View Dependent Object Space distance is found by averaging this distance over all pixels of all renderings.</p><p>Since the color space, with 8 bit per components, has not enough resolution and would introduce quantization noise in the measurement, we resorted to two consecutive renderings instead of one, and two probe textures, so that we can store the 3D position in 64 bits instead of 32.</p><p>To avoid an interference when testing a F that uses visibility direction (see Sec. 3.3), the set of random viewing directions we use to test F is a different one to the one used in the definition of F to find the average visibility direction.</p><p>Since each pixel of the rendering contributes to the total error, this method automatically gives more weight to the parts of M L that are more visible, whether they are so because of (lack of) occluders or because of orthogonality with the view direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">View dependent image space distance</head><p>The mesh M L is just an approximation of M H ; moreover, it does not represent a strictly self-coherent 3D mesh. In fact during the renderings, a point p i on its surface is displaced on the screen according to its real position, but is colored (and, in case of bumpmapping, shaded) according to how it would be if it was in another, different position F(p i ). The discrepancy of the two (in image space) depends much on the choice of F and can be measured. Note that this is a measure of the textured M L alone, not strictly a comparison with M H . The mesh M H affects the results only because the image of F is bounded to lie in M H .</p><p>More precisely, we can take a large set of test viewing rays, and, for each ray r i that hits M L in p L we measure how far the point F(p L ) is from the ray r i (see <ref type="figure" target="#fig_0">Fig. 3</ref>).</p><p>Note that this is not the same as measuring the average distance between p L and F(p L ): the vector (p L − F(p L )) can be long in module but have its effects partially cancelled by its parallelism with the view direction. Implementation It is a variant of the one done for the object space measurement, and uses the same probe textures. This time, we render only M L , with the probe textures as before, seen under orthogonal projections. For each not-background pixel c with value c rgb at window position (c x , c y ), we recover the position p = F(p) by p = D −1 (c rgb ); to find the ray-to-point distance, (since the projection is orthogonal) we compute the distance between (c x , c y ) and the window position of p projected under the current view transformation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Problems with image space distances</head><p>The Image Space distance is probably the more intuitive error measure, because it is a direct measure of pixel-by-pixel distance between a rendering of the real geometry and the one "simulated" by the texture. Still, as it is, that measure proves trickier than it seems (see <ref type="figure">Fig. 1</ref>): being Pixel-per-Pixel, it fails to penalize discontinuities in the rendering; moreover, in practice it is basically influenced solely by the average distance between p and F(p) (shorter distances rating better) which is not by itself a valid criteria, as we will show shortly (if it was, than the Proximity based F would be a very good choice, which is not, see <ref type="figure">Fig. 1</ref>).</p><p>To solve the latter problem, a good countermeasure is to normalize the image space distance dividing it at each ray by the distance between p and F(p).</p><p>To solve the former problem (failure to penalize discontinuities) we can apply separately the next criteria.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Sampling uniformity</head><p>The texture we are going to produce for M L will represent, in a sense, a sampling over M H . Therefore we can rate F analyzing this sampling, for example by measuring how well distributed it turns out to be (or rather, how closely the resulting sampling matches the one implicitly specified by texture coordinates). IEEE Visualization Let T ⊂ M L be set of 3D points that are represented by a texture sample, we want to measure how well distributed is F(T) ⊂ M H .</p><p>The sampling uniformity of T itself depends on the quality of the u-v mapping of M L , which is outside our scopes. Therefore, we will measure how much "worsened" is the resulting sampling of F(T)</p><p>in respect to T . More precisely we use, as a comparative measure, the average of percentage increase/decrease of the the Euclidean distance of elements of F(T) from their neighbors, in respect to the correspond- ing ones in T (considering two elements of F(T) to be neighbors when the respective texels are adjacent). Of course we average absolute percentages, meaning that we consider a 20% decrease the sampling distance to be as bad as a 20% increase (being the number of samples equal).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results and discussion</head><p>In order to test the different strategies of F, we implemented and applied them on mesh pairs M H M L . The results have been compared with the tools introduced in Section 4, and also by simply looking at the rendering of the resulting textured version of M L .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Test-bed</head><p>In our case, meshes M H comes from automatic acquisition: the "high-relief" dataset (250k faces), a laser scan of a high relief marble sculpture, and the a Michelangelo model (400k faces).</p><p>The original datasets were simplified to a thousands faces by an automatic quadric error based simplification software to create the low resolution meshes M L . We also needed a texture parameterization for M L : we used a trivial mapping of each triangle in a separate squared isosceles triangle (including some borders to mask the discontinuities), or, when we needed a seamless texture (see Section 3.3, Per Texel) we used the an ad hoc seamless parameterization for the high-relief model. In any case, in order to minimize the impact of the quality of texture parameterization, we used high resolution 2048 squared textures. For the renderings aimed at a subjective comparison we used, as detail function D(p), the normal of p in M H , thus obtaining a normal map to be rendered with standard GPU hardware <ref type="bibr" target="#b12">[Kilgard 2000</ref>  In each column, the position of the best performer is highlighted. Per Texel strategies could not be tested over the second dataset because it lacked a seamless u-v mapping.</p><p>Results <ref type="figure" target="#fig_4">Figures 7 and 8</ref> shows some rendering using different choices of mapping F, while <ref type="table" target="#tab_1">Table 1</ref> list the numerical values resulting from the tools as described in Sec. 4.</p><p>Discussion All in all, both measurements and subjective visual comparisons show that the Proximity based methods perform on average bad (except for the Images Space distance, for the reasons explained in Section 4.2.1), especially for their effect on the sampling uniformity. Still, they represent the more robust approach, especially if no holes are acceptable in the texture (for example, the black spots in the last three images of <ref type="figure" target="#fig_4">Figure 7</ref> are "ray that missed"). This, as mentioned, makes them the ideal fall-back strategy, to apply locally when other ones fail (as was suggested in <ref type="bibr" target="#b16">[Sander et al. 2000]</ref>).</p><p>Normal Based and Visibility based strategies tend to perform similarly, each prevailing in some circumstance and under some criteria. They have an opposite visual effect: sometimes they give a perception of "faked" geometry that looks respectively flatter, or bumpier, than it should. Note that for most parts of most meshes the two strategies do not differ too much (in absence of occlusions, the average visibility direction of a face is also its normal).</p><p>It is easy to see the reason behind the equivalence of the performances: both ray-casting approaches obviously give best results when the face of M L rendered is seen from a view direction similar to the direction of the ray-cast, that is, the normal or the average visibility direction (respectively). The normal based approach is advantaged by the maximized screen area that is covered by the face in that case; the visibility based approach has instead the advantage that the face is often occluded in the non optimal cases. The Hybrid approach (using variance) performs somewhat in between the two, but never rates much worse than either, possibly making it the best overall candidate. Also, it tends to produce renderings more visually similar to the original model. As a last note, the Visibility direction (whether used pure or in conjunction with the normal) sometimes gives better results when computed per texel than when computed per vertex. However, to compute it per texel requires a seamless u-v mapping for M L (or at least a smarter texel neighborhood scheme capable of "jumping over" texture boundaries). Both ways are better than the Visibility computed per Face (and then averaged at vertices), whose results, for conciseness, are not reported in the tables. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Extensions and future work</head><p>The work we presented here can be extended in many directions.</p><p>In our work, the set of non occluded view direction for a given point are just averaged together; instead, when the variance of that set is high, a clustering could be attempted first: if the non-occluded view directions are groupable in two or more separate clusters, it makes sense to produce a different texel following the centroid of each group, ultimately resulting in alternative textures for the same triangle, similarly to the view dependent textures proposed in <ref type="bibr" target="#b9">[Debevec et al. 1996]</ref>. In our case, the separability of the clusters would guarantee that transitions directions are never actually seen, making it possible to switch abruptly between alternative textures, thus avoiding any ghosting-plagued texel-value interpolation.</p><p>As an easy improvement, the average viewing direction could be a better predictor of rendering time view-direction if we weight the contribution of each non-occluded view direction according to its application-depended likelihood: for example, an human figure will mostly be seen from horizonal view directions.</p><p>We also believe that variations of this work can be adapted to improve results of similar problems, rather than just texture based detail recovery: the tool that measures the sampling uniformity can be also used to rate a given u-v mapping. Surface simplification, when used in conjunction with detail recovery, can benefit from considerations coming from the analysis of the error distributions returned by the measuring tools presented here: for example, convex regions tend to be error plagued more than line concave regions, suggesting that simplification can be done to a larger extent in the former. original model, simplified model flat shaded. Below, the redetailed bumpmapped model obtained using the Normal approach, and then the Visibility approach. Note that the ear is a complex 3D structure, but from many directions is occluded by the hairs: the visibility based approach takes advantage of this by optimizing the bump-map for the remaining views.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>A 2D example of the Image space (above) and Object space (below) distance measure along a specific view ray.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 3). Along each viewing ray r i , the rendering will show (either the background or) a point p L of M L ; thanks to the texture, that point will present the feature originally present in point p H = F(p L ) of M H . If M H was rendered instead of M L under the same viewing condition, the same ray r i would hit in general a different point p H .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Error distribution: each part of M L (bumpmapped with the visibility based methods) is colored according to its contribution to the Image Space Distance, from the lowest (red) to the highest (blue).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Top-left: the sample distribution T over M L (each junction is a point on M L represented by a texel -for clarity, we used a small 256 × 256 texture). Then, clockwise: the distribution of F(T), with F chosen as proximity based, and normal based and hybrid. Note how irregular the proximity based case is.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>The high-relief dataset: a visual comparison of the results obtained with the different mapping techniques. Top: the original M H (25K faces) and the simplified version M L (500 faces), shown flat shaded, and bump-mapped with a bumpmap created using visibility based F function. Just below, a close up of the original and simplified mesh. Then: comparative renderings of simplified models bumpmapped using proximity based, normal based, (third row) visibility based per texel, and hybrid based mappings F (last row).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Another example: a portion of the Michelangelo David; above:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>A comparison of the various error measures (as described in Sec. 4) obtained using a variety of possible mapping F (as described in Sec. 3) over the high-relief and the Michelangelo dataset.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">Point-to-point correspondence strategiesGiven a 3D point p ∈ M L , we want to find the position p = F(p), with p ∈ M H , so that we can fill texel t corresponding to p with D(p ). Which point shall we pick? In the following three subsections, we will discuss three different (categories of) strategies:</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments: to the anonymous reviewers for their suggestions, and to EU IST Project "ViHAP3D" for fundings.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Geometric computing and uniform grid technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Akman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kankanhalli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Narayanaswami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="410" to="420" />
			<date type="published" when="1989-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A fast voxel traversal algorithm for ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Amanatides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="3" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">High-quality texture reconstruction from multiple scans</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bernardini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Rushmeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="318" to="332" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Curvature simulation using normal maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Blasco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Game Programming Gems</title>
		<meeting><address><addrLine>III, Charles River Media, D. Treglia, Ed</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="433" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A general method for recovering attribute values on simplifed meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="59" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A comparison of mesh simplification algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers And Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="37" to="54" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Metro: measuring error on simplified surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="167" to="174" />
			<date type="published" when="1998-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Preserving attribute values on simplified meshes by re-sampling detail textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tarini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">preliminary results in IEEE VIS 98 Proc.)</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="519" to="539" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Appearancepreserving simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Olano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<idno>115-122. ISBN 0-89791-999-8</idno>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 98 Conf. Proc., Addison Wesley, M. Cohen</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>Annual Conf. Series, ACM SIGGRAPH</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Modeling and rendering architecture from photographs: A hybrid geometry-and image-based approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Debevec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conf. Series, ACM SIGGRAPH</title>
		<editor>H. Rushmeier</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
	<note>SIGGRAPH 96 Conf. Proc.</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Intrinsic parameterizations of surface meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Alliez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum (EG&apos;02 Proc.) 21</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multiresolution modeling: Survey &amp; future opportunities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROGRAPHICS&apos;99, State of the Art Report (STAR)</title>
		<meeting><address><addrLine>Aire-la-Ville</addrLine></address></meeting>
		<imprint>
			<publisher>CH</publisher>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>Eurographics Association</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pratical and robust bump mapping technique for today&apos;s GPU&apos;s</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Kilgard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Opengl Game development</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fitting smooth surfaces to dense polygon meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conf. Proc</title>
		<editor>H. Rushmeier</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="313" to="324" />
		</imprint>
	</monogr>
	<note>Annual Conf. Series</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Image-driven simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="204" to="241" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">All the polygons you can eat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Maughan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Game Developer Conf</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Silhouette clipping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">V</forename><surname>Sander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Gortler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 2000</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
	<note>Annual Conf. Series</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Visibility-guided simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th IEEE Visualization 2002 Conf. (VIS-02)</title>
		<editor>R. Moorhead, M. Gross, and K. I. Joy</editor>
		<meeting>of the 13th IEEE Visualization 2002 Conf. (VIS-02)<address><addrLine>Piscataway, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="267" to="274" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
