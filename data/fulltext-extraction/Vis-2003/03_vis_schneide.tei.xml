<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Compression Domain Volume Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Schneider</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Westermann</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Computer Graphics and Visualization Group</orgName>
								<orgName type="institution">Technical University Munich</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Seattle, Washington</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Compression Domain Volume Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism -Color</term>
					<term>shading</term>
					<term>shadowing and texture; I.3.8 [Computer Graphics]: Applications I.3.Volume Rendering</term>
					<term>Vector Quantization</term>
					<term>Texture Compression</term>
					<term>Graphics Hardware</term>
				</keywords>
			</textClass>
			<abstract>
				<p>A survey of graphics developers on the issue of texture mapping hardware for volume rendering would most likely find that the vast majority of them view limited texture memory as one of the most serious drawbacks of an otherwise fine technology. In this paper, we propose a compression scheme for static and time-varying volumetric data sets based on vector quantization that allows us to circumvent this limitation. We describe a hierarchical quantization scheme that is based on a multiresolution covariance analysis of the original field. This allows for the efficient encoding of large-scale data sets, yet providing a mechanism to exploit temporal coherence in non-stationary fields. We show, that decoding and rendering the compressed data stream can be done on the graphics chip using programmable hardware. In this way, data transfer between the CPU and the graphics processing unit (GPU) can be minimized thus enabling flexible and memory efficient real-time rendering options. We demonstrate the effectiveness of our approach by demonstrating interactive renditions of Gigabyte data sets at reasonable fidelity on commodity graphics hardware.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the last decade many articles have extolled the virtues of hardware accelerated texture mapping for interactive volume rendering. Often this mechanism was positioned as the latest cure for the software crisis in scientific visualization -the inability to develop volume rendering algorithms that are fast enough to be used in realtime environments, yet powerful enough to provide realistic simulation of volumetric effects. Despite all the great benefits that were introduced by the most recent texture mapping accelerators, however, one important issue has received little attention throughout the ongoing discussion in the visualization community: volumetric texture compression.</p><p>As the demand for high-resolution three-dimensional texture maps in visualization applications like medical imaging or computational fluid dynamics is continuously increasing, there is also an increasing need for effective texture compression schemes. Besides enabling the optimal exploitation of limited texture memory, texture compression has the potential to significantly reduce the load on the transmission channel between the CPU and the GPU. Therefore, however, methods need to be developed to directly decode the data stream on the graphics chip at run-time, yet still enabling interactive frame rates.</p><p>Apart from the aforementioned requirements, one additional requirement becomes important once the compression scheme has to be applied to large-scale data sets: encoding optimization. As we aim at the compression of large volumetric data and sequences, the encoding step can easily consume hours to generate an appropriately compressed data stream. Thus, to provide a tool that has the potential to be used in real-world scenarios, it is necessary to specifically address performance issues.</p><p>In this paper, the emphasis is on proposing a novel approach to volumetric texture compression that satisfies the mentioned requirements. The key to our approach is an improved implementation of vector quantization. A vector quantizer essentially maps any input vector to a single index that references a codebook. The respective codebook entry or codeword carries a vector of equal dimensionality that is used to reproduce the original one. Usually, no such codebook is known a priori. Hence, encoding the input set means finding a partitioning of the input set that calculates the codebook.</p><p>Our proposed scheme can effectively be applied to multidimensional data, and it can thus serve as a basis for region encoding of static and time-varying scalar or vector fields. Our choice of technique was mainly driven by the requirement to perform the decoding by means of the functionality available on consumer class graphics accelerators. Alternative compression techniques for volumetric data, for instance RLE encoding, IFS <ref type="bibr" target="#b4">[Fisher 1995;</ref><ref type="bibr" target="#b32">Saupe et al. 1996]</ref>, or compression schemes based on wavelet and Laplacian hierarchies <ref type="bibr" target="#b25">[Muraki 1993;</ref><ref type="bibr" target="#b39">Westermann 1994;</ref><ref type="bibr" target="#b8">Ghavamnia and Yang 1995;</ref><ref type="bibr" target="#b10">Gross et al. 1995;</ref><ref type="bibr" target="#b14">Ihm and Park 1998;</ref><ref type="bibr" target="#b0">Bajaj et al. 2001;</ref><ref type="bibr" target="#b26">Nguyen and Saupe 2001]</ref>, although in some cases they result in even better compression ratios, do not allow for simultaneous decoding and rendering of the compressed data on the GPU in general.</p><p>At the core of the quantization step the original data is split into a multiresolution representation. A covariance analysis at each resolution level followed by a relaxation step to minimize residual distortions allows us to compute sets of representative values at varying resolution. Temporal coherence between successive time steps in non-stationary fields is exploited in various ways to speed up the quantization process.</p><p>The data set is finally encoded into a RGB index texture, each color component being an index into a 2D dependent texture that holds the codebook generated at a particular resolution level. To access the compressed data stream and to decode the data we employ the Pixel Shader API, a specific set of instructions and capabilities in DirectX9-level hardware that can also be accessed from within the OpenGL API via the GL ARB fragment program extension <ref type="bibr">[OpenGL ARB n. d.]</ref>. Both the index texture and the dependent textures necessary to look up codewords from the codebook can be accessed on a per-fragment basis.</p><p>Although the decoding of compressed data on the GPU slows down rendering performance, above all it enables the rendering of volumetric data sets that would not have fit into texture memory otherwise. Even if the compressed data stream does not fit into texture memory, e.g. long sequences of large volumetric data sets are rendered, we achieve a considerable performance gain due to the minimization of bus transfer. One drawback of our rendering approach, however, is the fact that only nearest neighbor interpolation can be employed during rendering. This is a direct implication of vector quantization in general, and it can only be overcome by means of a considerably more expensive decoding scheme.</p><p>To further improve rendering performance, we effectively employ the early z-test that allows us to discard fragments before they enter the fragment program. Based on the observation that in the current implementation the loss in rendering performance is due to the complex shader program used to decode the data, we discard the execution of the shader program for those fragments that would most likely decode empty space.</p><p>The reminder of this paper is organized as follows. In Chapter 2 we review related work. The basic description of the hierarchical decomposition scheme is subject of Chapter 3. In Chapter 4 we describe GPU-based decoding and rendering of the compressed data stream. An improved implementation of vector quantization as well as performance issues and the compression of time-varying data sets is discussed in Chapter 5. We conclude the paper with a detailed discussion, and we show further results of our approach applied to real data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Previous Work</head><p>Over the last decades the effective use of textures for realistic image synthesis has been demonstrated in various computer graphics applications. In particular, graphics chip manufacturers have spent considerable effort on the design of dedicated hardware to achieve real-time 2D and 3D texture mapping. As a result, hardware assisted texture mapping has now positioned itself as one of the fundamental drawing operations to achieve interactivity in applications ranging from shading and lighting simulation to advanced volume rendering techniques.</p><p>On the other hand, with the increasing attraction of texture maps limited texture memory becomes a major concern, and one is faced the problem to extend texture volume without increasing local texture memory. Particularly in volume rendering via 2D or 3D textures <ref type="bibr" target="#b2">[Cabral et al. 1994;</ref><ref type="bibr" target="#b38">Westermann and Ertl 1998;</ref><ref type="bibr" target="#b31">Rezk-Salama et al. 2000;</ref><ref type="bibr" target="#b3">Engel et al. 2001;</ref><ref type="bibr" target="#b15">Kniss et al. 2001;</ref><ref type="bibr" target="#b16">Kniss et al. 2002]</ref>, limited texture memory has become an important issue that often prohibits the rendering of large-scale data sets at the maximum possible frame rates.</p><p>With the focus on the application to typical 2D textures as they arise in computer games, like stones, bricks and walls, chip manufacturers have already proposed hardware supported decoding of compressed texture maps. Based on compression technology provided by S3 Inc., these activities have lead to the S3 texture compression standard [OpenGL ARB n. d.], which is now part of the DirectX and OpenGL APIs. In the S3 standard, 4x4 texel values are grouped together and represented by two average color samples and 4 linear interpolation factors, each of which is addressed via 2 bit per texel. Although the S3 texture compression scheme yields decent fidelity when applied to the aforementioned textures, from the numerical point of view it generates insufficient results due to the linear fit that is performed even in non-homogeneous regions. In addition, due to the maximum compression ratio of 8:1, it is not appropriate for the application to volumetric textures or even timevarying data sets in general.</p><p>Customized compression schemes for 3D textures, on the other hand, have the potential to produce better compression ratios. For texture based volume rendering, Guthe et al. <ref type="bibr" target="#b11">[Guthe et al. 2002]</ref> employed wavelet transforms to significantly compress separate texture tiles. Although resulting in high fidelity, every tile has to be before it can be transferred and rendered on the GPU.</p><p>If an application demands for the rendering of time-varying data sets, data compression becomes an even more important requirement. Hierarchical data structures and difference encoding schemes have been proposed to detect spatial and temporal coherence in consecutive time steps, and to use this information to accelerated the rendering process <ref type="bibr" target="#b40">[Westermann 1995;</ref><ref type="bibr" target="#b34">Shen and Johnson 1994;</ref><ref type="bibr" target="#b35">Shen et al. 1999]</ref>. In general, however, none of these techniques has been shown to be able to decode the data on the graphics chip.</p><p>First approaches in which volumetric data decoding and rendering was performed on the graphics chip were proposed in <ref type="bibr" target="#b23">[Lum et al. 2001]</ref> for time-varying sequences, and in <ref type="bibr" target="#b17">[Kraus and Ertl 2002;</ref><ref type="bibr" target="#b20">Li and Kaufman 2002]</ref> for static data sets. The former approach is based on a transform coding of the original signal. DCTcoefficients are quantized and encoded into hardware assisted color tables, which can be reloaded to generate animations at interactive rates. In the latter techniques, relevant areas of the original texture are packed into a texture atlas of reduced size. Decoding is finally done by employing programmable graphics hardware to reconstruct the appropriate information for each rendered fragment.</p><p>A quite challenging alternative to the proposed compression schemes is vector quantization, which essentially enables the automatic computation of a reduced set of representative values used to approximate the original samples at reasonable fidelity.</p><p>In computer graphics many different applications have already benefit from vector quantization. Particularly in imaging applications, where true color images have to be displayed on devices exhibiting limited color resolution, the quantization of color samples has been used frequently to find an appropriate mapping <ref type="bibr" target="#b12">[Heckbert 1982;</ref><ref type="bibr" target="#b7">Gervauz and Purgathofer 1990;</ref><ref type="bibr" target="#b29">Orchard and Bouman 1991;</ref><ref type="bibr" target="#b1">Buhmann et al. 1998</ref>]. Vector quantization has also been used in volume rendering applications for compression purposes by treating continuous data blocks as multi-dimensional vectors to be encoded <ref type="bibr" target="#b27">[Ning and Hesselink 1992]</ref>, and for the quantization of grey-scale gradients to be used further on in 3D texture based volume rendering to simulate local illumination <ref type="bibr" target="#b37">[Van Gelder and Kim 1996]</ref>. The compression of light fields based on vector quantization was considered in <ref type="bibr" target="#b19">[Levoy and Hanrahan 1996;</ref><ref type="bibr" target="#b13">Heidrich et al. 1999]</ref>. In the latter approach, Heidrich et al. demonstrated the efficient use of texture color tables for the encoding and hardware assisted decoding of vector components. Tarini et al. <ref type="bibr" target="#b36">[Tarini et al. 2000]</ref> suggested to use vector quantization for the interactive simulation of local lighting effects on surfaces. Two-dimensional normal maps were quantized using a customized quantizer such that the lighting computation only had to be performed for each of the generated table entries.</p><p>In contrast to the described applications of vector quantization, in our work the focus is on a somewhat different topic. In particular; the goal of our approach is two-fold: to demonstrate that real-time decoding and rendering of quantized contiguous texel regions in large volumetric data sets and sequences can be achieved by means of standard graphics hardware and to propose an enhanced vector quantization scheme that is extremely performant, yet resulting in high fidelity and in the ability to efficiently process multi-dimensional data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Hierarchical Data Decomposition</head><p>Prior to the in-depth discussion of the proposed compression scheme, let us first outline the hierarchical setting our approach is based upon as well as the technique to render the hierarchically encoded data stream on programmable graphics hardware. Our implementation exploits the GL ARB fragment program extension to the OpenGL API on the latest ATI technology, the ATI 9700. In particular, we exploit the possibility to perform arithmetic operations <ref type="figure">Figure 1</ref>: The hierarchical decomposition and quantization of volumetric scalar data sets is illustrated. Blocks are first split into multiple frequency bands, which are quantized separately. This generates three index values per block, which are used to reference the computed codebooks.</p><p>and dependent texture fetches on a per-fragment basis.</p><p>Starting with the original scalar field, the data is initially partitioned into disjoint blocks of size 4 3 . Each block is decomposed into a multiresolution representation, which essentially splits the data into three different triadic frequency bands. Therefore, each block is down-sampled by a factor of two by averaging disjoint sets of 2 3 voxels each. The difference between the original data samples and the respective down-sampled value is stored in a 64-component vector. The same process is applied to the down-sampled version, producing one single value that represents the mean value of the entire block. The 2 3 difference values carrying the information that is lost when going from 2 3 mean values to the final one are stored in a 8-component vector. Finally, a 1-component vector stores the mean of the entire block. This procedure is illustrated in figure 1.</p><p>In performing this task, the data is decomposed into three vectors of length 64, 8, and 1, respectively, which hierarchically encode the data samples in one block. This approach has two main advantages. Firstly, the detail or difference coefficients will most likely become small, or they are already zero in homogeneous or empty regions. By applying a simple thresholding, many of the difference vectors can be mapped to the zero vector, maximizing the number of codewords to represent significant non-zero vectors. Moreover, the performance of the process is considerably increased, because the relaxation process that assigns vector elements to quantization bins becomes a simple operation for zero vectors. Secondly, by quantizing each frequency band separately and by assembling the original signal from these contributions, we enhance fidelity by using combinations of entries stored in each band.</p><p>By means of the vector quantizer, which will be described below, appropriate mappings and codebooks containing 64-and 8component codewords are computed for both high frequency bands. Let us therefore assume that the length of each codebook is 256, such that the respective index into the codebook can be stored as one 8 bit value. Let us also assume that mean values are stored in an 8 bit value. They can thus be used directly without the need to lookup the respective value in a codebook.</p><p>We thus end up with three 8 bit values per block: one value represents the mean of each block, while the other two values are indices into the respective codebooks representing the difference information. All three values are stored in one single RGB index texture, I, of size</p><formula xml:id="formula_0">(N x /4)x(N y /4)x(N z /4).</formula><p>Here, N x , N y and N z are the size of the original volume in every dimension.</p><p>The two codebooks are stored in two separate 2D textures C 1 and C 2 of size 256x64 and 256x8, respectively. They are indexed via (s,t) texture coordinates, the s coordinates being directly given by the G-and the B-component of I. To decode a particular block, its mean and the respective difference information from C 1 and C 2 have to be added. Both operations, the lookup of the difference information and the reconstruction of the final value can be done efficiently by means of per-fragment operations as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Compression Domain Rendering</head><p>Starting with a 3D scalar data set, the hierarchical quantization scheme generates a RGB index set of 1/4 the original size in ev-ery dimension. This data set is converted to a 3D texture map, and it is rendered via hardware accelerated 3D texture mapping. In our current implementation the texture is sliced either in back-to-front or front-to-back order via planes orthogonal to the viewing direction. Because each texel of the index texture is expanded to a 4 3 block during rendering, care has to be taken to perform the slicing with as many slices as necessary to render the original data.</p><p>To assemble each quantized block on a per-fragment basis, a shader program is issued that performs the following tasks:</p><p>• The respective texture sample is fetched from the index texture I.</p><p>• The difference vectors are indexed via the G-and Bcomponents, and they are fetched from the dependent textures C 1 and C 2 .</p><p>• The R-component of I (mean value) is added to the difference information.</p><p>• The final scalar value is mapped to color and opacity via a 1D dependent texture map <ref type="table">(color table)</ref>.</p><p>• Color and opacity is drawn to the framebuffer.</p><p>Although by the G-and B-component of the index texture I, for every fragment the s texture coordinates to index the respective codewords in C 1 and C 2 are uniquely determined, the relative address (t texture coordinate) of each fragment within this codeword is not yet available. Therefore, we issue an address texture, A, in the shader program. This texture is of the same size as the encoded texel region, 4 3 in the current example, and it is mapped via nearest neighbor interpolation. It stores relative addresses to access particular components in one codeword, and it is used by each fragment to determine the missing s texture coordinate.</p><p>In the R-component of A, 64 different addresses are coded to index C 1 . In the G-component, however, only 8 different addresses have to be coded to assign the codewords in C 2 . Therefore, blocks of 2 3 adjacent texels get assigned the same address, thus yielding 8 different values necessary to access C 2 . For sake of simplicity, the basic idea is illustrated in figure 2 for the encoding of 2x2 regions.  Because the address texture only holds the addresses for one single block, an enlarged texture as large as the original data set with its content repeated across the domain has to be mapped. This approach, however, is not appropriate, because it does not allow for the saving of any memory at all. Consequently, we proceed in a different way. To access the index texture, for each slice that is rendered we issue texture coordinates ranging from 0 to N x /4, N y /4 and N z /4, respectively, and we set the wrap parameter for texture coordinates to GL REPEAT. Now, the address texture is periodically repeated over the domain thus yielding the correct addresses at every fragment. As a matter of fact, the G-and B-component of T together with the R-and G-component of A uniquely determine the addresses into the dependent textures C 1 and C 2 , respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Early Shader Termination</head><p>For the simultaneous decoding and rendering of the compressed data sets as proposed, we perceive a loss in performance of about a factor of 2-3 compared to the rendering of uncompressed data. Based on the observation that in the current implementation the loss in performance is due to the complex shader program, and in particular due to the many texture indirections, we discard the execution of the shader program for fragments that are most likely to decode empty space.</p><p>Therefore, we employ the early z-test, which is available on our target architecture. The early z-test discards a fragment and thus avoids execution of the pixel shader program, if depth values are not explicitly modified in the shader program and other per-fragment tests are disabled.</p><p>To exploit the early z-test we render each slicing polygon twice. In the first pass, a simple pixel shader program is issued. In the shader, index texture I is accessed and the mean value stored in the R-component is checked. If it is zero, then the fragment is rendered with color and opacity set to zero. In this way, it does not affect the color buffer, but the depth value in the depth buffer is set to the fragments depth. If the mean value is not zero, then the fragment is discarded by means of a kill instruction. This instruction does not allow one to gain performance, but it takes care that the fragment does neither affect the color nor the depth buffer. As a matter of fact, if a fragment gets discarded in the shader program, the depth value of the fragment that was rendered last is still valid in the depth buffer.</p><p>In the second pass, the slicing polygon is rendered again, but now the complex shader as described in the previous section is called. However, because the depth test is set to GL GREATER, the early z-test only lets those fragments pass that have been discarded in the forgoing simple shader pass. All other fragments will be discarded before entering the complex shader program.</p><p>In this way, in empty regions only one texture fetch operation has to be performed to access the mean of each block. If this value is zero, then the difference information will be zero as well and the data sample does not have to be decoded. Particularly for the rendering of numerical simulation results, in which large empty regions occur quite frequently, the proposed acceleration technique results in a considerable speed-up.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Vector Quantization</head><p>Let us now briefly summarize the basic concept and the features provided by the improved vector quantizer that is used as a basis for volumetric texture compression and hardware accelerated texture decoding.</p><p>In its most general form a vector quantizer takes a n-dimensional vector as input and maps it to a single index that references a codebook. The respective codebook entry or codeword carries a vector of equal dimensionality that is used to reproduce the original one. Usually, no such codebook is known a priori. Hence encoding the input set means finding a partitioning of the input set that calculates the codebook. Because we aim at reproducing each input set as closely as possible vector quantization can be seen as a data fitting procedure that minimizes the residual distortion implied by the mapping with respect to some metric δ . The most common distortion metric used in data fitting processes is the squared-distance metric δ (x, y) → x−y 2 2 , which provides an intuitive measurement of the distortion.</p><p>Although vector quantization has been around for quite a long time, until now there was only a limited use of quantization schemes in computer graphics applications due to a number of drawbacks of existing algorithms. In our opinion the most serious drawback of vector quantization schemes is their inability to be used in time critical applications. Usually, high quality quantizers show a significant lack in performance, which prohibits their application to highresolution data. In addition, the extension of existing approaches to higher dimensions or multi-parameter data is not straight forward in general. This is due to the conceptual design of the algorithms and due to performance issues.</p><p>Linde, Buzo and Gray <ref type="bibr" target="#b21">[Linde et al. 1980</ref>] developed one of the first vector quantization algorithms suitable for practical applications -the LBG-algorithm -which improved on the scalar quantizer proposed by Max <ref type="bibr" target="#b24">[Max 1960</ref>] and by Lloyd <ref type="bibr" target="#b22">[Lloyd 1982]</ref>. For an excellent introduction to and a comprehensive survey of vector quantization let us refer to <ref type="bibr" target="#b9">[Gray and Neuhoff 1998;</ref><ref type="bibr" target="#b33">Sayood 2000]</ref>. While conceptually simple there are still some serious problems inherent to the LBG-algorithm, of which the most severe ones are execution speed and the so called empty cell problem.</p><p>In the following we will demonstrate that by integrating an enhanced splitting strategy to find optimal codebooks empty cells can be avoided automatically without any special treatment. In addition this approach makes vector quantization fast enough to establish it as attractive alternative to other compression schemes, yet providing excellent compression ratios at high fidelity. Our algorithm is easy to implement, and it is general enough to deal with high dimensional multi-parameter data. The latter property exposes our approach among previous ones, which are often restricted to applications in two or three dimensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">LBG Revisited</head><p>Since our algorithm is a modification of the LBG-algorithm, let us start with a review of this algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Start with an initial codebook</head><formula xml:id="formula_1">C = {Y (0) i } m i=1 ⊂ ℜ n .</formula><p>Let I ⊂ ℜ n be the set of input vectors. Set k = 0, D (0) = 0 and select threshold ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Find quantization regions</head><formula xml:id="formula_2">V (k) i = {X ∈ I : δ (X,Y i ) &lt; δ (X,Y j ) ∀ j = i}, where j = 1, 2,...,m.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Compute the distortion D</head><formula xml:id="formula_3">(k) = ∑ m i=1 ∑ X∈V (k) i δ (X,Y (k) i ) 4. If D (k−1) −D (k) D (k)</formula><p>&lt; ε stop, otherwise, continue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Increment k. Find a new codebook {Y</head><formula xml:id="formula_4">(k) i } m i=1 by calculating the centroids of each cell V (k−1) i . Go to (2).</formula><p>The final output of the algorithm is a codebook C = {Y</p><formula xml:id="formula_5">(k) i } m i=1</formula><p>and a partition {V</p><formula xml:id="formula_6">(k) i } 2 r i=1 of I,</formula><p>where r is the fixed bit-rate of the quantization. Each input vector is then replaced by the index of the associated quantization cell.</p><p>The initial codebook for step (1) is usually obtained by means of a so called splitting technique. First, the centroid of the entire input set is placed as a single entry into the codebook. Then, a second entry is generated by adding a random offset to the first entry, and the LBG-algorithm is executed until convergence. This procedure is repeated until the desired bit-rate is achieved While repeated nearest neighbor searches in step (2) slow down its performance significantly, the LBG-algorithm also suffers from the empty cell problem. Empty cells are the result of collapsing codebook entries during refinement steps. These entries are not detected by the algorithm, and as a consequence many codebook entries might be wasted. Although it is possible to explicitly detect and delete these entries, this alternative results in even more LBGsteps because the number of codebook entries is not going to be doubled in each iteration. Starting with as many codebook entries as there are input vectors and merging these entries until the desired codebook size is achieved solves the problem as well. This, however, requires 1 2 n 2 nearest neighbor searches for n input vectors and clearly disqualifies the approach when it comes to speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Covariance Analysis</head><p>To obtain the initial codebook an improved splitting technique needs to be integrated. A splitting based on a principal component analysis (PCA) followed by a relaxation-based optimization phase is one alternative solution to find an initial codebook. It enables us to choose an optimal splitting plane with regard to the variances of the disjunct subregions. The exploitation of such a splitting process has been described in various applications ranging from data clustering to load balancing, and it is essentially the technique used in <ref type="bibr" target="#b30">[Pauly et al. 2002;</ref><ref type="bibr" target="#b18">Lensch et al. 2001]</ref> for the hierarchical clustering of point sets and scanned BRDFs.</p><p>The splitting technique proceeds as follows. We start with a single quantization cell V 1 , which contains the entire input set I. The respective codebook entry Y 1 is the centroid of the entire set, and the distortion of this quantization cell is computed as</p><formula xml:id="formula_7">D 1 = ∑ X∈V 1 δ (X,Y 1 ).</formula><p>We then construct a double-linked "to-do" list by inserting the new "group" defined by</p><formula xml:id="formula_8">(D 1 , Y 1 , ℑ 1 = {i ∈ ℑ : X i ∈ V 1 })</formula><p>into this list. After subsequent splits this list is sorted in descending order with respect to the stored distortions D j . In each iteration the element j with the largest residual distortion D j is selected and split further on. We use this heuristic to predict the actual maximum decrease in distortion, without that we have to explicitly compute the gain. Because we no longer need to perform one split in advance, a considerable speed-up can be achieved in addition to improved quality of the codebook generated this way.</p><p>To perform one split, we proceed as follows:</p><p>1. Pick the group j with largest residual distortion D j from the to-do list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Calculate the auto-covariance matrix</head><formula xml:id="formula_9">M = ∑ i∈ℑ j (X i −Y j ) • (X i −Y j ) t</formula><p>3. Calculate the eigenvector e max that corresponds to the largest eigenvalue λ max of M 4. Split the original group into a "left" and a "right" group: This procedure essentially adds one codebook entry per split (see <ref type="figure" target="#fig_2">figure 3</ref>). Since the splitting hyperplane passes through the old centroid, the new distortions will be small compared to the old one. Once the splitting procedure terminates, the codebook along with the residual distortion can be directly obtained from the to-do list. The benefits of this approach are manifold. First, a cell with low residual distortion will never be split because it is always appended to the end of the list. In particular this includes cells that only contain one data point and thus have a residual distortion of 0. Second, if a cell is split it is divided into two sub-cells of roughly equal residual distortions. Third, applying some LBG-steps as post-refinement to relax the centroids quickly generates stable Voronoi regions (see <ref type="figure">figure 4)</ref>. Fourth, in all our examples we did never observe any empty cells during the LBG post-refinement. This is due to the fact that we always place centroids into densely populated cells. Fifth, our algorithm is extremely fast because it avoids expensive LBGsteps during the splitting process. It has a runtime of O <ref type="figure" target="#fig_1">(N • log 2 m)</ref>, where N is the number of input vectors and m = 2 r is the number of codebook entries. Sixth, the algorithm is easy to implement and can be extended straight forwardly to any dimension. Moreover, since the numerical complexity is dominated by distortion evaluations the algorithm offers a huge potential for further optimizations based on latest SIMD-technology, such as SSE or 3DNow <ref type="figure">Figure 4</ref>: A series of post-refinements by means of LBG-steps applied to the codebook from figure 3. Current centroids are marked by dark points, while bright points show the centroids from some previous iteration.</p><formula xml:id="formula_10">ℑ le f t = {i ∈ ℑ j , &lt; (Y j − X i ), e max &gt; &lt; 0 } ℑ right = {i ∈ ℑ j , &lt; (Y j − X i ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Performance Optimization</head><p>Regardless the mentioned improvements the total run-time of the algorithm is still dominated by the LBG-steps, which are employed to relax the codebook entries. On the other hand, these refinements are necessary because they significantly increase the resulting fidelity. As a consequence we further improved the performance of the enhanced LBG-algorithm as follows.</p><p>We restrict the expensive nearest-neighbor search that is performed during the LBG-refinement to a subset of the entire codebook entries. In the literature this is commonly referred to as fast searching. While there exist different approaches to determine the minimal codebook subset we favor a fast but solid heuristic. By observing that the possibility is high that during one LBG-step each data point migrates from the initial quantization cell into adjacent cells, we restrict the search to the k-neighborhood of the initial cell. Mutual distortions are calculated for each pair of centroids, and references to the k nearest neighbors are established for each entry. The k nearest neighbors are found by means of a modified Quicksort algorithm. This algorithm is essentially the one that is used to find the k smallest entries. In contrast to the full Quicksort, this sorting procedure only recurses for the partition that overlaps the k th entry and consequently runs in linear time. Now the nearest <ref type="figure">Figure 5</ref>: This sequence demonstrates the effectiveness of the hierarchical quantization scheme. First, a 24 bpp true color image (first) was encoded in 0.95 bpp (second). Next, a 3D 32 bpp confocal microscopy scan (third) was encoded in 1 bpp. neighbor search is restricted to the list of adjacent centroids and the adjacency information is updated after each LBG-step. Because for small k this procedure converges to a suboptimal distortion the search radius is continuously increased by some value whenever the convergence rate drops below 5%. This seems to be a reasonable choice, and it allows us to save up to 85% of the execution time compared to an exhaustive search. In both cases the algorithm terminates when no gain in distortion could be achieved or when a search radius k max or an user-defined minimum distortion ε is reached.</p><p>For higher dimensions our improvement relies on the concept of partial searches. Because the distortion measure is essentially a scalar product &lt; X,Y &gt; that increases with each evaluated dimension, the computation is stopped whenever the next contribution X i • Y i leads to a higher value than an initial distortion δ (X,Y init ). Obviously, the correct selection of Y init is very important because it triggers the number of computations to be performed. Since it is very probable for a data point not to change the associated quantization point, we initialize the distortion with respect to the nearest quantization point. In all our experiments this approach allows us to save about 50% of the accumulated calculations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Region Encoding</head><p>One of the drawbacks of vector quantization as described is that as soon as the bit-rate decreases below 8 bpp artifacts become apparent. In addition, the compression ratio is limited to roughly 3:1 because each RGB texel is represented by one 8 bit color index. On the other hand, we know that encoding contiguous pixel regions can significantly improve the compression ratio, yet resulting in even better quality. This phenomenon can be explained by the fact that the number of possible colors is increased due to larger codewords at the same time decreasing the spatial resolution by exploiting coherences. Using this approach the number of index bits can be reduced considerably, while the length of the generated codewords is increased. This makes the approach very appropriate for large data sets, since they profit most from a compact index set.</p><p>In correspondence to that observation the quantizer was modified such as to accept vectors of arbitrary length as input set. This allows us to interpret enlarged 3D regions as (n 3 )D vectors, which are fed into the quantizer to compute appropriate indices and corresponding codebooks. Note that scalar or RGBα samples can be handled in exactly the same way without any coding modifications. Now, the set of texels within a region is represented by the same codebook index. The compressed texture map is of length N x /n x N y /n x N z /n, where N x , N y and N z is the size of the original data set in each dimension. The codewords, however, consist of n 3 consecutive scalar or color samples.</p><p>As described in Chapter 3, the proposed quantization scheme can be easily integrated into a hierarchical setting to generate a multiresolution representation. Fed with the appropriate input vectors, the quantizer produces codebooks at different resolution levels. Code-words can then be combined to produce the best fit for a particular input vector.</p><p>Some results of the proposed quantization scheme are shown in <ref type="figure">figure 5</ref>, where a part of one slice of the Visible Human RGB data set and a 3D confocal microscopy scan of size 512 2 x32 were encoded using the hierarchical compression scheme. As one can see, by using the hierarchical region encoder we achieve high fidelity at good compression ratios of 25.3:1 and 31.2:1, respectively. These ratios include the memory overhead required to store the dependent textures. In both examples, dependent textures were of size 256x16 and 256x4. The RGB index texture used to store the mean value and indices into the dependent textures was composed of 8 bit components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Quantization of Time-Varying Sequences</head><p>To encode non-stationary data, we employ a so-called codebookretraining algorithm. For a good survey of such algorithms, that are at the core of adaptive vector quantization schemes, let us refer to <ref type="bibr" target="#b5">[Fowler 1996]</ref>. In general these algorithms partition the data stream into frames that are to be encoded one at a time, but each frame can reuse the codebooks of previous frames in different ways. Firstly, a frame can be encoded separately, producing an index texture and 2 local codebooks for every time step. Secondly, codebooks can be retrained from the previous frame. Retraining proceeds by taking the previous codebooks as initial codebooks to the LBG algorithm. Since not only the codebooks but also the index sets can be reused to obtain a first guess to the final quantization, fast and partial searches are possible throughout the entire process. <ref type="figure">Figure 6</ref>: This example demonstrates progressive encoding of timevarying sequences using I-and P-frames. On the left, time step 65 was separately encoded. On the right, the same time step was encoded using the initial codebook of time step 55, and by performing the LBG-relaxation on this codebook. Encoding time decreased from 29 minutes to 13 minutes for the entire sequence.</p><p>Obviously, choosing the second alternative for all but the first time step produces the best results in terms of performance, because it only computes the PCA-Split for the first frame. For all other frames fast searches are employed to speed up the remaining LBG-relaxations. On the other hand, after some number of frames the current codebooks can become sub-optimal, since the LBG-algorithm depends on the choice of the initial codebook. It <ref type="figure">Figure 7</ref>: The 256 3 skull data set (left) is quantized using different quantization modes. Second and third, 2 3 and 4 3 region encoding results in compression ratios of 7.98:1 and 60.24:1, respectively. Fourth, hierarchical quantization and encoding results in a compression ratio of 20.84:1. Rendering performance (512 2 viewport) is 14 fps, 10 fps, 11 fps and 11 fps, respectively. has thus become common practise to select special frames that are encoded separately, similar to key-frames, while the quantization for all other frames is obtained by retraining. This scheme shows remarkably good results. For instance, in figure 6 we show the same time step out of a shock wave simulation. In the first example the time step was encoded separately, while the second image was obtained using the 10th retrained codebook from the last key-frame.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results and Comparison</head><p>In the following we will discuss the proposed quantization and rendering scheme in more detail, and we will give performance and quality measures for a variety of different data sets. All our experiments were compiled and run under WindowsXP on a P4 2.8 GHz processor equipped with 512 MB main memory and an ATI 9700. <ref type="figure">Figure 7</ref> demonstrates the application of the hierarchical quantization scheme to the skull data set. All our examples are rendered using nearest neighbor interpolation, because linear interpolation within codebooks is not possible. Trilinear interpolation could be achieved by decoding 8 adjacent neighbors around each fragment. On the other hand, this approach would considerably slow down performance and has not been considered here.</p><p>The results of different quantization modes are shown and compared to each other. From left to right, we show the original data set, region encoding using 2 3 and 4 3 texel blocks, and hierarchical encoding of 4 3 blocks. The respective compression ratios are 7.98:1, 60.24:1 and 20.84:1. The corresponding SNRs are 14.86dB, 9.96dB and 11.70dB.</p><p>Obviously, 4 3 region encoding yields the best results in terms of compression ratio, but it also produces significant quantization artifacts. Hierarchical encoding, on the other hand, achieves significantly better texture fidelity at reasonable compression rates. Rendering performance drops to roughly 1/3 and 1/2 of the performance of standard 3D texture based rendering. Due to our improved rendering scheme, which employs the early z-test to skip empty regions, performance strongly depends on the consistency of the data sets. If noisy structures are removed from the data in advance, a considerable speed up can be achieved.</p><p>Hierarchical quantization took 50.6 seconds for the skull data set. Compared to other quantization tools, we achieve a significant speed up due the proposed performance optimizations. For instance, the Open Source vector quantization toolbox QccPack <ref type="bibr" target="#b6">[Fowler 2000</ref>] is of a factor of 40 slower than the proposed scheme; a difference that is of important relevance if a scheme is to be used for the compression of time-varying data sets.</p><p>In the last figure 8 we demonstrate the effectiveness of the hierarchical quantization scheme and the GPU-based rendering approach for the display of time-varying data sets. Two different sequences are shown: a shock wave simulation consisting of 89 time steps, each of size 256 3 , and a vortex flow simulation consisting of 100 time steps of size 128 3 . Both sequences were compressed using the proposed progressive quantizing scheme. In this way, memory requirement dropped from 1.4 GB to 70 MB for the shock wave simulation, and from 200 MB to 11.1 MB for the vortex simulation. Due to progressive encoding, quantization of the vortex data set took roughly 5 minutes.</p><p>Rendering the sequences on our target architecture is performed with 24 fps and 16 fps, respectively. Note that in the first example, a considerable speed-up is achieved by taking advantage of the advanced rendering method that allows us to skip empty space. In this case, we are yet slightly faster than standard 3D texture based rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and future work</head><p>In this work, we have outlined a basis for volumetric texture compression and hardware accelerated texture decoding and rendering. Therefore, we have developed a hierarchical vector quantization scheme that is able to efficiently encode static and timevarying multi-dimensional data. With regard to performance, the proposed scheme significantly improves previous vector quantization schemes, and it achieves compression rates and fidelity similar to wavelet based compression. For the quantization of sequences, we have presented an acceleration technique that effectively takes advantage of temporal coherence between consecutive time steps. In this way, performance gains up to a factor of 3 could be demonstrated. Furthermore, we have described a method to directly render hierarchically encoded data on programmable graphics hardware. We have employed DirectX9-level hardware to decode the data set and to achieve interactive frame rates even for large data sets. By effective use of the early z-test, we have considerably increased rendering performance. In this way, for sparse data sets we achieve performance rates similar or even better than those that can be achieved by rendering the uncompressed data sets. Although rendering is restricted to nearest neighbor interpolation, the proposed method allows for the interactive rendering of large data sets that would not have fit into texture memory otherwise.</p><p>In the future, we will investigate how to use our scheme to compress and render vector valued data. In particular, we will try to effectively compress large vector fields with regard to vector field topology. In addition, new rendering modes can be developed based on this technique, for instance palette based animation or template based flow representation. <ref type="figure">Figure 8</ref>: Time steps from two different sequences are shown. First, time step 85 of a 256 3 x89 shock wave simulation (1.4 GB) is shown. Second, from the hierarchically encoded data stream (70 MB), the same time step is directly rendered. Third, the first time step of a 128 3 x 100 (200 MB) vortex simulation is shown. Fourth, the sequence was encoded in 11.1 MB, and the compressed time step was rendered.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Illustration of on-chip decoding for a 2x2 texel region. Texture values from two different texture sources are used to fetch a difference sample from the dependent 2D texture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>A series of PCA-Splits to obtain a first codebook.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>e max &gt; ≥ 0 } 5. Calculate new centroids Y le f t and Y right along with new residual distortions D le f t and D right 6. Insert the two new groups into the to-do list.7. If number of groups equals 2 r , stop, else go to 1.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Special thanks to K.-L. Ma and D. Silver for providing the Vortex sequence.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">3D RGB image compression for interactive applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Ihm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics (TOG)</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="10" to="38" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dithered color quantization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Buhmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fellner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Held</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ketterer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Puzicha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROGRAPHICS &apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="219" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM Symposium on Volume Visualization</title>
		<meeting>ACM Symposium on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">High-quality pre-integrated volume rendering using hardware-accelerated pixel shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics/Siggraph Workshop on Graphics Hardware</title>
		<meeting>Eurographics/Siggraph Workshop on Graphics Hardware</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Fractal Image Compression: Theory and Application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Springer Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Adaptive Vector Quantization for the Coding of Nonstationary Sources</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fowler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
		<respStmt>
			<orgName>The Ohio State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Qccpack: An open-source software library for quantization, compression, and coding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Fowler</surname></persName>
		</author>
		<ptr target="http://qccpack.sourceforge.net" />
	</analytic>
	<monogr>
		<title level="m">Applicationd of Digital Image Processing XXIII (Proc. SPIE 4115)</title>
		<editor>A. G. Tescher</editor>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="294" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A simple method for color quantization: octree quantization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gervauz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Purgathofer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Academic Press</publisher>
			<biblScope unit="page" from="287" to="293" />
		</imprint>
	</monogr>
	<note>Graphics Gems</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Direct rendering of laplacian pyramid compressed volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ghavamnia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="192" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Neuhoff</surname></persName>
		</author>
		<title level="m">Quantization. IEEE Transactions on Information Theory</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">44</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A new method to approximate the volume rendering equation using wavelets and piecewise polynomials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lippert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dreger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Interactive rendering of large volume data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gonser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="104" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Color image quantization for frame buffer displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 82 Proceedings</title>
		<imprint>
			<date type="published" when="1982" />
			<biblScope unit="page" from="297" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Heidrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lensch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
		<title level="m">Light field techniques for reflections and refractions. Rendering Techniques &apos;99 (Proceedings of Eurographics Rendering Workshop</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="59" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Wavelet-based 3D compression scheme for very large volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Ihm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="107" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interactive volume rendering using multi-dimensional transfer functions and direct manipulation widgets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="255" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive translucent volume rendering and procedural modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Premoze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ebert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Adaptive texture maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH/EG Graphics Hardware Workshop &apos;02</title>
		<meeting>SIGGRAPH/EG Graphics Hardware Workshop &apos;02</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="7" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Image-based reconstruction of spatially varying materials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lensch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kautz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Goesele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Heidrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Eurographics Workshop on Rendering</title>
		<meeting>the 12th Eurographics Workshop on Rendering</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="104" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<title level="m">Light field rendering. Computer Graphics (SIGGRAPH 96 Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Accelerating volume rendering with bounded textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/SIGGRAPH Symposium on Volume Visualization and Graphics</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An algorithm for vector quantizer design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Linde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Buzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications COM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="84" to="95" />
			<date type="published" when="1980-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Least squares quantization in PCM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="129" to="137" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Texture hardware assisted rendering of time-varying volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clyne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Quantization for minimum distortion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Transactions on Information Theory IT</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="7" to="12" />
			<date type="published" when="1960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Volume data and wavelet transforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="50" to="56" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Rapid high quality compression of volume data for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Saupe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Vector quantization for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Workshop on Volume Visualization &apos;92</title>
		<meeting>Workshop on Volume Visualization &apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="69" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The OpenGL Architecture Revision Board</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Opengl Arb</surname></persName>
		</author>
		<ptr target="http://www.opengl.org/developers/about/arb.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Color quantization of images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Orchard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bouman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Signal Processing</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="2677" to="2690" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Efficient simplification of pointsampled surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pauly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="171" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Interactive volume rendering on standard PC graphics hardware using multi-textures and multi-stage rasterization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rezk-Salama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Greiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics/Siggraph Workshop on Graphics Hardware</title>
		<meeting>Eurographics/Siggraph Workshop on Graphics Hardware</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="109" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Fractal image compression -an introductory overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Saupe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hamzaoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hartenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Siggraph &apos;96 Course Note</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Introduction to Data Compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sayood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Morgan Kaufmann Publishers</publisher>
			<biblScope unit="volume">260</biblScope>
			<pubPlace>San Mateo, CA 94403, USA</pubPlace>
		</imprint>
	</monogr>
	<note>second ed. 2929 Campus Drive, Suite</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Differential volume rendering; a fast volume rendering technique for flow animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="180" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A fast volume rendering algorithm for time-varying fields using time-space partitioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="371" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Real time, accurate, multi-featured rendering of bump mapped surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tarini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROGRAPHICS &apos;00</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="112" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Direct volume rendering with shading via three-dimensional textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Symposium on Volume Visualization &apos;96</title>
		<meeting>Symposium on Volume Visualization &apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="23" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Efficiently using graphics hardware in volume rendering applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 98 Proceedings</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="291" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A multiresolution framework for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Volume Visualization, ACM SIGGRAPH</title>
		<editor>A. Kaufman and W. Krüger</editor>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="51" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Compression domain volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
