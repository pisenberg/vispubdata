<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Deformation and Visualization of Level Set Surfaces Using Graphics Hardware</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><forename type="middle">E</forename><surname>Lefohn</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><forename type="middle">M</forename><surname>Kniss</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ross</forename><forename type="middle">T</forename><surname>Whitaker</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Scientific Computing and Imaging Institute</orgName>
								<orgName type="institution">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Seattle, Washington</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive Deformation and Visualization of Level Set Surfaces Using Graphics Hardware</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]-Computational Geometry and Object Modeling</term>
					<term>Methodology and Techniques Deformable Models</term>
					<term>Image Segmentation</term>
					<term>Volume Visualization</term>
					<term>GPU</term>
					<term>Level Sets</term>
					<term>Streaming Computation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>a) (b) (c) Figure 1: (a) Interactive level set segmentation of a brain tumor from a 256 × 256 × 198 MRI with volume rendering to give context to the segmented surface. (b) A clipping plane shows the user the source data, the volume rendering, and the segmentation simultaneously, while probing data values on the plane. (c) The cerebral cortex segmented from the same data. The yellow band indicates the intersection of the level-set model with the clipping plane.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Level-set methods <ref type="bibr" target="#b20">[Osher and Sethian 1988</ref>] rely on partial differential equations (PDEs) to model deforming isosurfaces. These methods have applications in a wide range of fields such as visualization, scientific computing, computer graphics, and computer vision <ref type="bibr" target="#b7">[Fedkiw and Osher 2002;</ref><ref type="bibr" target="#b27">Sethian 1999]</ref>. Applications in visualization include volume segmentation <ref type="bibr" target="#b18">[Malladi et al. 1995;</ref><ref type="bibr" target="#b31">Whitaker 1994</ref>], surface processing <ref type="bibr" target="#b30">[Tasdizen et al. 2002]</ref>, and surface reconstruction <ref type="bibr" target="#b32">[Whitaker 1998</ref>].</p><p>The use of level sets in visualization can be problematic. Level sets are relatively slow to compute and they typically introduce several free parameters that control the surface deformation and the quality of the results. The latter problem is compounded by the first because, in many scenarios, a user must wait minutes or hours to observe the results of a parameter change. Although efforts have been made to take advantage of the sparse nature of the computation, the most highly optimized solvers are still far from interactive. This paper proposes a solution to the above problems by mapping the level-set PDE solver to a commodity graphics processor.</p><p>While the proposed technology has a wide range of uses within visualization and elsewhere, this paper focuses on a particular application: the analysis and visualization of vol-ume data. By accelerating the PDE solver to interactive rates and coupling it to a real-time volume renderer, it is possible to visualize and steer the computation of a levelset surface as it moves toward interesting regions within a volume. The volume renderer, with its global visualization capabilities, provides context for the evolving level set. Also, the results of a level-set segmentation can specify a regionof-interest for the volume renderer <ref type="bibr" target="#b34">[Yoo et al. 1992]</ref>.</p><p>The main contributions of this paper are:</p><p>• An integrated system that demonstrates level-set computations can be intuitively controlled by coupling a real-time volume renderer with an interactive solver. • A GPU-based 3D level-set solver which is approximately 15 times faster than previous optimized solutions. • A dynamic, packed texture format that enables the efficient processing of time-dependent, sparse GPU computations. • Real-time volume rendering directly from this packed texture format. • A novel message passing scheme between the GPU and CPU that uses automatic mipmap generation to create compact, encoded messages.</p><p>The following section discusses previous work and gives some technical background for level sets, GPUs, and hardware accelerated volume rendering. Section 3 discusses the algorithmic and graphics hardware details of our level-set solver and volume renderer. Section 4 describes our segmentation application. It gives the specific form of the levelset equations and desrcribes the results of a performance analysis. In Section 5, we give conclusions, describe future research directions, and make suggestions for future GPU improvements.</p><p>2 Background and Related Work</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Level Sets</head><p>This paper describes a new solver for an implicit representation of deformable surface models called the method of level sets <ref type="bibr" target="#b20">[Osher and Sethian 1988]</ref>. The use of level sets has been widely documented in the visualization literature, and several works give comprehensive reviews of the method and the associated numerical techniques <ref type="bibr" target="#b7">[Fedkiw and Osher 2002;</ref><ref type="bibr" target="#b27">Sethian 1999</ref>]. Here we merely review the notation and describe the particular formulation that is relevant to this paper.</p><p>In an implicit model the surface consists of all points S = {x|φ(x) = 0}, where φ : 3 → . Level-set methods relate the motion of that surface to a PDE on the volume, i.e.</p><formula xml:id="formula_0">∂φ/∂t = −∇φ •v,<label>(1)</label></formula><p>wherev, which can vary in space and time, describes the motion of the surface. Within this framework one can implement a wide range of deformations by defining an appropriatev. This velocity (or speed) term is often a combination of several other terms, including data-dependent terms, geometric terms (e.g. curvature), and others. In many applications, these velocities introduce free parameters, and the proper tuning of those parameters is critical to making the level-set model behave in a desirable manner. Equation 1 is the general form of the level-set equation, which can be tuned for wide variety of problems and which motivates the architecture of our solver. We describe the specific form used for volume segmentation in Sect. 4.1. Solving level-set PDEs on a volume requires proper numerical schemes <ref type="bibr" target="#b20">[Osher and Sethian 1988]</ref> and entails a significant computational burden. Stability requires that the surface can progress at most a distance of one voxel at each iteration, and thus a large number of iterations are required to compute significant deformations. The purpose of this paper is to offer a solution that is relevant to a wide variety of level-set applications; that is, the ability to solve such equations efficiently on commodity graphics hardware.</p><p>There is a special case of Eq. 1 in which the surface motion is strictly inward or outward. In such cases the PDE can be solved somewhat efficiently using the fast marching method <ref type="bibr" target="#b27">[Sethian 1999</ref>] and variations thereof <ref type="bibr" target="#b5">[Droske et al. 2001]</ref>. However, this case covers only a very small subset of interesting speed functions. In general we are concerned with problems that require a curvature term and simultaneously require the model to expand and contract.</p><p>Efficient algorithms for solving the more general equation rely on the observation that at any one time step the only parts of the solution that are important are those adjacent to the moving surface (near points where φ = 0). In light of this observation several authors have proposed numerical schemes that compute solutions for only those voxels that lie in a small number of layers adjacent to the surface. Adalsteinson and  have proposed the narrow band method, which updates the embedding, φ, on a band of 10-20 pixels around the model, and reinitializes that band whenever the model approaches the edge. <ref type="bibr" target="#b32">Whitaker [1998]</ref> proposed the sparse-field method, which introduces a scheme in which updates are calculated only on the wavefront, and several layers around that wavefront are updated via a distance transform at each iteration. A similar strategy is described in <ref type="bibr" target="#b22">Peng et al. [1999]</ref>. Even with this very narrow band of computation, update rates using conventional processors on typical resolutions (e.g. 256 3 voxels) are not interactive. This is the motivation behind our GPU-based solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Scientific Computation on Graphics Processors</head><p>Graphics processing units have been developed primarily for the computer gaming industry, but over the last several years researchers have come to recognize them as a low cost, high performance computing platform. Two important trends in GPU development, increased programmability and higher precision arithmetic processing, have helped to foster new non-gaming applications.</p><p>For many data-parallel computations, graphics processors out-perform central processing units (CPUs) by more than an order of magnitude because of their streaming architecture <ref type="bibr" target="#b21">[Owens 2002</ref>] and dedicated high-speed memory. In the streaming model of computation, arrays of input data are processed identically by the same computation kernel to produce output data streams. In contrast to vector architectures, the computation kernel in a streaming architecture may consist of many (possibly thousands) of instructions and use temporary registers to hold intermediate values. The GPU takes advantage of the data-level parallelism inherent in the streaming model by having many identical processing units execute the computation in parallel.</p><p>Currently GPUs must be programmed via graphics APIs such as OpenGL or DirectX. Therefore all computations must be cast in terms of computer graphics primitives such as vertices, textures, texture coordinates, etc. <ref type="figure" target="#fig_0">Figure 2</ref> depicts the computation pipeline of a typical GPU. A render pass is a set of data passing completely through this pipeline. It can also be thought of as the complete processing of a stream by a given kernel.</p><p>Grid-based computations are solved by first transferring the initial data into texture memory. The GPU performs the computation by rendering graphics primitives that address this texture. In the simplest case, a computation is performed on all elements of a 2D texture by drawing a quadrilateral that has the same number of grid points (pixels) as the texture. Memory addresses that identify each fragment's data value as well as the location of its neighbors are given as texture coordinates. A fragment program (the kernel) then uses these addresses to read data from texture memory, perform the computation, and write the result back to texture memory. A 3D grid is processed as a sequence of 2D slices. This computation model has been used by a number of researchers to map a wide variety of computationally demanding problems to GPUs. Examples include matrix multiplication, finite element methods, multigrid solvers, and others <ref type="bibr" target="#b9">[Goodnight et al. 2003;</ref><ref type="bibr" target="#b15">Larsen and McAllister 2001;</ref><ref type="bibr" target="#b29">Strzodka and Rumpf 2001]</ref>. All of these examples demonstrate a homogeneous sequence of operations over a densely populated grid structure. <ref type="bibr" target="#b29">Strzodka et al. [2001]</ref> were the first to show that the level-set equations could be solved using a graphics processor. Their solver implements the two-dimensional level-set method using a time-invariant speed function for flood-filllike image segmentation without the associated curvature. Lefohn and Whitaker demonstrate a full three dimensional level-set solver, with curvature, running on a graphics processor <ref type="bibr">[2002]</ref>. Neither of these approaches, however, take advantage of the sparse nature of level-set PDEs and therefore they perform only marginally better (e.g. twice as fast) than sparse or narrow band CPU implementations.</p><p>This paper presents a GPU computational model that supports sparse and dynamic grid problems. These problems are difficult to solve efficiently with GPUs for two reasons. The first is that in order to take advantage of the GPU's parallelism, the streams being processed must be large, contiguous blocks of data, and thus grid points near the level-set surface model must be packed into a small number of textures. The second difficulty is that the level set moves with each time step, and thus the packed representation must readily adapt to the changing position of the model. This requirement is in contrast to the recent sparse matrix solvers <ref type="bibr" target="#b2">[Bolz et al. 2003;</ref><ref type="bibr" target="#b14">Krüger and Westermann 2003</ref>] and previous work on rendering with compressed data <ref type="bibr" target="#b1">[Beers et al. 1996;</ref><ref type="bibr" target="#b13">Kraus and Ertl 2002]</ref>. Recent work by <ref type="bibr" target="#b28">Sherbondy et al. [2003]</ref> describes a dynamic, sparse GPU computation model and is discussed in Section 4. Section 3 gives a detailed description of our solution to the sparse, dynamic computation problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Hardware-Accelerated Volume Rendering</head><p>Volume rendering is a flexible and efficient technique for creating images from 3D data <ref type="bibr" target="#b4">[Drebin et al. 1988;</ref><ref type="bibr" target="#b17">Levoy 1988;</ref><ref type="bibr" target="#b26">Sabella 1988]</ref>. With the advent of dedicated hardware for rasterization and texturing, interactive volume rendering has become one of the most widely used techniques for visualizing moderately sized 3D rectilinear data <ref type="bibr" target="#b3">[Cabral et al. 1994;</ref><ref type="bibr" target="#b33">Wilson et al. 1994]</ref>. In recent years, graphics hardware has become more programmable, permitting rendering features with an image quality that rival sophisticated software techniques <ref type="bibr" target="#b6">[Engel et al. 2001;</ref><ref type="bibr" target="#b11">Kniss et al. 2002]</ref>. In this paper, we describe a novel volume rendering system that leverages programmable graphics hardware to simultaneously render   <ref type="figure">Figure 3</ref>: The spatial decomposition scheme for packing active regions of the volume into texture memory. The unpacked tile space is shown in (a) and the packed tile space is shown in (b). CPU-based data structures exist for both of these spaces. The only data stored on the GPU is that represented by (b). Three dimensional neighborhoods are efficiently reconstructed on the packed format by processing boundary pixels in nine separate special cases. These nine substreams are shown in (c).</p><p>the packed level-set solution and source data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Implementation</head><p>This section gives a technical description of our implementation. We begin with a high-level description of the algorithms used for both the sparse-grid, streaming, level-set solver and the real-time volume renderer. We then cover some of the implementation details that are specific to the architecture of current graphics processors. Note that this section focuses on our new solution to the sparse/narrowband computation problem. We therefore refer the reader to <ref type="bibr" target="#b15">Lefohn et al. [2002]</ref> for a detailed description of the levelset equations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithmic Details</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">GPU Level-Set Solver</head><p>The efficient solution of the level-set PDEs relies on updating only those voxels that are on or near the isosurface. The narrow band <ref type="bibr" target="#b27">[Sethian 1999</ref>] and sparse field <ref type="bibr" target="#b32">[Whitaker 1998</ref>] methods achieve this by operating on sequences of heterogeneous operations. For instance, the sparse-field method keeps a linked list of active voxels on which the computation is performed. Like the narrow band and sparse field CPU-based solvers, our sparse GPU level-set solver computes only those voxels near the isosurface. To run efficiently on GPUs, however, our solution must also have the following characteristics: texture-based data structures that can be efficiently updated, no scatter write operations, minimal memory requirements, and be highly data-parallel. We achieve these goals by decomposing the volume into a set of small 2D tiles (e.g. 16 × 16 pixels each). Only those tiles with non-zero derivatives are stored on the GPU (see <ref type="figure">Fig. 3</ref>). These active tiles are packed, in an arbitrary order, into a large 2D texture. The 3D level-set PDE is computed directly on this packed format. The CPU is used only to help manage the packing of the active data. <ref type="figure">Figure 4</ref> shows a flow diagram of our level-set solver.</p><p>Two data structures, a packed map and unpacked map, are kept on the CPU to track each tile's packed and unpacked position. The packed map stores the volumetric location of each tile in the sparse, GPU texture. The unpacked map  <ref type="figure">Figure 4</ref>: Flow diagram of the GPU-based level-set solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GPU CPU</head><p>stores a tile object that contains the vertices and texture coordinates for the actual texture data. There are two special tiles set aside for white and black regions. Tiles that are not active (i.e. homogeneous in value either inside or outside of the level set) are mapped to the white or black tile in texture memory. Also note that the vertices are replicated for each tile because each tile needs its own set of texture coordinates in order to locate its neighboring tiles. A diagram of these mappings are shown in <ref type="figure">Fig. 3</ref>. The overview of the GPU portion of the computation is given below. The six steps shown are those required for a single iteration of the level-set PDE. See <ref type="bibr" target="#b15">Lefohn et al. [2002]</ref> for an explanation of the twenty-one first and second derivatives and the discretization of the level-set equations.</p><p>1. Compute 21, 1st and 2nd partial derivatives. 9 substream passes-each to the same 4 buffers. 2. Compute N level-set speed terms. At least N passes. 3. Update level-set PDE. 1 pass. 4. Create eight-bytes of neighborhood info. 9 substream passes. 5. Down sample neighborhood information. 6. Create bit vector message. 1 pass. 7. Send bit vector to CPU.</p><p>The remaining portion of this section describes the details of the algorithm above.</p><p>Step 1 is the only point in the computation when neighboring data values are read. The location of all necessary neighbor values is reconstructed onthe-fly by using texture coordinates to locate adjacent tiles in the 3D unpacked space. The position of data elements in relation to tile boundaries divides these gather operations into nine different cases: interior, corners, and edges ( <ref type="figure">Fig. 3(c)</ref>). Rather than use a single fragment program to compute all nine cases, we instead create a specialized fragment program for each boundary case. Each specialized program is associated with geometry that rasterizes only the pixels needed for that case. We call this method of statically resolving conditionals using specialized fragment programs and geometry, substreams. The concept is a static implementation of the data-routing idea described <ref type="bibr" target="#b10">Kapasi et al. [2000]</ref>.</p><p>Our use of substreams is motivated by two characteristics of graphics hardware. The first is that GPUs do not support conditional execution in the fragment stage (all paths are executed and a single result is conditionally assigned). The second motivation is that the majority of the pixels are in the interior case, which has highly local neighbor lookups. In contrast, the neighbors for the eight boundary cases are almost never local, making texture caches almost useless. If we had instead combined all cases into one fragment program with an indirection texture to locate the address of each neighbor, neighbor lookups would be significantly slower for the common (interior) case.</p><p>Step 2 of the algorithm computes the speed terms described in Sect. 4. We add an additional term, however, to keep the volume in which the level-set is embedded, φ, resembling a clamped distance transform (CDT). This is necessary because active tiles are identified by non-zero gradients. The CDT ensures that voxels near the isosurface have finite derivatives while those farther away have gradient magnitudes of zero. Our new speed term is added to the velocity termv(t) in Eq. 1. This rescaling term, Gr is of the form,</p><formula xml:id="formula_1">Gr = φg φ − φ|∇φ|,<label>(2)</label></formula><p>where φ is the value of the embedding at a voxel and |∇φ| is the gradient in the direction of the isosurface. The target gradient, g φ , is set based on the numerical precision of the level-set data. This speed term is strictly a numerical construct; it does not affect the movement of the zero level set, i.e. the surface model. More detailed discussions of embedding-rescaling computations such as Eq. 2 can be found in the literature <ref type="bibr" target="#b16">[Lefohn et al. 2003;</ref><ref type="bibr" target="#b8">Fedkiw et al. 1999]</ref>. After the solver updates the level-set data in step 3, it creates a compressed, bit-vector message. This message enables the CPU (in step 7) to determine which tiles are active in the next pass. This compressed message provides the CPU with aggregated information about each tile at each iteration, so that it can send vertices and texture coordinates for the new active set of tiles that the GPU will need in the next iteration. All of this communication between the CPU and GPU must be at the level of tiles to avoid a communication bottleneck. The aggregated tile description is generated on the GPU from a logical combination of the status of each pixel within each tile. This aggregation is performed efficiently by using the built-in mipmap generation functionality of the GPU.</p><p>The GPU creates the bit vector message in three stagessteps 4, 5, and 6. The first stage (step 4) creates information buffers that determine the active status of each voxel and its neighbors. The information buffers created in step 4 consist of eight bytes per active voxel. Each byte is set to either its maximum value (true) or zero (false). The first byte is set to true if any of the six, one-sided cardinal derivatives are non-zero. This determines if the voxel needs to be active on the next iteration. Each of the next six tests represent the active status of adjacent tiles in the unpacked 3D neighborhood. Each test is true only if a tile boundary is crossed in the corresponding direction and a non-zero derivative exists across that boundary. Note that the substream technique is used to process only those voxels that lie on tile boundaries. The eighth value is simply the level-set embedding value of the voxel.</p><p>In step 5, the solver uses the automatic mipmapping feature on the GPU to down sample these eight bytes of information until each tile is reduced to a single pixel. Any non-zero value in the original information buffers will result in a non-zero down sampled value for the entire tile.</p><p>Finally in step 6, the GPU creates the bit vector image/message by combining the eight bytes per pixel of down sampled data into a single eight-bit code for each pixel. The bit code is created with a fragment program that emulates a bitwise OR operation by conditionally adding power-oftwo values. For each of the eight bytes that are non-zero, a unique power-of-two value is added to the final, single-byte result.</p><p>The CPU then reads back and decodes this small (&lt; 64 kB) bit-vector image in step 7. The bit code denotes whether a tile or any of the six adjacent tiles need to be active for the next iteration. The code also encapsulates whether a newly inactive tile is inside or outside the level-set surface. The CPU uses this information to activate new tiles (white or black as appropriate), frees tiles that are no longer active, and updates the packed and unpacked maps described above.  <ref type="figure">Figure 5</ref>: For volume rendering the packed level-set model: (a) When the preferred slicing direction is orthogonal to the packed texture, the tiles (shown in alternating colors) are rendered into slices as quadrilaterals. (b) For slicing directions parallel to the packed texture, the tiles are drawn onto slices as either vertical or horizontal lines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Volume Rendering of Packed Data</head><p>Our volume renderer performs a full 3D (transfer-function based) volume rendering of the original data simultaneously with the evolving level set. For rendering the original volume, the input data and its gradient vectors are kept on the GPU as 3D textures. The volume data is rendered on the GPU with multidimensional transfer functions as described in <ref type="bibr" target="#b11">Kniss et al. [2002]</ref>.</p><p>For rendering the evolving level-set model, we use a modification of the conventional 2D sliced approach to texturebased volume rendering <ref type="bibr" target="#b3">[Cabral et al. 1994]</ref>. We modify the conventional approach to render the level-set solution directly from the packed tiles, which are stored in a single 2D texture. The level-set data and tile configuration are dynamic, and therefore we do not precompute and store the three separate versions of the data, sliced along cardinal views, as is typically done with 2D texture approaches. Instead we reconstruct these views each time the volume is rendered.</p><p>The 2D slice-based rendering requires interpolation between two adjacent slices in the back-to-front ordering along the appropriate cardinal direction. We reconstruct each slice in unpacked space by texture mapping either quadrilateral or line primitives with data from the packed level-set texture. When the preferred slice axis, based on the viewing angle, is orthogonal to the unpacked slices, we reconstruct using textured quadrilateral for each tile. If the preferred slice direction is parallel to the unpacked slicing, we instead render a row or column from each tile using textured line primitives. <ref type="figure">Figure 5</ref> illustrates the two cases for 2D slice-based rendering of the level-set model.</p><p>For efficiency the renderer reuses data wherever possible. For instance, lighting for the level-set surface uses gradient vectors computed during the level-set update stage. The rendering of the source data relies on precomputed gradient data-the gradient magnitude is used by the transfer function and the gradient direction is used in the lighting model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Graphics Hardware Implementation Details</head><p>This subsection describes implementation details that are specific to the current generation of graphics hardware. Suggestions for future graphics hardware features are given in Sec. 5.</p><p>The level-set solver and volume renderer are implemented in programmable graphics hardware using vertex and fragment programs on the ATI Radeon 9800 GPU. The programs are written in the OpenGL ARB vertex program and ARB fragment program assembly languages. The bulk of the computations are performed in fragment programs. Vertex programs are used, however, to efficiently compute tex-ture coordinates for neighbor lookups-thereby minimizing both AGP bandwidth and valuable fragment instructions.</p><p>Critical to the performance of the system are two capabilities pertaining to render pass destination buffers. The first capability, relatively recent on GPUs, is the ability to output multiple, high-precision 4-tuple results from a fragment program. Multiple outputs enable us to perform the expensive 3D neighborhood reconstruction only once and use the gathered data to compute all derivatives in the same pass. The second feature crucial to the performance is the ability to quickly change render pass destination buffers. As <ref type="bibr" target="#b2">Bolz et al. [2003]</ref> discuss, changing pbuffers is very expensive due to the unnecessary context switch. We avoid this overhead by allocating a single buffer with many render surfaces <ref type="bibr">(front, back, aux0, etc.)</ref> and switching between them. When the complexity of the computation requires more intermediate buffers, we use sub-regions of larger buffers to augment this multisurface approach.</p><p>There is a subtle speed-versus-memory tradeoff that must be carefully considered. The packed level-set texture can be as large as 2048 2 (the largest 2D texture currently allowed on GPUs). In order to minimize the memory costs of the intermediate buffers <ref type="bibr">(derivatives, speed values, etc.)</ref>, the level-set data is updated in sub-regions. We maximize the size of these sub-regions to keep computational efficiency as high as possible. We currently use 512 2 sub-regions when the level-set texture is 2048 2 and use a single region when it is smaller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Application and Results</head><p>This section describes an application for interactive volume segmentation and visualization, which uses the level-set solver described previously. The system combines interactive level-set models with real-time volume rendering on the GPU. We show pictures from the system and present timing results relative to our current benchmark for level-set deformations, which is a highly optimized CPU solution [The Insight Toolkit 2003].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Volume Visualization and Analysis</head><p>For segmenting volume data with level sets, the velocity usually consists of a combination of two terms <ref type="bibr" target="#b18">[Malladi et al. 1995;</ref><ref type="bibr" target="#b31">Whitaker 1994</ref>]</p><formula xml:id="formula_2">∂φ ∂t = |∇φ| » αD(x) + (1 − α)∇ • ∇φ |∇φ| - ,<label>(3)</label></formula><p>where D is a data term that forces the model to expand or contract toward desirable features in the input data, the term ∇ • (∇φ/|∇φ|) is the mean curvature H of the surface, which forces the surface to have less area (and remain smooth), and α ∈ [0, 1] is a free parameter that controls the degree of smoothness in the solution. This corresponds to a surface velocity (from Eq. 1),v =n(D + H), wheren is the surface normal. This combination of a data-fitting speed function with the curvature term is critical to the application of level sets to volume segmentation. Most level-set data terms D from the segmentation literature are equivalent to well-known algorithms such as isosurfaces, flood fill, or edge detection when used without the smoothing term (i.e. α = 1). The smoothing term alleviates the effects of noise and small imperfections in the data, and can prevent the model from leaking into unwanted areas. Thus, the level-set surface models provide several capabilities that complement volume rendering: local, user-defined control; smooth surface normals for better rendering of noisy data; and a closed surface model,</p><formula xml:id="formula_3">D(I) Model Expands T D = 0 T-ε T+ε I Model</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contracts</head><p>Model Contracts <ref type="figure">Figure 6</ref>: A speed function based on image intensity causes the model to expand over regions with greyscale values within the specified range and contract otherwise. <ref type="figure">Figure 7</ref>: A depiction of the user interface for the volume analysis application. Users interact via slice views, a 3D rendering, and a control panel.</p><p>which can be used in subsequent processing or for quantitative shape analysis.</p><p>For the work in this paper we have chosen a simple speed function to demonstrate the effectiveness of interactivity and real-time visualization in level-set solvers. The speed function we use in this work depends solely on the greyscale value input data I at the pointx:</p><formula xml:id="formula_4">D(I) = − |I − T |,<label>(4)</label></formula><p>where T controls the brightness of the region to be segmented and controls the range of greyscale values around T that could be considered inside the object. In this way a model situated on voxels with greyscale values in the interval T ± will expand to enclose that voxel, whereas a model situated on greyscale values outside that inverval will contract to exclude that voxel. The speed term is gradual, as shown in <ref type="figure">Fig. 6</ref>, and thus the effects of the D diminish as the model approaches the boundaries of regions with greyscale levels within the T ± range, and the effects of the curvature term will be relatively larger. This choice of D corresponds to a simple, one-dimensional statistical classifier on the volume intensity <ref type="bibr" target="#b16">[Lefohn et al. 2003</ref>]. To control the model a user specifies three free parameters, T , , and α, as well as an initialization. The user generally draws a spherical initialization inside the region to be segmented. Note that the user can alternatively initialize the solver with a preprocessed (thresholded, flood filled, etc.) version of the source data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Interface and Usage</head><p>The application in this paper consists of a graphical user interface that presents the user with two slice viewing windows, a volume renderer, and a control panel <ref type="figure">(Fig. 7)</ref>. Many of the controls are duplicated throughout the windows to allow the user to interact with the data and solver through these various views. Two and three dimensional representations of the level-set surface are displayed in real time as it evolves.</p><p>The first 2D window displays the current segmentation as a yellow line overlaid on top of the source data. The sec-ond 2D window displays a visualization of the level-set speed function that clearly delineates the positive and negative regions. The first window can be probed with the mouse to accomplish three tasks: set the level set speed function, set the volume rendering transfer function, and draw 3D spherical initializations for the level-set solver. The first two are accomplished by accumulating an average and variance for values probed with the cursor. In the case of the speed function, the T is set to the average and is set to the standard deviation. Users can modify these values, via the GUI, while the level set deforms. The spherical drawing tool is used to initialize and/or edit the level-set surface. The user can place either white (model on) or black (model off) spheres into the system.</p><p>The volume renderer displays a 3D reconstruction of the current level set isosurface as well as the input data. In addition, an arbitrary clipping plane, with texture-mapped source data, can be enabled via the GUI <ref type="figure">(Fig. 1b)</ref>. Just as in the slice viewer, the speed function, transfer function, and level-set initialization can be set through probing on this clipping plane. The crossing of the level-set isosurface with the clipping plane is also shown in bright yellow.</p><p>The volume renderer uses a 2D transfer function to render the level set surface and a 3D transfer function to render the source data. The level-set transfer function axes are intensity and distance from the clipping plane (if enabled). The transfer function for rendering the original data is based on the source data value, gradient magnitude, and the levelset data value. The latter is included so that the level set model can function as a region-of-interest specifier. All of the transfer functions are evaluated on-the-fly in fragment programs rather than in lookup tables. This approach permits the use of arbitrarily high dimensional transfer functions, allows run-time flexibility, and reduces memory requirements <ref type="bibr" target="#b12">[Kniss et al. 2003</ref>].</p><p>We demonstrate our interactive level-set solver and volume rendering system with the following three data sets: a brain tumor MRI ( <ref type="figure">Fig. 1)</ref>, an MRI scan of a mouse <ref type="figure" target="#fig_3">(Fig. 8)</ref>, and transmission electron tomography data of a gap junction ( <ref type="figure" target="#fig_4">Fig. 9)</ref>. In all of these examples a user interactively controls the level-set surface evolution and volume rendering via the multiview interface. The initializations for the tumor and mouse were drawn via the user interface while the gap junction solution was seeded with a thresholded version of the source data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Performance Analysis</head><p>Our GPU-based level-set solver achieves a speedup of ten to fifteen times over a highly-optimized, sparse-field, CPUbased implementation <ref type="bibr">[The Insight Toolkit 2003</ref>]. All benchmarks were run on an Intel Xeon 1.7 GHz processor with 1 GB of RAM and an ATI Radeon 9800 Pro GPU. For a 256 × 256 × 175 volume, the level-set solver runs at rates varying from 70 steps per second for the tumor segmentation to 3.5 steps per second for the final stages of the cortex segmentation <ref type="figure">(Fig. 1)</ref>. In contrast, the CPU-based, sparse field implementation ran at 7 steps per second for the tumor and 0.25 steps per second for the cortex segmentation.</p><p>The speed of our solver is bound almost entirely by the fragment stage of the GPU. In addition, the speed of our solver scales linearly with the number of active voxels in the computation. Creation of the bit vector message consumes approximately 15% of the GPU arithmetic and texture instructions, but for most applications the speedup over a dense GPU-based implementation far eclipses this additional overhead.  The amount of texture memory required for the level-set computation is proportional to the surface area of the levelset surface-i.e. the number of active tiles. Our tests have shown that for many applications, only 10%-30% of the volume is active. To take full advantage of this savings, texture memory must be dynamically allocated as the surface expands. Our current implementation performs only static allocation, but future versions could easily realize the above memory savings. Section 5 discusses changes to GPU display drivers that will facilitate the implementation of this feature.</p><p>In comparison to the depth-culling-based sparse volume computation presented by <ref type="bibr" target="#b28">Sherbondy et al. [2003]</ref>, our packing scheme guarantees that very few wasted fragments are generated by the rasterization stage. This is especially important for sparse computations on large volumes-where the rasterization and culling of unused fragments could consume a signficant portion of the execution time. In addition, our packing strategy allows us to process the entire active data set simultaneously, rather than slice-by-slice. This improves the computationally efficiency by taking advantage of the GPU's deep pipelines and parallel execution. Our algorithm should also be able to process larger volumes, due to the memory savings discussed above. Our algorithm, however, does incur overhead associated with maintaining the tiles, and more experimentation is necessary to understand the circumstances under which each approach is advantageous. Furthermore, they are not mutually exclusive, and Sect. 5 discusses the possibility of using depth culling in combination with our packed representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>This papers demonstrates a new tool for interactive volume exploration and analysis that combines the quantitative capabilities of deformable isosurfaces with the qualitative power of volume rendering. By relying on graphics hardware, the level-set solver operates at interactive rates (approximately 15 times faster than previous solutions). This mapping relies on a novel dynamic, packed texture and a GPU-to-CPU message passing scheme. While the GPU updates the level set, it renders the surface model directly from this packed texture format. Future extensions and applications of the level-set solver include the processing of multivariate data as well as surface reconstruction and surface processing. Most of these only involve changing only the speed functions.</p><p>Another promising area of future work is to adapt these volume processing algorithms to leverage the evolving capabilities of GPUs. For instance, the efficiency of our memory usage is hampered by inflexibilities in the GPU memory model and instruction set. The first way in which we could use memory more efficiently is by spreading the packed representation across multiple textures. We could then dynamically allocate texture memory as needed and would not be limited to the maximum size of 2D textures. This approach requires either an efficient mechanism for rendering to a slice of a 3D buffer or the ability to dynamically select which texture is sampled (i.e. more indirection in texture reads). The former solution is now possible with the uber buffer <ref type="bibr" target="#b24">[Percy and Mace 2003</ref>] OpenGL extension. A second strategy for reducing memory usage is the development of better compression schemes. Implementing these more aggressive compression algorithms will almost certainly require the ability to use integer data types and bitwise operations in the fragment processor.</p><p>Current GPU capabilities also limit the computational efficiency of the proposed algorithms. We could achieve better computational efficiency within each tile if we could avoid processing pixels that are not sufficiently close to the surface, i.e. we could achieve an even narrower band of computation. This would require a more flexible depth and/or stencil culling mechanism in which multiple data buffers could access a single depth/stencil buffer <ref type="bibr" target="#b24">[Percy and Mace 2003</ref>]. In addition, we could save additional fragment instructions by computing all texture addresses in the vertex stage. This would require more per-vertex interpolants. For instance, the sampling of a 3 × 3 × 3 kernel from a 3D texture requires at least 21, 4-tuple interpolants.</p><p>Future implementations of our algorithm could also take advantage of recently proposed higher-level shading language features. The Java-like interfaces proposed in <ref type="bibr" target="#b19">Mark et al. [2003]</ref> could be used to separate memory access operations from arithmetic computation code. This would maximize code reuse for the nine specialized substream fragment programs because these programs differ only in the definition of their gather operation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>The modern graphics processor pipeline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 :</head><label>8</label><figDesc>(top) Volume rendering of a 256 3 MRI scan of a mouse thorax. Note the level set surface which is deformed to segment the liver. (bottom) Volume rendering of the vasculature inside the liver using the same transfer function as in (a) with the level-set surface is being used as a region-ofinterest specifier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 9 :</head><label>9</label><figDesc>Segmentation and volume rendering of 512× 512 × 61 3D transmission electron tomography data. The picture shows cytoskeletal membrane extensions and connexins (pink surfaces extracted with the level-set models) near the gap junction between two cells (volume rendered in cyan).</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Thanks to Evan Hart, Mark Segal, Jeff Royal and Jason Mitchell at ATI for donating technical advice and hardware to this project. Gordon Kindlmann's nrrd toolkit was used for dataset manipulation. Milan Ikits' GLEW library was used for OpenGL extension management. Erik Jorgensen helped with production of the video. Steve Lamont and Gina Sosinsky at the National Center for Microscopy and Imaging Research at UCSD provided the tomography data. Simon Warfield, Michael Kaus, Ron Kikinis, Peter Black and Ferenc Jolesz provided the MRI head data. The mouse data was supplied by the Center for In Vivo Microscopy at Duke University. This work was supported by grants from NSF, ACI0089915 and CCR0092065, and ONR N000140110033. We also thank John Owens and the anonymous reviewers for their input on the manuscript.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A fast level set method for propogating interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Adalsteinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Physics</title>
		<imprint>
			<biblScope unit="page" from="269" to="277" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Rendering from compressed textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Beers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Chaddha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="373" to="378" />
		</imprint>
	</monogr>
	<note>Annual Conference Series</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Sparse matrix solvers on the GPU: Conjugate gradients and multigrid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bolz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Farmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grinspun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="917" to="924" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium On Volume Visualization</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proceedings of SIGGRAPH 88)</title>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An adaptive level set method for medical image segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Droske</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schaller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Annual Symposium on Information Processing in Medical Imaging</title>
		<editor>R. Leahy and M. Insana</editor>
		<meeting>of the Annual Symposium on Information essing in Medical Imaging</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">High-Quality Pre-Integrated Volume Rendering Using Hardware-Accelerated Pixel Shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Level Set Methods and Dynamic Implicit Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fedkiw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A nonoscillatory Eulerian approach to interfaces in multimaterial flows (the ghost fluid method)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fedkiw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Aslam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Merriman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Physics</title>
		<imprint>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="page" from="457" to="492" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A multigrid solver for boundary value problems using programmable graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Goodnight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Woolley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lewin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="102" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient conditional operations for data-parallel architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Kapasi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rixner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Khailany</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual International Symposium on Microarchitecture</title>
		<meeting>the 33rd Annual International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="159" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multi-Dimensional Transfer Functions for Interactive Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="270" to="285" />
			<date type="published" when="2002-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Gaussian transfer functions for multi-field volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Premoze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ikits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>To Appear</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Adaptive texture maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="7" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Linear algebra operators for GPU implementation of numerical algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="908" to="916" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A GPU-based, threedimensional level set solver with curvature flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">;</forename><surname>Mcallister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Acm Sigarch/Ieee. Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
		<idno>UUCS-02-017</idno>
	</analytic>
	<monogr>
		<title level="m">Super Computing</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>University of Utah tech report</orgName>
		</respStmt>
	</monogr>
	<note>Fast matrix multiplies using graphics hardware</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive, GPUbased level sets for 3D brain tumor segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Medical Image Computing and Computer Assisted Intervention</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>To Appear</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Shape modeling with front propagation: A level set approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Malladi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Vemuri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="158" to="175" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cg: A system for programming graphics hardware in a C-like language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Glanville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Akeley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Kilgard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="896" to="907" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fronts propagating with curvaturedependent speed: Algorithms based on Hamilton-Jacobi formulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sethian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Physics</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="12" to="49" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Computer Graphics on a Stream Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Owens</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Merriman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A PDE based fast local level set method</title>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Physics</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="410" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Percy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mace</surname></persName>
		</author>
		<ptr target="http://mirror.ati.com/developer/techpapers.html" />
		<title level="m">OpenGL extensions: Siggraph</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Level set segmentation in graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Strzodka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Image Processing</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="1103" to="1106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A rendering algorithm for visualizing 3D scalar fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proceedings of SIGGRAPH 88)</title>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="51" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Level Set Methods and Fast Marching Methods Evolving Interfaces in Computational Geometry, Fluid Mechanics, Computer Vision, and Materials Science</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Fast volume segmentation with simultaneous visualization using programmable graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sherbondy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nepal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>To Appear</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Using graphics cards for quantized FEM computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Strzodka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings VIIP Conference on Visualization and Image Processing</title>
		<meeting>VIIP Conference on Visualization and Image Processing</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Geometric surface smoothing via anisotropic diffusion of normals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tasdizen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Burchard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osher</surname></persName>
		</author>
		<ptr target="http://www.itk.org" />
	</analytic>
	<monogr>
		<title level="m">The Insight Toolkit</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="125" to="132" />
		</imprint>
	</monogr>
	<note>IEEE Visualization</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Volumetric deformable models: Active blobs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">T</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization In Biomedical Computing</title>
		<meeting><address><addrLine>SPIE, Mayo Clinic, Rochester, Minnesota, R. A. Robb, Ed</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="122" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A level-set approach to 3D reconstruction from range data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Vision</title>
		<imprint>
			<biblScope unit="page" from="203" to="231" />
			<date type="published" when="1998-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Direct Volume Rendering via 3D Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>UCSC-CRL-94-19</idno>
		<imprint>
			<date type="published" when="1994-06" />
		</imprint>
		<respStmt>
			<orgName>University of California at Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Direct visualization of volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pizer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cullip</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rhoades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="63" to="71" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
