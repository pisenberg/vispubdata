<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hardware-Based Ray Casting for Tetrahedral Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manfred</forename><surname>Weiler</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Merz</surname></persName>
							<email>merzms@gmx.de.</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Visualization and Interactive Systems Group</orgName>
								<orgName type="institution">University of Stuttgart</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Universität Stuttgart</orgName>
								<address>
									<country>Universitätsstr</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Hardware-Based Ray Casting for Tetrahedral Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation-Bitmap and Framebuffer Operations</term>
					<term>Display Algorithms; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Color</term>
					<term>Shading</term>
					<term>Shadowing</term>
					<term>Texture</term>
					<term>Raytracing ray casting</term>
					<term>pixel shading</term>
					<term>programmable graphics hardware</term>
					<term>cell projection</term>
					<term>tetrahedral meshes</term>
					<term>unstructured meshes</term>
					<term>volume visualization</term>
					<term>pre-integrated volume rendering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: All images show tetrahedral meshes consisting of 125K to 190K cells rendered with our hardware-based ray casting algorithm. The algorithm exploits the programmable fragment unit of the ATI Radeon 9700 graphics chip and runs at several frames per second in a 512 × 512 viewport. The left image shows multiple shaded isosurfaces, the middle and right images are rendered with a full density-emitter model.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The evolution of computer graphics hardware has always been one of the predominant factors for the design of algorithms for computer graphics in general and computer visualization in particular. For example, the steady increase in memory of graphics subsystems favored frame buffer and texturing techniques over alternative approaches. Nowadays, modern graphics hardware is additionally characterized by a highly parallel architecture, floating-point arithmetic, and an increasingly flexible programmability. Provided that these features are efficiently exploited, many algorithms can be implemented completely in graphics hardware, thereby reducing the communication between the CPU and the graphics adapter to the bare minimum and running graphics hardware at full capacity. Therefore, the possibility to efficiently exploit these features is a more and more important trait of visualization algorithms. In order to achieve this goal, there are two particularly important requirements for the design of an algorithm: Firstly, a parallel implementation should be straightforward; and secondly, the algorithm should not require random memory writes. The latter requirement is often expressed by a "streaming processor model"; see, for example, <ref type="bibr" target="#b5">[Purcell et al. 2002]</ref>.</p><p>With respect to direct volume visualization of tetrahedral meshes, it is worth noting that there appears to be no working implementation of a hardware-based algorithm that fulfills these two requirements. For example, cell projection with non-commutative blending requires cell sorting, but a parallel implementation of cell sorting in graphics hardware has not been published yet. With the R-buffer architecture <ref type="bibr" target="#b13">[Wittenbrink 2001;</ref><ref type="bibr" target="#b3">King et al. 2001]</ref> orderindependent cell projection could be achieved. Unfortunately, it has not been built yet.</p><p>On the other hand, ray casting was recently implemented for uniform meshes in programmable graphics hardware <ref type="bibr" target="#b8">[Röttger et al. 2003</ref>]. Moreover, ray casting was also successfully employed <ref type="bibr">IEEE Visualization 2003</ref><ref type="bibr">, October 19-24, 2003</ref>, Seattle, Washington, USA 0-7803-8120-3/03/$17.00 ©2003 IEEE for view-independent projection of single tetrahedra <ref type="bibr" target="#b10">Weiler et al. 2003</ref>]. Therefore, our approach is to design and implement a complete ray caster for tetrahedral meshes in programmable graphics hardware. Obviously, all pixels can be processed in parallel and-as we will demonstrate-no random memory writes are required. Similarly to other ray casting approaches, cyclic meshes do not pose any particular problems and the performance can benefit from early ray termination techniques.</p><p>Thus, ray casting appears to be an extremely attractive algorithm for direct volume visualization of tetrahedral meshes on today's and future graphics hardware. Unfortunately, limitations of texture memory resources and the particular problems posed by complex non-convex meshes will often diminish the advantages of our approach. Therefore, instead of suggesting that ray casting will replace cell projection as the algorithm of choice for hardwareassisted direct volume visualization of unstructured meshes, we want to clarify under which circumstances ray casting is a serious competitor on modern graphics hardware.</p><p>Before presenting our ray casting algorithm for tetrahedral meshes in Section 3, we discuss previous and related work in Section 2. Section 4 introduces incremental pre-integration, an algorithm that allows us to employ pre-integrated volume rendering and still modify transfer functions at almost interactive rates. Implementation issues of our ray casting approach are discussed in Section 5, while results are presented in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Previous Work</head><p>Our ray casting algorithm is mainly based on the algorithm published in <ref type="bibr" target="#b0">[Garrity 1990</ref>], which-for each viewing ray-traverses a mesh by following links between cell neighbors. However, in order to compute re-entries of viewing rays in non-convex meshes, we employ a concept published in <ref type="bibr" target="#b12">[Williams 1992</ref>], which we refer to as the convexification of non-convex meshes. Ray integration within individual cells is performed analogously to the hardwarebased, view-independent cell projection published in <ref type="bibr" target="#b10">Weiler et al. 2003</ref>]; in particular, we also employ preintegrated volume rendering as suggested in <ref type="bibr" target="#b7">[Röttger et al. 2000]</ref>.</p><p>Several of our modifications of Garrity's ray casting algorithm that were necessary for an implementation in programmable graphics hardware were suggested by the ray tracing algorithm in <ref type="bibr" target="#b5">[Purcell et al. 2002]</ref> and the ray casting algorithm for uniform meshes published in <ref type="bibr" target="#b8">[Röttger et al. 2003</ref>]. Preliminary versions of our approach were described in <ref type="bibr" target="#b4">[Kraus and Ertl 2002]</ref> and <ref type="bibr" target="#b10">[Weiler et al. 2003</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Parallel Ray Casting</head><p>The fundament of our ray casting algorithm for programmable graphics hardware is a ray propagation approach similar to <ref type="bibr" target="#b0">[Garrity 1990]</ref>; see <ref type="figure" target="#fig_0">Figure 2</ref>. Each viewing ray is propagated front to back from cell to cell until the whole mesh has been traversed. The ray starts from its first intersection with the mesh, which is determined during an initialization phase. The traversal is performed in passes; in each pass the color and opacity contribution of a pixel's current cell is computed and accumulated in the frame buffer.</p><p>A software solution typically processes the pixels and, therefore, the viewing rays successively. However, ray casting algorithms can be parallelized easily as the computations performed for each pixel are independent. This paves the way for an implementation on programmable graphics hardware, where each fragment is processed individually. pixels in view plane tetrahedral mesh </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>We employ fragment programs to perform all computations of the ray propagation in graphics hardware. A screen-sized rectangle is rendered to perform one propagation step for each pixel and, thus, for each viewing ray at the same time. With each rendered rectangle each viewing ray will proceed one cell through the tetrahedral mesh. This strategy requires that intermediate information on intersections of rays with cells of the mesh is communicated between successive rendering passes. This is accomplished with the help of several two-dimensional RGBA textures of the dimensions of the frame buffer that are read and updated in every pass. The textures contain the current intersection point of the ray with the face of a cell and the index of the cell the ray is about to enter through this face.</p><p>In order to be able to compute all required information for a rendering pass, the fragment program requires access to the mesh data. Therefore, we store vertex data, face normals, and neighbor data in several texture maps, which not only enables random access by the fragment program but also allows for the data to reside in the local memory of the graphics adapter; thus, our algorithm has very low bandwidth requirements.</p><p>For each viewing ray, the algorithm basically performs the following steps: We start by clearing the frame buffer and by initializing the first intersection of the viewing ray, which is an intersection with one of the boundary faces of the mesh. This may be implemented using a rasterization of the visible boundary faces. However, it may also be performed in software as there are usually far less boundary faces than cells in a mesh, and thus, this step is not time critical. The remaining steps can be divided into ray integration and ray traversal issues. We will describe both parts after a brief introduction to the nomenclature used in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Nomenclature</head><p>In order to describe the computations of one rendering pass, a few notations have to be introduced; see also <ref type="figure" target="#fig_2">Figure 3</ref>. Tetrahedral cells of a mesh consisting of n cells are identified by an integer index from 0 to n − 1; often this index is called t. Each tetrahedron t has four faces, the normal vectors of which are denoted by n t,i , where i specifies the face and is 0, 1, 2, or 3. Note that normal vectors always point to the outside of their cell. Each tetrahedron t also defines four vertices v t,i , where vertex v t,i is opposite to the i-th face; see <ref type="figure" target="#fig_2">Figure 3a</ref>. As indicated in <ref type="figure" target="#fig_2">Figure 3b</ref>, the neighbor of a tetrahedron t that shares the i-th face is denoted by a t,i . The index of the face of a t,i that corresponds to the i-th face of t is denoted by f t,i ; see <ref type="figure" target="#fig_2">Figure 3c</ref>.</p><formula xml:id="formula_0">t v t,0 v t,1 v t,2 n t,0 n t,2 n t,1 (a) t a t,0 a t,2 a t,1 (b) t f t,0 f t,2 f t,1</formula><p>(c) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Ray Integration</head><p>Ray integration within single cells is the main task of one rendering pass of our ray casting algorithm. Given the current cell for each viewing ray we have to compute the color and opacity contribution for the ray segment inside the current cell, which has to be blended into the frame buffer. Note that we apply the pre-integrated classification approach published in <ref type="bibr" target="#b7">[Röttger et al. 2000]</ref>, which stores pre-integrated color and opacity values in a texture map, and uses the scalar value at the entry point, the scalar value at the exit point, and the length of the ray segment as parameters for the lookup into this texture. The entry point and its scalar value can be read easily from the textures communicating intermediate information between rendering passes as introduced in Section 3.1. These textures also identify the cell that the ray entered at this point. We determine the corresponding exit point by computing three intersection points of the ray with the faces of the entered cell and choosing the intersection</p><formula xml:id="formula_1">e t Λ 2 r Λ 1 r Λ 0 r v t,0 v t,1 v t,2 n t,0 n t,2 n t,1</formula><p>Figure 4: Intersections of a viewing ray with the faces of a cell. point that is closest to the eye point but not on a face that is visible from the eye point. Note that it is not necessary to consider the intersection with the entering face.</p><p>With the entering face j, the eye point e, and the normalized direction r of the viewing ray (see <ref type="figure">Figure 4</ref>), the three intersection points with the faces of cell t are e + λ i r with 0 ≤ i &lt; 4 ∧ i = j and</p><formula xml:id="formula_2">λ i = (v − e) • n t,i r • n t,i , where v := v t,3−i .<label>(1)</label></formula><p>This equation is easily implemented with pixel shading operations as three-dimensional vector operations are usually well supported. A face is visible if the denominator in the previous equation is negative; thus, this test comes almost for free. If λ i is set to an appropriately large number for all visible faces, min{λ i |0 ≤ i &lt; 4 ∧ i = j} identifies the exit point. Determining the minimum of three numbers is usually less well supported by pixel shading hardware, but it may be implemented with the help of a sequence of conditional set operations. (An alternative solution based on texture mapping is discussed in .) Once the minimum λ i and its face i are identified, the intersection point x may be computed as x = e + λ i r. The scalar field value s(x) at a point x can be computed as</p><formula xml:id="formula_3">s(x) = g t • (x − x 0 ) + s(x 0 ) = g t • x + (−g t • x 0 + s(x 0 )) ,<label>(2)</label></formula><p>where g t is the gradient of the scalar field, which is constant for a cell, and x 0 is any point in cell t, e.g., one of the vertices. Note that Equation <ref type="formula" target="#formula_3">2</ref>implies that we only have to store one vector g t and one scalarĝ</p><formula xml:id="formula_4">t = −g t • x 0 + s(x 0 )</formula><p>for each cell in order to be able to compute the scalar field value at any point within the cell. Moreover, this reconstruction of scalar values involves only one dot product and one scalar addition, which can be performed much more efficiently than a full linear interpolation from the scalar values at the vertices of the mesh since no computation of interpolation weights is involved.</p><p>With the scalar values of the entry point and the exit point and the length of the ray segment, which can be computed as the distance between the coordinates of these points, we are now able to evaluate the ray integral by performing a lookup in the pre-integration texture map. Note that the length has to be divided by the maximum edge length of the mesh in order to serve as a texture coordinate in the range of [0 . . . 1]. This dependent lookup can be implemented by only one additional fragment program operation.</p><p>As demonstrated in  this lookup supports different optical models including emission, absorption, maximum intensity projection, and the rendering of multiple flat shaded isosurfaces as well as arbitrary transfer functions, which only affect the generation of the texture map. In contrast to , however, our ray casting approach naturally allows for optical models requiring non-commutative blending, in particular the full density-emitter model <ref type="bibr" target="#b11">[Williams and Max 1992]</ref> that is commonly applied in volume rendering applications (see <ref type="figure" target="#fig_3">Figure 5</ref>). The cell traversal ensures the processing of the ray segments in correct visibility order. Therefore, in contrast to cell projection based algorithms no expensive cell sorting is required and visibility cycles are correctly rendered.</p><p>In a last step, the color contribution of the ray segment has to be written to the frame buffer. As the blending has to be performed front-to-back, the accumulated associated (i.e., premultiplied) color C k and opacity α k after k passes is given bỹ</p><formula xml:id="formula_5">C k =C k−1 + (1 − α k−1 )C k and α k = α k−1 + (1 − α k−1 )α k ,</formula><p>whereC k and α k denote the associated color and the opacity of the ray segment processed in the k-th pass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Cell Traversal</head><p>As mentioned above, the traversal of the viewing rays through the tetrahedral mesh is performed by successively rendering screensized rectangles. Each rendering pass progresses one layer of cells of the mesh. The traversal is controlled by a current cell index per viewing ray that is stored in intermediate textures of the same size as the frame buffer.</p><p>The fragment program applied in each rendering pass reads the current index and updates each texel of the texture with the index of the cell adjacent to the face through which the viewing ray leaves the current cell. This index is given by a t,i for the current cell t with i being the index of the minimum intersection λ i computed during ray integration.</p><p>Note that for boundary cells this index is −1; thus, we can easily determine whether a viewing ray has left the mesh and the ray processing for a particular pixel should end. In this case the new exit point should be set to the old entry point resulting in a zero length ray segment without effect on the frame buffer content. A more efficient solution which exploits the early z-test of modern graphics adapters is presented in Section 5.2 However, this procedure is only useful for convex meshes as there may be re-entries if the mesh is non-convex. We convert non-convex meshes into convex-meshes by filling the empty space between the boundary of the mesh and a convex hull of the mesh with imaginary cells as proposed in <ref type="bibr" target="#b12">[Williams 1992</ref>]. In the rendering pass we have to take special care of imaginary cells since these cells must not contribute to the color and opacity of the ray. However, we have to compute the exit point and the next cell in the same way as for ordinary cells.</p><p>The ray traversal has to continue until all rays have left the mesh. An appropriate test can be performed in software by evaluating the component of the intermediate textures specifying the current cell. However, this requires an expensive read back from the graphics adapter. Fortunately, modern graphics adapters can provide feedback, e.g., via the occlusion query functionality, which can be exploited to evaluate the stop condition in hardware as demonstrated in Section 5.2.</p><p>Furthermore, the current cell index allows us to easily incorporate techniques for early ray termination, which has the potential of greatly improving rendering performance due to the reduced rasterization. We simply have to set the current cell in the intermediate texture to −1, if the accumulated opacity is sufficiently high. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Incremental Pre-Integration</head><p>As mentioned in Section 3.3, the color and opacity contribution of each ray segment is determined by a pre-integrated texture lookup as suggested in <ref type="bibr" target="#b7">[Röttger et al. 2000]</ref>.</p><p>We employ transfer functions τ(s) and c(s), which depend on scalar values s = s(x) for any point x. τ(s) specifies extinction coefficients and color densities (per unit length) while emitted colors are specified by c(s). Thus, the associated colorC and opacity α of a ray segment within a tetrahedron arẽ Provided that a lookup table has been calculated for all entries with lengths less or equal l , the entries for the next length l = l +∆l can be calculated by splitting the integrals into one part of length ∆l and one part of length l ; see <ref type="figure" target="#fig_4">Figure 6</ref>. The scalar value s p at the split point is interpolated linearly between s f and s b , i.e., s p = (l s f + ∆l s b )/(∆l + l ). As the integrals for these parts are already covered by the lookup table, the evaluation is reduced to interpolations of tabulated integrals and a blending operation. More specifically, The interpolation of tabulated integrals for the table lookups in Equations (5) and (6) introduces an error depending on the chosen resolution of the table. Note that the errors associated with the lookups forC(s f , s p , ∆l) and α(s f , s p , ∆l) are not critical since these errors cannot accumulate. However, the errors associated with the lookups forC(s p , s b , l ) and α(s p , s b , l ) are potentially accumulating. In practice, this error accumulation is prevented by the blending operations in Equations (5) and (6) due to the chosen order of the two parts of length ∆l and l , respectively.</p><formula xml:id="formula_6">C = Z 1 0 τ (1 − ω)s f + ωs b c (1 − ω)s f + ωs b l × exp − Z ω 0 τ (1 − ω )s f + ω s b ldω dω (3) and α = 1 − exp − Z 1 0 τ (1 − ω)s f + ωs b ldω<label>(4)</label></formula><formula xml:id="formula_7">C(s f , s b , l) and α(s f , s b , l) are given bỹ C(s f , s b , l + ∆l) =C(s f , s p , ∆l) + + (1 − α(s f , s p , ∆l))C(s p , s b , l ), (5) α(s f , s b , l + ∆l) = α(s f , s p , ∆l) + + (1 − α(s f , s p , ∆l))α(s p , s b , l ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation Issues</head><p>In the description of our parallel ray casting algorithm for fragment shading hardware in Section 3 we tried to avoid most of the distracting hardware-specific details. This section will deal with issues of an implementation on an ATI Radeon 9700 with DirectX 9 and the Pixel Shader 2.0 shading language.</p><p>The feature set of Pixel Shaders 2.0 allows for a quite straightforward implementation of the operations described in Section 3, since several restrictions that applied to the previous version-Pixel Shaders 1.4-have been relaxed, in particular the number of different texture maps that can be addressed (16 in Pixel Shader 2.0), and the number of per-fragment operations provided per pass (32 texture addressing instructions and 64 color blending/arithmetic instructions). Moreover, the current pixel shader API does no longer restrict the interleaving of texture and arithmetical operations and supports floating point precision throughout all steps of the geometry and rasterization pipeline. We will, therefore, not present particular pixel shader code in this paper.</p><p>The essential feature of DirectX 9 for our algorithm is the support of textures with full 32 bit floating point precision since these, for the first time, allow us to store the complete mesh in texture maps, i.e., in the local memory of the graphics adapter, without losing accuracy. They also allow us to randomly access the data from a fragment program. However, several restrictions-e.g., only nearest neighbor sampling and no blending-apply to floating point textures depending on the actual graphics hardware and, therefore, had impact on our implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data Structures</head><p>All data structures required by our hardware-based ray caster, except for the pre-integration table, are implemented either as twodimensional or three-dimensional floating point RGBA texture maps. The pre-integration table is stored in an 8 bit RGBA texture since smooth ray integration depends on the trilinear interpolation. All other textures are mainly used for indexed lookup; thus, the lack of linear interpolation for floating point textures on the Radeon 9700 is actually no problem here. <ref type="table">Table 1</ref> provides an overview of the required textures. Note that the cell indices are encoded in two texture coordinates and two color components as their range might easily exceed the range of a single texture coordinate. data in texture coords texture data texture</p><formula xml:id="formula_8">u v w r g b α vertices t i v t,i - face normals t i n t,i f t,i neighbor data t i a t,i - - scalar data t - g tĝt current cell</formula><p>raster pos -t j intersect. pt.</p><p>raster pos ---λ s(e + λr) color, opacity raster pos -r g b α <ref type="table">Table 1</ref>: Summary of the textures described in the main text.</p><p>The lower index of a cell is the remainder of the cell index divided by the v-size of the texture, the upper index is the integer part of the division result. The texture maps can be divided into constant textures storing mesh data and intermediate textures that communicate data between different rendering passes. Mesh data consists of three three-dimensional textures for vertices, face normals, and neighbor data; and one two-dimensional texture for scalar data reconstruction (see Section 3.3). The normal texture additionally stores the cell type-imaginary or not-as the sign bit in the alpha channel of each texel. The textures are accessed via the cell index specified in the first and second texture coordinate. For three-dimensional textures the w-coordinate specifies the index of the vertex, face, or neighbor, respectively. Thus, the third dimension of all three-dimensional textures is fixed at a size of four since each tetrahedron specifies four vertices, four faces, and four neighbors. The u-and v-size has to be adapted to the size of the mesh.</p><p>The traversal data structures consist of three two-dimensional RGBA floating point textures.</p><p>They are accessed by the raster position of the corresponding pixel. Unfortunatelyunlike the OpenGL ARB fragment program extension-Pixel Shaders 2.0 do not automatically provide the raster position of a fragment; thus, we have to specify the raster position of the four vertices of the rendered rectangle as texture coordinates such that they are interpolated for each fragment.</p><p>The first traversal texture specifies the most recently entered cell for each viewing ray; the second texture specifies the position of and the scalar value at the last intersection point of each viewing ray with the faces of cells. Note that in contrast to the description in Section 3 we are not able to use the frame buffer for accumulating the color and opacity of the integrated ray segments since there is no floating point format available for the frame buffer. A precision of 8 bits, however, would lead to blending artifacts; in particular, as the contribution of a single ray segment usually is very small. Furthermore, the Radeon 9700 does not support simultaneous rendering to textures and the frame buffer. Thus, we employ an additional floating point texture for color and opacity accumulation.</p><p>All these textures are read and updated during each rendering pass. Therefore, we in fact require two sets of traversal data structures, i.e., two sets of textures, since current graphics adapters do not allow to read from and write into a texture at the same time. We apply ping-pong rendering by binding one set of textures for reading and specifying the second set as multiple render targets for writing and exchange the role of the texture sets after every rendering pass.</p><p>In order to access the normalized ray direction within the fragment program, we decided not to use a texture map because of the additional memory overhead. Instead we compute the direction in each rendering pass on-the-fly. The additional computational overhead can be neglected since we exploit the up-to-now hardly stressed geometry unit by computing the ray direction for each vertex within a vertex shader and add only one additional operation to the pixel shader that normalizes the interpolated ray directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Rasterization Loop</head><p>Terminating the rendering loop comprises two issues. First, for each fragment we have to detect whether the corresponding viewing ray has left the mesh. In this case ideally no more fragment operations should be spent on the corresponding pixel. Secondly, we must determine whether all viewing rays have left the mesh, i.e., whether we can stop the rendering.</p><p>For the first task we apply the early z-test provided by the Radeon 9700 graphics adapter <ref type="bibr" target="#b6">[Riguer 2002</ref>]. This additional z-test is applied before the shading of the fragment; thus, fragment processing is stopped before any pixel shader is invoked. This solution is much more efficient than using the pixel shader "kill" operation.</p><p>Exploiting the early z-test for detecting fully processed viewing rays is accomplished by checking within the pixel shader, whether there is no next cell, i.e., whether the neighbor index a t,i is −1 with i being the index of the face through which the view ray leaves the current cell t. In this case, the z-value of the corresponding pixel is altered to z near which prevents further updates of the pixel color. However, this cannot be performed within the regular ray processing pixel shader, since the early z-test is automatically disabled for pixel shaders modifying the z-value <ref type="bibr" target="#b6">[Riguer 2002</ref>]. Thus, we apply a special z-update pass, which reads from the source textures but only writes to the z-buffer. As mentioned above, we update the zvalue of each pixel with a corresponding current cell index of −1 to z near ; otherwise, i.e., if there is a next cell the pixel's z-value is not updated. The latter is accomplished by exploiting the z-test in the z-update pass since we assign a value of z far to the corresponding fragments, which are therefore discarded.</p><p>Since this additional pass introduces some overhead in terms of rasterization and pixel shader switches, z-update passes are not applied after every rendering pass. We experienced the greatest performance improvements with one z-update pass about every 14 rendering passes. Pixels not covered by the silhouette of the tetrahedral mesh are already locked by an additional z-update pass right after the rendering pass determining the first hit of each ray.</p><p>Note that if a cell index of −1 has been read, the shader has to copy the accumulated color and opacity from the source texture to the destination texture because the destination texture may still contain the results from the last but one ray integration step. However, it is not guaranteed that the copying takes place because the pixel might already be locked by the z-buffer. Therefore, in order to ensure a correct final image, we apply z-update passes only after odd rendering passes, i.e., after rendering into the first set of textures and we also expect the final result there. This is obviously correct for rays that require an odd number of rendering passes. The final result for rays requiring an even number of passes will eventually be written into the second set of textures. However, since the rendering loop will be terminated after odd passes only, at least one additional pass will be applied copying the result into the first set of intermediate textures.</p><p>In order to determine whether all rays have been fully processed, we employ the DirectX 9 occlusion query. With every z-update pass an occlusion query (D3DQUERYTYPE OCCLUSION) is initiated returning the number of pixels that passed the z-test. As only fragments corresponding to viewing rays which left the mesh since the last z-update pass will pass the z-test, the result exactly reflects the number of viewing rays that have recently become finished. Accumulating the results of the occlusion queries allows us to stop the rendering as soon as the sum reaches the number of pixels covered by the projected mesh. We determine the latter with an additional occlusion query for the initial rendering pass that is used for detecting the first hit of the viewing rays with the boundary of the tetrahedral mesh.</p><p>Note that the asynchronous delivery of the occlusion query result leads to some additional rendering passes. However, we found this effect neglectable compared to the delay caused by waiting for the result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>We have tested our implementation on a PC with an Athlon XP 1900+ processor and 512 MB RAM running Windows XP. However, the influence of the CPU is neglectable since our approach moves most of the computation to the graphics processor. As graphics adapter an ATI Radeon 9700 Pro with 128 MB of local memory was employed. The implementation was built on top of DirectX 9. total no. cells imaginary fps tets/sec Bluntfin <ref type="figure">(Fig. 1)</ref> 190 852 3 534 3.37 643 K Heat-sink ( <ref type="figure">Fig. 9)</ref> 124 152 2 484 2.27 282 K Cylinder <ref type="figure">(Fig. 9)</ref> 203 460 1 860 1.94 395 K Sphere <ref type="figure">(Fig. 1)</ref> 148 955 -5.13 764 K <ref type="table">Table 2</ref>: Performance of our hardware-based ray casting algorithm for different datasets using a Radeon 9700 Pro graphics adapter. The cell numbers include imaginary cells from the convexification process. The referenced figures demonstrate the rendering mode and the employed transfer functions. <ref type="table">Table 2</ref> shows the performance of our hardware-based ray casting algorithm for different datasets presented in the paper. Sphere, heat-sink, and bluntfin denote the datasets of <ref type="figure">Figure 1</ref>, whereas the cylinder dataset is shown in <ref type="figure">Figure 9</ref>. Note that the performance is merely affected by the optical model except for the full densityemitter model shown in the middle and right image of <ref type="figure">Figure 1</ref> since the required three-dimensional dependent texture lookup is more expensive than the two-dimensional lookup used for the other optical models. However, as our ray casting approach includes early ray termination the performance is influenced by the selected transfer function since the traversal terminates if the accumulated opacity is sufficiently high. The table, therefore, contains references to the corresponding images.</p><p>The performance numbers in <ref type="table">Table 2</ref> represent average values for varying view directions. They have been acquired by an animation where the datasets are rotated simultaneously about the local xaxis and y-axis with different angular velocities for each axis. The actual frame rate, or frame time respectively, almost directly corresponds to the number of calls to the ray traversal shader, which is influenced by the number of pixels covered by the projected dataset and the number of passes required for each pixel. The latter depends on the dataset itself and the visualization parameters that influence the effectiveness of the early ray termination. On average our implementation was able to perform about 15 million traversal shader calls per second on the test system. A typical variation of the frame time is presented in <ref type="figure">Figure 7</ref>. It corresponds to an animation sequence for the heat-sink dataset of <ref type="figure">Figure 9</ref>.</p><p>The effect of early ray termination is illustrated in <ref type="figure">Figure 8</ref>, which shows the number of fragments processed in each rendering shader calls frame time <ref type="figure">Figure 7</ref>: The figure shows the variation of the frame times for varying view directions on the heat-sink dataset rendered on a 512× 512 viewport. The corresponding image is shown in <ref type="figure">Figure 9</ref>. The curve shows good correspondance between the frame time and the total number of traversal operations. Note that the minimum and maximum of the frame times correspond to 1.80 fps and 3.55 fps respectively. 0 50000 100000 150000 200000 0 20 40 60 80 100 120 140 160 # fragments # passes w/o early z with early z early ray term. <ref type="figure">Figure 8</ref>: The figure shows statistics for the heat-sink dataset rendered on a 512 × 512 viewport. The corresponding image is shown in <ref type="figure">Figure 9</ref>. The curves reflect the number of fragments processed in each rendering pass. As can be seen from the area below the curves, exploiting the early z-test significantly reduces the total amount of rasterized fragments.</p><p>pass for the heat-sink dataset in <ref type="figure">Figure 9</ref>. Without early ray termination, for this particular set of viewing parameters, our ray casting algorithm requires 156 rendering passes to finish (green line). Thereby, compared to the brute-force fragment processing without an early-z test that discards rays that have left the mesh (red line), the load on the fragment processor is reduced by a factor of 2. When early ray termination is enabled the total fragment load is further reduced by a factor of 2 and the rendering completes after 96 passes (blue line).</p><p>Despite the advantages from early ray termination, currently, our ray casting algorithm can in many situations be outperformed by optimized cell projection algorithms, e.g., as reported by <ref type="bibr" target="#b1">[Guthe et al. 2003</ref>]. This is in particular the case for large viewports, since our algorithm is highly output sensitive. However, cell projection approaches, especially for non-commutative optical models, are limited by the visibility sorting, which already prevents the current graphics adapters from running at full capacity, due to limited CPU resources and graphics bus bandwidth. Thus, projecting the development of CPUs and graphics adapters during the last years our ray casting approach, which is only limited by the rasterization performance of the graphics adapter, may soon catch up. <ref type="figure">Figure 9</ref>: The left image shows an isosurface rendering of the heatsink dataset. In the right image the cylinder dataset is presented. The hole in the middle has been filled with imaginary cells in order to allow for re-entries during the cell traversal. Both datasets are rendered on a 512 × 512 viewport.</p><p>One of the main advantages of our approach is the low bandwidth requirement for the graphics bus that allows the graphics processor to run at full capacity. This, however, limits the size of suitable datasets since interactive frame rates cannot be achieved if texture paging is necessary.</p><p>Provided that the frame buffer consumes 12.5 MB of the graphics memory (2 × 32 bit RGBA + 16 bit depth for a standard 1280 × 1024 desktop), we are able to store between 500, 000 and 600, 000 tetrahedra depending on the optical model used. We apply a 8 bit 128 × 128 × 256 ( = 16 MB) RGBA texture for the full density-emitter model since this requires a three-dimensional pre-integration table, whereas for the remaining models a twodimensional RGBA texture (256 × 256 = 0.25 MB) is sufficient since the length of the ray segment affects the color contribution either linearly or not at all. Unfortunately, with DirectX 9 all textures for intermediate data must share the same pixel format in order to serve as render targets, which produces quite some memory overhead since according to <ref type="table">Table 1</ref> we only need 9 of the 12 provided color components per texture set. Moreover, 16 bit short values would provide enough precision for cell and face indices since we only have do address 2048 different texels, the maximum dimension of a texture. Thus, the memory required for one pixel in the output image is 2 × 48 bytes according to the following summary: Each tetrahedron requires 160 bytes of memory. As mentioned above, most mesh data is stored in RGBA floating point textures; however, neighbor data only requires a two-component 16 bit texture.</p><p>Note that limited fragment operations have prohibited further optimizations, e.g., data packing, storing only one instance of each vertex and referencing the vertices of each cell by an index in this texture, encoding normals with two components and one sign bit, or using a single 32 bit value for cell indices and face index restoring the individual components in the pixel shader on-the-fly.</p><p>These arrangements would have decreased the memory consumption to 16 bytes/vertex, 64 bytes/tetra, and 2 × 32 bytes/pixel allowing for 1, 280, 000 to 1, 530, 000 tetrahedra on a 128 MB graphics adapter without loss of accuracy.</p><p>The incremental pre-integration was tested for a lookup table of 128 × 128 × 256 on an Athlon XP 1900+. Computing each entry individually took about 128 sec., where the transfer function was sampled with the Nyquist frequency, but the number of integration steps was not increased with the length of each viewing ray segment. With our incremental pre-integration approach the computation took only 1.5 sec. to complete. In this case we perform an explicit integration only for the first slice of the texture corresponding to 1 256 of the maximum segment length. Combining two such ray segments during the incremental computation is equivalent with the numerical integration using twice as much samples along the length of the ray segment. Thus, the complete integration table is computed with a fixed sample distance along the ray segment and, therefore, the results are much more accurate. Note that the corresponding numerical integration of each entry of the integration texture with a fixed sample distance along the ray takes hours to complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>We have presented the first implementation of a volume ray casting algorithm for tetrahedral meshes running on off-the-shelf programmable graphics hardware. In contrast to cell projection approaches our algorithm allows the graphics adapter to access all mesh data from its local memory. Thus, it can run at full capacity since it is neither limited by the bandwidth of the graphics bus nor by the CPU. Cell projection, however, is computational and bandwidth bound since the CPU has to provide sorted cells and a lot of triangles must be transfered to the graphics chip per frame. Therefore, we expect our approach to benefit more from the increase in performance of graphics hardware than cell projection algorithms.</p><p>On the other hand, cell projection approaches will benefit more from higher CPU speeds and improved graphics bus bandwidths since the rasterization is more expensive for our approach and we are-due to the greater amount of texture lookups-additionally limited by the internal memory bandwidth of the graphics adapter. Furthermore, although we can exploit early ray termination, with our approach the total number of fragments can be higher since more fragments might be generated per pixel than the depth complexity of the mesh requires. In contrast to this, cell projection guarantees to rasterize exactly the front faces of all cells.</p><p>Texture memory is a crucial limitation of our approach since all mesh data for a dataset has to fit into the local memory of the graphics adapter in order to allow for interactive visualizations. However, memory resources on graphics adapters are also increasing but may not keep up with the size of the datasets to be visualized. In summary, our approach is of particular interest for visualizing small, possibly cyclic, convex meshes with high opacities, e.g., due to opaque isosurfaces.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Ray propagation: For each pixel one viewing ray is traced, which stops at all intersected cell faces. The initial intersections are marked with dots (•), further intersections with circles (•), squares ( ), and diamonds ( ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>still within the mesh: (a) compute exit point for current cell (b) determine scalar value at exit point (c) compute ray integral within current cell (d) blend to frame buffer (e) proceed to adjacent cell through exit point</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Nomenclature in this paper: (a) The vertex v t,i is opposite to and the face normal n t,i is perpendicular to the i-th face of cell t. For tetrahedral cells i is 0, 1, 2, or 3. (b) The neighbor a t,i of cell t shares the i-th face. (c) Face indices f t,i of t's neighbors: The i-th face of t corresponds to the f t,i -th face of t's neighbor a t,i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>A non-convex FE-dataset consisting of 124 K tetrahedra is rendered with a three-dimensional pre-integration lookup table implementing a volume density-emitter model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>with the scalar value s f at the entry point, the scalar value s b at the exit point, and the length l of the ray segment. Apart from the transfer functions τ(s) and c(s),C and α depend only on s f , s b , and l; thus, one three-dimensional texture is sufficient for a table lookup of these integrals. As this lookup table has to be updated whenever the transfer functions τ(s) or c(s) are modified, an efficient evaluation of Equations(3)and(4)is critical for many volume visualization applications.Here we present incremental pre-integration, which is one of the most efficient acceleration techniques for the computation of lookup tables forC =C(s f , s b , l) and α = α(s f , s b , l) according to Equations (3) and (4). Variants of this technique were developed independently by several researchers<ref type="bibr" target="#b2">[Guthe 2002</ref>] but, to our knowledge, have not been published previously. Splitting of a ray segment of length l into two parts of length ∆l and l , respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(6) Note thatC(s f , s b , 0) and α(s f , s b , 0) are 0 for all s f and s b , and that C(s f , s b , ∆l) and α(s f , s b , ∆l) have to be calculated by a numeric evaluation of the integrals in Equations (3) and (4).</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Raytracing Irregular Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1990 Workshop on Volume Visualization</title>
		<meeting>the 1990 Workshop on Volume Visualization</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="35" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">High-Quality Unstructured Volume Rendering on the PC Platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schieber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics / SIGGRAPH Workshop on Graphics Hardware &apos;02</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="119" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Architecture for Interactive Tetrahedral Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Wittenbrink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wolters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Volume Graphics</title>
		<editor>K. Mueller and A. Kaufman</editor>
		<meeting>the International Workshop on Volume Graphics</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="163" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Implementing Ray Casting in Tetrahedral Meshes with Programmable Graphics Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization and Interactive Systems Group at the University of</title>
		<meeting><address><addrLine>Stuttgart</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Ray Tracing on Programmable Graphics Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Purcell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGGRAPH 2002</title>
		<meeting>ACM SIGGRAPH 2002</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="703" to="712" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Performance Optimization Techniques for ATI Graphics Hardware with DirectX 9</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Riguer</surname></persName>
		</author>
		<ptr target="http://mirror.ati.com/developer/techpapers.html" />
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hardware-Accelerated Volume and Isosurface Rendering Based On Cell-Projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="109" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Smart Hardware-Accelerated Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procceedings of EG/IEEE TCVG Symposium on Visualization VisSym &apos;03</title>
		<meeting>ceedings of EG/IEEE TCVG Symposium on Visualization VisSym &apos;03</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Hardware-Based View-Independent Cell Projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Procceedings of IEEE Symposium on Volume Visualization</title>
		<meeting>ceedings of IEEE Symposium on Volume Visualization</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hardware-Based View-Independent Cell Projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Special Issue on IEEE Visualization</title>
		<imprint>
			<date type="published" when="2002-04" />
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="163" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Volume Density Optical Model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="61" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Visibility Ordering Meshed Polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">R-Buffer: A Pointerless A-Buffer Hardware Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Wittenbrink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Graphics Hardware</title>
		<meeting>Graphics Hardware</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="73" to="80" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
