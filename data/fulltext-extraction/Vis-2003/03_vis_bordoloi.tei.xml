<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Space Efficient Fast Isosurface Extraction for Large Datasets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Udeepta</forename><forename type="middle">D</forename><surname>Bordoloi</surname></persName>
							<email>bordoloi@cis.ohio-state.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
							<email>hwshen@cis.ohio-state.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Seattle, Washington</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Space Efficient Fast Isosurface Extraction for Large Datasets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: I.3.6 [Computer Graphics]: Methodology and Techniques Isosurface</term>
					<term>Compression</term>
					<term>Transform Coding</term>
					<term>Quantization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper, we present a space efficient algorithm for speeding up isosurface extraction. Even though there exist algorithms that can achieve optimal search performance to identify isosurface cells, they prove impractical for large datasets due to a high storage overhead. With the dual goals of achieving fast isosurface extraction and simultaneously reducing the space requirement, we introduce an algorithm based on transform coding to compress the interval information of the cells in a dataset. Compression is achieved by first transforming the cell intervals (minima, maxima) into a form which allows more efficient compaction. It is followed by a dataset optimized non-uniform quantization stage. The compressed data is stored in a data structure that allows fast searches in the compression domain, thus eliminating the need to retrieve the original representation of intervals at run-time. The space requirement of our search data structure is the mandatory cost of storing every cell id once, plus an overhead for quantization information. The overhead is typically in the order of a few hundredths of the dataset size.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Isosurfacing is one of the most popular methods for visually representing volumetric scalar fields. The effectiveness of isosurface visualization is, however, limited to a large extent by the interactivity of the visualization environment. The scope for interaction lies in two orthogonal components: isovalue (isosurface extraction phase) and view parameters (rendering phase). The usefulness of the visualization system is severely restricted if either the extraction or the rendering cannot be performed at interactive speeds.</p><p>Over the past few years, the sizes of the datasets being visualized using isosurfaces (among others techniques) have grown at an extraordinary rate. Consequently, achieving interactive speeds for the isosurface extraction phase has become progressively more and more challenging. Researchers have proposed a variety of isosurface-containing-cell 1 search techniques to expedite the process of isosurface extraction. These algorithms are motivated by the fact that given an isovalue, the volume needs to be searched for the cells that contain the isosurface. By pre-computing searchfriendly data structures, these techniques reduce the time needed to search for those cells at run-time. Some techniques approach the problem as a search in geometric-space. Others, commonly known as value-space methods, search the space of intervals 2 . In this paper, we present a value-space algorithm.</p><p>A number of algorithms have been designed based on the concept of value-space. These algorithms achieve nearly optimal <ref type="bibr" target="#b9">[Livnat et al. 1996]</ref> or optimal <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref> speeds for the cell search phase. However, they suffer from one significant disadvantage: the storage requirement for the pre-computed search data structures. With very large datasets (such as the visible human dataset) becoming commonplace, the high storage overhead associated with these search structures is a serious deterrent to their use. For example, <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref> states that the space requirement of Interval trees is four times the number of cells in the dataset. The Interval tree data structure for a 512 3 floating point dataset (512MB) will need more than 2036MB for storage. The large space complexity renders these techniques ( <ref type="bibr" target="#b5">[Giles and Haimes 1990]</ref> <ref type="bibr" target="#b12">[Shen and Johnson 1995]</ref> <ref type="bibr" target="#b9">[Livnat et al. 1996]</ref> <ref type="bibr" target="#b13">[Shen et al. 1996]</ref> <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref>) practically unusable without outof-core modifications. Moreover, the algorithms are slowed down considerably because a large amount of time is spent on file I/O.</p><p>With the primary objective of fast isosurface extraction, we propose a compression-based solution intended to alleviate the problem of bloated search data structures. The extremal information (minimum and maximum) of the cells is compacted using a form of compression referred to as transform coding. We propose a computationally inexpensive transform of the conventional <ref type="bibr">[minimum, maximum]</ref> representation of intervals 2 to a more compression friendly format. A traditional non-uniform quantizer is used to quantize the transformed data. We introduce a search algorithm to perform the isosurface search directly on the transformed representation. This eliminates the need for a decoding step to revert the data back to their original values. The search algorithm can be easily modified to do an incremental search, or to run outof-core. We are able to reduce the size of the search data structures almost three-fold compared to those used by ISSUE and Interval trees. The compression technique presented provides a storage friendly yet efficient solution for large dataset isosurface extraction. The trade-off between storage requirements and the speed of the search process can be exploited to suit the available storage resources and the performance demands of the visualization environment.</p><p>Since <ref type="bibr" target="#b10">[Lorensen and Cline 1987]</ref> proposed the Marching Cubes algorithm for constructing isosurfaces in 1987, a number of techniques have been proposed to speed up the search for isosurface containing cells. Active list <ref type="bibr" target="#b5">[Giles and Haimes 1990]</ref>, Span Filter <ref type="bibr" target="#b4">[Gallagher 1991]</ref>, Sweeping Simplices <ref type="bibr" target="#b12">[Shen and Johnson 1995]</ref>, and Octrees <ref type="bibr" target="#b14">[Wilhelm and Van Gelder 1992]</ref> are a few of the early methods. The first three are value-space based methods, while the ever popular octree is a geometric-space technique utilizing hierarchical spatial subdivision. <ref type="bibr" target="#b8">[Itoh and Koyamada 1995]</ref> (extrema graphs) and <ref type="bibr" target="#b0">[Bajaj et al. 1996]</ref> (seed cell set) use isosurface propagation techniques to avoid the need to search all the cells intersected by the isosurface. Propagation in unstructured grids needs adjacency information to be stored, which increases the storage. Below, we mention three value-space algorithms which are most related to our technique.</p><p>In 1996, <ref type="bibr" target="#b9">[Livnat et al. 1996]</ref> introduced the span space representation for intervals in a near optimal algorithm (NOISE). The span space is a two-dimensional space of intervals with the x-axis and y-axis representing minima and maxima respectively. Each cell can be depicted as a point in the span space with the coordinates (minimum, maximum). The span space is subdivided using a kdtree, where each node divides the space into two partitions. The subdivision is alternated between a partitioning of the minima-axis and the maxima-axis at even and odd levels. The ISSUE algorithm by <ref type="bibr" target="#b13">[Shen et al. 1996</ref>] employs a lattice-based subdivision of the span-space. Sequential and parallel algorithms are presented for performing a search over the lattice elements. <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref> proposed an optimal search algorithm using Interval trees. Each node of the tree divides the intervals into three groups: the intervals whose maxima are less than the value of the node, those whose minima are greater than the node value, and the third set which contain the node value in between their extrema. The first group of intervals are passed onto the left child, the second to the right child, and the third group is put into two sorted lists associated with the node. Next, we discuss the storage requirements of NOISE, ISSUE and Interval trees.</p><p>Let us assume that there are N cells in the dataset, and the identity of each cell (cell id) is stored as a number that requires c bytes. Also, suppose that each data value requires d bytes. A pointerless kd-tree, as used in NOISE, stores the information {cell id, minimum, maximum} once for each cell. The space requirement is thus (c + 2d)N. In ISSUE, all the lattice elements (except those intersected by the minimum = maximum line) store two data structures. Row is a list of {cell id, maximum} pairs sorted by the cell maxima. The Column list comprises of {cell id, minimum} sorted by cell minima. Each cell in a lattice element contributes once to both Row and Column structures. So, the space needed is (c+d)2N, plus overhead. Each node of Interval trees stores two sorted lists: A L and DR. A L is an ascending list of left extremes, i.e., of {cell id, minimum} pairs, and DR is a descending list of right extremes, i.e., of {cell id, maximum} pairs. Ignoring the tree overhead, the space needed is (c + d)2N. If cell ids are stored as 4-byte (one word) integers and data values as 4-byte floats, then the space requirement of NOISE, ISSUE, and Interval trees is respectively 3N, 4N and 4N words. For a 512 3 floating point dataset (512MB), for instance, N = 511 3 and 4N words occupy 2036MB.</p><p>In the case of large datasets, which are common nowadays, the high storage requirement severely restricts the usability of these algorithms. This has prompted researchers to propose modifications so that large datasets can be used with these algorithms. <ref type="bibr" target="#b3">[Cignoni et al. 1997</ref>] presents a 3D chess-board arrangement for regular grids to reduce the number of cells the interval tree stores. Cells are colored using a chess-board pattern, and only cells having black color are used to construct the interval tree. <ref type="bibr" target="#b1">[Chiang and Silva 1997]</ref> proposed the first out-of core isosurfacing technique in the form of an I/O optimal implementation of the interval tree. Later, <ref type="bibr" target="#b2">[Chiang et al. 1998</ref>] introduced a method to efficiently group individual cells into meta-cells. They construct an interval tree using the meta-cells instead of individual cells. Both the chess-board and the meta-cell techniques lower the space requirement by reducing the number of cells stored in the search data structures. Our algorithm achieves the same goal through efficient space utilization combined with compression of cell <ref type="bibr">[maximum, minimum]</ref> information. The compression method used is based on transform coding. If desired, the cell reduction techniques mentioned above (chess-board and/or metacell) can be incorporated into our algorithm to further decrease the search structure size. Let the effective number of cells (individual cells, or black cells in the chess-board pattern, or meta-cells) be N.</p><p>In an uncompressed form, the {cell id, minimum, maximum} information requires 3N words. Using transform coding, we compress the {minimum, maximum} information to a few hundredths of N words. The total space requirement of our method is thus one and a few hundredths of N words, as opposed to 4N words in <ref type="bibr" target="#b5">[Giles and Haimes 1990]</ref> <ref type="bibr" target="#b12">[Shen and Johnson 1995]</ref> <ref type="bibr" target="#b13">[Shen et al. 1996]</ref> <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref>.</p><p>Transform coding is a well known data compression approach, and has an extensive body of literature. The basic principle utilized by transform coding is that multiple dimensions of vector data are often correlated to a lesser or higher degree. (If the input data is scalar, multiple samples are collected to form a vector.) The redundancy of data values (due to correlation) is exploited for compression by transforming the vector data and then quantizing each scalar dimension. The transformation allows a better compaction of the data compared to the untransformed values. The best compression ratios are achieved if the transformed data dimensions are not statistically correlated. <ref type="bibr" target="#b7">[Hotelling 1933</ref>] presented the first transform to de-correlate discrete data in the method of principal components. Karhunen and Loéve derived the analogous transform for continuous functions, which is now popularly known as the K-L transform <ref type="bibr" target="#b11">[Sayood 2000</ref>] <ref type="bibr" target="#b6">[Gray and Neuhoff 1998</ref>]. One of the most widely used transform coding applications today is the discrete cosine transform (DCT), which is a part of many image and video coding standards, e.g., JPEG, MPEG etc. For a more detailed review of transform coding and quantization, the reader is referred to <ref type="bibr" target="#b11">[Sayood 2000]</ref> and <ref type="bibr" target="#b6">[Gray and Neuhoff 1998</ref>].</p><p>In the ensuing sections, we present our compression based algorithm for fast isosurface extraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Transform coding for intervals</head><p>A number of isosurface extraction algorithms have been developed to perform the search for cells in the value space, i.e., the space of [minimum, maximum] intervals of cells. The minima-maxima space, however, is not suitable for compression due to the high statistical dependence between the minimum and maximum values of cells (see figure 1). To reduce this dependence, we use a linear transform to transform this space into a new space (which we will refer to as the UV-space). This transformation is the first stage of our compression algorithm. Sections 3.1 and 3.2 discuss this step in greater detail. In the UV-space, each cell (or equivalently, each interval) is represented by its u-and v-coordinates. These coordinates are quantized using a dataset distribution optimized non-uniform quantizer. We use a companded quantizer, which simulates the non-uniform quantization process using a uniform quantizer. While choosing the output values of the quantizer, quantization errors are taken into account. This ensures that the isosurface search does not miss any cell that contains the isosurface. The quantization process is described in section 3.3. The compressed information (in the form of uv-coordinates) is then stored in a search friendly data structure, which is presented in section 4.1. At run-time, the search algorithm finds the cells for isosurface extraction based on the supplied isovalue. The search process is explained in section 4.2.</p><p>In the following sections, we give some background on transform coding, followed by details of the transform and quantization phases of our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Background</head><p>The central theme of transform coding is that the input data is modified, using a reversible transform, to another form which can be better quantized. The quantized data can then be converted back to the original form using the reverse transform. For the following discussion, we represent a multi-dimensional input data sample as the vector x. There are three stages in transform coding:</p><p>1. Transform: The input data x is transformed into y using a reversible transform A, where y = Ax. The transformation A is selected such that y has better compression characteristics than x, i.e., given a fixed distortion, compressing y yields a smaller output than that of x. Or, given a fixed compression rate, y has lower distortion compared to x. The best compression results are achieved when the data dimensions are uncorrelated. This suggests that the ideal transform for compaction is the method of principal components. This step by itself does not result in any compaction of the data, which is achieved by the next two steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Quantization:</head><p>The transformed data y is then quantized to a finite number of levels. Each dimension of the data can be quantized independently using different quantization strategies. The number of quantization levels depends on the desired amount of compaction. The statistics of the data y influence the design of the quantizer. For example, appropriate uniform or non-uniform quantizers can be chosen depending on input data properties and desired output statistics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Encoding:</head><p>The quantized data is then passed through a binary encoding stage (e.g., Huffman or arithmetic coding). This results is the final compressed form of the data.</p><p>Constructing a compression scheme thus boils down to three tasks: finding an appropriate transform, designing quantizers based on the desired compression ratio and error limit constraints, and selecting a proper binary encoder. The data decoding process consists of inverting the effects of the first and third stages above. The second stage is lossy, and that information cannot be recovered. The compressed data is passed through a matching binary decoder, and then an inverse transform A −1 is applied to recover the data in the original form.</p><p>For the problem we are concerned with, the input data is a set of two-dimensional points which represent the [minimum, maximum] intervals of cells. In the rest of section 3, we propose a suitable transformation for the intervals, and then design a quantization scheme for the two transformed axes. Since our primary goal is fast isosurface extraction, we do not use any binary encoding stage. Such a stage would necessitate a decoder during the cell search phase, which would slow it down and defeat the primary purpose of this paper. However, if the situation so demands, a binary encoder can be easily applied as the third stage of encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Transform</head><p>The best compression rates can be attained if we use a transformation which statistically de-correlates the minima and the maxima <ref type="bibr" target="#b11">[Sayood 2000</ref>]. Hence, the ideal choice for a transformation is the method of principal components. However, it is very expensive to compute, specially for large datasets, which makes it a very impractical choice. Instead, we use a simpler transformation based on <ref type="figure">Figure 1</ref>: A histogram plot of the difference between maximum and minimum values in the visible woman dataset. The x-axis represents the difference, and the y-axis shows the number of cells which have that difference. The y-axis is shown in a log 10 scale. In this dataset, the largest difference is 2978, but 90% of cells have a difference less than 163. the following observation: it is usual for the minima and maxima of the cells to be highly correlated. That is, cells with higher maxima tend to have higher minima and vice versa. <ref type="figure">Figure 1</ref> shows a histogram plot of the difference between maximum and minimum values in the visible woman dataset. As can be expected, the vast majority of cells have a very small difference between their maxima and minima.</p><p>Consider a two-dimensional space in which the x-axis represents the cell minima and the y-axis represents the maxima (span space in <ref type="bibr" target="#b9">[Livnat et al. 1996]</ref>). Since the cells tend to distribute themselves along the minimum = maximum line, the principal component of any dataset will have an orientation close to the minimum = maximum line. So, instead of the exact principal component transformation, we use a transformation to the 45 • line. (Note that the transformation can be interpreted as rotation of the coordinate frame). Each interval is represented as a vector</p><formula xml:id="formula_0">x = minimum maximum (1)</formula><p>The transformation is given by</p><formula xml:id="formula_1">A = cosθ sinθ −sinθ cosθ<label>(2)</label></formula><p>where θ = 45 • . After the transformation, each interval is represented by the vector</p><formula xml:id="formula_2">y = u v = Ax<label>(3)</label></formula><p>Or,</p><formula xml:id="formula_3">u v = 1 √ 2 1 1 −1 1 minimum maximum<label>(4)</label></formula><p>We reduce the computational expense of the transform by removing the multiplication present in equation (4). This can be viewed as a scaling of both components of y, or equivalently as the use of a different system of units. Hence, this does not affect the compression results. Defining</p><formula xml:id="formula_4">y = Bx = ( √ 2A)x<label>(5)</label></formula><p>we get</p><formula xml:id="formula_5">u = maximum + minimum (6) v = maximum − minimum<label>(7)</label></formula><p>Each cell is represented as a point with coordinates (u, v) in the uv frame, which is obtained by a counter-clockwise rotation of the  <ref type="formula" target="#formula_5">7</ref>. The u-v frame is obtained by a counter-clockwise rotation of the original min-max frame by 45 • , followed by a scaling by √ 2. The isosurface passes through the cells in the shaded region.</p><p>original min-max frame by 45 • , followed by a scaling with √ 2 (figure 2). We will refer to the two-dimensional space represented by the u-v frame as the UV-Space. Note that, u can be thought of as twice the mid-point of the interval, and v is the range of the interval.</p><p>Using the equations (6) and <ref type="formula" target="#formula_5">7</ref>, the interval minimum and maximum can be expressed as</p><formula xml:id="formula_6">minimum = (u − v)/2 (8) maximum = (u + v)/2<label>(9)</label></formula><p>The cells which contain the isosurface satisfy the following condition: minimum &lt; isovalue &lt; maximum</p><p>For simplicity, we have assumed minimum = isovalue = maximum. From equations (8), (9) and (10), we can derive the following condition for a cell which intersects the isosurface</p><formula xml:id="formula_8">v &gt; | u − isovalue × 2 |<label>(11)</label></formula><p>In figure 2, any cell lying inside the shaded region (defined by equation (11)) will be intersected by the isosurface. In addition to permitting better compression rates, the transformation given by equations (6) and (7) also has other advantages. First, it requires very little computation in the form of a couple of additive operations. An inverse transformation is not needed: the isosurface test can be done in the transform domain using equation <ref type="formula" target="#formula_8">11</ref>. Moreover, the transformed space lends itself to a simple and efficient search data structure, which we will present in section 4. As will be evident, we will need to store only one sorted list of cells, as opposed to two sorted lists in most algorithms ([ <ref type="bibr" target="#b5">Giles and Haimes 1990]</ref> <ref type="bibr" target="#b12">[Shen and Johnson 1995]</ref> <ref type="bibr" target="#b13">[Shen et al. 1996]</ref> <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Quantization</head><p>Quantization of the UV-space is performed in two phases: first, the u-axis is quantized, followed by a quantization of the v-axis. For both axes, we use data distribution optimized non-uniform quantization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Companded Quantization</head><p>After the transformations given by equations (6) and <ref type="formula" target="#formula_5">7</ref>, let the minimum u value for the dataset be u L , and the maximum u value be u R . We want to quantize the range [u L , u R ] into M intervals, where M is input by the user. The design of the quantizer involves deciding the following two sets of values:</p><formula xml:id="formula_9">• Decision Boundaries: The M + 1 endpoints {b i } M</formula><p>i=0 of the M intervals. We already have b 0 = u L , and</p><formula xml:id="formula_10">b M = u R . • Reconstruction Levels: The M representative values {r i } M i=1 for each interval.</formula><p>The quantizer function, Q(•), is given by</p><formula xml:id="formula_11">Q(u) = r i iff b i−1 &lt; u ≤ b i<label>(12)</label></formula><p>Since the distribution of cells in along the u-axis can be (and usually is) non-uniform, we will use a non-uniform quantization strategy. Specifically, we will use an approach called Companded Quantization <ref type="bibr" target="#b6">[Gray and Neuhoff 1998</ref>] <ref type="bibr" target="#b11">[Sayood 2000</ref>], which simulates a distribution optimized non-uniform quantizer. A compander has three stages:</p><formula xml:id="formula_12">1. Compressor:</formula><p>The input values (u coordinates of cells) are mapped into another value (say, u ) such that the output (u ) is uniformly distributed. The regions of the input which have high density are stretched, while regions with low density are compressed. The mapping conserves the ordering of the input values, i.e., if</p><formula xml:id="formula_13">u i &lt; u j , then u i &lt; u j .</formula><p>The concept is the same as that used in image equalization.</p><p>2. Uniform Quantizer: The output of the compressor stage (u ) is quantized into M levels using a uniform quantizer. The decision boundaries of this quantizer are {b i } M i=0 , and the reconstruction values are</p><formula xml:id="formula_14">{r i } M i=1 .</formula><p>3. Expander: The quantized u values are mapped back to the u-axis using an expander function, which inverts the warping introduced by the compressor function. The compander decision bounds {b i } M i=0 are derived from {b i } M i=0 , and the reconstruction levels</p><formula xml:id="formula_15">{r i } M i=1 are obtained from {r i } M i=1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Quantization of u-axis</head><p>For the first phase, the user specifies the number of quantization intervals, M, of the u-coordinates. We implement the compressor stage by sorting the cells by their u-coordinates. If the u-values of two cells are equal, we break the tie using cell ids. The position of a cell in the sorted sequence is used as its u value for the uniform quantizer. The first n M = N/M cells are quantized into the first interval, the next n M cells in the second interval and so on. The decision boundaries, {b i } M i=0 , of the uniform quantizer are the sequence positions of the extreme (the first, and the last) cells of the intervals. The expander stage involves mapping the {b i } M i=0 values to the u-axis using an inverse of the compressor stage. Let the uvalue of the jth cell (in the sorted sequence) be u j , and let η = n M . Then the compander decision boundaries, {b i } M i=0 , are defined as</p><formula xml:id="formula_16">b 0 = u L b 1 = (u η + u η+1 )/2 b 2 = (u 2η + u 2η+1 )/2 . . . . . . . . . b M = u R<label>(13)</label></formula><p>We have assumed that</p><formula xml:id="formula_17">{u i•η = u i•η+1 } M−1 i=1 .</formula><p>If that does not hold, we take b i as the average of the u-values of the next two satisfying cells. <ref type="figure" target="#fig_1">Figure 3 shows</ref>   i=0 are given by equation <ref type="formula" target="#formula_16">13</ref>. For the given isovalue, the reconstruction levels are given by equation <ref type="formula" target="#formula_20">14</ref>: r 1 = b 1 ,..., r 6 = b 6 , r 8 = b 7 ,..., r 11 = b 10 . r 7 is not used by the search algorithm. The M = 11 partitions of the UVspace will be referred to as U-partitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UV-space into</head><formula xml:id="formula_18">M = 11 partitions {P i } 11</formula><p>i=1 , which we will refer to as the U-partitions.</p><p>Unlike usual quantization procedures, the definition of the reconstruction values {r i } M i=1 is deferred till run-time. To avoid holes in the isosurface due to quantization errors, we need to incorporate the isovalue into the assignment of</p><formula xml:id="formula_19">{r i } M i=1 .</formula><p>Consider the cells A and B in the U-partition P 4 in figure 3, where the value u iso = 2 × isovalue lies in U-partition P 7 . Both will have the same quantized u-coordinate r 4 , which will be used at run-time for the isosurface test in equation <ref type="formula" target="#formula_8">11</ref>. If cell B fails the test, the resulting isosurface will have a hole in it. To prevent any potential isosurface cell from failing the test, we have to ensure that the right-hand side of the inequality (v &gt;| u − isovalue × 2 |) does not increase as a result of quantization. Hence, we choose the reconstruction level to be the greatest u-coordinate any cell in partition P 4 can take. This happens to be the right decision boundary of P 4 , and so we take r 4 to be equal to b 4 . For the same reasons, cells C and D in partition P 11 are assigned the reconstruction value r 11 = b 10 . Note that cells A and D will satisfy equation (11) and will be sent to the geometry extraction phase, which will simply ignore them. For the partition P 7 , which contains the value u iso , all the cells are presumed to have passed the test. We define the reconstruction levels in terms of the stored decision boundaries and the given isovalue using the following formula: assuming b iso−1 &lt; isovalue × 2 ≤ b iso</p><formula xml:id="formula_20">r 1 = b 1 . . . . . . . . . r iso−1 = b iso−1 r iso = not required r iso+1 = b iso . . . . . . . . . r M = b M−1<label>(14)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Quantization of v-axis</head><p>After the quantization of the u-axis, we proceed to the second phase of our algorithm. We quantize the v-axis in each partition</p><formula xml:id="formula_21">{P i } M i=1</formula><p>of the UV-space separately. The quantization strategy is similar to that used for the u-coordinates. The user specifies the number of quantization levels, L, for each U-partition. The following actions are then performed for each partition  <ref type="figure">Figure 4</ref>: Quantization of v-axis. After the u-axis has been quantized using M = 11, the v-axis is quantized separately into L = 7 levels for each U-partition {P i } 11</p><formula xml:id="formula_22">P i (i = 1...M).</formula><p>i=1 . The v-axis reconstruction levels, which are also the decision boundaries, are shown as the horizontal lines, and the values are calculated from equation <ref type="formula" target="#formula_23">15</ref>. The L = 7 intervals of each U-partition will be referred to as UV-partitions.</p><p>initially sorted by their v-values, breaking ties by cell ids. The first n L = n M /L cells are put in the first interval, the next n L cells in the second interval and so on. Unlike the quantization stage of uaxis, we do not prevent cells with the same v-values from being put into different intervals. We do so to ensure that each interval contains the same number (n L ) of cells. As a result, we do not have to explicitly store the number of cells in each interval in our data structure.</p><p>In the previous discussion on quantizing the u-axis, we argued the need to prevent quantization errors which might result in holes due to isosurface-containing cells being indicated otherwise. In the isosurface test (v &gt;| u − isovalue × 2 |, equation <ref type="formula" target="#formula_8">11</ref>), this translates to the requirement that the v-value should not decrease after quantization. Accordingly, for each interval, the highest v-value of its member cells is used as the reconstruction level for that interval. Let the v-value of the kth cell (in the sorted sequence) in the U-partition P i be v ik . Then, the reconstruction values, {s il } L l=1 are given by <ref type="figure">Figure 4</ref> shows the quantization of v-coordinates after the u-axis has been quantized (with M = 11, as shown in <ref type="figure" target="#fig_1">figure 3)</ref>. Each Upartition has been further divided by L(= 7) horizontal lines, which represent the reconstruction levels (also the decision boundaries) of the v-values within the U-partition. We will call the resulting rectangular regions UV-partitions. The UV-partitions which are to the left of the U-partition P 7 are represented by the uv-coordinates of their top-right corners. Similarly, those to the right of P 7 are represented by the uv-values of their top-left corners. For the given isovalue, the shaded UV-partitions pass the isosurface test as their representative corners satisfy equation (11).</p><formula xml:id="formula_23">s i1 = v i(n L ) s i2 = v i(2n L ) . . . . . . . . . s iL = v i(Ln L )<label>(15)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Search Algorithm</head><p>Following the transform coding steps outlined in the previous section, we construct data structures which store the information of the UV-space in a compressed form (section 4.1). These can then be used for fast isosurface extraction searches (section 4.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Data Structures</head><p>The preprocessing stage of our algorithm consists of the transformation and quantization steps that have been mentioned in sections 3.2 and 3.3 respectively. The results of the preprocessing stage are stored in appropriate data structures that enable a fast run time search for isosurface containing cells. The information that needs to be stored is: the user-specified quantization parameters M and L, the reconstruction levels for the u-and v-axes, and the cell ids in each UV-partition. We use the data structures given below to store that information:</p><p>1. U-Array: The decision boundaries {b i } M i=0 for the u-axis, given by equation <ref type="formula" target="#formula_16">13</ref>. These values are required at run time to derive the reconstruction levels for u-coordinates according to equation <ref type="formula" target="#formula_20">14</ref>. The storage required is the space for M + 1 values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">V-Array:</head><formula xml:id="formula_24">A two-dimensional array {d i j } M,L i=1, j=1</formula><p>with each element storing the v-axis reconstruction levels of the corresponding UV-partition given by equation (15). For example, d i j stores the decision boundary of the jth UV-partition of the ith U-partition. This needs a storage of ML values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ID-Array:</head><formula xml:id="formula_25">A two-dimensional array {A i j } M,L i=1, j=1</formula><p>with each element storing the ids of cells in the corresponding UVpartition. A(i, j) stores the cells within the jth UV-partition of the ith U-partition. The storage needed is that for N cell ids.</p><p>The total storage requirement is the space needed for N cell ids and ML + M + 1 quantization levels, where ML + M + 1 is typically of the order of a hundredth of N. This offers significant space reduction compared to most algorithms ( <ref type="bibr" target="#b5">[Giles and Haimes 1990]</ref> <ref type="bibr" target="#b12">[Shen and Johnson 1995]</ref> <ref type="bibr" target="#b13">[Shen et al. 1996]</ref> <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref>), which store 2N cell ids and 2N min-max values. During preprocessing, the three arrays are filled simultaneously through the quantization process described in section 3.3. To recap, each cell is transformed to uv-coordinates using equations (6) and (7). They are then sorted by their u-coordinates and the quantization interval endpoints {b i } M i=0 derived using equation <ref type="formula" target="#formula_16">13</ref>. The cells are then grouped into M Upartitions. The cells in each U-partition are now sorted by their vvalues. For each U-partition i, the V-array elements (v-axis decision bounds) are filled in according to equation (15). Simultaneously, ids of cells in each UV-partition are stored in the ID-Array.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Search</head><p>Given an isovalue, the search for isosurface containing cells over the UV-space can be decomposed into separate searches over each U-partition. For a given U-partition, the search can be thought of as a search for satisfying UV-partitions (because all the cells within a given UV-partition have the same quantized uv-values). The Upartition is traversed in order of decreasing v-coordinates, beginning with the topmost UV-partition (the one with highest v-value).</p><p>The reconstruction values of the UV-partition are read from the U-Array and the V-Array, and tested in equation (11). If the UVpartition satisfies the isosurface test, all the cells in the corresponding ID-Array position are selected for geometry extraction, and the search moves to the next UV-partition (the one below). When a UV-partition is reached whose uv-coordinates fail equation <ref type="formula" target="#formula_8">11</ref>, the traversal for the current U-partition is terminated and the another U-partition is taken up for traversal. The search is complete when all the U-partitions have been individually searched.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Incremental Search</head><p>If the isovalue is changed by a small amount from the previous isovalue, it is advantageous to do an incremental update to the results of the previous search. We assume that the previous isovalue search results for each U-partition are stored. For each U-partition, we also need to remember the position of last UV-partition accessed before the traversal was terminated. Let the previous isovalue be iso p . Without any loss of generality, let us assume that the isovalue has increased to a new value iso n . Let the corresponding u-axis points be u p = 2 × iso p and u n = 2 × iso n respectively. Then the addition of new cells and removal of cells no longer intersecting the isosurface are handled as follows: 1. Addition: New cells will be added to U-partitions that are to the right of u mid = (u p + u n )/2. For these U-partitions, we start an incremental search from the previous terminating UV-partition. The current traversal is continued till a UVpartition is reached which does not satisfy the isosurface condition (equation <ref type="formula" target="#formula_8">11</ref>). The cells of the newly traversed UVpartitions are added to the isosurface extraction list.</p><p>2. Removal: For U-partitions to the left of u mid , we will need to potentially remove cells which were selected for isosurfacing for the previous isovalue. Each U-partition is traversed upwards (towards increasing v-values), starting from the terminating UV-partition of the previous traversal. The upward traversal is stopped when a UV-partition is reached which satisfies the isosurface test. The UV-partitions encountered during this reverse traversal no longer contain the isosurface and are removed.</p><p>The U-partition which contains u mid can belongs to the addition category if the previous terminating UV-partition satisfies the isovalue. Otherwise, it is in the removal set. As in any incremental update search, this is more beneficial in case of small datasets, for which the intermediate results can be stored in main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Errors</head><p>The quantization of the UV-space introduces errors which may result in false conclusions for some cells in the isosurface test (equation (11)). We have designed our quantizer (section 3.3) such that the search does not miss any cell that contains the isosurface. Instead, some cells that do not truly intersect the isosurface will satisfy equation <ref type="formula" target="#formula_8">11</ref>. The errors are the combined effect of u-value quantization error and the v-axis quantization error. Below, we give an empirical discussion on the average effect of the u-axis quantization on the number of such erroneous cells. For this discussion, we first assume that the v-values are not quantized. Later, we will extend the error analysis to include the v-coordinate quantization. Consider the U-partition P i in <ref type="figure" target="#fig_2">figure 5(a)</ref>, which is to the left of u iso = 2 × isovalue. In other words, b i &lt; 2 × isovalue. Due to quantization of u-coordinates, all the cells within the shaded triangular region will satisfy the isosurface test, and will constitute the error for this U-partition. Each U-partition that is searched will contribute a similar group of erroneous cells. It should be noted that if the top-most UV-partition of a U-partition fails the isosurface test, it will not be traversed at all and hence will not contribute any error. For instance, in figure 4, the U-partitions P 1 , P 2 and P 3 will not have any error since the topmost UV-partitions lie outside the isosurface region. In practice, the dynamic range of u-values is usually much higher than the spread of v-values. As a result, a large number of U-partitions will not be traversed and so will not contribute any error. For this discussion, we assume that on an average, a fraction h of the total number M of U-partitions is traversed. Let the average width of a U-partition be u ave , and the mean concentration of cells be c ave . Then, on an average, each U-partition will contribute (u 2 ave /2)c ave false cells. If the u-value limits for the dataset are [u L , u R ], then the average number of cells which falsely satisfy equation <ref type="formula" target="#formula_8">11</ref>is</p><formula xml:id="formula_26">Average U-Error = hM( u 2 ave 2 • c ave ) = (u R − u L ) 2 hc ave 2M<label>(16)</label></formula><p>Next, the additional effect of v-coordinate quantization is considered. In <ref type="figure" target="#fig_2">figure 5(b)</ref>, all the cells in the UV-partition V i j have the same uv-coordinates (b i , s i( j+1) ), and thus all satisfy equation <ref type="formula" target="#formula_8">11</ref>. The triangular region contains cells which incorrectly satisfy the isosurface test due to u-axis quantization errors. The error added by v-axis quantization are those cells in the UV-partition V i j whose v-coordinates are less than v i = 2 × isovalue − b i . If the total number of cells in the dataset is N, and M and L are the number of quantization levels for u-and v-axes respectively, then each UVpartition has n L = N/ML cells. On an average, the total number of erroneous cells due to v-coordinate quantization is</p><formula xml:id="formula_27">Average V-Error = hM • n L 2 = hN 2L<label>(17)</label></formula><p>5 Results and Discussion</p><p>In this section, we first discuss the effect of the quantization parameters M and L on the size and search efficiency of the search data structures. We then present out-of-core results from our algorithm and also compare the performance with that of the interval tree. We have tested our algorithm on the UNC MR-brain dataset (256 × 256 × 109 2-byte integer), a Rayleigh-Taylor hydrodynamic instability dataset (256 3 floating-point) which we will refer to as Rage256, and the visible woman dataset (512 × 512 × 1728 2-byte integer).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Compression and Errors</head><p>We have mentioned before that either the meta-cell technique <ref type="bibr" target="#b2">[Chiang et al. 1998</ref>] or the chess-board method <ref type="bibr" target="#b3">[Cignoni et al. 1997]</ref> can be used with our algorithm. For the following discussion, we will denote the number of effective cells (single cells, meta-cells, or black cells in the chess-board pattern) by N. The space requirement of our search data structure is the storage for N cell ids (ID-Array)   and ML + M + 1 quantization levels (U-Array and V-Array). Since we are not compressing the cell ids, the space required to store the ID-Array will remain constant for all quantization parameters. We present the compression results as the ratio of the size of the U-Array and V-Array to the space required for storing the min-max values for every cell. <ref type="figure" target="#fig_4">Figure 6</ref> shows the compression ratios for the MR-brain dataset. Interval trees and ISSUE data structures store 2N cell ids and N min-max pairs. Compared to these, the storage required by our search data structure is 37.1% for MR-brain, 27.4% for Rage256, and 33.4% for visible woman dataset for a (M = 4000, L = 400) quantization. <ref type="figure" target="#fig_5">Figure 7</ref> shows the variation of error with L and M. The error is due to cells which are selected by the search algorithm but do not contain the isosurface. Please note that there is no error in the isosurface itself. The error is defined as the ratio of the erroneous cells to the number of isosurface containing cells. As expected, the error decreases with increase in both L and M. Note that the rate of decrease falls as L or M get larger. Keeping in mind the trade-off between search and space efficiencies, users can choose an (M,L) combination suitable for their requirements. For instance, the very little difference between performance of the M = 2000 and M = 4000 graphs may not justify the associated increase in storage space. <ref type="table" target="#tab_2">Table 1</ref> gives the preprocessing, search and extraction times for the MR-brain dataset for a subset of quantization parameters from figures 6 and 7.  <ref type="table">Table 2</ref>: Search and extraction times for the visible woman dataset using a compression of 3.27% of the min-max values. The size of the search data structure is 34.5% of the size of the ISSUE/Interval-Tree data structures. 2 × 2 × 2 meta-cells are used while constructing the search data structures. The number of isosurface containing meta-cells are given, along with the error introduced by quantization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance</head><p>In case of large datasets, the search data structures may not fit into main memory and out-of-core techniques have to be implemented. Because we store the min-max information and the cell ids in separate data structures, we do not need to modify our search algorithm for large datasets. Only the U-Array and the V-Array need to be kept in-core. During the search phase, the V-Array is scanned as described in the search algorithm (sec.4.2). If the uv-coordinates stored at a V-Array position pass the isosurface test, the corresponding ID-Array entry is read from the disk and the cells passed to the extraction stage. <ref type="table">Table 2</ref> shows the search and extraction times for the visible woman dataset. For this experiment, we have used a 2 × 2 × 2 meta-cell for constructing our data structure. The error (number of meta-cells selected due to quantization error) is given as a percentage of the isosurface meta-cells, given in the second column. The data-structure I/O times are included in the extraction times. The compression ratio of min-max information is 3.27% for the data structures used. The size of the search data structure is 34.5% of the size of the ISSUE/Interval-Tree data structures. <ref type="table">Table 3</ref> compares the size and performance of our algorithm to an in-core interval tree implementation on a MIPS R10000 Processor. We present results for a floating-point MR-brain dataset and the Rage256 dataset for both methods. The interval tree search performs marginally better than the search using compressed min-max values. The search data structures of our algorithm are smaller by a factor of four or more compared to the interval tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Future Work</head><p>We have presented a data structure for speeding up isosurface extraction using transform coding techniques. Significant reduction is achieved in terms of the space requirement of the search structures, without compromising the search speed. In the future, we want to extend the compression to cell ids to further reduce the size of the search structure, and to extend the algorithm to time-varying data.  <ref type="table">Table 3</ref>: Comparison of search times for the quantized search (QS) and the interval tree (I-Tree). The compression ratios for the minmax data are given in parentheses.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>UV-Space. The UV-space is a two-dimensional space of intervals. Each cell is represented as a point with coordinates(u, v)   defined by the equations (6) and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Quantization of u-axis. The u-axis is divided into M = 11 levels. The decision boundaries {b i } 11</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Quantization Errors. All the cells in the shaded triangular region in figure (a) satisfy the isosurface test and contribute to the error due to quantization of u-axis. The error that is added to this by v-axis quantization is shown in figure (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Effect of Quantization parameters M and L on data structure size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Effect of Quantization parameters M and L on search error for the MR-brain (isovalue = 1070.5, number of isosurface cells = 4352196).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>the quantization of u-coordinates with M = 11. The vertical lines at the decision boundaries {b i } 11 i=0 divide the</figDesc><table><row><cell>v−axis</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>P1</cell><cell>P2</cell><cell>P3</cell><cell>P4</cell><cell>P5</cell><cell>P6</cell><cell>P7</cell><cell cols="2">P8 P9</cell><cell>P10</cell><cell>P11</cell></row><row><cell></cell><cell></cell><cell></cell><cell>B</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>A</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>C</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>D</cell></row><row><cell>b0</cell><cell>b1</cell><cell>b2</cell><cell>b3</cell><cell>b4</cell><cell>b5</cell><cell cols="2">b6 b7 b8</cell><cell>b9</cell><cell cols="2">b10 b11</cell></row><row><cell></cell><cell></cell><cell cols="2">u−axis</cell><cell></cell><cell cols="3">isovalue*2</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Search and space efficiency trade-off. Processing times on a 600MHz PIII for different (M,L) combinations are shown (isovalue = 1070.5). The extraction time for a zero search error is 7.41s. The associated compression and errors are shown in figures 6 and 7.</figDesc><table><row><cell cols="2">M,L 500, 50 2000, 200 4000, 400 11.42% 0.44% Comp-Error ression 0.18% 2.33% 2.86% 0.66%</cell><cell cols="2">Pre-process 11.03s 11.40s 11.50s</cell><cell>Search Extract 0.04s 7.48s 0.03s 7.44s 0.03s 7.43s</cell></row><row><cell>Isovalue 600.5 1100.5 1400.5</cell><cell cols="2">Cells 2,066,710 4.39% Error 4,433,023 4.28% 809,193 9.47%</cell><cell>Search Extraction 0.05s 13.0s 0.12s 27.7s 0.04s 6.1s</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">We use the term cell while referring to the smallest volumetric element in a three-dimensional grid. For regular grids, a cell represents the same entity as a voxel. For unstructured grids, a cell may be a tetrahedron, prism, or any other polyhedron. Our method can be used for datasets on either structured or unstructured grids.2 Interval here refers to the[minimum, maximum]  interval of a cell.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>This research was supported in part by NSF grant ACR 0118915, NASA grant NCC-1261, Ameritech Faculty Fellowship and Ohio State Seed Grant. We thank the anonymous reviewers for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Fast isocontouring for improved interactivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>IEEE Computer Society Press</publisher>
			<biblScope unit="page" from="39" to="46" />
			<pubPlace>Los Alamitos, CA</pubPlace>
		</imprint>
	</monogr>
	<note>Symposium for Volume Visualization</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">I/O optimal isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;97</title>
		<meeting>Visualization &apos;97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="293" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactive out-of-core isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;98</title>
		<meeting>Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="293" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Speeding up isosurface extraction using interval trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="158" to="170" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Span filter: An optimization scheme for volume visualization of large finite element models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Advanced interactive visualization for CFD</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Giles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Systems in Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="51" to="62" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Neuhoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Quantization. IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="2325" to="2383" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Analysis of a complex of statistical variables into principal components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hotelling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Educational Psycology</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="498" to="520" />
			<date type="published" when="1933" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automatic isosurface propagation using an extrema graph and sorted boundary cell lists</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="319" to="327" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using the span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1996-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Introduction to Data Compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sayood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Morgan Kaufmann Publishers, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sweeping simplices: A fast isosurface extraction algorithm for unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;95</title>
		<meeting>Visualization &apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="143" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Isosurfacing in span space with utmost efficiency (ISSUE)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;96</title>
		<meeting>Visualization &apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="287" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
