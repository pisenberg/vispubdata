<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ViSlang: A System for Interpreted Domain-Specific Languages for Scientific Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Rautek</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Bruckner</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Eduard</forename><surname>Gröller</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Hadwiger</surname></persName>
						</author>
						<title level="a" type="main">ViSlang: A System for Interpreted Domain-Specific Languages for Scientific Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/TVCG.2014.2346318</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Domain-specific languages</term>
					<term>Volume visualization</term>
					<term>Volume visualization framework</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Researchers from many domains use scientific visualization in their daily practice. Existing implementations of algorithms usually come with a graphical user interface (high-level interface), or as software library or source code (low-level interface). In this paper we present a system that integrates domain-specific languages (DSLs) and facilitates the creation of new DSLs. DSLs provide an effective interface for domain scientists avoiding the difficulties involved with low-level interfaces and at the same time offering more flexibility than high-level interfaces. We describe the design and implementation of ViSlang, an interpreted language specifically tailored for scientific visualization. A major contribution of our design is the extensibility of the ViSlang language. Novel DSLs that are tailored to the problems of the domain can be created and integrated into ViSlang. We show that our approach can be added to existing user interfaces to increase the flexibility for expert users on demand, but at the same time does not interfere with the user experience of novice users. To demonstrate the flexibility of our approach we present new DSLs for volume processing, querying and visualization. We report the implementation effort for new DSLs and compare our approach with Matlab and Python implementations in terms of run-time performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Domain-specific languages (DSLs) offer increased expressiveness compared to general purpose programming languages and higher flexibility compared to graphical user interfaces at low computational overhead. By abstracting the details of the computer soft-and hardware, the user can focus on the relevant (i.e., domain-specific) problems. The cost of learning new DSLs pays off for the user if the language is focused enough to avoid code that is not related to the actual domain, and if at the same time the language is expressive enough to solve the relevant problems. Domain-specific languages are especially well-suited in situations where the low-level software APIs and the high-level domain problems are far apart in syntax and semantics. Scientific visualization in general is a good target for employing DSLs for exactly these reasons. For instance, the implementation of a feature extraction and rendering algorithm requires a lot of knowledge and code to arrive at even a basic setup. This basic setup (that is not specific to the actual algorithm) includes data loading, initialization and state manipulation of the graphics processing unit, as well as the windowing system. The actual algorithm is only a small portion of the code. Even more severe is the gap between parallel hardware programming and high-level domain problems. A domain scientist is ideally not confronted with the complexity of programming highly parallel hardware (e.g., graphics processing units). At the same time experts need access to the processing power of GPUs and need the flexibility to combine multiple visualization algorithms to answer specific questions. GPUs are a powerful, cost-effective and widely available data processing infrastructure. General purpose computing languages that are executed on the GPU, like CUDA and the open standard OpenCL, expose the computing power for all kinds of applications. Although many domain scientists are knowledgeable in programming, the parallel nature of GPUs bears additional challenges that often require in-depth knowledge in computer science and software engineering. Therefore, the programming of GPUs is usually done by computer scientists or knowledgeable software developers. DSLs can address the large gap between low-level programming and high-level problems using abstraction of algorithms. The low-level problems are hidden by the high-level DSL allowing a larger audience to make use of the underlying computing infrastructure.</p><p>In this paper we present a system that lowers the cost of developing novel DSLs. Further it integrates multiple DSLs in one solution to leverage their flexibility. <ref type="figure">Figure 1</ref> gives an overview of our design. ViSlang is a library and an execution environment with an extension mechanism. By integrating it into a visualization system the runtime can execute commands and thereby modify the behavior of the visualization system. The ViSlang runtime acts as the unified programming interface to the user. DSLs that extend ViSlang are called slangs. User input is executed by the ViSlang interpreter and commands that start with the keyword using are forwarded to the corresponding slang. In the example of <ref type="figure">Figure 1</ref>, the user writes a small program that makes use of the slang renderer. The slang renderer offers a DSL that allows to map data properties to visualization properties. A function updateRendering is declared and a trigger is defined that executes the function whenever the value of the variable x is changed. At the right of <ref type="figure">Figure 1</ref> the user tries different values for variable x, leading to interactive updates of the visualization. The example of <ref type="figure">Figure 1</ref> gives an overview of the ViSlang runtime system. In practice multiple DSLs are used in conjunction to combine data processing and visualization modules going beyond the functionality of the individual algorithms. ViSlang currently focuses on processing and visualization of static volumes. This is not a restriction of the system design but of its current implementation. However, one of the major design goals of ViSlang is its extensibility and other data structures can be added over time.</p><p>The major contribution of this paper is a language and system design that addresses the major risks and challenges of DSLs while preserving their benefits as listed by Van Deuresen et al. <ref type="bibr" target="#b36">[37]</ref>. Specifically we address the following issues with our design:</p><p>Extensibility: ViSlang can integrate multiple domain-specific languages, addressing the issue that one DSL is not expressive enough for all problems across all domains that make use of visualization. With this approach we anticipate that algorithms address different aspects of visualization with concise yet expressive languages. We show that a procedural DSL is well suited for querying volumes, while a declarative DSL is well suited for the configuration of a visualization algorithm. Further, we propose a combination with a functional DSL to compute certain statistics of the data. Implementation Overhead: We show that ViSlang keeps the implementation overhead for a new DSL low by using recurring patterns. Elements of the grammar can be reused, thereby reducing the effort to parse, analyze, and execute a new DSL. Data structures optimized for parallel algorithms can be reused to enable parallel execution without the low-level issues of GPU programming. We argue that the implementation overhead for new DSLs is small and that the benefits outweigh the costs. To further reduce the overhead of integrating a new DSL with ViSlang we provide a meta-language that instantiates templates to create new slangs.</p><p>Low-Level vs. High-Level Programming: Algorithms that are executed in parallel are generally harder to program than sequentially executed programs. It is desirable to offer an easier interface to these algorithms for non experts. In many cases critical parts of algorithms can be formulated independently of the semantics of parallel execution. These parts can be made accessible to inexperienced programmers using a DSL. We show an implementation of a parallel mapreduce algorithm. The mapping function is exposed as a DSL while the complexity of the implementation of the parallel reduction is hidden. We describe the implementation of a rendering algorithm and a logical query language. Both algorithms hide the low-level details of the parallel execution and offer a high-level programming interface.</p><p>Compatibility: All these challenges are addressed, maintaining compatibility to existing user interface concepts. We demonstrate how to add DSLs without changing existing interfaces. This offers increased flexibility on demand for expert users.</p><p>In this paper we first review related work in Section 2. We describe a set of slangs that demonstrate the different kinds of DSLs in Section 3. The extension mechanism and the meta-language are described in Section 4. The integration of reusable data structures that are optimized for parallel execution is described in Section 5. We discuss how implementation overhead is reduced and present runtime measurements in Section 6. The description of data types, and statements in ViSlang that are tailored for visualization, as well as the general control flow are described in Appendix A of the supplemental material. The ViSlang grammar in EBNF is given in Appendix B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Several approaches are commonly used to address the complexity of low-level interfaces for facilitating abstraction. For instance, software libraries are low-level interfaces that offer abstractions of algorithms and data structures. However, they require a lot of programming experience, and are not natively integrated in run-time environments. To allow a user to manipulate certain aspects of a visualization system at run-time, several approaches have been used. Turn-key user interfaces are a simple mechanism that enables the manipulation of parameters. They are frequently used due to the ease of implementation. However, they limit the flexibility of the user to certain parameter settings. Data flow systems encapsulate software modules and expose them to the user in a graphical user interface. Using the drag and drop metaphor, networks of data flows are specified connecting different modules. Our approach was inspired by the observation that the common visual programming approach of data flow systems tends to oversimplify the situation. It is not possible for the user to try variations of the algo-rithms by implementing the configurable parts of the software. This leads to systems that are not flexible enough for the user to take full advantage of the available visualization algorithms. <ref type="figure">Figure 2</ref> shows the different levels of run-time interfaces of a visualization application and the corresponding target user group ordered by increasing level of expertise.</p><p>The novice user gets an application that is pre-configured for classical turn-key interaction. The data flow interface is used by more advanced users that re-configure the application at run-time. The expert user profits from increased flexibility, and might use interfaces on all three levels. Typically, only expert programmers have the skills to modify existing source code and to reuse low level libraries.  <ref type="bibr" target="#b14">[15]</ref> targets computational fluid dynamics applications. It is conceptually similar to our approach as it presents a system with an interpreter supporting the rapid development of new visualization components. Computationally expensive components are written in C, while the rapid prototyping functionality is offered to the user at run-time using Scheme as a programming language. We follow a similar approach but integrate support for the creation of entirely new DSLs that can execute on parallel hardware.</p><p>Johnson and Huang <ref type="bibr" target="#b16">[17]</ref> present a declarative DSL for specifying feature classes and for deriving statistical matches of these classes. Their language is a good example for a concise yet powerful DSL.</p><p>Chiw et al. <ref type="bibr" target="#b5">[6]</ref> describe Diderot, a domain-specific language for image analysis and visualization. The language is tailored to the rapid prototyping of algorithms that are executed on parallel hardware. The language includes support for concepts and notations well known from tensor calculus. This high level of abstraction allows the programmer to write tensor operations using familiar notation. The authors demonstrate that the program runs very efficiently, although it is specified with high-level concepts. Hašan et al. <ref type="bibr" target="#b12">[13]</ref> present Shadie, a domain-specific (Python like) language that is translated to CUDA kernels. The run-time handles data loading, and parameters are automatically passed to the CUDA kernels. The recent work of Choi et al. <ref type="bibr" target="#b6">[7]</ref> presents Vivaldi, a DSL inspired by Shadie. It supports execution on distributed GPU architectures. McCormick et al. <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> and Jablin et al. <ref type="bibr" target="#b15">[16]</ref> present Scout, a high-level hardware accelerated language. Scout programs are compiled at run-time and executed on the GPU, hence omitting the complexity of parallel programming and still profiting from a highly parallel architecture. Stockinger et al. <ref type="bibr" target="#b33">[34]</ref> present a framework for efficient evaluation of range queries. Queries are specified by the user as logical combinations of range selectors for large multivariate data. The queries that define the interesting parts of the data are evaluated and the results are visualized.</p><p>Ragan-Kelley et al. <ref type="bibr" target="#b30">[31]</ref> present Halide, a domain-specific language for image processing pipelines. By separating algorithmic code from code that optimizes the execution, a concise language is presented that executes fast on parallel hardware.</p><p>Each of these approaches is focused on one specific aspect of the data analysis and visualization pipeline. The work of Johnson and Huang <ref type="bibr" target="#b16">[17]</ref> focuses on distributions of certain properties, Diderot <ref type="bibr" target="#b5">[6]</ref> on tensor calculus, Shadie <ref type="bibr" target="#b12">[13]</ref> on approximating the volume rendering integral, Scout <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref> on the visualization mapping, Halide <ref type="bibr" target="#b30">[31]</ref> and Vivaldi <ref type="bibr" target="#b6">[7]</ref> on efficient image and volume processing, and the work of Stockinger et al. <ref type="bibr" target="#b33">[34]</ref> on data selection by querying for data ranges. Unlike these approaches, we present a language design that generalizes the problem of integrating DSLs into visualization systems. We address the need for more than one domain-specific language in visualization with the extensibility of our language. This allows us to implement different slangs for different aspects of the visualization pipeline.</p><p>Duke et al. <ref type="bibr" target="#b8">[9]</ref> have used Haskell to integrate three different DSLs to solve a specific visualization problem with a functional programming language. They report on the benefits of employing multiple DSLs for scientific visualization in their work <ref type="bibr" target="#b9">[10]</ref>. Brown et al. <ref type="bibr" target="#b3">[4]</ref> present Delite, a framework to generate embedded DSLs that can execute on heterogeneous parallel hardware. They show OptiML as an example DSL for machine learning algorithms. We follow a similar idea and also suggest to generate and integrate novel DSLs in one common framework. However, we present a full system that integrates DSLs with a visualization environment and use an interpreted language to provide immediate visual feedback for the end user. Further, our framework does not require the DSLs to be embedded DSLs and has less restrictions on the syntax of new DSLs.</p><p>The usefulness of DSLs and abstraction of low-level implementation details in scientific visualization was previously also demonstrated on massively parallel clusters. The work of Glatter et al. <ref type="bibr" target="#b10">[11]</ref>, and Kendall et al. <ref type="bibr" target="#b18">[19]</ref> are noteworthy examples that demonstrate the advantages of DSLs as interfaces. Vo et al. <ref type="bibr" target="#b37">[38]</ref> present results of using a well known MapReduce framework for visualization. Although ViSlang is not meant to run on clusters, but rather on GPUs, it is similar as it separates low-level implementation details from high-level APIs using DSLs. However, unlike other work ViSlang focuses on the integration of multiple DSLs into one system and the support for creating new DSLs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Libraries and Data Flow Systems</head><p>Libraries and toolkits like VTK <ref type="bibr" target="#b32">[33]</ref>, and ITK <ref type="bibr" target="#b41">[42]</ref>, provide modules that can be re-purposed and combined to form more complex volume processing and visualization systems. Libraries are a common approach to offer modular and reusable software. In this aspect, they are similar to domain-specific languages. However, a library typically offers its functionality via a low-level interface that requires advanced software engineering skills. Lefohn et al. <ref type="bibr" target="#b20">[21]</ref> present Glift, a library of highly efficient, and reusable GPU data structures. It uses templates to offer generic data structures and algorithms similar to the Standard Template Library (STL).</p><p>The widely adopted data flow concept enables combination of existing modules in novel ways, and to extend the given functionality by integrating new modules. AVS <ref type="bibr" target="#b35">[36]</ref>, OpenDX <ref type="bibr" target="#b21">[22]</ref>, SCIRun <ref type="bibr" target="#b39">[40]</ref>, METK <ref type="bibr" target="#b26">[27]</ref>, Voreen <ref type="bibr" target="#b24">[25]</ref>, VisTrails <ref type="bibr" target="#b0">[1]</ref>, as well as the work of Rieder et al. <ref type="bibr" target="#b31">[32]</ref> are prominent examples for data flow frameworks.</p><p>Our approach is similar to the data flow concept, but can handle more complex interactions between different modules. By offering a common interface to all modules for the user, data can not only be passed from one module to the next but also be transformed by a userdefined program. We also believe that the programming interface is more natural and less cumbersome for programing certain parts of an application. Our approach also allows for a seamless integration with the data flow paradigm and offers a novel additional interface to the user.</p><p>Other frameworks like VisIt <ref type="bibr" target="#b4">[5]</ref> and ParaView <ref type="bibr" target="#b13">[14]</ref> incorporate a Python scripting interface. Scripting is a powerful tool to enable higher levels of flexibility for the expert users. The ViSlang runtime inherits these advantages of scripting interfaces. Additionally, ViSlang facilitates the easy integration of novel DSLs, each potentially more focused to one particular task than a general purpose language like Python.</p><p>The Dax Toolkit <ref type="bibr" target="#b25">[26]</ref> enables the combination of fine grained operations (worklets), which makes it particularly suitable for large scale computing. Unlike traditional module based data flow systems, worklets are combined before execution leading to less overhead and more parallelism. We employ a similar strategy and combine multiple user defined functions into one OpenCL kernel. This enables ViSlang to outperform other systems like Python and Matlab that call kernels sequentially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Interpreted Languages for Science</head><p>The high popularity and intensive usage of interpreter systems like R <ref type="bibr" target="#b29">[30]</ref>, Matlab <ref type="bibr" target="#b34">[35]</ref>, Mathematica <ref type="bibr" target="#b40">[41]</ref> and Python <ref type="bibr" target="#b27">[28]</ref>, shows that scientists from many domains are used to perform basic programming tasks. Recent work <ref type="bibr" target="#b11">[12]</ref> builds on top of Python and its many libraries for high-performance scientific computing and visualization. We propose an interpreted language that targets scientific visualization, and that addresses the specific needs of domain scientists to have access to advanced visualization, and parallel processing algorithms. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SLANGS</head><p>One of the main advantages of the ViSlang concept is that it enables the seamless integration of multiple programming paradigms in a common environment. For instance, for presentation and interaction, declarative approaches gained considerable popularity as they decouple specification and execution, and support retargeting. Well known examples include Cascading Style Sheets <ref type="bibr" target="#b38">[39]</ref> (CSS), or, more recently QML <ref type="bibr" target="#b28">[29]</ref>, the Qt Modeling Language, which provides a declarative interface to the popular Qt user-interface toolkit. Within the field of visualization, ProtoVis <ref type="bibr" target="#b1">[2]</ref> and its successor D3 <ref type="bibr" target="#b2">[3]</ref> have impressively demonstrated the advantages of declarative language designs. In signal and image processing, functional approaches are of particular interest as they offer a natural and efficient representation. They can represent data flow graphs in a direct manner and provide optimization opportunities such as lazy evaluation and easy data parallelism <ref type="bibr" target="#b17">[18]</ref>. Rendering algorithms, on the other hand, mostly lend themselves towards imperative languages due to the need for fine-grained control.</p><p>Our approach makes it possible to exploit the respective advantages of different paradigms in a single application through the combination of different slangs. In this section, we illustrate the power of ViSlang outlining three slangs that demonstrate the integration of different kinds of DSLs. The Volume Predicate slang described in Section 3.1 encapsulates the semantics of a logical query in subroutines. It is a procedural DSL for the specification of logical predicates that are executed in parallel and either yield true or false for each voxel. The Vlabel Visualization slang described in Section 3.2 is a declarative DSL for the specification of visualization styles. The Map-Reduce slang in Section 3.3 is a functional DSL. It is used to specify mapping functions that are passed as argument to one of the reduce functions.</p><p>From an end user perspective all DSLs are called from ViSlang. A slang block starts with the keyword using and ends with the end of input, or the using; instruction. The ViSlang parser forwards slang blocks to the specified slangs and waits until the commands are parsed. If the slangs report parser errors, they are presented to the user and interpretation is stopped. If parsing succeeds the execution phase starts. The commands are executed in order. When a slang instruction is reached the slang's execution interface is called and the slang takes the previously parsed commands and executes them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Volume Predicate Slang</head><p>The Volume Predicate slang abstracts the parallel evaluation of a 3D logical query. Predicates are defined as subroutines using mathemat-ical expressions and memory access functions for individual voxels. The subroutines are combined with the logical operators or, and, not. This slang is used to program queries that might be tailored to the application domain and the data sets under investigation. The result of a volume query is a binary volume, which is called vset in ViSlang.</p><p>In <ref type="figure" target="#fig_1">Figure 3</ref>, we show an example that combines multiple predicates defined by the user. At the top of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Vlabel Visualization Slang</head><p>The Vlabel Visualization slang implements a declarative language that takes data of type volume and a corresponding label volume (called vlabel in ViSlang) and performs ray-casting. It allows the user to specify different visualization styles and to assign particular labels to these styles. A style is specified using a very concise syntax controlling the weights of different colors, and other visual properties.</p><p>In the example of <ref type="figure" target="#fig_0">Figure 4</ref>, a predicate inRange is specified. It takes the two arguments fMin and fMax and returns true if the value of the voxel is in this range. <ref type="figure" target="#fig_0">Figure 4 (a)</ref> shows the predicate and the result after applying it. The predicate is transformed to an OpenCL program by the volume predicate slang. The colon symbol is used to call ViSlang's display function immediately after the statements are evaluated. As a result the vset renderer generates the parameter-less visualization of the vset by applying RGB colors to the normalized volumetric coordinates.</p><p>In <ref type="figure" target="#fig_0">Figure 4</ref> (b) a labeling algorithm is called to assign different labels to individual disconnected regions in the vset. Again the colon symbol is used to call the display function. The default visualization of the vlabel assigns a random color to each region. Using the DisplayVlabel slang, the style Selection is declared at the bottom of <ref type="figure" target="#fig_0">Figure 4 (b)</ref>. The declarations of other styles are similar and therefore omitted for brevity. <ref type="figure" target="#fig_0">Figure 4 (c)</ref> shows the code to specify the behavior of the system. A function appendToStyle is defined. The probe method of object DisplayVset is used to transform 2D image coordinates into 3D volumetric coordinates defined by the first hit of the ray. The label selectedLabel is retrieved as a 3D look-up in the vlabel data structure. The slang DisplayVlabel is used to assign the style to the region with  label selectedLabel. The last line of the code assigns a trigger to the variable Mouse.Position that executes the function appendToStyle every time the user clicks on the visualization. The image in <ref type="figure" target="#fig_0">Figure 4</ref> (c) is the visualization after the user assigned one style to multiple regions. By slightly modifying the appendToStyle function, the user can assign different styles to different regions. <ref type="figure" target="#fig_0">Figure 4 (d)</ref> shows the result after the user assigned five different styles: random coloring with specular highlights for the Christmas baubles, white with shading for the candles, red with shading for the decoration, brown with shading for the trunk of the tree, and yellow cartoon shading that shines through other objects for the figure in the middle of the image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Map-Reduce Slang</head><p>The Map-Reduce slang abstracts the parallel evaluation of a mapping function followed by a 3D reduction operation <ref type="bibr" target="#b19">[20]</ref>. The user specifies a function that maps voxel attributes of (multiple) input volume(s) to one output value. The mapping function is then passed to one of the predefined reduction operations addition, minimum, maximum or multiplication. With the Map-Reduce slang the user can quickly implement reduction operations that are executed on the GPU. Typical algorithms that can be implemented by the user include: counting all voxels that are true in a vset, or finding the maximum of all voxels in a vlabel. More complex mapping functions can be used to query for certain value ranges, for instance, to count voxels or to compute the centroid of a connected component with a specific id in a vlabel volume. For multiple input volumes, the computation of properties of intersections and unions is possible as well as performing more complex filtering operations. <ref type="figure" target="#fig_2">Figure 5</ref> shows an example of using the Volume Predicate, the Vlabel Visualization, and the Map-Reduce slang in conjunction. A 3D energy-dispersive X-ray spectroscopy (EDS) dataset is visualized. <ref type="figure" target="#fig_2">Figure 5 (a)</ref> shows the result of applying a volume predicate and using the labeling algorithm. The Map-Reduce slang is used to find the maximum region number (maxRegionLabel). <ref type="figure" target="#fig_2">Figure 5 (b)</ref> shows the visualization after styles for small, medium, and large regions as well as the background are declared (the code is similar to style declarations before and therefore omitted for brevity). At this point no styles are assigned to individual regions. Therefore everything is visualized in the background style. The mapping function countVoxels is used in conjunction with the sum reduction. <ref type="figure" target="#fig_2">Figure 5 (c)</ref> shows the reduction to compute the number of voxels per region. One of three visualization styles is assigned accordingly. The smallest regions are made transparent. Medium sized regions get a random color and large regions are assigned a yellow style. This example shows how multiple slangs are used to program a visualization that is tailored to a particular EDS dataset. The accompanying video features a similar setup that generates an animation during assignment of the visualization styles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXTENSION MECHANISM AND THE META-LANGUAGE</head><p>Although DSLs are extremely useful interfaces, they pose an additional burden on the application developer. Implementing a new slang technically is a matter of deriving a C++ class from ViSlang's slang class. However, developing a new DSL involves lexing, parsing, semantic analysis, abstract syntax tree (AST) transformations and interpretation. Additional features that are important for end users of the DSL are error reporting, debugging, syntax high-lighting, and performance optimization, just to name a few. Furthermore, DSLs for visualization are most useful when they abstract parallel algorithms. The need for a parallel execution environment introduces even more complexity for the DSL developer. In sum the additional work is often too costly and therefore DSLs are not as often employed as they would be useful.</p><p>To reduce the effort of implementing a new slang, the programmer can profit from using recurring patterns. ViSlang already incorporates a parser framework, a code generator and optimized GPU data structures that are used to manage GPU memory resources, share resources efficiently among slangs and apply optimizations. Since the ViSlang library aims to support a wide variety of visualization algorithms, we chose a set of libraries and an execution environment that are efficient, standardized, open, platform-and hardware independent, and suitable for parallel execution. The lexer and parser framework of ViSlang is Boost Spirit <ref type="bibr" target="#b7">[8]</ref>. Boost Spirit is used to define recursive descent parsers inlined in C++. Unlike other parser generators it omits an additional build step and therefore does not depend on external tools. As a parallel execution environment we found OpenCL to be a perfect match for ViSlang. It is a just-in-time (JIT) compiled language and therefore seamlessly integrates with our interpreter. Building on this software infrastructure we have identified three common patterns for the development of new slangs in ViSlang:</p><p>Parsing: We implemented recurring syntax concepts like expressions, lists, arguments, etc. on top of Boost Spirit. These concepts can be reused and repurposed with very low effort. For example when instancing the list syntax, any parser can be used as argument. Therefore, parsing of lists of any kind is implemented quickly. Syntax constructs can be combined with the well known parser operators sequence, not, and, optional, Kleene star, and plus. Although reusing this parser framework and existing grammar elements might tremendously reduce the effort to specify a new DSL, we do by no means enforce it. Alternatively, parsers can be generated with any other popular parser generator framework. Especially grammars and parsers of existing DSLs can be integrated without additional overhead.</p><p>OpenCL code generation: ViSlang implements classes for OpenCL code generation. By using OpenCL template files with a simple annotation syntax, an OpenCL algorithm can be abstracted with low effort. At run-time, code is injected into the template and the OpenCL program is generated. A DSL that generates and just-in-time compiles OpenCL programs, can benefit from implementing the OpenCLAlgorithm and Injector interfaces. When deriving from the OpenCLAlgorithm class, ViSlang handles OpenCL program compilation and offers extended debugging functionality. OpenCL template files and OpenCL programs can be inspected and modified at run-time. This greatly reduces the implementation effort for this pattern.</p><p>OpenCL data structures: By re-using the data structures that were optimized for sparse volumes, implementation effort can be greatly reduced. structs are offered for the different data structures that can be included in C++ and OpenCL. Setand Get-methods are used to transparently handle virtual memory management, address calculations, and on-the-fly memory allocation.</p><p>To even further reduce the effort of implementing a DSL, we developed a meta-language for the specification and generation of new slangs. A Slang is defined in terms of a name, a template, a set of parameters, a grammar, and a description. The meta-language automates some of the implementation work by instantiating templates. In order to avoid compromising the performance of a new DSL we create the parser and the execution code in C++ including OpenCL boilerplate code. For example the program in Listing 1 defines the new Slang Filter3D that is meant for the specification of a 3D filter kernel. It builds on the volume2volume template, meaning that OpenCL code is generated for volume processing. The Filter3D slang has the parameters kernelWidth, kernelHeight, anf kernelDepth. The end user will have access to these parameters via ViSlang. The grammar defines the syntax of the DSL. It consists of a list of parsers. In Listing 1 the parsers kernelFunction, functionName, arguments, argument, and expression are defined. The meta-language generates parsers and abstract syntax tree nodes accordingly.</p><p>1 // setting the parameters 2 Filter3D.kernelWidth = 5; 3 Filter3D.kernelHeight = 5; 4 Filter3D.kernelDepth = 5; 5 // using the DSL interface 6 using Filter3D; In the example of Listing 1 the kernelFunction is defined as a sequence (&gt;) of other parsers and a set of symbols ('(', ')', '=', and ';'). The meta-language supports the common parsers sequence, Kleene star, option, logical or, and all ViSlang parsers, the parsers that make up the ViSlang language. A slang created by the meta-language is compiled with a C++ compiler and automatically gets registered with the ViSlang system. At runtime it accepts user input according to its grammar. Listing 2 shows an example of user input that is accepted by the new Filter3D slang. The Filter3D slang parses the input, creates an abstract syntax tree and sets the parameters of the OpenCL kernel. To implement the execution phase the programmer has to transform the AST to executable code. This can be done by using the OpenCL code generation tools of ViSlang. AST nodes like function declaration, function call, arithmetic-and boolean expressions, while-, for-, if statements and literals generate OpenCL code. These features of ViSlang greatly reduce the cost of development for new DSLs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">VISLANG RUNTIME, MEMORY MANAGEMENT AND DATA STRUCTURES</head><p>The ViSlang runtime interprets the code by executing it sequentially. A memory manager keeps track of the allocated data structures and of the variables in scope. The variables are derived from one common class that supports linking and triggering of events. This not only allows the user to link variables and trigger events when a value changes, but also to link variables to a graphical user interface. When a new variable is declared an equivalent GUI element is created that is linked to the variable. An assignment of a new value to a variable causes a GUI update to be triggered and, likewise, manipulation of the GUI will trigger assigned ViSlang functions. The ViSlang library that includes the ViSlang runtime is largely separated from the rest of the visualization system and can be integrated with other systems written in C++. In fact our test environment and a console application that link to the ViSlang library do not make use of any visualization system, yet can be used to operate on volumes. Since the integration of rendering algorithms works differently in different systems, these parts were implemented specifically for one visualization system. Also the templates for the Meta-Language are specific to one system and need to be replaced when integrating with a different visualization system. ViSlang implements optimized data structures for parallel execution of algorithms in OpenCL. As an example of a managed data structure we describe vsets, an optimized data structure for storing and manipulating sparse binary volumes. Conceptually, vsets are volumes with each voxel representing a boolean value. This is a common case for many algorithms that try to extract higher level semantics from the data. The most prominent example are binary segmentation algorithms, but many other algorithms also need to keep track if voxels belong to a certain class.</p><p>To benefit from spatial coherence we use a bricking scheme where each vset is conceptually subdivided into independent volumetric bricks. All homogenous bricks are represented very efficiently with only one value. Inhomogeneous bricks (with at least one entry being different from the others), are completely represented in memory, storing one bit for each voxel. The memory manager allocates memory from the graphics hardware for a pool of bricks. Each vset holds a list of indices into this memory pool. An empty vset is represented by a list of zeros and no memory is used from the brick pool. If an algorithm sets a bit in a given vset to true, the memory manager allocates an empty brick from the brick pool. This allocation is done at the run-time of the OpenCL program. The memory manager has a list of locks, to synchronize memory access to the bricks in the brick pool. Further, a list of empty bricks is held by the memory manager. A pointer into the list is required to keep track of the next empty brick to be allocated. <ref type="figure" target="#fig_5">Figure 6</ref> shows the brick pool of the memory manager and the allocations and deallocations during the life-cycle of several vsets. <ref type="figure" target="#fig_5">Figure 6 (a)</ref> shows the brick pool after the allocation of the three vsets orange, green, and violet. The vsets have lists that point to the brick pool. Zero as index of a vset means that the brick is empty, 1 means that each entry of the brick is set to true. The brick pool holds the memory for non-empty bricks of all allocated vsets starting with index 2. Between the memory layouts shown in <ref type="figure" target="#fig_5">Figure 6</ref> (a) and (b), the following events happened: vset violet sets all bits that previously were true to false in bricks 8 and 9. Since every brick contains a counter that keeps track of the number of bits that are set to true, this situation is detected and the entries into the brick list are updated to 0. The bricks 8 and 9 are marked for garbage collection. vset violet also sets bits to true in different bricks of the volume, and therefore new bricks (14 and 15) are allocated. vset orange allocates a new brick <ref type="bibr" target="#b15">(16)</ref>. vset green allocates brick 17, and all bits of the brick 3 of vset green are set to false, causing that it points to 0. Later in the same brick of vset green, bits are again set to true. The memory manager at this point does not know that the old brick is already free again and assigns a new brick with number 18. vset orange allocates new bricks <ref type="bibr">(19 and 20)</ref>. Three bricks of the brick pool (drawn in white) are not used, but cannot be allocated by the memory manager, because they are not in the list of empty bricks anymore. In <ref type="figure" target="#fig_5">Figure 6</ref> (c) the green and orange vsets are deallocated. Deallocation of a vset causes the memory manager to set all bits in all used bricks of the vset to false. After the allocation of a new vset (vset brown allocates bricks 21 to 26) in <ref type="figure" target="#fig_5">Figure 6</ref> (c), the memory manager detects a low memory situation (i.e., the number of free bricks is low). The garbage collector inserts the 14 bricks that are empty into the list of empty bricks. The result after garbage collection can be seen in <ref type="figure" target="#fig_5">Figure 6 (d)</ref>.</p><p>In our implementation a brick size of 32 <ref type="bibr" target="#b2">3</ref> is used, which results in 4 KB per brick. Additionally we store one integer per brick that keeps track of the number of bits that are set to true. A vset is represented by an array of integers, each holding an index of a brick. An empty vset of size w × h × d is efficiently represented by an array of size ceil(w/32) × ceil(h/32) × ceil(d/32). For instance a vset of dimensions 1024 <ref type="bibr" target="#b2">3</ref> is represented by 128 KB of memory. A typical example of a sparse vset with 10% of bricks being non-homogenous is represented with less than 13.2 MB of memory allowing for a large number of sparse vsets to be represented on modern graphics hardware.</p><p>The memory manager has an additional overhead that depends on the number of allocated bricks. The empty brick list contains one entry per brick. To guarantee thread-safe allocation of bricks (which is critical for OpenCL algorithms), the memory manager must store a lock for each brick represented as an integer in our implementation. For a memory pool of 1 GB, this requires in total 2 MB of additional storage plus 4 bytes for the head pointer of the empty list.</p><p>Vsets are an example of an optimized data-structure that is part of the ViSlang system. A new slang can benefit from these datastructures using their interfaces regardless of their low-level imple- mentation details. Although our implementation is currently limited to single GPU, in-core data structures for regular volumetric data, this is not a general limitation of our system. With vsets we demonstrate the separation of low-level implementation, mid-level re-useability for new DSLs and high-level programming for end users. In the future we will follow the same implementation patterns with data structures for other use cases in visualization like flow-data and time varying data. Although, it should be rather easy to compile and run our system on other platforms, so far we have tested ViSlang on Windows only. However, to avoid complications in the future we exclusively rely on C++, OpenCL, and portable libraries like Boost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Overhead of Algorithm Abstraction</head><p>In this section we attempt to estimate the overhead for the integration of an algorithm with ViSlang. To quantify the overhead we classified the additional lines of code that are required to implement a DSL and to integrate it into ViSlang. Obviously the overhead depends on the functionality of the slang and the complexity of the grammar. For the slangs presented in this paper the overhead is on the order of several hundred lines of code. A classification of the lines of code according to their primary functionality is shown in <ref type="table" target="#tab_4">Table 1</ref>. The additional C++ code is only a small fraction of the overall C++ code that is used to build the algorithms. We quantify the additional OpenCL code in absolute numbers and as a fraction of the total OpenCL code. The percentages are shown in the last row of <ref type="table" target="#tab_4">Table 1</ref>. The C++ code is reported in absolute numbers. All examples were created without the meta-language, giving an estimate for the (less frequent but) more general case that the DSL is written from scratch. For the common case that a new DSL makes use of the meta-language the lines of code are reduced dramatically. The ViSlang interface and parser code are generated entirely and the other C++ and OpenCL code can be greatly reduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Run-time Measurements</head><p>ViSlang strives to minimize the implementation turnaround time as well as the execution runtime for parallel algorithms. The typical turnaround time for setups without an interpreted language (like C++ with OpenCL) is on the order of tens of seconds to minutes. In this context, we define turnaround time as the total time from compiling a program to the visualization of the result. The turnaround time includes parsing, compiling, execution of the host language, just-in-time compilation of an OpenCL program, setup of kernels and memory objects, execution of the OpenCL algorithm, and visualization of the result. For instance, the typical turnaround time for the VolumePredicate and for the Map-Reduce slang is one second. In ViSlang this includes parsing and execution of the slang, OpenCL code generation and injection as well as the OpenCL just-in-time compilation. The turnaround time depends on aspects like the complexity of the algorithm, the userdefined program, the complexity of the set of parameters, and other factors. The dominant cost in ViSlang is OpenCL JIT compilation with about 90-95% of the total build time. However, a reduction of the total turnaround time to one second means a dramatic increase in productivity for the end user.</p><p>It is important to understand that just-in-time compilation only takes place on demand, i.e., when the DSL interface of a slang is used and the underlying OpenCL program has to be generated. Once the OpenCL code is generated it can be reused without recompilation. This is critical for data processing and rendering algorithms that are executed multiple times per second.</p><p>To quantify the overhead that is introduced by the abstraction layer of the algorithm, we measured the compilation and run-time for abstracted and hard-coded versions of three different algorithms. All measurements were done on a PC with 12 dual core 3. <ref type="bibr" target="#b32">33</ref>   <ref type="table">Table 2</ref>.</p><p>Comparison of abstracted with hard-coded algorithms. Columns from left to right: 1. algorithm, 2. just in time (jit) compile time for abstracted algorithm, 3.-8. run-times for abstracted (abst.) and hard-coded (hard.) algorithms for three different data sets. All numbers are in milliseconds.</p><p>In <ref type="table">Table 2</ref> we provide measurements for the algorithms a) the reduction operation max, b) thresholding a volume, and c) the vlabel rendering. The run-time comparisons are shown for three different datasets: spheres (128x128x128), christmas tree (512x499x512), and EDS Mag (1024x987x72). Algorithms a) and b) employ dynamic generation of OpenCL code. Therefore, JIT compilation times are much higher than for algorithm c). However, the run-time measurements for algorithms a) and b) show that the overhead of abstraction is very low (4-27 ms in our experiments). For the rendering algorithm c) we used an image size of 1024x1024 and a sample distance of one. The compilation for the rendering algorithm is much shorter since it only involves parsing, AST generation and execution in ViSlang and no OpenCL recompilation is required. At runtime the more costly abstraction layer of the rendering algorithm results in significantly lower performance. Comparing these cases clearly shows that there is a trade-off between compilation time and runtime. It is important to consider this trade-off for the implementation of new slangs in ViSlang and for interpreted DSLs in general.  <ref type="table">Table 3</ref>. Data processing rate in GB/s (higher is better).</p><p>To quantify the runtime performance of algorithms implemented in ViSlang we compared with the two frequently used interpreted languages Matlab and Python. <ref type="table">Table 3</ref> shows the average data throughput in GB/s that were measured for three different operations. The operations are: maximum reduction (max), map-reduce operation: identity mapping and maximum reduction (map-reduce), and a logical predicate (x &gt; 0)&amp;true (predicate).</p><p>The results clearly demonstrate the benefits of the flexibility of ViSlang's approach. While Matlab slightly outperforms ViSlang for the case of a simple maximum reduction, the more general map-reduce operation is much faster in ViSlang. Matlab has optimized vector operations that include typical reduction operations. In our map-reduce experiment we take the identity function as a mapping function, which is mathematically equivalent to performing the maximum reduction only. However, Matlab cannot make use of its set of optimized operations and therefore drops sharply in performance. In ViSlang the mapping function is automatically translated to OpenCL. Therefore, it results in a comparably small performance drop when used in a mapreduce operation. We get similar results for the logical predicate. Matlab slightly outperforms ViSlang when using a standard predicate like (x &gt; 0). When applying a logically equivalent predicate (x &gt; 0)&amp;true optimization is omitted and ViSlang outperforms Matlab.</p><p>Although all three languages are well suited for scientific applications, ViSlang is an integrated solution for visualization with parallel data processing allowing for high performance applications, increased flexibility, low turnaround times, and high data throughput. We argue that these benefits outweigh the cost of integrating new DSLs in ViSlang.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS AND FUTURE WORK</head><p>We have presented an interpreted language capable of including multiple DSLs. Each language can address a different aspect of the visualization pipeline or domain science. DSLs are realized as slangs of the main language, extending the functionality of the visualization system, and allow the user to program on a higher level of abstraction, oblivious of the implementation details of the underlying algorithms. This is especially beneficial for parallel algorithms. The increased implementation effort for the developer of a DSL is addressed with reusable components and the meta-language that is offered by the ViSlang system. GPU accelerated data structures are provided that are specialized for visualization algorithms resulting in high performance implementations. We showed that our approach is capable of integrating different programming paradigms. DSLs are not restricted to one syntax but are free to specify the most natural syntax for the problem domain. In our results we show that ViSlang offers short turnaround times, with interactive visual feedback, suitable for rapid prototyping of visualization applications with high runtime performance.</p><p>In the future, we want to experiment with the integration of existing DSLs like QML and D3 to offer support for a large body of user interaction methods and visualization algorithms. Further, we want to extend our managed data structures to deal with out-of-core algorithms. Exposing the out-of-core semantics via a DSL could benefit visualization experts that deal with the implementation of large data applications. The ViSlang system together with its collection of slangs will be made available as an open source project.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4 .</head><label>4</label><figDesc>using VolumePredicate; predicate distanceLess[voxel vox in v] (float x, float y, float z, float dist) { float d = (vox.x-x)*(vox.x-x) + (vox.y-y)*(vox.y-y) + (vox.z-z)*(vox.z-z); return (sqrt(d) &lt; dist); } predicate valueAbove[voxel vox in v] (float thresh) { return (vox.value&gt;thresh); } distanceLess(x, y, z, 64) &amp; ! valueAbove(0.5); valueAbove(0.5); Fig. 3. The two volume predicates distanceLess and valueAbove are used to extract two regions. The distanceLess predicate specifies a focus region. In combination with valueAbove two vsets are extracted. The combined result is shown as well as each vset with separate transfer functions. void appendToStyle(integer u, integer v){ list volumePos = DisplayVset.probe(u, v); selectedLabel = labelVolume.get(volumePos.get(0), volumePos.get(1), volumePos.get(2)); DisplayVlabel.setSelection(selectedLabel); } Mouse.clickPosition -&gt; appendToStyle(Mouse.getX(), Mouse.getY()); using DisplayVlabel: Selection{ color:100%(1.0,1.0,0.0,1.0), bordercolor:100%(0.0, 0.0, 0.0, 1.0), compositing:50% } vlabel labelVolume = Vlabel.label(vset1): using VolumePredicate; predicate inRange[voxel vox in v] ( float fMin, float fMax){ return ((vox.value&gt;=fMin)&amp;(vox.value&lt;=fMax)); } using; vset vset1 = VolumePredicate.inRange(0.12,1): ViSlang is used to program a visualization system that assigns visualization styles to different regions on mouse click. (a) shows the application of a declarative slang resulting in a segmentation of the volume. (b) shows the labeling of the individual regions and the declaration of visualization styles. (c) shows how mouse clicks trigger the assignment of visualization styles. (d) shows the result after several styles were assigned by the user.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3</head><label>3</label><figDesc>the predicates distanceLess and valueAbove are shown. The distanceLess predicate is true if the Euclidean distance between the voxel vox and a point in space (defined with the arguments x, y, z) is smaller than the argument dist. Combining the distanceLess predicate with the valueAbove predicate results in two vsets in this example. At the bottom of Figure 3 the result and the individual vsets are shown. Each vset as well as the remainder of the volume are jointly rendered with individual transfer functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>The Map-Reduce slang is used to efficiently compute the number of labels as well as the number of voxels in each region. In conjunction with the other slangs a visualization is programmed that assigns different styles to regions of different size. (a) shows the result after the individual regions are labeled. (b) shows the result after the styles are defined and the background style is applied to all regions by default. (c) shows the result after all regions were assigned a style.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>16 /</head><label>16</label><figDesc>/ a human readable description for the end user 17 description: ... Listing 1. Using the Meta-Language to define a new slang.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>7 f</head><label>7</label><figDesc>(float dx, float dy, float dz, float a, float s)= 8 a * exp(-1.0 * (dx * dx)+(dy * dy)+(dz * dz) * (1.0/2 * s * s)); Listing 2. Using the slang Filter3D to generate a 3D Gaussian filter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>The brick pool of the memory manager and the life-cycle of several vsets. Filled bricks are assigned to the vset of the corresponding color. Empty bricks are either ready to be assigned by the memory manager (blue) or used and waiting for garbage collection (other colors).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>•</head><label></label><figDesc>Peter Rautek is with KAUST, E-mail: peter.rautek@kaust.edu.sa. • Stefan Bruckner is with University of Bergen, E-mail: stefan.bruckner@uib.no. • M. Eduard Gröller is with Vienna University of Technology and VrVis Research Center, E-mail: meister@cg.tuwien.ac.at.</figDesc><table /><note>• Markus Hadwiger is with KAUST, E-mail: markus.hadwiger@kaust.edu.sa.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Fig. 1. System Overview: Slangs are DSLs that encapsulate a certain functionality and register it with the ViSlang runtime. The ViSlang runtime implements an embedded interpreter that executes programs in an interactive environment. The user interacts with an integrated program editor to issue ViSlang commands.</figDesc><table><row><cell></cell><cell>slangs</cell><cell></cell><cell cols="3">program editor</cell><cell>interactive interpretation and visualization</cell></row><row><cell cols="2">... ... renderer</cell><cell>vislang runtime</cell><cell cols="3">void updateRendering(float x) { // use slang renderer using renderer: focus = value &gt; x; using; } //assign trigger</cell></row><row><cell cols="2">resources</cell><cell></cell><cell cols="3">float x -&gt; updateRendering(x);</cell><cell>x = 0;</cell><cell>x = 0.05;</cell><cell>x = 0.1;</cell><cell>x = 0.2;</cell></row><row><cell cols="6">Manuscript received 31 Mar. 2014; accepted 1 Aug. 2014 ate of D .</cell></row><row><cell>publication</cell><cell>11 Aug.</cell><cell cols="2">2014; date of current version</cell><cell>9 Nov.</cell><cell>2014.</cell></row></table><note>For information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org.Digital Object Identifier 10.1109/TVCG.2014.2346318 8</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>2.1 Domain-Specific Languages for Visual Computing</head><label></label><figDesc></figDesc><table><row><cell>source code and libraries</cell><cell></cell><cell></cell><cell></cell><cell>expert programmer</cell></row><row><cell>turn-key systems data ow modules DSLs</cell><cell>exibility</cell><cell>required</cell><cell>experience</cell><cell>expert user novice intermediate</cell></row><row><cell cols="5">Fig. 2. Interfaces by increasing flexibility and user experience: Users</cell></row><row><cell cols="5">of different levels of experience get different views on an application.</cell></row><row><cell cols="5">Novice and intermediate users adapt parameters and combine mod-</cell></row><row><cell cols="5">ules with a graphical user interface. Experts program certain aspects of</cell></row><row><cell cols="4">modules (DSLs) or entirely new functionality.</cell><cell></cell></row><row><cell cols="5">Domain-specific languages have been extensively used in visual com-</cell></row><row><cell cols="5">puting for a long time. Graphics APIs like OpenGL and shader lan-</cell></row><row><cell cols="5">guages like HLSL, GLSL, Cg, etc. are low-level interfaces for pro-</cell></row><row><cell cols="5">gramming the graphics hardware of modern computer systems. These</cell></row><row><cell cols="5">APIs are used to modify the state and the data stored on the graphics</cell></row><row><cell cols="5">card. API calls initiate the graphics pipeline to process data prim-</cell></row><row><cell cols="5">itives and to compute pixel colors. Shaders are a good example of</cell></row><row><cell cols="5">widely used DSLs for programming parts of the graphics pipeline.</cell></row><row><cell cols="5">More recently general purpose computing languages, like CUDA and</cell></row><row><cell cols="5">OpenCL, are available that enable programming of graphics hardware</cell></row><row><cell cols="5">in a more flexible way. These languages are APIs for parallel com-</cell></row><row><cell cols="5">puting applications in the field of visual computing and beyond. As</cell></row><row><cell cols="5">they are low-level APIs they do not address the special needs of non-</cell></row><row><cell cols="5">experts. A large body of previous work addresses the gap between</cell></row><row><cell>low-and high-level APIs.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">For instance the work of Hultquist and Raible</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>// declare visualization styles 'Small', 'Medium', 'Biggest' using DisplayVlabel; ... // code omitted for brevity</figDesc><table><row><cell>(a)</cell><cell cols="2">(b)</cell><cell>(c)</cell><cell></cell></row><row><cell>// label individual volume regions // reduction for finding the maximum region id</cell><cell cols="2">// declare visualization styles 'Small', 'Medium', 'Biggest'</cell><cell cols="2">// iterate over all regions and assign a visualization style // iterate over all regions and assign a visualization style</cell></row><row><cell>vlabel labelVolume = Vlabel.label(vset1): // result (a) integer maxRegionLabel = 0;</cell><cell cols="2">using DisplayVlabel; ... // code omitted for brevity</cell><cell cols="2">for (integer i=0; i&lt;maxRegionLabel; i=i+1){ for (integer i=0; i&lt;maxRegionLabel; i=i+1){</cell></row><row><cell>// reduction for finding the maximum region id using Reduction;</cell><cell cols="2">// result (b) // declare reduction for counting voxels in a region</cell><cell>using Reduction; using Reduction;</cell><cell></cell></row><row><cell>integer maxRegionLabel = 0; integer getRegionLabel(uvoxel v) {</cell><cell cols="2">// declare reduction for counting voxels in a region using Reduction;</cell><cell cols="2">n = sum[uvoxel vox in l]countVoxels(vox, i); n = sum[uvoxel vox in l]countVoxels(vox, i);</cell></row><row><cell>using Reduction; return v.value;</cell><cell cols="2">using Reduction; integer countVoxels(uvoxel v, integer id) {</cell><cell>using; using;</cell><cell></cell></row><row><cell>integer getRegionLabel(uvoxel v) { }</cell><cell cols="2">integer countVoxels(uvoxel v, integer id) { if (v.value == id) { return 1; }</cell><cell cols="2">if (n&gt;2000) { DisplayVlabel.setBiggest(i); } if (n&gt;2000) { DisplayVlabel.setBiggest(i); }</cell></row><row><cell>return v.value; maxRegionLabel = max[uvoxel vox in l]getRegionLabel(vox);</cell><cell></cell><cell>if (v.value == id) { return 1; } return 0;</cell><cell cols="2">else if (n&gt;500) { DisplayVlabel.setMedium(i); } else if (n&gt;500) { DisplayVlabel.setMedium(i); }</cell></row><row><cell>}</cell><cell>}</cell><cell>return 0;</cell><cell>else { DisplayVlabel.setSmall(i); } else { DisplayVlabel.setSmall(i); }</cell><cell>} }</cell></row><row><cell>maxRegionLabel = max[uvoxel vox in l]getRegionLabel(vox);</cell><cell>}</cell><cell></cell><cell>// result (c)</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 .</head><label>1</label><figDesc>Examples of implementation overhead for DSLs in lines of code (loc). The last row shows additional OpenCL code as lines of code and as percentage of the total OpenCL code of the algorithm.</figDesc><table><row><cell>functionality</cell><cell cols="2">predicate (loc) renderer (loc)</cell><cell>map-reduce (loc)</cell></row><row><cell>ViSlang interface</cell><cell>112</cell><cell>114</cell><cell>161</cell></row><row><cell>code generation</cell><cell>383</cell><cell>0</cell><cell>171</cell></row><row><cell>parser</cell><cell>216</cell><cell>277</cell><cell>174</cell></row><row><cell>other C++</cell><cell>35</cell><cell>272</cell><cell>129</cell></row><row><cell>total C++</cell><cell>746</cell><cell>663</cell><cell>635</cell></row><row><cell>OpenCL / (%)</cell><cell>24 / (8%)</cell><cell>166 / (23%)</cell><cell>102 / (22%)</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The research presented in this publication was supported by the King Abdullah University of Science and Technology (KAUST) Visual Computing Center, and the ViMaL project (FWF -Austrian Science Fund, no. P21695).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Vistrails: Enabling interactive multiple-view visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Crossno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization 2005</title>
		<meeting>IEEE Visualization 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Protovis: A graphical toolkit for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1121" to="1128" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">D3 data-driven documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ogievetsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2301" to="2309" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A heterogeneous parallel framework for domain-specific languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sujeeth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rompf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Parallel Architectures and Compilation Techniques (PACT)</title>
		<meeting>International Conference on Parallel Architectures and Compilation Techniques (PACT)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="89" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">VisIt: An End-User Tool For Visualizing and Analyzing Very Large Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Childs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Brugger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Whitlock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ahern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pugmire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Biagas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fogal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sanderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Garth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bethel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Camp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Rübel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Durant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Favre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Navrátil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High Performance Visualization-Enabling Extreme-Scale Scientific Insight</title>
		<imprint>
			<publisher>Chapman and Hall/CRC</publisher>
			<date type="published" when="2012-10" />
			<biblScope unit="page" from="357" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Diderot: A parallel DSL for image analysis and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chiw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reppy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Samuels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2012 Conference on Programming Language Design and Implementation (PLDI &apos;12)</title>
		<meeting>the ACM SIGPLAN 2012 Conference on Programming Language Design and Implementation (PLDI &apos;12)</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="111" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Vivaldi: A domain-specic language for volume processing and visualization on distributed heterogeneous systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hildebrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-K</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proceedings Scientific Visualization / Information Visualization 2014)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">20</biblScope>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>De Guzman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nuffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Spirit</surname></persName>
		</author>
		<idno>2.5</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Experience report: visualizing data through functional pipelines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Borgo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Runciman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wallace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="379" to="382" />
			<date type="published" when="2008-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Huge data but small programs: Visualization design via multiple embedded DSLs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Borgo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Runciman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Practical Aspects of Declarative Languages</title>
		<editor>A. Gill and T. Swift</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="31" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Visualizing temporal patterns in large multivariate data using textual pattern matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Glatter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ahern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1467" to="1474" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient dynamic derived field generation on many-core architectures using python</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Navratil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moussalem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Childs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Python for High Performance and Scientific Computing</title>
		<meeting>the Workshop on Python for High Performance and Scientific Computing</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Shadie: A domainspecific language for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hašan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wolfgang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<ptr target="http://miloshasan.net/Shadie/shadie.pdf" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>Draft paper; available at</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">ParaView Guide, A Parallel Visualization Application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Henderson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>Kitware Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Superglue: A programming environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hultquist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Raible</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="243" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scout: High-performance heterogeneous computing made simple</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jablin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Parallel and Distributed Processing</title>
		<meeting>IEEE International Symposium on Parallel and Distributed Processing</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="2093" to="2096" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Distribution driven visualization of volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="734" to="746" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A functional methodology for parallel image processing development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Johnston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fleury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Downton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Visual Information Engineering</title>
		<meeting>the International Conference on Visual Information Engineering</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="266" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Simplified parallel domain traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kendall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Peterka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Erickson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Supercomputing Conference</title>
		<meeting>the Supercomputing Conference</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Programming Massively Parallel Processors, Second Edition: A Hands-on Approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Kirk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Hwu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Glift: Generic, efficient, random-access gpu data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Strzodka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="60" to="99" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An architecture for a scientic visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">S</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Gresh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Mcauliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page">107114</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scout: a data-parallel programming language for graphics processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Inman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mohd-Yusof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cummins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="648" to="662" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Scout: A hardware-accelerated system for quantitatively driven visualization and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Inman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="171" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Voreen: A rapid-prototyping environment for ray-casting-based volume visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meyer-Spradow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ropinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mensmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hinrichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="6" to="13" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dax toolkit: A proposed framework for data analysis and visualization at extreme scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moreland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Ayachit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Geveci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Large-Scale Data Analysis and Visualization</title>
		<meeting>IEEE Symposium on Large-Scale Data Analysis and Visualization</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>LDAV 2011</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The medical exploration toolkit: An efficient support for visual computing in surgical planning and training</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mühler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tietjen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ritter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Preim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="133" to="146" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title/>
		<ptr target="http://www.python.org/" />
	</analytic>
	<monogr>
		<title level="j">Python Software Foundation. Python Language Reference</title>
		<imprint>
			<biblScope unit="page" from="2014" to="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<idno>accessed: 2014-03-30</idno>
		<ptr target="http://qt-project.org/wiki/QtQuickToolingWhitepaper" />
		<title level="m">Qt Project. Qt Quick Tooling Whitepaper</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Development Core</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Team</surname></persName>
		</author>
		<idno>3-900051-07-0</idno>
		<ptr target="http://www.R-project.org" />
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="2014" to="2017" />
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Decoupling algorithms from schedules for easy optimization of image processing pipelines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Durand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A shader framework for rapid prototyping of gpu-based volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rieder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Link</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">K</forename><surname>Hahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1031" to="1040" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit: An Object-Oriented Approach to 3D Graphics, Third Edition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Kitware, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Query-driven visualization of large data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Stockinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bethel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title/>
		<ptr target="http://www.mathworks.com/" />
	</analytic>
	<monogr>
		<title level="j">The MathWorks Inc. MATLAB</title>
		<imprint>
			<biblScope unit="page" from="2014" to="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The application visualization system: a computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Domain-specific languages: An annotated bibliography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Deursen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="26" to="36" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Parallel visualization on large clusters using mapreduce</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bronson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Summa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Large Data Analysis and Visualization (LDAV 2011)</title>
		<meeting>IEEE Symposium on Large Data Analysis and Visualization (LDAV 2011)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<idno>accessed: 2014-03-30</idno>
		<ptr target="http://www.w3.org/TR/CSS2/" />
		<title level="m">W3C. Cascading Style Sheets</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Visualization in the scirun problem-solving environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weinstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Simpson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zimmerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Visualization Handbook</title>
		<editor>C. Hansen and C. Johnson</editor>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="615" to="632" />
		</imprint>
	</monogr>
	<note>Elsevier</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wolfram</surname></persName>
		</author>
		<title level="m">Mathematica: A System for Doing Mathematics by Computer</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
	<note>Second Edition</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Engineering and algorithm design for an image processing API: A technical report on ITK -the insight toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chalana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Aylward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Metaxas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Medicine Meets Virtual Reality</title>
		<meeting>Medicine Meets Virtual Reality</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="586" to="592" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
