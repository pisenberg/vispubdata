<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visualizing Massive Multi-Digraphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Abello</surname></persName>
							<email>abello@research.att.com</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Information Visualization Research Shannon Laboratories</orgName>
								<orgName type="institution">AT&amp;T Labs-Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Korn</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Information Visualization Research Shannon Laboratories</orgName>
								<orgName type="institution">AT&amp;T Labs-Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Visualizing Massive Multi-Digraphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>visualization</term>
					<term>massive data sets</term>
					<term>graphs</term>
					<term>hierarchies</term>
					<term>out-of-core algorithms</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We describe MGV, an integrated visualization and exploration system for massive multi-digraph navigation. MGV&apos;s only assumption is that the vertex set of the underlying digraph corresponds to the set of leaves of a predetermined tree ¢. MGV builds an out-of-core graph hierarchy and provides mechanisms to plug in arbitrary visual representations for each graph hierarchy slice. Navigation from one level to another of the hierarchy corresponds to the implementation of a drill-down interface. In order to provide the user with navigation control and interactive response, MGV incorporates a number of visualization techniques like interactive pixel-oriented 2D and 3D maps, statistical displays, multi-linked views, and a zoomable label based interface. This makes the association of geographic information and graph data very natural. MGV follows the clientserver paradigm and it is implemented in C and Java-3D. We highlight the main algorithmic and visualization techniques behind the tools and point out along the way several possible application scenarios. Our techniques are being applied to multi-graphs defined on vertex sets with sizes ranging from 100 million to 250 million vertices.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Processing, querying, exploring and visualizing massive data sets poses a series of interesting computational and visual challenges. A variety of these data sets can be modeled as very large but sparse multi-digraphs with a special collection of application dependent edge attributes. Geographic information systems, telecommunications traffic and internet data are prime examples of the type of data our system is targeted to handle.</p><p>Sheer size is the first fundamental issue that needs to be addressed when the data to be dealt with is considered massive. In our case, for one of the data sets, we receive a stream of about 275 million records daily yielding about 450GBytes per month. Having access to several SGI Origin-2000 servers, 5 terabytes of disk and an SGI Onyx connected to a £ ¥ ¤ § ¦ © ¦ © © power wall certainly helps in the processing but it does not circumvent two important bottlenecks: I/O bandwidth and screen real estate.</p><p>The I/O bottleneck is caused by the substantial difference between CPU speeds and external memories. Algorithms whose performance is stated in terms of not just the input size, , but also in terms of the size of main memory, and of the disc block transfer size, , are called external memory algorithms <ref type="bibr" target="#b0">1</ref> . With this framework in mind, the first requirement for a data set to be considered massive is that its size ( ) must be larger than the size of available RAM ( ). In the case of multi-digraphs, is essentially ( ! "</p><p>) where</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>! #</head><p>is the number of edges of the underlying graph. <ref type="bibr" target="#b0">1</ref> See J. Abello and J. Vitter <ref type="bibr" target="#b9">[10]</ref> for a recent review of this subject.</p><p>An intermediate case, quite relevant in practice, occurs when the set of vertices fits in RAM but not the edge set (this is called the semi-external case in <ref type="bibr" target="#b5">[6]</ref>). The justification for this model relies on the increased availability of large RAMs. For example, the essential information associated with 250 million vertices fits nicely in 2GBs of RAM. In this case, in principle, one can process any secondary storage multi-digraph with vertex set up to this size.</p><p>The screen bottleneck is caused by the simple fact that the amount of information that can be displayed at once is ultimately limited by the number of available pixels and the speed at which the information is digested by a user. Even though a large number of pixels diminishes the screen bottleneck, it does not help the user's visual processing abstraction unless the display metaphor incorporates some global data set semantics. Luckily, a variety of massive multi-digraphs are implicitly defined on vertex sets that correspond to the leaves of a predefined hierarchy ¢ . When we can induce such a hierarchy we can use it to guide the exploration and visualization of the data set. This is done by defining an inherited equivalence relation on the multi-digraph edge set (see Section 2). The hierarchy makes it possible for a user to digest one manageable portion of the data at a given time.</p><p>In order to deal in a unified manner with both the I/O and the screen bottlenecks, we base our work on a metaphor called hierarchical graph slices. The main idea is to build a hierarchy of multi-digraph layers on top of the input multi-graph. Each layer is obtained by coalescing disjoint sets of vertices at a previous level and aggregating their corresponding weighted edges. A collection of edges in a layer whose aggregation produces an edge at the next higher layer is called an edge slice. Several "natural" operations provide hierarchical browsing. Each edge-slice is small enough to be represented visually in a variety of ways, such as a 2D needlegrid, a 2D star-grid or star-map, a 2D surface in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>$ &amp; %</head><p>or a conventional graph drawing. Slices have different properties depending on their depth, as shown in <ref type="figure">Figure 1</ref>. Slices at a greater depth are represented by more pixel hungry representations. Representations can be chosen automatically based on properties of the data, or can be plugged in manually by a system user.</p><p>Many of our visualizations depart strongly from the conventional visual graph representation that draws graphs as nodes and edges, unless the slice being considered is very sparse and defined on a very small number of vertices and edges. In our hierarchical decomposition, when facing a dense subset of edges, we use adjacency matrix based visualizations since they are likely easier to digest. Conventional graph representations like the one shown in <ref type="figure" target="#fig_3">Figure 2</ref> are of very limited use for the range of sizes being considered in this work. This paper presents new techniques that are particularly helpful in visualizing dense slices.</p><p>When a hierarchy ¢ is fixed, the corresponding graph-layers can be updated incrementally. They are suitable for the processing, navigation and visualization of external memory graphs <ref type="bibr" target="#b5">[6]</ref> whose vertex sets are hierarchically labeled.</p><p>A by-product of the hierarchical graph-slices metaphor is that a commercial relational database can be used to query the multidigraph hierarchy with very little extra effort. Also, hierarchical graph-slices are amenable to distributed visual exploration.</p><p>Our current prototype (termed Massive Graph Visualizer) is a system with the following highlights:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>It handles hierarchical views of massive multi-digraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>It consists of a C-computational engine (server) and a Java-3D visualizer (client), which may reside on separate machines. In fact, the visualizer can run on multiple desktops allowing different users to navigate a massive data set independently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>It provides a drill-down zoom-able interface together with a collection of multi-linked views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>Context is maintained by using multiple cameras. One provides an overview and the others trail each other depending of a user specified zooming interval. A persistent history of previous navigations of the hierarchy is maintained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>In the case of geographical data, displays such as the star-map (Section 4.2) allow the superposition of graph neighborhood information on a given geography. This offers an alternative to the conventional approach of explicitly drawing the edges among specified positions on a given map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>Visual aggregation can be obtained by special views, such as our multi-comb view (Section 4.3) or by an adaptation of the circle of segments technique <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>Users can plug-in alternative visualizations of the hierarchical graph slices, and can apply their own filters to the slices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>The work presented here grew out of the graph surfaces metaphor presented in <ref type="bibr" target="#b8">[9]</ref>. The primary difference is that 2D surfaces are not easy to refine locally. By choosing different representations for the higher levels of the hierarchy we get very fast local refinement, a very intuitive visual aggregation operation and visually pleasant animations of data set evolution.</p><p>The vertex set of our hierarchy is a super-set of the vertex set of the underlying multi-digraph. This makes our approach quite different than other graph visualizations based on spanning trees of the underlying graph (see Munzner <ref type="bibr" target="#b15">[16]</ref>, Wills <ref type="bibr" target="#b7">[8]</ref>). The use of hierarchies for the exploration of large graphs is explicitly mentioned in <ref type="bibr" target="#b6">[7]</ref>. Our work can be viewed as an automation of these ideas that provides a uniform overall view of massive graph data together with scalable, efficient and flexible visual navigation tools.</p><p>The layout of the paper is as follows. In Section 2, we discuss graph slices, the main elements of the computational engine, and its fundamental operations and I/O performance. In Section 3, we discuss the correspondence between the slice hierarchy and the different visual representations. The components of the Java-3D visualizer and the main interface issues are the contents of Sections 4 and 5. Section 6 points out some future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Hierarchical Graph Slices</head><p>In order to handle very large graphs, a hierarchy of multi-digraph layers is constructed. Each layer represents a multi-digraph obtained from an equivalence relation defined on the edge set of the input multi-graph. Each layer edge represents an equivalence class of edges at the previous layer. Each such equivalence class constitutes what we call an edge-slice. Zooming operations are provided that allow the user to explore the graph slice hierarchy in a fluid manner.</p><p>We introduce these concepts more formally next. <ref type="figure" target="#fig_4">Figure 3</ref> illustrates our definitions.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Definitions</head><formula xml:id="formula_0">( = 0 1 ) B A C ! D A E 4 F 2 . ' For a rooted tree ¢ , let G B H § I Q P ¥ H S R T 0 U ¢ 2 = set of leaves of ¢ . V H § W Y X Q Q a b 0 U ¢ 2 =</formula><formula xml:id="formula_1">( = 0 1 ) B A t ! 3 A E 4 i 2</formula><p>and a rooted tree</p><formula xml:id="formula_2">¢ such that G B H § I ¥ P ¥ H © R T 0 U ¢ 2 v u w ) 3 0 1 ( &amp; 2</formula><p>, the multiplicity of a pair of vertices</p><formula xml:id="formula_3">r and s of ¢ is 4 x 0 y r A s T 2 u p § 1 T 4 0 d f A E 2 for f 9 g G H § I ¥ P ¥ H S R T 0 U ¢ 7 2 and g G B H § I Q P ¥ H S R T 0 U ¢ e d f 2 h g An incomparable pair 0 y r A E s 2</formula><p>is called a multi-edge when  </p><formula xml:id="formula_4">V H § W Y X Q Q a b 0 d s 2 i V H § W d X Q a b 0 y r e 2</formula><p>is called a primary crossing multiedge.</p><p>Notice that a horizontal multi-edge  </p><formula xml:id="formula_5">V 0 1 ( k A E ¢ 2</formula><p>contains a very large collection of multiedges that can be computed from the horizontal and primary crossing multi-edges as defined above, we take the approach of maintaining just these multi-edges and computing the remaining ones on demand. This sub-multigraph is denoted by    has below it a hierarchy of edge-slices where each level represents an aggregation of previous levels and where the bottom most level is the subgraph of</p><formula xml:id="formula_6">G V 0 1 ( k A ¢ l 2 . G V 0 1 ( k A e ¢</formula><formula xml:id="formula_7">( with vertices G B H f I ¥ P ¥ H S R T 0 U ¢ 2 union G B H § I Q P ¥ H S R T 0 U ¢ d 2</formula><p>and edges of ( running between them. This is the justification for naming this section Hierarchical Graph Slices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Constructing n p o r q e s F t h u 3 v</head><p>The procedure Construct</p><formula xml:id="formula_8">G V 0 1 ( k A ¢ l 2</formula><p>, presented in <ref type="bibr" target="#b8">[9]</ref>, takes as input a stream of edges representing a multi-digraph ( and a rooted tree</p><formula xml:id="formula_9">¢ such that G B H f I ¥ P ¥ H S R T 0 U ¢ 2 = ) 3 0 1 ( &amp; 2</formula><p>. It returns as output, a disk resident, multi-level index structure to the edges of</p><formula xml:id="formula_10">G V 0 1 ( k A ¢ l 2 . Lemma 1. G V 0 1 ( k A E ¢ 2 can be constructed in time D 0 w ) 3 0 1 ( &amp; 2 b f V H § W Y X Q Q a b 0 U ¢ 2 y x z ! 3 0 1 ( &amp; 2 b 2</formula><p>in a bottom-up fashion <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b11">12]</ref>. Space requirements are similar, making</p><formula xml:id="formula_11">G V 0 1 ( k A E ¢ 2</formula><p>an efficient data structure to use for our visualization system. Because</p><formula xml:id="formula_12">G V 0 1 ( k A E ¢ 2</formula><p>is really ¢ plus the collection of layers of ( given by ¢ , we can think of each layer as being represented by a two dimensional grid and ¢ as a road map to navigate the slice hierarchy. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Handling the I/O bottleneck</head><formula xml:id="formula_13">) # 0 1 ( &amp; 2</formula><p>does not fit. The first two cases correspond to what is called the semi-external version and the third one is referred to as fully external. We center our discussion in the first two cases since they suffice for our applications. The third case is not fully understood yet and its solution may take something of a breakthrough both at the algorithmic and at the systems level. In the first case, the edges of ( are read in blocks and each one is filtered up through the levels of ¢ until it lands in its final layer. This can be achieved with one pass.</p><p>In the second case, a multilevel external memory index structure is set up to represent ¢ as a parent array according to precomputed breadth first search numbers. Filtering the edges through this external representation of ¢ can be done in no more than</p><formula xml:id="formula_14">V H § W d X Q a b 0 U ¢ 2</formula><p>scans over the data.</p><p>As pointed out in the introduction, the increased availability of large RAMs makes it realistic to assume that the vertex set fits in main memory. With multi-gigabyte RAMs being a reality and using our approach, one can process in principle any secondary storage multi-digraph defined on hundreds of millions of vertices. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Navigating the Hierarchy</head><formula xml:id="formula_15">) 3 0 1 ( &amp; 2</formula><p>with every higher level being just a partial aggregation of this partition. This implies in turn that from any given layer one can move to any of the adjacent layers by partial aggregation or by refinement of some sets in the corresponding partition. This is precisely the information that is encoded in</p><formula xml:id="formula_16">G V 0 1 ( k A E ¢ 2</formula><p>. Namely, from any given multi-edge</p><formula xml:id="formula_17">H in G V 0 1 ( k A E ¢ 2</formula><p>one can obtain the set of edges in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H</head><p>. This is the only operation that is needed to navigate since vertices in ¢ can be easily replaced by their children by just following the tree edges. Non-primary crossing edges between non-leaves of the tree can be expanded by using the basic operations defined below. The</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>| Q }</head><p>complexity is proportional to the difference in height between the two end points.</p><p>The main navigational operations used by the computational engine are: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Visual Navigation</head><p>When we are visualizing data sets that are two to three orders of magnitude larger (say around 250 million records) than the screen resolution (typically about one million pixels), it becomes imperative to use a hierarchical decomposition of the visual space, particularly if we require real-time interactivity. In our case, we achieve fast response by navigating an input graph via its slices.</p><p>Our system allows the user to begin with a visualization of an initial layer, and interactively focus on selected edges which can be zoomed in to produce a visualization of a slice from the next layer down the hierarchy. Currently, the system uses a mouse/keyboard input interface. Using joysticks and gestures to navigate the environment is a possibility worth exploring. The best representation for a particular slice depends on properties of the graph representing that slice, so our system allows a variety of visualization techniques to be used for each slice. In the case of highly dense slices, which are usually encountered in higher layers of the slice hierarchy, we are often best off using adjacency matrix style visualizations since the number of edges is too large to effectively use the traditional nodes-and-edges visualization.</p><p>In our experience, the process of drilling down on slices works well to explore the real world multi-digraphs we are dealing with. Such data sets have highly skewed distributions, and this skewness can be directly observed by the visual cues in our 2D and 3D representations. For example, when we are dealing with phone records (calling frequency or total minutes of call), we are naturally interested in areas of larger edge weights. Looking at the grid representation shown in <ref type="figure" target="#fig_11">Figure 4</ref>, we can quickly determine such edges using the inclination and color of the sticks. We can then zoom into these sticks to obtain more refined views.</p><p>We now describe in more detail our scheme to visualize very large multi-digraphs. In this context, large refers to data sets that do not fit into main memory. Our system consists of two main components: the C computational engine and the Java-3D graphical engine. Given a large graph as input, the computational engine uses the approach outlined in the previous sections to cluster subgraphs together in a recursive fashion and generates a hierarchy of weighted multi-digraphs. The edge-slices in each layer of this hierarchy are sufficiently small to fit in main memory.</p><p>A typical large and realistic data set may have a number of interesting patterns and trends that information visualization and data mining applications want to explore. However, providing all this information in one shot might be too difficult to analyze or understand. In our metaphor, we amortize the visual content in every scene with the constructed graph hierarchy. Further, the reduced size of each edge-slice makes it possible to provide the necessary real-time feedback in such an exploratory setting. As the user traverses deeper into the hierarchy, the scene displayed becomes more detailed in a restricted portion of the data set.</p><p>The graphical engine has two primary functions -generating graph representations for individual slices in</p><formula xml:id="formula_18">V 0 1 ( k A ¢ 2</formula><p>using the navigation operations defined in the previous section, and displaying appropriate visual cues and labeled text. One of the aims is to help the user have intuitive understanding along with complete navigation control.</p><p>We now describe the main visual primitives that allow a user to move from one level of the hierarchy to another while changing the visual representation if necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Zooming</head><p>As the user is viewing a particular slice, he/she can use the mouse or keyboard to pan, rotate, or zoom the image. A threshold can be set which defines between which zoom factors the visualization is valid. If the user zooms far enough in or out to exceed the threshold, a callback is invoked which replaces the current slice with a new slice. When zooming, the computation engine retrieves a new slice representing the closest edge to the center (which is where we are zooming into) and the slice is placed on a stack. When zooming out the corresponding slice is retrieved from the stack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Views</head><p>A variety of visualizations can be used to display a given slice. A default is chosen automatically based on properties of the graph, but the user is presented with a list of visualization types that can be selected. If an alternate view is selected, the current visualization is substituted by the chosen replacement. Our system keeps track of the preferred view in case the user navigates to other slices and then returns to a slice. Moreover, several mechanisms are provided that allow the user to plug-in his/her own slice representation.</p><p>When multiple views of a slice are used simultaneously, they can be linked together. As the mouse passes over elements in one view, other views highlight the corresponding elements in their view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Selection</head><p>The user interface allows for nodes to be selected with the mouse. A list of selected nodes is maintained by the system which can be used by different visualization methods. Typically, the selection is used to display a sub-graph of the current slice. For example, if we are displaying a graph whose nodes are all states in the US, we could select a handful of states we are interested and limit our display to only those nodes and related edges. When the selection changes on one view of a graph, it is appropriately updated on corresponding linked views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Slice Computation</head><p>Our computation engine does not need to compute the entire</p><formula xml:id="formula_19">V 0 1 ( k A E ¢ 2</formula><p>a priori, since it is likely that a user will only navigate through a subset of the data. Therefore, our engine runs in concert with the visualization interface and acts as a server. The interface starts off by requesting an initial slice from the server. This slice is converted to a visual representation, which is navigated by the user. If the user selects to zoom into an edge, the interface sends a request to the server to obtain a new slice. The engine can compute this slice on the fly, or simply return the contents of a precomputed slice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Slice Views</head><p>This section describes some of the built-in visualization techniques that can be used to display graph slices. MGV provides a flexible interface for defining new visualizations so we are not limited to the set of views that we describe here.</p><p>MGV works with slices in their adjacency matrix representation. Slices are visualized as a set of line segments, where each matrix element maps into a single line segment whose origin, length, color, width, etc. depend on some mapping function . In the simplest case, we can draw the elements onto a rectangular grid, but much more sophisticated mappings are possible.</p><p>Our system automatically tracks the correspondence between edges and visual segments. Thus, the author of a visualization does not have to handle the details of user interaction. The system can determine which edges are selected through the interface. It uses this information to interactively label edges and determine which edge is to be replaced and expanded when the user zooms in.</p><p>Currently, our visual metaphors are being used in the analysis of several large multi-digraphs arising in the telecommunications industry. These graphs are collected incrementally. For example, the AT&amp;T call detail multi-digraph, consists on daily increments of about 275 million edges defined on a set containing on the order of 260 million vertices. The aim is to process and visualize these type of multi-digraphs at a rate of a million edges per second. We will use examples from this data to illustrate the metaphors presented in <ref type="figure">Figure 5</ref>: A star-map view of call data, superimposed with geographic information. this section 2 ; we describe other applications in Section 4.6. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Needle Grid</head><formula xml:id="formula_20">0 d W t A 1 { 2</formula><p>, is called the needle-grid representation of the given matrix or a needle slice. (see <ref type="figure" target="#fig_11">Figure 4</ref> for an example). Note that the grid view for a particular graph is not unique. It depends on the ordering of the matrix elements.</p><p>For our set of phone call data in <ref type="figure" target="#fig_11">Figure 4</ref>, we can make some interesting observations. First, we see high values along the diagonal. This indicates a higher call volume for interstate calls in general. We have arranged the order of the matrix elements to conform to a Peano-Hilbert path through the US map. In this way, clusters around the diagonal correspond to country regions with high calling traffic. We can also observe asymmetries in the edge density and that could be areas with differing densities of AT&amp;T customers. In general, patterns at higher levels of the hierarchy can be used as exploration guides at lower detail levels. <ref type="bibr" target="#b1">2</ref> Values have been changed in this paper to protect sensitive information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Star Maps</head><p>The star-map view rearranges each row or column of our matrix into a circular histogram rooted at a single point. The histogram is arranged such that the first value is drawn at 0 degrees and values are evenly spaced such that the final value is drawn at ¦ S . This results in a star-like appearance. We refer to each element of a star as a star segment. Star segments have a length proportional to the value of the edge it represents. Additionally, the color of the star segment is dependent on the value to provide an additional visual cue.</p><p>Each star represents a row or column, depending on which type of star visualization is chosen. The position in which each star is placed is arbitrary; however, if available, we can make use of geographic data associated with each node in the graph. For example, suppose we are looking at call detail data, where each node in the slice represents a particular state. We could supply latitude and longitude for each node and arrange the stars on a USA map, as shown in <ref type="figure">Figure 5</ref>. In this case, we are placing the star representing the row (or column) at the geographic position of . The star-map conveys a different type of information than the needle grid. It is particularly well suited to focus on a particular subset of vertices and detect easily among them those ones with higher or lower incoming or outgoing traffic. By moving the mouse over the segments, the corresponding vertex labels get activated. In the call detail data, we notice some states with one or two star segments that are larger than the others. Moving the mouse over the segments reveals which states these are.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Multi-comb</head><p>The multi-comb view can be thought of as an extension of the star map. With star maps, an entire row or column of the matrix is drawn such that it appears as a single object (in the shape of a star) but it represents a collection of values. Taking this a step further, we can turn an entire matrix into a "single" object by placing the collection of stars that compose the matrix on top of each other along the axis and connecting the endpoints of the corresponding star segments. An example is provided in <ref type="figure" target="#fig_12">Figure 6</ref>. This single object represents an aggregate view of a graph with hundreds of million of edges.</p><p>An advantage of this view is that we can compare rows or columns depending if we look along the star segments at a particular or if we look at all the values for a particular star segment. When we consider all the values for a single star segment, it resembles a comb, which is why we term this view the multi-comb view. This view is useful in providing animations of data set evolution. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Multi-wedge</head><p>The multi-wedge view is a different way to overlay stars on top of each other. Instead of putting each star at a different value as we do with the multi-comb, we draw a single star as ticks instead of segments, where each tick is placed at the endpoint of that segment. The resulting picture, as shown in <ref type="figure" target="#fig_14">Figure 7</ref>, is a circular histogram with a distribution spectrum on each star segment, which we call a wedge. From this view, we can see the min and max values for a star line (which is a row or column), standard deviation, median, mean, etc. This is a two dimensional view, which is preferable to the multi-comb for static visualizations. The colors of the ticks represent the value of the back-edge in the multi-graph. When the matrix is symmetrical, the colors of ticks will occur in order. Thus, we can easily detect asymmetries with this coloring convention.</p><p>In our example, we can look at the calling distributions for each state. We again see that intrastate calling is typically a lot greater than interstate calling, but this view reveals the rest of the distribution varies a lot by state. Looking at the distributions can tell us which states have more regional calling patterns. For example, North Dakota makes a lot more calls to Minnesota than to any other state, but California has a more even distribution to the other states. We also see that the northern states of Idaho, Montana and North Dakota have lower phone usage than neighboring states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Aggregate Views</head><p>Although we map each matrix entry to exactly one screen segment, we can create mappings which effectively compute certain aggregate operations. For example, suppose we are using the star map for a graph with associated geographic information and we want to replace the stars with a single bar representing their aggregate equivalent. We can accomplish this by creating bar segments for each star and placing them on top of each other along the direction. The resulting view will appear as a single bar representing the sum of values for that row (or column), as shown in <ref type="figure" target="#fig_13">Figure 8</ref>. Additionally, a user can move the cursor on the bar to find out what are the segments that make up the bar, and can zoom in on a particular segment.</p><p>If we wish to do more complicated aggregations, such as taking the mean, median or an arbitrary function over the values, we can accomplish this by mapping the slice into a new slice representing the aggregation and visualizing that slice. For example, if we wanted to visualize the average over each row, we would map an 4 slice into a 4 ¤ slice. Our system provides a mechanism to define slice transformations, which are useful in other contexts as well. For instance, suppose we are only interested in a subset of the vertices. We can use a slice mapping to select out only the nodes we are interested in. We can also use transformations to rearrange the vertex ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Applications</head><p>The navigation operations can be enhanced to perform a variety of statistical computations in an incremental manner. They can also be used to animate behavior through time. The stars-map metaphor is very useful when the vertices of the multi-digraph have an underlying geographic location (see <ref type="figure">Figure 5</ref>). This offers a high degree of correlation between graph theoretical information and the underlying geography. We currently have instantiations of MGV that visualize call detail data and network capacity data. We can work with a variety of other data sets as well; citation indexes, general library collections, program function call graphs, file systems and internet router traffic data are, among others, interesting data sets that can be explored using the approach described here.</p><p>Internet data is a prime example of a hierarchically labeled multidigraph that fits quite naturally our graph metaphor. Each i-layer represents traffic among the aggregate elements that lie at the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>W d</head><p>level of the hierarchy (such as IP address blocks or the domain name space). We can also apply the techniques to web data. Considering pages as nodes and hyper-links as edges, we can take a set of web pages as a digraph. A portal such as Yahoo, which categorizes web sites into a hierarchy, could be used as ¢ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>As mentioned previously, MGV is separated into a computation engine and a Java-based user interface. The engine runs as a web server, and communication takes place using the http protocol. The server encodes slices as XML which are then processed by the interface. The use of Java-3D makes the system portable and allows fast rendering of visual representations, as it is able to take advantage of hardware graphics support. In the design of the interface, we had to make decisions on some interesting questions regarding the presentation of the various visualizations:</p><p>'</p><p>How do we provide context to the user while he/she is exploring a node deep in the hierarchy? '</p><p>Typically, at each level, there are a few sites that are potentially interesting. How do we communicate this in the display and encourage them to explore deeper?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>'</head><p>Labeling is an important issue when displaying information. How can we avoid the problem of cluttering during the display of labels?</p><p>'</p><p>How can we apply geographic information associated with the data?</p><p>In our display, we maintain context in two ways. We use one window to display a delayed view, with respect to zooming, of the user's view (see <ref type="figure" target="#fig_15">Figure 9)</ref>. We highlight those data portions that have been visited already to provide users with information about the extent of their exploration.</p><p>The visualization engine tracks the mouse activity of the user and displays textual information about the closest edge in a separate window.</p><p>Potentially interesting regions (i.e. hotspots) are highlighted in a different color to catch the user's attention. An obvious limitation of the current approach is that what is and is not interesting from a data mining point of view must be pre-determined.</p><p>In order to handle textual labels in an efficient manner we divide the set of labels into two parts, static and dynamic. Static labels are displayed at all times. They are a small fraction of the entire label set. Dynamic labels are displayed only when the user selects them. The combination of static and dynamic labels manages the excessive clutter in the display well. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>Needle-grids, star-maps, multi-combs and multi-wedges are the visual counterpart of the graph theoretical notions of edges and neighborhoods. They can be superimposed on an arbitrary layout of the vertex set of a graph without cluttering the view. They can be also used to visually represent certain type of aggregate statistics on multi-graphs. These facts coupled with a predefined hierarchy on the vertex set allow us to visually explore very massive multidigraphs. The navigation is based on the notion of graph-slices. Graph-slices provide flexibility in terms of visual representations and visual navigation. The fact that the MGV client is implemented in Java3D helps make the system highly portable and extensible.</p><p>Our metaphor allows the integration of visualization and computation on a large class of massive data sets. It opens the door to the use of matrix theoretical methods for the hierarchical analysis of very large data collections. In particular, the pseudo-automatic selection of color maps depending of the statistical properties of the data at different levels of the hierarchy is one of the major issues that we are planning to address in the future.</p><p>Another natural direction to pursue is to come up with an efficient distributed memory implementation of MGV.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>r a r c h y O r i g i n a l G r a p h I n d u c e d L e v e l Graph layers. Layers in deeper levels tend to be sparser. Traditional nodes-and-edges representation of a fully connected graph with 20 nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>of the other.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>'</head><label></label><figDesc>Given a multi-digraph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2</head><label>2</label><figDesc>is greater than zero. When both r and s are at the same distance from the root of ¢ , the multi-edge is called horizontal. A non-horizontal</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Hierarchical Graph Decomposition multi-edge between vertices r and s where r is a leaf and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>equal to the edges of ¢ union the multi-edges running between incomparable pairs of ¢ . Because</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>'</head><label></label><figDesc>i-layer its edge-slice is the submultigraph of the (i+1)-layer whose nodes are the children of f union the children of , and whose multi-edges are those in the (i+1)-layer running between these nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>'</head><label></label><figDesc>A good mental picture of what the definitions convey is that each multi-edge</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>(</head><label></label><figDesc>that are represented by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 4 :</head><label>4</label><figDesc>A graph slice represented as a needle grid. Edge values are shown with multiple cues: the segment color, segment length, and segment orientation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 6 :</head><label>6</label><figDesc>Multi-Comb View of call detail data at the state level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 8 :</head><label>8</label><figDesc>Aggregate view of the data represented inFigure 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 7 :</head><label>7</label><figDesc>Multi-Wedge view of call detail data. Each wedge shows the distribution of calls for one state, and can be compared to the star of a particular state.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 9 :</head><label>9</label><figDesc>Overview window. The plus symbol shows the location in the parent slice of our current zooming position.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>; add all the edges in the next layer that run from the children of~to the children of P . Suitable inverses of the operations above can be defined provided certain restrictions are obeyed. For example, the inverse of</figDesc><table><row><cell cols="6">' Replacement: Given a vertex~in tutes~by its children. This can be implemented by gener-¢ , H t r y I Q H { 0 d substi-e 2</cell></row><row><cell>ating edges children(~).</cell><cell>¥ 0 d</cell><cell>A w y 1 2</cell><cell cols="3">:7 is a child of~in</cell><cell>¢ and vertices l</cell></row><row><cell cols="6">' Vertex zoom: Given a vertex~in  § A t e © A g g g A w e , zoom0 d y 2 generates { 0 d A t n and pairs (ỹ ,¥ ) such that in the input multi-digraph the with childreñ ¢ :~ is a child ofĩ 2 ¢ set of edges from G B H  § I Q P ¥ H S R T 0 d 2 to G B H  § I Q P ¥ H S R T 0 d 2 is non-empty .</cell></row><row><cell>as follows:</cell><cell cols="3">delete the edge</cell><cell>0 d A t P Q 2 , zoom0 0 d q A t P Q 2 ; H t r y j I ¥</cell><cell>t 0 d H ¥ 0 d A t P Q 2 t 2 y 2 ; H is defined t r y j I ¥ H ¥ 0 d P Q 2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>© H t r y</cell><cell>j I ¥ b H</cell></row></table><note>' Edge zoom: Given an edgeis defined, for a set of vertices, only if they are on the same layer and if they constitute all the children of a vertex~.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank S. Byers, D. Keim, S. Sudarsky and W. Sweldens for comments and discussions about this this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Rule-based Tool for Assisting Colormap Selection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Rogowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Treinish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;95 proceedings</title>
		<imprint>
			<date type="published" when="1995-10" />
			<biblScope unit="volume">444</biblScope>
			<biblScope unit="page" from="118" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dynamic Aggregation with Circular Visual Designs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chuah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Symposium on Information Visualization</title>
		<meeting>IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="35" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Circle Segments: A Technique for Visually Exploring Large Multidimensional Data Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ankerst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kriegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conf. Visualization</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Large Scale Network Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Newsletter</title>
		<imprint>
			<date type="published" when="1999-08" />
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="13" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">How not to lie with visualization In Computers in Physics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Rogowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Treinish</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">268</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A functional approach to external memory graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Buchsbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Westbrook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Algorithms</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1461</biblScope>
			<biblScope unit="page" from="332" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Navigating Large Networks with hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Visualization</title>
		<meeting>IEEE Conf. Visualization</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="204" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">NicheWorks-interactive visualization of very large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int. Symp. Graph Drawing, GD</title>
		<meeting>5th Int. Symp. Graph Drawing, GD</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">1353</biblScope>
			<biblScope unit="page" from="403" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Navigating Graph Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation and Complexity in Numerical Optimization: Continuous and Discrete Problems</title>
		<editor>P. Pardalos</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">AMS-DIMACS Series on Discrete Mathematics and Theoretical Computer Science</title>
		<editor>J. Abello, J. Vitter.</editor>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hierarchical geometric models for visible surface algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="547" to="554" />
			<date type="published" when="1976-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Balanced Aspect Ratio Trees and Their Use for Drawing Very Large Graphs. Lecture Notes in Computer Science</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Duncan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kobourov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">1547</biblScope>
			<biblScope unit="page" from="111" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Multilevel Visualization of Clustered Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">W</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1190</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="101" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Delaunay-Based Method for Surface Approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Falcidieno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pienovi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurographics &apos;</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="333" to="350" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multiresolution modeling for fast rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Interface &apos;94</title>
		<meeting>Graphics Interface &apos;94</meeting>
		<imprint>
			<date type="published" when="1994-05" />
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exploring Large Graphs in 3D Hyperbolic Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="23" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Stealth terrain navigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ansel</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Dementhon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><forename type="middle">S</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst. Man Cybern</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="110" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
