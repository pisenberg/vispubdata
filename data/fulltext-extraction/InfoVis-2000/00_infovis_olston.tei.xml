<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Getting Portals to Behave</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Olston</surname></persName>
							<email>olston@db.stanford.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allison</forename><surname>Woodruff</surname></persName>
							<email>woodruff@parc.xerox.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Xerox PARC</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Getting Portals to Behave</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Portals</term>
					<term>Multiple Views</term>
					<term>Data Visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Data visualization environments help users understand and analyze their data by permitting interactive browsing of graphical representations of the data. To further facilitate understanding and analysis, many visualization environments have special features known as portals, which are sub-windows of a data canvas. Portals provide a way to display multiple graphical representations simultaneously, in a nested fashion. This makes portals an extremely powerful and flexible paradigm for data visualization. Unfortunately, with this flexibility comes complexity. There are over a hundred possible ways each portal can be configured to exhibit different behaviors. Many of these behaviors are confusing and certain behaviors can be inappropriate for a particular setting. It is desirable to eliminate confusing and inappropriate behaviors. In this paper, we construct a taxonomy of portal behaviors and give recommendations to help designers of visualization systems decide which behaviors are intuitive and appropriate for a particular setting. We apply these recommendations to an example setting that is fully visually programmable and analyze the resulting reduced set of behaviors. Finally, we consider a real visualization environment and demonstrate some problems associated with behaviors that do not follow our recommendations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recently, much attention has been devoted to data visualization environments that permit interactive browsing of graphical representations of large data sets <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>. Many of these environments present a twodimensional infinite canvas 1 of graphical data through which the user can "navigate" to interactively browse the data. Interactive browsing can be a powerful way to understand and analyze data. To further facilitate browsing and analysis, many visualization environments have special features known as portals <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13</ref>], 2 which are * Supported by a National Science Foundation graduate research fellowship. <ref type="bibr" target="#b0">1</ref> Called a "surface" in Pad <ref type="bibr" target="#b12">[13]</ref>. <ref type="bibr" target="#b1">2</ref> Portals have many names, including "wormholes" in Tioga-2 <ref type="bibr" target="#b1">[2]</ref>, the predecessor to DataSplash. sub-windows of a data canvas. Portals provide a way to display multiple graphical representations simultaneously, in a nested fashion. This makes portals an extremely powerful and flexible paradigm for data visualization.</p><p>Unfortunately, with this flexibility comes complexity. There are over a hundred possible ways each portal can be configured to exhibit different behaviors. Many of these behaviors have confusing effects. Furthermore, many behaviors are inappropriate for a particular setting. For example, certain behaviors have visually programmable aspects and thus are not appropriate in a browse only setting. It is desirable to eliminate confusing and inappropriate behaviors. In this paper, we construct a taxonomy of portal behaviors and give recommendations to help designers of visualization systems decide which behaviors are intuitive and appropriate for a particular setting.</p><p>So that this analysis can apply as broadly as possible, we model the environment as follows. A visualization environment <ref type="bibr" target="#b2">3</ref> is any system that displays (a portion of) a two-dimensional canvas, called the parent canvas, which contains a set of objects. Some of these objects may be portals, which are special objects that show a portion of another canvas, called the child canvas. Note that the child canvas can be the same as the parent canvas. A concrete example is illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>, which is a screenshot from the DataSplash visualization environment <ref type="bibr" target="#b11">[12]</ref> showing a parent canvas of filled polygons and other objects. The polygons are U.S. states. The three square objects are portals, each located at the coordinates of a major city. Each portal is a sub-window in the parent canvas that shows a portion of a child canvas, which in this case contains a bar chart describing transportation data for the city. Note that, in general, portals can be of any shape.</p><p>In addition to showing a portion of the child canvas, portals can be used for navigation. Many visualization environments allow users to "enter" portals to instantly navigate to the child canvas. For example, entering one of the portals in <ref type="figure" target="#fig_0">Figure 1</ref> causes the corresponding bar chart canvas to become the parent canvas and the bar chart to fill the entire screen. Since portals allow users to instantly navigate to another location and/or another canvas, they can be used to create visual versions of hyperlinks and bookmarks. There are also many other uses for portals. Portals can be used to implement a variety of tools to help the user browse and understand the data being visualized by showing multiple views simultaneously. The views can show different representations of the data, or data at different levels of magnification. For example, magnifying glasses <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13]</ref> show a magnified view of the data below them and can in some cases be repositioned by the user.</p><p>Each portal tool comes in many varieties, depending on how the user is permitted to interact with the tool. For example, the user may or may not be permitted to reposition a magnifying glass. When the user pans and zooms, magnifying glasses can travel with the user or remain fixed relative to the canvas. Furthermore, the user may or may not be allowed to pan and zoom the child canvas inside the magnifying glass. If zooming inside the magnifying glass is allowed, it may change the magnification factor, zoom the entire parent canvas along with the child canvas inside the magnifying glass, automatically resize the magnifying glass, or apply some combination of these effects. Finally, if resizing the magnifying glass is allowed, enlarging it may increase the magnification, or alternatively cause more data to become visible with the same magnification.</p><p>In this paper, we concentrate on the properties that govern which user operations are allowed and which user operations trigger which other operations. Considering only these fundamental properties we have identified, there are 125 possible behaviors for each portal. Enabling all possible behaviors is probably not a good idea for several reasons. First, it is unlikely that the user can be expected to understand all 125 behaviors. Second, some of the behaviors may have confusing effects. Finally, many of the behaviors may simply not be useful or appropriate, depending on the setting. This paper addresses this issue by formally defining the behavior space and proposing a two-step procedure for reducing the behavior space to a handful of intuitive and appropriate behaviors. The first step eliminates behaviors that are confusing. For this purpose we propose a set of rules that can be applied in all settings. The second step eliminates those behaviors that are not appropriate in a particular setting. To illustrate the process of eliminating inappropriate behaviors, we consider a specific example setting-a fully visually programmable environment-and describe rules to be applied. We then analyze the resulting reduced set of behaviors. We omit an exhaustive analysis of possible settings.</p><p>The analysis in this paper focuses uniquely on the binary choice of which user operations trigger which other operations. We do not consider the exact behavior when changes are propagated via triggering. For example, when the user enlarges a magnifying glass, either the same portion of the canvas remains visible but is shown at increased magnification (i.e., no triggering), or a larger portion of the canvas is shown at the same magnification (i.e. triggering). Our analysis addresses which of these two scenarios may occur, but not how much more of the canvas becomes visible nor how much the magnification increases. These issues are orthogonal to the discussion in this paper.</p><p>Others have focused on modeling the way operations are correlated in specific behaviors <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b9">10]</ref>, often using a spatial model. However, we are not aware of any work on enumerating fundamental behaviors. Furthermore, to our knowledge no work has focused on making recommendations for choosing a reduced set of behaviors from the large space of possible behaviors we identify.</p><p>The remainder of this paper is structured as follows. After giving an overview of some useful portal tools in Section 2, we present our model for portals in Section 3, which focuses on a set of fundamental binary properties that determine the portal behavior. To reduce the space of allowed behaviors by eliminating confusing behaviors, we propose rules in Section 4. Next, in Section 5, we describe rules to further reduce the space for an example setting by eliminating inappropriate behaviors, and we analyze the remaining reduced set of behaviors. Section 6 considers a real visualization environment, and demonstrates some problems associated with behaviors that do not conform to the suggested rules. Finally, in Section 7, we discuss avenues for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Portal Tools</head><p>In this section, we give examples of portal tools. We make no claim that this is an exhaustive list of useful tools. Each portal tool comes in many varieties, depending on which aspects are visually programmable by the user and which are not. Since there are so many variations on each tool, each requiring a different behavior, we omit a thorough discussion. Instead, in Section 3, we describe a set of fundamental properties that govern the behavior of a portal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Visual Hyperlinks</head><p>Visual hyperlinks are analogous to hypertext hyperlinks (e.g., between Web pages) in that they allow the user to instantly navigate between a location on one canvas to some location on another canvas. Additionally, visual hyperlinks display the contents of the destination in a sub-window, to provide a "preview" of the destination. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Bookmarks</head><p>Bookmarks are visual hyperlinks that remain on the screen at all times and allow the user to instantly navigate to the location displayed in the bookmark portal. Indexes in Pad++ <ref type="bibr" target="#b2">[3]</ref> are similar to bookmark tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Coordinated Views</head><p>A coordinated view <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15]</ref> is a portal tool that remains on the screen at all times and shows a different representation of the data in the main window. The data shown in the coordinated view corresponds to some region of the main window and is not related to the position of the portal. Coordinated views can be quite useful in applications such as astronomy, medical imaging, comparative cartography, and structural analysis, where data objects have several alternative representations showing different characteristics <ref type="bibr" target="#b14">[15]</ref>. For example, <ref type="figure" target="#fig_1">Figure 2</ref> illustrates a visualization displaying a satellite image in the parent canvas and a street map of the same geographic region in a coordinated view tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Overviews</head><p>An overview is a portal tool that shows a demagnified (zoomed out) copy of the canvas and is fixed on the screen to help orient the user during navigation. In the literature, the combination of overview portal and parent canvas is called an overview and detail view <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Filters</head><p>Filters <ref type="bibr" target="#b12">[13]</ref> show a different graphical representation of the region of the canvas that is occluded by the portal object. Filters are useful for displaying two different representations of the same data. Movable filters are filters that the user is allowed to reposition and resize. Afterward, whatever region of the parent canvas is newly occluded by the filter is instead displayed inside the filter, as the alternative representation. Movable filters allow the user to interactively adjust the region of the canvas being filtered. This can be a useful behavior for a number of reasons outlined in <ref type="bibr" target="#b5">[6]</ref>. Magic Lenses in the See-Through Interface <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b14">15]</ref> and Pad++ <ref type="bibr" target="#b2">[3]</ref>   <ref type="figure">Figure 3</ref>: Two snapshots of a map visualization having a movable magnifying glass with the lens and lens −1 dependencies enabled. The user can go from the before image (left) to the after image (right) either by repositioning the magnifying glass or by panning the magnified image inside the magnifying glass.</p><p>Filters and movable filters can either be canvasstationary or user-stationary. Canvas-stationary filters are stationary relative to the parent canvas, and do not remain with the user during navigation unless the user explicitly moves them. Canvas-stationary filters are often kept positioned near a particular region of the canvas that is interesting to see through a filter. On the other hand, user-stationary filters remain fixed in position and size on the screen during navigation. User-stationary filters are useful when the user wishes to see a filtered view of every part of the canvas visited, possibly in conjunction with the regular, unfiltered view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Magnifying Glasses</head><p>A magnifying glass <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13]</ref> is a portal tool that shows a magnified (zoomed in) view of the region of the canvas underneath. <ref type="bibr" target="#b3">4</ref> Movable magnifying glasses are magnifying glasses that the user is allowed to reposition (and resize). Movable magnifying glasses can help the user see different portions of the canvas in detail without navigating. For example, a movable magnifying glass might be useful when using a map visualization to view street names that are otherwise too small to read without zooming in, as illustrated in <ref type="figure">Figure 3</ref> (the reader should ignore the caption for now, as it contains concepts that have not yet been introduced).</p><p>As with filters, magnifying glasses and movable magnifying glasses can either be canvas-stationary or userstationary. Both types can be useful. For example, consider a map visualization used to convey driving directions between two points. When viewing the entire route in freeway-level detail on the screen, it may be useful to have one canvas-stationary magnifying glass over the starting location and another over the destination showing detailed street maps. Alternatively, consider a document visualization. A user-stationary magnifying glass could be positioned in the center of the screen to facilitate reading text while still displaying the context in the periphery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Hybrid Tools</head><p>Hybrid tools can be created that have properties taken from several portal tools. For example, a magnifying glass/filter hybrid would simultaneously magnify the data and change its representation. Such tools are particularly common in semantic zoom <ref type="bibr" target="#b12">[13]</ref> environments that display different representations of data depending on the magnification level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Portal Model</head><p>In this section we present the model used in this paper. Our model is simple enough to capture the semantics of many environments with portals. <ref type="figure" target="#fig_2">Figure 4</ref> illustrates a side-view of our model, with the user on the left. The vertical line immediately to the right of the user represents the parent canvas. The parent visible frame, or simply parent frame, is the two-dimensional region of the parent canvas displayed on the screen. This frame corresponds to the entire window in <ref type="figure" target="#fig_0">Figure 1</ref>. The parent canvas may contain one or more portals. Each portal has a portal frame, which is a two-dimensional region of the parent canvas. The border of each square in <ref type="figure" target="#fig_0">Figure 1</ref> is a portal frame.</p><p>The vertical line on the right represents the child canvas associated with a portal. Note that each portal in the parent canvas can point to a different child canvas. The child visible frame, or simply child frame, is the twodimensional region of the child canvas that is displayed inside the portal. This frame corresponds to one of the bar charts in <ref type="figure" target="#fig_0">Figure 1</ref>.</p><p>The position and size of each frame can be adjusted by the user. Editing the parent visible frame is accomplished via parent navigation operations, i.e., pan and zoom. Similarly, many environments support child navigation, which allows the user to edit the child visible frame. For example, a user could potentially pan and zoom one of the child canvases in <ref type="figure" target="#fig_0">Figure 1</ref> to enlarge a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User Operation</head><p>Frame Edited parent navigation (panning and zooming in the parent canvas) parent visible frame manipulating (resizing and repositioning) the portal object portal frame child navigation (panning and zooming in the child canvas) child visible frame <ref type="figure">Figure 5</ref>: Summary of which user operations edit which frames.</p><p>portion of the bar chart without affecting the parent canvas.</p><p>In addition to editing the parent and child visible frames via parent and child navigation, a user can edit the portal frame by manipulating the portal object. Recall that a portal can be thought of as a special object that displays another canvas. Some environments permit users to move and resize portal objects in the same manner as other non-portal objects. For example, a user could make one of the portals in <ref type="figure" target="#fig_0">Figure 1</ref> smaller and reposition it. <ref type="figure">Figure 5</ref> summarizes which user operations edit which frames.</p><p>While other models are possible, we believe these three frames represent the minimal set of entities needed to describe what appears on the screen. The parent frame describes what portion of the parent canvas is displayed, the portal frame specifies the position of the portal, and the child frame determines what portion of the child canvas appears inside the portal.</p><p>The three frames in this model can be thought of as having an ordering in terms of conceptual distance from the user. First, the parent visible frame is the closest to the user since it controls what the user sees of the parent canvas. Second, the portal frame is an element of the parent canvas, where it can be manipulated by the user. Third, the child visible frame is the farthest from the user, because editing it requires navigating the child canvas, which is conceptually located beneath the parent canvas. To indicate this order, we write parent visible frame portal frame child visible frame. The order of frames in terms of conceptual distance from the user is a useful concept that we will invoke later in the paper.</p><p>Some environments (e.g., DataSplash <ref type="bibr" target="#b11">[12]</ref>) support multiple levels of nesting, where portals can contain portals, and so on, and thus have additional frames beyond the three discussed. In DataSplash, the user is only permitted to edit the three closest frames (the parent visible, portal, and child visible frames), and cannot edit frames of grandchild portals without first entering the child portal. Therefore, in this paper we consider only the three closest frames. However, our model easily generalizes to environments that permit the user to edit frames of nested portals.</p><p>Now that we have presented our model for portals, we turn to a discussion of portal properties. Although there are a multitude of properties that portals can have, we wish our model to be basic enough to capture the semantics of as many environments with portals as possible. Therefore, our model considers only two types of binary properties, which we consider fundamental, called frame editability, which applies to frames, and frame dependency, which applies to ordered pairs of frames. Each property of either type can be either enabled or disabled. A set of enabled properties is called a behavior. Various instances of the tools discussed in Section 2 can be implemented as portals with different behaviors. We now discuss the editability and dependency properties in turn.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Frame Editability Properties</head><p>It is possible to disallow edits to one or more frames by disabling its editability property. Recall from <ref type="figure">Figure 5</ref> that the parent and child frames are edited by parent and child navigation operations, respectively, and the portal frame is edited by repositioning and resizing the portal object. It is often desirable to disallow edits to certain frames in some behaviors. For example, some behaviors require portals to remain fixed and do not permit users to resize or reposition portals. Therefore, each portal has three binary editability properties, one for each frame. For convenience, we write editable(A) to indicate that a frame A is editable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Frame Dependency Properties</head><p>In the absence of any dependencies between frames, each frame is independent. In other words, editing one frame does not affect the other two frames. For example, making one of the portals in <ref type="figure" target="#fig_0">Figure 1</ref> smaller does not affect the child visible frame, which remains the same size. Thus, the same child frame (the entire bar chart) will be displayed in the now smaller portal frame. <ref type="bibr" target="#b4">5</ref> Frame dependencies are properties that cause one frame to change automatically when the user edits another frame. Dependencies are one-way links between ordered pairs of frames, of which there are six. Each dependency can either be enabled or disabled. If a dependency from frame A to frame B (written A → B) is enabled, whenever the user edits the position and/or size of frame A, the position and/or size of frame B changes automatically. Of course, a dependency A → B cannot be enabled unless frame A is editable. On the other hand, even if frame B is not editable, the dependency can be used. Editability only restricts direct editing, while still allowing indirect editing via frame dependencies. For notational convenience, we write A ❀ B if a (possibly empty) chain of dependencies is enabled from frame A to frame B. Note that since editing a frame always changes it, A → A and A ❀ A are trivially true for any frame A.</p><p>There are six possible frame dependencies in our three-frame model. We classify the dependencies into forward and reverse dependencies. A dependency A → B is forward if A B, and reverse otherwise. Each forward dependency A → B has an inverse, B → A that is a reverse dependency. Conversely, the inverse of a reverse dependency is a forward dependency. It is useful to think of the frame dependency properties <ref type="bibr" target="#b4">5</ref> For the purposes of this paper, we assume that the shape of the child visible frame must be the same as the shape of the portal frame. When these frames are rectangles, the aspect ratios must be equal. of a portal as a directed graph with three vertices, one for each frame (parent visible, portal, and child visible). An edge from frame A to frame B means that the frame dependency A → B is enabled. <ref type="figure">Figure 6</ref> shows a graph for the behavior with all the frame dependencies enabled.</p><p>The nodes are displayed in order of conceptual distance from the user, from left to right. Each edge in the graph is labeled with the name we give to the corresponding dependency. Next, we describe the three forward dependencies (which we call sticky, s-nav, and lens) and their inverses (sticky −1 , s-nav <ref type="bibr">−1</ref> , and lens −1 ) in Sections 3.2.1, 3.2.2, and 3.2.3. Then, in Section 3.3, we describe dependency mappings, which specify the exact way in which editing a frame automatically changes a dependent frame.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Sticky and Sticky −1 Dependencies</head><p>We refer to the dependency parent visible frame → portal frame as the sticky dependency, which can be used to make portals "stick to the screen" <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. In this scenario, when the user edits the parent frame (e.g., by panning and zooming), the portal frame changes so that its size and position relative to the parent frame remain constant. The sticky dependency is useful for portals that are intended to remain on the screen at all times. <ref type="bibr" target="#b5">6</ref> The sticky −1 dependency is the inverse of the sticky dependency: portal frame → parent visible frame. This dependency is useful when moving a portal should automatically change the parent frame. This dependency is often temporarily applied when the user drags an object off the edge of the screen, allowing the parent frame to follow the drag. For the sake of simplicity, in this paper we limit ourselves to behaviors that arise from permanently enabling the sticky −1 dependency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">S-nav and S-nav −1 Dependencies</head><p>We refer to the dependency parent visible frame → child visible frame as the s-nav dependency (for synchronous navigation), which can be used to apply navigation performed in the parent canvas to the child canvas (possibly with a transformation) <ref type="bibr" target="#b15">[16]</ref>. In other words, navigating the parent canvas causes the child canvas inside the portal to automatically navigate. This dependency is useful for portals whose view is somehow linked to the view of the parent, as in coordinated views (Section 2.3) and certain varieties of other tools.</p><p>The s-nav −1 dependency is the inverse of the s-nav dependency: child visible frame → parent visible frame. In certain behaviors, navigation in the child canvas automatically navigates the parent. Some varieties of coordinated views and other tools use this effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Lens and Lens −1 Dependencies</head><p>We refer to the dependency portal frame → child visible frame as the lens dependency, which creates behaviors where editing the portal frame affects which part of the child canvas is displayed inside the portal. This dependency is useful for movable filters and magnifying glasses (see Sections 2.5 and 2.6).</p><p>The lens −1 dependency is the inverse of the lens dependency: child visible frame → portal frame. When the lens −1 dependency is enabled, navigating the child canvas inside the portal changes the portal's position and/or size on the surface of the parent canvas. This dependency can be used for many purposes, including to create a variety of movable filters in which panning the child canvas to change the region being filtered automatically repositions the filter above the corresponding region in the parent canvas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Dependency Mappings</head><p>When a dependency A → B is enabled, it is useful to think of the relationship between frames A and B as a dependency mapping from edits by the user of frame A to changes automatically performed on frame B. Although a detailed discussion of dependency mappings is beyond the scope of this paper, which focuses instead on the binary choice of which dependencies are enabled, we give a short illustrative example.</p><p>Consider a magnifying glass with the lens dependency enabled. One interesting dependency mapping for the lens dependency might have, among other things, the following characteristic. If the user enlarges the magnifying glass (portal frame), then the region of data displayed inside the magnifying glass (child frame) also enlarges. Such a mapping could be used to maintain a fixed ratio between the portal frame and child frame sizes, to hold the magnification factor constant. In this situation, the magnification factor is a parameter in the dependency mapping.</p><p>Ideally, we would like our analysis in this paper to be orthogonal to the choice of dependency mappings, since we concentrate on the binary choice of enabling or disabling each dependency. However, we do make two minor restrictions on dependency mappings to simplify our analysis without loss of applicability. It is our belief that systems that do not meet these restrictions have unintuitive and undesirable behaviors. Specifically, we only consider environments that obey mapping transitivity and mapping inversion, which we discuss next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Mapping Transitivity</head><p>In environments with mapping transitivity, if dependencies X → Y , Y → Z, and X → Z are enabled, then the mapping for the X → Z dependency is the composition of the mappings for X → Y and Y → Z. In general, the composition of mappings along any path from X to Z must produce the same mapping as X → Z. We say that a dependency X → Z is derivable via transitivity if there is a path X ❀ Z other than X → Z. This means that the mapping for X → Z can be derived by composing a sequence of mappings for dependencies from X to Z.</p><p>Environments that do not employ mapping transitivity can allow confusing behaviors. Consider a behavior with the following three dependencies: X → Y , Y → Z, and X → Z. Editing X to X automatically changes Y to Y and Z to Z . If mapping transitivity is not employed, then manually editing Y to Y can change Z to something other than Z . This is counter intuitive.</p><p>As a concrete example, consider a behavior with dependencies parent → portal (sticky), portal → child (lens), and parent → child (s-nav). Say that moving the portal to the right by one unit automatically pans the child canvas to the right by some amount x. The user can also cause the portal to move one unit to the right indirectly via the sticky dependency by panning the parent. Without mapping transitivity, doing so pans the child canvas by some amount other than x. This effect is confusing because intuitively the user expects the child canvas to pan by x, which would occur if they had moved the portal directly.</p><p>On the other hand, with mapping transitivity, the s-nav mapping is derivable from the sticky and lens mappings. In this case, whenever the portal is moved (either directly, or indirectly by panning the parent), the same effect is manifest on the child frame. This effect is determined solely by the lens dependency mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Mapping Inversion</head><p>In environments with mapping inversion, if a dependency A → B is enabled in conjunction with its inverse (B → A), then the two mappings are inverses of each other. In other words, when two frames are codependent, the user can directly edit either frame to produce the same effect.</p><p>Having two frames that are co-dependent without mapping inversion is confusing. For example, consider the canvas with a coordinated view illustrated in <ref type="figure" target="#fig_1">Figure 2</ref>. Say the user pans the satellite image (parent canvas) to the right by one kilometer, which causes the street map (child canvas) inside the coordinated view to pan to the right by 0.625 miles. Without mapping inversion, manually panning the street map to the right by 0.625 miles does not pan the satellite image to the right by one kilometer, as would be expected when the parent and child frames are co-dependent.</p><p>Mapping inversion can be seen as a special case of mapping transitivity. Consider two co-dependent frames A and B. By mapping transitivity, the mapping along the path A → B → A must equal the mapping for A → A, which is the identity mapping.</p><p>We say that a dependency A → B is derivable via inversion if the inverse dependency B → A is enabled. This means that the mapping for A → B can be derived from the mapping for B → A by inverting it. Note that whenever a dependency and its inverse are both enabled, they are always mutually derivable via inversion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Reducing the Number of Behaviors</head><p>The behavior of a portal is defined by the set of frame editability and frame dependency properties that are enabled. We count the number of possible behaviors, keeping in mind that a dependency A → B cannot be enabled unless frame A is editable. First, if none of the frames are editable, the only valid behavior has no dependencies. Second, if any one of the three frames is editable, it is possible to select any subset of the two outgoing dependencies from the enabled frame, for a subtotal of 3•2 2 behaviors with any one frame editable. Third, if any two of the three frames are editable, then any subset of the four outgoing dependencies from the two enabled frames can be selected, giving 3 Presenting the user with a choice of any possible behavior for each portal is probably not a good idea for several reasons. First, it is unlikely that the user can be expected to understand all 125 behaviors. Second, some of the behaviors may have confusing effects. Finally, many of the behaviors may not be appropriate, depending on the setting.</p><p>In the remainder of this section, we present a set of rules that eliminate confusing behaviors in all settings. Then, in Section 5, we focus on a specific example setting and discuss ways to further limit the space to behaviors that are appropriate for the particular setting we consider.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Dependency Transitivity</head><p>We recommend enforcing dependency transitivity. In a behavior that is not dependency transitive, when the user explicitly edits frame Y , frame Z automatically changes, but when the user edits some other frame X that automatically changes Y , frame Z does not change. This is counterintuitive.</p><p>For example, consider a behavior that is not dependency transitive with only dependencies parent → portal <ref type="figure">Figure 7</ref>: A behavior with bypassing as the user pans upward in the parent canvas.</p><p>and portal → child enabled. Moving the portal automatically pans the child canvas, and panning the parent automatically moves the portal but does not pan the child canvas. Since behaviors that do not obey dependency transitive are unintuitive, we recommend the use of the following rule:</p><formula xml:id="formula_0">Dependency Transitivity Rule: ∀X, Y, Z((X → Y ) ∧ (Y → Z) ⇒ (X → Z))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">No Bypassing</head><p>We strongly believe that bypassing can be confusing for the user. Recall from Section 3 that frames have an order based on conceptual distance from the user. Bypassing occurs when editing one frame automatically changes a closer or farther frame without changing an intermediate frame.</p><p>The No Bypassing rule states that no dependency can bypass a frame in the conceptual distance order. In other words, if editing one frame automatically changes a closer or farther frame, then it must also change all frames in between.</p><p>For example, consider a behavior where the only enabled dependency is parent → child (s-nav). <ref type="figure">Figure 7</ref> illustrates the effect of panning upward in the parent canvas. The portal frame remains stationary relative to the other objects in the parent canvas, yet the child canvas inside the portal pans. This behavior can be quite confusing, so we suggest the following rule:</p><formula xml:id="formula_1">No Bypassing Rule: ∀X, Y, Z((X → Z) ∧ ((X Y Z) ∨ (Z Y X)) ⇒ (X → Y ))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Only Forward Derivable Reverse Dependencies</head><p>Behaviors with reverse dependencies are usually confusing. In general, users expect edits of a frame to propagate to more distant frames via forward dependencies, but not the other way around. However, reverse dependencies can make sense when they are derivable via transitivity or inversion (recall Sections 3.3.1 and 3.3.2) from some sequence of dependencies that includes a forward dependency. When this is the case, we say that a reverse dependency is forward derivable, written formally as:</p><formula xml:id="formula_2">forward-derivable(B → A) ⇔ (A → B) ∨ ∃X 1 , X 2 , . . . X k ((X 1 = B) ∧ (X k = A) ∧ ∀1 ≤ i ≤ k − 1(X i → X (i+1) ) ∧ ∀1 ≤ i ≤ k, 1 ≤ j ≤ k(X i = X j ) ∧ ∃1 ≤ i ≤ k − 1(X i X (i+1) )).</formula><p>Since the user is aware of the forward dependency, the reverse dependency from which it is derived does not come as a surprise. The notion that behaviors with nonforward derivable reverse dependencies are confusing is best illustrated through three examples. The first two examples describe intuitive behaviors with reverse dependencies that are forward derivable via inversion and transitivity, respectively. The third example illustrates a confusing behavior with a reverse dependency that is not forward derivable. First, we describe an intuitive behavior with a reverse dependency that is forward derivable via inversion. Consider a behavior with both the lens and lens −1 dependencies enabled. Clearly, the lens −1 dependency is derivable from the lens dependency via inversion (Section 3.3.2). In this behavior, repositioning the portal automatically pans the child canvas inside (as with a movable magnifying glass). If the user manually pans the child canvas, the portal is automatically repositioned appropriately. <ref type="figure">Figure 3</ref> illustrates an example display before and after performing either of these operations to a movable magnifying glass in a map visualization. This is an intuitive behavior because changing what region is displayed inside the magnifying glass automatically repositions the magnifying glass over the corresponding region of the map.</p><p>We now describe an intuitive behavior with a reverse dependency that is forward derivable via transitivity. Consider the behavior whose dependency graph is illustrated in <ref type="figure">Figure 8</ref> having the sticky, s-nav, s-nav −1 , and lens −1 dependencies enabled. The lens −1 dependency is derivable from the s-nav −1 and sticky dependencies via transitivity (Section 3.3.1). In this behavior, panning the parent canvas automatically moves the portal frame and pans the child canvas (as with a coordinated view). In addition, panning the child canvas automatically pans the parent canvas and moves the portal frame in the same manner as if the parent had been panned manually. Intuitively, panning the child produces the same effect as panning the parent (via the s-nav −1 dependency), which among other things moves the portal frame (via the sticky dependency). <ref type="figure">Figure 9</ref> illustrates the display before and after repositioning a coordinated view tool (top) and panning left in either the parent or child canvas (bottom).</p><p>Now that we have presented two examples of intuitive behaviors with forward derivable reverse dependencies, we give an example of a confusing behavior with a reverse dependency that is not forward derivable. Con- <ref type="figure">Figure 9</ref>: Two sequences of snapshots of a visualization having a coordinated view with the sticky, s-nav, snav −1 , and lens −1 dependencies enabled. The top two snapshots illustrate the display before and after repositioning the coordinated view portal. The bottom two snapshots illustrate the display before and after panning left in either the parent or the child canvas. sider the behavior with only the lens −1 dependency enabled. Repositioning the portal has no effect on the child canvas inside (as with a visual bookmark). However, panning the child canvas automatically moves the portal. <ref type="figure" target="#fig_0">Figure 10</ref> illustrates the display before and after repositioning the portal (top) and panning the child canvas to the right (bottom). This is effect is counter-intuitive. The user has no reason to expect panning the child canvas to have any reverse effects like moving the portal, because the lens −1 dependency is not forward derivable.</p><p>Since behaviors with underivable reverse dependencies are confusing, we propose the following rule: Only Forward Derivable Reverse Dependencies Rule:</p><formula xml:id="formula_3">∀X, Y ((X Y ) ∧ ¬forward-derivable(Y → X) ⇒ ¬(Y → X))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Example Setting</head><p>Applying the usability rules presented in Section 4 reduces the size of the behavior space from 125 potential behaviors to 32 intuitive behaviors. We omit a detailed discussion of all intuitive behaviors. Not all of these behaviors are appropriate in every setting. In this section we describe additional rules to further reduce the set of behaviors for a visualization environment that permits the user to edit any frame and to visually program any dependency mapping.</p><p>Given a mapping M , user edits that alter M can be thought of as programming M , and edits that do not alter M can be thought of as browsing with respect to M . Consider two frames A and B with the dependency A → B enabled using mapping M , and no other dependencies among frames. Editing frame B does not affect frame A, and thus programs the relationship between frames A and B: mapping M . On the other hand, editing frame A causes frame B to be changed according to the mapping and does not alter the mapping. Therefore, editing A is considered browsing with respect to M .</p><p>For example, consider a magnifying glass with the lens dependency enabled and the lens −1 dependency disabled. A dependency mapping for the lens dependency <ref type="figure" target="#fig_0">Figure 10</ref>: Two sequences of snapshots of a visualization having a portal with only the lens −1 dependencies enabled, which is not forward derivable. The top two snapshots illustrate the display before and after repositioning the coordinated view portal. The bottom two snapshots illustrate the display before and after panning the child canvas to the right. might cause the child frame to be automatically enlarged when the user enlarges the portal frame. The ratio of the portal frame to parent frame sizes is a parameter in the lens dependency mapping that controls the magnification factor, as discussed in Section 3.3. Since the lens −1 dependency is disabled, editing the child frame does not affect the portal frame, and thus programs the magnification factor.</p><p>In the fully programmable setting, we would like every dependency to be programmable, meaning that there is a way for the user to program its dependency mapping. A dependency is programmable if the dependent frame is editable and the inverse dependency is disabled. Enabling the inverse dependency would cause the two frames to be co-dependent, so that no edits could alter the relationship between frames. Note that although inverse dependencies are undesirable in this setting, they are useful in other settings with browse-only characteristics.</p><p>It is also desirable for all dependencies to be independently programmable, meaning that programming its mapping does not also program any other mapping. In mapping transitive environments (which we consider in this paper as discussed in Section 3.3), a dependency A → B is independently programmable if all mappings for dependencies pointing to B are derivable via transitivity from each other. In this case, all dependency mappings pointing to B are really just incarnations of the same mapping, which can be programmed independently of other mappings that do not point to B. The formal rule for enforcing independent programmability of a dependency A → B is: Independent Programmability Rule for A → B:</p><formula xml:id="formula_4">(A → B) ⇒ editable(B) ∧ ¬(B → A) ∧ ∀X((X → B) ⇒ (X ❀ A) ∨ (A ❀ X))</formula><p>To obtain a reduced set of behaviors for a fully editable and independently programmable environment, we start by applying our usability rules suggested in Section 4, which reduces the size of the behavior space to 32 intuitive behaviors. To further reduce the set of allowed behaviors in this setting, we start by asserting that all frames are editable, which results in 11 behaviors. Then, we apply the Independent Programmability rule to each pair of frames, which leaves the following set of five behaviors that are intuitive and fully editable and have all dependencies independently programmable: In this reduced set of behaviors, all dependencies are uni-directional since this setting requires independent programmability of all dependencies, and they are forward since our usability rules do not permit underivable reverse dependencies. Our usability rules also eliminate the behaviors {s-nav} and {s-nav, lens}, which both exhibit bypassing, and {sticky, lens}, which violates dependency transitivity. We now turn to a discussion of the five allowed behaviors.</p><p>Behavior 1 has no dependencies, and can be used to implement visual hyperlinks (Section 2.1). Behavior 2 can be used to construct bookmarks (Section 2.2).</p><p>Coordinated views (Section 2.3) and overview tools (Section 2.4) use Behavior 3. The sticky dependency ensures that the portal frame is always in the same position relative to the parent visible frame, i.e., is fixed on the screen. Using the s-nav dependency with the identity mapping, the child visible frame always shows the same set of objects as the parent visible frame, giving rise to a coordinated view. Alternatively, using a different s-nav dependency mapping that causes the child visible frame to be larger than the parent visible frame, we have an overview tool.</p><p>Finally, Behaviors 4 and 5 can be used to construct movable filters (Section 2.5) and movable magnifying glasses (Section 2.6). The lens dependency maps changes to the portal frame to changes to the child visible frame so that moving or resizing the portal changes which part of the child canvas is filtered or magnified. Using Behavior 4, the filter or magnifying glass is canvas-stationary, since its size and position is static relative to the parent canvas, independent of navigation. Alternatively, using Behavior 5, the filter or magnifying glass is user-stationary, so it remains fixed on the screen.</p><p>Each of these behaviors is fully and independently programmable. To see this, consider the most restrictive case of Behavior 5, where all three forward dependencies are enabled. The sticky mapping is programmed by editing the portal frame, and the lens mapping is programmed by editing the child visible frame. Since mapping transitivity is employed, the s-nav mapping is defined as the composition of the sticky and lens mappings and is not a separate mapping available for programming. Therefore, Behavior 5 is fully and independently programmable, as are the other behaviors with fewer dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Case Study: DataSplash</head><p>The authors of this paper were involved in the DataSplash prototype implementation <ref type="bibr" target="#b11">[12]</ref> as part of the Tioga project at UC Berkeley <ref type="bibr" target="#b13">[14]</ref>. The DataSplash prototype was designed and implemented before the analysis of this paper was conducted. Therefore, it does not conform to all of the rules outlined here. We discuss the behaviors allowed in DataSplash, and show that in cases where the rules in the paper were not followed, behaviors can be undesirable.</p><p>DataSplash employs mapping transitivity and mapping inversion, and allows the following set of six behaviors, the last two of which violate dependency transitivity: Behavior 3, illustrated in <ref type="figure">Figure 8</ref>, was discussed in Section 4.3 and has two forward derivable reverse dependencies. It is similar to Behavior 3 in the fully programmable setting and can be used to construct coordinated views and overviews that have an independently programmable sticky dependency. However, the s-nav dependency mapping, e.g., the demagnification factor of an overview tool, is not programmable since the parent and child frames are co-dependent.</p><p>Behavior 5 is inconsistent and confusing because it violates the Dependency Transitivity rule, which was recommended for usability in Section 4.1. The user can edit the portal, causing the child to automatically navigate. However, if the user pans or zooms the parent, the portal follows the user, but the child does not automatically navigate. Another way to see how this is problematic is that the dependency mapping initially set up between the portal frame and child frame (e.g., making them the same for a movable filter) is destroyed when the user navigates the parent. Our experience with the DataSplash prototype confirms this lack of usability. Behavior 5 was never used. Behavior 6, illustrated in <ref type="figure" target="#fig_0">Figure 11</ref>, also violates dependency transitivity. Since editing the portal frame automatically changes the child frame but does not also change the parent frame, it does not make sense that editing the child frame should change the parent frame. For example, consider a magnifying glass. Moving the magnifying glass around has the expected effect: it causes a magnification of the region of the canvas underneath the repositioned magnifying glass to appear in the magnifying glass. Panning the magnified region not only automatically repositions the magnifying glass, but also pans the parent. The latter effect can be surprising and confusing.</p><p>One way to convert Behavior 6 into a less confusing behavior is to remove the s-nav −1 dependency. This more intuitive behavior can be used for movable magnifying glasses whose lens dependency is not programmable. When the user pans the child inside the magnifying glass, the magnifying glass moves so as to remain correctly positioned relative to the parent canvas. Similarly, when the user zooms the child inside the magnifying glass, the magnifying glass automatically resizes to maintain the same magnification factor.</p><p>In practice, Behavior 6 was effectively converted into a less confusing behavior in another way. While experimenting with the DataSplash prototype, we never edited the child frame directly for portals using Behavior 6 because it was confusing. Thus, child frame editability was effectively disabled. Notice that if we remove child editability from Behavior 6, the s-nav −1 and lens −1 dependencies become meaningless and are removed, and the behavior no longer violates transitivity and is similar to fully programmable Behavior 5 (see Section 5), but with child editability disabled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Summary and Future Work</head><p>In this paper, we presented a model for portals and fundamental binary properties that govern their behavior and gave examples of useful tools that come in many varieties with different properties. Since the space of possible behaviors is quite large, we introduced rules that can be applied to eliminate confusing behaviors. We then suggested additional rules to apply to eliminate inappropriate behaviors for an example setting and examined the resulting reduced set of behaviors. Finally, we analyzed the set of behaviors available in a real visualization environment, focusing on behaviors that violate our rules and the resulting adverse effects.</p><p>There are numerous avenues for future work in this area. First, we plan to explore models for dependency mappings. Some models for displaying portals treat the portal frame as a physical window, where moving closer enlarges the visible area of the child. With other models, portals are like hanging pictures rather than windows in this respect.</p><p>In addition, we plan to consider environments that permit partial editability (e.g., where panning is permitted but not zooming), and partial programming of dependencies (e.g., where zooming the child of a magnifying glass changes the magnification, but panning does not change the magnified region). Furthermore, we plan to consider environments where frame editability and dependency programmability are temporary states, rather than static properties of a behavior.</p><p>Some environments support replicated portals <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5]</ref> (called "splash" portals in DataSplash <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>). Portals can be automatically replicated, one for each data item in a data set. For example, <ref type="figure" target="#fig_0">Figure 1</ref> shows a map visualization of the U.S. states (the filled polygons) in which a replicated portal displays a bar chart for each major city. In some cases, it may be desirable to have dependencies between child frames of replicated portals, so that navigating one portal automatically navigates others. We plan to study the interaction of dependencies between child frames and the dependencies discussed in this paper, such as the s-nav dependency.</p><p>Finally, since portals are so complex, more work remains to be done on intuitive ways to convey to the user the behavior and dependency mappings of each portal.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>An example DataSplash visualization with portals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>A visualization showing a satellite image in the parent canvas and a street map in a coordinated view tool.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Portal model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 Figure 6 :</head><label>16</label><figDesc>A graph of the behavior having all the frame dependencies enabled. The nodes are displayed in order of conceptual distance from the user, from left to right. The name of each dependency is shown next to its corresponding edge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>2 4 behaviors. Finally, if all three frames are editable, there are 2 6 behaviors. Summing up the possibilities, there are 1•2 0 +3•2 2 +3•2 4 +1•2 6 = 125 different behaviors, considering only the frame editability and frame dependency properties.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 Figure 8 :</head><label>18</label><figDesc>A graph of DataSplash Behavior 3, which has all reverse dependencies derivable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 Figure 11 :</head><label>111</label><figDesc>A graph of DataSplash Behavior 6, which violates dependency transitivity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>are movable filter tools. Shattuck Ashby Virginia La Loma Shattuck Ashby Hearst Virginia Hearst La Loma Rose Rose</head><label></label><figDesc></figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">Although we use the term "visualization environment" throughout this paper, our analysis also applies more generally to multiple view systems that contain views that are related (usually via an underlying spatial model).</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">We draw a distinction between filters (which show a different graphical representation of a given region of a canvas) from magnifying glasses (which show a larger or smaller region of a canvas). We discuss hybrid tools in the following subsection.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6">This property and its inverse can also be applied to objects other than portals. For example, shapes such as triangles or circles may be sticky.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the other members of the DataSplash research group at UC Berkeley: Alexander Aiken, Michael Chu, Vuk Ercegovac, Mark Lin, Mybrid Spalding, and Michael Stonebraker. They provided many useful discussions. We also thank Ed Chi and Jock Mackinlay for helpful feedback.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">IVEE: An information visualization and exploration environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ahlberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wistrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Information Visualization Symposium (InfoVis &apos;95)</title>
		<meeting>the First Information Visualization Symposium (InfoVis &apos;95)<address><addrLine>Atlanta, Georgia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Tioga-2: A direct manipulation database visualization environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Data Engineering</title>
		<meeting>the 12th International Conference on Data Engineering<address><addrLine>Louisiana</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-02" />
			<biblScope unit="page" from="208" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Pad++: A zoomable graphical sketchpad for exploring alternate interface physics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Hollan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Perlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Furnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Visual Languages and Computing</title>
		<imprint>
			<date type="published" when="1996-03" />
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="3" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Jazz: An extensible 2D+ zooming graphics toolkit in java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mcalister</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-05" />
		</imprint>
		<respStmt>
			<orgName>University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">CrossGraphs: Multidimensional graphical reporting and data visualization. White paper, Belmont Research</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Belmont</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Toolglass and magic lenses: The see-through interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Bier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Stone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGGRAPH Computer Graphics Annual Conference Series</title>
		<meeting>the ACM SIGGRAPH Computer Graphics Annual Conference Series<address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="73" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<title level="m">formation Visualization: Using Vision to Think</title>
		<meeting><address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan-Kaufmann</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="285" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An interactive visualization environment for data exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Derthick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Kolojejchick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">F</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>the Third International Conference on Knowledge Discovery and Data Mining<address><addrLine>Newport Beach, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="2" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Integrated querying and visual exploration of large datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Donjerkovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lawande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Myllymaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wenger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>De-Vise</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Tucson, Arizona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05" />
			<biblScope unit="page" from="301" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Snap-together visualization: A user interface for coordinating visualizations of a relational database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Working Conference on Advanced Visual Interfaces</title>
		<meeting>the 5th International Working Conference on Advanced Visual Interfaces<address><addrLine>Palermo, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">VIQING: Visual Interactive QueryING</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th IEEE Symposium on Visual Languages</title>
		<meeting>the 14th IEEE Symposium on Visual Languages<address><addrLine>Halifax, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-09" />
			<biblScope unit="page" from="162" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ercegovac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spalding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Datasplash</surname></persName>
		</author>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="page" from="550" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pad: An alternative approach to the computer interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Perlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Computer Graphics and Interactive Techniques</title>
		<meeting>the 20th International Conference on Computer Graphics and Interactive Techniques<address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">DataSplash: A database visualization environment developed by the UC Berkeley Tioga project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spalding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
		<ptr target="http://datasplash.cs.berkeley.edu" />
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The movable filter as a user interface tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Stone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fishkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Bier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCHI Conference on Human Factors in Computing Systems</title>
		<meeting>the ACM SIGCHI Conference on Human Factors in Computing Systems<address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-04" />
			<biblScope unit="page" from="306" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Navigation and coordination primitives for multidimensional browsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wisnovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd IFIP 2.6 Working Conference on Visual Database Systems</title>
		<meeting>the 3rd IFIP 2.6 Working Conference on Visual Database Systems<address><addrLine>Lausanne, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-03" />
			<biblScope unit="page" from="360" to="371" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
