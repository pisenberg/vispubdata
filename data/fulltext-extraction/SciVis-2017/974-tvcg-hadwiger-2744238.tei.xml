<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SparseLeap: Efficient Empty Space Skipping for Large-Scale Volume Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Hadwiger</surname></persName>
							<email>markus.hadwiger@kaust.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><forename type="middle">K</forename><surname>Al-Awami</surname></persName>
							<email>ali.awami@kaust.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johanna</forename><surname>Beyer</surname></persName>
							<email>jbeyer@seas.harvard.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Agus</surname></persName>
							<email>marco.agus@kaust.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanspeter</forename><surname>Pfister</surname></persName>
							<email>pfister@seas.harvard.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">King Abdullah University of Science and Technology (KAUST)</orgName>
								<address>
									<postCode>23955-6900</postCode>
									<settlement>Thuwal</settlement>
									<country key="SA">Saudi Arabia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">John A. Paulson School of Engineering and Applied Sciences at</orgName>
								<orgName type="institution">Harvard University</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SparseLeap: Efficient Empty Space Skipping for Large-Scale Volume Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/TVCG.2017.2744238</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Empty Space Skipping</term>
					<term>Volume Rendering</term>
					<term>Segmented Volume Data</term>
					<term>Hybrid Image/Object-Order Approaches</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Comparison of empty space skipping methods. Bold rays denote where the volume is sampled; dots depict look-ups for empty space skipping. (a) No empty space skipping: everything is sampled; (b) Standard rasterization of non-empty bounding geometry allows skipping empty space before the first and behind the last non-empty sample, but samples everything in-between. (c) Octree empty space skipping incurs many tree traversal steps in the fragmented space around fine-grained structures. (d) SparseLeap skips long segments of empty space even around intricate structures, rasterizing geometry into per-pixel linked lists of ray segments.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>In volume rendering, a significant part of the computational effort goes into computing a large number of samples from the underlying scalar field. Therefore, one of the most important basic performance optimizations is trying to avoid sampling empty space, i.e., regions where the samples do not contribute to the volume rendering integral. This process is usually called empty space skipping or space leaping <ref type="bibr" target="#b8">[6]</ref>.</p><p>In recent years, advances in data acquisition techniques have tremendously increased the resolution, size, and complexity of the volume data that need to be visualized. One example are high-resolution microscopy volumes, where the individual voxels can be on the order of micrometers down to a few nanometers in resolution. In neuroscience, for example, the corresponding volume data sets can be multiple to hundreds of terabytes in size <ref type="bibr" target="#b16">[14]</ref>. Often, such volumes contain finely detailed structures, such as axons and dendrites of brain tissue <ref type="bibr" target="#b4">[2]</ref> or thin blood vessels <ref type="bibr" target="#b33">[31]</ref>. However, large volumes containing intricate structures pose a huge challenge to empty space skipping.</p><p>Standard empty space skipping techniques, such as those based on octrees, perform well for relatively large connected areas classified as either fully empty or fully non-empty. However, fine-grained, non-homogeneous regions can lead to severe performance problems when fine structures cause the surrounding space to be subdivided very finely, as depicted in <ref type="figure">Fig. 1(c)</ref>. We refer to this as the fragmentation of space incurred by a space subdivision such as an octree, which can ultimately lead to very high costs for skipping empty space.</p><p>SparseLeap. We propose the novel SparseLeap method for efficient empty space skipping in GPU volume rendering. SparseLeap is a hybrid object-order (rasterization) / image-order (ray-casting) approach that retains high performance even for large volumes containing fine, intricate structures, because it avoids unnecessary fragmentation of space. Balancing the overall load between object-order and imageorder stages allows us to combine the advantages of both worlds.</p><p>Our method comprises several key components: First, we introduce an occupancy histogram tree that hierarchically tracks three occupancy classes for volume regions: empty, non-empty, and unknown (Sec. 5). Second, we describe a traversal algorithm for the occupancy histogram tree that extracts view-independent occupancy geometry of nested bounding boxes only where the occupancy class changes (Sec. 6). This significantly reduces the fragmentation of space. Third, we introduce ray segment lists, which are per-pixel linked lists of consecutive segments of differing occupancy class. These lists are generated by rasterizing the occupancy geometry, while merging successive segments of the same class, such as several consecutive empty segments, into a single segment (Sec. 7). Finally, empty space skipping during ray-casting is now a simple linear list traversal that skips "aslong-as-possible" empty ray segments without hierarchy traversal. <ref type="figure">Fig. 2</ref>. Empty space skipping for large, finely detailed volume data. Large volumes are often sparse and contain thin structures with many individual objects. This leads to highly fragmented empty regions, which makes empty space skipping via tree traversal inefficient because of many small incremental skips. Our SparseLeap method enables efficient fine-grained empty space skipping for such sparse volumes with fragmented empty regions using a hybrid object/image-order approach. (a) and (b): more than 4, 000 segments in the SEM Mouse Cortex volume; (c) and (d): a subset of less than 100 segments; (a) and (c) show the volume rendering; (b) and (d) also show our occupancy geometry (green and red boxes).</p><p>Contributions. In this paper we make several key contributions: (1) A novel method for efficient empty space skipping in large, complex data sets that significantly reduces the fragmentation of space that usually occurs when skipping fine-grained structures in a volume.</p><p>(2) The design and implementation of efficient algorithms and data structures that combine the advantages of object-and image-order approaches that allow empty space skipping during ray-casting without hierarchy traversal. (3) A performance evaluation of SparseLeap, and a comparison to standard octree-based empty space skipping on several large volume data sets with different levels of sparsity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND ON EMPTY SPACE SKIPPING</head><p>The goal of empty space skipping is to exclude regions in the volume from sampling that are classified as empty, i.e., regions that are not contributing to the output image. How this can be done depends on the (often hierarchical) volume subdivision employed, as well as on the actual volume rendering method, such as ray-casting or texture slicing, using either a single-pass or a multi-pass rendering approach.</p><p>Image-order empty space skipping. State-of-the-art image order volume rendering methods, such as GPU octree ray-casting <ref type="bibr" target="#b5">[3]</ref>, follow each ray from tree node to tree node. Nodes that are marked as empty can simply be skipped. These decisions are often computed for each ray independently, without exploiting coherence between rays or between successive rendering frames, which is typical for GPU raycasters <ref type="bibr" target="#b7">[5,</ref><ref type="bibr" target="#b13">11]</ref>. Even more importantly, for volumes with thin structures (e.g., the neurites in <ref type="figure">Fig. 2</ref>), octrees subdivide space very finely, and many spatially adjacent nodes will have the same type (empty or non-empty). The corresponding high level of tree refinement forces ray traversal to proceed in unnecessarily small spatial increments. See <ref type="figure">Fig. 1(c)</ref>. This large overhead makes empty space skipping inefficient, and significantly reduces the potential performance improvement. Spatial subdivisions that are able to adapt better to thin structures, such as kd-trees, can alleviate these problems, but are rarely used in practice <ref type="bibr" target="#b5">[3]</ref>, because their subdivision is extremely dependent on the spatial locations of non-empty voxels. If the transfer function or the active set of segmented objects changes frequently, adapting a kd-tree to the new spatial characteristics is not feasible in real time.</p><p>Object-order empty space skipping. An alternative to putting almost all of the computational load on the ray traversal stage (e.g., the GPU fragment shader) is to move some of this load into a preceding object order stage. In volume rendering, two approaches are common <ref type="bibr" target="#b5">[3]</ref>: (1) Multi-pass out-of-core volume rendering often subdivides the volume into relatively large bricks, and each brick is rendered separately <ref type="bibr" target="#b9">[7]</ref>. Empty bricks are simply excluded from rendering. This approach is usually restricted to a very coarse granularity, i.e., large bricks, due to the large overhead of multiple rendering passes. <ref type="bibr" target="#b4">(2)</ref> Rasterization of approximate bounding geometry allows the ray-casting stage to exclude some empty space <ref type="bibr" target="#b3">[1,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b50">48]</ref>. See <ref type="figure">Fig. 1(b)</ref>. These approaches can usually only skip "exterior" empty space, or also have to resort to multi-pass rendering and large brick sizes. It is possible to extend these approaches for skipping interior space <ref type="bibr" target="#b42">[40]</ref>, but this remains unfeasible for hierarchical subdivisions of very large volumes.</p><p>The goal of our SparseLeap method is to combine the best of these two worlds in a novel hybrid approach that leverages both object-order and image-order components, using fast GPU rasterization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK</head><p>The overall volume rendering process and empty space skipping techniques are intimately tied together in most cases. Therefore, we briefly review papers on volume rendering in a comprehensive sense, before focusing more specifically on empty space skipping approaches.</p><p>Volume rendering. Recent scalable volume rendering approaches for large data sets typically use GPU ray-casting <ref type="bibr" target="#b7">[5,</ref><ref type="bibr" target="#b13">11,</ref><ref type="bibr" target="#b16">14,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b25">23]</ref>. In these approaches, large volume data are often represented by an octree, which is then traversed on the GPU using either explicit links between nodes <ref type="bibr" target="#b13">[11]</ref>, or with octree traversal methods adapted from kdtree traversal in ray tracing <ref type="bibr" target="#b7">[5,</ref><ref type="bibr" target="#b10">8]</ref>. An important recent development is ray-guided volume rendering, which scales with the output image instead of with the input data set size <ref type="bibr" target="#b7">[5,</ref><ref type="bibr" target="#b10">8,</ref><ref type="bibr" target="#b16">14]</ref>. In our work, we employ a similar ray-guided volume rendering approach. A survey of large-scale volume rendering techniques is given by Beyer et al. <ref type="bibr" target="#b5">[3]</ref>.</p><p>Volume representations. Skipping empty space is often tied to the specific volume representation used. The simplest representation is a regular grid of volume bricks <ref type="bibr" target="#b5">[3]</ref>. Kd-trees can adaptively subdivide the volume according to various criteria <ref type="bibr" target="#b43">[41,</ref><ref type="bibr" target="#b45">43]</ref>. Kd-trees are also common for rendering on clusters <ref type="bibr" target="#b9">[7]</ref>. However, more often large volumes are represented using octrees <ref type="bibr" target="#b6">[4,</ref><ref type="bibr" target="#b7">5,</ref><ref type="bibr" target="#b12">10,</ref><ref type="bibr" target="#b13">11,</ref><ref type="bibr" target="#b15">13,</ref><ref type="bibr" target="#b30">28,</ref><ref type="bibr" target="#b40">38,</ref><ref type="bibr" target="#b44">42,</ref><ref type="bibr" target="#b49">47]</ref>. Octrees are less adaptive than kd-trees, but are easier to update after changes to the transfer function or after en-/disabling segmented objects. Page table hierarchies are an alternative that has been shown to scale well to very large data <ref type="bibr" target="#b16">[14]</ref>. A recent representation for raycasting voxelized geometry are sparse voxel octrees <ref type="bibr" target="#b27">[25,</ref><ref type="bibr" target="#b28">26]</ref>. Another alternative are adaptive mesh refinement (AMR) hierarchies <ref type="bibr" target="#b20">[18,</ref><ref type="bibr" target="#b21">19,</ref><ref type="bibr" target="#b48">46]</ref>. Hybrids between grids and trees have also been used <ref type="bibr" target="#b26">[24,</ref><ref type="bibr" target="#b41">39]</ref>. Bounding volume hierarchies (BVHs) are standard in ray tracing, and can be applied to volumes <ref type="bibr" target="#b24">[22]</ref>, but are not commonly used for regular volume data. Specific representations for sparse volumes can improve storage, performance, or both <ref type="bibr" target="#b26">[24,</ref><ref type="bibr" target="#b37">35]</ref>. The data structure used for empty space skipping is usually intricately linked with the underlying volume representation and rendering method, e.g., standard octree empty space skipping stores non-empty volume data in the same octree, which is traversed for rendering and empty space skipping at the same time. In contrast, the SparseLeap data structures for empty space skipping are decoupled from the underlying volume representation.</p><p>Empty space skipping. Traditionally, object-order vs. imageorder volume rendering refers to slicing vs. ray-casting approaches <ref type="bibr" target="#b8">[6]</ref>. In the context of empty space skipping, object-order mainly refers to the involvement of the rasterization of some kind of bounding geometry that approximates the non-empty parts of the volume <ref type="bibr" target="#b3">[1,</ref><ref type="bibr" target="#b42">40,</ref><ref type="bibr" target="#b50">48]</ref>, such as bounding boxes <ref type="bibr" target="#b17">[15]</ref> or proxy spheres <ref type="bibr" target="#b32">[30]</ref>. If octree or kd-tree nodes are rendered in separate passes, empty space can simply be skipped by excluding the passes of empty nodes <ref type="bibr" target="#b9">[7,</ref><ref type="bibr" target="#b31">29]</ref>. Exploiting ray coherence can improve performance <ref type="bibr" target="#b29">[27]</ref>, for example by re-projecting the previous frame <ref type="bibr" target="#b23">[21,</ref><ref type="bibr" target="#b46">44]</ref> or occlusion frusta <ref type="bibr" target="#b36">[34]</ref>.  In the same context, image-order mainly refers to GPU ray-casting methods that perform empty space skipping per pixel during the volume sampling step. Typical examples are GPU octree-based raycasting methods <ref type="bibr" target="#b7">[5,</ref><ref type="bibr" target="#b13">11]</ref> that traverse the octree during ray-casting and skip nodes that are marked as empty. Some work has specifically targeted fibrous structures <ref type="bibr" target="#b35">[33,</ref><ref type="bibr" target="#b38">36]</ref>. It has been shown that AMR hierarchies work better for skipping empty space around thin structures than octrees <ref type="bibr" target="#b20">[18,</ref><ref type="bibr" target="#b21">19]</ref>. However, well-adapted space subdivisions are unfeasible to update interactively in response to transfer function changes or en-/disabling of segmented objects. Strategies for skipping empty space have also been implemented in hardware architectures <ref type="bibr" target="#b34">[32]</ref>.</p><p>SparseLeap is a hybrid method with object-and image-order stages. Hybrid strategies have been employed successfully before, for example in the polygon assisted ray casting (PARC) by Avila et al. <ref type="bibr" target="#b3">[1]</ref>, and by Westermann and Sevenich <ref type="bibr" target="#b50">[48]</ref>. Early approaches often employed graphics hardware rasterization, while performing ray-casting on the CPU. Sobierajski and Avila <ref type="bibr" target="#b42">[40]</ref> were able to skip interior empty space instead of only exterior space, by rasterizing a grid of bounding boxes into multiple depth layers, which, although stored very differently, has similarities with our ray segment lists. Bounding geometry can also be represented efficiently, for example using run-length encoding <ref type="bibr" target="#b47">[45]</ref>.</p><p>Geometry and per-pixel linked lists. We take inspiration from occlusion/visibility culling, which is a standard problem in computer graphics that aims at avoiding rendering geometry that is invisible or occluded. Seminal papers are the hierarchical z-buffer <ref type="bibr" target="#b14">[12]</ref>, and hierarchical occlusion maps <ref type="bibr" target="#b52">[50]</ref>. Recent output-sensitive volume rendering architectures <ref type="bibr" target="#b5">[3]</ref> refer to this property as ray-guided <ref type="bibr" target="#b7">[5]</ref> or visualization-driven <ref type="bibr" target="#b16">[14]</ref>, ray-casting only non-occluded volume regions. SparseLeap employs this strategy to only rasterize geometry where the volume is known to be potentially visible and non-empty.</p><p>To create our ray segment lists, we take inspiration from recent order-independent transparency (OIT) methods that use per-pixel linked lists <ref type="bibr" target="#b51">[49]</ref>. However, our lists do not need to be sorted after rasterization, which avoids a big performance bottleneck. An alternative is performing rasterization intertwined with volume rendering by doing both in CUDA kernels <ref type="bibr" target="#b22">[20]</ref>. The latter approach is very flexible, but we target exploiting the faster hardware rasterization of GPUs. <ref type="figure" target="#fig_0">Fig. 3</ref> depicts the SparseLeap algorithm and its main data structures. We use an occupancy histogram tree to track volume occupancy of regions. Whenever the user enables/disables objects or updates the transfer function, we use the occupancy histogram tree to generate occupancy geometry. For each new view, we rasterize this geometry to generate a linear ray segment list per ray. Ray-casting then leaps over empty space via linear traversal of the ray segment list of each ray.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ALGORITHM OVERVIEW</head><p>Occupancy histogram tree. We track volume occupancy hierarchically, using the three occupancy classes empty, non-empty, and unknown. Each node of the occupancy histogram tree represents a region of the volume. Each leaf node is assigned an occupancy class that is determined via standard culling, i.e., by comparing volume region information, such as min/max scalar value and the set of contained objects, against the current transfer function and the currently active set of objects. Each non-leaf node stores an occupancy histogram that is computed by propagating occupancy information up the tree. Each occupancy histogram is the sum of all occupancy histograms below its node. Therefore, each node stores the total count of leaf nodes of the entire corresponding sub-tree in each of the three occupancy classes. Using the non-standard occupancy class unknown facilitates lazy (delayed) culling (see Sec. 5.1), which is important for very large data.</p><p>Occupancy geometry. From the occupancy histogram tree, we extract a set of nested bounding boxes via a linear-time top-down traversal, assigning each box an occupancy class. However, not every tree node "emits" a bounding box. Using a simple set of traversal rules, we emit geometry only when the occupancy class changes while traversing down the tree. This leads to a significant reduction in both geometry and the corresponding fragmentation of space. Corresponding to the spatial extent of nodes, box sizes decrease from the root node down the tree. An important insight of SparseLeap is that the occupancy class of a smaller box is able to override the class of the larger box that contains it, over the extent of the smaller box. Finally, we exploit the coherence between successive rendering frames by re-using the same occupancy geometry, unless the occupancy itself has changed because the transfer function or the active set of objects has changed.</p><p>Ray segment lists. For each new view, the occupancy geometry is rasterized into per-pixel linked lists that store a sequence of successive segments (1D intervals) for each ray. Each segment corresponds to one of the three occupancy classes. During rasterization, consecutive segments of the same class are merged into a single segment. We generate all ray segment lists in parallel by rasterizing the occupancy geometry stored in GPU memory. This approach leverages the extremely fast GPU rasterization hardware, and in this way removes the most significant cost of empty space skipping from the GPU ray-casting shader.</p><p>Our method has similarities with GPU order-independent transparency (OIT) approaches using per-pixel linked lists. However, we obtain the ray segment lists in already sorted order, by rasterizing the occupancy geometry accordingly (Sec. 6.2). Therefore, we do not need to sort them afterward, which is a big difference to standard OIT.</p><p>Ray-casting. The ray segment lists enable empty space skipping during ray-casting via a simple linear list traversal. The main change to a standard ray-casting implementation is adding an additional outer loop that traverses the ray segment list of the current pixel from front to back along the ray, skipping each encountered empty segment. Volume sampling is only performed for non-empty segments, as well as for unknown segments. Therefore, the SparseLeap algorithm can easily be integrated into any existing GPU ray-casting shader.</p><p>We now discuss the details of each major component of the Sparse-Leap pipeline just outlined in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">OCCUPANCY HISTOGRAM TREE</head><p>The occupancy histogram tree depicted in <ref type="figure" target="#fig_0">Fig. 3</ref>(a) comprises a spatial subdivision of the volume, i.e., each tree node corresponds to a specific region of space. Our occupancy histogram tree is implemented as an octree, i.e., the spatial region corresponding to each node is an axisaligned box. However, we emphasize that our occupancy histogram tree serves a different purpose than a volume octree in standard volume rendering. Specifically, the occupancy histogram tree stores a hierarchy of occupancy histograms over multiple possible occupancy classes. In contrast to standard usage, encoding occupancy information in histograms does not mean that every parent node of a non-empty node is classified as non-empty as well. This is a crucial difference to how occupancy information is propagated in standard volume octrees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Occupancy Histograms and Occupancy Classes</head><p>An occupancy histogram is a histogram over the three occupancy classes empty, non-empty, and unknown. The histogram stored in a given node of the occupancy histogram tree stores one count for each of the three occupancy classes. Each count corresponds to how many leaf nodes of the sub-tree of that node belong to that occupancy class. The leaf nodes of the occupancy histogram tree do not need to store a full histogram. Instead, they directly store the occupancy class corresponding to the spatial region represented by the leaf node.</p><p>Occupancy classes empty and non-empty. For each leaf node, a culling step determines whether the spatial region corresponding to the node is empty or non-empty, by comparing meta-data against the current transfer function and the set of active objects. See below.</p><p>Occupancy class unknown. In order to be able to scale to very large data, we allow for delayed culling, i.e., the lazy determination of the occupancy classes empty or non-empty. This is facilitated by the class unknown, which denotes that it is not yet known whether the spatial region corresponding to a leaf node is actually empty or nonempty. To fully support this, our ray-caster generates an occupancy miss when it encounters a ray segment of class unknown (Sec. 8.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Tree Updates</head><p>In order to determine the occupancy class of a given leaf node of the occupancy histogram tree, actual culling must be performed for that node. Apart from allowing delayed culling (see below), we do this in the standard way, i.e., by comparing stored meta-data of the leaf node against global user-determined settings, such as the current transfer function, and the current set of active (enabled) segmented objects:</p><p>• Segmented objects: Culling requires meta-data of the set of objects contained in each node. If all contained objects are globally disabled, the occupancy class of the node will be set to empty. Otherwise, it will be set depending on the transfer function. • Transfer function: Culling requires meta-data of min/max scalar value of each node. For completely transparent (zero opacity) nodes, this will result in an occupancy class of empty, otherwise in a class of non-empty. Iso-surfaces can be culled analogously.</p><p>Delayed culling. Culling can be performed in a delayed fashion, where the occupancy class of a leaf node is initially set to unknown, and only changed to empty or non-empty after the (asynchronous) culling process has completed. In addition to delayed culling, our implementation supports even computing the meta-data required by culling in a delayed fashion. In order to support this, the meta-data are allowed to be missing. When an occupancy miss is reported for a node that is still missing its meta-data, it will be computed at that time.</p><p>Occupancy histogram propagation. The occupancy histograms are computed by propagating the occupancy class information of leaf nodes up the tree. In order to do this, we traverse the occupancy histogram tree recursively in depth first order, starting at the root: Each non-leaf node first descends to its child nodes, and, after the child traversal returns, computes its occupancy histogram as the sum of the occupancy histograms of its child nodes, which are now correctly set.</p><p>Growing and pruning the tree. When an occupancy miss is reported that corresponds to a node that does not exist in the occupancy histogram tree, the tree is automatically grown to include that node. The initial occupancy class of new nodes is always set to unknown. It will be changed to empty or non-empty after culling has been performed. We automatically retire unused (invisible) tree nodes, i.e., nodes that are occluded or outside the view frustum. Doing so makes our approach output-sensitive, i.e., it scales with the visible output instead of the whole volume. This is done by deleting nodes, and possibly their entire sub-tree, using a least-recently used strategy (Sec. 8.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">OCCUPANCY GEOMETRY GENERATION</head><p>From the occupancy histogram tree, the corresponding occupancy geometry illustrated in <ref type="figure" target="#fig_1">Fig. 4</ref> is extracted by traversing the tree using simple traversal rules that determine whether a node's bounding box should be emitted or not. Note that this process is view-independent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Occupancy Histogram Tree Traversal</head><p>To generate the occupancy geometry, we traverse the occupancy histogram tree in breadth first order, visiting child nodes in a fixed order (not in visibility order). The resulting occupancy geometry therefore always stores larger boxes (coarser tree levels) before smaller boxes (finer tree levels), which optionally allows stopping the traversal when a given budget for the number of boxes has been reached.</p><p>According to the traversal rules below, a given node might simply be skipped during traversal, or it might emit the geometry of the node's bounding box (we only store box center and size), together with the node's occupancy class, as well as the occupancy class of its parent.  Ray segment lists are generated by rasterizing nested occupancy geometry bounding boxes. The rasterization of their front-and back-faces, respectively, results in ray events at the corresponding intersection positions: entry events for front faces, and exit events for back faces. After all ray events have been rasterized (right), including possibly merging or deleting events, the result is the final ray segment list (left): a sequence of ray segments (intervals between consecutive ray events), with one occupancy class per segment: empty, non-empty, or unknown. Left: Occupancy geometry and corresponding output ray segment list. Right:</p><p>Step-by-step generation.</p><p>Traversal rules. The occupancy histogram tree produces an array of bounding boxes with occupancy classes using the following rules:</p><p>• The tree is traversed in breadth first order starting at the root.</p><p>Each node is passed in the occupancy class of its parent node. The parent class for the root node is invalid, defined as not equal to any other class. Therefore, the root node always emits its bounding box (see below), i.e., the whole volume bounding box.</p><p>• Each node determines its occupancy class. For leaf nodes the occupancy class is already stored in the node and does not have to be computed. Each visited non-leaf node inspects its occupancy histogram to determine its own occupancy class. The class is set to the majority vote over the occupancy histogram, i.e., the class that occurs the most often in all leaf nodes of its sub-tree.</p><p>• Geometry emission: Each visited node compares its occupancy class with the class of its parent: If the class is the same, no bounding box is emitted. If the class is different, a bounding box with the respective occupancy class info is emitted for the node.</p><p>• If the already emitted number of bounding boxes exceeds a prespecified (optional) resource limit, traversal is stopped.</p><p>Occupancy geometry and fragmentation of space. <ref type="figure" target="#fig_1">Fig. 4(a)</ref> illustrates an example occupancy geometry of nested bounding boxes resulting from these traversal rules. <ref type="figure">Fig. 2(b, d</ref>) depicts actual occupancy geometry as green (non-empty) and red (empty) boxes. Using our approach, space is significantly less fragmented than when a standard octree is used. However, we observe that some fragmentation of space still remains. These cases are resolved during the subsequent rasterization of ray segment lists, where consecutive ray segments of the same occupancy class are detected and merged <ref type="figure" target="#fig_2">(Fig. 5)</ref>. The overall resulting depth complexity is very low, which is visualized in <ref type="figure">Fig. 7</ref> (left).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Occupancy Visibility-Ordering</head><p>The occupancy geometry itself is view-independent. However, the rasterization of ray segment lists below must be performed in visibility order with respect to the current view point. Therefore, whenever the view changes, we compute a visibility-sorted index array that references the current occupancy geometry in front-to-back visibility order. Visibility traversal. We traverse the occupancy histogram tree in depth first order, visiting child nodes in front-to-back visibility order. In contrast to a standard tree traversal in visibility order, we do not only emit indices for leaf nodes, but for all non-leaf nodes as well.</p><p>In fact, each node index is emitted twice, such that the subsequent rasterization is able to differentiate bounding box front and back faces, respectively (in the fragment shader). Each non-leaf index is emitted before its child nodes are visited, and is again emitted afterward. The former index is marked for front face rasterization. The latter index is marked for back face rasterization. Leaf node indexes are emitted twice back-to-back: first for front face, then for back face rasterization.</p><p>Visiting all occupancy histogram tree nodes recursively in visibility order proceeds in the following (standard) manner. Given a view point (for perspective projection), or a view direction (for orthogonal projection), we compute in which of eight possible octants it lies. This octant then determines the order in which child nodes have to be visited.</p><p>Relation to rasterization. This approach enables the subsequent rasterization stage to generate ray segments in front-to-back order, and achieve the desired property that smaller boxes inside larger boxes are preceded by the front face of the enclosing larger box, and are succeeded by its back face. This is illustrated in <ref type="figure" target="#fig_2">Fig. 5</ref>. This property is fundamental to achieving one of the major properties of the Sparse-Leap algorithm: that the occupancy class of smaller occupancy geometry bounding boxes correctly overrides that of larger bounding boxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RAY SEGMENT LIST GENERATION</head><p>Given the occupancy geometry and the computed visibility order, we can now rasterize this geometry to create the corresponding ray segment lists, such as the ray segment list of the ray depicted in <ref type="figure" target="#fig_2">Fig. 5</ref>. Rasterizing the occupancy geometry results in a sequence of ray events. These events are processed directly during rasterization (in the fragment shader), during which ray events may be merged or deleted. The remaining ray events then form the resulting ray segment list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Ray Events</head><p>Each fragment generated during occupancy geometry rasterization results in the creation of a ray event. Each ray event corresponds to the intersection of a ray with one of the six faces of an occupancy geometry bounding box, at a certain depth (position) along the ray. Each box intersected by a ray produces two ray events: one for the intersection with a front face of the box, where the ray enters it, and one for the intersection with a back face of the box, where the ray exits again <ref type="figure" target="#fig_2">(Fig. 5)</ref>. Each ray event therefore has an associated event type, which depends on whether the fragment resulted from the rasterization of a front face or a back face. Each ray event contains the following:</p><p>• Depth. The position (1D parameter) where the event was generated, i.e., where the ray has intersected a bounding box face.</p><p>• Event type (entry or exit). We store whether the event resulted from entering a bounding box or from exiting (leaving) it, respectively. Bounding box front faces produce entry events; back faces produce exit events. This distinction is crucial for the correct on-the-fly merging and deletion of events (see below).</p><p>• Occupancy class. The occupancy class of the event can be either empty, non-empty, or unknown. The occupancy class associated with an event depends on whether the event is of type entry or exit, respectively. For an entry event, the occupancy class is set to that of the bounding box that generated the event. For an exit event, it is set to the occupancy class of the box's parent.</p><p>Correspondence to occupancy histogram tree traversal. The idea of associating a different occupancy class with a ray event depending on whether it is an entry-or an exit event is simple, but it actually is what enables completely sequential, non-hierarchical "traversal" of the occupancy histogram tree. Without this approach, whenever an entry event is parsed, the current occupancy class would have to be pushed onto a stack. Likewise, whenever an exit event is parsed, the occupancy class would have to be popped off the stack again. This point is important to emphasize: For each ray (output pixel), traversing the corresponding linear list of ray events is equivalent to hierarchically traversing the occupancy histogram tree along that ray. However, in our rasterization stage, there is no tree to traverse, and there is no need for a stack, or stack-less hierarchy traversal, which would usually be required to traverse tree nodes in visibility order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Ray Segment Lists</head><p>Each ray segment list is a singly-linked list for a given pixel that stores ray events in front-to-back visibility order. Ray events and segments, as they result from occupancy geometry, are illustrated in <ref type="figure" target="#fig_2">Fig. 5</ref>.</p><p>A ray segment is the interval bounded by two consecutive ray events. Corresponding to the rasterization that produces each ray event as described above, each ray segment is thus started either by a front face or by a back face of a bounding box in the occupancy geometry.</p><p>Initial ray segment list. The default ray segment list for each pixel is a single segment with occupancy class unknown that starts at the volume bounding box front face position and ends at the volume bounding box back face position. This list comprises the corresponding two ray events: entering the volume bounding box, and exiting it, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Occupancy Geometry Rasterization</head><p>The occupancy geometry array is rasterized in a single rendering pass. For each fragment that is generated during rasterization, we invoke a fragment shader that generates the ray segment list for that fragment. Detailed pseudo code is given in the supplementary material.</p><p>Determining the event type. The first task of this shader is to determine whether the fragment has resulted from the rasterization of the front face, or the back face, of a bounding box. This determines whether the corresponding ray event should be created with type entry or exit, respectively. This event type has to be compared against the flag stored in the occupancy geometry array, which kind of face should be retained: fragments from front faces, or fragments from back faces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">Ray event merging and deletion during rasterization</head><p>In order to speed up the subsequent ray-casting stage, it is crucial to avoid an unnecessarily high depth complexity (i.e., total number of events per ray) in the ray segment lists. We achieve this by performing on-the-fly merging and deletion of ray events during rasterization.</p><p>Our rules for processing ray events at the same position (depth) are:</p><p>• Two events of the same type (entry or exit) can always be merged, retaining only the second event, and overwriting the first one. The surviving occupancy class will be that of the second event.</p><p>• Two events where the first is of type exit, and the second of type entry, can both be deleted when the occupancy classes of the second event and the event before the first event match. This happens for consecutive segments of the same occupancy class.</p><p>• Two events where the first is of type entry, and the second of type exit, can both be deleted, independent of the corresponding occupancy classes. This happens when a ray grazes a bounding box edge or corner, generating two events at the same depth.</p><p>These rules can be executed simply for each incoming event (rasterized fragment) in the fragment shader whenever a fragment is processed, accessing the tail of the ray segment list built so far. Nevertheless, since each rule transforms a consistent ray segment list into a likewise consistent, updated ray segment list, this incremental update strategy results in the desired, consistent ray segment list for any arbitrarily long sequence of incoming events (rasterized fragments). The second rule above will implicitly grow multiple consecutive segments of the same occupancy class into a single longer segment. Additionally, in order to handle boundary cases that would otherwise result in an unnecessarily high depth complexity, we detect and remove all very short empty ray segments that cannot be merged into a longer empty segment because they precede a non-empty segment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RENDERING</head><p>In our implementation, volume rendering is performed via ray-casting in a ray-guided volume rendering framework <ref type="bibr" target="#b16">[14]</ref>. Adding Sparse-Leap to the existing code was quite easy due to our conceptual separation of rendering and empty space skipping. Ray-guided volume rendering is built on the basic principle of lazy evaluation. A data brick is only loaded into memory when the brick is hit by the ray-caster. Whenever the ray-caster hits a brick that has not yet been loaded, a data cache miss for that brick is generated, which, in turn, triggers that the brick will be loaded into memory. In SparseLeap, we extend this concept further from the sole loading of volume data to the loading and computation of the meta-data required by empty space skipping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Ray Traversal</head><p>When the ray segment lists have been created as described above, the actual ray-casting process only requires a very small modification from a standard ray-casting loop. The standard loop that iterates from sample to sample is augmented by an additional outer loop iterating over the ray segment list. This outer loop iterates linearly from ray segment to ray segment along the ray. We do this by looking at consecutive (overlapping) pairs of ray events in the ray segment list. Segments of occupancy class empty are simply skipped, i.e., the ray position is advanced to the subsequent segment. Segments of occupancy class nonempty, or of occupancy class unknown (they could be either empty or non-empty, without knowing which), need to be sampled. Sampling is performed exactly as in standard ray-casting, in any way desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Cache Misses and the Occupancy Histogram Tree</head><p>Our implementation of SparseLeap utilizes two different types of cache misses. The first one supports output-sensitive culling and empty space skipping. The second one is standard in ray-guided volume rendering, except for our use of the occupancy class unknown.</p><p>Occupancy misses. For segments of occupancy class unknown, the ray-caster generates an occupancy miss, so that the actual occupancy class (empty or non-empty) will be determined via culling. This leads to an output-sensitive (i.e., ray-guided) approach with delayed occupancy class updates: Volume bricks that are never intersected by view rays (because they are occluded, or because they are outside the view frustum) will not even get their occupancy class determined. The latter is crucial for large data, because this means that their culling meta-data need not be fetched or computed, culling need not be performed, and occupancy class changes need not be updated in the occupancy histogram tree. Finally, sub-trees in the occupancy histogram tree that have become homogeneous due to occupancy class updates, i.e., where all nodes are now of the same occupancy class, are substituted on-the-fly by a single node of that occupancy class. Determining homogeneous sub-trees is trivial using the occupancy histograms. <ref type="figure">Fig. 6</ref> illustrates these delayed updates of occupancy classes in the occupancy histogram tree, driven by ray-casting and occupancy misses.</p><p>Data cache misses. Once the occupancy class of a volume brick has been determined (which happened to resolve an occupancy miss), further behavior depends on whether or not the actual volume data of the brick are resident in the volume cache (a 3D texture <ref type="bibr" target="#b16">[14]</ref>). If the volume data are not resident and the occupancy class of the brick is non-empty, a data cache miss will be generated, which, as in standard  <ref type="figure">Fig. 6</ref>. Delayed occupancy class updates. Left: Initially, everything is unknown (the occupancy histogram tree comprises only the root node). Center: Some nodes are now known to be empty. Note the subdivisions. Right: As more nodes become known, the larger homogeneous regions now known to be empty can be represented by single nodes. <ref type="figure">Fig. 7</ref>. Space subdivision. We visualize the depth complexity of empty space skipping traversal as pixel brightness (brighter means more steps). For SparseLeap (left) this is the number of segments (min = 1, max = 31, avg = 3.84). SparseLeap fragments space very little. For octree-based empty space skipping (right) this is the number of intersected nodes (min = 4, max = 45, avg = 13.44). Octrees incur a much more fragmented subdivision of space. Data set: SEM Mouse Cortex. ray-guided rendering will lead to the data being loaded. In all other cases, no data cache miss will be generated. These are the cases when the occupancy class is empty or unknown, or the data are already in the cache. The reason for not generating a data cache miss in the unknown case (where data will be sampled, if in the cache, see above) is that we want to avoid burdening the system with loading new data that is not yet known to be needed. In this case, the occupancy miss will simply be resolved first, and only then will data be loaded, if actually needed.</p><p>Simplified implementation. While we have just described two different types of cache misses, the entire required functionality between GPU and CPU can be implemented by the ray-caster reporting a single, unified type of miss (essentially consisting of a brick ID). The cache miss semantics described above leave only one choice for the conceptual type of miss "meant" by the ray-caster in each case, so it is always clear whether to resolve an occupancy miss or a data miss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Cache Usage and the Occupancy Histogram Tree</head><p>For fully output-sensitive culling and empty space skipping, we track usage information for nodes in the occupancy histogram tree, and retire unused nodes over time. In our implementation, we combine this with the usage reporting of the out-of-core memory management system <ref type="bibr" target="#b16">[14]</ref>. The ray-caster reports which parts of the volume it still needs to be cached in the volume cache. From this, the corresponding nodes in the occupancy histogram tree are computed. Unused nodes are retired regularly using a least-recently used (LRU) scheme. This approach keeps the size of the occupancy histogram tree in correspondence with the currently visible part of the volume (the working set in cache terminology). In this way, the occupancy histogram tree can be made to scale with the current output size instead of the whole volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">IMPLEMENTATION</head><p>Our implementation is integrated with a large-scale out-of-core raycasting system <ref type="bibr" target="#b16">[14]</ref>. We use OpenGL with GLSL shaders for implementing the entire SparseLeap pipeline. For the rasterization of the occupancy geometry into ray segment lists, fragments need to be processed in the same order as they are submitted to OpenGL, according to the occupancy visibility ordering (Sec. 6.2). In order to be able to guarantee this, the fragment shader executed during the rasterization of the occupancy geometry makes use of the fragment shader interlock capability of recent GPUs. This capability is exposed in OpenGL by the ARB extension ARB_fragment_shader_interlock, whose usual main application is order-independent transparency. For evaluation and all timings that we report, we have used an NVIDIA Geforce Titan X (Pascal) GPU with 12 GB RAM, which supports this extension.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Data Management and Culling Granularity</head><p>Our goal is to decouple the empty space skipping architecture from the actual volume rendering architecture. We therefore conceptually separate the meta-data needed for empty space skipping from the actual volume data. In our case, meta-data refers to aggregated information for box-shaped volume regions, such as the min/max value of the contained scalar data, and a set of IDs of contained segmented objects.</p><p>Meta-and Volume Data Subdivision. Separating the handling of meta-data from the actual volume data allows our implementation to use a different granularity for skipping empty space than that for managing volume data. Especially for finely detailed structures, empty space skipping ultimately needs to be done with a finer granularity (e.g., 16 3 blocks) than a brick size that is still feasible for memory management (e.g., 32 3 blocks). We can currently use a granularity as small as 4 3 blocks for empty space skipping of terabyte-sized volumes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">EVALUATION AND RESULTS</head><p>We evaluate SparseLeap using the volume data sets listed in <ref type="table">Table 1</ref>, and compare against a reference implementation of empty space skipping using octree traversal, which we implemented in the same framework <ref type="bibr" target="#b16">[14]</ref>. Our approach scales better to finely detailed, sparse data. <ref type="table">Table 1</ref> gives information on resolution and size of the data sets that we have used. All volumes are segmented, and the table lists the number of segmented objects (segments), and the occupancy (the percentage of non-empty voxels vs. the total number of voxels) of each volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Data Sets</head><p>Connectome data set: SEM Mouse Cortex. A major motivation for developing SparseLeap was the mouse cortex data set depicted in <ref type="figure">Fig. 8</ref>. It is a high-resolution SEM (scanning electron microscopy) volume that our collaborators in neuroscience have manually segmented sparsely, i.e., only a few thousand select structures were segmented instead of densely segmenting millions of structures in the SEM. Neuroscientists analyze these volumes by zooming in on interesting areas, and either examining individual segments, or using interactive visual queries <ref type="bibr" target="#b4">[2]</ref> to rapidly select different subsets of segments that are of interest, such as axons connected to the red dendrite depicted in <ref type="figure">Fig. 8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Comparison to the State of the Art</head><p>We evaluate our novel algorithm by comparing it to two other approaches: (1) rendering without empty space skipping as a baseline, and (2) state-of-the-art image-order empty space skipping using an octree. For the latter comparisons, we have implemented octree-based empty space skipping, since this is the de-facto standard for volume rendering of large data. Usually, ray traversal (octree traversal) and empty space skipping are tightly linked: Rays intersect octree node boundaries, and at that stage determine if the block should be sampled or whether it can be skipped. The two major drawbacks are: (1) A lot of tree traversal down (and maybe up) the tree is incurred; (2) It is usually not possible to skip multiple consecutive empty nodes in one step. Each node has to be visited in turn, advancing the ray position to the next node's boundary after the current node has been traversed (sampled or skipped). A lot of unnessary ray-box intersections are computed. Different octree traversal approaches incur different amounts of overhead <ref type="bibr" target="#b11">[9,</ref><ref type="bibr" target="#b18">16,</ref><ref type="bibr" target="#b19">17,</ref><ref type="bibr" target="#b39">37]</ref>. We have implemented the octree traversal during ray-casting using the standard kd-restart algorithm <ref type="bibr" target="#b11">[9]</ref>. <ref type="figure">Fig. 7</ref> contrasts the qualitatively very different approaches to subdividing space for empty space skipping that our method employs vs. the fragmented subdivision incurred by a standard octree approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3">Performance</head><p>We compare overall frame rates, as well as the overall depth complexity incurred by accessing the empty space skipping data structure. <ref type="table">Table 1</ref> compares frame rates for ray-casting using the three evaluated approaches: ray-casting without empty space skipping, ray-casting with standard octree-based empty space skipping, and ray-casting using SparseLeap. We report frame rates for two different volume occupancy settings that allow us to compare performance between dense and sparse volume scenarios. It can be seen that our approach always outperforms ray-casting without empty space skipping. However, the most significant performance gains are obtained for sparse volumes. <ref type="figure">Fig. 8</ref> (left) and <ref type="figure">Fig. 9</ref> give a detailed evaluation for a single data set (the SEM Mouse Cortex). We show the performance impact of different block sizes <ref type="figure">(Fig. 8</ref>) and data resolution levels <ref type="figure">(Fig. 9)</ref>, for two block size 32 <ref type="bibr" target="#b5">3</ref> 16 <ref type="formula">3  8</ref> different volume occupancies (dense, sparse). In the latter, the performance of ray-casting without empty space skipping is almost the same for the sparse and dense cases, respectively. However, octree skipping can be even slower than no skipping for some resolution levels in the dense case. SparseLeap is more efficient in both scenarios. Disabling rasterization. Alternatively to rasterizing the occupancy geometry every frame, and then using the resulting ray segment lists in the ray-casting shader, we can also disable the rasterization stage and re-use the previous ray segment lists. This option can be used whenever the view has not been rotated or moved, e.g., when only parameters such as lighting or sampling rate have been changed. In this case, the existing ray segment lists can be re-used without performing rasterization, leading to even higher performance. The corresponding frame rates are reported in <ref type="table">Table 1</ref> in the second SparseLeap column. <ref type="figure">Fig. 8 (right)</ref> shows a comparison of the depth complexity during raycasting using SparseLeap for different block sizes, compared with standard octree empty space skipping (lower is better). Our hybrid approach significantly limits the number of nodes that need to be accessed (rasterized) and that have to be visited during ray-casting. This leads to a lower depth complexity compared with the octree approach. We report the average depth complexity over all rays of the measured frame, as well as the maximum depth complexity (dashed lines).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3.1">Rendering performance</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3.2">Depth complexity (view-dependent)</head><p>In SparseLeap, the average depth complexity stays roughly constant when the granularity becomes finer. This is due to the fact that we incur the fine granularity only where it is required by fine structures inside the volume. On the other hand, in the octree-based approach a finer granularity always leads to a higher depth complexity. This is due to the fact that smaller blocks lead to a higher spatial fragmentation, even in completely empty regions, corresponding to <ref type="figure">Fig. 7 (right)</ref>.  <ref type="figure">Fig. 9</ref>. Performance comparison for different resolution levels. We compare SparseLeap against an octree-based approach for block sizes of 8 3 and 16 <ref type="bibr" target="#b5">3</ref> , respectively, for a sparse and a dense volume (see <ref type="figure">Fig. 8,  right)</ref>. L4 is the lowest data resolution, L1 the highest. Dashed lines are for the performance of SparseLeap when the rasterization does not need to be updated, e.g., when only the light direction changes. (Viewport: 1, 200 × 1, 200, Geforce Titan X, data set: SEM Mouse Cortex.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3.3">Memory requirements</head><p>The GPU memory requirements of SparseLeap consist of two parts. The first part is the storage required for the occupancy geometry. The second part is the storage required for the ray segment lists.</p><p>GPU geometry (occupancy geometry vs. octree). Our occupancy geometry always contains significantly fewer nodes than the equivalent octree representation, which we have directly compared using our two implementations. The reason for this is that many occupancy histogram tree nodes do not emit any geometry, whereas they do have to be stored in an equivalent octree representation on the GPU. In practice, we have observed a memory usage of just several dozen to a few hundred kilobytes for the occupancy geometry used by SparseLeap, whereas the equivalent octree consumed several megabytes.</p><p>GPU ray segment list buffer. The storage for ray segment lists depends on the screen resolution, and is equivalent to a frame buffer with multiple layers. The actual memory requirement depends on the average depth complexity, which, as shown in <ref type="figure">Fig. 7</ref>, is very low in SparseLeap. For example, an average depth complexity of 4 requires allocating a buffer of 'four times the screen resolution' linked list elements, plus allocating a linked list head pointer for each pixel. In our implementation, the size of each list element is 12 bytes, and the size of each list head is 16 bytes. For a screen resolution of 1, 200 × 1, 200, a buffer of 154 MB suffices up to an average depth complexity of 8.</p><p>CPU memory. The CPU memory requirements between the occupancy histogram tree and a standard octree structure are very similar. Apart from standard child pointers, the histograms stored in the occupancy histogram tree consume only three integer counts per node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">DISCUSSION</head><p>Important characteristics that make SparseLeap unique: (1) Rasterizing intersections of rays with the occupancy geometry into ray segment lists moves the major cost of empty space skipping from the raycasting stage into the faster GPU hardware rasterization. (2) Empty space skipping during ray-casting is not hierarchical. Each ray simply traverses the linear list of successive ray segments without costly fine-grained hierarchy traversal. (3) Temporal frame coherence (reusing occupancy geometry) as well as ray coherence (rasterization of each bounding box maps to many pixels/rays at the same time) are implicitly exploited. This amortizes the cost over successive frames as well as over nearby rays. (4) SparseLeap is efficient even for drastically changing sparsity characteristics due to transfer function changes and en-/disabling of segmented objects, without re-computing a space subdivision. (5) Ray segment lists conceptually decouple empty space skipping from volume sampling. This allows combining our approach with any out-of-core strategy and any volume representation, e.g., grids, octrees, kd-trees, AMR, page table hierarchies, and so on.</p><p>Sparsity of data. The amount and structure of sparsity in the data has a big influence on the efficiency of empty space skipping, which naturally also incurs overhead (i.e., storing and computing meta-data, look-ups in the data structure) that can only be amortized if the volume that is being rendered is sufficiently sparse. Ideally, a volume renderer <ref type="table">Table 1</ref>. Data set statistics for the volumes used for the evaluation of our method (Sec. 10). We list data resolution in voxels, storage size for original volume ('Images') and voxel-level segmentation ('Labels'), number of resolution levels (3D mipmap levels equivalent to octree levels), and number of (non-empty) segments (i.e., segmented objects) and average segment size in voxels. Occupancy in the Segment Statistics column refers to the percentage of all non-empty voxels (i.e., the sum of all voxels of all non-empty segments) in the whole volume. Relative to this total volume occupancy in the Segment Statistics column, we have measured two different occupancy of enabled segments settings (first row "dense," vs. second row "sparse"), by enabling different sets of segments. We compare rendering performance (frames per second) for ray-casting without empty space skipping, octree-based empty space skipping, and SparseLeap. For SparseLeap, we report two frame rates: The standard case ('w/ rast.'), and the performance when the rasterization is not re-computed ('w/o rast.'), for example when only the light source is moved. To factor out other influences such as the transfer function, all frame rates in this table have been measured without early ray termination (ERT). All timings are for a 1, 200 × 1, 200 viewport on a Geforce Titan X. All data were rendered at a resolution level and zoom factor that spanned the whole viewport. should automatically detect the point at which empty space skipping should be suspended, and switch to standard rendering for very dense volumes. We defer a detailed investigation of this issue to future work.</p><p>Moreover, for some volume structures, an optimized octree implementation might sometimes be faster (when rasterization is enabled), as can be seen in <ref type="table">Table 1</ref> for the Dreh Sensor data set. This, however, depends on the arrangement in space and the sizes of the enabled segments. We want to investigate this issue in more detail in the future.</p><p>Scaling to extreme-scale data. Our overall architecture is outputsensitive <ref type="bibr" target="#b5">[3]</ref>. We perform culling only for potentially visible parts of the volume, which is crucial for scaling to extremely large volume data, where performing computations for large invisible parts of the volume can be too slow <ref type="bibr" target="#b16">[14]</ref>. This was made possible via the introduction of the occupancy class unknown, which enables delayed culling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">CONCLUSIONS</head><p>Our empty space skipping approach combines object-order stages and image-order stages in a novel way to significantly reduce the traversal complexity for leaping over empty space in large volumes that con-tain finely-detailed structures. Our method is inspired by recent orderindependent transparency techniques on GPUs. However, in contrast to these methods, we sort the bounding geometry for empty space skipping on the CPU and avoid the necessity for any sorting to be done on the GPU. For this, the rasterization performed by the GPU hardware rasterization units needs to obey the ordering prescribed by the CPU traversal. This is now possible by exploiting recent GPU capabilities for enforcing the processing order of rasterized fragments. This combination of a novel algorithm together with novel GPU capabilities for order-independent transparency methods has enabled significant improvements for the volume rendering of large, complex structures.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .</head><label>3</label><figDesc>SparseLeap algorithm overview. (a) The occupancy histogram tree stores hierarchical volume occupancy information, using the classes empty, non-empty, and unknown. (b) Traversal of the occupancy histogram tree creates occupancy geometry whenever nested regions differ in occupancy class. The occupancy geometry can be re-used for multiple frames. (c) The occupancy geometry is rasterized into ray segment lists, merging successive segments of the same class. (d) Ray-casting leaps over empty space via linear traversal of the ray segment list of each ray.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Occupancy geometry generation and ray segments. (a) The occupancy geometry comprises view-independent nested bounding boxes of different occupancy class, reducing the fragmentation of space. (b) Consecutive segments of the same occupancy class are merged during rasterization of the occupancy geometry into ray segment lists.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Ray events and ray segment list generation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Left: Frame rates for sparse (see right, top image) and dense (see right, bottom image) volume occupancy settings. We compare SparseLeap against an octree-based approach, with and without early ray termination (ERT), for block sizes of 4 3 , 8 3 , 16<ref type="bibr" target="#b5">3</ref> , and 32<ref type="bibr" target="#b5">3</ref> . Right: Depth complexity during ray-casting. The solid line represents the average depth complexity over all rays, the dashed line represents the maximum depth complexity. (Viewport: 1, 200 × 1, 200, Geforce Titan X, data set: SEM Mouse Cortex.)</figDesc><table><row><cell></cell><cell>Sparse Volume</cell><cell></cell><cell>Dense Volume</cell><cell></cell><cell></cell><cell>Sparse Volume</cell><cell></cell><cell></cell><cell>Dense Volume</cell><cell></cell></row><row><cell>fps</cell><cell></cell><cell></cell><cell></cell><cell>depth complexity</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>32 3</cell><cell>block size 16 3 8 3</cell><cell>4 3</cell><cell>3</cell><cell>4 3</cell><cell>32 3</cell><cell>block size 16 3 8 3</cell><cell>4 3</cell><cell>32 3</cell><cell>block size 16 3 8 3</cell><cell>4 3</cell></row><row><cell></cell><cell>SparseLeap ERT</cell><cell>Octree ERT</cell><cell>no skipping ERT</cell><cell></cell><cell></cell><cell>SparseLeap avg</cell><cell cols="2">Octree ERT avg</cell><cell>Octree avg</cell><cell></cell></row><row><cell></cell><cell>SparseLeap</cell><cell>Octree</cell><cell>no skipping</cell><cell></cell><cell></cell><cell>SparseLeap max</cell><cell cols="2">Octree ERT max</cell><cell>Octree max</cell><cell></cell></row><row><cell cols="6">Fig. 8. Performance comparison for different culling granularities.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers for their insightful comments and for pointing us to related work. We thank John Keyser for the 'KESM Mouse Brain' data <ref type="bibr" target="#b33">[31]</ref>. 'Dreh Sensor' courtesy of Siemens Healthcare, Components and Vacuum Technology, Imaging Solutions; reconstructed by the Siemens OEM reconstruction API CERA TXR (Theoretically Exact Reconstruction). This work was supported by funding from King Abdullah University of Science and Technology (KAUST) and KAUST award OSR-2015-CCF-2533-01.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">Images: 134.2 MB (8 bit) Labels: 134.2 MB (8 bit) Resolution levels: 5 # Segments: 55 Avg size: 9.25 K Occupancy: 0.38 %</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">bit) Labels: 342 MB (8 bit) Resolution levels: 6 # Segments: 7 Avg size: 1.93 M Occupancy: 3.96 %</title>
		<imprint>
			<biblScope unit="page">342</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">Images: 833.6 MB (8 bit) Labels: 833.6 MB (8 bit) Resolution levels: 6 # Segments: 4 Avg size: 153.7 M Occupancy</title>
		<imprint>
			<biblScope unit="page" from="73" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards a comprehensive volume visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Avila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Sobierajski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ConnectomeExplorer: Query-Guided Visual Analysis of Large Volumetric Neuroscience Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Al-Awami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kasthuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Lichtman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE SciVis &apos;13)</title>
		<meeting>IEEE SciVis &apos;13)</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="2868" to="2877" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">State-of-the-art in GPU-based large-scale volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">34</biblScope>
			<biblScope unit="page" from="13" to="37" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multiresolution Volume Visualization with a Texture-based Octree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Boada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Navazo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="197" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Gigavoxels: Rayguided streaming for efficient and detailed voxel rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Crassin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Neyret</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lefebvre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Eisemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive 3D Graphics and Games</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Real-Time Volume Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rezk-Salama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<editor>A. K. Peters, Ltd.</editor>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Tuvok-An Architecture for Large Scale Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fogal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Vision, Modeling and Visualization</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="139" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Analysis of Scalable GPU-Based Ray-Guided Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fogal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schiewe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Large Data Analysis and Visualization (LDAV &apos;13)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="43" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Kd-tree acceleration structures for a GPU raytracer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sugerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware 2005</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Far Voxels: A Multiresolution Framework for Interactive Rendering of Huge Complex 3D Models on Commodity Graphics Platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Marton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="878" to="885" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A single-pass GPU ray casting framework for interactive out-of-core rendering of massive volumetric datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Marton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Guitián</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="797" to="806" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Hierarchical Z-Buffer Visibility</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH &apos;93</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="231" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">View-Dependent Exploration of Massive Volumetric Models on Large-Scale Light Field Displays. The Visual Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Guitián</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Marton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1037" to="1047" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive Volume Exploration of Petascale Microscopy Data Streams Using a Visualization-Driven Virtual Memory Approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-K</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE SciVis &apos;12)</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="2285" to="2294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Real-Time Ray-Casting and Advanced Shading of Discrete Isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Scharsach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bühler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum (Proc. Eurographics &apos;05)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="303" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Interactive k-d tree GPU raytracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sugerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive 3D Graphics and Games</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Kd-jump: a path-preserving stackless traversal for faster isosurface raytracing on GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE Visualization &apos;09)</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1555" to="1562" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Visualization of time-dependent remote adaptive mesh refinement data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kähler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Prohaska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hutanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="175" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Interactive volume rendering of large sparse data sets using adaptive mesh refinement hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kähler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="341" to="351" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Ray Casting of Multiple Volumetric Datasets with Polyhedral Boundaries on Manycore GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kainz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grabner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bornik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hauswiesner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mühl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schmalstieg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Exploiting frameto-frame coherence for accelerating high-quality volume raycasting on graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strengert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Stegmaier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="223" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Full-Resolution Interactive CPU Volume Rendering with Coherent BVH Traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Thelen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Papka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Pacific Visualization Symposium</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="3" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Acceleration Techniques for GPU-based Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="287" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">JiTTree: A just-in-time compiled sparse GPU volume data structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Labschütz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bruckner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gröller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rautek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE SciVis &apos;15)</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1025" to="1034" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient Sparse Voxel Octrees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Laine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Karras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive 3D Graphics and Games</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="55" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient Sparse Voxel Octrees -Analysis, Extensions, and Implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Laine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Karras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NVIDIA</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Light weight space leaping using ray coherence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lakare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Multiresolution Techniques for Interactive Texture-Based Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lamar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="355" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Empty Space Skipping and Occlusion Clipping for Texture-based Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="317" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Accelerating Volume Raycasting using Proxy Spheres</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Clapworthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="839" to="846" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Fast macro-scale transmission imaging of microvascular networks using KESM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mayerich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Abbott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Keyser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Choe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biomedical Optics Express</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="2888" to="2896" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient space leaping for ray casting architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Meißner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Doggett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hirche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Kanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Volume Graphics</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="149" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Visualization of fibrous and thread-like data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Melek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mayerich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yuksel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Keyser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE Visualization &apos;06)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1165" to="1172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Accelerating Volume Raycasting using Occlusion Frustums</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mensmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ropinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hinrichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EG/IEEE Conference on Point-Based Graphics</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="147" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">VDB: High-Resolution Sparse Volumes with Dynamic Topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Museth</surname></persName>
		</author>
		<idno>27:1-27:22</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Visualizing whole-brain DTI tractography with GPU-based tuboids and LoD management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Petrovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fallon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Kuester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE Visualization &apos;07)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1488" to="1495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Stackless kd-tree traversal for high performance GPU ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Popov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Slusallek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="415" to="424" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Visualization of Big SPH Simulations via Compressed Octree Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Reichl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Treib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Big Data</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Optimizing GPU Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ruijters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vilanova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Winter School of Computer Graphics</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A hardware acceleration method for volumetric ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Sobierajski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Avila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Applying space subdivision techniques to volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Fussell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="150" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Treib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bürger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Reichl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meneveau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szalay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<title level="m">Turbulence visualization at the terascale on desktop PCs. IEEE Transactions on Visualization and Computer Graphics (Proc. IEEE SciVis &apos;12)</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="2169" to="2177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Simple empty-space removal for interactive volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vidal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Mei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Decaudin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graphics Tools</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="21" to="36" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Fast and reliable space leaping for interactive volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Aamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="195" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">High performance presenceaccelerated ray casting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bryson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="379" to="389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Parallel cell projection rendering of adaptive mesh refinement data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Öhler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kreylos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Bethel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Parallel and Large-Data Visualization and Graphics</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="8" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Level-Of-Detail Volume Rendering via 3D Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zimmerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Volume Visualization</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Accelerated volume ray-casting using texture mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Sevenich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Real-time concurrent linked list construction on the GPU</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hensley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Grün</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Thibieroz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics Symposium on Rendering 2010)</title>
		<meeting>Eurographics Symposium on Rendering 2010)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1297" to="1304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Visibility Culling Using Hierarchical Occlusion Maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Hoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH &apos;97</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="77" to="88" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
