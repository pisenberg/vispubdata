<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On-the-Fly Rendering Of Losslessly Compressed Irregular Volume Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chuan-Kai</forename><surname>Yang</surname></persName>
							<email>ckyang@cs.sunysb.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tulika</forename><surname>Mitra</surname></persName>
							<email>mitra@cs.sunysb.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tzi-Cker</forename><surname>Chiueh</surname></persName>
							<email>chi-ueh@cs.sunysb.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On-the-Fly Rendering Of Losslessly Compressed Irregular Volume Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation-Display Algorithms; E.4 [Coding and Information Theory]: Data Compaction and Compression Irregular Grids</term>
					<term>Tetrahedral Compression</term>
					<term>Volume Rendering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Very large irregular-grid data sets are represented as tetrahedral meshes and may incur significant disk I/O access overhead in the rendering process. An effective way to alleviate the disk I/O overhead associated with rendering large tetrahedral mesh is to reduce the I/O bandwidth requirement through compression. Existing tetrahedral mesh compression algorithms focus only on compression efficiency and cannot be readily integrated into the mesh rendering process, and thus demand that a compressed tetrahedral mesh be decompressed before it can be rendered into a 2D image. This paper presents an integrated tetrahedral mesh compression and rendering algorithm called Gatun, which allows compressed tetrahedral meshes to be rendered incrementally as they are being decompressed, thus leading to an efficient irregular grid rendering pipeline. Both compression and rendering algorithms in Gatun exploit the same local connectivity information among adjacent tetrahedra, and thus can be tightly integrated into a unified implementation framework. Our tetrahedral compression algorithm is specifically designed to facilitate the integration with irregular grid renderer without any compromise in compression efficiency. A unique performance advantage of Gatun is its ability to reduce the runtime memory footprint requirement by releasing memory allocated to tetrahedra as early as possible. As a result, Gatun is able to decrease rendering time by one or two orders of magnitude for very large tetrahedral mesh whose size exceeds the amount of physical memory. At the same time, the smaller working set and better access locality of Gatun improve the rendering performance by up to 30%, even when the input tetrahedral mesh is entirely memoryresident.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Irregular-grid volumetric data set represented as tetrahedral mesh is becoming ever more important in volume visualization research be-cause of its natural fit with the way physical systems are modeled, i.e., representing more details only where they are actually needed. However, because of the lack of structure in the irregular grids, the coordinates of the vertices need to be explicitly represented, as well as the connectivity among vertices. As a result, irregular volume grids require relatively large storage space and may incur significant disk I/O overhead during the rendering process. One way to reduce this disk I/O performance overhead is to compress the irregular grid data sets, so that at least the initial data set loading time is reduced. Existing tetrahedral mesh compression algorithms focus mainly on improving the compression efficiency and are completely decoupled from the irregular volume rendering process. Because of this decoupling, a compressed tetrahedral mesh needs to be completely decompressed before it can be rendered into a 2D image. In contrast to this "store and forward" approach, this paper describes a "cut through" approach that integrates the decompression and rendering steps into a streamlined process, and thereby significantly cuts down both the run-time memory footprint size and the disk I/O bandwidth requirement.</p><p>The resulting irregular-grid volume rendering system, called Gatun, consists of a lossless tetrahedral mesh compression algorithm and an object space-based ray-casting rendering algorithm. The proposed tetrahedral mesh compression algorithm is a generalization of the one originally designed for triangle mesh <ref type="bibr" target="#b8">[9]</ref> and provides compression efficiency comparable to <ref type="bibr" target="#b4">[5]</ref>. Basically this algorithm starts from a seed tetrahedron or a seed face, and then proceeds in a "breadth first" manner until it covers all the tetrahedra. This breadth first traversal decision plays an important role in Gatun's ability to streamline the decompression and rendering steps of compressed tetrahedral meshes.</p><p>The second component of Gatun is an irregular grid volume renderer that uses ray-casting, but is object space-based rather than image space-based. This object space orientation allows Gatun to incrementally build up the contribution of each tetrahedron to the intersecting rays as it is decompressed. It exploits the tetrahedral adjacency information, which is created and exploited by the tetrahedral mesh compression algorithm, to perform on-the-fly rendering of uncompressed tetrahedra without waiting for the whole data set to be completely decompressed. As a result, the start-up latency for rendering a compressed tetrahedral mesh is minimal. To support incremental rendering, the compression algorithm traverses the tetrahedral mesh from the external surface "inwards" towards the core of the data set. As new tetrahedra appear in the decompression process, their contributions to the rays that intersect with them are accumulated. This incremental rendering algorithm includes a new tetrahedron interpolation scheme and a new segment-based compositing formula, and implements unit sampling distance as in standard regular-grid volume rendering.</p><p>A key innovation of Gatun is its ability to determine when a tetrahedron is no longer needed and de-allocate the memory allocated to the tetrahedron as soon as it is done. As a result, Gatun reduces the maximal memory footprint to as low as one fifth of the entire data set and greatly improves the rendering performance of very large data sets by avoiding paging. In summary, Gatun streamlines the decompression and rendering of losslessly compressed tetrahedral mesh and significantly reduces the run-time memory and disk bandwidth requirements. In certain cases, Gatun makes it possible to render certain data sets on a machine that were not even "runnable" with standard irregular-grid volume renderers.</p><p>The rest of this paper is organized as follows. We review related work on tetrahedral mesh compression, as well as on irregular grid rendering in the next section. Section 3 presents the proposed tetrahedral mesh compression algorithm and how it is designed to facilitate integration with the rendering process. In Section 4, we describe the on-the-fly rendering algorithm that is tightly coupled with the mesh decompressor, and the current prototype implementation. Section 5 reports the performance measurements of Gatun prototype for six irregular-grid data sets with the number of tetrahedra ranging from 1.3K to 1M . Section 6 summarizes the main research contribution of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>In the area of lossless tetrahedral mesh compression, there are two existing methods. The first one was proposed by Szymczak <ref type="bibr" target="#b12">[13]</ref>. Their representation consists of a tetrahedron spanning tree string, which is obtained by recursively attaching tetrahedra to external faces starting from an arbitrary tetrahedron, and a folding string, which defines the incidence relations among the remaining external faces. Their method requires 7 bits per tetrahedron on an average to represent the topology. The second method, proposed by Gumhold <ref type="bibr" target="#b4">[5]</ref> achieves by far the best compression efficiency for tetrahedral meshes. Their cut-border engine starts with the faces of an arbitrary tetrahedron and attempts to add tetrahedra to the external faces through different operations. They require 2.04 bits per tetrahedron on an average. The compression algorithm used in Gatun is similar in spirit to this approach. However, the operations we perform and the heuristics we use are much simpler and lead to faster implementation.</p><p>There are several early works on rendering of irregular grids. Wilhelms et. al. <ref type="bibr" target="#b14">[15]</ref> applied a re-sampling technique to reduce the problem to the rendering of traditional regular rectilinear grids. However, to represent the finest details, the re-sampling overhead may be exceedingly high. Another attempt from Fruhauf <ref type="bibr" target="#b1">[2]</ref> tried to apply the traditional algorithm, originally designed for rectilinear grids, to curvilinear grids by casting "curved" rays to fit the curvilinearity of the data set. However this approach can not be readily applied to the unstructured grids. Another school of algorithms is called "sweeping" algorithm, proposed originally by Giertsen <ref type="bibr" target="#b3">[4]</ref> and later improved or modified by Silva and Yagel <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16]</ref>. While the algorithm in <ref type="bibr" target="#b15">[16]</ref> needs a large amount of memory and high-end graphics engines, the approach in <ref type="bibr" target="#b10">[11]</ref> is more memory efficient and reasonably fast even when a moderate graphics engine is available. However, Bunyk et. al. <ref type="bibr" target="#b0">[1]</ref> presented a much faster algorithm based on the works from Garrity and Uselton <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14]</ref>. This algorithm, although still requires a great deal of memory for good performance, does provide a good starting point to derive the rendering algorithm used in Gatun. Another completely different approach to render irregular grids is through "projection." Here, each tetrahedron is scan-converted and displayed on the image plane through a projection process that takes into account the depth information. The idea was proposed independently by Max et. al. <ref type="bibr" target="#b7">[8]</ref> and Shirley et. al. <ref type="bibr" target="#b9">[10]</ref>. The best property of this approach is that it can take advantage of the standard 3D graphics hardware. But a major drawback is that it requires depth-sorting of the tetrahedra in order to generate correct composited image. The work from <ref type="bibr" target="#b6">[7]</ref> uses a hybrid scheme by "splatting" the sample points obtained from the object base. However, it requires a re-sampling process and sorting to get the correct result. Ma <ref type="bibr" target="#b5">[6]</ref> and Silva <ref type="bibr" target="#b11">[12]</ref> have tried to parallelize irregular volume rendering algorithms. In contrast, the target machines of this project are mostly PC workstations which in general are single-processor machines.</p><p>Gatun uses an object space-based ray-casting approach. Because of ray-casting, the resulting rendered image quality is high. Because of the object space architecture, rendering can be done incrementally and thus can be nicely tied with the mesh decompression process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Tetrahedral Mesh Compression</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>Given a tetrahedral mesh, the proposed tetrahedral mesh compression algorithm starts with the boundary faces and then grows the surface inwards by visiting the tetrahedron that is paired with each boundary face. After all the tetrahedra that can be paired with the current surface are visited, the set of faces of these tetrahedra, that are not part of the current surface, form a new surface. The algorithm then continues with this new surface to visit more tetrahedra, iteration by iteration, until it visits every tetrahedron in the mesh. The input tetrahedral mesh consists of a vertex array containing the geometry information associated with the vertices and a tetrahedron array containing four vertex indices per tetrahedron. The output of the tetrahedral mesh compression algorithm also consists of two parts: a representation of the boundary surface and a representation of the geometry and connectivity of the tetrahedral mesh. To represent the boundary surface of a tetrahedral mesh efficiently, we use a triangle mesh compression algorithm described in <ref type="bibr" target="#b8">[9]</ref>, which is based on a similar breadth-first-traversal approach applied to triangle meshes. The geometry information associated with a vertex, such as coordinate and density value, appear in the compressed output only once, when either the first boundary face or the first tetrahedron containing that vertex is visited. The first time the geometry information of a vertex appears in the input, it is appended to the vertex table. Future references to this vertex can then be an index access to the vertex table. The order of the first appearance of each vertex in the input determines the index of the vertex in the vertex table, which is implicitly agreed upon by the mesh compressor and decompressor. In the proposed tetrahedral mesh compression algorithm, visiting a tetrahedron means denoting the fourth vertex that pairs with a triangle face on the current surface. If the fourth vertex of every visited tetrahedron is explicitly represented by its geometry information in its first appearance and as an index into the vertex table for all subsequent appearances, then it takes N − V indices where N is the number of tetrahedra, V is the number of vertices, and the size of each vertex index is log(V ) bits. The challenge of the tetrahedral mesh compression algorithm design is to represent "fourth" vertices implicitly by exploiting connectivity information, so that fewer than log(V ) bits per tetrahedron is required.</p><p>Let us call the particular face with which to pair a "fourth" vertex as the current face. A face is a partly-used face if only one of its adjoining tetrahedra is not yet visited. A partly-used face is either a boundary face with no adjoining visited tetrahedron or a non-boundary face with one adjoining visited tetrahedron. This is because a boundary face has exactly one adjoining tetrahedron and a non-boundary face has two adjoining tetrahedra. Let T be the triangle mesh containing all the partly-used faces as the compression algorithm visits the tetrahedral mesh. The current face is an element of T . In most cases, the fourth vertex that pairs with the current face is a vertex that belongs to one of the edge-adjacent faces of the current face in T . Note that the triangle mesh T can be non-manifold with the implication that an edge of the current face can have more than one adjacent faces. To denote the face with which the pairing vertex is associated, we order the faces edge-adjacent to the current face. First, we order the vertices of the current face according to their indices to the vertex table. Let this order be (v1, v2, v3), and let n1, n2, n3 be the number of faces adjacent to the edges (v1, v2), (v2, v3), and (v3, v1) respectively (excluding the current face). Then the faces adjacent to the current face are numbered If a pairing vertex cannot be represented by an edge-adjacent face, there are two possibilities: (1) the vertex appears for the first time in the input or (2) the vertex appeared earlier. In the first case, we can store the geometry information associated with the vertex into the vertex table. In the second case (which fortunately does not occur frequently), we first check if the paring vertex belongs to a face adjacent to a vertex of the current face, see <ref type="figure">Figure 2</ref>. If so, the vertex is specified according to its position in an ordered vertex list that includes all the vertices that belong to faces adjacent to vertices (but not edges) of the current face. The order of the vertices is determined by the order in which the vertex adjacent faces they belong to are visited during compression/decompression. If the pairing vertex is not incident to any vertex of the current face, it is represented by its index value into the vertex table. Once the fourth vertex of a tetrahedron is determined, the three faces of the tetrahedron other than the current face are examined individually. For each of these faces, if it is marked partly-used, then all the adjoining tetrahedra of that face have been visited and the face can be deleted. If not, we mark the face as partly-used and put it in the next surface for the next iteration. Finally, the current face is deleted.</p><p>The compression algorithm as described above does not specify which face of a surface to start with. The choice of the current face has direct impact on compression efficiency since it determines where the fourth vertex falls in the neighborhood of a face. Gatun chooses to use the order as determined by the triangle mesh traversal and completes the formation of tetrahedra for all of them before moving onto the next iteration. This design decision is based on the belief that peeling the tetrahedral mesh layer by layer will allow the rendering process to complete the processing of a tetrahedron as early as possible. Within an iteration, we choose to follow the generation order of the faces, and empirical results indicate that this heuristic works well. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Encoding of the Compressed Mesh</head><p>The encoding for the boundary faces of a tetrahedral mesh is based on a triangle mesh compression algorithm described in <ref type="bibr" target="#b8">[9]</ref>. The way each tetrahedron is represented depends on whether the fourth vertex is represented explicitly, using geometry information, or using connectivity information. There are four different commands for the encoding:</p><p>1. EXPLICIT {geometry information}: This is for explicit representation of a vertex when it first appears in the input mesh. 2. INDEX {index value}: This corresponds to the case when the fourth vertex is represented as an index into the vertex table. 3. FACE {order}: This is used when the fourth vertex belongs to a face incident to an edge of the current face. The order is the order of the face among the adjacent faces as defined earlier. 4. VERTEX {order}: This is used when the fourth vertex belongs to a face adjacent to a vertex of the current face and cannot be represented by face-adjacency. The order is determined using the method discussed in subsection 3.1.</p><p>After the tetrahedra are represented using the above commands, we apply Huffman encoding on the resultant command sequence to achieve on an average 22% further compression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Data Structure</head><p>Because Gatun streamlines the decompression and rendering steps, the decompression step must be sufficiently simple to reduce its impacts on run-time performance. The mesh decompressor maintains the following data structures:</p><p>1. Vertex <ref type="table">Table contains</ref> the geometry information of the vertices and is accessed by both the decompressor and the renderer. The table can be re-created on the fly from the compressed mesh. 2. Partly-Used Face List is a list of partly-used faces for each vertex at any point of time. This list changes dynamically as faces are created and deleted. This list is used to determine the particular face/vertex given the FACE {order} and VER-TEX {order} command.</p><p>3. Surface Queues are the two queues of faces corresponding to the triangle meshes associated with the current iteration and the next iteration. The decompressor dequeues faces from the current-iteration surface queue and adds the newly generated faces to the next-iteration surface queue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">On-the-Fly Rendering of Compressed Grids 4.1 Baseline Algorithm</head><p>The baseline tetrahedron mesh rendering algorithm is based on the work described in <ref type="bibr" target="#b0">[1]</ref>. Although this algorithm was designed for parallel projection, it can be readily extended to support perspective projection. The algorithm has a "view-independent" preprocessing step that identifies the adjacency information and some normal vector processing associated with each face of the input tetrahedral mesh. The adjacency information includes which vertices are used in which faces, and which faces are used in which tetrahedra.</p><p>Given a view angle, the baseline algorithm first identifies the intersections between the input mesh's boundary faces and all the cast rays. More concretely, the algorithm back-projects each boundary face to the image plane, finds a bounding box for the projected footprint, and tests every ray inside the bounding box to check whether it falls within the boundary face's projected footprint. An optimization to this step is to perform this intersection computation only for boundary faces whose projected footprint is not completely occluded. Once the set of intersecting boundary faces are identified, the algorithm sorts the intersection points with respect to a ray according to their distance from the origin of the ray on the image plane. Note that a ray may have more than two intersection points if the input tetrahedral mesh is not convex.</p><p>The final phase of the baseline algorithm is a ray-casting process. For each ray, the algorithm retrieves the first boundary face that it intersects, then the face's associated tetrahedron, and then the next face of the same tetrahedron that this ray passes through. If this next face is a not a boundary face, then the "next" tetrahedron that shares this new face is retrieved. Through the same process, a ray can go through faces of neighboring tetrahedra until it hits another boundary face and exits the data set. The adjacency information computed by the pre-processing step plays an important role in allowing the algorithm to quickly identify which faces and tetrahedra (c) represents a more general case where the data set has multiple segments for some rays, while (d) shows our modified version of rays for the same data set.</p><p>to retrieve for a given ray at run time. As the baseline algorithm traverses the sample points on a cast ray, it performs interpolation of density values, maps density values into color and opacity values, and accumulates the contributions of sample values through standard compositing formulas. The sampling approach used here is a unit-distance sampling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Gatun Approach</head><p>The goal of on-the-fly mesh rendering is to accumulate the contribution of each tetrahedron as it is output from the decompressor. This way there is no need to wait for the entire decompression process to complete and the memory allocated to the tetrahedra can be freed as soon as possible. Gatun uses an object-space ray-casting algorithm to achieve this goal. The fundamental problem is to identify the set of rays cast from the image plane that intersect with a given tetrahedron. Compared to the baseline algorithm, which assumes that an uncompressed tetrahedral mesh is already available, Gatun does not have all the adjacency information immediately available, and the ray-casting process is dictated by the order of the tetrahedra that the decompressor outputs. By employing an inward approach towards tetrahedral mesh compression, Gatun exploits the explicit representation of boundary surfaces to calculate the intersections between the boundary sur- faces and the cast rays. Then a ray is decomposed into a set of one or multiple segments, each corresponding to a contiguous section of the ray that intersects with the input data volume, as shown in <ref type="figure" target="#fig_3">Figure 4</ref>. Notice that each ray is duplicated not only in the opposite direction, but also in each segment. Moreover, each segment is further decomposed into two subsegments, one starting with the end closer to the image plane and having the original raycast direction, while the other starting with the end that is further away from the image plane and having the opposite of the original raycast direction, as shown in <ref type="figure" target="#fig_4">Figure 5</ref>.</p><p>Once the intersection points between the boundary faces and the rays are available, each ray is "attached" to its corresponding boundary face. As mentioned in the previous paragraph, since each ray in duplicated in each segment and for both directions, therefore it becomes easier to identify all the rays that intersect with a given tetrahedron as early as possible. Every time a tetrahedron is output from the decompressor, Gatun checks if there are any rays attached to any of its four faces, and if so, advances those rays as much as possible. To determine whether a ray has exhausted all the tetrahedra that it can possibly intersect, the renderer maintains a water mark that represents the current progress of each subsegment, and concludes that a segment is "done" when the water marks of these co-locating subsegments meet.</p><p>Because of the use of segments and subsegments, the compositing process associated with a ray is necessarily hierarchical: a standard front-to-back compositing algorithm is used within a subsegment, and a slightly modified front-to-back compositing algorithm is used between subsegments and between segments. The sampleto-sample front-to-back compositing formulas are:</p><formula xml:id="formula_0">Cout = Cin + (1 − Oin)CvOv (1) Oout = Oin + (1 − Oin)Ov<label>(2)</label></formula><p>where Cin and Oin are the input color and opacity values, Cout and Oout are the output color and opacity values, Cv and Ov are the color and opacity values of the sample point v, which are the results of applying the desired color and transfer functions to the interpolated density values of v. It can be shown that to maintain the same sample-by-sample compositing semantics the subsegmentby-subsegment compositing formula are:</p><formula xml:id="formula_1">C total = C f ront + (1 − O f ront )C back (3) O total = O f ront + (1 − O f ront )O back<label>(4)</label></formula><p>where Because Gatun uses an object-space rendering algorithm that processes those rays that intersect with each tetrahedron, it is conceivable that the memory allocated for a tetrahedron can be freed as soon as it is done, thus significantly reducing the memory footprint requirement of the rendering process. However, this requires Gatun to maintain the following invariant: whenever a tetrahedron is processed, all the rays that can intersect with this tetrahedron have already been attached to its faces. This invariant does not hold in general, because when the decompressor outputs a tetrahedron, some of the rays that intersect with this tetrahedron may not arrive at its faces yet. For example, in <ref type="figure">Figure 6</ref>, if tetrahedron A is output first, then only the rays for its face a have arrived. Those rays that are to be attached to face e through face c have not come yet.</p><formula xml:id="formula_2">C</formula><p>To address this problem, Gatun checks whether a tetrahedron is ready before processing it. A tetrahedron is ready if: the projection of "processed" faces of this tetrahedron covers the projected footprint of the tetrahedron. This check is called the readiness check. A face is processed if all the rays that can be attached to the face have already been attached. Initially all the faces are unprocessed. There are only two cases in which a face can become processed. First, the face is a boundary face, for which Gatun uses back projection to identify all the intersecting rays. Therefore by definition it is a processed face. Second, the face belongs to a tetrahedron that is ready. By definition, a tetrahedron is ready if all the rays that can be attached to it are already attached, therefore after the processing of the tetrahedron, all its constituent faces must become processed. After a tetrahedron is processed, the memory allocated to it is freed.</p><p>Gatun uses a tetrahedron classification scheme to classify the projection of a tetrahedron into a fixed number of cases in order to decide if the projected footprint of the processed faces of a tetrahedron is the same as the projection of the entire tetrahedron. There are 6 different possible shapes for a tetrahedron's projection image, as shown in <ref type="figure">Figure 7</ref>. The algorithm first tries to decide which case it is for a given tetrahedron. It first checks if there exists any pair of vertices whose projections are exactly the same. If yes, then the projection shape must be either case (d), (e) or (f) in <ref type="figure">Figure 7</ref>; otherwise, the projection shape is either case (a), (b) or (c). Let p0, p1, p2 and p3 represent the projected 2D points of the tetrahedron's four vertices on the image plane, and ij the vector pointing from pi to pj. For cases (a), (b) and (c), the algorithm performs four 2D cross products: 01 × 02, 01 × 03, 12 × 13 and 02 × 03, and classifies each tetrahedron according to the signs of these results: positive, negative or zero. For cases (d), (e), and (f), the algorithm performs three 2D cross products: 01 × 02, 01 × 03 and 02 × 03, and classifies them according to the signs of these cross products. If all of the three cross products are zero, then the projection of the tetrahedron must be a segment or a point, for which further distinction is not necessary because practically such a tetrahedron would not intersect rays. To speed up tetrahedron classification, we use a radix-3 table look-up scheme to map the results of cross products to the classification decision. On a Pentium II 300MHz machine, this algorithm takes less than 1.5 secs to classify 1M tetrahedra.</p><p>After a tetrahedron's projection is classified, Gatun performs the readiness check on the tetrahedron. For example, if an tetrahedron's projection is case (a) in <ref type="figure">Figure 7</ref> with p3 in the center, then there are two ways to "cover" this projection: 012 or 013 ∪ 123 ∪ 203, where ijk is a face formed from pi, pj and p k . So in this case, if 012 is already a processed face, then the entire tetrahedron is covered and therefore ready. Scenarios in which two processed faces are required to cover a tetrahedron's projection can be found from group (b) and (c) in <ref type="figure">Figure 7</ref>.</p><p>It should be noted that a tetrahedron must be ready when more than two of its faces are processed, and a tetrahedron cannot be ready when none of its faces is processed. Therefore the readiness check only needs to be applied to a new tetrahedron when it has one or two processed faces. When the decompressor outputs a tetrahedron, if the renderer cannot conclude that it is ready, then the renderer puts this tetrahedron to the waiting field of all its unprocessed faces. If on the other hand the new tetrahedron is determined to be ready, then the renderer processes all the attached rays by accumulating the contributions from the tetrahedron to the rays from the processed faces, advancing these rays according to their casting direction, and eventually attaching these rays to other faces of this tetrahedron. As for unprocessed faces, they turn processed as more rays are attached to them during the processing of the tetrahedron.</p><p>After a tetrahedron is processed, the renderer examines each constituent face. If a face is previously processed, then it is freed because all its adjoining tetrahedra have been visited. If a face is unprocessed, Gatun changes the status of this face to processed, removes the tetrahedron in its waiting field, and performs the readiness check on the tetrahedron just removed to see if it, with the addition of this processed face, is ready or not. If the tetrahedron indeed turns ready, Gatun continues to process this tetrahedron. Whenever a tetrahedron is found to be ready, it is put into a tetrahedra working queue. Gatun returns control to the decompressor to output new tetrahedra only when this working queue is empty, which means either currently all the non-ready tetrahedra are waiting for some faces to become processed, or all the tetrahedra have been processed already. Because a non-ready tetrahedron is put into the waiting field of all its unprocessed faces, there is a bit in the tetrahedron data structure to indicate that a given tetrahedron is already put in the tetrahedra working queue to avoid duplicated insertion from multiple faces.</p><p>With the tetrahedron classification scheme for efficient readiness check, Gatun is able to free at least 98% more tetrahedra on an average from the memory, compared to the naive approach where a tetrahedron can be released only if it has more than two processed faces. Moreover, the smaller working set also leads to better overall performance in many cases, as will be shown in the performance evaluation section. <ref type="table" target="#tab_1">Tetrahedra  Faces  Boundary  Faces  Spx  2896  12936  27252  2760  Fighter  13832  70125  143881  7262  Blunt  40960  187395  381548  13516  Combustion  47025  215040  437888  15616  Post  109744  513375  1040588  27676  Delta  211680  1005765  203208  41468   Table 1</ref>: Description of our testing data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data set Points</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Performance Evaluation</head><p>The performance evaluation of Gatun is carried out on a Pentium II 300 MHz machine with 320 MB memory. The data sets used are shown in <ref type="table">Table 1</ref>, ordered by the number of tetrahedra. While the first two data sets are unstructured grids, the remaining four are converted into tetrahedral grids from originally curvilinear grids. The intent of including the first two grids into our experiments is to demonstrate that our algorithm can be applied to both structured and unstructured grids. <ref type="table" target="#tab_1">Table 2</ref> presents the compression performance. The command sequence generated by the compression code is run through a static Huffman encoder to arrive at the final compressed output. The first and second columns show the cost in bytes to represent the boundary faces and the tetrahedra. This cost is only for the topology. We ignore the cost of geometry information in this work. The Total Cost column indicates the sum of boundary faces and tetrahedra representation. The fourth column shows the average number of bits required to encode the topology of a tetrahedron. Column five and six show the percentage savings with respect to the number of bytes for the topology and the topology plus geometry of the input data set. The input representation is a vertex array followed by the tetrahedra represented as four indices into the vertex array. Pervertex geometry costs 16 bytes, 12 for coordinates and 4 for density.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Compression Efficiency</head><p>Finally, the last column shows the decompression speed in tetrahedra per second. This decompression speed is for topology only and does not include the disk I/O cost. On an average, our encoding requires 2.31 bits per tetrahedron and can be decompressed at the rate of 162K tetrahedra/sec. Our compression efficiency is comparable to that of <ref type="bibr" target="#b4">[5]</ref>, which is the most efficient tetrahedral compression algorithm developed so far and requires 2.04 bits on an average, and our encoding can be decompressed 1.5 times as fast. <ref type="table" target="#tab_3">Table 3</ref> represents the distribution of different commands for implicitly represented fourth vertex. The first three cases represent the Face {order} command with order value 0, 1 or 2. The last case represents the Vertex {order}, Index {index value}, and Face {order} command with order greater than 2. Across all data sets, more than 88% of the time, the fourth vertex can be represented with Face 0, Face 1, or Face 2 commands. In fact, for all curvilinear data sets, the pairing vertex can be covered with these three commands for 99% cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Rendering Performance</head><p>To evaluate the performance of Gatun , we first modified the baseline renderer (called generic renderer hereafter) so that it reads the compressed data set from the disk, uncompresses the entire data set, and then starts the rendering. To show that Gatun can improve the rendering performance in many cases with a much smaller memory    The total execution time of the generic renderer and Gatun corresponding to four different image resolutions for all data sets are shown. When the system has 320 MB of main memory, the entire working set can be memory resident for all the data sets. However, as can be seen from <ref type="table" target="#tab_2">Table 4</ref>, a system with 160 MB main memory fails to hold the data set for Post at resolution 1024 × 1024 and Delta at all resolutions, and a system with 80 MB main memory fails to hold the data sets for Blunt and Combustion at resolution 1024 × 1024 and Post, Delta at all resolutions, leading to paging, and hence longer execution time. Moreover, even with paging, the generic renderer fails to run Delta at the resolutions of 512 × 512 and 1024 × 1024 with 160MB of memory, and Post at resolution 1024 × 1024 and Delta at all resolutions with 80MB of memory. Therefore their corresponding timings can not be shown in <ref type="figure">Figure 9</ref>. However, Gatun can complete the rendering for these data sets due to its smaller memory footprint. In general, performance of Gatun is much better than the generic renderer when the working set of the generic renderer cannot fit in the main memory, resulting in considerable virtual memory paging. In general, Gatun achieves around 8.2% performance improvement for smaller resolutions and around 40% for higher resolutions. Even when the entire working set can be resident in the main memory, as in the case of 320MB memory setting, Gatun can improve the rendering performance by as much as 30% for large data set and high image resolutions.</p><p>For some data sets and for small image resolutions, Gatun might perform worse than the generic renderer. The reasons behind this performance loss are the following. First, Gatun needs to attach rays from face to face, an overhead that does not appear in the generic approach where each ray is dealt with one at a time. The generic approach therefore does not involve any intermediate bookkeeping cost. Second, Gatun needs to maintain the invariant that each tetrahedron, when being processed, has already had all the rays attached to its faces. This involves the readiness checks and possibly some queuing/dequeuing of tetrahedra to/from their faces. These overhead turn out to be non-negligible in some low resolution cases. The fundamental trade-off we face here is between performance and memory. De-allocating the memory for a tetrahedron requires performing the classification. For the generic renderer, it can be shown that for Delta at 256 × 256 image resolution , only about one third of the tetrahedra would intersect the rays. Therefore in Gatun about two third of the effort to "classify" and thus releasing the allocated memory for tetrahedra will end up as redundant work. Thus the effort to reduce the memory usage results in more computation in this case, which in turn may hurt the performance. As can be seen from <ref type="figure">Figure 9</ref>, as the image resolution increases, and higher percentage of tetrahedra get "touched", a higher percentage of the classification becomes useful, and therefore the advantage of using smaller memory begins to emerge. Another subtle point worth pointing out is the following. Since we are dealing with one tetrahedron at a time, it seems it should exhibit better memory locality than that of the generic renderer where the memory access pattern is considerably random, determined by the traversal of the rays along the data set. <ref type="figure">Figure 8</ref> (color plate) shows the peak memory requirement for Gatun and generic renderer corresponding to different image resolutions. In general, the peak memory requirement of Gatun is around 50-70% of the generic renderer. As the image resolution increases, the difference becomes more significant. However, at 512 × 512 and 1024 × 1024 image resolutions for the Spx data set, Gatun uses a little more peak memory than that in the generic renderer. This is because Spx is a non-convex dataset with holes, and therefore the average number of segments per ray is slightly higher than in the other data sets. This results in extra storage and processing overhead for the segments. However, we should point out that most of the time the memory usages of Gatun are below the corresponding peak memory usage because of the early deallocation scheme we employ, whereas for generic renderer peak memory requirement is constant for the entire duration of the rendering process. <ref type="figure" target="#fig_7">Figure 10</ref> (color plate) shows some images rendered by our system. We applied the linear color transfer function from <ref type="bibr" target="#b0">[1]</ref> and a linear opacity transfer function by mapping the highest density value to 1 and the lowest to 0. No directional shading is applied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Very large irregular-grid volume data set is becoming more or more popular in the scientific computing community because it is a natural fit for modeling the physical world. Rendering of irregular or unstructured grids could incur significant disk I/O overhead due to both initial data loading and virtual memory paging. Compression is an effective technique to reduce the memory requirements at run time. While existing rendering systems require the input data set to be completely uncompressed before the rendering starts, the system described in this paper called Gatun supports a novel on-the-fly rendering method for losslessly compressed tetrahedral mesh. To further reduce the memory usage, Gatun features a unique "garbage detection" technique that can quickly recognize the tetrahedra that have been processed completely and thus can be safely discarded without affecting the correctness of the rendering programs.</p><p>Performance measurements on the first Gatun prototype shows that the lossless compression algorithm used in Gatun achieves a compression efficiency of 5 times on an average, the run-time memory requirements are reduced by up to a factor of 7, and the performance can be one or two orders of magnitude better when the data set size is larger than the host memory size. Even when the whole data set is memory resident, Gatun's integrated rendering algorithm is up to 30% better than a "store and forward" approach because it exhibits better data access locality.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>The fourth vertex of a tetrahedron belongs to a face that is adjacent to the current face The fourth vertex belongs to a face adjacent to a vertex (but not edge) of the current face. The shaded triangle is the current face and f 0 • • • f 7 are the adjacent faces in the current triangle mesh. Only vertices 0, 1 ,2 and 3 belong to vertex adjacent faces and vertex 3 is the fourth vertex. 0, 1, . . . , n1 + n2 + n3 − 1. The ordering among faces adjacent to the same edge is determined by the order in which they are visited during compression/decompression. Thus the ordering of adjacent faces with respect to the current face is guaranteed to be unique and shared by the compressor and the decompressor. Given this ordering, specifying the neighboring face that contains the pairing vertex specifies the fourth vertex and visits the associated tetrahedron. Empirical results indicate that the index value of the "pairing face" is 0, 1, 2 in most of the cases.Figure 1shows how the fourth vertex can be represented using the ordering discussed above. The vertices are ordered as v1, v2, v3. The faces associated with the edges are ordered as F 0, F 1, F 2 and F 3 respectively. The fourth vertex belongs to the face F 2 and hence, in this case the specification for the pairing vertex is 2. This introduces two new faces, d (v1, v2, v4) and e (v1, v3, v4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3</head><label>3</label><figDesc>illustrates how the visit of a tetrahedral mesh starts from the boundary surface. The leftmost figure shows the traversal order of the triangles as determined by the triangle mesh compression algorithm. The rest of the figure shows the formation of the tetrahedra. The bold lines indicate the tetrahedron enumerated for a particular boundary face. Notice that faces 1, 3, 5, 6, and 9 form new tetrahedra with explicitly represented vertices, whereas other tetrahedra are formed by pairing up with a neighboring face. The rightmost figure shows the new faces that will participate in the next iteration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Enumeration of tetrahedra and creation of the new surface starting from the boundary surface of a sample tetrahedral mesh.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>A 2D example of the original rays versus the modified rays. In (a), all the rays are shooting in one direction, while in (b), for the same data set, rays are duplicated in the opposite directions;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>A 2D example of the segment and subsegments for a given ray.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>f ront and O f ront are the color and opacity values of the front subsegment, C back and O back , are the color and opacity values of the back subsegment, and C total and O total are the color and opacity values of the encompassing segment. This figure shows a 2D case where a tetrahedra traversal order may lead to the late arrival of some rays. The possible geometrical shapes of a tetrahedron's projection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Peak memory requirement for different data sets. Execution time for all memory configurations and for all test data sets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Some rendered images from our system. From left to right: Blunt-fin, Combustion Chamber and Fighter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Compression performance. The cost is in bytes</figDesc><table><row><cell>Data Set</cell><cell>Image</cell><cell cols="2">160 MB</cell><cell cols="2">80 MB</cell></row><row><cell></cell><cell>Resolution</cell><cell>Generic</cell><cell cols="2">Gatun Generic</cell><cell>Gatun</cell></row><row><cell>Blunt-fin</cell><cell>1024 × 1024</cell><cell>125.88</cell><cell>97.36</cell><cell>245.54*</cell><cell>97.96</cell></row><row><cell cols="2">Combustion Chamber 1024 × 1024</cell><cell>141.28</cell><cell cols="2">123.12 601.17*</cell><cell>176.15*</cell></row><row><cell>Liquid</cell><cell>128 × 128</cell><cell>18.51</cell><cell>19.17</cell><cell>705.67*</cell><cell>19.26</cell></row><row><cell>Oxygen</cell><cell>256 × 256</cell><cell>24.80</cell><cell>23.40</cell><cell>791.35*</cell><cell>23.45</cell></row><row><cell>Post</cell><cell>512 × 512</cell><cell>54.06</cell><cell>40.69</cell><cell>964.70*</cell><cell>40.73</cell></row><row><cell></cell><cell>1024 × 1024</cell><cell>284.95*</cell><cell>122.16</cell><cell>N/A</cell><cell>3129.55*</cell></row><row><cell>Delta Wing</cell><cell>128 × 128</cell><cell>2414.41*</cell><cell>47.77</cell><cell>N/A</cell><cell>50.26</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 4 :</head><label>4</label><figDesc>Execution time for four data sets at some resolutions for 160 MB and 80 MB memory capacity. "*" means paging happened.</figDesc><table><row><cell>Dataset</cell><cell cols="4">Face 0 Face 1 Face 2 Others</cell></row><row><cell>Spx</cell><cell>73.49</cell><cell>8.30</cell><cell>7.16</cell><cell>11.05</cell></row><row><cell>Fighter</cell><cell>75.71</cell><cell>7.75</cell><cell>7.48</cell><cell>9.06</cell></row><row><cell>Blunt</cell><cell>54.69</cell><cell>28.12</cell><cell>16.12</cell><cell>1.07</cell></row><row><cell>Combustion</cell><cell>54.78</cell><cell>28.09</cell><cell>15.88</cell><cell>1.25</cell></row><row><cell>Post</cell><cell>53.67</cell><cell>28.85</cell><cell>16.67</cell><cell>0.81</cell></row><row><cell>Delta</cell><cell>52.79</cell><cell>29.46</cell><cell>17.12</cell><cell>0.63</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Distribution</figDesc><table><row><cell>of different commands for implicitly repre-</cell></row><row><cell>sented fourth vertex</cell></row><row><cell>footprint, in addition to the original 320 MB memory configuration,</cell></row><row><cell>we use the memory configurations of 160 MB and 80 MB as well.</cell></row><row><cell>Figures 9 (color plate) summarizes the performance comparison</cell></row><row><cell>between Gatun and the generic renderer with three different main</cell></row><row><cell>memory settings: (1)320 MB, (2) 160 MB and (3) 80 MB and four</cell></row><row><cell>image resolutions: (1) 128 × 128, (2) 256 × 256, (3) 512 × 512 and</cell></row><row><cell>(4) 1024 × 1024.</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgment</head><p>Thanks to Paul Bunyk, Claudio Silva, Lichan Hong and Kwan-liu Ma for providing some helpful discussions and the NASA testing data sets. This research is supported by an NSF Career Award MIP-9502067, NSF MIP-9710622, NSF IRI-9711635, NSF EIA-9818342, NSF ANI-9814934, a contract 95F138600000 from Community Management Staff's Massive Digital Data System Program, USENIX student research grants, as well as funding from Sandia National Laboratory, Reuters Information Technology Inc., and Computer Associates/Cheyenne Inc.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Simple, Fast and Robust Ray Casting of Irregular Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bunyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Center for Visual Computing</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
		<respStmt>
			<orgName>State University of New York at Stony Brook</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Raycasting of Nonregularly Structured Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fruhauf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum (Eurographics &apos;94)</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Raytracing Irregular Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (San Diego Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1990-11" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="35" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Volume Visualization of Sparse Irregular Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Giertsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="40" to="48" />
			<date type="published" when="1992-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Tetrahedral Mesh Compression with the Cut-Border Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straβer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Annual IEEE Visualization Conference</title>
		<meeting>the 10th Annual IEEE Visualization Conference</meeting>
		<imprint>
			<date type="published" when="1999-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parallel Volume Rendering for Unstructured-Grid Data on Distributed Memory Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/ACM Parallel Rendering Symposium &apos;95</title>
		<meeting>IEEE/ACM Parallel Rendering Symposium &apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Splatting of Curvilinear Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="61" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Area and Volume Coherence for Efficient Visualization of 3d Scalar Functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (San Diego Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1990-11" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="27" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Breadth-First Approach to Efficient Mesh Traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM SIGGRAPH/Eurographics Workshop on Graphics Hardware</title>
		<meeting>the 13th ACM SIGGRAPH/Eurographics Workshop on Graphics Hardware</meeting>
		<imprint>
			<date type="published" when="1998-09" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Polygonal Approximation to Direct Scalar Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Parallel Volume Rendering of Irregular Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, State University of New York at Stony Brook</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Lazy Sweep Ray Casting Algorithm for Rendering Irregular Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Grow &amp; Fold: Compression of Tetrahedral Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM Symposium on Solid Modelling and Applications</title>
		<meeting>the 5th ACM Symposium on Solid Modelling and Applications</meeting>
		<imprint>
			<date type="published" when="1999-06" />
			<biblScope unit="page" from="54" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Volume Rendering for Computational Fluid Dynamics: Initial Results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Uselton</surname></persName>
		</author>
		<idno>RNR-91-026</idno>
		<imprint>
			<date type="published" when="1991" />
			<pubPlace>Nasa Ames Research Center</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Direct Volume Rendering of Curvilinear Volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Challinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Alper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramamoorthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vaziri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (San Diego Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1990-11" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="41" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hardware Assisted Volume Rendering of Unstructured Grids by Incremental Slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P-W</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization Symposium</title>
		<imprint>
			<date type="published" when="1996-11" />
			<biblScope unit="page" from="55" to="62" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
