<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Geometric Compression For Interactive Transmission</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Devillers</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">INRIA Sophia Antipolis</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Marie</forename><surname>Gandoin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">INRIA Sophia Antipolis</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Geometric Compression For Interactive Transmission</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>geometry</term>
					<term>compression</term>
					<term>coding</term>
					<term>interactivity</term>
					<term>mesh</term>
					<term>reconstruction</term>
					<term>terrain models</term>
				</keywords>
			</textClass>
			<abstract>
				<p>The compression of geometric structures is a relatively new field of data compression. Since about 1995, several articles have dealt with the coding of meshes, using for most of them the following approach: the vertices of the mesh are coded in an order that partially contains the topology of the mesh. In the same time, some simple rules attempt to predict the position of each vertex from the positions of its neighbors that have been previously coded. In this article, we describe a compression algorithm whose principle is completely different: the coding order of the vertices is used to compress their coordinates, and then the topology of the mesh is reconstructed from the vertices. This algorithm achieves compression ratios that are slightly better than those of the currently available algorithms, and moreover, it allows progressive and interactive transmission of the meshes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivations</head><p>In the context of image visualization in a network application, a remote server has to transmit data to a client. This data is usually bitmap data and is transferred through some compression algorithm. This method has also been used in the past for computer graphics images, but in that special case, another solution consists in transmitting the scene description and in running the image synthesis program on the client. A 3D geometric scene is made of polygons, and so is typically coded as a sequence of numbers (the vertex coordinates) and tuples of vertex pointers (the edges joining the vertices).</p><p>If the problem of bitmap image compression has already been widely studied, the compression of geometric data, lying between computational geometry and standard data compression, is quite a new field of research.</p><p>Yet the rapid growth of image synthesis applications makes necessary the manipulation and the exchange of this type of data in a fast and economical manner. In particular, the numerous possibilities given by the World Wide Web in the field of virtual reality could <ref type="bibr">INRIA -2004</ref>, route des Lucioles, B.P. 93 -06902 Sophia Antipolis Cedex -France, FirstName.LastName@sophia.inria.fr be dramatically restricted without a fast access to the data. This implies -especially for remote access through low bandwidth lines -that the geometric data would be efficiently structured.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>Among the works dealing with mesh compression, we focus on the following three articles, according to historical and efficiency criteria.</p><p>Geometric Compression Through Topological Surgery, by Taubin and Rossignac <ref type="bibr" target="#b15">[16]</ref> describes one of the first algorithms that use the transmission order of the mesh vertices to code the topology, and code the vertex positions efficiently by applying prediction schemes. This algorithm -which handles triangle meshes onlydecomposes the mesh in triangle strips, and codes the vertices in their order of appearance in the strips, which amounts to code the connectivity of the triangulation. On the other hand, since this order preserves the geometric neighborhood of the vertices, it allows to linearly predict the position of a vertex from the positions of vertices immediately preceeding in the code. So, instead of coding the absolute coordinates of each vertex, the algorithm uses standard entropy coding methods to send only the error resulting from the predictive technique. Compared to the other methods based on the decomposition of the mesh into triangle strips (in particular, those of Deering <ref type="bibr" target="#b7">[8]</ref> and Chow <ref type="bibr" target="#b5">[6]</ref>), this one seems to give the smallest compression ratios on practical examples <ref type="bibr" target="#b0">1</ref> .</p><p>Triangle Mesh Compression, by Touma and Gotsman <ref type="bibr" target="#b16">[17]</ref> describes another algorithm, whose general principle is quite close. The first difference is the way to traverse the triangulation. The algorithm maintains a list of vertices forming a polygon which contains the coded triangles. This polygon grows by conquering, for each vertex on its boundary, the outside incident triangles. This gives an order over the vertices of the mesh which allows to reconstruct its topology with few additional information. The second difference with the previous algorithm is the method used to predict a vertex position from its predecessors in the code. Besides a linear prediction technique, the algorithm estimates the crease between the current triangles from the previous creases. This yields better compression ratios in practice. Amongst the other works dealing with single resolution compression of triangle meshes, the method of Gumhold and Strasser <ref type="bibr" target="#b8">[9]</ref> stands out as providing fast algorithms intended for real time applications. The compression ratios are close to the results of Touma and Gotsman concerning the connectivity, but the method lacks an efficient scheme for the geometric part.</p><p>Progressive Compression Of Arbitrary Triangular Meshes, by Cohen-Or, Levin and Remez <ref type="bibr" target="#b6">[7]</ref> proposes a method using multiresolution decomposition to achieve progressive compression of the meshes. An initial simplified mesh is refined by insertion of vertices in patches. The position of each new vertex is predicted from the positions of the vertices of the patch where it is inserted, then corrected by additional information. The algorithm uses an efficient scheme of coloring to allow the decoder to recognize the patches. Concerning progressive geometric coding, this algorithm gives the best results published so far, since it yields a code size increase of only 10% compared to the results of Touma and Gotsman. Other progressive methods <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b1">2]</ref> are slightly less efficient.</p><p>These algorithms are designed for triangulated surfaces in the 3-dimensional space. The case of genus greater than 0 is deduced from the null genus case by adding some artificial data. It is also important to note that these algorithms first quantize the vertex coordinates to a number of bits typically lying between 8 and 12.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Overview</head><p>In this article, we tackle the problem of coding geometric structures in a different way. We use the fact that in many cases, the 3D objects are constructed automatically from point samples. Hence the topology of a mesh can often be reconstructed from its vertices. Consequently, our algorithm exploits the transmission order of the vertices to code only their coordinates (description, analysis and features in Sections 2, 3 and 4). Some additional gain can be obtained by using prediction and entropy coding (Section 5). In this form, the algorithm can be applied to any geometric structure as long as a reconstruction algorithm is available for the topology of the original model. However, to handle cases where automatic reconstruction is not suitable, we propose also a progressive topological coder (Section 6). Finally, in order to compare our method to previous works, we present experimental results (Section 7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DESCRIPTION OF THE ALGORITHM</head><p>In order to simplify the description of the algorithm, we start by handling the one-dimensional case. We will see that the generalization to any dimension is straightforward.</p><p>We first describe the coding part of the algorithm. Let S be a set of n points lying on a line segment, between 0 and 2 b (the coordinates of the points are integers coded on b bits). The algorithm begins to code the total number of points on an arbitrary fixed number of bits (32 for example). Then it starts up the main loop which consists in subdividing the current segment in two halves and in coding the number of points contained in one of them (the left halfsegment for example) on an optimal number of bits: if the current segment contains p points, the number of points in the half-segment will be coded on log 2 (p + 1 ) bits. We will see in then add S2 at the end of L The loop stops when there are no more divisible segments in the list, that is to say no segment of length greater than 1. It is to be noted that the only output of the algorithm are the numbers of points lying on the successive segments. The positions of these points are hidden in the order of the output. Indeed, this order contains an implicit binary tree structure.</p><p>The decoding part of the algorithm matches exactly its coding part. A list of segments is maintained, but this time the line segment data structure is composed of: the segment coordinates, the number of points lying on the segment.</p><p>The entire decoding part is detailed below. 9.</p><p>if n1 &gt; 0</p><p>10.</p><p>then S1 left half of S</p><p>11.</p><p>add S1 at the end of L</p><p>12.</p><p>if n2 &gt; 0</p><p>13.</p><formula xml:id="formula_0">then S2 right half of S 14.</formula><p>add S2 at the end of L</p><p>As the algorithm progresses, the data read allow to localize the points with more accuracy. Therefore it is possible to visualize the set of points at intermediate stages of the decoding, by displaying the middle point of each segment Si of the list. Thus the accuracy over the point coordinates is equal to half the length of the corresponding segment.</p><p>To generalize this algorithm to any dimension, let us define a cell as the geometric object containing the points to be coded. In dimensions 1, 2 and 3, the cells are respectively line segments, rectangles, and rectangular parallelepipeds. The only part of the algorithm that differs from a dimension to another is the subdivision of the cell. In dimension d, a cell must be subdivided d times (along each of the d axes). Consequently, an order of subdivision for the cells must be chosen (we will come back to this question in the following) and fixed so that the coder and the decoder can communicate. <ref type="figure">Figure 1</ref> represents a two-dimensional example. The numbers of points transmitted by the coder are written with the corresponding number of bits below, and the numbers of points deduced by subtraction are written in parentheses. <ref type="figure" target="#fig_0">Figure 2</ref> shows the resulting code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THEORETICAL ANALYSIS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Compression Ratio</head><p>To do a theoretical analysis of the algorithm, we will assume that the n points are the vertices of a grid in a d-dimensional hypercube.</p><p>Let 2 b i (for i = 1::d) be the side lengths of the hypercube (the original cell of the algorithm). In the following, Q will denote the number of bits to code the position of a point:</p><formula xml:id="formula_1">Q = P d i=1 bi.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>(2)  Let us calculate the number of bits used to separate the points. With the regularity hypothesis, the dichotomy of a cell containing c points generates two cells containing c=2 points each. Therefore, to separate the n points using this technique, dlog 2 ne subdivisions are necessary. If we decompose the algorithm in phases defined by the size of the cells in the current list, the number of cells doubles and the number of points in each cell is reduced by half from a phase to the next one. Now, the number of bits used for the subdivision of a cell containing c points is equal to log2(c + 1 ) . So finally, the total number of bits used to code the separation of the points is given by: Finally, the calculations of the sums show that the number of bits used at the end of the separation of the points is less than: </p><formula xml:id="formula_2">log 2 (7 + 1) 7 1 (1) 1 (2) 2 (0) log 2 (2+1) log 2 (3+1) log 2 (2+1) 2 (3) 0 (2) log 2 (5 + 1) log 2 (2 + 1) 1 (1) 0 (0) 1 (0) 1 (1) 1 (1) log 2 (1+1) log 2 (1+1) log 2 (1+1) log 2 (2+1) l o g 2 (2+1)</formula><formula xml:id="formula_3">log 2 n;1 X i=0 2 i log 2 n 2 i + 1 = ; log 2 n;1 X i=0 2 i i + log 2 n;1 X i=0 2 i log 2 (n + 2 i ) ;(</formula><formula xml:id="formula_4">N1 =</formula><formula xml:id="formula_5">N2 = n (Q ; log 2 n)</formula><p>Consequently, the total number of bits used by the algorithm to code the point coordinates is:</p><formula xml:id="formula_6">N = N1 + N2 = n (Q ; log 2 n + 2 :402)</formula><p>If we compare N to n Q (the number of bits used to code the points without compression), we notice that the gain is log 2 n ;2:402 per point, and for the set of points, if we neglect the additive constant, it is n log 2 n, which corresponds exactly to the order information over the points (log 2 n bits are necessary to code the index of a point among n). In other words, the algorithm saves the encoding of the order information over the points.</p><p>It is important to observe that this theoretical gain is a lower bound: the regular distribution is the worst-case for the algorithm. In fact, the most non uniform is the distribution, the most efficient is the algorithm. The intuitive idea is that if a cell c is split in two unbalanced parts, then more points share the bit corresponding to c, so the global coding of this bit is cheaper. More formally, let n1 n 2 : : : n 2 j be the numbers of points in the cells after j subdivision phases, then the cost of the next phase is</p><formula xml:id="formula_7">P 2 j i=1 log(ni + 1 ) ,</formula><p>which is maximal when all the ni's are n=2 j , due to the convexity of the log function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Complexity</head><p>The algorithm (compression and decompression) is linear in time and space with respect to Qn. However, the time and space constants of the decompression are significantly smaller than the compression ones. Indeed, during the compression, lists of points are stored and must be traversed for each cell subdivision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FEATURES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Progressivity</head><p>The most interesting feature of the algorithm is the possibility to apply it for progressive coding (and decoding) of the geometric scene. We saw in Section 2 that the only output of the coder were the numbers of points contained in the successive cells, and that the sizes and the positions of those cells were implicitly coded in the order of the output. The choice of this order, i.e. of the way to subdivide the original set of points, can be optimized in order to prioritize the progressive coding of the scene. Since the algorithm organizes the cells in a kd-tree, two traversals are possible. The first one is a depth-first traversal: each point is completely localized before the next one is handled. In the second one (breadth-first traversal), all the cells of a same size are processed, generating twice as small cells which will be processed together at the next stage of the algorithm. Therefore after the decoding of an entire batch of cells, it is possible to construct an intermediate version of the set of points such that the precision is the same over each point. A typical manner to do this is to display the center point of each cell of the current list. Of course, if there is no need for an uniform precision over the points, the scene can be visualized at any time of the decompression, and even in real-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Interactivity</head><p>Thus, for net applications (browsing in particular), it is possible to send successive refined versions of a 3D scene to the final user until he considers that the accuracy is sufficient for his needs. In fact, the method allows to go further in the interactivity with the user. Since the cells are structured in a tree, it is possible, during the decoding, to select one or more subsets of the scene and to refine them and only them. Hence an interactive navigation through a 3D scene, with dilatations and translations, can be optimized from the point of view of the quantity of transmitted information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Lossless Compression</head><p>Contrary to the previous works on the subject, our method does not introduce any loss over the original data. The algorithm handles integer coordinates, but the conversion from float does not need any quantization (for typical VRML objects, 24 to 32 bits are necessary to store the coordinates lossless, to be compared with the 8 to 12 bits quantization of <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b6">7]</ref>). Thus the user can choose to bring the decompression to its end and so obtain the real original object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Dimension</head><p>Another important feature of the algorithm is that it can be applied straightforwardly to data in any dimension. Beyond the threedimensional space, it can be useful for virtual reality data. Indeed, in the widely spread VRML format, extra data is often associated to the vertices, as normal vectors, surfaces, color, radiosity. This data can be handled as additional dimensions and thus compressed exactly like the coordinates. Again, the algorithm performs better with strongly structured data, thus the compression ratio will be smaller when the additional data is correlated to the spatial data (which is the case in usual models).</p><p>Moreover, in high dimensions, the choice of the order of subdivision can have important consequences over the compression ratio. If the priority is to obtain intermediate representations of the scene faithful to the original scene, the ideal order is the one of the breadth-first traversal, which consists in subdividing all the cells of a batch along the first dimension, then subdividing the obtained cells along the second dimension, . . . , until the dimension d, then restarting the same process until the complete localization of the points. But from the point of view of the compression efficiency, the optimal cutting must create empty cells as a priority, and thus, according to the data distribution, it can be more economic to subdivide the cells several times along the same direction. It suffices to add in some header of the compressed data which order of subdivision is best suited to the scene.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ENTROPY CODING AND PREDICTION</head><p>The algorithm we described so far is not a compression method in the classical sense of the information theory. Usually, a compression method gives a manner to extract the canonical information of the data (canonical means here non redundant) and to code it efficiently. Here, what we have done is a reorganization of the data to drop a part of the information which does not interest us (the order over the points). Therefore, it is natural to think that it remains some redundancy in the information part that we kept (the point coordinates).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Arithmetic Coding</head><p>Arithmetic coding is a classical entropy coding method developed in the 1980's <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b17">18]</ref>, that allows to code each symbol s of a sequence on log <ref type="bibr">2 1</ref> P + bits, where P is the estimated probability of s, and a small quantity compared to log 2 1 P . Thus this technique can be quite powerful if coupled to an efficient statistic modeling of the data to be coded.</p><p>The first utility of the arithmetic coding for our method is to code the numbers of points of the cells on an optimal number of bits, even if this number is not an integer. Indeed, we saw in the description of the algorithm that for a cell containing p points, the number of points in the first half-cell generated by the subdivision was coded on log 2 (p+ 1 ) bits. In fact, this is possible thanks to the arithmetic coding principle: without a suitable method, this number would be coded on dlog 2 (p + 1 ) e bits. Hence the gain for each point would be bounded by log 2 n ; 3 instead of log 2 n ; 2:402.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Prediction Methods</head><p>By coding the number of points in the first half-cell generated by the subdivision on log 2 (p+ 1 ) bits (where p is the number of points in the parent cell), we assume that each integer value lying between 0 and p is equiprobable, with the probability 1=(p+ 1 ) . To improve the performances of the algorithm, we can try to estimate more precisely the probability of each of those values. To do so, we study the local densities of points in the neighborhood of the cell being subdivided.</p><p>The prediction technique relies on the assumption that the local densities in the current cell are correlated with the local densities in its neighborhood. Thus the algorithm analyses the context taking into account all the available information at this precise time of the coding or decoding. Let us give an example to explain the general principle of the method. Let us assume that we have to subdivide vertically the central cell of the <ref type="figure" target="#fig_1">Figure 3</ref>. The figure shows the state of the kd-tree of cells at this stage. A very simple manner to determine the most probable repartition of the points in the two half-cells is to calculate the percentage of points in the left neighbor cell with respect to the total number of neighbor points (in the left and right neighbor cells), and then to assume that the half-cells will match this percentage. Here, we count 11 left neighbors over 14 neighbors, which leads to predict 7 points in the left half of the current cell and 2 points in its right half. From that, a basic method consists in estimating the probabilities of the 10 possible values for the left half-cell with a discrete gaussian law centered at 7. Thus In this example, the prediction uses only the first order neighborhood, but the technique can be enlarged to higher orders, by giving more weight to the nearest neighbor cells. In fact, the order of the analysed context can be optimized to achieve a satisfying trade-off between the accuracy of the prediction and the algorithm complexity.</p><p>With our setting of the parameters, this prediction method provides an additional gain of about 5% on average, the best results being reached for 3D models whose local densities are the most various. It is to be noted that the simple list of cells used in Section 2 is no longer sufficient, since the prediction needs a suitable data structure for a quick access to the cell neighborhood.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">TOPOLOGY CODING</head><p>We saw in Section 1.2 that the previous methods of geometric compression needed the topology of the object to perform some prediction on the position of the points and so manage compression of this data. The original point in our method is that we obtain similar results (see Section 7.2) without the support of the topological information. That is why this method is particularly well-suited for models whose topology can be automatically reconstructed. However, for many 3D objects, this automatic reconstruction cannot be done in a lossless way. Moreover, reconstruction algorithms are generally more time-consuming than a single topology decompression, and in some contexts, this overcost can be undesirable (the actual decoding and reconstruction time must be maintained under the transmission time).</p><p>Consequently, we propose an algorithm that progressively codes the topology of a geometric structure. This algorithm relies on the same principle of cells subdivision used by the positions coder, so can be applied to the object simultaneously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Description Of The Algorithm</head><p>Our algorithm codes the minimal connectivity information of the structure in the sense that only the object edges are coded. Consequently, some extra work is necessary to reconstruct the facets of the mesh and the adjacency relations between them when the final application needs these informations. In the following, we will call super-edge an edge between 2 cells. We say that there is a superedge between 2 cells when there is an edge joining a point of one cell to a point of the other. We call neighbors 2 cells joined by a super-edge.</p><p>The algorithm codes these super-edges. Each cell stores a list of its neighbors (at the beginning, the first cell, which is the bounding box of the object, has no neighbor). For each subdivision, we code how the super-edges incident to the original cell are connected to its 2 sub-cells. More precisely, there are 3 possibilities for each super-edge E incident to the original cell C: E is incident to the first sub-cell c0, E is incident to the second sub-cell c1, E is incident to c0 and c1.</p><p>Consequently, for each cell subdivision, each super-edge generates a code on log 2 (3) bits. Besides, one additional bit is necessary to code the possible appearance of a new super-edge between the subcells c0 and c1. Of course, when a cell subdivision generates an empty cell, there is no topological information to be transmitted. The non empty sub-cell inherits all the super-edges of its parent cell.</p><p>Regarding the visualization of intermediate versions of the original model, some post-processing regularization work must be done, since the early stages of the decompression can create edge crossings (see <ref type="figure" target="#fig_2">Figure 4)</ref>. It is only during the final localization, when each cell contains one point, that the topology of the intermediate object has the same properties as the original one. <ref type="figure" target="#fig_2">Figure 4</ref> shows a two-dimensional example (including the original mesh). The code of <ref type="figure" target="#fig_3">Figure 5</ref> corresponds to a clockwise description of the super-edges, starting with the bottom-left cell.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Theoretical Analysis</head><p>The amount of memory used by this method to code the topology of a geometric structure depends on the average degree of a cell. Indeed, the subdivision of a cell having d neighbors costs exactly d log 2 (3) + 1 bits (if it is a "true" subdivision, i.e. if it does not generate an empty cell). Now, it takes exactly n ; 1 "true" subdivisions to separate the n points of an object, i.e. to code its whole topology. Consequently, if the average degree of a cell is d, the progressive coding of the topology takes less than d log 2 (3) + 1 bits per vertex.</p><p>The difficulty is to evaluate this average degree, which must not be confused with the average degree of the original geometric object: it is the average number of neighbors of a cell during the separation phase of the algorithm, therefore, it is slightly greater than the average degree of a vertex. Typically, for a triangular mesh, the average degree of a cell is about 7, which corresponds to a cost of 12 bits per vertex for the topology coding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Future Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Prediction</head><p>As it is, the compression achieved by this topology coding algorithm is far from the results of <ref type="bibr" target="#b16">[17]</ref> or <ref type="bibr" target="#b6">[7]</ref>. However, this method should allow us to handle special connectivity cases, like triangular meshes, in a much more efficient way using prediction and entropy coding. For example, the appearance of a new super-edge between the sub-cells is highly probable and can be coded efficiently using entropy coding. Moreover, the connectivity of a parent cell neighbors to the two sub-cells can often be predicted from various informations like cells positions, sizes, or number of points. This work will be described in a forthcoming paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Automatic Reconstruction</head><p>An example of application where the topology can be reconstructed from the set of points is given by terrain models. In most cases, the connectivity of such models is obtained by computing the Delaunay triangulation of the 2D-projected set of points. In some cases however, slight variations are introduced in the object topology (in order to follow roads or rivers for instance). In such cases, 5 to 10% only of the edges are not Delaunay edges. It suffices to code them, then to compute the constrained Delaunay triangulation to reconstruct the model topology. In 3D, the same technique can be applied to tetrahedral meshes. More generally, the topology coder allows to "help" any reconstruction algorithm by coding a subset of the object edges.</p><p>Kim et al. have developed a compression method for terrain models that uses this idea to code only the non Delaunay edges of the model <ref type="bibr" target="#b9">[10]</ref>. However, if the algorithm reaches very good results regarding the connectivity, it does not compress the geometric information.</p><p>It is worth to be noted that the efficient transmission of 2D Delaunay triangulations is a classical problem in GIS (Geographic Information System). It has been handled by Snoeyink and van Kreveld <ref type="bibr" target="#b12">[13]</ref>, and more recently, by Sohler <ref type="bibr" target="#b13">[14]</ref>. However, in these works, the main purpose is different from ours: the vertex transmission order is used to speed up the triangulation reconstruction (a linear time is obtained instead of O(n log n)). In addition, some compression is achieved by coding the vertex coordinates in a differential way, using variable length codes, but the gain remains relatively small compared to the one generated by pure compression methods. <ref type="figure" target="#fig_4">Figure 6</ref> gives results of our method applied to some terrain models. The first two lines come from a GIS database covering the region of Vancouver, whereas the third one corresponds to a simple terrain model composed of 14641 vertices with 12=12=10 bits coordinates.  The last two columns allow to compare the theoretical minimal gain obtained in Section 3.1 to the actual gain achieved by the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTAL RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Terrain Models</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This example allows to visualize the progression of the decoding on</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Standard 3D Objects</head><p>We present in <ref type="figure">Figure 7</ref> some results of the method described in this paper compared to those of Taubin and Rossignac <ref type="bibr" target="#b15">[16]</ref> and Touma and Gotsman <ref type="bibr" target="#b16">[17]</ref>. We saw in Section 1.2 that these two methods coded the connectivity and the coordinates of the mesh vertices. However, the figures that appear here concern only the coding of the coordinates, so are comparable to the results of our algorithm. The columns 3 and 4 have been extracted from the article of Touma and Gotsman, and we have applied our method to the same geometric models to obtain the column 5. It is to be noted that the coordinates of these 3D models have been prior quantized on 8 bits to follow exactly the same process as in the first two cited articles. The differences of efficiency come from the structure of the models: "eight" and "shape" have a very regular structure which suits the predictive method of Touma and Gotsman. On the contrary, "dumptruck" and "engine" are more complex models containing variations of local density more suitable for our algorithm. Regarding the method of Cohen-Or et al. <ref type="bibr" target="#b6">[7]</ref>, we do not have results for the same models, but the authors report an average code size increase of about 10% compared to the results of Touma and Gotsman.</p><p>In <ref type="figure" target="#fig_0">Figure 12</ref>, we show what can be obtained by automatic reconstruction <ref type="bibr" target="#b3">[4]</ref> from the set of points, without any connectivity information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have presented a new method of geometric compression whose originality is to perform coordinates compression without the support of the connectivity information. Besides reaching slightly better ratios than the current available algorithms, this technique allows lossless coding and interactive decoding. Moreover, the algorithm is valid for any dimension, and simple to implement. This method is particularly well-suited to any geometric structure whose topology is reconstructible from its vertices, which is the case of terrain models. However, the progressive topology coding feature permits to handle any geometric structure (not only triangular meshes).</p><p>Concerning the special case of triangular meshes, a future publication will show how prediction and entropy coding can lead to competitive compression ratios for the connectivity.</p><p>On the other hand, future works will consider the use of some 3D surface reconstruction methods <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b3">4]</ref>, which give a necessary and sufficient condition over the object sample to guarantee a valid reconstruction. Thus, by possibly adding a small number of points (or edges, using the topology coder) to the original set, it will be possible to reconstruct the object topology.</p><p>Another important perspective is to improve the predictive scheme, whose current results are not completely satisfying. It could be achieved by a more precise analysis of the point distribution in the neighborhood of the current cell, and by applying optimization methods for the parameters setting.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>The output code of the two-dimensional example Let us split up the algorithm in two successive phases: separation of the points: the cells are recursively subdivided until each cell of the list contains exactly 1 point, final localization: each cell (containing only one point) is subdivided until it reaches the unit size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Neighborhood of a two-dimensional cell the actual value of the left half-cell (6 points) will have a strong estimated probability, and so will be coded on a small number of bits.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Coding the topology on a two-dimensional example left both yes left both both right right</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>The output code of the two-dimensional example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>compression results on terrain models 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :Figure 9 :Figure 10 :Figure 11 :</head><label>891011</label><figDesc>precision = 5 bits, comp. ratio = 3% precision = 6 bits, comp. ratio = 8% precision = 7 bits, comp. ratio = 16% precision = 12 bits (lossless), c. r. = 54%(a) Original topology (b) Reconstructed topology</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 12 :</head><label>12</label><figDesc>Beethoven (geometry cost: 9:6 bpv)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Once a cell contains only one point, it must be subdivided until the point is completely localized. Since log 2 n subdivisions have been performed during the separation phase, it remains to subdivide each cell Q ; log 2 n times. During this phase, a subdivision costs 1 bit (the point belongs either to the first half-cell or to the second one). Thus the number of bits used to code the final localization of the points is:</figDesc><table><row><cell>2 :402 n</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">In this article, we will measure the efficiency of the compression with the ratio compressed datasize original data size (multiplied by 100 to obtain a percentage).</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">The first column gives the number of vertices of the model. The next columns give the size of the data in bytes, and the corresponding number of bits per vertex (bpv).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Surface reconstruction by Voronoi filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nina</forename><surname>Amenta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marshall</forename><surname>Bern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SoCG &apos;98 Proc</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="39" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Progressive compression and transmission of arbitrary triangular meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chandrajit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guozhong</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zhuang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99 Proc</title>
		<imprint>
			<date type="published" when="1999-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Sampling and reconstructing manifolds using alpha-shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fausto</forename><surname>Bernardini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandrajit</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Canad. Conf. Comput. Geom</title>
		<meeting>9th Canad. Conf. Comput. Geom</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="193" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Smooth shape reconstruction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Daniel</forename><surname>Boissonnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fréderic</forename><surname>Cazals</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SoCG &apos;00 Proc</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">3-dimensional reconstruction of complex shapes based on the Delaunay triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Daniel</forename><surname>Boissonnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Geiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Biomedical Image Processing and Biomedical Visualization</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="volume">1905</biblScope>
			<biblScope unit="page" from="964" to="975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Optimized geometry compression for real time rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><forename type="middle">M</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97 Proc</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="347" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Progressive compression of arbitrary triangular meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Offir</forename><surname>Remez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99 Proc</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="67" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Geometry compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;95 Proc</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Real time compression of triangle mesh connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;98 Proc</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An improved tin compression using delaunay triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang-Soo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dong-Gyu</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jung</forename><surname>Ho Youl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hwan-Gue</forename><surname>Cho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific Graphics &apos;99 Proc</title>
		<imprint>
			<date type="published" when="1999-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Compressed progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarek</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="79" to="93" />
			<date type="published" when="2000-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Arithmetic coding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rissanen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Langdon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Develop</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="162" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Linear time reconstruction of delaunay triangulations with applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jack</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Van Kreveld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Algorithms Proc</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast reconstruction of delaunay triangulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Sohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Canad. Conf. Comput. Geometry Proc</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Progressive forest split compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">André</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francis</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;98 Proc</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Geometric compression through topological surgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jack</forename><surname>Rossignak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Triangle mesh compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Costa</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface &apos;98 Proc</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Arithmetic coding for data compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">H</forename><surname>Witten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Neal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">G</forename><surname>Cleary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="520" to="540" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
