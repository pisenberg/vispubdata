<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Visibility Determination Algorithm for Interactive Virtual Endoscopy</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rami</forename><surname>Hietala</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarkko</forename><surname>Oikarinen</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Diagnostic Radiology</orgName>
								<orgName type="institution">Oulu University Hospital</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Diagnostic Radiology and Department of Electrical Engineering</orgName>
								<orgName type="institution">University of Oulu</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Visibility Determination Algorithm for Interactive Virtual Endoscopy</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Visible line/surface algorithms; I.3.8 [Computer Graphics]: Applications Volume Visualization</term>
					<term>Template</term>
					<term>Visibility</term>
					<term>Isosurface Extraction</term>
					<term>Surface Rendering -plane (at depth</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present a new visibility determination algorithm for interactive virtual endoscopy. The algorithm uses a modified version of template-based ray casting to extract a view dependent set of potentially visible voxels from volume data. The voxels are triangulated by Marching Cubes and the triangles are rendered onto the display by a graphics accelerator. Early ray termination and space leaping are used to accelerate the ray casting step and a quadtree subdivision algorithm is used to reduce the number of cast rays. Compared to other recently proposed rendering algorithms for virtual endoscopy, our rendering algorithm does not require a long preprocessing step or a high-end graphics workstation, but achieves interactive frame rates on a standard PC equipped with a low-cost graphics accelerator.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Optical endoscopy is a medical procedure that is used to examine hollow organs or cavities within a human body. The operation may be rather painful, because the endoscope is inserted into the patient through natural holes or small incisions. Virtual endoscopy is an alternative technique, in which optical endoscopy is simulated by using three dimensional perspective volume visualization and interactive volume navigation.</p><p>Two approaches to perspective volume visualization are surface rendering and direct volume rendering. Surface rendering algorithms are, generally, much faster than the algorithms based on direct volume rendering, but the image quality is typically lower due to improper visualization of partially translucent objects. Interactive virtual edoscopy systems most often use surface rendering to achieve interactivity. ¢ worm@ee.oulu.fi £ jto@iki.fi Marching Cubes <ref type="bibr" target="#b6">[7]</ref> is the best known algorithm for extracting surfaces from the volume data. The problem of Marching Cubes is, however, that the number of extracted polygons may be millions and can easily overwhelm even the fastest graphics accelerators. Rendering times can be reduced by rendering only the polygons that are visible from a given view point, but only if the visible polygons can be found efficiently.</p><p>The determination of a potentially visible set (PVS) of cells <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16]</ref> is an object-order visibility determination method. It is based on subdividing the volume into a set of cells, each consisting of a group of polygons (or any other drawing primitives). The visibility of each cell is determined and if a cell is not visible, none of the polygons belonging to the cell is visible either. Generally, only a fraction of all polygons within the data set are visible per view and therefore by calculating the PVS the number of polygons fed to the graphics pipeline can be substantially reduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Direct volume rendering has recently been used for perspective volume visualization in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b16">17]</ref>. Most of the proposed methods are, however, too slow or require a multiprocessor computer for interactive volume navigation. Interactive virtual edoscopy systems <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref> are usually based on surface rendering, because the standard graphics hardware can be used to accelerate rendering of polygons.</p><p>The main difference between the systems based on surface rendering is in the visibility method. PVS has been considered as a suitable visibility determination method for virtual angioscopy <ref type="bibr" target="#b0">[1]</ref> and for virtual colonoscopy <ref type="bibr" target="#b4">[5]</ref>, due to the twisted nature of the structures (blood vessels, the colon) that are visualized. Typically, only a fraction of cells are visible to the viewer anywhere within the colon or blood vessel and the rest are outside the view frustum or occluded by some other cell.</p><p>Bartz et al. used a PVS together with hardware assisted occlusion culling and octree volume decomposition in <ref type="bibr" target="#b0">[1]</ref>. The group was able to achieve a total visibility culling rate of 90.6% and a frame rate of 15.7Hz on a HP B180/fx4 graphics workstation. Hong et al. used PVS together with portals and an aggregate cull rectangle in <ref type="bibr" target="#b4">[5]</ref> and a total visibility culling rate with their algorithm was between 89.1% and 95.8%. The frame rates achieved with the second algorithm were between 14.8Hz and 22.7Hz (depending on the data set) on a SGI R10000 processor with an InfiniteReality graphics system.</p><p>The disadvantages in the methods presented above are the long preprocessing step and relatively high hardware requirements. The method in <ref type="bibr" target="#b0">[1]</ref> requires the user to set virtual clips in order to reduce the visual complexity of the surface model and in <ref type="bibr" target="#b4">[5]</ref> the preprocessing took a few hours on a SGI workstation. Our goal was to develop an algorithm that would not need a long preprocessing step or an expensive hardware, but would run on a standard PC with a low-cost graphics accelerator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE ALGORITHM</head><p>The new rendering algorithm described in this work consists of three phases: sparse ray casting, perspective template grid construction and quadtree grid subdivision. Sparse ray casting, described in Section 3.1, is used to find surface voxels from the volume data and to determine the coarse visibility of those voxels. Our ray casting method only casts a fraction of all rays that are cast by the traditional ray casting methods. The purpose is not to determine pixel values by casting rays through the pixels, but to process the view dependent set of potentially visible voxels of the volume, as illustrated in <ref type="figure" target="#fig_0">Fig. 1</ref>. The surface voxels are triangulated by the software and triangles are rendered onto the display by a hardware graphics accelerator (with a z-buffer). Triangle configuration indices (0-255) used by Marching Cubes are calculated and stored into the preprocessed volume. The indices help us to detect solid intersections (see Section 3.1), but they are also used to improve the performance of the triangulation operations. Gradient vectors precalculated at the sixneighborhood of a volume sample are used in order to speed up the triangle shading operations.</p><p>We use early ray termination -modified for our purposes -in order to reduce the amount of voxels that are accessed during sparse ray casting. We also use the Proximity Clouds method <ref type="bibr" target="#b2">[3]</ref> with the City-Block metric to reduce the ray traversal time. The distance to the nearest non-empty voxel is stored into each empty voxel of the preprocessed volume. The stored values are used during ray casting to leap over the empty space as fast as possible.</p><p>Perspective template grid construction, discussed in Section 3.2, determines how the individual ray-templates, that are used by sparse ray casting, are constructed. We use a modified version of the template-based ray traversal algorithm <ref type="bibr" target="#b14">[15]</ref> to accelerate the ray casting step. Another reason for the use of templates is that the sample points on the volume slices are organized so that the rows and columns are axis aligned with the voxel scanlines -a property of the template-based methods that is essential for our visibility method.</p><p>In perspective projection rays diverge and one might think that the templates should be calculated for all rays that are cast. However, by separating the ¤ -and ¥ -components of the templates we can reduce the number of the templates. A single ray that is used by the sparse ray casting algorithm is composed of one ¤ -template and one ¥ -template. Quadtree grid subdivision, described in Section 3.3, is used to determine the (nearly) minimal density of rays that have to be cast. The ray spacing is calculated so that all potentially visible surface voxels inside the volume are visited. The subdivision begins with a large cell that contains all rays of the template grid. The first ray of the cell is cast and its depth of termination determines whether the cell has to be subdivided into four child cells or not. The child cells are processed like the parent cell and subdivided if necessary. The result of our subdivision scheme is that a lot of rays are cast into the areas where the surface voxels are far away and only a few rays are cast into the areas where the surface voxels are very close to the viewer.</p><p>In order to clarify the description of our algorithm we have defined the most common terms used in the next sections as follows: ¦ a volume sample is a value that is proportional to the strength of x-ray radiation absorption (CT) or proton density (MR) inside the volume. Values are defined on discrete locations at the nodes of the volume grid. Volume sample is said to be inside (or outside) an object if its value is above <ref type="bibr">(</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sparse Ray Casting</head><p>The sparse ray casting part of our algorithm is used to find a view dependent set of potentially visible surface voxels from the volume data. After the voxels are found they are triangulated using a fast implementation of the original Marching Cubes algorithm <ref type="bibr" target="#b6">[7]</ref> and the resulting triangles are rendered onto the display. The process is illustrated in <ref type="figure" target="#fig_2">Fig. 2</ref>. Z-buffer is used to determine the visibility of the triangles on the image plane, because ray casting methods do not process the voxels in depth-order.  Rays are not cast through the image pixels like in traditional ray casting. Instead, the ray spacing at the back clipping plane is the same as the voxel width, as illustrated in <ref type="figure" target="#fig_3">Fig. 3</ref>. This ensures that all potentially visible voxels within the view frustum are pierced by at least one ray. Generally, the volume slice resolution is much lower than the display resolution (at least with high resolution displays) and therefore we call our method sparse ray casting.</p><p>Template-based ray casting methods assume that the principal ray axis is perpendicular to the base plane of the template <ref type="bibr" target="#b14">[15]</ref>. In this work the principal ray axis is called § Connectivity. <ref type="figure" target="#fig_4">Fig. 4</ref> illustrates how the rays are voxelized and how the sample points along a ray are determined. <ref type="figure" target="#fig_4">Fig. 4</ref> (left) shows the basic principle of ray casting that uses 6-connected (4connected in 2D) voxelized rays. Voxels along rays A and F are shaded to show the amount of accessed voxels with 6-connected ray traversal. 6-connected rays have a containment property, which means that none of the voxels pierced by a continuous ray are missed by the respective 6-connected voxelized line <ref type="bibr" target="#b3">[4]</ref>.  shows how the rays are sampled by our 26connected (8-connected in 2D) ray traversal algorithm. The algorithm stores information of steps along a 26-connected voxelized ray into a ray-template. The steps along the ray are dependent on the sample points so that the voxel pierced by the ray just before a sample point is the voxel that is accessed by the 26-connected ray.</p><p>It has been shown that 6-connected rays can have up to two times more voxels than 26-connected rays <ref type="bibr" target="#b3">[4]</ref>. Therefore, 26connected rays are much faster to traverse than 6-connected rays. 26-connected rays do not have the containment property and they can miss some non-empty voxels along their way. It does not matter, however, if 26-connected rays are used only to leap over the empty space, as presented in <ref type="bibr" target="#b3">[4]</ref>.</p><p>Although our rendering algorithm requires that all potentially visible surface voxels along a ray are accessed, it is still possible to utilize fast 26-connected rays. Our ray casting method is based on the observation that when a ray is cast between two 6-connected rays, it can be 26-connected without reducing the number of voxels that are accessed by the three rays. Some of the non-empty voxels along the middle ray may be missed, but it does not matter because it is guaranteed that the missed cells are accessed by one of the neighboring 6-connected rays. In fact, there can be any number of 26-connected rays between two 6-connected rays as long as the ray spacing stays below the cell width. <ref type="figure" target="#fig_6">Fig. 5</ref> illustrates the use of 26-connected rays in practice. Rays A and F are 6-connected, but rays B-E use 26-connected ray traversal. The only rays that have to be 6-connected are rays A and F, because they enclose the view frustum and have to be 6-connected in order to access all voxels also at the borders of the view frustum. The figure also shows one drawback of our algorithm: some of the cells are accessed several times. Ray splitting <ref type="bibr" target="#b8">[9]</ref> could be used to reduce the amount of multiple voxel accesses, but our visibility method does not allow this. The method we use relies on quadtree grid subdivision, which reduces the amount of cast rays. Early Ray Termination. Early ray termination can also be used with sparse ray casting, although the ray termination conditions are slightly different than in the traditional ray casting methods. Our early ray termination method is illustrated in <ref type="figure" target="#fig_7">Fig. 6</ref> (right). As can be seen, every 26-connected ray is between two 6-connected rays. This was the initial requirement for the use 26-connected rays, as mentioned above. However, now the rays have been terminated before they hit the back clipping plane.</p><p>If the first and the last ray (always 6-connected) are not considered, the connectivity requirements and the ray termination criteria for ray © ( is the ray number) can be fulfilled by following the four basic rules: can be traversed using 26connected ray traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The portion of ray</head><formula xml:id="formula_0">© c that is between § C E DF G ! G H E P Q ' d § A $ C E D! $ V U ' ) 2 X e 3 4 5 &amp; 7 8 9 and § C E D! $ B U ' f ) 2 1 ¤ 3 4 5 6 g 7 h 9</formula><p>must be traversed using 6-connected ray traversal.</p><p>By the imaginary sample points we mean the sample points that are on the same</p><formula xml:id="formula_1">¤ i ¥ © r E and © u 6</formula><p>hit the solid intersections of voxels B, C and D, respectively. Voxels B-D in <ref type="figure">Fig. 8</ref>   <ref type="figure">Figure 8</ref>: Checking the solid intersections.</p><p>This way the ray termination conditions will be more strict, but the implementation of the algorithm is simpler because the subsequent rays do not affect the termination of the current ray anymore.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Perspective Template Grid Construction</head><p>Template-based ray traversal algorithms have mostly been used with parallel projection, because the same ray-template can be used for all rays <ref type="bibr" target="#b14">[15]</ref>. Perspective projection introduces a problem of diverging rays, which requires us to separate the ¤ -and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¥</head><p>-components of the ray-templates if we want to avoid calculating a separate template for each ray. We call the separated components ¤ -and ¥ templates in this work.</p><p>The construction of a ray-template begins by determining a base plane for a ray. A base plane is the plane that is perpendicular to the principal axis of the ray. We have to determine a base plane for each ray, since the rays within the boundaries of the view frustum can have a different base plane (due to perspective projection). The ¤ and ¥ -templates that share the same base plane form a grid that we call a template grid in this paper. Each template grid is processed separately by our quadtree grid subdivision algorithm.</p><p>The base planes can be determined by placing the center of the projection into the center of a voxel and calculating the intersection of the view frustum and the voxel as illustrated in <ref type="figure" target="#fig_9">Fig. 9</ref>. Voxel dimensions are</p><formula xml:id="formula_2">v = (v x w y 5 &amp; v g 5 &amp; v</formula><p>). The faces of the voxel intersected by the view frustum are parallel to the base planes that are used when the template grids (¤ -and ¥ -templates) are constructed. Intersection polygons determine the boundaries, i.e. the first and last ray-templates, of every template grid.  . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¥</head><p>-template. The relevant information about the voxels along the ray is stored into the templates. Our algorithm stores the information needed by sparse ray casting: the memory offsets and the ¤ -and ¥ -offsets relative to the center of the projection. This information is used by sparse ray casting for accessing the voxel data and for transforming the coordinates of the voxels from object space coordinates to image space coordinates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Adaptive Quadtree Grid Subdivision</head><p>We use an adaptive quadtree grid subdivision method to process the template grids and to determine the rays that should be cast. The ray spacing is selected so that each potentially visible surface voxel is hit by at least one ray. Our method is based loosely on the Warnock's area subdivision and visibility algorithm <ref type="bibr" target="#b13">[14]</ref>.</p><p>Each template grid consists of rays that share the same base plane, as mentioned in Section 3. The subdivision begins by processing the root node. The first ray within the root cell is cast and the depth of the first group of four solid intersections along the ray determines whether the cell has to be subdivided or not. If the cell has to be subdivided, the cell is split into four child cells called quadrants. The quadrants represent the child nodes of the root. After the subdivision the four quadrants are processed just like the root cell. The first rays within the child cells are cast and the cells are split again, if necessary. By adaptive subdivision we can avoid processing a large amount of the leaf nodes (rays) in the quadtree assuming that all quadtree cells are not subdivided.</p><p>The principle of adaptive subdivision is illustrated in <ref type="figure" target="#fig_0">Fig. 11</ref>   , if necessary. We can easily calculate whether the projection of faces A-D covers all the necessary rays on the template grid by knowing the depth of termination of a ray. The cell size, i.e. the number of rays within the quadtree cell, is dependent on the level of the cell at the quadtree hierarchy (always a power of four). If a ray hits a structure of four solid intersections A-D at depth and the back clipping plane is at depth § % x w t w</p><p>, the number of subsequent rays (in direction of the positive ¤ -and ¥ -axes) that also hit the same structure can be calculated as follows:  ). By knowing the value of y and the number of rays within the quadtree cell we can easily detect the cases when the cell has to be split.</p><formula xml:id="formula_3">y z ' { § % x w t w } |<label>(4)</label></formula><p>The value of plays an important role in our algorithm. It is used to decide whether the quadtree cells should be subdivided or not, but it is also used to decide when a ray can be terminated and which portions of the ray should be traversed using 6-connected ray traversal (see rules 1-4 in Section 3.1). We use a min-max data structure associated with the leaf nodes of the quadtree, i.e. the rays of the template grid, to store the values. Whenever a ray is processed, the value of the current ray is stored into the min-max data structures of the upcoming rays. When we update the data structure associated with a ray, we call the ray marked. All marked rays should be cast in order to avoid missing the potentially visible cells along the marked rays. . We also have to check the rays on the borders of the current cell for marked rays, if the previous cell at the quadtree hierarchy is split into smaller subregions than the current cell. For example, in <ref type="figure" target="#fig_0">Fig. 12</ref>   <ref type="figure" target="#fig_0">(Fig. 13</ref>) that shows the pixels pierced by the rays (white dots) and the boundaries of the view frustum (white rectangle). The image shows clearly how the density of rays is bigger on areas where the surfaces are far away and smaller on areas where the surfaces are close to the viewer. The image also shows one drawback of our algorithm. Because the enclosing rectangle on a base plane (see Section 3.2) is generally larger than the intersection polygon, rays are also cast through areas that are not within the view frustum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTS</head><p>We tested our algorithm with two data sets, consisting of 256 256 200 and 256 256 100 voxels. The first data set, CT images from a human aorta, was used to demonstrate the capability of the visualization algorithm in virtual angioscopy. Voxel dimensions in the first data set were 0.684 mm 0.684 mm 1.700 mm and the total number of triangles extracted from the data set was 1,156,883, when Marching Cubes was applied to all voxels within the data set. A fly-through animation consisting of 320 frames was generated for measurements. The field of view angle in the first animation was s p S p and the front and back clipping planes were at 2 mm and 100 mm distances, respectively -the clipping planes were selected so that almost nothing was actually clipped. A few snapshots (every 40th frame) from the first animation are presented in <ref type="figure" target="#fig_0">Fig. 14.</ref> The second data set, CT images from a human colon, was used to demonstrate our algorithm in virtual colonoscopy. Voxel dimensions in the second data set were 0.629 mm 0.629 mm 2.000 mm and the total number of triangles generated by Marching Cubes was 633,578, when all voxels were triangulated. A fly-through animation consisting of 400 frames was generated for measurements. The field of view angle in the second animation was B S and the front and back clipping planes were the same as in the first animation. Some snapshots from the animation are shown in <ref type="figure" target="#fig_0">Fig. 15</ref>.</p><p>The hardware configuration for our experiments was a 450 MHz Pentium II Xeon with two processors (only one was utilized by our algorithm) and 512 MB of physical memory. The graphics accelerator was a 3dfx Voodoo 3000 AGP with 16 MB of memory. The software platform was Slackware Linux with kernel version 2.2.13. The interface to the graphics accelerator was Glide version 3.10.00.0435. The display size that we used in both animations was 1600 1200 pixels. We used the system clock of our computer for the measurements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>We evaluated our algorithm by measuring the average times spent in different parts of the algorithm. The results are in <ref type="table" target="#tab_1">Table 1</ref>. Tmpl is the time spent in constructing the template grid and calculating the templates. Ray is the time used by the ray casting algorithm and MC is the time spent in triangulating the voxels and projecting the triangles onto the image plane. Render is the time that it took to render the triangles by the graphics accelerator and Total is the total rendering time seen by the user. Timings of the animations are shown in <ref type="figure" target="#fig_0">Figs. 16 and 17</ref>. An average frame rate in the first animation was 26Hz and in the second animation 5.4Hz, although the values vary quite a lot during the animations. The peak performance values for the animations were 34Hz and 11Hz and the worst case values 20Hz and 3.0Hz.</p><p>We also measured the visual complexity during the animations. The results are presented in <ref type="table" target="#tab_8">Table 2</ref>. Voxels-column shows the average number of voxels accessed by the sparse ray casting algorithm.  MC is the number of voxels forwarded to Marching Cubes and Tris is the number of triangles drawn onto the display. Rays is the average number of cast rays and the percentage value is the amount rays that were skipped by the quadtree grid subdivision algorithm (the efficiency of quadtree subdivision). We also compared our visibility method to view frustum culling. Results are shown in <ref type="table" target="#tab_9">Table 3</ref>. VFC is the average number of triangles with view frustum culling only and Our-column represents the number of rendered triangles when our visibility method was used. The last column shows how much our visibility method reduced the amount of rendered triangles compared to the VFC.  trates how the numbers varied during the first animation. We used thresholding with connectivity to segment the objects before we measured the rates of view frustum culling, because pure thresholding produced a lot of triangles that did not belong to the cavity that we were exploring. Thresholding with connectivity reduced the number of triangles in the data sets from 1,156,883 to 194,950 (aorta) and from 633,578 to 498,683 (colon). Our visibility method is not so sensitive to the number of those extra triangles, because we use early ray termination to determine the visibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DISCUSSION</head><p>The numbers presented in the previous section prove that our algorithm can achieve interactive frame rates in the applications such as virtual angioscopy and virtual colonoscopy. Our algorithm does not suffer from a long preprocessing step such as the ones presented  in <ref type="bibr" target="#b0">[1]</ref> (center-line extraction and cell decomposition) and <ref type="bibr" target="#b4">[5]</ref> (userdefined virtual clips). We calculate only the Marching Cubes indices and Proximity Clouds during preprocessing. This process, performed every time the user changes the threshold, took less than 10 seconds with both data sets that we used in the experiments. A long preprocessing step is a burden of many virtual endoscopy systems in case the user wants to change the threshold value. The visibility culling rates of our algorithm were also comparable to the results presented in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b4">[5]</ref>. Bartz et al. were able to improve the rate of view frustum culling by 80.4%; the respective values in our case were 87.9% (aorta) and 69.1% (colon). Bartz et al. increased the average culling rate by a factor of four by using hardware assisted occlusion culling, but they improved the overall rendering performance only by a factor of two (from 7.5Hz to 15.7Hz). This indicates that half of the rendering time is spent in determining the PVS. The results are similar to those achieved by our visibility algorithm, as can be seen from <ref type="table" target="#tab_1">Table 1</ref>. Columns Ray and Templ show the time that was spent in determining the PVS, which is close to half of the total rendering time.</p><p>The visibility determination algorithm presented in this work does not require expensive graphics workstations (used in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b4">[5]</ref>), but runs on a standard PC with a low-cost graphics accelerator. Generally, low-cost accelerators do not support hardware assisted occlusion culling that was used in <ref type="bibr" target="#b0">[1]</ref>. Good visibility culling rates and low hardware requirements make this algorithm an attractive visualization method for interactive virtual endoscopy. Because the algorithm does not need a high-end graphics workstation, the developed visualization system is available to a large medical and scientific community.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>The purpose is to process only the view dependent set of potentially visible voxels in the shaded area.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>In sparse ray casting surface voxels along a ray are triangulated and the triangles are rendered onto the display.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>-Figure 3 :</head><label>3</label><figDesc>axis. Sample points along a ray are located on the ¤ ¥ -planes between § -adjacent voxels so that each volume slice that is parallel to the base plane is sampled uniformly. Sample points on a single ¤ ¥ -plane form rows and columns that are aligned with the ¤ Ray spacing at the back clipping plane is the same as the cell width.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Cells accessed by 4-connected rays (left) and 8-connected rays (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 (</head><label>4</label><figDesc>right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Cells accessed by sparse ray casting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Fig. 6(left) is the basic situation presented in Figs. 4 and 5, but now with an isosurface (isocontour in 2D) representing the boundary of an object. Early ray termination is not used and the rays are not terminated until they hit the back clipping plane. The triangulated cells represent the surface voxels that are forwarded to Marching Cubes and triangulated. Early ray termination with sparse ray casting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>The view frustum is clipped against a voxel.Sparse ray casting requires that the principal ray axis is the § constructed. After the base plane is perpendicular to the § -axis, the ¤ -and ¥ -templates within the same template grid can be calculated. The boundaries of the template grid are extracted from the rectangle that encloses the intersection polygon on the voxel face as shown inFig. 10. If the number of ¤</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>2 .</head><label>2</label><figDesc>The rays are the leaf nodes at the lowest level of our quadtree hierarchy. Upper levels merge four child nodes into a single parent node. At the topmost level a single root node represents all rays of the grid. A node can also be thought of as a cell that covers m p n rays on the template grid (o is the node's level at the quadtree hierarchy). Each node is assigned the information of the first ray inside the cell. The first ray within a cell is the ray that has the smallest and h values (see Equation 3 in Section 3.2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 : 6 r 6 r</head><label>1166</label><figDesc>Cells of the quadtree hierarchy. The subdivision algorithm traverses ray © r until it finds the depth at which all of faces A-D are solid intersections. This depth is the same as depth in rule 1 of the early ray termination algorithm presented in Section 3.1. The size of the projection of faces A-D on the template grid determines whether we have to subdivide cell and the ray spacing between these rays is less than the voxel width (or height), then cell p r does not have to be split and we can start processing the subsequent cells at the same level of the quadtree hierarchy. Fig. 11 presents a case, in which the projection of faces A-D does not cover all the necessary rays and cell p q r 6 rhas to be split. The result after subdivision is shown inFig. 12. The child cells are named that the ray spacing between the rays at the depth of termination is less than the voxel width), the cell p v r 6 r does not have to be subdivided anymore, but we can proceed to the other child cells. The first rays within the child cells are traversed like ray of four solid intersections, after which the child cells are subdivided like</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>The result after subdivision of cell</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>The min-max values associated with ray © are the smallest and largest values of the previous rays. The coordinates of the upcoming rays depend on the level of the current cell at the quadtree hierarchy. If coordinates of the first ray in the current cell are</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 13 :</head><label>13</label><figDesc>Quadtree subdivision in practice.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 14 :Figure 15 :</head><label>1415</label><figDesc>Snapshots from the animation through aorta. Snapshots from the animation through colon.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 16 :Figure 17 :</head><label>1617</label><figDesc>Fig. 18illus-Timings of the first animation (aorta). Timings of the second animation (colon).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 18 :</head><label>18</label><figDesc>Number of rendered triangles with view frustum culling and with our visibility method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>1 .</head><label>1</label><figDesc>The first depth at which sample points on rays</figDesc><table><row><cell cols="2">2. Ray depth ©  § cannot be terminated before it is traversed to the " ! $ # &amp; % ( ' 0 ) 2 1 ¤ 3 4 5 6 7 8 @ 9 .</cell></row><row><cell>3. The portion of ray and  § A $ C E D! $ V U ' W ) Y X a 3 © 4 b 5 that is between 6 7 8 @ 9</cell><cell>§ B A $ C E DF G ! I H @ P Q R ' T S</cell></row><row><cell></cell><cell cols="2">© and and all imaginary sample points between them are inside the ©</cell></row><row><cell></cell><cell>same object is</cell><cell>.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>are the three neighboring voxels of voxel A in direction of the positive ¤</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Voxel A</cell><cell>Voxel B</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>z</cell><cell>x</cell><cell>Volume sample inside</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>y</cell><cell>R 00</cell><cell>R 10</cell><cell>Volume sample outside Solid intersection</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Sample point</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>R 01</cell><cell>R 11</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Voxel C</cell><cell>Voxel D</cell></row><row><cell cols="9">-and tersection of voxel A, but we do not know which solid intersections ¥ -axis. Ray © c r hit the solid in-6 r</cell></row><row><cell>are hit by ray</cell><cell>© u t r</cell><cell>,</cell><cell>© c r E</cell><cell>or</cell><cell cols="2">© s 6</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>© u t r ,</cell><cell>©</cell><cell>r E</cell><cell>or</cell><cell>© s 6</cell><cell>in order to terminate ray</cell><cell>© c r 6 r</cell><cell>.</cell></row></table><note>before we check the positions of the sample points on these rays. If each of the voxels A-D contains a solid intersection we do not have to know the locations of the sam- ple points on rays</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>is the center of the projection and is the index of the sample point. Sample points along a ray are calculated step-by-step by incrementing by a factor of 1 after each step (the first -value is defined so that the sample points are on the</figDesc><table><row><cell>the</cell><cell>X t h</cell><cell>¤</cell><cell cols="4">-template can be calculated as follows:</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">P 3 " 6 9 e '</cell><cell>3 t</cell><cell>b P 6 5 &amp; S</cell><cell>5</cell><cell>9</cell><cell>(1)</cell></row><row><cell cols="2">where</cell><cell></cell><cell>'</cell><cell>3 4 p w y 5 $ p</cell><cell cols="2">5 6 p V 9</cell></row><row><cell cols="7">¤ -planes ¥ t h template in X or is the slope of the b P is the slope in -adjacent voxels).  § -direction and between ¤  § -direction ( d ).</cell></row><row><cell></cell><cell></cell><cell></cell><cell>z</cell><cell>x</cell><cell></cell><cell>y 0</cell><cell>x 0</cell><cell>x n-1</cell><cell>y 0</cell></row><row><cell></cell><cell></cell><cell></cell><cell>y</cell><cell></cell><cell>x 0</cell><cell>x n-1 y m-1</cell><cell>y m-1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>x-templates</cell><cell>+</cell><cell>y-templates</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>= template grid</cell></row><row><cell cols="7">Figure 10: Boundaries of the template grid are extracted from the</cell></row><row><cell cols="7">rectangle that encloses the intersection polygon.</cell></row><row><cell cols="7">If we have coordinates of the enclosing rectangle are ) e ¥ -templates, the minimum and maximum ¥ r and ¥ p % c 7 8 . For templates we do not calculate ¤ -or -coordinates of the sample -¥ -¥  § points, but only the -coordinates relative to the center of projec-¥ tion as follows: f g g 3 " &amp; 9 q ' 3 S 5 @ h g 5 S (2) p 9 where h g is the slope of the i th ¥ -template in -direction. After ¥ the ¤ -and -templates have been calculated they are used in sparse ¥ ray casting by combining the information of a single -template ¤ and a single -template: ¥ © c P D g 3 " &amp; 9 j ' P 3 " 6 9 k f g 3 " &amp; 9 ' 3 t P 5 @ h g 5 @ l 9 (3)</cell></row><row><cell cols="7">This is the ray equation for a ray that combines information of ¤ -template and i th</cell><cell>t h X</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>The sample points along</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 1 :</head><label>1</label><figDesc>Average times spent in different parts of the algorithm</figDesc><table><row><cell>Data Set</cell><cell>Templ</cell><cell>Ray</cell><cell>MC</cell><cell>Render</cell><cell>Total</cell></row><row><cell>Aorta</cell><cell>15 ms</cell><cell>9 ms</cell><cell>8 ms</cell><cell>7 ms</cell><cell>38 ms</cell></row><row><cell>Colon</cell><cell cols="3">21 ms 57 ms 62 ms</cell><cell>50 ms</cell><cell>187 ms</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 2 :</head><label>2</label><figDesc>The average number of objects per each frame</figDesc><table><row><cell>Data Set</cell><cell>Voxels</cell><cell>MC</cell><cell>Tris</cell><cell>Rays (%)</cell></row><row><cell>Aorta</cell><cell>58,830</cell><cell>2,326</cell><cell>4,021</cell><cell>2,154 (96.4%)</cell></row><row><cell>Colon</cell><cell cols="4">424,128 17,914 30,811 12,885 (89.0%)</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 3 :</head><label>3</label><figDesc>Comparison between VFC and our visibility method</figDesc><table><row><cell>Data Set</cell><cell>VFC</cell><cell>Our</cell><cell>Reduction</cell></row><row><cell>Aorta</cell><cell>33,095</cell><cell>4,021</cell><cell>87.9%</cell></row><row><cell>Colon</cell><cell cols="2">99,630 30,811</cell><cell>69.1%</cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Interactive exploration of extra-and interacranial blood vessels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Skalej</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Welte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;99</title>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="389" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interactive volume navigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brady</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="243" to="256" />
			<date type="published" when="1998-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Proximity clouds -an acceleration technique for 3D grid traversal. The Visual Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Sheffer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">3D line voxelization and connectivity control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="80" to="87" />
			<date type="published" when="1997-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Virtual voyage: Interactive navigation in the human colon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muraki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97</title>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Jolesz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shinmoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nakajima</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kavanaugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Saiviroonporn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Seltzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Silverman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kikinis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Interactive virtual endoscopy. AJR</title>
		<imprint>
			<biblScope unit="volume">169</biblScope>
			<biblScope unit="page" from="1229" to="1235" />
			<date type="published" when="1997-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 87</title>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Portals and mirrors: Simple, fast evaluation of potentially visible sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Georges</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1995-04" />
			<biblScope unit="page" from="105" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An efficient method for volume rendering using perspective projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Novins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sillion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="95" to="102" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for isosurface rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">P</forename><surname>Sloan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="233" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Perspective volume rendering of CT and MR images: Applications for endoscopic imaging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Beaulieu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Argiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ringl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Norbash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jeffrey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Napel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Radiology</title>
		<imprint>
			<biblScope unit="volume">199</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="321" to="330" />
			<date type="published" when="1996-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Visibility preprocessing for interactive walkthroughs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Séquin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 91</title>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="page" from="61" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Volume rendering based interactive navigation within the human colon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wax</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;99</title>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="397" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A hidden-surface algorithm for computer generated half-tone pictures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Warnock</surname></persName>
		</author>
		<idno>TR 4-15, NTIS AD-733 671</idno>
		<imprint>
			<date type="published" when="1969" />
		</imprint>
		<respStmt>
			<orgName>University of Utah, Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Template-based volume viewing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics &apos;92)</title>
		<imprint>
			<date type="published" when="1992-09" />
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="153" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Visibility computation for efficient walkthrough of complex environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PRESENCE</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive volume rendering for virtual colonoscopy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Junyaprasert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muraki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wax</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;97</title>
		<imprint>
			<date type="published" when="1997-11" />
			<biblScope unit="page" from="433" to="346" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
