<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multi-Resolution Dynamic Meshes with Arbitrary Deformations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ariel</forename><surname>Shamir</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Chandrajit Bajaj ¡ ¡ Center for Computational Visualization TICAM</orgName>
								<orgName type="institution">University of Texas at Austin ¢ Center for Applied Scientific Computing Laurence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Chandrajit Bajaj ¡ ¡ Center for Computational Visualization TICAM</orgName>
								<orgName type="institution">University of Texas at Austin ¢ Center for Applied Scientific Computing Laurence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Multi-Resolution Dynamic Meshes with Arbitrary Deformations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Multi-resolution techniques and models have been shown to be effective for the display and transmission of large static geometric object. Dynamic environments with internally deforming models and scientific simulations using dynamic meshes pose greater challenges in terms of time and space, and need the development of similar solutions. In this paper we introduce the T-DAG, an adaptive multi-resolution representation for dynamic meshes with arbitrary deformations including attribute, position, connectivity and topology changes. T-DAG stands for Time-dependent Directed Acyclic Graph which defines the structure supporting this representation. We also provide an incremental algorithm (in time) for constructing the T-DAG representation of a given input mesh. This enables the traversal and use of the multi-resolution dynamic model for partial playback while still constructing new time-steps. © d c , the histories match exactly apart from places where topology or connectivity changes. When © 3 each history is almost totally different since no similarity constraint is imposed. When © over several time-steps one can see that most of the histories are using the same decimation operations in the same order.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Dynamic scenes in computer graphics are represented by defining some of the scene parameters as functions of time. Global parameters like the position of the viewer (walk-through) or the position of objects can be encoded easily using rigid body transformations or interpolators and behaviors <ref type="bibr" target="#b17">[18]</ref>. The representation of deforming objects is generally much more complex and more time/space consuming. Multi-resolution techniques have been shown to be an effective tool for handling complex geometric objects. However, most of the work done in this field concentrates on static objects. Moreover, the application of previously proposed solutions for dynamic models is restricted to objects in which the connectivity and topology are fixed over time. The T-DAG representation introduced here removes such limitations allowing for a unified representation of dynamic geometries where no restriction is imposed on the modification through time in terms of local connectivity or global topology.</p><p>The T-DAG data-structure is constructed incrementally over time. The information relative to the model evolution for each new £ This work was performed under the auspices of the U.S. Department of Energy by University of California Lawrence Livermore National Laboratory under contract No. W-7405-Eng-48. Research supported in part by NSF grants CCR-9732306, DMS-9873326, ACI-9982297 and Sandia/LLNL DOE ASCI-BD4485 time-step is integrated in the T-DAG as it becomes available. This allows traversing adaptively the multi-resolution model up to timestep ¤ while still augmenting the model with the newly modified object for time-step ¤ ¦ ¥ § . The scheme extends the possibility of using adaptive multi-resolution techniques for display and transmission of time-dependent meshes with general deformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Previous Work</head><p>Many approaches have been developed in the past for creating multi-resolution representations of geometric data for graphics and visualization <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>. They vary in both the simplification scheme like vertex removal <ref type="bibr" target="#b1">[2]</ref>, edge contraction <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>, triangle contraction <ref type="bibr" target="#b7">[8]</ref>, vertex clustering <ref type="bibr" target="#b19">[20]</ref>, wavelet analysis <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref>, and in the structure used to organize the levels of detail (either linear order <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b13">14]</ref> or in a DAG <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b16">17]</ref>). However, these techniques are based on the assumption that the finest resolution mesh is static. Our scheme evolves from such approaches removing this basic assumption of static input and allowing to define a multi-resolution representation for dynamic meshes.</p><p>A time dependent data structure for the extraction of isosurfaces from dynamic volumetric data is presented in <ref type="bibr" target="#b23">[24]</ref>. A temporal Branch On Need Octree (BONO) is created to index the data spatially. Extreme isovalues in each node of the hierarchy are computed for each time step and stored separately. This structure is then used to support queries of the form (timevalue,isovalue) by traversing top down and visiting only in the parts that hold the correct isovalues for the current time-step. When a leaf node is reached, the block containing its data is stored in a list. Once the traversal is done, only blocks in the list are read and the isosurface computed. While this structure seems to be very efficient for isosurface extraction, it supports only this specific visualization primitive. It does not apply to meshes where connectivity can change, and it must be built off-line by global preprocessing. The volume rendering approach of time dependent data in <ref type="bibr" target="#b20">[21]</ref> uses a spatial octree to partition the data, but each node holds a binary time-tree. Each node in the binary tree holds the average value of the containing octree node sub-volume, along with measurements of the spatial and temporal errors of these voxels in the corresponding time range. These measures serve as an indication of the spatial and temporal coherency of the sub-volume. The structure supports queries of the form (timevalue,spatial-err,temporal-err). The octree is then traversed from the root expanding only the nodes that do not pass the tolerance test. In each node the binary time-tree is traversed likewise. The rendering of each octree-node voxel is done separately and the sub-images are composed using their colors and opacities to create the full image. This structure allows very efficient timedependent volume rendering, but is tailored for this specific type of visualization and does not support changes in connectivity or topology of the mesh.</p><p>An opposite approach was presented earlier in <ref type="bibr" target="#b3">[4]</ref> for multiresolution video. A binary time tree is built by subdividing the time span. Each node corresponds to some averaging of all the images of its time span. The node holds a spatial quadtree built from this average image. This structure supports multi-resolution in the temporal dimension by accessing the average images, and seems very appropriate for video sequences. However, it is not clear how to define the average of several time-dependent surfaces, especially when topology and connectivity could change over time, and consequently is difficult to apply such an approach to 3D meshes.</p><p>In our approach we exploit the difference in nature between time and space. We order time information sequentially while supporting multi-resolution representation in the spatial dimensions. However, since we separate the temporal information of each vertex, there is no restriction in storing this information consecutively. In fact, any type of multi-resolution can be defined for this data similar to the binary trees of <ref type="bibr" target="#b20">[21]</ref>. Another option is to use compression in temporal space. In <ref type="bibr" target="#b14">[15]</ref> a method is described for compression of time dependent geometry. The vertex positions matrix is decomposed into</p><formula xml:id="formula_0">¢ ¡ ¤ £ ¥ ¡ § ¦</formula><p>, where P is the time interpolation, V is the vertex positions at key time-steps and G is the Geometry interpolation or spatial interpolation. Using those terms, <ref type="bibr" target="#b14">[15]</ref> concentrates on compressing the £ matrix, while we concentrate on encoding the ¦ matrix using multi-resolution methods. Therefore the two methods are somewhat complementary, and might be combined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contribution</head><p>We define a multi-resolution data structure using time-tags for time dependent traversal. In particular we treat the symbolic information (mesh connectivity and decimation dependencies) in a similar manner as we treat the numeric information (attributes and positions of nodes). We show how this extended data structure enables the representation of a larger class of dynamic models including also connectivity and topology changes.</p><p>We present an incremental algorithm for building this datastructure. The incremental construction enables the use of the datastructure (of previous time-steps) even while the input is being processed. Moreover, this algorithm enables adjusting the resulting structure according to the tradeoff between optimized storage space and traversal time in each time-step for the creation of meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Meshes</head><p>As customary in many application fields and for visualization, we assume that objects are represented by triangular surface meshes. We define a mesh¨by a tuple© §</p><formula xml:id="formula_1">. © ! " $ # &amp; %</formula><p>is a collection of points in ' ) (</p><p>called vertices (we distinguish between vertices and nodes using the latter in conjunction with graphs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">0 2 4 3 5 4 3 5</head><p>is a set of tuples of three vertices in P defining the faces (or triangles) of the mesh. Note that the set of faces induces a certain global topology on the object defined by the mesh (number of connected components, genus of each component). © 6 8 7#% is a collection of functions called attributes defined over the vertices of the mesh, such as 'color' or 'temperature' (7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head># 5 9</head><p>A @ B C</p><p>), or "texture coordinates" (7</p><formula xml:id="formula_2">8 # 9 D @ E C G F</formula><p>). Note that although we restrict our discussion to objects in C (</p><p>, the multi-resolution model and construction algorithm can support objects in any dimension. We call and the numerical information of the mesh, and along with the decimation dependencies (see section 2.3), the symbolic information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Dynamic Meshes</head><p>Consider a time-sequence of meshes:H . For our purposes the actual time values are irrelevant, and so we can normalize the time-steps to unitary intervals ¤ #% @ E g</p><formula xml:id="formula_3">P I ¨ Q H S R U T U T U T V ¨ Q H X W , where ¤ Y à ¤ c b 5 T U T U T ¤ d .</formula><p>. Therefore, we examine the modifications between two consecutive meshesḧ# andQ#</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P i p b</head><p>, and distinguish between different possible classes of changes:</p><p>1. Attribute changes:</p><formula xml:id="formula_4">#© # q i r b , #© # P i p b , # t s © # q i r b . 2. Position changes: # u © # P i p b , # s © # q i p b , # s © # q i r b .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Connectivity changes:</head><formula xml:id="formula_5"># v s © # q i p b , # w s © # q i p b , # x s © # q i p b</formula><p>, but the topology of the object does not change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Topological changes:</head><formula xml:id="formula_6"># y s © # q i r b , # 2 s © # q i r b , # y s © # q i p b , with no restriction.</formula><p>This broad notation covers a large class of possible dynamic meshes defined in scientific simulations, graphics and animation. This includes any finite-element simulations of dynamic systems or key-framing animations featuring attribute and positional changes. It includes continuous affine transformations and free form deformations, by sampling the modification function over time, and creating a sequence of changing meshes. But it also includes dynamic meshes with more drastic changes such as the creation and removal of holes, splitting and merging of components etc.</p><p>The higher modification level a representation scheme can support the larger the class of meshes it can represent, and the greater its expressive power is. An important factor in the definition of our scheme was the ability to support all different levels of dynamic change without sacrificing too much the possibility to optimize the representation for models with lower levels of dynamic change (for example by using quantization of attributes or compression of geometry positions).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Multi-Resolution Model</head><p>A multi-resolution mesh representation for a geometric object¨, is a representation that embodies a set of meshes</p><formula xml:id="formula_7">b F V T U T U T %</formula><p>each of which is in turn a representation for¨. These representations can be seen as different approximations of the original object according to some tolerance. One popular way of creating a multi-resolution model is by decimating an initial mesh¨from the bottom up to a coarse mesh. In very general terms this process involves three primary decisions:</p><p>1. Selecting the primitive decimation operation and the basic decimation element e.g. a vertex in vertex removal, an edge in edge contraction. These operation and elements are used in a priority queue which governs the order of decimation.</p><p>2. Defining an error function (estimate) introduced by applying the primitive decimation to the mesh. This function is highly dependent on the mesh type and decimation scheme: e.g. terrains <ref type="bibr" target="#b1">[2]</ref>, scientific data <ref type="bibr" target="#b0">[1]</ref>, or graphical objects with color and texture attributes <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12]</ref>. This type of function is used (i) during the construction of the multi-resolution model for priority in the decimation queue, and (ii) for traversal of the resulting model to extract a given mesh.</p><p>3. Choosing the type of multi-resolution data-structure used for storage.</p><p>Once these are set, the algorithm for building a multi-resolution model consists of inserting all decimation elements into a priority queue, repeatedly choosing the first element, applying the decimation to the mesh, and encoding the decimation and its error in the data-structure. In a sequential model, the sequence of discrete modifications (decimation operations) is recorded in a linear data structure. According to the direction of traversal and the current approximation, a series of operations from this sequence is performed on the existing mesh either from coarse to fine or from fine to coarse. In the graph model <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b25">25]</ref> simplification is performed in multiple levels where each level includes only independent decimation operations. The operations are recorded in a Directed Acyclic Graph (DAG). The nodes of the DAG represent decimation operations while the edges represent dependencies between such operations. If we assume that all roots in this DAG are connected to a single virtual super-root, then a cut in this graph is a collection of edges, which intersect all paths from the super-root to the leaves once and only once. Any such cut corresponds to a valid adaptiveresolution approximation of the model <ref type="bibr" target="#b4">[5]</ref>. In particular the approximation corresponding to a specific cut can be obtained performing all and only the decimation primitives corresponding to nodes in the DAG below the cut (nodes in a path from the cut a leaf). The DAG model allows greater flexibility since one can generate adaptive approximations that were not explicitly constructed during the simplification process.</p><p>The decimation elements can be vertices in a vertex removal scheme or edges in an edge contraction scheme. A cost function</p><formula xml:id="formula_8">¡ £ ¢ ¥ ¤ ¤ U</formula><p>associates each element with the cost (or degradation) due to its removal from the mesh. The priority queue ¦ keeps always at the top (maximum priority) the element with minimum cost. The ¤ ¢ §</p><p>(tolerance) parameter governs the stopping criteria for the decimation in each level. It is initialized to some minimum and gradually increased with the levels in order to continue building the hierarchy ¦ . This helps control the maximum error allowed at each level, but should be used cautiously as it may lead to an unbalanced hierarchy. To guarantee a balanced hierarchy we keep performing the decimation process if the tolerance criterion is satisfied or if a minimum percentage of the mesh vertices have not been decimated yet. Once the DAG is constructed, a mesh representation can be generated by traversing the DAG from the roots towards the leaves, and creating a cut in the DAG. At each step, the error stored at the current node is compared with a given error tolerance. If this tolerance is not met, the cut is advanced from this node to its children, reversing their decimation operations and checking them in the same manner. In order to create coherent triangulations, a node can be included in the cut only if all its parents are already in the cut (not only the parent from which this node was reached). This is corrected by recursively checking and adding all the parents of a node before visiting it.</p><p>Our multi-resolution time-dependent model extends the graphbased approach. This means that in addition to the attributes, positions and connectivity information, the dependencies recorded in the graph may also be time-dependent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DYNAMIC MULTI-RESOLUTION MODEL</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Mesh Mapping and Global Vertex Indexing</head><p>In order to define the dynamic multi-resolution model we need to have some correspondence mapping between the vertices of the mesh in the consecutive time-steps. One simple approach to accomplish this is to assume that each vertex can be identified precisely through time. Let¨Y</p><formula xml:id="formula_9">b U T U T U T¨ d</formula><p>be the dynamic sequence of meshes. This mapping means that if "# 0 respectively). In other words the mapping between consecutive time steps is implemented using a global indexing scheme for the vertices in the mesh through time so that new vertices can appear and old vertices can be removed. Each new vertex must have a distinct identifier and the identifiers of removed ver-tices cannot be reused. This restriction can simplify both the structure and implementation of the algorithms. Additional conditions under which an index can be reused are also possible but tend to become complex for incremental construction of the T-DAG. The underlying assumption is that although dynamic changes are involved, most of the meshes have similar sets of vertices (the worst case will mean each time-step will have a separate vertex set).</p><p>Furthermore, we need a similar mapping between vertices of different levels of approximation. Therefore, we restrict our choice of decimation operation to those which preserve a mapping between the vertices before and after applying the operation. For example, vertex removal or Half-edge contraction do not introduce new vertices and therefore the identity of vertices is carried through trivially to any level. By applying some positional change in general edge contraction, one can map the new vertex introduced after the contraction to one of the two old vertices. Let¨# be a mesh at some resolution, and let¨# q i r b </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Definitions</head><p>Once the two mapping restrictions are met, we can identify a node in the DAG with some specific vertex in the dynamic mesh. Such node represents the decimation operation connected with this vertex (e.g. the removal of this vertex or the contraction of an edge adjacent to it). We then attach all the numeric vertex information and symbolic graph information as fields to the nodes. All nodes will have the same set of five fields: (i) vertex attributes, (ii) vertex positions, (iii) node decimation error, (iv) parent node links in the DAG, and (v) child node links in the DAG.</p><p>These fields have two basic types: single-valued fields and multiple-valued fields. Error estimation, vertex coordinates, or color components have only a single possible value, and therefore are defined as single value fields. Parent and child links in the DAG have several values associated with them all valid at the same time, and therefore are defined as multiple-valued fields. For a static multi-resolution DAG the fields in all nodes would be static. In a dynamic setting they are time dependent and need to be represented as functions of time. Both the numerical and the symbolic information are treated in the same manner by attaching different time-tags to different values in the fields. These tags are in the form of sequences of ranges g </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Queries</head><p>As a model for the dynamic meshesḧY</p><formula xml:id="formula_10">¨ A b T U T U T U ¨ d</formula><p>, the T-DAG is parametric in two dimensions: resolution and time (see <ref type="figure" target="#fig_3">Figure 7)</ref>. Therefore, every valid T-DAG query needs to instantiate these two parameters. The fundamental query we are interested in is a random-time and random-resolution mesh retrieval in the form (time = ¤ ,tol = ). The result of this query is an approximation¨¡ H of the meshQH which does not differ fromḧH by more than under some given error function. Note that we use only in our discussion for simplicity, but the error functions supported can involve more complex computations and additional parameters like in view-dependent error estimate.</p><p>The second type of queries we consider is incremental in nature: given¨¡</p><formula xml:id="formula_11">H fi nd¨¡ Hi p b o r¨¡ H £ ¢ b , or given¨¡ R H find¨¡ ¥ ¤ H</formula><p>. The incremental queries can be supported trivially using the fundamental query. However, we are interested in finding progressive solutions, where the mesh of previous time step (previous resolution) is progressively updated to arrive at the next time (resolution). The third type of query is the most difficult to support progressively and it involves increments in both time and resolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Time-Dependent Storage and Retrieval</head><p>Considering that almost all actual information of the T-DAG is stored at the nodes, the above queries would be translated to basic time-dependent retrieval operations on the fields of the nodes. These operations are of the form: </p><formula xml:id="formula_12">¤# q i p b © ¤# 4 ¤# ¥ ! ¤# q i " i p b . Similarly, ¤ #¢b © ¤# ¥ ¤ #¢b 4 " ! ¤ # q i</formula><p>. We keep pointers to the value with smallest birth time greater than ¤ # q i " in the birth time array, and to the value with the largest death time smaller than ¤ # t o the death time array. Using those pointers, the incremental (both forward or backward in time) update takes § ¦ time. For random access, the binary search to reposition the pointers and the collection of values inside storage. Also, inside a given window in time, we can preserve § ¦ for random time queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Resolution Change</head><p>For traversal in resolution space, an array of root indices is stored in the T-DAG in addition to all nodal values. This array is stored in the same manner as any other multiple-valued field. For a give timestep ¤ , the T-DAG can be seen as a static multi-resolution DAG for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H</head><p>. Therefore, the type of error functions supported by the T-DAG are exactly the same as those for the static case, including adaptive and view-dependent refinements (see Color Plate 1). Moreover, traversal is done using essentially the same algorithm for top down construction of a mesh from a static multi-resolution representation. For a given time-step ¤ , we start from the set of alive roots at time ¤ , and traverse the graph in a top down manner using only child and parent links which are alive in time ¤ . At each node the error stored for time ¤ is checked using the given error function. Other attributes and position information (used for example, for rendering the mesh), are all accessed as a function of time ¤ , allowing simple modification of the shape and appearance of the mesh through time. Moreover, if the time ¤ remains static, incremental resolution queries on a T-DAG can be supported dynamically by updating the DAG-cut similar to static multi-resolution DAGs.</p><p>Although our storage and retrieval scheme favors incremental time queries inside nodes, we adopt a lazy-evaluation scheme for the values of the nodal fields. For a given time ¤ only the fields of nodes visited during the traversal are retrieved and updated to the current time ¤ . As a consequence a node which was above the cut at time ¤ for a specific tolerance, and below the cut at times</p><formula xml:id="formula_13">¤ ¥ § U T U T U T V ¤ ¥ $ # 4 §</formula><p>, would not be evaluated and updated in those times. If it returns to be above the cut at time ¤ ¥ % #</p><p>, the retrieval of values in its fields would become random-time queries instead of incremental. However, since the T-DAG is a multi-resolution model, only a subset of all nodes (and hence, a subset of the vertices) is needed to create an approximating mesh for a given tolerance. Therefore, the cost of random time retrievals of values in some node fields is a minor penalty with respect to the large gain of updating only a sub-set of the nodes at each time-step. <ref type="figure">Figure 6</ref> displays for different T-DAGs the average traversal time needed to create meshes of various resolutions. These plots are similar in behavior to that of static multi-resolution DAGs <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">T-DAG CONSTRUCTION</head><p>Consider a time sequence of meshesḧY</p><formula xml:id="formula_14">¨ A b T U T V T U ¨ h d</formula><p>, which satisfies the global vertex indexing scheme defined in Section 3.1. In this section we introduce and analyze an on-line algorithm for constructing a T-DAG providing a multi-resolution model for the given time sequence of meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Space-Time Tradeoffs</head><p>The trivial scheme that one may consider is to treat each mesḧ # i ndependently, and construct an independent multi-resolution DAG¨ # w hich conforms to the resolution-levels mapping (Section 3.1). The result of this scheme is a sequence of multiresolution DAGs¨</p><formula xml:id="formula_15">Y ¨ b U T U T V T¨ d</formula><p>. for this field and set its birth and death time to be ¤ ¥ § . Using time range tags to encode the lifespan of field values is beneficial when the ranges of the values are long. This gain is expressed both in terms of space (changing the death-time instead of creating a new value) and in terms of traversal time (less timedependent updates). The longer these chains of similar values are, the greater the gain. Therefore, this T-DAG construction scheme is almost equivalent to the worst case of storing each¨ # s eparately. The fact that the DAGs were created independently results in rare occurrences of fields having the same value for consecutive time steps <ref type="figure" target="#fig_7">(Figure 2(a)</ref>).</p><p>The other extreme for a T-DAG creation scheme would be to use just a single DAG for all time-steps. For example, create¨  <ref type="figure" target="#fig_7">(Figure 2(b)</ref>). In such a scheme the storage space and timeupdates are kept to a minimum. However, a single DAG will not have an optimal structure for all different meshes in all time-steps. This will generally force traversals to reach down to lower levels of the graph in order to satisfy a given error tolerance, and results in larger meshes for a given tolerance (see Color Plate 2). Furthermore, it is not always possible to use a single DAG to encode a whole sequence of dynamic meshes. As an example, consider the case of dynamic meshes where the connectivity or the topology changes over time.</p><p>The first construction scheme favors optimizing each specific time-step locally in terms of traversal time for a certain error, or The original dynamic meshes hold 12000 vertices in 20 time-steps. (a) was constructed by simply merging independent DAGs created for each time-step, hence, most of the values have very small time ranges, (b) was constructed by using only a single DAG of the first time-step and applying, whenever possible, the exact same decimations for all other time-steps meshes. Similar distributions occur in most fields of T-DAGs constructed using these two opposite schemes. the quality of the mesh for time restrictions. The second (which is not always possible) means sacrificing traversal time or quality at the gain of lower storage space, and less time-dependent updates in nodes. Defining a general construction scheme which is optimal both in terms of storage-space and traversal time might be difficult. Instead, we aim at defining a framework where a valid T-DAG can always be constructed, and there is a possibility of control over the different tradeoffs, by using a predefined construction parameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Incremental Construction</head><p>In addition to the space-time tradeoffs for a given T-DAG construction, it is often beneficiary to construct the T-DAG incrementally over time. For example, in scientific simulations heavy computations are involved in producing the mesh for each time-step. Instead of waiting until the whole process is complete to construct the model, we would like to be able to visualize in a multi-resolution manner even partial results. Let </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>#¢b</head><p>might involve complicated graph matching problems. Instead, the key idea behind the incremental T-DAG construction algorithm is to create at each time-step a multiresolution DAG using decimations which will conform to the existing T-DAG. This is done by using an enhanced priority in the decimation process, introducing some history considerations which augment the regular priorities of decimation cost. These considerations aim to preserve the structure of the previous time-steps T-DAG.</p><p>We define a history of decimations as a sequence of decimation operations that were applied to a mesh, sorted by increasing level and in each level by the order in which they were executed. Our algorithm uses two such history sequences: "   <ref type="figure" target="#fig_9">Figure 3</ref>: An outline of the algorithm for one time-step of creating a multi-resolution T-DAG model. The degree of conformity between the current and previous time-steps is governed by the function largeDiff. This function checks the difference in cost of the decimation in the current and the previous time-steps. The algorithm first tries to decimate conforming to the previous time-step, and only then reverts to its own priority queue. At each time-step the decimation order is recorded and used in the next time-step by using the decimation histories " g ! and " ¢ $ # ¤ . some decimations of previous levels may have been skipped due e.g. to large cost, but they might be applied in the current level. The element extracted is matched to an element in the current priority queue ¦ . The matching of elements is used in a loose sense, e.g. two edges can match in edge contraction even if the surrounding triangles do not match perfectly. A stricter matching strategy would fail more often, and our goal is to use such matching only to increase the chance of long time ranges for values in the node fields. The decimation is skipped in one of the following four cases: (i) if no matching element is found in the current queue, (ii) if the element found is dependent in this level, (iii) if the cost of applying the decimation is too large (</p><formula xml:id="formula_16">7 ¡ ,© ¦ ) A while is not empty § $ # ) B C £ ¦ D 1 0 ¦ 3 2 ¦ 4 if § is marked as dependent continue if § $ # ) ( &amp; 0 ¦ 3 2 5 4 ¢ 6 ¦ break ApplyDecimation( § , , 7 ¡ ,© ¦ ) A increase ¦ A ApplyDecimation( § , , 7 ¡ ,© ¦ ) mark all elements dependent on § decimate using § store decimation in ¢ ¡ 2¦ ¤ £ ¦ ¥ E § &amp; 4 store § dependencies in ¢ ¡ 2¦ ¤ £ ¦ ¥ E § &amp; 4 store § in © ¦ update if needed A</formula><formula xml:id="formula_17">¡ £ ¢ ¥ ¤ ¤ U % ¤ ¢ §</formula><p>), or (iv) if the difference between the previous decimation costs and current is too large (see Section 4.3 for the definition of largeDiff). Otherwise, it is performed and recorded in " ¢ $ # ¤ for the next time-step. Some decimations from the previous time-step cannot be found due to topology or connectivity changes. Other decimations are valid only on the current mesh, and so the algorithm performs them at the end of each level. <ref type="figure">Figure 4</ref> illustrates a comparisons between the decimation histories of consecutive time-steps of the balls in (Color Plate 4). As can be seen, most of the decimations are carried across the time-steps in the same order, the likelihood of long time ranges for nodal field values is increased, and there is gain in storage and time-values updates. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H1 H2 H1 H2</head><p>H1 H2 H2 H3 H3 H4  <ref type="figure">Figure 6</ref> displays the average traversal time from the roots to a cut satisfying different tolerances for the three different conforming factors. Larger values means the T-DAG shape will be optimized for each time-step separately, creating higher cuts in the DAG for a given tolerance, and presumably traversing faster.</p><formula xml:id="formula_18">W Y X ∞ ∞ ∞ ∞ W Y X à W Y X Y T W Y X Y T W b X Y T</formula><p>However, during the traversal, the time-dependent fields need to be updated. Whenever the conformity is larger, this update is smaller and faster and this results in the total traversal being faster. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>In this section we examine several examples for the use of a T-DAG. We show the flexibility of the model and the ability of the construction algorithm to encode time-dependent information with different restrictions. All examples were created on an Intel Pentium-2 450 mhz machine with 128mb of memory.</p><p>In the first example (see Color Plate 3), is the output of a simulation of two sub-atom particles colliding over a 2D domain. This simulation tracks several attributes changing over 50 time-steps (density, electrostatic field, ...). Under these conditions, defining an optimal decimation for all variables could be difficult. Moreover, if new attributes were introduced, this would mean recalculation of the whole structure from the first time-step. Instead, we chose to use a purely geometric condition to govern the decimation process. Using random maximal vertex removal, we preserve at each step a Delaunay triangulation (this scheme was presented in <ref type="bibr" target="#b1">[2]</ref> for static terrain meshes). On average, the Delaunay triangulation gives good adaptive triangulation results for all attributes. The real advantage of using such a scheme is in the fact that a single average DAG was used for all time-steps and all attributes. This means that the child and parent links all have the maximum time-range and therefore there are no time-dependent updates. The different triangulations extracted over time are a result of the differences in the error field for different attributes over time.</p><p>Considering a 3D surfaces, additional tests are necessary be-sides checking the approximation error during the traversal of the DAG. For example, in order to preserve correct embedding of the surface, triangles in the neighborhood of the decimation need to be checked for orientation changes, global intersections should be tracked, etc. <ref type="bibr" target="#b21">[22]</ref>. These types of tests could involve heavy computation, making it impractical at traversal time. However, if these tests are carried out during the construction stage of the T-DAG, verifying that all cuts in all time-steps satisfy the tests, the traversal time can be reduced. A simpler choice, although it does not guarantee correct embedding, would be to penalize during decimation the cost of contractions that cause a change in triangle orientation, and omit such checks during traversal.</p><p>In the second example we encode a dynamic sequence of meshes created by two waves colliding (using 7200 faces). We use halfedge contraction as decimation primitive and quadratic error metric for tracking decimation cost <ref type="bibr" target="#b6">[7]</ref>. The T-DAG constructed then supports the extraction of meshes at any point in the two dimensional space of time and adaptive resolution ( <ref type="figure" target="#fig_3">Figure 7</ref>). In cases where the connectivity or topology of the dynamic mesh changes, the differences of the symbolic information through time must be encoded as changes in the child and parent field values over time. The last example (Color Plate 4) shows a two balls merging (or a ball splitting) with 12,800 faces. The multi-resolution hierarchy was built with quadratic error metric using half-edge contraction. In this case the finest resolution triangulation has different connectivity in most time-steps and there is also a discrete change in topology at one time-step. In fact, using the T-DAG model these changes were encoded seamlessly by the construction algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FUTURE DIREC-TIONS</head><p>Numerical simulations and dynamic environment processing deformable large scale models are becoming more common as the computation power and ability to display high-end graphics evolves. These models are larger and more complex than static geometric models, and therefore necessitate further use of multiresolution techniques. In this paper we presented the T-DAG, a multi-resolution representation for dynamic meshes with arbitrary change. This model is flexible enough to encode models ranging from the use of a single DAG for all time-steps to more complex graphs with connectivity and topology change. The construction algorithm is simple enough to be used with many types of decimation operations, yet it is powerful enough to seamlessly encode topology and connectivity changes in the dynamic meshes. There are several possible extensions for this work. One of the most important remaining challenges for the T-DAG is the update of any adaptive cut dynamically over time instead of creating it by traversing from the roots. Another involves out-of-core computations. The T-DAG structure evolves through time in coordination with the meshes around the current time-step. Although the amount of time-dependent information in each node of the T-DAG could be large, if one concentrates on the window of time-steps, the live information is much smaller. This fact could be used to support out-of-core multi-resolution dynamic models, enabling efficient decomposition of the data into viewing windows of time-steps which can fit into memory. Also, since the temporal information is gathered in the T-DAG nodes, temporal coherency could be exploited for compression.</p><p>Lastly, it is possible to use the T-DAG for applying timedependent constraints for multi-resolution in the same manner as view-and space-dependent constraints are used. For example, an object which moves or deforms rapidly could be displayed in lower resolution than an object which deforms slowly.</p><p>Color Plate 1: A dynamic mesh represented by a T-DAG can support adaptive cuts similar to static meshes. The snake's mesh may change over time (top) but the head which is closer to the viewing point has finer resolution than the tail in all time steps (bottom).</p><p>Color Plate 2: A T-DAG created by using a single time-step DAG does not have an optimal structure for all time-steps. Compare the left mesh extracted for a given tolerance for the first time-step (which is the time-step of the DAG used to govern the T-DAG construction), to the right mesh extracted for later time using the same tolerance.</p><p>Color Plate 3: A simulation of collision between two sub-atomic particles encoded in a T-DAG. The simulation tracks the interaction of several different variables over 50 time-steps. The T-DAG was built using random vertex removal preserving Delaunay triangulations. This means the symbolic information for all time-steps is the same, but the numerical information is different. The T-DAG extracts different triangulations due to the difference in errors over time (top to bottom), difference in tolerance (1% at (a) and (c) and 10% at (b) and (d) sub-columns) and for different variables ((a),(b) show density and (c),(d) show electrostatic scalar field potential).</p><p>Color Plate 4: A merging or splitting ball mesh sequence. The top row shows several time-steps. The middle row shows the starting and ending meshes which have different topology and connectivity at both high and low resolution. The bottom row shows detail of the balls intersection curve at various resolutions. Note that this curve is not a boundary curve but rather a set of internal edges in the mesh.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>"</head><label></label><figDesc>are considered the same vertex in different time-steps (¤ © and ¤</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>be a mesh created by applying such decimation operator to¨# , then we have that the total number of nodes in the DAG is exactly the number of vertices in the original finest resolution mesh. Another possibility in edge contraction is to use a total of " ! vertices for all levels when ! is the number of vertices in the fine resolution mesh<ref type="bibr" target="#b10">[11]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>7 , as long as g s © 8 .Figure 1 :</head><label>781</label><figDesc>value is alive in its field. Consider a dynamic mesh with % time-steps. We define a singlevalued field of a node ! of numbers (for simplicity of notation even pointers are assumed to be represented as real numbers). A value 6 is defined as not alive at time step ¤ iff its field returns 0 death-time. Note that 6 can have be multiple birth/death times. The T-DAG is the collection of all values for all time steps of all the fields in all the nodes. Note that the overall T-DAG can be a general graph but for any specific time-step ¤ , the collection of all alive parent or all alive child links form an actual DAG at time ¤ (see Figure 1). In general, a node ! Y in the T-DAG might be a descendent of node ! b a t time ¤ # , and an ascendant of node ! b a t time ¤ The child links in a T-DAG structure with five time-steps (top), and the five DAGs it represents (bottom). Each child link edge in the top T-DAG carries a tag depicting the range of timesteps in which it is alive.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>. 7 !</head><label>7</label><figDesc>node.getAliveValue(timeStep t)which returns the alive value for a single-valued field (e.g. getError, getPosition) or: node.getAliveValues(timeStep t, array &amp;values) which returns the alive values for a multiple-valued field (e.g. getChildren, getParents).Let% be the number of time-steps in the T-DAG, and ¦ the maximum single-time size of a multiple-valued field of a node (for example, the maximum number of children for all time-steps). If ! is the number of different values for a specific field in all time-For fast random and incremental access of the time-dependent information ( § § for single-valued, § ¦ for multiple-valued fields), values can be stored in an § % ¦array of all time-steps. However, often this storage is too costly. A better option would be to store the single-valued fields in a list sorted by birth time, and the multiple-valued fields as an interval tree. This will bring down the storage to § 7 ! in the worst case, but the retrieval time would be worse. For the single-valued fields, incremental access would be constant, but random time access would take § © (binary search for the active value). For multiple-valued fields, both random and incremental access would take active values from the tree.A slightly better approach for multiple-valued fields allows § ¦ incremental and sometimes random access, and § access. We store the values in two lists, one sorted by increasing birth times and the other sorted by decreasing death times ( § 7 ! storage). We define a time-window of size G % , where we store all active values for this window in time (i.e. from of values born in time ¤ . It is simple to check that</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>time queries can be implemented in § ¦ time-complexity with § 7 !</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>6 , we create a new value 6 for</head><label>66</label><figDesc>To encode such sequence of DAGs in a single T-DAG we can define ¡ union of all vertices in all timesteps. Then we construct a node in the T-DAG for each such vertex, and encode all¨ # m eshes using these nodes in the following manner: loop on all timesteps ¦ loop on all nodes § inï f § © set the fields of § at time ¦ with the values of the fields of § in elseset the fields of § this field and set its birth and death time to be ¤</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>of looping on the nodes of¨ # , we loop on all # , and apply the same decimations as in¨ Y t o the mesh¨# . This would mean most fields (e.g. child or parent links) would have values alive for the whole time range, but some (such as coordinate positions or decimation error) would still have changing values over time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 2 :</head><label>2</label><figDesc>Percent of parent link values of all nodes in a T-DAG covered by parent link values of a given range for two different T-DAGs. The size of T-DAG (b) is around 30% the size T-DAG (a). The two T-DAGs were constructed for the snake example of Color Plate 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>3 )</head><label>3</label><figDesc>time-step decimations. At the beginning of each time-step (% The algorithm (Figure 3) loops on the decimation operations in " g ! using getElement(). This function returns the next element (edge, vertex etc.) representing the next decimation operation in " g ! from levels 0 and up to the current level. This is done since</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 4 : 3 .</head><label>43</label><figDesc>Comparisons between decimation histories of consecutive time-steps for different strategies. The decimation operations are laid out from top to bottom according to their execution order. White regions represent operations that match in both histories. Gray regions represent operations that were performed only at the left or right histories. The links across histories connect regions where the same operations were performed in different order. When4.3 Space-Time Control FactorWhen the conformity between consecutive time-step decimations is large, more attribute values are unchanged across several time steps and the time-range tags of such attributes in the node fields are larger. As discussed earlier, this results in reduced storage size, and faster time-dependent changes. If ¡ H i s the cost of the current decimation in the current time-step, and cost of the same decimation in the previous time-step, then we use largeDiff( order to control the level of conformity between the two time-steps. Whenever this function returns true the decimation is skipped. Therefore, for greater conformity more such tests should fail, and for lesser conformity, more tests should succeed. We use as specific largeDiff: the value of the factor increases, the conformity decreases. For example, consider three T-DAGS of the meshes sequence inFigure 7built with conformity factors © These meshes have 7200 faces and 50 time-steps.Figure 5displays the percent of child links covered by ranges of child link values in the three different T-DAGs. Other nodal field values (e.g. parent links) display very similar patterns, and in fact, the ratio of the total sizes of the three different T-DAGs is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>F=10Figure 5 :Figure 6 :</head><label>56</label><figDesc>Percent of child link values of all nodes in a T-DAG covered by child link values of a given range for T-DAGs created with different values of the conforming factor © Average traversal time (of 50 timesteps) for a given tolerance for T-DAGS of different conforming factor F.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 7 :</head><label>7</label><figDesc>Two dimensional space of time (horizontal) and resolution (vertical) defined by the T-DAG model of a mesh of two colliding waves.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Topology preserving data simplification with error bounds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="12" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On levels of detail in terrains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">T G</forename><surname>Dobrindt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphical Models and Image Processing</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics Proceedings, SIGGRAPH&apos;95, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="173" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multiresolution video</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Salesin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics Proceedings, SIGGRAPH&apos;96, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="281" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Building and traversing a surface at variable resolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Visualization Conference VIS&apos;97</title>
		<meeting>the IEEE Visualization Conference VIS&apos;97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="103" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Data structures for simplicial multi-complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Symposium on Spatial Databases</title>
		<meeting>Symposium on Spatial Databases<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics Proceedings, SIGGRAPH&apos;97, Annual Conference Series</title>
		<editor>Turner Whitted</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Constructing hierarchies for triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tran</forename><forename type="middle">S</forename><surname>Gieng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">L</forename><surname>Schussman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Issac</forename><forename type="middle">J</forename><surname>Trotts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="145" to="161" />
			<date type="published" when="1998-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Survey of polygonal surface simplification algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics Proceedings, Annual Conference Series, SIGGRAPH&apos;97, Multiresolution Surface Modelling</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics Proceedings, SIGGRAPH&apos;96, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics Proceedings, SIGGRAPH&apos;97, Annual Conference Series</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">New quadratic metric for simplifying meshes with appearance attributes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization&apos;99</title>
		<meeting>IEEE Visualization&apos;99</meeting>
		<imprint>
			<publisher>IEEE Comp. Soc. Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Smooth view-dependent level-of-detail control and its application to terrain rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization&apos;98</title>
		<meeting>IEEE Visualization&apos;98</meeting>
		<imprint>
			<publisher>IEEE Comp. Soc. Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multiresolution representations for surface meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SCCG</title>
		<meeting>the SCCG</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Compression of time-dependent geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Lengyel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 ACM Symposium on Interactive 3D Graphics</title>
		<meeting>the 1999 ACM Symposium on Interactive 3D Graphics<address><addrLine>Atlanta, Georgia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Spatial operations on multiresolution cell complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paola</forename><surname>Magillo</surname></persName>
		</author>
		<idno>DISI-TH-1999-03</idno>
	</analytic>
	<monogr>
		<title level="m">Dipartimento di Informatica e Scienze dell&apos;Informazione, University of</title>
		<meeting><address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>phd thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Progressive tins: Algorithms and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Maheshwari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Morin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Sack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 5th ACM workshop on Advances in geographic information systems, Las Vegas</title>
		<meeting>5th ACM workshop on Advances in geographic information systems, Las Vegas</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>International Organisation For</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Standardi-Sation</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Of</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Audio</forename><surname>Pictures</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iso</surname></persName>
		</author>
		<ptr target="http://drogo.cselt.it/mpeg/standards/mpeg-4/mpeg-4" />
		<title level="m">IEC JTC1/SC29/WG11 N2995. MPEG4 standard specifications</title>
		<imprint/>
	</monogr>
	<note>htm edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multi-resolution 3d approximation for rendering complex scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Geometric Modeling in Computer Graphics</title>
		<editor>B. Falcidieno and T. Kunii</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A topology modifying progressive decimation algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization97</title>
		<editor>Roni Yagel and Hans Hagen, editors</editor>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997-11" />
			<biblScope unit="page" from="205" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A fast volume rendering algorithm for time-varying fields using a time-space partitioning (tsp) tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Visualization Conference VIS&apos;99</title>
		<meeting>the IEEE Visualization Conference VIS&apos;99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="371" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Progressive tetrahedralizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">G</forename><surname>Staadt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Visualization Conference Vis98</title>
		<meeting>the IEEE Visualization Conference Vis98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="397" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Wavelets for Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Stollnitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">D</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Salesin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Isosurface extraction in timevarying fields using a temporal branch-on-need tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>t-bon</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m">Proceedings of the IEEE Visualization Conference VIS&apos;99</title>
		<meeting>the IEEE Visualization Conference VIS&apos;99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="147" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dynamic view-dependent simplification for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Visualization Conference Vis96</title>
		<meeting>the IEEE Visualization Conference Vis96</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
