<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multi-User View-Dependent Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jihad</forename><surname>El-Sana</surname></persName>
							<email>el-sana@cs.bgu.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Ben-Gurion University Beer-Sheva</orgName>
								<address>
									<postCode>84105</postCode>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Multi-User View-Dependent Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>In this paper we are presenting a novel architecture which allows rendering of large-shared dataset at interactive rates on an inexpensive workstation. The idea is based on view-dependent rendering on a client-server network. The server stores the large dataset and manages the selection of the various levels of detail while the inexpensive clients receive a stream of update operations that generate the appropriate level of detail in an incremental fashion. These update operations are based on changes in the clients&apos; view-parameters. Our approach dramatically reduces the amount of memory needed by each client and the entire computing system since the dataset is stored only once on the server&apos;s local memory. In addition, it decreases the load on the network as results of the incremental update contributed by view-dependent rendering.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The advances in three-dimensional acquisition, simulation, and design technologies enable the generation of complex polygonal models and large virtual environments. However, most of these datasets exceed the main memory size and the interactive rendering capabilities of current graphics hardware resulting in unacceptable frame rates for most applications that require real-time interaction. Several software and algorithmic solutions have been recently proposed to bridge the increasing gap between hardware capabilities and the complexity of the graphics datasets. These include level-of-detail rendering, occlusion culling, and image-based rendering.</p><p>Recently view-dependent rendering has been introduced to enable seamless and adaptive level-of-detail representations on real-time for polygonal datasets. The level of detail selection is based on view parameters such as view location, illumination, and speed of motion. Current view-dependent rendering schemes usually increase the size of the dataset, require the existence of the entire dataset in main memory, and do not enable different users to share the dataset currently in memory. To overcome the memory size drawback El-Sana and Chiang <ref type="bibr" target="#b7">[8]</ref> have developed an external memory view-dependent simplification. However, their approach provides only a single-user solution and requires an additional level of preprocessing. In an era of reasonably fast communication networks and supercomputer servers with large memory size, the issue of sharing the multiresolution representation of the dataset becomes even more crucial.</p><p>To clarify this issue let us consider, as an example, a large CAD firm. In such a firm, usually there are several engineers who work on the same product which is generally very large, complex, and therefore kept on a local server. Often, these users can not bring the entire model to their local workstations because either the entire model exceeds their local machines' memories or they must keep consistency on the model database. In addition, sending the entire dataset to the users' machines at each frame or even every dozen frames would overwhelm the local network. Providing each user with a powerful workstation (in terms of computation, rendering capabilities, and memory size) seems to be an inadequate solution because it is too expensive and still does not handle all large datasets. Hence, we assume that users have inexpensive machines, which do not have the capability to render the entire dataset at interactive rates.</p><p>The engineers, in our example, are interested in visualizing the entire dataset as well as observing small regions. For example, in a car design they are interested in the external appearance of the car -hence they have to visualize the entire car model-as well as observe the fitness of small fuel pipes. Using a lower resolution will allow rendering the entire model at interactive rates, even though its size exceeds that of the local memory and are beyond the rendering capability of the user's workstation. Also, keeping the close-to-viewer, front-facing, and in-frustum regions at high resolution and far-form-viewer, back-facing, and off-frustum regions at low-resolution will enable visualizing the given dataset at interactive rates. Therefore, using view-dependent rendering seems to provide an excellent solution but the users' machines often do not have the capability to carry out a view-dependent rendering procedure. Actually, this is the main motivation for combining multi-user visualization with view-dependent rendering.</p><p>In this paper we have developed a view-dependent rendering for large datasets over a local network. Our solution is based on the view-dependent tree data-structure <ref type="bibr" target="#b9">[10]</ref> and a client-server architecture. The view-dependence tree resides in a capable machine in terms of memory size and computation power. We shall refer to the capable machine as a server and to the other workstations as clients. During a connection session between a server and a client, the server receives the client's viewparameters, then based on these parameters the server sends a list of operations which includes a set of vertices and triangles to insert or remove. On receiving these operations the client updates its display lists and sends them to its graphics hardware.</p><p>Our architecture enables inexpensive workstations to take advantage of view-dependent rendering when visualizing large datasets. In addition, it reduces the memory needed by each client machine, improves the rendering frame rates, and dramatically reduces the communication load. Currently our approach works on local networks but we believe it should also work for geographically distributed networks.</p><p>In the rest of the paper we shall first discuss previous work on multiresolution hierarchies and distributed rendering. Then we describe our approach followed by implementation details and empirical results. Finally we draw some conclusions and suggest directions for future work. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Previous Work</head><p>Our system is based on two main ideas: view-dependent rendering and a set of users who share the visualized dataset. Next, we will briefly discuss some of the previous work in these two fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">View-Dependent Rendering</head><p>Most of the previous work on generating multiresolution hierarchies for level-of-detail-based rendering has concentrated on computing a fixed set of view-independent levels of detail. At runtime an appropriate level of detail is selected based on viewing parameters. Recent advances to address some of these issues in a view-dependent manner take advantage of temporal coherence to adaptively refine or simplify the polygonal environment from one frame to the next. In particular, adaptive levels of detail have been used in terrains by Gross et al <ref type="bibr" target="#b11">[12]</ref> and Lindstrom et al <ref type="bibr" target="#b17">[18]</ref>. Gross et al define wavelet space filters that allow changes to the quality of the surface approximations in locally-defined regions. Lindstrom et al define a quadtreebased block data structure that provides a continuous level of detail representation. Most of the work for view-dependent simplifications for general polygonal models is closely related to the concept of progressive meshes that are summarized next.</p><p>Progressive meshes have been introduced by Hoppe [14] to provide a continuous resolution representation of polygonal meshes. Progressive meshes are based upon two fundamental operators -edge collapse and its dual, the vertex split.</p><p>Merge trees have been introduced by Xia et al <ref type="bibr" target="#b26">[27]</ref> as a datastructure built upon progressive meshes to enable real-time view-dependent rendering of an object. Hoppe <ref type="bibr" target="#b14">[15]</ref> has developed a view-dependent simplification algorithm that works with progressive meshes. This algorithm proceeds to construct a vertex hierarchy over a progressive mesh in a top-down fashion by minimizing an energy function. Luebke and Erikson <ref type="bibr" target="#b18">[19]</ref> define a tight octree over the vertices of the given model to generate hierarchical view-dependent simplifications. Gueziec et al <ref type="bibr" target="#b12">[13]</ref> demonstrate a surface partition scheme for a progressive encoding scheme for surfaces in the form of a directed acyclic graph (DAG). Klein et al <ref type="bibr" target="#b15">[16]</ref> have developed an illumination-dependent refinement algorithm for multiresolution meshes. Schilling and Klein <ref type="bibr" target="#b23">[24]</ref> have introduced a refinement algorithm that is texture dependent. El-Sana et al <ref type="bibr" target="#b8">[9]</ref> have developed Skip Strip: a data-structure that efficiently maintains triangle strips during view-dependent rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">View-Dependence Trees</head><p>View-dependence tree <ref type="bibr" target="#b9">[10]</ref> is a compact multiresolution hierarchical data-structure that supports view-dependent rendering. In fact, for a given input dataset the view-dependence tree construction often leads to a forest (set of trees) since not all the nodes can be merged together to form one tree. Viewdependence trees are constructed bottom-up by recursively applying the vertex-pair collapse operation (see <ref type="figure">figure 2)</ref>. The order of the collapses is determined by a predefined simplification metric.  View-dependence trees are able to adapt to various levels of detail. Coarse details are associated with nodes that are close to the top of the tree (roots) and high details are associated with nodes that are close to the bottom of the tree (leaves). To be able to handle non-manifold cases, a more general scheme is used so that when a vertex split occurs more than two new adjacent triangles can be added that share the newly created edge (in the case of a manifold each edge is shared by no more than two triangles).</p><p>The reconstruction of a real-time adaptive mesh requires the determination of the list of vertices of this adaptive mesh and the list of triangles that connect these vertices. Following <ref type="bibr" target="#b9">[10]</ref>, we refer to these lists as the list of active nodes and the list of active triangles. At each frame the active nodes list is traversed to adapt to the appropriate level-of-detail representation of the given scene. <ref type="figure">Figure 3</ref> shows the split and merge operations in the view-dependent tree. The two active nodes AE and AE in <ref type="figure">Figure 3</ref>(a) merge to make the node AEÔ active (in <ref type="figure">Figure 3</ref>(b)). Note that CAT stands for Current Adjacent Triangles and PAT for Permanent Adjacent Triangles (see <ref type="bibr" target="#b9">[10]</ref> for more detail).</p><p>In order to prevent foldover at run-time view-dependence trees use an implicit dependencies instead of storing explicit dependencies lists (as in <ref type="bibr" target="#b26">[27]</ref> and <ref type="bibr" target="#b14">[15]</ref>). Hence, they reduce the memory space to store the dependencies and require only local accesses. Implicit dependencies rely on the enumeration of vertices generated after each collapse during the construction of the view-dependence trees. If the model has Ò vertices at the highest level of detail they are assigned vertex-ids ¼ ½ Ò ½. Every time a vertex pair is collapsed to generate a new vertex, the id of the new vertex is assigned to be one more than the greatest vertex-id thus far. This process is continued till the entire view-dependence trees have been constructed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Multi-User Interaction</head><p>Several distributed systems have been developed to take advantage of the computing capabilities of the Internet such as ATLAS <ref type="bibr" target="#b1">[2]</ref>, Charlotte <ref type="bibr" target="#b2">[3]</ref>, JavaParty <ref type="bibr" target="#b21">[22]</ref>, and Legion <ref type="bibr" target="#b16">[17]</ref>. These systems usually experiment with general-purpose applications while taking into account the characterization of current Internet access such as low bandwidth communication and high latency.</p><p>Experimental distributed systems have also been developed for real-time iteration in shared virtual environments. The WAVE system <ref type="bibr" target="#b22">[23]</ref> uses message managers to mediate communication between hosts. These message managers often manage to cull irrelevant messages. DEDICATED <ref type="bibr" target="#b10">[11]</ref> is a distributed heterogeneous multimedia learning environment based on device-independent architecture. VEOS <ref type="bibr" target="#b5">[6]</ref> is a distributed virtual environment which maintains consistency among all workstations by sending point-to-point messages. Anupam and Bajaj <ref type="bibr" target="#b0">[1]</ref> have developed the Shastra, an extensible and programmable system that supports large scale, geographically dispersed collaboration amongst multi-users environment. NPSNET <ref type="bibr" target="#b19">[20]</ref> uses a broadcast approach to maintain a large distributed battle field simulation over the Internet. Cspary <ref type="bibr" target="#b20">[21]</ref> developers focus on providing a small group of scientists the means of interactive collaboration and data sharing. The RING system <ref type="bibr" target="#b25">[26]</ref> manages large simulations by sending entity-state-change messages to one server who is responsible to redirect them to the users affected by the change. It has been used for visibility-based message culling during large simulations. DIVE <ref type="bibr" target="#b6">[7]</ref> is a fully distributed heterogeneous virtual reality system, where users can navigate and interact in 3D space.</p><p>Distributed multi-user virtual environment systems maintain consistency among the Ò workstation by sending messages to each other whenever any entity on the distributed environment changes its state. Various message exchange policies have been developed. Next we shall state some of these strategies The workstation hosts the changed entity sends point-topoint messages to the Ò ½ other workstations. This approach generates a large number of messages, where most of them are not necessary. Among the systems use this policy were Build For Two <ref type="bibr" target="#b3">[4]</ref> and VEOS <ref type="bibr" target="#b5">[6]</ref> The workstation broadcasts the change to all the workstation on the network. This approach reduces the number of sent messages, yet many workstations have to process unnecessary messages. NPSNET <ref type="bibr" target="#b19">[20]</ref>, and VERN <ref type="bibr" target="#b4">[5]</ref> have adopted this strategȳ Messages are sent to an intermediate server who is responsible to redirect them to the appropriate workstations.</p><p>The RING <ref type="bibr" target="#b25">[26]</ref> and WAVE <ref type="bibr" target="#b22">[23]</ref> systems have used similar policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Our Approach</head><p>Our approach provides a novel solution, which allows multiusers with inexpensive workstations to visualize large datasets. The users' workstations usually lack the memory size and the rendering capability to interact (at interactive rates) with the large dataset by themselves. Our algorithm is based on clientserver communication network and view-dependent rendering. In our current implementation, we assume that the large dataset resides in a local server, which has enough memory and computation power to store and handle the entire multiresolution representation. Our system consists of a server application which runs on the server machine and several client applications that run on the clients' inexpensive workstations. We shall refer to the server's application as server and to the client's application as client. Clients access the large dataset through the server machine without downloading the entire dataset into their local machines' memory because of memory size, consistency, or security reasons. Since many users access the same dataset in the same server concurrently, our approach also aims to reduce the load on the local network to avoid undesirable slowdown. Next we shall describe the architecture of our system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">System Architecture</head><p>In this section we shall review the architecture of our system, which is based on one server and multiple clients (note that several servers could be running on the same local network). Therefore, we shall review the architecture of the server and client independently, and then we explain the shared aspects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Server</head><p>The server consists of two main entities, a server manager and a set of interfaces. The server manager is the main process of the server. It sets the public communication channel, initializes the shared memory arena, and loads the view-dependence tree of the given dataset into the shared memory. The server manager also listens on the public channel for requests for connection by new clients.</p><p>For each calling client, the server creates an interface, which is responsible for the interaction with the calling client. Since the calling client and the created interface are associated with each other we shall refer to the calling client as the associate client and to the created interface as the associate interface. The interface stores the characteristic parameters of the associate client, maintains the active-nodes list of its associate client, and handles the client's view-parameters changes. On each change of the client's view-parameters, its associate interface updates the active-nodes list to adapt to a better representation of the viewed scene. The interface is also responsible for packing the merge/split operation and sending them with the proper additional information (such as new vertex coordinate and new triangles vertices) to its associate client.</p><p>In order to deliver the appropriate level of detail, the interface periodically checks the data channel for changes in the view parameters such as camera position, view direction, and illumination. Then based on the updated view-parameters, it scans the active-nodes list and tries to converge to the best visual appearance of the scene by increasing (merge operation) or decreasing (split operation) the resolution in various regions. After each update operation (split or merge) the interface packs the operation with the appropriate information and sends it to its associate client. Such approach leads to streaming the update operations to the client, which updates the graphics display on its convenient time (independent of the interface adapt loop).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Client</head><p>Clients should know the connection information of servers from whom they are interested to seek service. Since each server application handles one dataset, a client can access a server by its dataset name(in our current implementation servers are identified by the name of the dataset they handle). Clients maintain a list of vertices and a list of triangles, which are sent to the graphics hardware at each frame. Practically, these lists represent the appropriate level of detail of the visualized dataset with respect to view parameters of the client.</p><p>Nodes in the view-dependence trees are identified by their id-es, which are identical to their indices. However, the indices of nodes in the client's address space differ from that in the server's address space. Therefore, each client keeps a map to translate a given id to its appropriate index in the client's address space. Clients also watch changes in the view-parameters and send the updated view-parameters to the server, which updates its active-nodes list appropriately.</p><p>At each change of the view parameters on the client side, it sends these changes to its associate interface and updates the vertex and triangle lists according to the update operations it receives form its associate interface. In addition, it maintains immediate interaction with the user and sends the current level of detail to the graphics hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Client-Server Communication</head><p>In our current implementation we assume that the server and clients share a LAN network. Even though we believe that our system should work properly on a WAN network, we have not yet conducted any tests in this direction. The server manager listens on a public channel, on a non-blocking mode waiting for requests from new clients. The public channel is a simplex channel (single direction) open for write-only by clients and read-only by the server. Through this channel, the server expects to receive only fixed-size packets which include the characteristic parameters of clients. The data channel is a private channel shared only by one client and its associate interface. Since, the data channel is a full-duplex channel (two simultaneous directions) the client and its associate interface send and receive data over this channel. The client sends the view-parameter changes and receives a stream of update operations and the interface receives the view-parameters changes and generates the stream of the update operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Communication Messages</head><p>Since the server and any client run in two different machines, they relay messages to exchange information over the local network. They exchange various messages during the different phases of interaction. These messages appear in the connection diagram in <ref type="figure" target="#fig_4">Figure 5</ref>. Next we will briefly overview these messages.</p><p>Call-For-Connection message is sent by the client to the server through the public communication channel. This is a fixed-size message, which includes the client machine characteristics such as client-name, memory-size, average time to render ½Ã triangles, and minimum frame rates.</p><p>ACK-Connection message is sent by the server to the client approving the connection. It includes the viewdependence tree parameters such as the number of root nodes, the number of triangles at the top level, and the number of leaves of the view-dependence tree. This message contains essential information for the client to initialize its internal lists and data-structures.</p><p>Top-Level message is sent by an interface to its associate client to initialize the vertices and triangles lists. It includes the list of all the root nodes and the top-level triangles. Practically, this message includes the coarsest level of detail.  View-Parameters message is sent by a client to its associate interface to report changes in the view parameters such as camera position, view direction, and illumination.</p><p>Spilt/Merge message is sent by an interface to its associate client for each split or merge operation the interface executes. This message includes a stream of operation that allows the client to update its vertex and triangle lists to match the active-nodes list of its associate interface.</p><p>Disconnect message is sent by a client to indicate the end of a connection session. This message enables a clean release of the interface's resources.</p><p>It is important to note that we rely on the data-network layer, thus we assume that the connection is sequential and reliable (packets arrive free of error and duplication and in the correct sequence). However, the system maintains a time-out on the data channel to detect critical simple errors. For example, if the client does not receive update operations when it sends changes in the view parameters to the server, it reports a time-out error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Interaction Phases</head><p>The client uses the memory and computation power of the server to acquire the ability to visualize large datasets that exceeds its rendering capabilities. Since this process is done over a local network, it involves several different phases of interaction. Next we shall explain in detail these phases one by one.</p><p>Server Setup: In this phase the server loads the viewdependence tree of a given dataset and opens a public communication channel at which it listens for users' requests for connection. In our current implementation we assume that the given dataset has passed the preprocessing stage.</p><p>Connection Setup: The setup phase initiated by a client. It sends its machine parameters such as memory size and rendering capability to the server through the public communication channel. On receiving this message the server checks whether the calling client satisfies the minimum requirement to visualize the server's dataset. In case of a positive answer, the server approves the connection and creates an interface to handle the connection with the calling client. The interface then creates the data channel. From this point on the interface handles the entire interaction with the calling client. It is important to note that the interface has access permission to the shared memory where the view-dependence tree resides.</p><p>Initializing: This phase starts when the server and a client are ready to exchange data (messages). The interface initializes its active nodes list using the root-nodes list of the view-dependence trees. Then it sends the coarsest level of detail to its associate client. On receiving the root nodes and triangles, the associate client initializes its vertex list and its triangle list. It also initializes a mapping from the node id-es and triangles id-es to the their appropriate indices in the client lists.</p><p>Adapt Dialog: The client-server dialog enables the client to adapt to the best visual appearance of the scene with respect to its computation power, local memory, and rendering capabilities. The client sends its view parameters to the server's interface, which updates its active-nodes list to adapt to better representation of the given dataset according to the received view parameters (taking into account the hardware limitation of the client). During the adaptation process the server's interface sends to the client the added nodes and triangles, the removed nodes and triangles, and the changed triangles. These updates are sent to the client in a compact form of messages in order to reduce even more the load on the network.</p><p>Disconnection phase: This phase is initiated by the client by sending a disconnect message. On receiving this message, the associate interface releases its allocated resources, sends an acknowledge message to its associate client, and ends the interface session. Only then the client application can exit. It is important to note that the client and server could enter the disconnection phase if the data channel times out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Sharable View-Dependence Tree</head><p>In order to adopt view-dependence trees to a shared multiusers environment we have made two major changes. First we separate the active-nodes list from the view-dependence tree and eliminate the active-triangles list. Second, we reduce the split/merge restriction imposed by the implicit dependencies by localizing the view-dependence tree.</p><p>Recall that implicit dependencies <ref type="bibr" target="#b9">[10]</ref> have been developed to prevent foldover at runtime by carefully assigning id-es to the nodes of the view-dependence tree. In addition, we have found that they (the implicit dependencies) enable the separation of the active-nodes from the view-dependence tree. This separation is a vital point in our system architecture, since it enables multiple interfaces to have different active-nodes list and share the same view-dependent tree. In addition, we have implemented implicit dependencies by keeping two integers for each active node. These two integers keep the maximum id of adjacent nodes and the minimum id of the adjacent parent. We updated these two id-es after each collapse and merge opera-tion. At run time we need only to compare the id of the node with the two stored id-es.</p><p>Implicit dependencies are used to avoid foldovers at runtime by preventing the collapse or merge of nodes before others. Hence, these dependencies often restrict the refinement of nodes, which might have otherwise refined to comply with the visual fidelity or error metric. Note that this phenomenon exists also in the explicit dependencies lists. One way to reduce such restrictions could be achieved by reducing the dependencies between the nodes of the tree, which could be done by localizing the view-dependence tree. By localizing the tree we refer to minimizing the distance between the nodes of the tree.</p><p>To show how we localize a view-dependence tree let us first define the radius of a subtree as the maximum distance between the root of the subtree and any of its children. We are currently using the Euclidean distance metric to measure the distance between nodes. We have chosen to localize the view-dependence tree by minimizing the radius of each subtree. Since we construct the tree bottom-up, the algorithm starts by initializing each subtree radius to zero (each subtree has only one node). The effect of the collapse operation could be seen as a merge of two subtrees. Therefore, we collapse a node to the neighbor, which result in the minimum radius. It is important to note that our algorithm does not guarantee optimal radiuses for the final trees. In practice, it results in fairly acceptable small radiuses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Implementation Details</head><p>We have developed our system using C++ over the Unix/Linux operating systems. It runs on various machines such as PC, SUN, and SGI. We have used the FLTK <ref type="bibr" target="#b24">[25]</ref> library to design the graphics user interfaces. The communication channels are based on the Unix socket library.</p><p>As we have mentioned, the view-dependence tree resides in the shared memory arena of the server. Each interface has read-only access to the shared memory to maintain its activenodes list. The active-nodes list keeps a record for each active node which include a pointer to the actual node of the viewdependence tree, a list of id-es of its current adjacent triangles, and two integers to maintain the implicit dependencies.</p><p>Recall that on a view-dependence each triangle is stored only once, in the node which leads to its degeneration (actually, the node keeps the last non-degenerate form of the triangle). In contrast to previous implementations of view-dependence, we have found that we do not need to store the active-triangles list in the interface entity. They are implicit on the interface side but they have explicit representation on the client side. This approach reduces the memory required by the interfaces, which enables more clients to connect to the same server.</p><p>View-dependent rendering algorithms usually store (in local or external memory) the multiresolution hierarchy on the rendering machine. Instead, our approach keeps only the selected level of detail as a list of vertices and a list of triangles in the rendering machine (the client machine). Such technique usually provides more memory space which enables the selection of larger (more detailed) level-of-detail representation for large datasets. In addition, the display process and the adaptation process run completely in parallel since they live in two different machines. This parallelization enables faster response to various user events.</p><p>The client keeps a list of vertices and a list of triangles, which are sent to the graphics hardware at each frame. Instead of sending the whole vertex information with each triangle, we have adopted the idea of vertex-array of OpenGL. In the vertexarray approach, we send a list of vertices then we send a set of triangles represented by three indices in the vertex list. But sending the whole list of vertices has often led to a lot of thrashing as a result of the limited buffers of the graphics hardware. Therefore, we have decided to subdivide the set of vertices and set of triangles into several sub-sets. Each sub-set contains a list of vertices and the associated triangles (shared vertices are duplicated). At rendering time we send these subsets one by one. For each subset we send first the list of vertices in a vertexarray form, then we transmit the set of associate triangles to the graphics hardware. This approach reduces the cache miss and hence the thrashing phenomenon. It is clear that the size of these lists depends on the graphics hardware memory size and the weights of each vertex and triangle. We have found that a size of 64 vertices for each subset leads to a good performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Results</head><p>We have implemented our architecture in C++ as two separate executables, server and client. Then we conducted several tests on various datasets using our unoptimized implementation and have received encouraging results. The results we are reporting next were conducted on various machines using the same local network. We have used the network of our department, which is a 10 Megabit (per second) local network.Therefore, we shall report the specific configuration we have used for each table of results.</p><p>Since view-dependent rendering takes advantage of coherence between consecutive frames, it makes more sense to compare its performance over sequences of frames and not over one isolated frame. Therefore, all the results we are reporting in this paper were obtained using a sequence of frames.</p><p>In table 1 we report the average of number of split/merge operations, data sent over the data channel, number of triangles at each frame, and the average time for a frame. These results were obtained using the configuration: the server runs on an SGI ORIGIN 200 and the client runs on an SGI O2 with 96 MB. As can be seen from <ref type="table" target="#tab_1">Table 1</ref> we have achieved acceptable frame rate even for large datasets. In the same time the average amount of data transmitted at each frame is quite low.</p><p>We have also compared the performance of view-dependent rendering over a network (using our approach), local memory, and external memory <ref type="bibr" target="#b7">[8]</ref>. The external memory algorithm relies on smart prefetching from disk, while the local memory algorithm counts on the operating system in managing the memory (by swapping pages).</p><p>For each dataset we record a path which includes the camera parameters and illumination. Then, we compare the performance of the three algorithms over the same path for each dataset. Note that the camera parameters and illumination determine the selected level-of-detail (for the same simplification metric) and hence determine the set of rendered triangles (the quality of the resulting image). Therefore, to compare the performance of two view-dependent algorithms we use the same dataset and the same path, then compare the frame rates. One could also keep the frame rate constant and measure the quality of the resulting images. Since it is not easy to measure the quality of the images we chose to use the first approach. In table 2 we report some results by comparing the three algorithms. These results were achieved using the configuration: the server runs on an SGI ORIGIN 200 and the client runs on an SGI O2 with 80 MB. For the other two algorithms (external and local  We have found that for small models such as "Bunny" the local memory algorithm achieves the best frame rates and the network algorithm comes last. But, as the datasets grow larger, the network algorithm starts to catch up and achieves the best frame rates for large datasets. For small dataset the local memory algorithm runs locally and the external memory algorithm does not need to access the disk often but the network algorithm has to pay the network overhead. When the datasets grow larger the local-memory algorithm does a lot of swaps, the external memory takes advantage of smart prefetch, and the network algorithm needs only to maintain his display lists which are much smaller that the entire view dependence tree. The network algorithm has another advantage over the other two algorithms because the display and adapter processes run completely in parallel. Recall that the adaptation process, which selects the appropriate level of detail, runs on the server's machine and only the display process, which sends the vertex and triangle lists to the graphics hardware, runs on the client's machine. <ref type="figure">Figures 6, 7</ref>, and 8 show images generated by our system. The small window on the top-right corner of some images is the image seen by the user and the other window is the global view of the dataset. <ref type="figure">Figure 6</ref> shows the full resolution of Dragon dataset <ref type="figure">(Figure 6(a)</ref>), and two different clients interacting with the same Dragon model concurrently <ref type="figure">(Figure 6</ref>(a) and <ref type="figure">Figure 6</ref>(b)). Note that the view-dependence tree of the Dragon model resides on a different machine (the server). The dynamic changes in the model resolution allow view-dependent rendering at interactive rate (about 10-14 frames/second). <ref type="figure">Figure 7</ref> is the same as figure 6 for the Terrain dataset. <ref type="figure">Figure 8</ref> shows the most possible detailed image of the Terrain dataset using view-dependent rendering over a network <ref type="figure">(Figure 8(a)</ref>) and external memory view-dependent <ref type="figure">(Figure 8(b)</ref>). We were able to achieve more detailed representation on the networkbased algorithm because the client has more memory available to represent one level of detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion and Future Work</head><p>We have presented a novel approach for view-dependent rendering of large datasets on an inexpensive workstation. Our idea is based on a client-server architecture over a local network. The view-dependence tree (a compact multiresolution hierarchy that supports view-dependent rendering) resides in a local server. A client (runs on an inexpensive machine) establishes a connection with a server and sends its view-parameters to the server which provides it (the client) with the appropriate level-of-detail representation of the scene with respect to the sent view parameters.</p><p>We see the scope for future work in designing virtual environment application for hardware with limited memory size and rendering capabilities but still need to navigate through large datasets. Examples of these applications include (a) wireless head-mounted displays equipped with inexpensive computer and rely on a local server and (b) and large modeling firms in which several users with inexpensive machines interact with the large datasets. Current view-dependence tree does not support incremental changes. Therefore, the view-dependence tree is constructed, form scratch, after each change. The idea to perform changes in the tree locally could dramatically reduce the preprocessing time.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Server-Client network design.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Vertex-pair collapse and vertex split operations. The two nodes AE and AE merge to create the parent node AEÔ. ,d,e, f,g,h,i} SI The collapse and split operations on the viewdependent trees for the mesh inFigure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>View-dependent rendering over a client-server network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Major Messages over One Connection Session.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Run time over a sequence of frames for various datasets.</figDesc><table><row><cell>Dataset</cell><cell cols="2">Original</cell><cell></cell><cell></cell><cell></cell><cell>Average/frame</cell></row><row><cell></cell><cell cols="7">Vertices Triangles Triangles (K) Split/Merge (K) Memory(KB) Time(ms )</cell></row><row><cell>Bunny</cell><cell>36 K</cell><cell></cell><cell>69 K</cell><cell>40</cell><cell></cell><cell>1.6</cell><cell>70</cell><cell>75</cell></row><row><cell>DragonA</cell><cell>101 K</cell><cell></cell><cell>200 K</cell><cell>45</cell><cell></cell><cell>1.4</cell><cell>71</cell><cell>78</cell></row><row><cell>BallJoint</cell><cell>137 K</cell><cell cols="2">274 K</cell><cell>47</cell><cell></cell><cell>1.2</cell><cell>69</cell><cell>82</cell></row><row><cell>Buddha</cell><cell>145 K</cell><cell></cell><cell>293 K</cell><cell>60</cell><cell></cell><cell>1.8</cell><cell>76</cell><cell>80</cell></row><row><cell>DragonB</cell><cell>101 K</cell><cell></cell><cell>300 K</cell><cell>82</cell><cell></cell><cell>1.7</cell><cell>86</cell><cell>81</cell></row><row><cell>Terrain</cell><cell>262 K</cell><cell cols="2">522 K</cell><cell>76</cell><cell></cell><cell>1.9</cell><cell>110</cell><cell>78</cell></row><row><cell>Steve</cell><cell>272 K</cell><cell></cell><cell>739 K</cell><cell>60</cell><cell></cell><cell>2.2</cell><cell>120</cell><cell>85</cell></row><row><cell>David</cell><cell>588 K</cell><cell cols="2">1,172 K</cell><cell>70</cell><cell></cell><cell>2.3</cell><cell>130</cell><cell>96</cell></row><row><cell></cell><cell cols="2">Dataset</cell><cell cols="2">Original</cell><cell cols="3">Average Time(ms)/frame</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="5">Vertices Triangles Local Extern Network</cell></row><row><cell></cell><cell>Bunny</cell><cell></cell><cell>36 K</cell><cell>69 K</cell><cell>60</cell><cell>72</cell><cell>78</cell></row><row><cell></cell><cell cols="2">DragonA</cell><cell>101 K</cell><cell>200 K</cell><cell>68</cell><cell>83</cell><cell>84</cell></row><row><cell></cell><cell cols="2">BallJoint</cell><cell>137 K</cell><cell>274 K</cell><cell>76</cell><cell>88</cell><cell>86</cell></row><row><cell></cell><cell cols="2">Buddha</cell><cell>145 K</cell><cell>293 K</cell><cell>96</cell><cell>94</cell><cell>87</cell></row><row><cell></cell><cell cols="2">DragonB</cell><cell>101 K</cell><cell>300 K</cell><cell>120</cell><cell>101</cell><cell>90</cell></row><row><cell></cell><cell>Terrain</cell><cell></cell><cell>262 K</cell><cell>522 K</cell><cell>160</cell><cell>112</cell><cell>93</cell></row><row><cell></cell><cell>Steve</cell><cell></cell><cell>272 K</cell><cell>739 K</cell><cell>181</cell><cell>120</cell><cell>94</cell></row><row><cell></cell><cell>David</cell><cell></cell><cell>588 K</cell><cell>1,172 K</cell><cell>245</cell><cell>194</cell><cell>105</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Comparison of different view-dependent rendering algorithms.</figDesc><table /><note>memory) we have used the same SGI O2 with 80 MB (the client machine).</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Acknowledgements</head><p>We would like to acknowledge the Weiler Family Fund which helped in purchasing some of the equipment used in this project. We also would like to thank Cyberware and the Stanford Computer Graphics Laboratory for providing datasets. Cyberware has provided the Steve, David, Knee, and BallJoint models. The Stanford Computer Graphics Laboratory has provided the Bunny, Dragon, and Buddha models. We are grateful to the reviewers for their insightful comments which led to several improvements in the presentation of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Shastra: An architecture for development of collaborative applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Anupam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Intelligent and Cooperative Information Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="172" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Atlas: An infrastructure for global computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Baldeschwieler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Blumofe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh ACM SIGOPS European Workshop on System Support for Worldwide Applications</title>
		<meeting>the Seventh ACM SIGOPS European Workshop on System Support for Worldwide Applications</meeting>
		<imprint>
			<date type="published" when="1996-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Charlotte: metacomputing on the Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Baratloo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Karaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Kedem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wyckoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">In In Proceedings of the 9th Conference on Parallel and Distributed Computing Systems</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="2" to="12" />
		</imprint>
	</monogr>
	<note>International Society of Computers and Their Applications</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reality built for two: a virtual reality tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blanchard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Burgess</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Harvill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lanier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Oberman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Teitel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1990 Symposium on Interactive Graphics</title>
		<meeting>1990 Symposium on Interactive Graphics<address><addrLine>Snowbird Utah</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="35" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Networked virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Blau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Moshell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lisle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH Special Issue on 1992 Symposium on Interactive 3D Graphics</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="157" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The veos project. tech-report FJ-15</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bricken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Coco</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Seattle 98195,WA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Washington</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dive -a multi-user virtual reality system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Carlsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Hagsand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Virtual Reality Annual International Symposium</title>
		<meeting>the IEEE Virtual Reality Annual International Symposium</meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">External memory view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum</title>
		<imprint>
			<publisher>Eurographics Association and Blackwell Publishers Ltd</publisher>
			<date type="published" when="2000" />
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
	<note>page to appear</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Skip strips: Maintaining triangle strips for view-dependent rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Azanli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99 Proceedings</title>
		<imprint>
			<publisher>ACM/SIGGRAPH Press</publisher>
			<date type="published" when="1999-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generalized view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum</title>
		<imprint>
			<publisher>Eurographics Association and Blackwell Publishers Ltd</publisher>
			<date type="published" when="1999" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="83" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dedicatedlearning on networked multimedia platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Encarnacao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Tritsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hornung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization in Scientific Computing: Uses in University Education. IFIP WG3.2 Working Conference, volume A-48</title>
		<imprint>
			<date type="published" when="1993-07" />
			<biblScope unit="page" from="67" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast multiresolution surface meshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gatti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95 Proceedings</title>
		<editor>G. M. Nielson and D. Silver</editor>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Surface partitions for progressive transmission and display, and dynamic simplification of polygonal surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings VRML 98</title>
		<meeting>VRML 98<address><addrLine>Monterey, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIG-GRAPH &apos;96</title>
		<meeting>SIG-GRAPH &apos;96<address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH, ACM Press</publisher>
			<date type="published" when="1996-08-09" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;97 (Los Angeles, CA)</title>
		<meeting>SIGGRAPH &apos;97 (Los Angeles, CA)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="189" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Illumination dependent refinement of multiresolution meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schilling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straßer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Intl</title>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="page" from="680" to="687" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The core legion object model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Grimshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing</title>
		<meeting>the Fifth IEEE International Symposium on High Performance Distributed Computing</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Real-Time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings, Annual Conference Series</title>
		<editor>Holly Rushmeier</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;97</title>
		<meeting>SIGGRAPH &apos;97<address><addrLine>Los Angeles, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH, ACM Press</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="198" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Npsnet: A multi-player 3d virtual environment over the internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Macedonia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brutzmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zyda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Falby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Locke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIG-GRAPH Special Issue on 1995 Symposium on Interactive 3D Graphics</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="93" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Cspray: A collaborative scientific visualization application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wittenbrink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Multimedia Computing and Networking</title>
		<meeting>Multimedia Computing and Networking<address><addrLine>San Jose. California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Javaparty: Transparent remote objects in java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Philippsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1225" to="1242" />
			<date type="published" when="1997-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Making waves: On the design of architectures for low-end distributed virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Virtual Reality Annual International Symposium</title>
		<meeting>IEEE Virtual Reality Annual International Symposium</meeting>
		<imprint>
			<date type="published" when="1993-09" />
			<biblScope unit="page" from="443" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Graphics in/for digital libraries -rendering of multiresolution models with texture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schilling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="667" to="679" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Fltk 1.0.6</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Spitzak</surname></persName>
		</author>
		<ptr target="http://www.fltk.org" />
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Ring: A clientserver system for multi-user virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH Special Issue on 1995 Symposium on Interactive 3D Graphics</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="85" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Adaptive realtime level-of-detail-based rendering for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="page" from="171" to="183" />
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
