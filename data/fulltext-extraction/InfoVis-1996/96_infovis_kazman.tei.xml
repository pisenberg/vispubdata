<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rapid Prototyping of Information Visualizations Using VANISH OpenLook</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rick</forename><surname>Kazman</surname></persName>
							<email>mkazman@cgl.uwaterloo.ca</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Waterloo</orgName>
								<address>
									<settlement>Waterloo</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amulet</forename><surname>Motif</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Waterloo</orgName>
								<address>
									<settlement>Waterloo</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Postscript</forename><surname>Mesa</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Waterloo</orgName>
								<address>
									<settlement>Waterloo</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xforms</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Waterloo</orgName>
								<address>
									<settlement>Waterloo</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Rapid Prototyping of Information Visualizations Using VANISH OpenLook</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>.information visualization</term>
					<term>sofnvare tools</term>
					<term>visual programming languages RCSNode NetNode ClassNode WWWNode</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper discusses a software tool, called VANISH, which supports the rapid prototyping of interactive 2D and 3D information visualizations. VANISH supports rapid prototyping: through a special-purpose language tailored for visualizations; through a software architecture that insulates visualization-specific code from changes in both the domain being visualized and the presentation toolkit used; and through the reuse of visualization techniques between application domains. The generality of VANISH is established by showing how it is able to recreate a wide variety of &quot;standard&quot; visualization techniques. VANISH&apos;s support for prototyping is shown through an extended example, where we build a C++ class browser, exploring many visualization alternatives in the process.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Creating meaningful information visualizations is a difficult, programming-intensive task, typically involving many iterations and refinements before achieving a satisfying effect. It is generally accepted that ease of prototyping encourages interactive exploration of different implementation possibilities. Standard general-purpose programming languages, on the other hand, do not encourage prototyping. This is because the costs of making changes to a working program, or of completely scrapping an existing program in favor of a radically different approach are typically prohibitive and meet with substantial resistance from both programmers and managers. Prototyping languages, on the other hand, are typically tailored specifically to an application domain. They allow applications within that domain to be quickly created and modified, typically sacrificing efficiency or generality (or both) in the process. Prototyping languages and systems exist for many domains, but little work has been done thus far in the area of information visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Jeromy Carrihre</head><p>Nortel Ottawa, Ontario, Canada jayc@ nortel.ca</p><p>In an attempt to address this perceived gap, we have created VANISH (Visualizing And Navigating Information Structured Hierarchically). VANISH supports the rapid prototyping of interactive information visualizations in the following ways:</p><p>the VANISH Programming Language (VaPL) is a special-purpose visual language which allows a programmer to directly translate semantic attributes from the domain being visualized into visual attributes in some presentation toolkit;</p><p>VANISH's software architecture separates concerns in a layered fashion in such a way as to insulate VaPL code from changes in the presentation toolkit or the domain being visualized;</p><p>visualization mappings are written in a sufficiently generic way that they can be, and are, easily reused.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">System Description</head><p>VANISH is implemented in C++ and is structured as a layered system, where each layer is a coherent set of object classes. A brief description of the VANISH system will be presented here, but we encourage readers to refer to [5] for a more detailed description of the system's software architecture and language.</p><p>The software structure of VANISH emphasizes modifiability and portability. It does this by following the ArcNSlinky metamodel of user interface software [ 121.</p><p>The gross software decomposition is shown in <ref type="figure">Figure 1</ref>.</p><p>This model insulates the presentation layer (instantiated</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FOR COLOR PLATE SEE PAGE 118</head><p>here by OpenLook, Motif, Amulet, Mesa, PostScript and XForms) and the application layer (instantiated here by various classes for file systems, networks, RCS repositories and so on) from changes in the interaction dialogue, which is written in VaPL. The architecture similarly insulates the VaPL dialogue from changes in the underlying application or the presentation toolkit being used. This is accomplished through the use of two abstraction classes, called LPresentation (logical presentation) and BaseNode, as buffers between the layers.</p><p>In this way, VaPL code never directly references an application domain object or a presentation function. These are always referred to indirectly, through the auspices of the attributes and methods of the LPresentation and BaseNode classes. This has the effect of making visualizations written in VaPL highly reusable, as we shall demonstrate in Section 5, where we show an extended example of using VANISH for information visualization prototyping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Semantic Domains</head><p>The nature of the semantic domain to be visualized is not constrained by the VANISH system, beyond the requirements that it be organized as a collection of nodes, each of which has a set of pre-defined attributes and some calculable relationship with other nodes in the domain.</p><p>The BaseNode class provides a collection of functionality that allows the construction of hierarchies and the manipulation of node attributes in those hierarchies. The class includes a mechanism that allows cycles in structures to be broken, permitting the visualization of domains which are inherently structured as graphs (potentially losing some structural information).</p><p>To integrate a new semantic domain, a BaseNode subclass is created. This subclass has a method that implements the construction of the hierarchy. In this way the relationships between nodes, and the attributes of nodes in the domain may be computed at run-time if necessary. This is crucial if purely structural information, such as distance to the root of the tree, is to be visualized.</p><p>Semantic domains that have thus far been incorporated include Unix file systems, RCS version trees, C++ class hierarchies, local area networks and networks of World-Wide Web sites. The BaseNode subclasses for these domains were implemented in 1 to 2 hours each. There is also a subclass called RawNode that allows manipulation of a generic hierarchy in textual format.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">VaPL</head><p>VaNISH's Programming Language is an interpreted, visual, data-flow language similar in basic concept and appearance to Prograph <ref type="bibr">[3]</ref>. It is a Turing complete programming language, but has specialized facilities which simplify the creation of visualizations. Other visualization systems use visual languages, such as Khoros, AVS, or IBM's Data Explorer. Typically, these languages are not complete programming languages, but only exist to control the flow of data through a set of pre-packaged filters.</p><p>The central language construct is a mapping, so named to convey the primary goal of mapping attributes of nodes from the semantic domain to visual presentation characteristics. Visual attributes of nodes in a hierarchy (such as position, color, shape) are computed from the semantic attributes. Semantic attributes may reflect information which is inherent in the particular domain, or which is an artifact of the semantic hierarchy, such as whether a node is a leaf, the number of children of a node, and so on. A mapping, like a function in a textual language, may be provided with inputs and may produce outputs.</p><p>A mapping is composed of a set of cases, in a fixed enumeration. The order of the cases determines their order of execution. Each case is tried, in turn, until one succeeds, or until all cases fail. Each case is made up a set of nodes and arcs, in typical data-flow style. The characteristic that distinguishes VaPL from other visualization languages is that mappings execute in the context of a hierarchy node, as discussed in Section 4. The sole purpose of a mapping is to associate the semantic and structural properties of the node with the visual properties of the visualization. The traversal of the hierarchy is provided "for free" to the VaPL programmer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Presentation</head><p>To provide a general-purpose visual presentation facility, VANISH incorporates a presentation layer that abstracts away from platform-and toolkit-specific operations. This enhances portability as well as VANISH users from the details of the underlying graphics engine. There are two distinct aspects of the system that utilize the presentation layer: VANISH'S programming interface and its rendering window.</p><p>The actual transformation of the visual elements or attributes (computed by VaPL mappings) to presentation layer operations is performed by a "rendering" engine. This engine simply produces a graphical representation based on the computed visual attributes: direct calls to graphics primitives are not possible in VaPL.</p><p>1. Khoros' Cantata language is the exception here, being a complete programming language. interface development environment written in C++ that is portable across X11 and Windows NT. While the underlying VANISH functionality has not yet been ported to Windows NT, the Amulet toolkit would make this relatively painless. There are very few Unix-specific components in VANISH. Mesa is an OpenGL-like API for X11 that provides 2-and 3-dimensional graphics primitives. XForms is a toolkit for X11 that mimics the Forms library for SGI GL.</p><p>Both the VaPL editor and the visualizationlrendering window use VANISH'S abstract presentation layer. However, because each of these operates in a separate window, different presentation toolkits can be used for the programming interface and the rendering window, if desired. For example, a programmer might prefer to use a Motif interface for programming VaPL, but present the results of the visualization to an end user in a Mesa window or as a PostScript file. As another example, if we were to port VANISH to Windows NT, Amulet could be used for the VaPL editor and OpenGL could be used for presentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Re-implementation of Existing Visualization</head><p>In an effort to demonstrate the efficacy and generality of VANISH for the exploration of visualization techniques, several well-known techniques were re-implemented. These include two-dimensional trees, cone trees <ref type="formula">(</ref> , and the troop movements are specified as start and end latitude and longitude, number of troops and temperature. As this data is not inherently hierarchical, it may seem inappropriate to visualize it using VANISH which operates on hierarchical application domains. However, it is trivial to impose a hierarchy onto the data: make each troop movement (a pair of stadend locations) a hierarchy node, and associate temperatures and troop numbers with either the start or the end. Battles occur at these start/end points, so their data is included with the nodes. VaPL mappings are then written to transform:</p><p>The result is shown in <ref type="figure" target="#fig_0">Figure 2</ref>. The VaPL used to create this visualization are discussed below.</p><p>troop numbers into widths of lines joining nodes;</p><p>latitude and longitude into line start/end locations;</p><p>temperatures into line colors; and nodes representing battles into labelled rectangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Using VaPL for Prototyping Visualizations</head><p>While VaPL, as described above, is a general-purpose programming language with constructs for subprograms (mappings), logical branching, loops, and recursion, it is particularly well suited to the rapid prototyping of information visualizations for several reasons:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hierarchical context and operations</head><p>Mappings in VANISH are executed for each node in the current hierarchy and are always executed in the context of a hierarchy node. When a mapping is executed, a traversal of the hierarchy is performed, and the mapping executes for each ping has direct read and write access to the attributes of the current hierarchy node, through VaPL operations.</p><p>In this way, VaPL is specific to the domain of visualization without sacrificing language generality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Independence of mappings</head><p>Mappings serve to connect semantic (domain) attributes to visual attributes. Rather than writing a visualization as a tightly coupled set of mappings, we can make them loosely coupled, which enhances their reusability. This is because the effects of mappings may be cumulative. For example, one mapping might create an overall layout of the nodes in a hierarchy, another might color the nodes, while another might set the nodes' sizes. None of these mappings needs to know of the existence or operations of the others.</p><p>This point can be explained using an example. Consider a display in which mappings have produced a two-dimensional tree with labels to the right of the nodes. If one wished to move the labels beneath the nodes, the original mapping or mappings that were used need not need to be modified. One could, rather, create a new delta mapping and execute it after the original mapping, producing the required displacement of the labels. The programmer need only create the new mapping and specify the proper ordering of the mappings to produce the desired result. The old mapping is unaffected.</p><p>Hence, a typical way of programming in VaPL is to begin with a standard set of mappings and then to refine the visualization through a collection of delta mappings. The trail from initial to final product is preserved in code, and general purpose mappings remain general.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reuse of mappings</head><p>The mappings used to produce a visualization are not necessarily specific to a particular semantic set-line-colours</p><formula xml:id="formula_0">1 /3 (normal)</formula><p>domain. For example, a set of mappings producing a cone tree could just as easily be applied to a class hierarchy as a file system. Of course, refinements to the basic presentation typically will depend on the semantic domain and will incorporate domain-specific attributes, such as file size for a file system visualization, or whether a class is abstract or concrete for a class browser. However, these changes are relatively small delta mappings; the bulk of the VaPL code is reused.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interpreted, not compiled</head><p>Because VaPL is an interpreted visual language, it is impossible to create a syntactically invalid construct. The programmer is not allowed to connect nodes unless the connection is syntactically valid. In addition, semantic errors are discovered without the delay inherent in the edit-compile-run cycle.</p><p>Developing hand-crafted, single-use visualizations using traditional environments (such as C++ and OpenGL) makes prototyping iterations expensive, both because functionality in these environments is typically not organized into orthogonal mappinglike constructs, and because there is a compilation delay every time a change is made. This second point may not seem like a substantial objection, since compilation times are often short on modern computers. However, when one adds in the time wasted in fixing syntactic mistakes, the effect is a noticeable reluctance on the part of developers to continue to make incremental changes.</p><p>We wish to encourage these iterations in order to promote the exploration of visualizations. The interpreted nature of VaPL supports this goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>set-line-colours 2/3 (normal)</head><p>set-I ine-colours 3/3 (normal) Examples of VaPL mappings used to compute elements of the visualization of Napoleon's 1812 campaign are shown in <ref type="figure" target="#fig_1">Figure 3</ref>. The data for this visualization comprises a collection of nodes, each representing a stop along the march; each node has several attributes: the latitude and longitude of the stop, the temperature (in Farenheit) for the march ending at the stop, the number of troops on the march and the name of any significant battle that occurred at the stop. <ref type="figure" target="#fig_1">Figure 3</ref> shows (on the left) two of the three cases of the mapping used to compute the line colours. The first case computes the line colour when the temperature is greater than or equal to 40°F: the temperature attribute (temp) for the current node is retrieved and if it is less than 40, execution continues in the next case. The dashed line in the mapping is a synchronization and ensures that the relational operation is performed before the subtraction. If the temperature is greater than or equal to 40, execution continues in the current case: 32 is subtracted from the temperature, the result is divided by 63 (an arbitrary value) and this value is subtracted from 1 .O. The final result is used to set the line-colour-b and line-colour-g attributes (which must be reals between 0.0 and 1 .O). The line-colour-r attribute is set to 1 .O. The second case applies when the temperature is less than 40 but greater than or equal to 22. In this case the line colour components are set using a single operation and the the line style is set to "dashed". The third case is not shown, but is similar to the first.</p><p>The rightmost mapping in <ref type="figure" target="#fig_1">Figure 3</ref> is used to compute the x and y position of nodes. The mapping retrieves the maximum and minimum latitude and longitude by calling another mapping, retrieves the current node's latitude and longitude, normalizes them (with scaling factors) and sets the x and y attributes (with small offsets). Other mappings (not shown) are used to compute label positions and to set attributes for the rectangles at the significant battle sites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">An Extended Prototyping Example</head><p>Part of the power of VANISH is the power of all rapid prototyping systems: it encourages exploration of visual alternatives because the cost of making changes and experimenting with different visualization alternatives is small. To make this point more concretely, we will recount our initial attempts at prototyping a C++ class browser. This example illustrates the wide variety of visualizations that VaPL supports and the ease with which different visualization techniques can be prototyped.</p><p>In this example, we wanted to visualize a library of approximately 300 C++ classes that implement a splines rendering and manipulation package. Our objective in the visualization was straight-forward: to allow a user to easily learn the class hierarchy and find particular classes. In addition, we wanted to provide a unified browsing/editing environment. One constraint included in this exercise is the restriction that the size of the window in which the hierarchy is rendered is fixed at 500 by 500 pixels. The figures below include only the portion of that region that was actually used by the visualization technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">A Standard 2D Tree</head><p>We began by visualizing the entire hierarchy as a conventional 2D tree ( <ref type="figure" target="#fig_2">Figure 5)</ref>, with the root at the top and the children of a node below their parent.  There were some obvious problems with this presentation. It makes poor use of screen real-estate, since the nodes must fit within the horizontal resolution of the display. When the tree is scaled to fit within the window, the node labels, even when shown using an 8 point font (which was virtually unreadable by the older of the two authors of this paper) occluded each other heavily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">A Rotated 2D Tree</head><p>An obvious solution to this problem was to rotate the tree so that the root was on the left, and the children of a node were to the right of that node. Since English reads left to right, this meant that adjacent nodes no longer occluded each other. To make this change in VANISH, the x and y coordinates were reversed and the relative position of a label with respect to its node was modified.</p><p>This solution, while an improvement in terms of both occlusion and usage of screen space, still resulted in vertical overlap (as seen in <ref type="figure">Figure 6</ref>). There simply was not enough vertical resolution in the rendering window.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">A Scrolled, Rotated 2D Tree</head><p>The obvious solution to this problem was to not scale the tree to fit within the rendering window. The node labels were fixed at a 10 point font, and the rendering area was turned into a scrolling window (not shown).</p><p>Making this change simply involved recomputing the unscaled coordinates, enabling a particular node shape (the boxes), setting the font size and defining the node colours.</p><p>SPasteDomDAC <ref type="figure">Figure 6</ref>: A Rotated 2D Tree.</p><p>Now, scrolling introduces its own problems and these were immediately manifested with this version of the prototype. A user could now view a part of the class hierarchy at an appropriate resolution, but lost a sense context within the overall class hierarchy. This meant that a user would now spend more time scrolling around the hierarchy, trying to understand the big picture, or searching for a desired class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">A 2D Orthogonal View of a Cone Tree</head><p>At this point we decided to change direction and try a different visualization technique, that of a 2D orthogonal cone tree <ref type="figure">(Figure 7)</ref>. In this technique, the hierarchy was laid out as a cone tree viewed from above, laid out so that no node obscures any other node [ 2 ] .</p><p>As we had available a set of mappings for computation of such a cone tree, making this change was simply a matter of loading and running the mappings.</p><p>While this solution allowed us to make better use of available screen space, placing the children of a node along the perimeter of a circle around the parent meant that there was a significant amount of overlap in the labels. Roughly three-quarters of the labels in the tree were unreadable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Adding Navigation to a 2D Cone Tree</head><p>We next considered that it might be unreasonable to expect to represent 300 class nodes in a single window, with the constraint that every node is easily readable.</p><p>Another possibility is to only show part of the tree at any one time (the selected node and its children) and to allow the user to "navigate" around the tree. In this visualization technique, when a new node is selected its children are expanded, and the siblings of the selected node are collapsed back into the parent node. In this way we only need to visualize the area surrounding the user's current focus, and the trail of "parents" leading to the currently selected node.</p><p>SVor <ref type="figure">Figure 7</ref>: A 2D Orthogonal View of a Cone Tree.</p><p>This solution (not shown) once again brought its own, unique problems. Although the tree now fit easily on the screen, the user loses a sense of context, by only being able to view the children and direct ancestors of the current node. In particular, this display gave no indication of which children themselves contained child nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Using Node Shape</head><p>To alleviate this problem, we modified the above technique slightly: we used node shape to indicate whether a node had children or not. Nodes with children were represented as triangles while leaf nodes were represented as squares <ref type="figure" target="#fig_3">(Figure 8</ref>).</p><p>However, this only gave us a binary distinction between nodes: children versus no children. It did not tell us where the child hierarchy was deep and where it was shallow. This sort of information, which was immediately obvious from any of the previous tree visualizations, was lost in the current version. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">3D Cone Tree</head><p>Continuing the theme of the previous prototype, we decided to put more of the burden on the human perceptual system. We visualized the class hierarchy as a 3D cone tree <ref type="figure" target="#fig_4">(Figure 9</ref>), and relied on depth perception and the natural scaling that depth perception implies as a way of organizing the tree. Once again, however, we were frustrated by the limits of screen resolution. Most of the node labels in the cone tree were unreadable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8">Fish-eye View of a 2D Cone Tree</head><p>Finally, we came to another technique that has been widely used to balance the competing requirements of maintaining context and maximizing resolution: a fisheye view <ref type="bibr">[lo]</ref>. We applied an adapted fish-eye view to the 2D orthogonal cone tree of <ref type="figure">Figure 7</ref>.</p><p>In this visualization <ref type="figure">(Figure lo)</ref>, nodes are scaled according to how recently they were the user's currently selected focus (unlike a standard graphical fisheye, in which a node is sized according to its distance from the focus). That is, the current focus is largest, the previous focus the second largest, and so on. In this way, we are able to visualize the entire tree, maximize resolution at the user's current focus, and provide gracefully degrading resolution as we move away from the focus. <ref type="figure">Figure 10</ref>: A Fish-eye View of a 2D Cone Tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SDisp SDisplayLi</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.9">Notes and Observations</head><p>In each of these prototypes, the user was able to start their favorite editor by clicking on a node with the left mouse button. This was accomplished through a standard callback mechanism that VANISH supports. Which technique is best? This depends on the size of the class hierarchy being visualized, the user's requirements and perceptual abilities, and the user's familiarity with the hierarchy. For us, the fish-eye view of a 2D cone tree was an effective balance of the competing requirements.</p><p>We are not claiming to have to discovered the best mechanism for visualizing class hierarchies; rather, we are demonstrating the efficacy of VANISH for exploring the possibilities for visualizing this domain. Further refinements to this visualization could include disabling node labels for nodes more than 2 or 3 links from the focus, decreasing font size as distance to the focus increases, andlor altering the fish-eye algorithm to provide a more symmetric layout. Also, more information about the domain could be provided visually (via node shape or colour, for example), such as indicating which classes are abstract and which are concrete.</p><p>These 8 prototypes were created in a total of about 2 hours. A substantial part of this time was not spent programming, but discussing the nature of the problems with the current version and deciding on the next iteration.</p><p>It may be argued that this example was only quick and easy because we already had many existing mappings which we could draw upon. This objection is, however, an argument for the strengths of VaPL, particularly in its support for reuse. The fact that we were able to easily reuse a large variety of mappings which had not been written with C++ class browsing in mind argues in favor of the efficacy of the approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions and Future Work</head><p>Future work with VANISH is proceeding in several directions. The system is currently well suited to producing prototypes to establish the effectiveness of visualization techniques. Like all interpreted prototyping languages, its performance is roughly an order of magnitude worse than an equivalent compiled system.</p><p>In a "production" environment, where interactive performance is of more importance, one would likely want to replace the interpreted VANISH environment with a compiled version of the application. Currently, such an application would need to be developed from scratch (based on the work done with VANISH) typically in a standard procedural language such as C or C++. However, a simpler and more economical solution is to have VANISH generate the C++ code that replicates the VaPL mappings. This avenue is currently being investigated.</p><p>A second direction for continued work will explore the possibilities for a more general user interface. In the current model, interaction with a visualization is implemented through VaPL callbacks from mouse clicks on hierarchy nodes, and through slider callbacks.</p><p>Any callback can alter the presentation and cause it to be re-displayed. Currently, however, there are a small, fixed number of such interactors in VaPL's user interface, and their presentation is fixed. While this user interface has sufficed for our development use, it is clearly unacceptable for building general purpose interactive visualizations.</p><p>A generalized interface would allow an external "control panel" of arbitrary complexity, designed separately, to trigger VaPL callbacks registered for user-defined events. Thus we are designing a messaging scheme which will allow an external application to send and receive events from VANISH. In this way, a user interface could be developed using one's normal user interface development environment, and then this interface could be linked with an arbitrary VANISH application.</p><p>Our experience in prototyping visualizations with VAN-ISH, while positive, has been limited to anecdotal accounts such as those presented here. Another avenue of future work is to perform controlled studies of user productivity, comparing VANISH with other visualization systems, to be able to (hopefully) make a more compelling argument for the use of VANISH.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>BORISOVFigure 2</head><label>2</label><figDesc>: A VANISH Implementation of a Visualization of Napoleon's 1812 Campaign. Currently, several concrete presentation classes exist. These include instances for OpenLook, Motif, Amulet, Mesa, PostScript and XForms. Amulet [6] is a user</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>VaPL mappings to compute visual attributes for Napoleon visualization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>A Standard 2D Tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 :</head><label>8</label><figDesc>Node Shape with Navigation in a 2D Cone Tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 9 :</head><label>9</label><figDesc>A 3D Cone Tree.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="0">-8186-7668-X/96 $5.00 0 1996 IEEE</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">IVEE: An Information Visualization &amp; Exploration Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ahlberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wistrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Information Visualization &apos;95</title>
		<meeting>of Information Visualization &apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="66" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interacting with Huge Hierarchies: Beyond Cone Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Carrikre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Information Visualization &apos;95</title>
		<meeting>of Information Visualization &apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="74" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Prograph: A Step Towards Liberating Programming from Textual Conditioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Giles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pietrzykowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Workshop on Visual Languages</title>
		<imprint>
			<biblScope unit="page" from="150" to="155" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tree-Maps: A Space-Filling Approach to the Visualization of Hierarchical Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Adaptable Software Architecture for Rapidly Creating Information Visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Carrikre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kosbie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Graphics Inte$ace &apos;96</title>
		<meeting>of Graphics Inte$ace &apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="260" to="267" />
		</imprint>
	</monogr>
	<note>Proc. of CHI &apos;96</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Integrated Visual Language and Software Development Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Visual Languages and Computing</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="217" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Cone Trees: Animated 3D Visualizations of Hierarchical Information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CHI&apos;91</title>
		<meeting>of CHI&apos;91</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="189" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive Graphic Design Using Automatic Presentation Knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kolojejchick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mattis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">; M</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Brown ; E</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tufte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Visual Display of Quantitative Information</title>
		<meeting><address><addrLine>Cheshire, CT</addrLine></address></meeting>
		<imprint>
			<publisher>Graphic Press</publisher>
			<date type="published" when="1983" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="32" to="37" />
		</imprint>
	</monogr>
	<note>A Metamodel for the Runtime Architecture of an Interactive System</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="73" to="84" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m">Rapid Prototyping of Information Visualizations using VANISH</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
