<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Integrating Visualization Techniques for Effective Software Exploration</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Simon Fraser University University of Victoria Burnaby</orgName>
								<address>
									<addrLine>Canada Victoria</addrLine>
									<region>BC, BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">D</forename><surname>Fracchia</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Simon Fraser University University of Victoria Burnaby</orgName>
								<address>
									<addrLine>Canada Victoria</addrLine>
									<region>BC, BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On Integrating Visualization Techniques for Effective Software Exploration</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.5.1 [Information Interfaces and Retrieval]: Multimedia Information Systems-Hypertext-navigation and maps; H.5.1 [Information Interfaces and Retrieval]: User Interfaces-Evaluation/methodology Nested graphs</term>
					<term>pan and zoom</term>
					<term>fisheye views</term>
					<term>hypertext</term>
					<term>mental map</term>
					<term>software visualization</term>
					<term>program understanding</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper describes the SHriMP visualization technique for seamlessly exploring software structure and browsing source code, with a focus on effectively assisting hybrid program comprehension strategies. The technique integrates both pan+zoom and fisheye-view visualization approaches for exploring a nested graph view of software structure. The fisheye-view approach handles multiple focal points, which are necessary when examining several subsystems and their mutual interconnections. Source code is presented by embedding code fragments within the nodes of the nested graph. Finer connections among these fragments are represented by a network that is navigated using a hypertext link-following metaphor. SHriMP combines this hypertext metaphor with animated panning and zooming motions over the nested graph to provide continuous orientation and contextual cues for the user. The SHriMP tool is currently being evaluated in several user studies. Observations of users performing program understanding tasks with the tool are discussed.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Understanding a software system is often a difficult process because of missing, inconsistent, or even too much information. Software visualizations are often provided in an effort to ease understanding <ref type="bibr" target="#b16">[17]</ref>. Some visualization tools show animations of algorithms and data structures, often for educational purposes. Others show the run-time behavior of a program to aid debugging, testing, or performance optimization tasks. Some tools focus on "pretty printing" listings of the source code to increase readability and understanding. Another class of tools, the subject of this paper, presents views of static structures in the software linked to textual source code views to enhance program understanding during software maintenance.</p><p>In many maintenance situations, program code may be the only source of reliable information. Higher-level, structural information may be recovered from the code using various reverse engineering approaches <ref type="bibr" target="#b3">[4]</ref>. Effectively structuring this information for future exploration is critical to program understanding <ref type="bibr" target="#b29">[30]</ref>. Unfortunately, it is not always clear how to visually present this higher-level information for subsequent navigation and analysis to enhance understanding.</p><p>Many researchers have conducted experiments to observe how programmers explore program information. This research has resulted in several cognitive theories to describe the program comprehension process. Some theories propose that programs are understood "top-down", by reconstructing knowledge about the application domain and mapping that to the low-level source code <ref type="bibr" target="#b1">[2]</ref>. Other theories suggest that understanding is built "bottom-up", by reading source code and then mentally chunking the statements into higher-level abstractions. These abstractions are grouped until a high-level understanding of the program is attained <ref type="bibr" target="#b21">[22]</ref>. More recent studies show that programmers use a hybrid approach and frequently switch between various comprehension strategies <ref type="bibr" target="#b30">[31]</ref>.</p><p>The diversity of these cognitive models is is not surprising, when one considers the varied characteristics of maintainers, programs to be understood, and the goals driving the comprehension tasks <ref type="bibr" target="#b27">[28]</ref>. Nevertheless, all the cognitive models agree that understanding is achieved by exploring program information, such as code or documentation, and assimilating that information into existing knowledge about the program. For many programmers, the source code of the software system is the most trusted form of documentation. Many software visualization tools provide access to the code, but in many cases the program code is not well integrated with higher-level architectural views. According to the integrated model of comprehension <ref type="bibr" target="#b30">[31]</ref>, programmers frequently switch between top-down and bottom-up approaches. Therefore, a programmer should be able to rapidly switch between a high-level view of the software and lower-level source code as they strive to understand the program. Hence, to effectively aid program comprehension, a tool must support a wide variety of comprehension strategies through its visualization and navigation approaches.</p><p>For software exploration, graphs are often used for representing and documenting software structures where nodes in the graph correspond to software artifacts such as functions, data types, and subsystems, and directed arcs correspond to function calls, data dependencies, and containment relationships. However, as the complexity of software systems increase, so too do their presentations as graphs. The useful information conveyed by these graphs can be increased through a variety of techniques. Filtering non-essential nodes and arcs can reduce the amount of visual clutter and consequently improve the readability of the graph. Graph abstraction reduces complexity by collapsing subgraphs of related nodes and arcs into single nodes. The layout of a graph (the relative sizes and positions of nodes and arcs) also strongly affects readability.</p><p>Additional techniques are needed to help programmers visual-ize and explore the larger, more complex graphs typical of legacy software systems. Some tools use a multiple window approach, where each window displays a portion of the graph. Other tools use a pan+zoom metaphor for browsing the graph at various levels of detail. Some visualization tools employ a fisheye-view or con-text+detail approach, where critical information is displayed larger than less relevant information. All of these techniques have been applied to the task of visualizing software <ref type="bibr" target="#b24">[25]</ref>. For exploring software, the Simple Hierarchical Multi-Perspective (SHriMP) visualization technique proposes that an integrated approach which combines both pan+zoom and fisheye-view approaches is preferable for supporting a variety of comprehension strategies. Filtering, abstraction, and layout algorithms are also used to better convey important structural information in the graph. Nested graphs display hierarchical structures such as containment relationships and graph abstractions. For example, related software artifacts may be collapsed into a single subsystem node, with nesting to show a containment relationship between this node and the original artifacts.</p><p>Moreover in SHriMP, the source code is directly accessible and tightly integrated within the visual presentation. A programmer can browse the code by magnifying a node of interest until the corresponding code is visible within the node. This approach presents the detailed code simultaneously within the additional context of the overall, structural diagram. The program code can be further explored by following hypertext links in the code or by navigating within the diagram using various pan+zoom techniques.</p><p>The rest of this paper is organized as follows. Section 2 briefly reviews techniques for visually presenting complex information spaces and discusses their suitability for visualizing static software structures. Section 3 describes the extended interface for SHriMP, an integrated visualization technique applied to exploring software structures and browsing source code. Section 4 highlights important issues addressed by this visualization technique and outlines areas for future research. The final section concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Dealing with Large Graphs</head><p>This section discusses the suitability of several techniques for representing graphs of large, complex software systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Multiple Views</head><p>For a large software system, the corresponding graph may contain many thousands of nodes and arcs. Some tools partition the graph into pieces and display each piece in a separate window <ref type="bibr" target="#b24">[25]</ref>. These windows may be cascaded or arranged so that the user can selectively choose which part of the graph to examine further. Frequently, an overview or map is provided to show a less detailed, global view of the entire graph. For many applications, this multiple view approach is less than satisfactory since the user has the difficult task of accurately conceptualizing and integrating the implicit relationships among the contents of the individual windows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Single View: Pan+Zoom</head><p>Several approachesdisplay large graphs using a single, unified view. In a pan+zoom view, the user may pan the view using scroll bars or by dragging the mouse over the view. Also, the user may explore the graph in varying detail by zooming in (enlarging) or zooming out (shrinking) the view. Pad++ <ref type="bibr" target="#b0">[1]</ref> uses highly optimized graphics to achieve smooth panning and zooming, making out-of-view parts of the graph quickly accessible. A pan+zoom web browser was recently developed within Pad++ <ref type="bibr" target="#b6">[7]</ref>. One problem with the pan+zoom technique is that a user can only enlarge one area of interest at a time in a given view. For program understanding, it is often necessary to look at several disjoint parts of the software in detail at the same time, since the code relating to a particular algorithm is often fragmented <ref type="bibr" target="#b22">[23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Single View: Context+Detail</head><p>Several approaches have been devised to present detailed information while also providing the user with important contextual cues. The term fisheye view, coined by Furnas <ref type="bibr" target="#b9">[10]</ref>, is commonly used to describe views that simultaneously display both context and detail. A fisheye lens has the distorting optical effect that objects closer to the center of the view appear increasingly larger. Furnas' original technique applied a degree of interest function to two measures for each object: its a priori relevance to the user and its distance from a focal point. When applied, this function produces a set of priority values. Objects with priorities below a certain threshold are filtered from the view. Furnas applied these ideas to display program source code and to display calendars.</p><p>The Treemap <ref type="bibr" target="#b12">[13]</ref>, Interactive Graph Layout <ref type="bibr" target="#b11">[12]</ref> and Layout Independent Fisheye View <ref type="bibr" target="#b14">[15]</ref> systems use a static, context+detail display technique. There is no stability in the graph layouts generated by these systems. A reissued layout might change dramatically due to a small change in requested node sizes. For software visualization, the graph layout is often designed to assist the programmer in building a mental map of the program. Drastically changing the whole layout due to a change of focus would disturb the programmer's mental map.</p><p>Dynamic context+detail display techniques allow the user to change the area(s) of interest interactively and incrementally. For example, SemNet was developed for exploring and modifying large information spaces <ref type="bibr" target="#b7">[8]</ref>. SemNet uses three-point perspective to create 3-D fisheye views. An advantage of 3-D drawing is that the view can be rotated until arcs of interest do not overlap. However, these graph displays tend to be cluttered and unfortunately impede the understanding of the structure <ref type="bibr" target="#b18">[19]</ref>.</p><p>Sarkar and Brown extended Furnas' technique to create interactive fisheye views of graphs <ref type="bibr" target="#b20">[21]</ref>. Points of greater interest are magnified and points of lesser interest are demagnified by distorting the space around the focal point. Nodes further away from the focal point appear increasingly smaller. For software visualization, however, this use of distance to derive interest or importance may not be entirely suitable. A related, more sophisticated approach (3DPS) is described in <ref type="bibr" target="#b2">[3]</ref>.</p><p>The Continuous Zoom algorithm by Dill et al. <ref type="bibr" target="#b5">[6]</ref>, is suitable for interactively displaying hierarchically-organized, two-dimensional networks. This approach allows users to view and navigate nested graphs by expanding and shrinking nodes. The underlying algorithm uniformly resizes nodes to provide space for focal points and uses a budgeting process to distribute space among the nodes in the network. However, this algorithm adversely distorts certain layouts useful for visualizing software structures, such as spring <ref type="bibr" target="#b8">[9]</ref> and tree <ref type="bibr" target="#b17">[18]</ref> layouts. The SHriMP fisheye algorithm, first presented in <ref type="bibr" target="#b25">[26]</ref>, can adjust an existing layout while preserving various constraints.</p><p>The next section describes the SHriMP technique, which integrates pan+zoom and context+detail approaches for browsing nested graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SHriMP</head><p>This section presents some background on the implementation of the SHriMP visualization technique and describes its user interface features for navigating and browsing software. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Nested graphs</head><p>The SHriMP visualization technique employs a nested-graph formalism <ref type="bibr" target="#b10">[11]</ref> to present the structure of a software system. A nested graph has composite nodes that contain other nodes, thus forming a hierarchical structure. These composite nodes typically represent software subsystems (perhaps discovered during reverse engineering). In a nested graph, a composite arc represents one or more arcs between lower-level nodes in the hierarchy. Composite arcs can be selected and opened to display the lower-level, constituent arcs they represent. <ref type="figure" target="#fig_0">Figure 1</ref> shows a series of views at various levels of detail in a C program that implements a Hangman game. In <ref type="figure" target="#fig_0">Fig. 1(a)</ref>, a single node is displayed. This node is an abstract representation of the entire Hangman program. In <ref type="figure" target="#fig_0">Fig. 1(b)</ref>, this node is opened to reveal the next level in the software hierarchy. Further detail is exposed by opening additional nodes in <ref type="figure" target="#fig_0">Fig. 1(c)</ref>.</p><p>Composite nodes are drawn in grey and have a sunken or raised effect to indicate if they are open or closed, respectively. Leaf nodes are colored according to the type of software artifact represented (e.g., functions (blue), data types (orange), variables (green) and files (pink)). A node may be manually positioned in the canvas, constrained by the boundaries of its parent node. Automatic layout algorithms can alternatively be applied to each of the subgraphs, including: grid (nodes are positioned in a rectangular matrix), spring <ref type="bibr" target="#b8">[9]</ref>, tree <ref type="bibr" target="#b17">[18]</ref>, and Sugiyama <ref type="bibr" target="#b28">[29]</ref> (see <ref type="figure">Fig. 2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Magnifying nodes of interest</head><p>SHriMP integrates context+detail and pan+zoom approaches for magnifying nodes of interest. The context+detail approach uses the SHriMP fisheye-view algorithm <ref type="bibr" target="#b25">[26]</ref>, which preserves constraints such as orthogonality and proximity among nodes as they are individually resized. The SHriMP fisheye view algorithm is unique in that it supports various layout adjustment strategies for nested graphs so that a distorted graph will preserve specific constraints and thus the user's mental map of the original layout <ref type="bibr" target="#b13">[14]</ref> (see <ref type="figure">Fig. 2)</ref>. <ref type="figure">Figure 3</ref>(a) shows how the GamePlay subsystem is magnified in the Hangman program by concurrently shrinking the rest of the graph to allocate more space to the GamePlay node. Several nodes of interest can be selected and magnified by shrinking the remainder of the graph to allocate more space to these nodes.</p><p>The pan+zoom approach allows the user to pan and zoom around a single view. To show more detail for a node of interest, the user selects the node and zooms in until the required level of detail is visible. <ref type="figure">Figure 3(b)</ref> shows the GamePlay subsystem after zooming in until the node fills the available screen area.</p><p>The SHriMP fisheye-view approach has the advantage of showing both context and detail, but depending on the given task and required information, contextual cues may not always be needed. The pan+zoom approach, however, only supports one focal point. A programmer often needs to browse several interacting subsystems concurrently in a single view. Here, the SHriMP fisheye-view approach would be more suitable for magnifying several focal points.</p><p>A user browsing a software hierarchy might combine these two approaches to magnify nodes of interest. For example, in <ref type="figure">Fig. 3(b)</ref> the GamePlay subsystem node is magnified by zooming in (without context) but three of its children nodes are sized larger than their siblings using the SHriMP fisheye algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Browsing source code</head><p>With SHriMP, the user can easily access the source code for a program. Each leaf node directly corresponds to a chunk of code in the program. A user can browse this code using any of three methods. In the first method, a separate text editor window may be opened to display the corresponding source file and code for a selected node. The other two methods represent the code as hypertext <ref type="bibr" target="#b4">[5]</ref> with function calls, data type references, and variable references represented as hyperlinks. The second method uses the user's preferred web browser, such as Netscape Navigator, for exploring the hypertext code. The third method embeds the hypertext code inside the nodes so that the source code can then be browsed within the context of the software structure view.</p><p>In addition to embedding the code inside nodes, SHriMP integrates the hypertext link-following metaphor (at the code level) with animated panning and zooming motions over the nested graph (at the structural level). Consequently, following a link to another function pans and zooms the view so that this function's code is presented within its node. By seamlessly combining code and structural browsing, the SHriMP interface supports and encourages switching among various comprehension strategies. The hyperlinks also provide complementary pathways for navigation beyond following the nested graph structure. are visible in <ref type="figure" target="#fig_2">Fig. 4(b)</ref>. This intermediate step is important to avoid disorienting the user as the view is panned and zoomed from one node to another. SHriMP then animates the view so that the code for endgame is fully visible, as in <ref type="figure" target="#fig_2">Fig. 4(c)</ref>. To see the code more clearly, the user can fully zoom the endgame node as shown in <ref type="figure" target="#fig_2">Fig. 4(d)</ref>. Displaying the code inside the nodes and animating the view as the focus is changedshould reduce lost in space effects often encountered by programmers when browsing the code of complex software systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Implementation</head><p>The first prototype of the SHriMP interface <ref type="bibr" target="#b23">[24]</ref> was implemented in Tcl/Tk <ref type="bibr" target="#b15">[16]</ref>. Tcl/Tk is a scripting language and user interface library useful for rapidly prototyping graphical interfaces. However, its graphics capabilities are not optimized for efficiently displaying the large graphs typical of software systems. The second prototype has been implemented using Pad++ <ref type="bibr" target="#b0">[1]</ref>, a graphics extension for Tcl/Tk. Pad++ is a substrate for building multiscale, dynamic user interfaces. Also, Pad++ is highly optimized for efficiently displaying large numbers of objects and smoothly animating the motions of panning and zooming. For SHriMP, the nested graph views and fisheye-view algorithm are implemented in Tcl/Tk using the Pad++ widgets. Pad++ also supports HTML items in its canvas. This feature was used to display source code inside the nodes. The Pad++ panning and zooming features are used extensively in SHriMP.</p><p>Two user studies have been conducted to evaluate the strengths and weaknesses of the SHriMP interface. Some pertinent observations from these studies are discussed next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>The SHriMP technique was developed as an alternative visualization method for Rigi, a tool for reverse engineering developed at the University of Victoria <ref type="bibr" target="#b23">[24]</ref>. Rigi displays software hierarchies as graphs using a multiple window approach. We are currently conducting some user experiments to compare the SHriMP interface with the multiple-window interface provided by Rigi.</p><p>In an early experiment <ref type="bibr" target="#b26">[27]</ref>, 12 subjects were observed while solving simple program understanding tasks using three different interfaces: Rigi, SHriMP, and a non-graphical, command-line interface (consisting of a vi editor and grep). Each subject tested the three interfaces in order: command-line, then Rigi, then SHriMP. Three test programs written in C of varying complexity were, for each user, randomly assigned to the interfaces.</p><p>The command-line interface was used very effectively for the smaller programs. Many of the subjects found the multiple windows in Rigi to be confusing and were misled by hidden, implicit dependencies among the disjoint windows. However, for the larger programs, many users were overwhelmed with the large amount of information presented in the SHriMP views. Results from a usability questionnaire showed that the users preferred SHriMP, but this may have been due to the biased and fixed test order of the three interfaces. At the time of this experiment, the Rigi and SHriMP interfaces were still prototypes.</p><p>In a second experiment, 30 subjects (graduate and undergraduate students in computer science at the University of Victoria) were observed while solving more realistic software maintenance tasks. The studied tools were Rigi, SHriMP, and SNiFF+ (an integrated development environment from TakeFive Software). This experiment is described in more detail in <ref type="bibr" target="#b27">[28]</ref>.</p><p>Each of the 30 subjects (of a particular level of computing experience) was randomly assigned to only one interface, allowing time for adequate training and practice tasks before the formal tasks. Test programs of increasing complexity were used for the three sets of tasks, culminating with a 1700 line Monopoly game program for the formal tasks. A typical formal task asked the subject to determine the appropriate changes needed to implement a new Monopoly rule.</p><p>To prepare the experiment, a parser was used to extract low-level software artifacts and relationships from the test programs. Using the Rigi graph editor, one of the authors looked for meaningful ab- stractions and composed a layered, subsystem hierarchy. To effectively assist program understanding, it was critical that an easily understood set of subsystems be built, that the hierarchy be organized to support navigation, and that meaningful, easy-to-recognize subsystem names be defined. For example, in Monopoly, three subsystem nodes were called Play, Mortgage and Buying &amp; Selling.</p><p>The creation of meaningful subsystems greatly depends on the use of application and programming domain knowledge. In the experiment, the same hierarchies were used for both Rigi and SHriMP. The presentations offered by these tools can help convey a mental map of the program design. Hypertext files of code fragments were also generated.</p><p>In this experiment, we hypothesized that a given interface would affect the comprehension strategy undertaken by a subject to complete an assigned task. For SNiFF+, we expected that its predominantly textual interface would encourage a bottom-up comprehension strategy, where the code is read in some detail before drawing any conclusions about the global program structure. For Rigi, we expected that it would promote a top-down strategy, where the global subsystem structure would be understood before browsing the code in detail. Finally, we expected that the SHriMP interface would support frequent switching between top-down and bottomup approaches due to the seamless integration of source code and high-level graphical views. Our observations do seem to support this hypothesis, but a detailed analysis of the videotaped sessions is needed.</p><p>In the experiment, we also wanted to compare the fisheye-view (context+detail) and pan+zoom techniques used in SHriMP. The fisheye-view technique was not used as much as pan+zoom, probably because of implementation problems in the interface. At the time of this experiment, the SHriMP interface did not support applying the fisheye-view algorithm to multiple focal points. Some subjects mentioned (in a post study interview) that they would have liked to use this feature to magnify multiple subsystem nodes to examine their interactions. Several subjects did use the fisheye-view technique on a single subsystem node, to further explore the interactions between it and the rest of the software.</p><p>We provided one-way access from a SHriMP view to Netscape Navigator for browsing hypertext source code, but Navigator was seldom used even though it was a more familiar and robust tool than the SHriMP code browser. This may have been due to the lack of a tight, two-way integration between Navigator and SHriMP. Many subjects mentioned that they liked the contextual feedback from seeing the code embedded within the nodes as it helped them relate the code to the graphical view of the subsystem hierarchy. This feedback helped them build a mental map of the structure of the program as they browsed the code.</p><p>Another interesting observation was that previously opened subsystems no longer in focus acted as thumbnail images to provide retrieval cues (as a kind of history and/or path-marking feature). Several subjects relied on these visual cues to help retrieve previously explored subsystems.</p><p>The biggest problem observed with SHriMP was in managing complexity in the view, especially when composite arcs were opened. <ref type="figure">Figure 5</ref> shows the visual complexity that arose after opening several composite arcs. Some subjects commented that arcs should be hidden by default and be shown only upon request. Others suggested that filtering mechanisms would have been helpful, so that irrelevant arcs could be hidden. In general, the SHriMP interface was used quite effectively, although further analysis of the experimental data is needed.</p><p>The SHriMP implementation is currently being enhanced to allow the user to display or hide arcs for a set of selected nodes. This poses an interesting problem in general, with many user interface issues to be considered. Some algorithms have been devised for automatically computing layouts of nested graphs with composite arcs <ref type="figure">Figure 5</ref>: Information overload impeded the use of SHriMP due to a lack of filtering mechanisms. <ref type="bibr" target="#b19">[20]</ref>, but few tools have addressed the issue of interactively browsing these graphs.</p><p>Of key importance for program comprehension is the ability to search for keywords in the code and documentation. Observational studies of programmers have clearly shown that making hypotheses and searching for cues to verify or reject these hypotheses are the main activities in program comprehension <ref type="bibr" target="#b22">[23]</ref>. Integrating an effective search engine into SHriMP will also raise some interesting design issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>This paper described an integrated approach for presenting software structure and code that combines both pan+zoom and fisheye-view visualization metaphors in a single view. The SHriMP approach displays software architectural diagrams using nested graphs, conveying containment relationships and graph abstractions. High-level views of the software structure provide a guide through which the user can directly manipulate the view to access pertinent details. The SHriMP interface embeds source code directly inside the nodes and integrates the hypertext link-following metaphor (at the code level) with animated panning and zooming motions over the nested graph (at the structural level). By seamlessly combining code and structural browsing, the SHriMP interface supports and encourages switching between bottom-up and top-down program comprehension strategies.</p><p>The SHriMP tool is currently being evaluated in several user studies. Early observations from these studies were discussed in this paper. As the interface of SHriMP evolves, future experiments will evaluate its effectiveness. Through this iterative cycle of design, implementation and testing, we are working towards a more effective tool for software exploration.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>(a) This figure shows a single node representing the Hangman program. (b) The user has opened the root node of the program to display the next level in the program hierarchy. (c) Further detail is exposed by opening additional nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 (Figure 2 :Figure 3 :</head><label>423</label><figDesc>a) displays the playgame function as a focal point with its code visible. The playgame function calls endgame (see the last line in the body of playgame). If the user clicks on the endgame hyperlink, the tool animates the view so that both nodes This figure demonstrates how the SHriMP fisheye view algorithm has different strategies to adjust graph layouts while preserving the user's mental map. The first column shows several undistorted graph layouts. The second column shows the effects of enlarging nodes using a strategy of this fisheye-view algorithm which preserves orthogonal relationships among nodes in the graph. This method is well suited to the grid layout, but badly distorts the other layouts. The third column shows a different strategy which preserves clusters in the graph layout. This strategy is more suited to the spring layout which groups related nodes. The final column shows some hybrid strategies which are suitable for tree layouts. (a) The GamePlay subsystem in the Hangman program hierarchy has been magnified using the SHriMP fisheye view algorithm. (See color plate 1.) (b) GamePlay has been magnified further, removing most of the context from the view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>(a) The playgame function node is magnified so that its source code is readable. The user selects the endgame hyperlink to see the called function's code. (b) As an animated intermediate step, the SHriMP view shows both the playgame and endgame nodes. (c) Finally, the SHriMP view animates so that the endgame function's code is readable. (d) To see endgame more clearly, the user can zoom in so that the node fills the available screen area. (See color plates 2-5.)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We wish to thank Jim McDaniel for writing a tool to generate HTML'ized code fragments from C source code. We are also grateful to Ben Bederson for suggesting how to use Pad++ within SHriMP more efficiently.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This plate shows the GamePlay subsystem zoomed with no context. In addition, the code for the playgame function has been displayed inside its node. The user has selected a hyperlink in the playgame code for the called endgame function. The code for endgame is displayed inside the node at the bottom right, before the view animates ….</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Color Plate 3:</head><p>The view animates so that both the playgame and the endgame functions are visible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Color Plate 4:</head><p>As a final step, the endgame node is gradually enlarged until its code is visible Color Plate 5: The user may decide to fully zoom the endgame node so that the code fills the available screen space without context.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Pad++: A zooming graphical interface for exploring alternate interface physics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Hollan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM UIST&apos;94</title>
		<meeting>ACM UIST&apos;94<address><addrLine>Marina del Rey, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-11" />
			<biblScope unit="page" from="17" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Towards a theory of the comprehension of computer programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruven</forename><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Man-Machine Studies</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="543" to="554" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">3-dimensional pliable surfaces: For effective presentation of visual information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S T</forename><surname>Carpendale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Cowperthwaite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">D</forename><surname>Fracchia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM UIST&apos;95</title>
		<meeting>ACM UIST&apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="217" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reverse engineering and design recovery: A taxonomy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Chikofsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Cross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="13" to="17" />
			<date type="published" when="1990-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hypertext: An introduction and survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Conklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="17" to="41" />
			<date type="published" when="1987-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A continuously variable zoom for navigating large hierarchical networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bartram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Henigman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 IEEE Conference on Systems, Man and Cybernetics</title>
		<meeting>the 1994 IEEE Conference on Systems, Man and Cybernetics</meeting>
		<imprint>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="386" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A zooming web browser. In Human Factors in Web Development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">SemNet: Three-dimensional graphic representations of large knowledge bases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Fairchild</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Poltrock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Furnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cognitive Science and its Applications for Human-Computer Interaction</title>
		<editor>Raymonde Guindon</editor>
		<imprint>
			<publisher>Lawrence Erlbaum Associates, Publishers</publisher>
			<date type="published" when="1988" />
			<biblScope unit="page" from="201" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Graph drawing by forcedirected placement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fruchtermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Reingold</surname></persName>
		</author>
		<idno>UIUC CDS-R-90-1609</idno>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generalized fisheye views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Furnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM CHI&apos;86</title>
		<meeting>ACM CHI&apos;86<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-04" />
			<biblScope unit="page" from="16" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On visual formalisms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="514" to="530" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Interactive graph layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">R</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Hudson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of UIST &apos;91</title>
		<meeting>UIST &apos;91<address><addrLine>Hilton Head, South Carolina</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-11" />
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Tree-maps: A space-filling approach to the visualization of hierarchical information structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
	<note>California)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Layout adjustment and the mental map</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Misue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="210" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Layout-independent fisheye views of nested graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G</forename><surname>Noik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL&apos;93: IEEE Symposium on Visual Languages</title>
		<meeting><address><addrLine>Bergen, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="336" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Tcl and the Tk Toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A principled taxonomy of software visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Price</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Baecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Small</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<date type="published" when="1993-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Tidier drawing of trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Tilford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering, SE</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="223" to="228" />
			<date type="published" when="1981-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Cone trees: Animated 3d visualizations of hierarchical information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM CHI&apos;91</title>
		<meeting>ACM CHI&apos;91<address><addrLine>New Orleans,Louisiana</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-04" />
			<biblScope unit="page" from="189" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Graph layout for applications in compiler construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sander</surname></persName>
		</author>
		<idno>A/01/96</idno>
		<imprint>
			<date type="published" when="1996-02-27" />
		</imprint>
		<respStmt>
			<orgName>Universität des Saarlandes</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
		<title level="m">Graphical fisheye views. Communications of the ACM</title>
		<imprint>
			<date type="published" when="1994-12" />
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Software Psychology: Human Factors in Computer and Information Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980" />
			<publisher>Winthrop Publishers, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Designing documentation to compensate for delocalized plans</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Soloway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Letovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Littman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lampert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1259" to="1267" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Manipulating and documenting software structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Visualization</title>
		<editor>P. Eades and K. Zhang</editor>
		<imprint>
			<publisher>World Scientific Publishing Co</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="244" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cognitive design elements to support the construction of a mental model during software visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">D</forename><surname>Fracchia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Workshop on Program Comprehension (IWPC&apos;97)</title>
		<meeting>the 5th International Workshop on Program Comprehension (IWPC&apos;97)<address><addrLine>Dearborn, Michigan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05" />
			<biblScope unit="page" from="17" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Graph layout adjustment strategies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graph Drawing</title>
		<meeting>Graph Drawing<address><addrLine>Passau, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1995-09" />
			<biblScope unit="page" from="487" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On designing an experiment to evaluate a reverse engineering tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hopkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Working Conference on Reverse Engineering (WCRE96)</title>
		<meeting>the 3rd Working Conference on Reverse Engineering (WCRE96)<address><addrLine>Monterey, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-11" />
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">How do program understanding tools affect how programmers understand programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><forename type="middle">D</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Working Conference on Reverse Engineering (WCRE97)</title>
		<meeting>the 4th Working Conference on Reverse Engineering (WCRE97)<address><addrLine>Amsterdam, Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
	<note>To appear in the</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Methods for visual understanding of hierarchical systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="109" to="125" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Towards a framework for program understanding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Tilley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Program Comprehension (IWPC&apos;96)</title>
		<meeting>the 4th International Workshop on Program Comprehension (IWPC&apos;96)<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-03" />
			<biblScope unit="page" from="19" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Program comprehension during software maintenance and evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mayrhauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Vans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="page" from="44" to="55" />
			<date type="published" when="1995-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
