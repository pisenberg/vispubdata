<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Managing Software with New Visual Representations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mei</forename><forename type="middle">C</forename><surname>Chuah</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213 (412) 268-2145</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
							<email>eick@research.bell-labs.com</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Bell Laboratories Room</orgName>
								<address>
									<postCode>1G-351, 60566</postCode>
									<settlement>Naperville</settlement>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Managing Software with New Visual Representations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Managing large projects is a very challenging task requiring the tracking and scheduling of many resources. Although new technologies have made it possible to automatically collect data on project resources, it is very difficult to access this data because of its size and lack of structure. We present three novel glyphs for simplifying this process and apply them to visualizing statistics from a multi-million line software project. These glyphs address four important needs in project management: 1) Viewing time dependent data; 2) Managing large data volumes; 3) Dealing with diverse data types and 4</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Visualization can support software engineering at many levels. For code production, which includes code writing, code understanding, debugging, and feature modifications, visualizations are used to highlight functions, identify the differences between releases, examine function execution times, and to understand code change history and authorship <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">11]</ref>. For algorithm understanding, animation can easily communicate the underlying mathematical concepts <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b7">8]</ref>. There is, however, an aspect of the software process that visualization has yet to impact: Project management, the overall task of efficiently managing and processing resources, both human and machine, involved in a software project.</p><p>Managing a large software project is time intensive. Any reasonable-sized project will have many different classes of resources (lab equipment, staff time, machine cycles, disk resources, interim deliverables, customer commitments) that must be scheduled and tracked. Inevitably problems will arise and solutions must be found. To support the management process, information systems collect and maintain large status databases. Our aim is to support and improve this process through visualization.</p><p>Although large volumes of data are collected, much of it remains underutilized. The size of the data volumes make them unfeasible to read textually, and their lack of structure frustrates statistical analysis tools. New visual metaphors can simplify the process of extracting information and presenting it to users in an actionable form. This paper presents three novel glyphs for exactly this purpose.</p><p>Managing a large software project is a specific instance of the project management problem. Project management is "the art of directing and coordinating human and material resources throughout the life of a project by using modern management techniques to achieve predetermined objectives of scope, cost, time, quality, and participation satisfaction" <ref type="bibr" target="#b6">[7]</ref>. Besides software, project management is involved in many other industries including construction, manufacturing, and transportation. Thus even though we will only show the application of these glyphs to software production management, they address issues that are common to project management domains in general.</p><p>There are four interesting issues in project management data: 1. Time: Project management is time-oriented. Each project has a "life" or a time in which it must be completed (deadline). To properly meet deadlines it is important to track milestones, monitor resource usage patterns, and anticipate delays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Large Data Volumes:</head><p>Large projects have a lot of data associated with them. For example, a multimillion line software project may be partitioned into tens to hundreds of subsystems, hundreds to thousands of modules, and thousands to hundreds of thousands of files. Our experience is that much of this data is unstructured, so mining information from it is difficult. Our approach, as is typical in large projects, is to partition the data hierarchically. For example, a software project will have a high-level manager with overall responsibility. This manager may have several supervisors under her and each supervisor will lead a group of engineers.</p><p>3. Diversity/Variety: It is common for projects to have a diverse group of resources as well as resource attributes. Expressing different types of resources (e.g. engineers, computers) as well as their attributes (e.g. number of code lines, number of errors) requires that the visual representations be flexible enough to convey meaningfully information about a set of diverse data. Our glyphs are designed to be versatile so that they can show data for many different software artifacts. Users do not need to relearn new visualization structures for each object type. Flexibility is achieved by enabling our representations to show many different data types, including both discrete and continuous domains. This is unlike previous glyphs <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">10]</ref> that focus on a narrower set of data types.</p><p>4. Correspondence to "real world" concepts: In a project database, data elements usually correspond to "real world" entities or concepts. For example, a userID-1 data element in a software database represents an actual person and the element file-125 corresponds to a source code file. By using glyphs, we maintain the "objectness" of the data elements because all the properties of a data element are grouped together visually. Visual grouping is achieved in our glyphs in two ways: 1) by bringing together various graphical artifacts to form a familiar shape, namely an insect; 2) by arranging the graphical elements according to a common geometric shape (circle). Another method for viewing multidimensional objects is through linked scatterplots <ref type="bibr" target="#b2">[3]</ref>, however, this method does not preserve the "objectness" of the software components.</p><p>Glyphs are not a new concept, being first developed for multi-dimensional data by Chernoff in 1973 <ref type="bibr" target="#b4">[5]</ref>. Our work, however, is different from previous efforts because it combines established visualization views (time series, histogram, rose-diagram) to form glyphs. This allows users to more easily interpret the glyph by using prior graphic knowledge.</p><p>Above we have described how our glyphs deal with the issues of diversity and "real-world" correspondence. In the next two sections we describe how our visual representations can be applied to view time information and deal with large data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">VIEWING TIME-ORIENTED INFORMATION</head><p>Visualizing time-oriented information is challenging because it is unclear what representation will best show the salient information. Animation, a traditional method, uses a symbol to represent the information at one slice in time. This symbol is then rapidly varied to show the data for subsequent time slices. Rapid changes representing outliers are jarring and easily perceived <ref type="bibr" target="#b2">[3]</ref>. Although effective for identifying outliers, animations are less effective than traditional time-series plots for determining overall time patterns. A time-series plot has time on the xaxis and a variable on the y-axis. For viewing time information we present two types of visual representations: timeWheel and 3D-Wheel. These representations are a variation of the time series plots.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">TimeWheel</head><p>In a timeWheel each object attribute is represented as a time series and the time series are laid out around a circle. The goal of this display is to be able to quickly or even preattentively pick out objects based on their time trends.  We encode attributes in two ways, by their position on the circle and by a rainbow-hue colormap. Color, or hue, simplifies the process of identifying object attributes. The rainbow colormap is appropriate for encoding the attribute types because it is a perceptually discrete dimension <ref type="bibr" target="#b11">[12]</ref>. Nevertheless, with a careful choice of scale, hue may also be used to encode continuous variables <ref type="bibr" target="#b8">[9]</ref>. TimeWheel glyphs show two major trends: the increasing trend and the decreasing or tapering trend. The increasing trend glyph looks like a "prickly fruit" <ref type="figure" target="#fig_2">(Figure 2</ref>-left) and it indicates objects which have very little activity at the outset but increasing activity towards the end. The decreasing trend glyph on the other hand looks like a hairy fruit, e.g. a coconut husk <ref type="figure" target="#fig_2">(Figure 2</ref>-right).</p><p>Decreasing trends indicate high activity at the outset but declining activity through time.  <ref type="figure" target="#fig_3">Figure 3</ref> and white in Plate 1-a); 2) objects with decreasing trends which are the older releases and activity has since slowed to a crawl (outlined in black in <ref type="figure" target="#fig_3">Figure 3</ref> and red in Plate 1-a), and 3) in-between objects which represent releases worked on in the middle of the project (non-outlined objects in <ref type="figure" target="#fig_3">Figure 3</ref> or Plate 1-a).</p><p>Grouping the time series into a glyph allows us to identify the dominant time trend, however, having the individual time series available allows us to examine divergences from that trend. For example in <ref type="figure" target="#fig_0">Figure 1</ref>, userId-1 has an overall tapering trend, but there are divergent variables.</p><p>The interesting information to derive from userId-1's timeWheel display is that the aerr and derr attributes have tapering trends while the anew and dnew attributes have increasing trends. Because the loc trend (colored in red) is tapering, we can deduce that most of the code added were from error fixes. In addition, we can tell that there are two clear phases for developer userId-1. First, userId-1 did error fixes but later moved on to developing new code. We can also deduce that error fixing accounted for a more important portion of userId-1's activities because it corresponds to the dominant trend.</p><p>An obvious and traditional way to arrange a set of time series on a two dimensional plane would be to lay them out linearly as in <ref type="figure">Figure 4</ref>. For tasks involving browsing or searching for gestalt patterns, the circular layout may be more effective than a linear layout for four reasons: eye movement, local pattern perception, reading order, and information density. Reduce the number of eye movements per object: Cropper &amp; Evans as well as Danchak found that the visual angle over which the eye is most sensitive is 0.088 radians (5 degrees) <ref type="bibr" target="#b13">[14]</ref>. Cropper and Evans subsequently stated that "the presentation of information in `chunks' ... which can be taken in one fixation will help to overcome the limitations in the human input system in searching tasks". Laying out the time series in a circular fashion as in <ref type="figure">Figure 5</ref> allows all of the time plots to be taken in with one eye fixation. However, laying them out in a linear fashion as in <ref type="figure">Figure 4</ref> requires more than one eye fixation. There is, however, a limit to the number of object attributes that can be displayed in the timeWheel for it to fit within the area of an eye fixation. As a rough approximation, for a viewer that is 15 inches from the screen, a visual angle of 5 degrees translates into a circular area on the screen with a radius of 0.65 inches.</p><p>Our experience is that we can comfortably encode 10 variables in that area. It may be possible to encode as many as 15 variables before the display becomes too dense to interpret.</p><p>An alternative layout scheme arranges the time series in rows. This reduces the number of eye fixations, however, the user might begin to cluster the data by rows because we are conditioned to it from reading text. This would adversely affect the users' ability to sense the overall time patterns in the glyphs. Another possibility positions the time series out in 3D space and encode properties along the z-axis. The drawback to this 3D layout is occlusion:</p><p>The first few series occlude the others.</p><p>Less susceptible to local patterns: Linear ordering highlights local patterns. For example, in <ref type="figure">Figure 4</ref> a dominant visual impression is the cyclic local pattern shown in <ref type="figure">Figure 6</ref>. The local pattern is formed here because our perceptual system groups the two time series based on the gestalt principle of closure <ref type="bibr" target="#b12">[13]</ref>. This grouping however is spurious because the object attributes have no ordering.</p><p>The perceptual differences between the two rows in <ref type="figure">Figure 4</ref> are emphasized due to local grouping effects. By comparison, the circular placement suffers less because the symbols are not placed directly next to each other. As an example <ref type="figure">Figure 5</ref> shows that the rows in <ref type="figure">Figure 4</ref> are in fact quite similar --one is merely a rotation of the other. This pattern is masked in <ref type="figure">Figure 4</ref> because of distracting local patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6: Cyclic local pattern</head><p>Reading order: A linear layout encourages users to read the plots from left to right. Since the attribute types are unordered, this may cause false impressions. For example, more importance could be placed on the series at the start or end. Unlike linear ordering, a circular layout positions each time series at the same distance from the glyph center. In this way, the time series position has a much weaker ordering implication. Reading order is another reason why the two rows in <ref type="figure">Figure 4</ref> appear to be different. The bottom object has cyclic patterns at its start and end while the top object has two opposing patterns namely and .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Less separation and therefore higher information density:</head><p>The circular layout creates a strong gestalt pattern out of individual time series. We recognize the circular pattern because it is a common geometric shape. On the other hand, the linear layout ties the time series together only through spatial proximity. As a result, for us to see the boundaries between objects, we have to leave a lot more whitespace between the series than in the timeWheel case. For example the top row in <ref type="figure" target="#fig_6">Figure 7</ref> contains the same information as the bottom row and is divided by the same amount of whitespace, however it is hard to see the division between the top objects while it is much easier to see the division between the bottom objects. Instead of whitespace we could use a bounding box to indicate object boundaries for the linear layouts, however this adds to the density of the display and may distract the user <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">3D-Wheel</head><p>The 3D wheel encodes the same data attributes as the timeWheel but using the height dimension to encode time. Each variable is encoded as an equal slice of a base circle and the radius of the slice encodes the size of the variable as in a rose diagram. Each variable is also colored in its own discrete, shaded color. An object that has a sharp apex as in <ref type="figure">Figure 8</ref>-left has an increasing trend through time and an object that balloons out as in <ref type="figure">Figure 8</ref>-right has a tapering trend.  <ref type="figure" target="#fig_3">Figure 3</ref> using 3D wheel glyphs. The 3D wheel shares the advantages of the timeWheel over linear ordering methods. However, unlike the timeWheel where the dominant trend is perceived through the global pattern formed by the series, the 3D wheel allows users to perceive the dominant time trend through its shape. As a result it is easier to identify overall time trends using the 3D wheel. It is however harder to identify divergences because of occlusion and perspective. Even though there is occlusion in the 3D wheel, it is still a lot less than if we were to lay out the time series over the z-axis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">VIEWING SUMMARIES WITH INFOBUG</head><p>Associated with any reasonably-sized software project are diverse data sets involving the developers, files, software releases, etc. Physical constraints (e.g. screen space) and cognitive constraints (e.g. short-term memory) make it unfeasible to view all this data at once. To address this problem, we partitioned the data hierarchically into three classes of software artifacts ( <ref type="figure" target="#fig_0">Figure 10</ref>) and used it to construct a scatterplot interface <ref type="figure" target="#fig_0">(Figure 11</ref>).  On the x-axis of each scatterplot we encode the number of code lines (loc) and on the y-axis we encoded the number of errors (err). This encoding is made because the ratio of err/loc helps determine the quality of a software component. Objects may be selected in the scatterplot by using a bounding box swept out by the mouse. Once selected, the children of the objects may be viewed at a lower level in the scatterplot hierarchy ( <ref type="figure" target="#fig_0">Figure 11</ref>).</p><p>Viewing objects hierarchically helps alleviate some of the data scale issues. Even so, it is often the case that within each level of the hierarchy summarization is still needed. The InfoBUG glyph shows many properties simultaneously in a small footprint such that patterns preattentively "jump out" at the user.</p><p>Four important classes of software data are represented by the infoBUG head, tail, wings, and body. As is shown in <ref type="figure" target="#fig_0">Figure 12</ref> the number of code lines and number of errors are assigned to the bug wings, the code type consistency to the head, the number of changes to the bug tail, and the component size to the body.</p><p>The infoBUG glyph is interactive and through animation can show the information at different times within the project. Clicking on the wings selects a time-slice causing the head, body, and tail to update. The selected time slice is indicated with a red band on the infoBUG wing. The time component for all infoBUG glyphs can be changed simultaneously by using the slider at the bottom of the interface <ref type="figure" target="#fig_0">(Figure 13</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lines of code vs. number of errors ratio:</head><p>This is an important measure for determining problems within project components and is encoded within the wings of the infoBUG. Each wing is a time series with time running from top to bottom. The x-axis on the left bug wing encodes the number of code lines and the x-axis of the right bug wing encodes the number of errors. Usually increases in code bring about comparable increases in number of errors. This results in symmetrical insect wings.</p><p>Increases in code that are not accompanied by similar increases in errors may imply that the component is not being well tested. On the other hand increases in the number of errors that are not accompanied by similar increases in code could mean that the existing code is inherently difficult, has architectural problems, or is poorly written and in need of re-engineering. These cases are represented visually by non-symmetrical wings which are easy to identify using infoBUGs.</p><p>The position of the wings (whether starting at the top or bottom) indicates the time at which the project was started while the shape of the wings shows whether the number of code lines and the number of errors found are increasing, decreasing, or static with time.</p><p>Code type consistency: A particular software component may consist of several different types of code. For example to implement the glyph systems described in this paper <ref type="figure" target="#fig_3">(Figure 3, Figure 9</ref>, <ref type="figure" target="#fig_0">Figure 11</ref>, and <ref type="figure" target="#fig_0">Figure 13</ref>) we used Java to specify and control the interfaces, Perl to extract and process the data, and VRML to render the three dimensional wheel glyphs. The code consistency of software components indicate the components' capabilities and purposes. For example knowing that VRML is used suggests three dimensional representations. Examining such data might also show changes in development practices and in the requirements for a software component.</p><p>Code type consistency is encoded by the infoBUG head. The head shows, for a given time slice, the relative code sizes by type. The code type is color coded and the color scale for it is shown at the left of the interface in <ref type="figure" target="#fig_0">Figure  13</ref> (Plate 1-c) For example the software component in <ref type="figure" target="#fig_0">Figure 12</ref> is made up of C code, SD (State Definition) code, and header lines.</p><p>By interactively changing the time component we are able to obtain information on how the different code types evolve. Such changes give us hints about the changing needs of a software component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Information on changes made:</head><p>The bug tail is triangleshaped. Its base encodes the number of code lines added and its height encodes the number of code lines deleted. The tail base is further divided into two parts: code added due to error fixing (color coded in red) and code added for new functionality (color coded in green). <ref type="figure" target="#fig_0">Figure 13</ref>  By looking at the shape of the tail we can determine the ratio of number of code lines added to lines deleted. A short squat triangle like the one for release-8 shows a high added to deleted ratio. The shapes of the triangles for most of the other releases are less squat indicating a lower added to deleted ratio. A triangle that is higher than it is wide has more deleted lines than added lines. This could be an indication of a serious problem in the release. None of the releases in <ref type="figure" target="#fig_0">Figure 13</ref> show this property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Size of components:</head><p>The size of a component is often important as it reflects the extent to which a component affects the project. Component size is encoded in two ways: through the number of altered files and through the number of child objects a software component contains. The bar in the middle of the infoBUG body shows the absolute number of file changes. The size of the black circles on the body encode the number of child components that are contained within the current objects. The type of child objects encoded depends on the software hierarchy of the system being analyzed. Our system for example, is based on the software hierarchy shown in <ref type="figure" target="#fig_0">Figure 10</ref>.</p><p>The size of the children groups helps us gauge whether a software object is "wide" (i.e. related to many other components) or "narrow" (i.e. related to only a few other components). A software component may be wide in certain respects and narrow in others. For example release-1 and release-2 in <ref type="figure" target="#fig_0">Figure 13</ref> are spread out over many modules (top left body circle) but affects very few supervisors and packages. This indicates that the releases are specific to a small set of packages but the changes made affected large portions of those packages. On the other hand, release-11 affects many packages (lower right body circle) but the effects within each package are relatively small as indicated by the small module circle (top left circle).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSION</head><p>We have developed three novel representations for dealing with project management data. These representations address important issues in project management namely: time dependent data, large data sets, diversity, and correspondence to real world entities.</p><p>One particularly exciting aspect of this research involves the company Intranet. We are using the corporate WEB as a distribution mechanism to provide access to our visualization. We built our glyphs using Java and VRML and have them running on top of a Netscape browser. Now anyone inside the corporate firewall can access our software visualization glyphs and display software project data. In the past we have built many innovative tools that were not widely used because of platform and database obstacles. By centralizing the databases and building on top of a ubiquitous platform, we can connect with a much wider user base.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1</head><label>1</label><figDesc>shows a timeWheel and the different attributes that are mapped onto it. The direction of the arrows indicates the direction of time increment for each series.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>TimeWheel Glyph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Left -increasing trend timeWheel (prickly fruit); Right-decreasing trend timeWheel (hairy fruit)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 (</head><label>3</label><figDesc>Plate 1-a) shows 16 software releases using the timeWheel glyph interface. Looking at this figure we can partition releases into three major classes: 1) objects with increasing trends, which are new releases that have only been worked on later in the project (outlined in light gray in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>timeWheel interface for 16 software releases(Plate 1-a)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 : 2 Figure 5 :</head><label>425</label><figDesc>Linear layout of object-1 and object-Circular layout of object-1 and object-2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>The objects in Figure 4 and Figure 5 placed close to each other</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :Figure 9 : 3D wheel interface of the 16 software releases shown in Figure 3 (Figure 9 (</head><label>8939</label><figDesc>Left -increasing trend (sharp apex); Right -decreasing/tapering trend (balloon) Plate 1-b) Plate 1-b) shows the 16 releases from</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Figure 10: Software Hierarchy</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Scatterplot interface</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :Figure 13 : infoBUG interface of the 16 software releases shown in Figure 3 and Figure 9 (</head><label>121339</label><figDesc>InfoBUG glyph Plate 1-c)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>(Plate 1-c) shows that most of the releases consist of code added for new functionality, except for release-8 which is a bug fixing release.</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Human Factors and Typography for More Readable Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Baecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Software Visualization in the Large</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="33" to="42" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Brushing Scatterplots</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">S</forename><surname>Cleveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technometrics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="127" to="142" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Algorithm Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Distinguished Dissertations</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Use of Faces to Represent Points in k-Dimensional Space Graphically</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chernoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="page" from="361" to="368" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SeeSoft-A Tool for Visualizing Line-Oriented Software Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">E</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="957" to="968" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Project Management for Construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hendrickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Au</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Visualization of Parallel Systems: An Overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kraemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="105" to="117" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Color Scales for Image Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lefkowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">T</forename><surname>Herman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="72" to="80" />
			<date type="published" when="1992-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Iconographic Displays for Visualizing Multidimensional Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Pickett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Grinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Conference on Systems, Man and Cybernetics</title>
		<meeting>IEEE Conference on Systems, Man and Cybernetics</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="514" to="519" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Taxonomy of Software Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Price</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Small</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Baecker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Architecture for Rule-Based Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">E</forename><surname>Rogowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Treinish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;93</title>
		<meeting>IEEE Visualization &apos;93</meeting>
		<imprint>
			<biblScope unit="page" from="236" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">T</forename><surname>Spoehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Lehmkuhle</surname></persName>
		</author>
		<title level="m">Visual Information Processing</title>
		<imprint>
			<publisher>W.H. Freeman and Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Formatting of Alphanumeric Displays: A Review and Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Tullis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Human Factors</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="657" to="682" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
