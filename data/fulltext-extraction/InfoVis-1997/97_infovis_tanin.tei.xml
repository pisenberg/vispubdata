<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Design and Evaluation of Incremental Data Structures and Algorithms for Dynamic Query Interfaces</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Egemen</forename><surname>Tanin</surname></persName>
							<email>egemen@cs.umd.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Beigel</surname></persName>
							<email>beigel@cs.umd.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Shneiderman</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Human-Computer Interaction Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Institute for Systems Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science, U. of Maryland at Col-lege Park</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Design and Evaluation of Incremental Data Structures and Algorithms for Dynamic Query Interfaces</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Data Structure</term>
					<term>Algorithm</term>
					<term>Database</term>
					<term>User Interface</term>
					<term>Information Visualization</term>
					<term>Direct Manipulation</term>
					<term>and Dynamic Query</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Dynamic query interfaces (DQIs) are a recently developed database access mechanism that provides continuous real-time feedback to the user during query formulation. Previous work shows that DQIs are an elegant and powerful interface to small databases. Unfortunately, when applied to large databases, previous DQI algorithms slow to a crawl. We present a new incremental approach to DQI algorithms and display updates that works well with large databases, both in theory and in practice.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="figure">Figure 1</ref><p>: Spotfire: sample DQI (www.ivee.com). The user specifies a query using the widgets along the left, bottom, and right of the display. The hit set for the current query is displayed as a starfield on the left. This example does not contain a bar giving aggregate information about the database but the hit set size is shown as a count at the bottom.</p><p>widgets are updated to show the hit set's bounding rectangle, so the widgets provide a limited form of output as well. If desired, we can even display a histogram on each widget to show the distribution of data in its dimension. The user may click on an individual point on the starfield for "details on demand".</p><p>Range sliders are used to manipulate continuous attributes. See <ref type="figure">Figure 2</ref> for a sample range slider. A range slider contains a pair of arrows, one at each end. The user selects a range slider by clicking on it, and the user adjusts the range by dragging either arrow with the mouse. As the range is being adjusted, the starfield, bars, and charts are updated. Histograms and states of the other widgets can also be updated. Thus, for each tiny increment of the range slider, much information must be computed rapidly. <ref type="figure">Figure 2</ref>: A sample range slider. By moving the arrows, the user specifies a range, which is represented by the white rectangle. The numbers above the arrows give the current range. The numbers on the far ends of the range slider are the extreme values that the attribute can take.</p><p>Toggles allow the user to specify a binary attribute of the data. On the display they look like boxes. Internally they can be implemented directly without much trouble or treated as a nearly trivial special case of range sliders. List boxes, radio buttons, and various other discrete widgets can be handled with similar ease.</p><p>Alphanumeric sliders allow the user to specify a range of strings. Although our auxiliary data structures apply to them as well, the fine granularity of alphanumeric data seems to necessitate additional implementation ideas that are best described in a separate paper.</p><p>We propose a new approach to DQI algorithms that can handle larger databases than previous implementations. This paper expands our previous note <ref type="bibr" target="#b12">[13]</ref> by providing a detailed explanation and evaluation of our DQI algorithms. We present our approach in general in Section 2. We give a detailed explanation of the data structures and algorithms in Section 3. We analyze the complexity of our algorithm in Section 4. We evaluate our approach experimentally in Section 5. We state our conclusions and future work in Sections 6 and 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Incremental Approach</head><p>In DQIs queries are formed in an incremental fashion. For example: to set a range on a slider, the user drags the two arrows of the slider to desired positions on the display. This enables the user to visualize intermediate results until a desired final set of positions is reached. Also, a query can be formed via a conjunction (or disjunction) of constraints on more than one or two attributes. This also produces numerous intermediate results to be displayed. Therefore, we chose the incremental query formulation paradigm in our designs for algorithms and data structures for DQIs.</p><p>The incremental approach gains its efficiency from the following innovations:</p><p>Active subset We define an "active" subset of the database, of limited size, which we store in main memory. (While in principle the size of main memory may seem like a severe limitation, in practice DQI algorithms seem to be limited more by time than by space).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Auxiliary data structures</head><p>We augment the active subset with data structures that facilitate continuous querying (users can tolerate a response time of about 0.1 seconds for continuous operations <ref type="bibr" target="#b0">[1]</ref>).</p><p>Reprocessing The auxiliary data structures change only when the user clicks on a widget. After such an action the user will accept a delay of approximately 1 second or less, during which we reconstruct the auxiliary data structures.</p><p>Incremental display Slight changes in the query tend to cause only slight changes in the output. By computing and displaying the difference, we can update the display continuously.</p><p>We envision using the DQI algorithms in tandem with a query previewer <ref type="bibr" target="#b2">[3]</ref> that allows the user to browse a huge database and select a manageably small subset to scan. Once the user selects such a subset, the query previewer passes its bounding rectangle to the DQI, which then takes control. The bounding rectangle for the active subset determines the extreme values for each attribute. Therefore, the query preview approach can also be considered as an application of the incremental querying paradigm (in a more broad sense). If, at some later time, the user wants to look outside the active subset, then the simplest solution is for the DQI to return control to the query previewer. This will be considered in a future paper on the interaction between the DQI and the query previewer. The data structures and algorithms are given in the following section with an example on range sliders.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Data Structures and Algorithms</head><p>Our DQI algorithms perform three major operations: setup, selection, and querying.</p><p>Setup occurs when the query previewer passes control to the DQI. During setup, the widgets, starfield display, bars, and charts are initially drawn on the display. The DQI reads the active subset. In addition, it makes a copy of the active subset and re-scales each attribute to the range 1; p where p is the number of pixels in the attribute's range slider. This step is important because we need this re-scaled information frequently. Because setup occurs infrequently, we can allow several seconds for it.</p><p>Selection occurs when the user clicks on a range slider. During selection, the algorithm computes the auxiliary data structures, which depend on the currently selected attribute and the current ranges for the other attributes. Various experiments with user interfaces show that we must respond to the mouse click in about 1 second in order not to annoy the user. At the cost of a factor of 2 in memory, we could precompute the auxiliary data structures whenever the mouse is moved close to a new range slider. Using somewhat more memory, we could steal cycles from the query operation in order to precompute the auxiliary data structures for several sliders. Thus 1 second may be an overly conservative bound on the time for selection.</p><p>Querying occurs continuously as the user drags the mouse to update the selected range slider. During querying, the algorithm recomputes the hit set and updates the output on the display. For the purpose of timing, we say that a single query occurs each time the DQI detects a change in the position of the mouse on the range slider. Experiments show that DQIs must process each query in about 0.1 seconds in order to give a continuous response <ref type="bibr" target="#b0">[1]</ref>.</p><p>During the selection operation, the DQI computes the maximum hit set, which is the hit set determined by the extreme values for the selected attribute and the current ranges for the other attributes.</p><p>Then it partitions the maximum hit set into p buckets, one for each user-specifiable value for the current attribute. This is essentially a linear time counting sort of the maximum hit set. We store the size of each bucket and all left-to-right partial sums of these sizes (an example range slider with bucket information included is given in <ref type="figure">Figure 3</ref>).  <ref type="figure">Figure 3</ref>: A sample range slider with bucket information. This example shows 10 records distributed on the range slider sorted in ascending order for the related attribute. The arrows from the range slider to the hit set show the related positions in the sorted maximum hit set that each discrete pixel position of the range slider maps to where the numbers in this hit set give the values of the records for that attribute represented by the slider. The lower array of boxes represents the partial sums of counts for a given pixel position of the range slider. This example contains only 7 hypothetical pixels for simplicity.</p><p>In selection, we also compute the information that facilitates computation of histograms and tight coupling of range sliders, i.e., the redisplay of all slider ranges when any range is changed. To achieve this goal a two dimensional array for each slider is kept (i.e., size p 2 , shown in <ref type="figure" target="#fig_0">Figure 4</ref>). Thus, any time the range slider is updated, even by a large number of pixels (as might happen if the user moves the mouse extremely fast), we can determine the number of hits in constant time. We can also determine ranges for the other sliders in constant time per slider, and histograms for the other sliders in constant time per point. Changes to the display are determined by scanning the buckets between the older attribute value and the new one. The display is updated in time that is linear in the number of changes.</p><p>If the user changes the axis parameters for the starfield display, then the hits are redisplayed (projected on the new pair of coordinates) but none of the internal data structures is changed. The only thing that is updated is the starfield information.</p><p>The starfield information is equivalent to a two dimensional "dirty-pixel" array where for each starfield pixel we keep a count. Whenever a pixel count reaches zero that pixel color is set to the background color (and visa versa i.e., if it was zero and becomes a positive integer then we plot that pixel on the starfield display using the foreground color). Programmers can use these counts to give another form of histogram information to the user. Also, they can immediately find the necessary pixels on the starfield display that must be updated (i.e., only the pixel positions where the counts vary). Preliminary experiments show that the incremental approach can deal with an active subset consisting of 100,000 records with 10 attributes each <ref type="bibr" target="#b12">[13]</ref>. In comparison, the pioneering work in the area, the Film Finder program <ref type="bibr" target="#b0">[1]</ref>, could handle a database of 10,000 records with 10 attributes, and some of the standard data structures analyzed in <ref type="bibr" target="#b9">[10]</ref> and tested in <ref type="bibr" target="#b10">[11]</ref> demonstrated scalability up to 20,000 records with 10 attributes.</p><p>The following subsections describe the experimentation on an implementation made by using our methods and show the results. First, we describe the implementations and the environment for the experiments. The experimentation method and the results are presented next. After this we show the derivation of the experimental run time behavior (complexities) obtained from the experiments. Then we test the validity of these experimental complexities and finally state some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimentation Environment</head><p>We implemented a sample DQI using range sliders. The interface consisted of a starfield display, a preview bar (to show aggregate information about the query that is being formed), and a number of range sliders depending on the number of attributes in the input dataset. The starfield display and the points in the starfield display could have variable sizes. Also the range slider sizes could vary.</p><p>We used a SUN SPARC Station 5 with 32MB of RAM that runs a standard UNIX operating system for our experiments. Motif and C were used in our implementations.</p><p>We timed the setup, selection, and querying separately by considering CPU time spent for each operation (to avoid defects that might come from a multiuser environment). File read, data structure setup, and similar sub-setup and sub-selection times were also measured. Also all the experiments were repeated without a preview bar and a starfield display to measure the querying time (without giving any visual output to the user, this is the "pure" querying time).</p><p>We varied the total number of attributes, the total number of records, the starfield size, the point sizes on the starfield, the range slider sizes, and the jump sizes (the displacements, in pixels, of a single side of a range slider between consecutive queries). The experiments were controlled by a batch process. This was necessary to get accurate timings using exact jump sizes. We generated random numbers according to a uniform distribution for our datasets in our experiments. This was also necessary because the starfield display has its slowest performance when there are many pixels to be updated on the display. To make a worst case analysis, we tried to reduce the number of overlaps on the display. Although this might eliminate some of the computations for updating the overlapping points, it increases the starfield update times which is more expensive than the count updates.</p><p>We considered the worst case that might occur in a single selection operation. This occurs when m is equal to r that might not occur very frequently in real applications. So our experiments show some over-estimated times for querying, selection, and setup. In real-life applications we expect to observe better performances from our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experiments and Results</head><p>We ran 7200 experiments to assess the performance of our implementations. 3600 of them ran with the starfield display and the preview bar enabled and the other 3600 ran with them disabled.</p><p>The following values were used in our experiments: 10; 000, 25; 000, 50; 000, 75; 000, or 100; 000 records Jump size/range slider size (j=p) 1=50, 1=25, 1=10, or 1=5</p><p>In the first 3600 experiments we measured the time to update the internal data structures (without any user interface updates). In general we observed that the "pure" querying time is no more than 20 milliseconds (average of 10 milliseconds). This was negligible, with respect to the starfield display times obtained, especially when the number of records got larger (with a starfield display that does not use our methods, querying time becomes even less significant with respect to the update times for the starfield display). This suggests that the starfield update times must be optimized first for a faster DQI.</p><p>The second set of 3600 experiments were used to measure the querying times including the starfield display update times. The complexity analysis depends on these remaining 3600 experiments, which we present in the following subsections ( <ref type="figure" target="#fig_1">Figure 5</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experimental Complexity</head><p>Let se denote the estimated setup time. Let so denote the setup time observed from our experiments. In an ideal analysis we must always observe an equality between the two times. Obviously there are some errors in the experiments and in the formula itself (due to neglecting some low-order terms). We ran a multiple linear regression on our experiments where jso,sej is minimized over all the experiments. This is equivalent to finding the best constants for se = A+B ra formula (again over all the experiments) where A and B are the constants and ra term is obtained from the theoretical complexities given in Onotation in previous sections. The setup has a constant A as we need to represent file open and close times spent in the experiments. After the regression we obtained A = 1:16 and B = 0:0000177. Hence, se = 1:16 + 0:0000177 r a.</p><p>We did a similar analysis with the selection times. Let Se denote the estimated selection time. Let So denote the selection time observed from our experiments. Therefore, we can get the formula Se = B r a + C a p 2 . Selection does not have a constant like A as we had in setup so A = 0. The regression produced B = 0:00000121 and C = 0:00000116. Hence, Se = 0:00000121 r a + 0:00000116 a p 2 .</p><p>Finally, let Qe denote the estimated querying time. Let Qo denote the querying time observed from our experiments. Again using the theoretical complexities we can get Qe = A + B a p + Cu. Due to initialization routines, we found the existence of A appropriate in this formula (eventually it turned out to be a small value). Unfortunately, the analysis for querying is not trivial, as we have to find an estimate for u in terms of display size, point size, and etc. We saw that the u term is directly proportional to the jump size and the number of records needed to be updated on the starfield. Since we paint more than one pixel per point (in general) the formula counts the number of pixels that are updated. So our estimate for u is r j d 2 =p where d 2 is the number of pixels to be painted per each point and j is the jump size. Hence, Qe = A + B ap+Cu becomes Qe = A + B a p + C r j d 2 =p for our case.</p><p>Similarly, the regression produced A = 0:00528, B = 0:0000157, and C = 0:000000263. Hence, Qe = 0:00528 + 0:0000157 a p + 0:000000263 r j d 2 =p. pixels (which forms the average case for our experiments). The querying times given in this graph show that the average case for our experiments is an order of magnitude faster than the ones observed in the previous experiments with other data structures and algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Evaluation</head><p>To evaluate the approach we used two methods. The first one is to run the X 2 test to assess the correlation between our experiments and the theoretical terms. Then we ran another set of experiments to see whether we can estimate the outcomes of these new experiments with our old formulas (and hence with the old constants) or not.</p><p>The X 2 test, for all of the three measurements (setup, querying, selection), showed that the estimated values and the actual values obtained from the experiments were highly correlated. We ran 1000 new experiments and obtained the same times with the similar methods used for the previous set of experiments (the starfield display was always active in this set of experiments). We had a random combination of the following values for our experiments: point size varied between 1 2 to 10 2 , jump size varied from 1 to 50, display size varied from 300 2 to 600 2 (with range sliders of size 250 pixels a user interface with a starfield of 600 2 pixels nearly fills the display), and the slider sizes varied from 150 to 250. The only values that were fixed during these new set of experiments (i.e., same values with the previous set of experiments) were the dataset sizes and the attribute counts (as it is practically impossible to generate all the possible (random) datasets (either in terms of time or space) on the fly for these new set of experiments). The differences between the estimates and the actual times were obtained. The average deviation observed for setup time was 9:50 percent; for selection, 3:97 percent; for querying, 16:63 percent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Discussion</head><p>Using the incremental approach we achieved better querying times than previous implementations (that had standard data structures for querying which were not specifically designed for DQIs). We also consumed less memory as we created the data structures whenever they were needed. The new approach enabled us to give preview bar, histogram, and tight coupling information to the user without making any additional queries or spending additional processing times. The size of the main memory that is being used by the implementations remained as a secondary problem. We saw that there are problems in the selection times before we reached to the memory limits of our architecture (more than 1 second generally annoys the user). The selection times were mostly around 1 second. Hence, memory still remained as a secondary problem for DQIs. As r increases, terms that contain the r factor become more significant. The starfield display times were significant for huge r's and our approach gains its power from the incremental starfield display updates (but huge jumps in range sliders can still cause high display update times).</p><p>The average deviation for the selection times was smaller than we expected for the random set of experiments. The setup times were also acceptable as the disk input caused fluctuations in setup times. The querying time estimates were less accurate than we expected but were again acceptable. The reason for this was the high precision measurements that were made on a system that has lower precision settings than the required ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>The new incremental approach for queries and display updates introduces a better way of dealing with large databases. Experiments show that this approach is faster than previous approaches and can deal with an order of magnitude of larger datasets (i.e., 100; 000 records with 10 attributes). The querying time is dominated by the starfield update time (also observed in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b12">13]</ref>). The incremental approach enables faster display because only the difference between consecutive queries is updated in the data structures and on the starfield display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Future Work</head><p>Our goal is to make another order of magnitude increase in the size of the datasets that DQIs can deal with (1; 000; 000 records with 10 attributes). We plan to: implement other widget types, e.g., alphanumeric sliders. try spatial data structures like k-D trees to see how they effect the times for selection and querying. (As a general non-worst-case rule of thumb, spatial data structures answer range queries in time OjHj <ref type="bibr">1,1=a</ref> where H is the set of hits and a is the number of attributes in the input dataset. This could be good for selection, because it is sub-linear. But it could be bad for querying, because it is close to linear, and prior work seems to confirm this doubt <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b12">13]</ref>. Instead, we will use an incremental approach where we compute the difference ∆H between consecutive hit sets,which in practice should take time only Oj∆Hj 1,1=a .)</p><p>combine our DQIs with a query previewer <ref type="bibr" target="#b2">[3]</ref> in order to produce a new state of the art in interactive dynamic database access.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 4 :</head><label>4</label><figDesc>A table containing the histogram and the tight coupling information. This figure uses the same data and example asFigure 3. Each box in the square holds a count. The user sets the range for attribute 1. For a given specified range of attribute 1 we can find the valid range for attribute 2 by projecting the hit set's bounding rectangle onto attribute 2. Each row is a prefix sum of counts from left to right. So if we subtract column j from column i we can use the resulting difference array to find the valid range for attribute 2. The highest nonzero row (k) and the lowest nonzero row (m) give the valid range for attribute 2. Note that the histogram information for attribute 2 is just the difference array.4 Theoretical ComplexityLet r denote the number of records in the active subset, a the number of attributes, and b the number of bytes needed to store the value of a single attribute. Let p denote the length in pixels of each range slider, f the area in pixels of the starfield, and u the average number of pixels that need to be updated in the starfield display per query (this number depends in a nontrivial way on the size of the starfield, the velocity of the range slider, and the clustering of data in the active subset). Let m denote the number of records in the maximum hit set.The active subset occupies r a b bytes. The rescaled active subset occupies Or a bytes. The bucket partition also occupies Ora bytes. The data structures for tight coupling occupy Oap bytes. The data structures for range histograms occupy Oa p 2 bytes. The starfield occupies f bytes. Setup takes time Or a b. There are four components to the time for selection. Determining the maximum hit set takes time Or a. Sorting the maximum hit set takes time Om (there is no log factor because we discretize the data). Computing the auxiliary data structures for tight coupling takes time Oa p + m a. Computing the auxiliary data structures for histograms takes time Oa p 2 + m a. Thus, the total time for selection is Oa r + m + p 2 = Oa r + p 2 . There are three components to the time for querying. Tight coupling takes time Oa. Computing histograms takes time Oa p. Updating the starfield takes time Ou. Thus the total time for querying is Oa p + u.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5 :</head><label>5</label><figDesc>A subset of experiments (25 experiments out of 3600): The starfield size is 500 2 pixels, the range slider size is 200 pixels, the point size is 5 2 pixels, and the jump size is 200 1=25 = 8</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Visual Information Seeking: Tight Coupling of Dynamic Query Filters with Starfield Displays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ahlberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCHI &apos;94</title>
		<meeting>ACM SIGCHI &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="313" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">IVEE: An Information Visualization and Exploration Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ahlberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wistrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Information Visualization</title>
		<meeting>IEEE Information Visualization</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="66" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Query Previews in Networked Information Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Forum on Advances in Digital Libraries</title>
		<meeting>Forum on Advances in Digital Libraries</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="120" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data Visualization Sliders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM User Interface Software and Technology</title>
		<meeting>ACM User Interface Software and Technology</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="119" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Enhanced Dynamic Queries via Movable Filters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fishkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Stone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCHI &apos;95</title>
		<meeting>ACM SIGCHI &apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="415" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Using Aggregation and Dynamic Queries for Exploring Large Data Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">F</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCHI &apos;94</title>
		<meeting>ACM SIGCHI &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="23" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">University of Maryland at College Park, Homefinder, 1992. The down-loadable PC demonstration</title>
		<ptr target="//ftp.cs.umd.edu/pub/hcil/Demos/DQ/dq-home.zip" />
		<imprint/>
		<respStmt>
			<orgName>Human-Computer Interaction Laboratory (HCIL)</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Online Java demo and down-loadable demos for various platforms</title>
		<ptr target="http://www.ivee.com/" />
	</analytic>
	<monogr>
		<title level="j">Information Visualization and Exploration Environment (IVEE) Development AB</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dynamic Information Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ioannidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIG-MOD Record</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="16" to="20" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data Structures for Dynamic Queries: An Analytical and Experimental Evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Advanced Visual Interfaces,Available from ACM</title>
		<meeting>Advanced Visual Interfaces,Available from ACM<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">reachable via email: pointek@cs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pointek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
	<note>personal communication. umd.edu</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Dynamic Queries for Visual Information Seeking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="70" to="77" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Incremental Data Structures and Algorithms for Dynamic Query Interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tanin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Beigel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="21" to="24" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Dynamic Home-Finder: Evaluating Dynamic Queries in a Real-Estate Information Exploration System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Williamson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGIR &apos;92</title>
		<meeting>ACM SIGIR &apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="339" to="346" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
