<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Hierarchy Specification and Visualization Draft</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">M</forename><surname>Wilson</surname></persName>
							<email>rmwilson@cs.unh.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department Kingsbury Hall (33 College Road</orgName>
								<orgName type="institution">University of New Hampshire Durham</orgName>
								<address>
									<postCode>03824</postCode>
									<region>NH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Daniel Bergeron</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department Kingsbury Hall (33 College Road</orgName>
								<orgName type="institution">University of New Hampshire Durham</orgName>
								<address>
									<postCode>03824</postCode>
									<region>NH</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Hierarchy Specification and Visualization Draft</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper describes concepts that underlie the design and implementation of an information exploration system that allows users to impose arbitrary hierarchical organizations on their data. Such hierarchies allow a user to embed important semantic information into the hierarchy definition. Our goal is to recognize the significance of this implicit information and to utilize it in the hierarchy visualization. The innovative features of our system include the dynamic modification of the hierarchy definitions and the definition and implementation of a set of layout algorithms that utilize semantic information implicit in the tree construction.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>As data set sizes continue to increase dramatically, it is becoming increasingly difficult to visualize them effectively. It is essential to be able to extract subsets and define appropriate highlevel abstractions of portions of the data set in order to reduce the active data size to manageable levels. One valuable mechanism for reducing the effective size of a data set is to organize it into a hierarchy. It is possible to create a hierarchy where the leaf nodes contain data and the internal nodes contain conditions that determine the position of the data. Using this structure, the data within a leaf inherits all the properties of its ancestors. Furthermore, visualizing the constructed hierarchy may reveal structure, patterns, and relationships in the data.</p><p>Recent advances in hierarchy visualization such as cone trees <ref type="bibr" target="#b15">[13]</ref>, disc trees <ref type="bibr" target="#b8">[7]</ref>, and 3d hyperbolic trees <ref type="bibr" target="#b14">[12]</ref> have dramatically increased the size of trees that can be effectively rendered. The implementations of these techniques, however, assume that the data set is a "natural" hierarchy that includes no inherent metric interpretation of its structure. In other words, all nodes are created equal. If the hierarchy is, in fact, created by imposing semantic interpretations on data values in the data set, the "default" visualization may lead to incorrect interpretations. In particular, the relative visual appearance of two nodes may not reflect their relative importance for the current task.</p><p>We describe a visualization system that facilitates the exploration of data organized in hierarchies that are designed interactively by the user. User-defined hierarchical structures may help to reduce large data collections into smaller and more manageable subsets. In order to avoid creating meaningless hierarchies, the user should bring domain-specific and taskspecific knowledge to the hierarchy specification. By organizing complex data sets into a semantically meaningful hierarchy, we hope to reveal patterns and relationships among the data, both of which support the process of turning raw data into usable information. It is very often the case that there is considerable semantic knowledge about the expected values for variates in a data set. For example, although a salary field may have legal values from 0 to many millions, it is probably not useful to partition this range into equal sized subranges. Once we use world knowledge to define partition ranges, it is important that the visualizations of the resulting trees reflect (in some manner) the way in which the hierarchy has been defined, or else the visualizations may show patterns that don't really exist and may fail to show significant patterns that are present in the data. To address this problem we have developed a set of layout algorithms that can be tailored to the semantics of the hierarchy specification.</p><p>In some circumstances the definition of partitions that define a hierarchy may be very sensitive to minor changes in the partition boundary definition. In order to explore such a possibility, we have developed a tool for dynamically modifying the partition ranges of any part of the hierarchy specification. As the ranges are modified, the user can view the effect on the visualization-if minor boundary changes cause major display changes, the user will have to do additional exploration to validate the results of the visualization.</p><p>The remainder of this paper presents a brief overview of related work, describes a system that supports interactive user definition of hierarchies, highlights the layout algorithms that support alternative visualizations of user-defined hierarchies, and describes the facilities for dynamic modifications to hierarchy partition boundaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Conventional hierarchy visualizations include the indented list, the 2D node-link diagram <ref type="bibr" target="#b10">[9]</ref>, the horizontal family tree diagram <ref type="bibr" target="#b10">[9]</ref> and the radial tree diagram <ref type="bibr" target="#b11">[10]</ref>. Within the last decade, novel visualization methods have been developed for displaying large hierarchies, including the Treemap <ref type="bibr" target="#b9">[8]</ref>, cone tree <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">13,</ref><ref type="bibr" target="#b16">14,</ref><ref type="bibr" target="#b2">3]</ref>, disc tree <ref type="bibr" target="#b8">[7]</ref>, hyperbolic tree <ref type="bibr" target="#b11">[10]</ref>, and 3D hyperbolic tree <ref type="bibr" target="#b14">[12]</ref> visualizations. The Treemap display <ref type="bibr" target="#b9">[8,</ref><ref type="bibr" target="#b17">15]</ref> consists of a hierarchy mapped onto the full screen, which is accomplished by subdividing the screen space into smaller rectangles, resulting in a node size and location that is a function of both node weight and depth. The cone tree <ref type="bibr" target="#b15">[13,</ref><ref type="bibr" target="#b16">14,</ref><ref type="bibr" target="#b2">3]</ref>, which is a variation of the traditional two-dimensional link-node display, consists of a radial tree layout mapped into a three-dimensional environment. Variations on cone trees include cam trees <ref type="bibr" target="#b15">[13]</ref> and reconfigurable disc trees <ref type="bibr" target="#b8">[7]</ref>. Cam trees are cones trees that use a horizontal rather that a vertical layout. Reconfigurable disc trees are cone trees modified to use discs rather than cones, resulting in an increase of the number of nodes that can be displayed within a single visualization.</p><p>Although the ideas we present in this paper are applicable to any tree visualization technique, our initial prototype system is based primarily on the hyperbolic tree. This visualization technique is a unique solution for displaying thousands of nodes without the large amount of resources required by the cone tree. It was developed in 1994 by Lamping and Rao <ref type="bibr" target="#b12">[11]</ref> and uses a focus+context technique for displaying hierarchies. The hyperbolic tree display consists of a radial tree layout mapped onto a hyperbolic plane, which is then mapped onto a 2D disc with nodes decreasing in size as the radius increases. There is an area of interest located at the center of the disc where magnification of the nodes within this region occurs. The entire hierarchy is always visible. Nodes outside of this area are still visible, although significantly reduced in size. Like the cone tree, structure in the hyperbolic visualization is immediately apparent.</p><p>There are three limiting factors with the existing hierarchical visualization techniques. First, they are limited to data which have an intrinsically hierarchical structure, such as organization charts, taxonomies, and computer file systems. Second, these techniques provide an essentially fixed pre-defined hierarchy visualization not allowing the user to see the data in different arrangements. Finally, current techniques do not attempt to utilize semantic information about how the hierarchy is defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The User-Defined Hierarchy Approach</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>The user-defined hierarchy (UDH) approach provides a method for creating a hierarchical structure from various types of user data for the purpose of information visualization and exploration. Data structured into a UDH may already have intrinsic hierarchical form, in which case the natural hierarchy may be used or a user-defined one may be imposed. Non-hierarchical data, such as temporal, multivariate, and spatial data types, can also be mapped into hierarchical structures.</p><p>User data record descriptions are required to identify field names and types that may be used in constructing hierarchies. From these descriptions, the user can interactively specify fields and conditions on field data to form UDHs. Conditions for levels and nodes within a UDH might include relational and equality operators, string pattern matching operators, and logical operators. The user can specify a variety of conditions for a single data set thereby creating an assortment of UDH descriptions. Each unique description provides a discrete view of the data. Forming various hierarchies creates multiple data views that could aid in highlighting patterns and relationships among the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">UDH Functionality</head><p>We have implemented the UDH concept in a prototype system we call UNHIDES (User-Navigated Hierarchical Interactive Data Exploration System). UNHIDES enables the user to create hierarchy descriptions and render data visually. Prior to defining hierarchy descriptions, a user data record description must be created that registers the name and type for each field with the system. For user convenience, the system allows the interactive entry of field names and field types for the user data record description. Field names identify each field in the data record and are implemented as text strings. Field types determine how the user data is to be represented in memory and what operators are applicable for the field. Various data types are supported by the system, including integer, float, and string.</p><p>Once the user data record description has been created, a hierarchy description can be defined. The hierarchy description builder provides an interactive user interface for defining and editing hierarchy descriptions. Defining a UDH begins by selecting a data field from the user data record description and establishing conditions on it for structuring user data into the hierarchy. This process is iterative and fields may be used more than once.</p><p>Following the process of defining a hierarchy description, the system constructs an internal hierarchy incorporating the user data into it. Subsequently, the system creates and renders one or more simultaneous UDH visualizations that are internally linked. Visualizations could include cone trees, disc trees, hyperbolic trees, 3D hyperbolic trees, tree maps, as well as conventional tree displays. Our initial implementation focuses primarily on hyperbolic tree visualization.</p><p>Navigating and exploring UDHs may be achieved through the use of interactive controls. Navigation controls depend on the particular visualization technique and could include interactions such as rotating, translating, and scaling the view of the hierarchy, as well as providing context between the region of interest and the entire visualization. Exploration interactions could include functionality for data inspection, data filters, and dynamic queries. Other exploratory interactions might include data overviews, multiple visualizations for comparison and contrast, as well as iterative, goal-oriented reconstruction of UDH descriptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">System Overview</head><p>The UNHIDES system enables users to explore data through multiple user-defined hierarchical views. There are three main stages to the UDH creation and exploration process which include input, hierarchy processing, and user interaction. <ref type="figure" target="#fig_0">Figure 1</ref> shows an overview of this process. Stage one, the input stage, reads data, record definitions, and UDH definitions and produces three components used as input for the next stage. Data can be supplied to the system either as a text file or as a database query result. Text file input contains a data set with one data record per line. A record definition must also be supplied in the form of another text file, which contains field name, type, and delimiter definitions. Database input is supported through the use of the JDBC API, which provides an SQL interface from the system to a database. Record definitions are provided automatically by the DBMS as a result of an SQL statement execution. A UDH can be supplied to the system by using the system's UDH editor or by reading a previously defined one that is stored in a text file.</p><p>Stage two is where the hierarchy processing occurs. Hierarchy processing is supported through a software subsystem that provides for hierarchy creation, data integration, and visualization production. A hierarchy is created as specified by the UDH description from the input stage, which contains level descriptions. Once created, data is then populated into the hierarchy according to conditions at each level. Upon completion of hierarchy creation and data integration, a visualization is produced and presented to the user.</p><p>It is in stage three that the user can interact with the system and explore the data by changing hierarchy layouts, refining partitions, and modifying hierarchy levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Visualization Features</head><p>Visualization features include dynamic hierarchy layout, graphical data distributions, edge and node coloring, and node labeling. Hierarchy layout and data distributions are discussed in subsequent sections. Edge coloring provides a method for coloring edges based on the proportion of nodes within a subtree. Subtrees with a large number of data nodes are assigned a higher color intensity than those of a lower number of data nodes. Coloring can be based on both local and global node information.</p><p>A data node contains a data record and can display any field within that record according to a user-defined active field. The active field is used for node labeling, coloring, sorting, and UDH statistics. Labels can be toggled on and off. Nodes can be colored according to their active field value with respect to the local or global data range; they can also be sorted into ascending and descending order. By default, UDH nodes display their partition information, but can also display a variety of statistics relative to the active field, such as mean, median, standard deviation, and range.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Hierarchy Layout Algorithms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview</head><p>Once a UDH has been created and populated with data, a spatial layout algorithm must then process it to create a layout that can be used in the course of creating a hierarchy visualization. UNHIDES uses a hyperbolic tree <ref type="bibr" target="#b12">[11]</ref> for its main display, which requires that all locations be calculated in a radial fashion along an arc with respect to depth in the tree and to an interior point where the root node resides. Given a UDH, a spatial layout algorithm traverses the tree and calculates an x, y location for each node, resulting in a layout coordinate set consisting of coordinates paired with nodes. When calculating each nodecoordinate pair, consideration is given to the distance a node is from its parent, siblings, and other neighbors. Pairs within the layout coordinate set are used by the visualization algorithm to generate an output hierarchy visualization. There is no distinction between calculating locations for data nodes and internal nodes. Using different spatial layout algorithms can have a dramatic effect on how the hierarchy appears in the final visualization. This effect is clearly evident using the Treemap algorithm <ref type="bibr" target="#b9">[8,</ref><ref type="bibr" target="#b0">1]</ref> which uses weights derived from node content to determine the visual size of the node's representation. We call this an attribute-based layout and apply it to the hyperbolic tree display in UNHIDES.</p><p>In addition to an attribute-based layout, UNHIDES supports four other layout algorithms: leaf-based, subnode-based, rangebased, and density-based that are described in detail in this section. In all four layout algorithms, positions are calculated for each node based on radius and on arc center. A node's radius value is obtained via a lookup table according to its depth within the hierarchy. This table contains increasing values from 0.3 to 1.0 and has the effect of positioning nodes closer together at upper levels within the hierarchy. Radius values at depth d, denoted as rd, are calculated as follows:</p><formula xml:id="formula_0">rd = ∑ = d i i e radiustabl 1 ] [</formula><p>A node's arc center is calculated using metric and region variables. The metric variable defines a value corresponding to the proportion of space that a node can occupy. The region variable defines a value calculated using the metric and indicates a node's arc definition, at the center of which the node is located.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Layout Algorithm Selection</head><p>In this section, we explore and illustrate the use of each layout algorithm with a focus on its merits and on how it can contribute toward achieving data exploration goals. One key goal involves finding data clusters, which can reveal relationships among variates within a UDH. Data within a UDH might be part of a data group or part of a data cluster. A data group is set of data nodes with a common parent, while a data cluster is a data group that embodies some semantic cohesiveness. Throughout the data exploration process, user goals could include any of the following objectives:</p><p>• Find data clusters • Observe data distribution within the hierarchy • Differentiate data groups from data clusters • Detect outliers • Observe conditions matching no data records</p><p>The four layout algorithms typically provide different layout configurations that can then be used to produce different visualizations for a given data set. Each distinct visualization presents an opportunity for the user to gain further insight into the data set.</p><p>In order to illustrate the effect a layout algorithm has on the hierarchy visualization, a real-world data set is used throughout the examples within this section. The data set used here consists of 40 data records retrieved from a stock market quote service <ref type="bibr" target="#b3">[4]</ref> and contains information relating stock requests for a single day (see www.cs.unh.edu/~rdb/unhides/sdata98.html for a copy of this data). A three level UDH is constructed from this data set based  on the stock requests, price change, and trading volume fields. The detailed UDH description is shown in <ref type="figure" target="#fig_2">Figure 2</ref>, where levels are described using a name and data type, along with one or more partitions. Partitions are described using a 3-tuple format with minimum, maximum, and partition count parameters, respectively. From the description in <ref type="figure" target="#fig_2">Figure 2</ref>, R represents stock requests, C represents price change, and V represents trading volume. The first level is defined using the stock requests field, which ranges in value from 6 to 51. Level two is based on price change, which ranges in value from −11.25 to 2.94. The last level is based on trading volume, which ranges in value from 1,600 to 10,101,300.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Leaf-Based Layout</head><p>The first layout algorithm is called the leaf-based layout algorithm and was provided as the default layout in the hyperbolic tree library <ref type="bibr" target="#b5">[5]</ref> used in this research. With this algorithm, each leaf node is given an equal amount of space on the circumference of the visualization. Construction of this layout is accomplished from the bottom up starting with leaf nodes. Thus, a requirement of this algorithm is that all internal UDH nodes must contain at least one child. To satisfy this condition, any terminal UDH node without a child leaf is allocated space for an invisible child for use in the layout algorithm.</p><p>All visible and invisible leaves are located uniformly along the circumference of the layout. The calculation for the radius, r, of each leaf arc is: r = 2π/(count(data nodes)+count(childless UDH nodes)).</p><p>The calculation of an internal node's arc center is based on the center arc of its children. For terminal UDH nodes without children, the arc center is based on a single invisible child along the circumference. The resulting layout is such that large numbers of data nodes occupy large regions, whereas a small number of data nodes occupy small regions. Both of these properties hold, regardless of the range conditions that define the partitions.</p><p>The leaf-based layout has the property that each leaf node is given an equal amount of space on the circumference of the visualization. This property has the visual effect of giving all individual data nodes equal weight. This can help the user to perceive how data is distributed within the hierarchy; subhierarchies containing large numbers of data nodes occupy more space than subhierarchies with few nodes. <ref type="figure" target="#fig_1">Figure 3</ref> shows the stock market data set using the leaf-based layout, where the distribution of data nodes can be seen. From this visualization, it is immediately apparent that subtree R1 has many more nodes than subtrees R2 or R3. Notice that terminating UDH nodes without children are allocated space for an invisible data node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Subnode -Based Layout</head><p>The subnode-based layout algorithm divides space evenly among nodes at each internal level within a subhierarchy. Terminal UDH nodes containing no children are allocated the same amount of space as each of their siblings. Construction of this layout, as well as the next two layout types, is accomplished from the top down starting at the root node. A node's arc is calculated based on its parent arc divided evenly among its children. That is, if a node has four children, the arc allocated to the parent is divided into four equal-sized subranges, one for each child. This calculation can be broken down into two parts, the proportion metric and the node region: metric = 1 / count(parent's subnodes) region = parent region * metric As a result of the subnode-based layout, the hierarchy branches at regular intervals and its structure is natural and easy to see. <ref type="figure" target="#fig_3">Figure 4</ref> shows a stock market data visualization produced using this layout algorithm. Notice how the uniform division of space among subnodes within the visualization provides a clear and natural way to see the hierarchy structure. Subhierarchies R1, R2, and R3 are all allocated the same amount of space; each of the data node groups are also allocated the same amount of space. The latter property has the effect of conspicuously isolating outliers within the visualization enabling them to be easily noticed by the user. Regions containing no data whatsoever are also manifest. Another benefit of the subnode-based layout algorithm is that layout uniformity provides for an ideal hierarchy layout to compare different data sets under the same conditions. This is also true of the range-based layout. Both of these layout algorithms have the property that the numbers of leaves within a subhierarchy do not affect how the basic hierarchy is shown.</p><p>Although there are many benefits to the subnode-based layout algorithm, finding data clustering can sometimes be problematic because all nodes on a particular level within a branch are uniform and equally spaced. This is often appropriate if the partitions cover equal sized ranges and the fundamental semantics associated with the data supports the equal range partitioning. However, consider the case where one node has a large range condition and another has a small range condition, yet they both have the same large number of data nodes. Here, they both have a similar appearance in the visualization, such as the two potential clusters at the right in <ref type="figure" target="#fig_3">Figure 4</ref>, and a cluster might go unnoticed without careful scrutiny by the user. Partition changes can also go unnoticed within the visualization due to the uniform layout.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Range-Based Layout</head><p>The range-based layout algorithm divides space proportional to the size of the range value associated with each node. Nodes with a large range value occupy a greater amount of space than those with a small range value. Clusters appear as dense groups of data nodes that occupy a small region within the visualization. The metric and region values are calculated for each node as follows: metric = range / sum(sibling range) region = parent region * metric As a result of the range-based layout, the hierarchy branches containing a large range value are given a large amount of space. Consider that a cluster can be identified by a large number of nodes that lie within a small range. The issue of identifying clusters can be overcome now that space is being used in the layout to conform to a node's range condition. Clusters appear as dense groups of data nodes that occupy a small region within the visualization.</p><p>This algorithm works particularly well with hierarchies in which the range among sibling nodes varies significantly; it does not provide a substantially different layout than the subnodebased layout in the case where the range of nodes are approximately the same size. Dynamic partition changes made by the user are noticeable within the visualization by the reallocation of space for the hierarchy. <ref type="figure" target="#fig_4">Figure 5</ref> shows a range-based stock market data visualization. Notice the data clusters in the left branches of subtrees R1 and R2 and how they appear tightly grouped together. Also notice how much space is allocated to R3 due to its large range.</p><p>A primary user goal involves finding data clusters. Using the rangebased layout algorithm with a data set containing data clusters, those clusters can be made visible as a set of densely grouped data nodes within a small region. However, because data clusters are given less space within the visualization than larger-range nodes, it might become difficult to easily separate adjoining clusters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Density-Based Layout</head><p>The density-based layout algorithm divides space using a density metric. Nodes with a high density occupy a greater amount of space than those with a low density. Density is computed as the number of data nodes within a subtree divided by the range of that subtree. Clusters appear as groups of data nodes that occupy a large region within the visualization. The density, metric, and region values are calculated for each node as follows: density = count(subtree data nodes) / range metric = density / sum(level(density)) region = parent region * metric</p><p>In the resulting layout, subtrees with a high density occupy more space than those with a low density. Another property of this layout is that neighboring UDH terminal nodes containing no children converge to a single location. By applying the density metric to the layout, denser subtrees, which are likely to contain clusters, are given a larger proportion of space within the visualization. A potential cluster is now identified as a single group of leaf nodes that occupies a large arc space. The resulting visualization also helps to separate neighboring clusters. <ref type="figure" target="#fig_5">Figure 6</ref> shows a density-based stock market data visualization. The two potential clusters that are quite evident in the four and five o'clock positions of the range-based visualization shown in <ref type="figure" target="#fig_4">Figure 5</ref> and in the two and four o'clock positions of the subnode-based visualization shown in <ref type="figure" target="#fig_3">Figure 4</ref> have moved in <ref type="figure" target="#fig_5">Figure 6</ref> to the ten and twelve o'clock positions and are now distinguished as one data group and one data cluster. The five-node group at the twelve o'clock position is, in fact, a cluster since it spreads out over a relatively wide range. In contrast, the six-node group at the ten o'clock position occupies relatively little space, so it is not likely to be a significant cluster. Furthermore, a two-node cluster, which up to this point remained hidden, is now made evident within subhierarchy R1 on the right side of the visualization. Because of subhierarchy R1's considerable density, it is allocated the most space within the visualization, about two-thirds of the total space. Also notice that because of subhierarchy R2's low density, it is allocated the least amount of space.</p><p>Contrast this visualization with the one in <ref type="figure" target="#fig_4">Figure 5</ref>. The dense packing of potential clusters in <ref type="figure" target="#fig_4">Figure 5</ref> is immediately visually apparent, but it is not necessarily clear that these "obvious" visual patterns are true clusters. The layout of <ref type="figure" target="#fig_5">Figure 6</ref> requires more careful inspection, but also yields more conclusive results. These observations suggest that a series of visualizations may be the most effective exploration tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Dynamic Blending Metric</head><p>As shown in the previous section, user goals for data exploration can be achieved by using different layout algorithms to create visualizations targeted to achieve goal-related objectives. However, each algorithm produces a fixed layout according to a given data set and UDH description. Furthermore, it is possible for the user to create partitions where the range values or density values are significantly skewed. Under such conditions, it may be best to use either the subnode-based or the density-based layout algorithm or some combination of the two. A blending algorithm can be used to calculate a metric that reflects percentages of both the subnode and density metrics. Both layout algorithms can then be used proportionately according to the blending metric. For example, the density-based and subnode-based layout algorithms could be combined as follows:</p><p>Let blend = 0.5 metric = blend * density + (1 -blend) * subnode region = parent region * metric  After applying a blending metric of 0.5 to the density and subnode metrics, the region metric is weighted with a 50% contribution from each algorithm. As the blending parameter increases, more weight is given to the density metric; as it decreases, more is given to the subnode metric. The region metric can be applied to a node subsequent to the even division among siblings that initializes each layout algorithm. <ref type="figure" target="#fig_6">Figure 7</ref> shows a visualization sequence using algorithm blending with the subnode-based and density-based algorithms. There are five different visualizations at various stages of a blending progression. <ref type="figure" target="#fig_6">Figure 7a</ref> was created using 100% of the subnodebased layout algorithm and 0% of the density-based layout algorithm, while <ref type="figure" target="#fig_6">Figure 7e</ref> was created using the 100% of the density layout algorithm and 0% of the subnode-based layout algorithm. <ref type="figure" target="#fig_6">Figures 7b, 7c, and 7d</ref> show blending of the subnodebased and density-based algorithms at ratios of 75:25, 50:50, and 25:75. Notice how it becomes increasingly apparent through the visualization sequence that the group of data nodes at the nine o'clock position in <ref type="figure" target="#fig_6">Figure 7a</ref> is a significant cluster as shown in <ref type="figure" target="#fig_6">Figure 7e</ref>. There are two more clusters that are revealed at the right and at the top of <ref type="figure" target="#fig_6">Figure 7e</ref>. Also note the potential cluster at the three o'clock position in <ref type="figure" target="#fig_6">Figure 7a</ref> is revealed to be a data group (not a cluster) at the 10 o'clock position in <ref type="figure" target="#fig_6">Figure 7e</ref>.</p><p>Adding a blending factor to a composition of layout algorithms provides support for enabling continuous variation in a layout algorithm's contribution to the final visualization. Moreover, by providing support for the blending factor at runtime through a continuously-variable, user-controlled slider, the dynamic layout algorithm allows the user to effect dramatic changes in the hierarchy appearance in a smooth progression of layout changes. Thus, the user can search for clusters or search for other patterns by using the subnode-based, range-based, or density-based algorithms or by using a dynamic layout created by combining any two algorithms together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Partition Definition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Dynamic Partitions</head><p>A convenient method for defining and editing partitions is through the use of graphical dynamic partition sliders (GDPS). A GDPS display is similar in form to Eick's data visualization slider <ref type="bibr" target="#b7">[6]</ref>; it contains information for each data value within a field paired with its index into the unordered data set. GDPSs support dynamic revision for partitions using direct manipulation of boundaries represented in a graphical data distribution chart that depicts the distribution. Results from partition revisions are immediately reflected in the hierarchy visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Partition Definition with GDPSs</head><p>There are two different types of GDPSs: ordered and unordered. An ordered GDPS is created by using a set of data values sorted into ascending order and partition descriptions as input to create a data chart visualization like the ones shown in <ref type="figure" target="#fig_7">Figures 8a, 8b</ref>, and 8d. Data is depicted as connected points in a chart where the horizontal axis indicates data indexes on a counting scale and the vertical axis indicates the full range of data values on a value scale.</p><p>Partitions are depicted in the graphs as vertical lines within the ordered displays and as horizontal lines in the unordered displays. A partitioning scheme can be either complete or partial. In the complete range scheme, the full data range is broken into a contiguous set of partitions. Partial range partitions provide support for creating non-contiguous partitions. By using noncontiguous partitions, the user can filter data by excluding it from the set of defined partitions. <ref type="figure" target="#fig_7">Figure 8a</ref> shows a GDPS using the complete range partition scheme, where there is a user-defined partition boundary in the center at data index 8, which contains the value 5.28. When using the complete range partitioning scheme, fixed partition boundaries are always defined at the left and right chart extremes. <ref type="figure" target="#fig_7">Figure 8b</ref> shows partitions defined using the partial range partition scheme with two partitions defined on indexes 6 through 9 and 12 through 15. The disjoint partitions are shown as shaded region within the graph.</p><p>An unordered GDPS is created by using an unordered set of data values and partition descriptions as input to create a data chart visualization like the one shown in <ref type="figure" target="#fig_7">Figure 8c</ref>. In this figure,  data values are displayed according to their associated index values, which are in a sequentially increasing order. Also note that the partition boundary is shown as a horizontal line across the unordered data graph. Graph coloring associates a color for each value according to its index value and is colored from dark to light as indexes increase in value. Data indexes in the unordered display are in increasing order from 0 to n, where n is the total number of data elements minus one. <ref type="figure" target="#fig_7">Figure 8c</ref> shows the unordered data set with index coloring, where dark color values have low indexes and light color values have high indexes. Data index coloring is also shown in figure 8d, which shows a graph of the ordered data set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Interactive Partition Modification</head><p>User interactions supported by a GDPS include revising, adding, and removing partition boundaries. Revising a boundary is accomplished by "dragging" the boundary to a new location using a mouse. Throughout the boundary revision process, the visualization is updated immediately with each new position. New boundaries can be added and old boundaries deleted by simple interactions. Upon completion of any of these tasks, the hierarchy is modified to correspond to the structural change, repopulated with data, and redisplayed in the hierarchy visualizations. Additionally, the index coloring can be turned on and off.</p><p>The GDPS has several advantages over the UDH editor in terms of partition definition. The visual aspect of a GDPS allows the user to see the data distribution for hierarchy levels in both ordered and unordered forms. This can facilitate definitions of effective partitions. For example, in the ordered GDPSs, partitions defined over flatter sections of a distribution, in which values lie within a small range, are more likely to yield data clustering than other partitions. The dynamic nature of the graphical slider provides a method for the user to use direct manipulation to modify the hierarchy through partition changes. Moreover, the GDPS supports immediate visualization updates for revisions that provide timely feedback to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Our user-defined hierarchies help to reduce a data set into smaller subsets that are more manageable and to reveal patterns within a data set such as clustering. The semantic interpretation that underlies a user defined hierarchy can lead to inappropriate visualization using existing hierarchy visualization techniques. Our implementation of user-defined hierarchies, called UNHIDES, addresses this problem by providing multiple hierarchy layouts, layout blending, and dynamic partition adjustment, all of which help the user to find patterns within data.</p><p>In future research, we would like to compare the results from statistical clustering techniques to results from user-defined hierarchies for some given data sets. Statistical clustering results could provide a starting point from which to define hierarchies, whereupon the user could refine the hierarchy in accordance with world knowledge of the data. We would like to adapt our ideas to other tree visualization algorithms, such as cone trees, disc trees, and 3d hyperbolic trees. Other possibilities include refinements to the UNHIDES system such as supporting a user-controllable filtering mechanism used for pruning branches with few data nodes, coloring nodes that incurred a parent change during a partition refinement, and providing a preview of data movement prior to an actual partition change.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Overview of the UDH creation and exploration process.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Visualization created using leaf-based layout for stock market data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2</head><label>2</label><figDesc>level = C type = float partition = (-20.0, 20.0, 2.0) level = V type = integer partition = (1600, 2285200, 1) partition = (2285200, 2988200, 1) partition = (2988200, 10101300, 1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Visualization created using subnode-based layout for stock market data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Visualization created using range-based layout for stock market data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Visualization created using density-based layout for stock market data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>The dynamic algorithm blending was used to create this sequence of stock market visualizations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>A data set of 16 values displayed using four different graphical dynamic partition sliders. (a) Ordered data with complete range partitions (b) Ordered data with partial range partitions (c) Unordered data with complete range partitions and index coloring (d) Ordered data with complete range partitions and index coloring</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Using Treemaps to Visualize the Analytic Hierarchy Process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Asahi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Turo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="357" to="375" />
			<date type="published" when="1995-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Information Visualizer, An Information Workspace</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCHI&apos;91 Conference on Human Factors in Computing Systems</title>
		<meeting>the ACM SIGCHI&apos;91 Conference on Human Factors in Computing Systems<address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-04" />
			<biblScope unit="page" from="181" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Research Report Interacting with Huge Hierarchies: Beyond Cone Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Carriere</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Information Visualization&apos;95</title>
		<meeting>Information Visualization&apos;95<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-10" />
			<biblScope unit="page" from="74" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m">Top Stocks</title>
		<imprint/>
	</monogr>
	<note>On-line</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stockmaster</surname></persName>
		</author>
		<ptr target="http://www.stockmaster.com/wc/form/P1?template=sm/topstocks" />
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ebi Hyperbolic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Viewer</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>On-line</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<ptr target="http://industry.ebi.ac.uk/~alan/components" />
	</analytic>
	<monogr>
		<title level="j">European Bioinformatics Institute</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data Visualization Sliders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of UIST&apos;94, ACM Symposium on User Interface Software and Technology</title>
		<meeting>eeding of UIST&apos;94, ACM Symposium on User Interface Software and Technology<address><addrLine>Marina del Rey, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="119" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Reconfigurable disc trees for visualizing large hierarchical information space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Information Visualization</title>
		<meeting>Information Visualization</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page">149</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Tree-maps: A Space Filling Approach to the Visualization of Hierarchical Information Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization&apos;91 Conference</title>
		<meeting>IEEE Visualization&apos;91 Conference<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming: Fundamental Algorithms, Third Edition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="page" from="308" to="316" />
			<pubPlace>Reading, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Focus+Context Technique Based on Hyperbolic Geometry for Visualizing Large Hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pirolli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI &apos;95 ACM Conference on Human Factors in Computing Systems</title>
		<meeting>CHI &apos;95 ACM Conference on Human Factors in Computing Systems<address><addrLine>Denver, CO; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM press</publisher>
			<date type="published" when="1995-05" />
			<biblScope unit="page" from="401" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Laying Out and Visualizing Large Trees Using a Hyperbolic Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rao</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">94</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Proceedings</title>
		<imprint>
			<biblScope unit="page" from="13" to="14" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Exploring Large Graphs in 3D Hyperbolic Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Munzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="18" to="23" />
			<date type="published" when="1998-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Cone Trees: Animated 3D Visualizations of Hierarchical Information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCHI&apos;91 Conference on Human Factors in Computing Systems</title>
		<meeting>ACM SIGCHI&apos;91 Conference on Human Factors in Computing Systems<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="189" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Information Visualization Using 3D Interactive Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mackinlay</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="57" to="71" />
			<date type="published" when="1993-04-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Designing the User Interface: Strategies for Effective Human-Computer Interaction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="page" from="510" to="544" />
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>third edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Eyes Have It: A task by Data Type Taxonomy for Information Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1996 IEEE, Visual Languages</title>
		<meeting>1996 IEEE, Visual Languages<address><addrLine>Boulder, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="336" to="343" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
