<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cushion Treemaps: Visualization of Hierarchical Information</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarke</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huub</forename><surname>Van De Wetering</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Eindhoven University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Cushion Treemaps: Visualization of Hierarchical Information</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.5.2 [Information Interfaces and Presentation] -User Interfaces</term>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques -Interaction techniques</term>
					<term>I.3.8 [Computer Graphics]: Applications Information Visualization, Tree Visualization, Treemaps</term>
				</keywords>
			</textClass>
			<abstract>
				<p>A new method is presented for the visualization of hierarchical information, such as directory structures and organization structures. Cushion treemaps inherit the elegance of standard treemaps: compact, space-filling displays of hierarchical information, based on recursive subdivision of a rectangular image space. Intuitive shading is used to provide insight in the hierarchical structure. During the subdivision ridges are added per rectangle, which are rendered with a simple shading model. The result is a surface that consists of recursive cushions. The method is efficient, effective, easy to use and implement, and has a wide applicability.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Hierarchical structures of information are ubiquitous: family trees, directory structures, organization structures, catalogues, computer programs, etcetera. Small hierarchical structures are very effective to locate information, but the content and organization of large structures is much harder to grasp.</p><p>We present a new visualization method for such large hierarchical structures: Cushion Treemaps. The method is based on treemaps, developed by Shneiderman and Johnson <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b7">8]</ref>. Treemaps are efficient and compact displays, which are particularly effective to show the size of the final elements in the structure. Cushion Treemaps provide shading as a strong extra cue to emphasize the hierarchical structure. For a quick impression, figure 3 and 4 show treemaps, figure 7 and 8 show the corresponding cushion treemaps.</p><p>In section 2 we discuss existing methods to visualize hierarchical structures. The new method is presented in section 3. The em- * Eindhoven University of Technology, Dept. of Mathematics and Computing Science, P.O. Box 513, 5600 MB Eindhoven, The Netherlands. E-mail: fvanwijk, wstahwg@win.tue.nl bedding of the method in an interactive system for tree visualization is described in section 4. Finally, we discuss extensions and alternatives in section 5, and we summarize the results in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>Many methods exist to browse through and to display hierarchical information structures, or, for short, trees. File browsers are the best known example. Usually a listing of the files and directories is used, where the levels in the hierarchy are shown by means of indentation. The number of files and directories that can be shown simultaneously is limited, which is no problem if one knows what to search for. However, if we want to get an overview, or want to answer a more global question, such as: "Why is my disk full?", scrolling, and opening and closing of subdirectories have to be used intensively. During this process it is hard to form a mental image of the overall structure <ref type="bibr" target="#b2">[3]</ref>.  <ref type="figure" target="#fig_0">1</ref>). Elements are shown as nodes, relations are shown as links from parent to child nodes. Sophisticated techniques have been presented to improve the efficiency and aesthetic qualities of such diagrams, both in 2D and in 3D <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b9">10]</ref>. Such diagrams are very effective for small trees, but usually fall short when more than a couple of hundred elements have to be visualized simultaneously. The main reason for this limitation is simply that node and link diagrams use the display space inefficiently: Most of the pixels are used as background. Treemaps <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b7">8]</ref> were developed to remedy this problem. The full display space is used to visualize the contents of the tree. Here we  <ref type="figure" target="#fig_1">Figure 2</ref> shows an example. Each node (as shown in the tree diagram) has a name (a letter) and an associated size (a number). The size of leaves may represent for instance the size of individual files, the size of non-leave nodes is the sum of the sizes of its children. The treemap is constructed via recursive subdivision of the initial rectangle. The size of each sub-rectangle is proportional to the size of the node. The direction of subdivision alternates per level: first horizontally, next vertically, etcetera. As a result, the initial rectangle is partitioned into smaller rectangles, such that the size of each rectangle reflects the size of the leaf. The structure of the tree is also reflected in the treemap, as a result of its construction. Color and annotation can be used to give extra information about the leaves.</p><p>Treemaps are very effective when size is the most important feature to be displayed. <ref type="figure" target="#fig_2">Figure 3</ref> shows an overview of a file system: 1400 files are shown and one can effortlessly determine which are the largest ones. Labels are not shown here, but can be shown interactively by pointing at the areas of interest.</p><p>However, treemaps have limitations <ref type="bibr" target="#b3">[4]</ref>. The problem addressed here is that treemaps often fall short to visualize the structure of the tree. The worst case is a balanced tree, where each parent has the same number of children and each leaf has the same size. The treemap degenerates here into a regular grid. Indeed, leaves that are close in the tree are also close on the screen, but the reverse is not always true. As an example, <ref type="figure" target="#fig_3">figure 4</ref> shows an (artificial) organization chart, modeled after the structure of our university. The university has seven faculties, subdivided into departments, which in turn are divided into sections. Each section is divided into units. Each unit contains four different types of staff members (full, associate, and assistant professor, PhD-student). The final 3060 rectangles denote individual employees. Questions such as "What is the largest section?" or "Is the division into units balanced?" are hard to answer from such an image.</p><p>Nested treemaps <ref type="bibr" target="#b7">[8]</ref> are a partial remedy. During the subdivision process instead of the initial rectangle a slightly smaller rectangle is used, such that each group of siblings is enclosed by a margin. However, this consumes screen space and the visual interpretation, especially for deeply nested trees, requires effort from the viewer. The variation of properties of the surrounding lines is another option. However, the number of steps in linewidth or intensity that can be discerned without effort is small, and also here the user is required to trace lines in a maze-like image. Coloring the rectangles would not work either. Color does not provide a natural hierarchical structure, and furthermore, we want to use color to show other One alternative has not been exploited yet: The use of shading to visualize the structure. In the remainder of this paper we will show how this can be done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CUSHION TREEMAPS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Method</head><p>How can we use shading to show the tree structure? The human visual system is trained to interpret variations in shade effortlessly as illuminated surfaces <ref type="bibr" target="#b5">[6]</ref>. Hence, we can answer the question by constructing a surface which shape encodes the tree structure.  We introduce our solution with a simple one-dimensional example: binary subdivision of an interval. First, we subdivide the interval and add a bump to each of the two sub-intervals. Next, we repeat this step recursively. To each new sub-interval we add a bump again, with the same shape but half of the size of the previous one. If we do this for three levels, the results are eight segments and the topmost curve in figure 5. If we interpret this curve as a side view of a bent strip, and render it as viewed from above, the bumps transform into a sequence of ridges ( <ref type="figure" target="#fig_5">fig. 6</ref>). The separate segments are clearly visible, each is bounded by the sharp discontinuities in the shading. Furthermore, also the binary tree structure is clearly visible, because the depth of the valleys between the segments is proportional to the distance between segments in the tree.</p><p>We can generalize this idea to the two-dimensional case. Suppose that the x-axis is horizontal, the y-axis is vertical, and that the z-axis points towards the viewer. If we subdivide the rectangle in the x-direction, we add ridges aligned with the y-direction, and vice versa for subdivision in the y-direction. As a result, cushions are generated: The summation of orthogonal ridges gives a cushionlike shape. Numerically, the simplest bump that can be used is a parabola, hence for each rectangle of the treemap we use a segment of a parabolic surface. The height z of such a surface is given by z(x, y) = ax 2 + by 2 + cx + dy + e.</p><p>Initially, the surface is flat, all coefficients are zero. Consider now a new rectangle which results from subdivision along the x-axis. The ridge z we add is:</p><formula xml:id="formula_1">z(x, y) = 4h x 2 − x 1 (x − x 1 )(x 2 − x),<label>(2)</label></formula><p>where x 1 and x 2 are the bounds of the rectangle in the x-direction. The height of this ridge is 0 for x = x 1 and x = x 2 , and equal to (</p><formula xml:id="formula_2">x 2 − x 1 )h in the center (x 1 + x 2 )/2.</formula><p>The parameter h denotes the height proportional to the width, hence it controls only the shape of the ridge. The ridge z in (2) does not depend on y, the bump has the same shape at each cross section y = C. Subdivision along the y-axis is done similarly, here the ridge z that is added is:</p><formula xml:id="formula_3">z(x, y) = 4h y 2 − y 1 (y − y 1 )(y 2 − y).<label>(3)</label></formula><p>The same value for h for each level of the tree gives a self-similar surface. A decreasing value for h is useful to emphasize the global structure of the tree. A convenient solution is to use:</p><formula xml:id="formula_4">h i = f i h (4)</formula><p>where h i is the actual value of h at level i, and f a scale factor between 0 and 1. For the shading of the geometry a simple model, i.e. diffuse reflection, suffices <ref type="bibr" target="#b4">[5]</ref>. The normal n follows from:</p><formula xml:id="formula_5">n = [1, 0, ∂z/∂ x] × [0, 1, ∂z/∂ y] = [−∂z/∂ x, −∂z/∂ y, 1] = [−(2ax + c), −(2by + d), 1]. (5)</formula><p>The intensity I is then given by:</p><formula xml:id="formula_6">I = I a + I s max(0, n•l |n||l| )<label>(6)</label></formula><p>where I a is the intensity of ambient light, I s is the intensity of a directional light source, and l is a vector that points towards this light source.</p><p>Results of this method are shown in figure 7 and figure 8: a cushion treemap of the file system, and three cushion treemaps of the organization, with different values for the scale factor f . All images have a resolution of 640×480 pixels. If we compare these with the treemap versions, it is clear that the shading provides a strong cue for the hierarchical structure: substructures can be identified effortlessly. With the scale factor f a continuous trade off between the visualization of global and detailed information can be made.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Algorithm</head><p>With the ingredients supplied in the previous section, the complete algorithm can be derived. We present it here in full detail, not because of its complexity, but to show its simplicity. First, we define a few data types. The directions X and Y are encoded via arrayindexing to enable a compact algorithm. The surface is described by its linear and quadratic coefficients for the X-and Y-direction. For a Surface s the coefficients a, b, c, and d of equation <ref type="formula" target="#formula_0">1</ref> The procedure CTM generates the cushion treemap recursively, following the same lines as the original treemap algorithm. The main extension is that during the generation of the rectangles the surface s is constructed. The surface is bent in the direction d. If the tree is a leaf, the cushion is rendered, else the direction is changed and its children are visited. The height h is updated according to equation (4). The main input for CTM consists of the root of the tree to be rendered, the initial rectangle to be used, and settings for h and f . A simple driver routine: If in CTM a leaf node has to be rendered, RenderCushion is called. The rectangle, defined in continuous space, is scan converted via sampling the centers of the pixels that fall within the rectangle. The intensity of a pixel is calculated according to equation <ref type="bibr" target="#b4">(5)</ref> and <ref type="bibr" target="#b5">(6)</ref>. A straightforward implementation is given below. For clarity, no optimization is applied here. Early outs (if the rectangle does not cover the center of any pixel), a priori calculation of common subexpressions, removal of constant sub-expressions out of the loops and incremental evaluation of the quadratic expression can easily be added. Other extensions are the rendering of lines that separate the rectangles and the use of color to visualize some property of the leaf. The fixed settings used here for the light source give good results. The frontal light is slightly offset to the right and to above: This concludes the presentation of the complete algorithm. It shows that cushion treemaps can be easily implemented in a compact way.</p><formula xml:id="formula_7">l = [1, 2, 10].</formula><p>Presentation of hierarchical structures is only one aspect, for effective visualization of such structures interaction is equally important. We have embedded cushion treemaps in SEQUOIAVIEW, our interactive system for the analysis and visualization of large tree structures. The cushion treemaps are generated with a slightly extended version of the previous algorithm. This takes less than a second on an SGI O2, even for larger images and trees. Upon each interaction the image is copied to the screen, annotation is overlaid, selected rectangles are colored by superimposing transparent rectangles. Various coloring options are available, to show the size, the level, and other attributes of the leaves. Regeneration of the image is done only if the tree or one of the image parameters change. Many options are provided for navigation and selection. The user can click on rectangles, upon which the properties of the leaf are displayed in a separate window. The current node is highlighted with a red outline. The arrow keys can be used to select siblings (left, right), the parent (up) and the first child (down). The selected elements are continuously updated and highlighted, which enables fast and accurate navigation. Elements within a user-defined size range can be selected, and elements can be selected by matching their name with regular expressions. The user can zoom in on subtrees, and zoom out again.</p><p>SEQUOIAVIEW has been used now for various applications: file systems, organization charts, lexical parse trees, and software structures. The cushion treemaps, supported by multiple options for navigation and selection, turned out to be highly effective. <ref type="figure" target="#fig_11">Figure 9</ref> shows an example of an interactive session: inspection of a trie. A trie is a data structure that stores elements in a tree, where the path from the root to the leaf is described by the key. As an example: A record with the key hello is stored in /h/e/l/l/o/hello, using directory notation. A trie is very useful to store information using words or strings as keys; the retrieval time is proportional to the length of the word and the density of the trie.</p><p>Here we zoomed in on a subset of a trie with Dutch words. All 2200 words that start with the letter p and that are up to eight letters long are shown. Within this trie, words that contain the letter o are selected and highlighted with color. The color indicates the level in the trie, which corresponds here to the word length: from blue (two letters) to red (eight letters). Some representative words are labeled. From the image we see for instance that the letters a and o occur most often as the second letter, because the words that start with pa and po form the largest horizontal bands. Also, we see that pro is an often occurring prefix, because those words form a large block. Furthermore we see, not surprisingly, that the earlier the letter o occurs in a word, the stronger the clustering in the trie with other words that contain an o. Words that have an o as second letter form a single band, while words like patio are isolated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>Both simpler and more complex variants of the cushion treemap presented here are conceivable. We consider both here to show that the version presented is optimal, in the sense that these variants are no improvements.</p><p>We have chosen to use a geometric model, which is shown as a shaded surface viewed from above. We could also have used a direct, 2D model for the shading. This could lead to a more efficient algorithm, without the normalization of the normal per pixel. For instance, the value of z(x, y) as defined before could directly denote an intensity. However, such a simple model does not work satisfactorily. The result is that each rectangle is filled with an ellipseshaped spot. More sophisticated 2D models could work, but their control is cumbersome, when compared to the intuitive model with two parameters (h, f ) presented here. The use of a geometrically based shading leads automatically to an image that is easy to interpret. Another option is to view the surface from an oblique angle (figure 10). This leads to odd pictures. They show clearly that the cushion surface is not continuous: If two siblings have different numbers of children, then the surface makes a jump when the line between families is crossed. When viewed from above, this does not cause a visual disturbance.</p><p>This artifact can be removed if not ridges, but bumps are used for the offset per rectangle. Only the interior of the rectangle is offset, the boundaries remain in place. <ref type="figure" target="#fig_0">Figure 11</ref> shows a result. Cubic Bezier patches were used to represent the surface, upon each subdivision the four central control points were offset in the z-direction. The surface is continuous now, but thin rectangles still emerge as large, narrow ridges. Also, details in the structure are smoothed out. In general however, 3D views do not pay off. The 3D view is more expensive to generate, the absolute height direction does not provide a direct cue on the structure, and the only view where all rectangles can be viewed simultaneously is the top view.</p><p>Rather, we will spend effort in other areas. Some open questions are:</p><p>-How can anti-aliasing be provided, to handle rectangles that fall between pixels? -How can we effectively present multi-dimensional attributes per leaf? -How can graph-information (e.g. symbolic links in file systems) be included? -Does the combination of this representation with other types of presentations pay off? -Can the presentation of size be improved, such that perceptual characteristics are taken into account?</p><p>Summarizing, still much work has to be done in the area of tree visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>We have presented a new method to visualize hierarchical information. Cushion treemaps inherit the elegance of standard treemaps, and add intuitive shading to provide insight in the hierarchical structure. Their features can be summarized as follows:</p><p>-efficient: generation of an image typically takes less than a second; -effective: the structure is visualized much more effective compared with standard treemaps. This is obvious if we compare for instance figure 4 with figure 8; -compact: the display area is used very efficiently, more than 3000 leaves can be displayed easily in an image with 640×480 resolution. As a result, no scrolling or opening/closing of nodes is needed to view the whole structure;</p><p>-easy to implement: the complete algorithm fits on one page;</p><p>-easy to control: the appearance can be controlled with a few intuitive parameters, for which default values often suffice.</p><p>Finally, cushion treemaps address one of the most important topics in visualization. Their wide applicability is probably what has struck us most during our research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Tree diagram Many techniques have been proposed to show such structures more effectively. An important category are node and link diagrams (fig.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Treemap</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Treemap of file system present an overview of the concept, an in depth treatment is given in the original references.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Treemap of organization attributes of the elements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Binary subdivision of interval with bumps added</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Binary subdivision of interval, viewed from above</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 : 5 Figure 8 :</head><label>758</label><figDesc>Cushion treemap of file system, h = 0.5, f = 1 h = 0.5, f = 1 h = 0.5, f = 0.75 h = 0.5, f = 0.Cushion treemaps of organization</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>correspond to s[X,2], s[Y,2], s[X,1], and s[Y,1] respectively. The constant coefficient e can be ignored here, because it is not used in the shading calculation. Each tree record has an associated size, and a pointer to its parent, to its first child, and to the next sibling. type Dir = (X,Y); Bound = (Min, Max); Degree = (1, 2); Rectangle = array[Dir, Bound] of real; Surface = array[Dir, Degree] of real; TreeRecord = record real size; Tree parent, child, next; end; Tree = pointer to TreeRecord;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>procedure</head><label></label><figDesc>CTM(Tree t; Rectangle r; real h, f; Dir d; Surface s) var Tree tc; real w; begin if t.parent = nil then AddRidge(r[d, Min], r[d, Max], h, s[d,1], s[d,2]); if t.child = nil then RenderCushion(r, s) else begin if d = X then d := Y else d := X; w := (r[d, Max] -r[d, Min])/t.size; tc := t.child; while tc = nil do begin r[d, Max] := r[d, Min] + w*tc.size; CTM(tc, r, h*f, f, d, s); r[d, Min] := r[d, Max]; tc := tc.next end end endfCTMg;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>procedure</head><label></label><figDesc>MakeCushionTreeMap(Tree root; integer width, height) var Rectangle r; Surface s; begin r[X, Min] := 0; r[X, Max] := width; r[Y, Min] := 0; r[Y, Max] := height; s[X, 1] := 0; s[X, 2] := 0; s[Y, 1] := 0; s[Y, 2] := 0; CTM(root, r, 0.5, 0.75, X, s) end; fMakeCushionTreeMapg The procedure AddRidge takes care of the update of the coefficients of the parabolic surface according to equation (2) and (3): procedure AddRidge(real x1, x2, h; var real s1, s2) begin s1 := s1 + 4*h*(x2+x1)/(x2-x1); s2 := s2 -4*h/(x2-x1) end;fAddRidgeg</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>procedure</head><label></label><figDesc>RenderCushion(Rectangle r; Surface s) const Ia = 40; Is = 215; Lx = 0.09759; Ly = 0.19518; Lz = 0.9759; var integer ix, iy; real nx, ny, cosa; begin for iy := trunc(r[Y, Min]+0.5) to trunc(r[Y, Max]-0.5) do for ix := trunc(r[X, Min]+0.5) to trunc(r[X, Max]-0.5) do begin nx := -(2*s[X,2]*(ix+0.5) + s[X,1]); ny := -(2*s[Y,2]*(iy+0.5) + s[Y,1]); cosa := (nx*Lx + ny*Ly + Lz)/ sqrt(nx*nx + ny*ny + 1.0); SetPixel(ix, iy, Ia + max(0, Is*cosa)) end end;fRenderCushiong</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Cushion treemap trie</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>Cushion treemap file system, oblique view</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 11 :</head><label>11</label><figDesc>Continuous cushion treemap file system</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Drawing trees nicely with tex</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bruggemann-Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Electronic Publishing</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="101" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The information visualizer, an information workspace</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CHI&apos;91, Conference on Human Factors in Computing Systems</title>
		<meeting>of ACM CHI&apos;91, Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="181" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Evaluation of three interfaces for browsing hierarchical tables of contents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chimera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wolman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<idno>CAR-TR-539, CS- TR-2620</idno>
		<imprint>
			<date type="published" when="1991-02" />
		</imprint>
		<respStmt>
			<orgName>University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Visualization and interaction techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI97 Tutorial notes on Information Visualization. ACM SIGCHI</title>
		<imprint>
			<date type="published" when="1997-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Computer Graphics -Principles and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Feiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Hughes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Shapefrom-shading Analysis with Shadelets and Bumplets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">T</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">H</forename><surname>Adelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Pentland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Inv. Opth. and Vis. Sci. (supp)</title>
		<meeting><address><addrLine>Spring</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page">410</biblScope>
		</imprint>
	</monogr>
	<note>Association for Research in Vision and Ophthalmology</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generalized fisheye views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Furnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CHI&apos;86, Conference on Human Factors in computing systems</title>
		<meeting>of ACM CHI&apos;86, Conference on Human Factors in computing systems</meeting>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="page" from="16" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Treemaps: a space-filling approach to the visualization of hierarchical information structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd International IEEE Visualization Conference</title>
		<meeting>of the 2nd International IEEE Visualization Conference</meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="284" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Fundamental algorithms, art of computer programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="volume">1</biblScope>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cone trees: animated 3d visualizations of hierarchical information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CHI&apos;91, Conference on Human Factors in Computing Systems</title>
		<meeting>of ACM CHI&apos;91, Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="189" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Tree visualization with tree-maps: a 2d space-filling approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="1990-09" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
