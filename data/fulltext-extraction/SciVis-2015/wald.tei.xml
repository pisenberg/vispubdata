<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CPU Ray Tracing Large Particle Data with Balanced P-k-d Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ingo</forename><surname>Wald</surname></persName>
							<email>ingo.wald@intel.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Knoll</surname></persName>
							<email>knolla@sci.utah.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">P</forename><surname>Johnson</surname></persName>
							<email>gregory.p.johnson@intel.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
							<email>pascucci@sci.utah.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">E</forename><surname>Papka</surname></persName>
							<email>papka@anl.gov</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Intel Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">SCI Institute</orgName>
								<orgName type="institution" key="instit2">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Will Usher § SCI Institute</orgName>
								<orgName type="institution" key="instit1">Intel Corporation</orgName>
								<orgName type="institution" key="instit2">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">SCI Institute</orgName>
								<orgName type="institution" key="instit2">University of Utah</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="laboratory">Argonne National Laboratory, Northern Illinois University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">CPU Ray Tracing Large Particle Data with Balanced P-k-d Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Ray tracing</term>
					<term>Visualization</term>
					<term>Particle Data</term>
					<term>k-d Trees K.6.1 [Management of Computing and Information Systems]: Project and People Management-Life Cycle; K.7.m [The Computing Profession]: Miscellaneous-Ethics</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Full-detail ray tracing of giga-particle data sets. From left to right: CosmicWeb early universe data set from a P3D simulation with 29 billion particles; a 100 million atom molecular dynamics Al 2 O 3 − SiC materials fracture simulation; and a 1.3 billion particle Uintah MPM detonation simulation. Using a quad-socket, 72-core 2.5 GHz Intel R † Xeon R E7-8890 v3 Processor with 3 TB RAM and path-tracing with progressive refinement at 1 sample per pixel, these far and close images (above and below) are rendered at 1.6 (far) / 1.0 (close) fps (left), 2.0 / 1.2 fps (center), and 1.0 / 0.9 fps (right), respectively, at 4K (3840 × 2160) resolution. All examples use our balanced P-k-d tree, an acceleration structure which requires little or no memory cost beyond the original data.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With ever increasing compute power, simulations produce increasingly large quantities of data to be visualized. The largest computational codes predominantly generate particle data: molecular dynamics materials computations, mesoscale or macroscale atomistic simulations, and cosmology and astrophysics n-body codes. The largest cosmology simulations now generate trillions of particles at scale; these petabytes of data are seldom even stored, let alone visualized. Examples of such data are shown in <ref type="figure">Figure 1</ref>.</p><p>At such scale, traditional rasterization-based approaches to rendering such data sets become problematic: simply rendering each particle with a tessellated sphere becomes prohibitive, and even splatting and impostor techniques are limited by rasterization performance, GPU memory limitations and PCI bandwidth. This becomes more challenging if the user desires to interact with multiple data time steps, apply different attribute color mappings, or perform interactive parameter range selection. State-of-the-art GPU techniques <ref type="bibr" target="#b15">[16]</ref> can render up to 10 billion particles on a single GPU with level-of-detail (LOD). However, LOD approaches must be specifically tuned to individual data and rendering modalities. For extremely large datasets from cosmology, showing full-detail data is challenging but crucial to understanding both structure and scale of the simulation <ref type="figure" target="#fig_0">(Figure 2</ref>). Ideally, we wish to visualize data at full-resolution without LOD. GPU visualization clusters can render on the order of hundreds of billions of particles with no LOD in parallel <ref type="bibr" target="#b22">[23]</ref>. However, repartitioning and compositing massive point data can be costly, and requires data-parallel software architectures and significant compute resources.</p><p>With the right algorithms, large-scale visualization is achievable on single-node CPU hardware. Visualization is a big data problem -the chief challenge is accessing large memory efficiently and directly. CPU memory is cheap, plentiful and fast: a laptop CPU has more memory (16 GB) than even a high-end GPU <ref type="bibr">(12 GB)</ref>, and a large-memory workstation with 768 GB can be acquired for less than $10,000. New vis clusters commonly feature nodes with 256 GB, and "fat" nodes are capable of 1-6 TB. Directly visualizing large data on a single resource is attractive, but requires fast memory-efficient rendering techniques for the CPU. CPU ray trac-IEEE Scientific Visualization Conference 2015 October 25-30, Chicago, Il, USA 978-1-4673-9785-8/15/$31.00 ©2015 IEEE ing has proven a viable approach for particle data (e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14]</ref>), but previous methods used standard acceleration structures with high overhead or algorithms specific to older SIMD architectures. General-purpose ray tracers like Embree <ref type="bibr" target="#b26">[27]</ref> offer performance and portability, but incur high memory cost and lack the ability to efficiently query data.</p><p>In this paper, we describe a novel approach for visualizing large particle data sets using a ray tracing acceleration data structure based on the original balanced k-d tree <ref type="bibr" target="#b1">[2]</ref>. Our approach rearranges data in-place into an acceleration structure that requires no additional memory footprint. Balanced k-d trees are different from the spatial k-d trees (BSP trees) commonly used in ray tracing, and to the best of our knowledge we are the first to employ this structure in directly ray tracing particle data at this scale. Our technical contribution is augmenting the balanced k-d tree into a P-k-d tree supporting additional range queries and efficient traversal and classification in a packet ray tracer. We achieve performance competitive with existing BVH ray tracing approaches, while requiring significantly less memory. We implement our approach in the OSPRay visualization framework <ref type="bibr" target="#b18">[19]</ref>, and use it to ray trace billion-particle data sets <ref type="figure" target="#fig_0">(Figures 1 and 2</ref>) on commodity workstations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND 2.1 Particle and Point Visualization</head><p>Efficient rendering of point data has been a popular topic in graphics (see, e.g., <ref type="bibr" target="#b7">[8]</ref>). In this paper, we are principally interested in visualizing volumetric particle data from molecular dynamics and other Lagrangian simulations. Points fill interior space as opposed to defining a surface, and have one or more attributes, e.g. atom type, temperature, etc. Approaches for rendering such data vary, but can roughly be categorized into glyph, volumetric and implicit surface approaches.</p><p>Glyph techniques have long been explored on both GPU and CPU. Most relevant to our work, Gribble et al. <ref type="bibr" target="#b6">[7]</ref> employ coherent ray tracing algorithms on the CPU to efficiently render millions of opaque sphere glyphs. Knoll et al. <ref type="bibr" target="#b14">[15]</ref> employed BVHs in a predecessor of OSPRay for ray tracing megascale ball-and-stick models on CPU and Xeon Phi architectures. Megamol <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b8">9]</ref> uses a combination of GPU rasterization, ray casting of sphere impostors, and image-space filtering to efficiently render millions of atoms. More recently, Le Muzic et al. <ref type="bibr" target="#b15">[16]</ref> demonstrated a dynamic LOD system for rendering up to 10 billion atoms at 10 fps. With LOD, the system effectively renders on the order of 10 7 primitives on-device. They used this approach for real-time molecular animation, procedurally deformed with Brownian motion and user interaction. This approach works principally because the GPU controls both levelof-detail and movement of particles; it would likely face IO challenges if applied to large-scale, time-varying simulation data. In our work, we propose a CPU-based solution to rendering full-scale data, without LOD.</p><p>Volumetric approaches to rendering large point-based data vary widely. With LOD, systems have proven capable of rendering bil-lions of particles; Fraedrich et al. <ref type="bibr" target="#b4">[5]</ref> implemented an extremely fast out-of-core LOD particle renderer for real-time rendering of astrophysics data. However, image-space reconstruction is insufficient to reconstruct smooth surfaces classified from volume data. For that, one generally has the choice of resampling particle data onto a grid, or employing direct SPH/RBF volume rendering. Kähler et al. <ref type="bibr" target="#b12">[13]</ref> demonstrate the former, using an octree to simultaneously splat particle data (simplified using LOD) and volume-render approximated data on a structured grid. Fraedrich et al. <ref type="bibr" target="#b3">[4]</ref> dynamically resample from an octree into perspective-space uniform grids of predetermined size, and achieve nearly interactive performance on an NVIDIA 280 GTX for up to 42M particles (0.1 fps). Orthomann et al. <ref type="bibr" target="#b17">[18]</ref> describe a similar system traversing an octree, using "packets" of rays computed on the GPU. Reda et al. <ref type="bibr" target="#b21">[22]</ref> use the GPU to efficiently volume ray cast ball-and-stick glyphs, structured volumes, and RBF volume data. Knoll et al. <ref type="bibr" target="#b13">[14]</ref> demonstrate fast direct RBF volume rendering on the CPU and Xeon Phi, using a BVH which incurs significant memory overhead.</p><p>The astrophysics and cosmology communities have several tools for parallel batch visualization of particles <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b0">1]</ref>. Generally, these do not take advantage of SIMD, have limited if any GPU acceleration, and are not designed for interactive rendering. Irrespective of the type of data, rendering large numbers of particles can also be seen as a special case of more general large-model rendering techniques, for which we refer interested readers to stateof-the-art papers on CPU <ref type="bibr" target="#b26">[27]</ref> and GPU <ref type="bibr" target="#b5">[6]</ref> approaches, as well as more recent work involving large-model ray tracing on GPUs <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Ray Tracing Acceleration Structures</head><p>Ray tracing describes an entire family of algorithms that solve for the intersection of rays with geometric primitives, and the transport of light (or other properties) across a spatial media. At its core, ray tracing relies on spatial data structures, or acceleration structures, such as grids, binary space partitioning (BSP), (spatial) k-d trees, or bounding volume hierarchies (BVHs) (see <ref type="figure" target="#fig_2">Figure 3a</ref>-b). Bounding Volume Hierarchies (BVHs, <ref type="figure" target="#fig_2">Figure 3a)</ref> are object hierarchies that store the bounds of all enclosed primitives in each node. Inner nodes specify tree topology; leaf nodes store primitives. Each primitive is referenced in exactly one leaf node, and nodes can spatially overlap. BVH trees are generally highly unbalanced.  Spatial k-d trees, in contrast (see <ref type="figure" target="#fig_2">Figure 3b</ref>), rely on hierarchical space partitioning. Spatial (subdivision) k-d trees are just a special case of more general binary space partitioning (BSP) trees, in which split planes are axis-aligned but may be placed anywhere in space. Inner nodes of a spatial k-d tree specify axis-aligned partitioning planes that recursively subdivide space; leaf nodes store references to geometric primitives. Nearly all "k-d trees" in ray tracing, collision and graphics are of this variety. Range Trees BVHs, spatial k-d trees, etc can all be augmented with additional information to store, for each node, the min/max ranges of the attribute values associated with primitives in this sub-tree; this can then be used to, interactively reject sub-trees outside of a given parameter range (see, e.g., <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b6">7]</ref>) These structures are often called min-max trees or interval trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Balanced k-d Trees</head><p>In contrast to spatial k-d trees used in ray tracing, in this paper we build upon the original balanced k-d trees of Bentley <ref type="bibr" target="#b1">[2]</ref>, illustrated in <ref type="figure" target="#fig_2">Figure 3</ref>(c). Spatial k-d trees and balanced k-d trees sound similar, and both subdivide space via axis-aligned split planes. However, they are fundamentally different data structures with very different properties. In particular, balanced k-d trees are explicitly designed to store points (not geometric primitives), which make them not immediately applicable to ray tracing. They do, however, have some interesting properties, specifically that a balanced k-d tree is:</p><p>(i) complete: all but the lowest levels of the tree are filled, (ii) left-balanced: all nodes are on the left side of the tree, and (iii) pointer-less: children of node i live at 2i + 1 and 2i + 2 These allow balanced k-d trees to encode a spatial hierarchy simply by reordering the original data, requiring no memory at all other than for the particle positions themselves <ref type="bibr" target="#b1">[2]</ref>. We discuss the properties of k-d trees, and our variant the p-k-d tree, in greater detail in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">ISPC, Embree, and OSPRay</head><p>Our implementation make use of several open-source projects that influence how exactly our technique was implemented. Embree [27, http://embree.github.io] is a high-performance kernel framework for efficient CPU ray tracing. It offers a set of low-level kernels for building and traversing ray tracing data structures that are particularly optimized to exploit modern CPUs' vector instruction sets through highly optimized, hand-tuned kernels. Embree allows for using user-defined primitive types (e.g., spheres), but handles all acceleration structure kernels (e.g., type of BVH) internally and opaquely.</p><p>OSPRay (ospray.github.io) is a ray tracing based rendering engine for high-fidelity visualization. OSPRay builds on both Embree and ISPC, using Embree for everything related to tracing rays, and ISPC for everything involving rendering and shading. OSPRay generally achieves interactive performance even on a single laptop or workstation (depending on the number of rays traced per pixel) and supports effects such as shadows, reflections, transparency, or ambient occlusion. Improving on Embree, OSPRay allows for new shading models and user-defined data representations and acceleration structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Challenges in Ray Tracing Large Particle Models</head><p>Initially, when we set out applying ray tracing to particle visualization we did not expect this would require anything new; we initially took the OSPRay ray tracing engine (which internally builds on Embree), used Embree's user defined geometry functionality to add a sphere primitive to OSPRay. This enabled us to render complex models with many millions of particles, but soon revealed two major issues. The first issue is the desire to interactively color-map and discard (i.e. query) particle data based on range or other attributes. This is impossible with the standard Embree BVH. Simply discarding deactivated particles during traversal is performance-prohibitive when large regions of particles are inactive; they are traversed but never actually intersected. One solution is to use min-max trees <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b13">14]</ref>; but these cannot easily be realized within the Embree framework. We required a new data structure supporting efficient query.</p><p>The second problem is the memory overhead required to handle the ray tracing acceleration structures, in particular if the memory required for each primitive itself is relatively small. For example, using sphere glyphs in Embree's user-defined geometry requires 16 bytes for the primitive and 32 bytes per BVH leaf, leading to an overhead of up to 7× for leaves with one primitive each. While copious CPU memory encourages waste if performance can be gained, in many cases inefficiency can mean the difference between being able to handle a data set or not. Also, in an in situ visualization context, the memory overhead required for rendering would leave only a fraction of memory for the actual simulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RAY TRACING USING BALANCED P-K-D TREES</head><p>In this paper, we propose a novel approach to efficiently handle large particle data in a ray tracer-in particular taking into account memory consumption and construction time of the acceleration structure. We apply this technique to interactive visualization of large particle data sets using the OSPRay CPU ray tracing framework. Given the challenges outlined in Section 2.5, we need a way of ray tracing large numbers of particles that:</p><p>• allows large numbers of particles to be rendered, scaling logarithmically with number of particles • has significantly lower overhead than 7×; and • achieves competitive, interactive performance. We take an approach based on balanced k-d trees which achieves these goals. Our method works by representing each primitive i via a single representative point x i (in the case of spheres, their centers), and computing the maximum spatial extent R max that any primitive deviates from this point (in the case of spheres, the maximum radius of any sphere). We then organize these points in a balanced "point"-k-d tree which has several nice properties for our particular application -in particular memory consumption -and devise a novel ray traversal scheme that, given the point-k-d tree and R max can efficiently ray trace the primitives encoded in this tree. Our P-k-d tree is thus a balanced k-d tree with several modifications to enable efficient rendering of particle data, namely:</p><p>• we use maximum extent <ref type="bibr" target="#b11">[12]</ref> instead of round robin <ref type="bibr" target="#b1">[2]</ref> to pick split planes, we encode the split axis in the tree data itself • we re-arrange particle attributes into separate balanced trees, so they may be queried separately • we preprocess attributes into (optional) min-max trees for faster query, incurring only modest extra cost of 1-2 bytes per particle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Balanced vs. Spatial k-d tree Traversal</head><p>As discussed in Section 3, balanced kd-trees are quite different from spatial k-d trees commonly used in ray tracing. This has important consequences for ray traversal.</p><p>In spatial k-d trees, splitting planes are used to separate different primitives that all have a spatial extent. Different sub trees' spatial extends do not overlap, and primitives will often be referenced in multiple leaf nodes. In the spatial k-d tree, inner nodes correspond to splitting planes and store a plane description; leaf nodes correspond to regions of space and store (references to) primitives. Being able to place partitioning planes at arbitrary locations allows the spatial k-d tree a wide variety of construction options <ref type="bibr" target="#b10">[11]</ref>. Properly built spatial k-d trees can enclose their geometric primitives quite well, but require significant memory overhead for interior nodes, and pointers for both tree topology and primitives.</p><p>Balanced k-d trees, in contrast, always and exclusively encode points (not 3D primitives), and place planes always right through the data points. When building the k-d tree such that the resulting tree is binary, complete, and left-balanced, balanced k-d trees can be encoded in completely pointerless fashion: the children for the node n i are always n 2i+1 and n 2i+2 , respectively, and a child exists if and only if its index i is less than the number of points N. In each node n i , the partitioning plane's dimension d i is defined implicitly through the node's tree level</p><formula xml:id="formula_0">L i = f loor(log 2 (i)) (as d i = L i % k,</formula><p>where k is the number of dimensions), and the plane's positiongoing through n i then is</p><formula xml:id="formula_1">x i , d, where x i , i ∈ [0..k)</formula><p>are the k coordinates of point i. Stored in that way, a balanced k-d tree can encode N k-dimensional points with exactly zero memory other than for the points themselves.</p><p>The drawback of the balanced k-d tree is that a node does not partition its primitives into exclusively left and right sides, but instead also contains a primitive at each inner node itself. These inner nodes must be intersected by every ray entering this sub-tree, usually unsuccessfully. The root node, for example, is guaranteed to be intersected by almost every ray traversing the data structure (though early termination may avoid its traversal). This data structure would be impractical for geometry whose intersection tests are expensive. However, for visualization of spheres, the cost of unnecessary intersection is low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Naïve Balanced P-k-d Tree Traversal</head><p>In order to efficiently allow 3D object queries such as ray traversal a data structure has must allow for recursive traversal that quickly rejects sub-trees that do not intersect the query (e.g., a ray, frustum, range, etc). A spatial k-d tree style traversal does not easily work for the P-k-d tree data structure; the balanced k-d tree is in fact closer to an object hierarchy (like a BVH), where each node partitions its objects into disjoint sets of those objects on the left, those on the right, and the root node-and even though the representative point of an object may lie to the left of the root node's plane it is not guaranteed that the entire object is exclusively on that side.</p><p>Given a maximum radius R max we can compute conservative bounding boxes for its two children as depicted in <ref type="figure" target="#fig_4">Figure 4</ref>. Offsetting the node x's plane P x into +R max and −R max yields two implicit planes P x,lo and P x,hi that, when clipped against the bounding box for the given sub-tree, yields two bounding boxes that can easily be guaranteed to conservatively bound all the primitives in that   Algorithm 1: A naïve recursive traversal algorithm applicable for 3D object query (ray, frustum, range, etc.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Optimized Ray Traversal</head><p>Several optimizations to such a naïve algorithm can significantly improve performance. In particular, for ray traversal we want to traverse as much as possible in front-to-back order, in order to maximize the likelihood of skipping entire subtrees once a close hit is found. Like in a spatial k-d tree, we can actually guarantee a frontto-back traversal using only local traversal decisions. However, unlike in a spatial k-d tree, we can not early-terminate a ray upon the first found intersection: since sub-trees can overlap, our data structure and traversal are actually closer to a BVH, and other sub-trees may still contain a possibly closer intersection.</p><p>Another important observation to make is that when traversing from one node to any of its children, only one of the six box sides will actually change. Thus, performing full ray-box intersection tests would redundantly re-compute 5 of 6 values every time. Instead, we can adopt an idea from spatial k-d tree traversal that, rather than tracking the bounding box itself, instead tracks only the ray interval that overlaps the current box, and incrementally changes that based on the distance to the respective plane(s). We do not employ actual recursion, but emulate the recursion using a manually-maintained node stack as commonly done for both BVHs and spatial k-d trees. In addition, we add some logic for traversal of the min-max range trees, optionally computed for each particle attribute we wish to query (described in Section 3.6). The final pseudo-code is given in Algorithm 2.</p><p>function traverse(Ray R, K-D tree tree) { box aabb_root = tree.bounds().extend(Rmax); (t_in,t_out) = clip R to aabb_root; if (t_out &gt;= t_in) return DONE; Node n = tree.root; while (true) while (true) if (node is leaf) intersect particle n; break; // particle range culling: if (n out of valid range) break; // compute dist to near and far plane t_lo,t_hi = distance to P_lo,P_hi // node IDs for near/far child k = split_dim(n) s = sign(R.dir[k]); (n_nr,n_fr) = (2n+2-s,2n+1+s) // entry/exit dist for nr/fr child t_fr_in = max(t_in,min(t_lo,t_hi)) t_nr_out = min(t_out,max(t_lo,t_hi)) if (t_in &gt; t_near_out) // entire [t_in,t_out] on far side n = t_far; continue; if (t_fr &lt; t_far_in) // entire [t_in,t_out] on near side n = t_near; continue; push(n,n_far,t_far_in,t_out) (n,t_out) = (n_nr,t_nr,out) // pop from stack: while (true) if (stack is empty) return; (n,n_far,t_in,t_out) = pop(); if (ray.t_hit &lt; t_in) continue; intersectPrim(n); break; // go on traversing Algorithm 2: Optimized algorithm for traversing rays through a P-k-d tree, including attribute range selection. The algorithm is a hybrid between spatial k-d-tree and BVH traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Handling Particles With Different Radii</head><p>Though all our data sets use a fixed radii for all particles, it would be possible to also support different radii (for example, by storing a radius per particle, or by deriving a particle from a mapped attribute), and even non-spherical shapes such as balls-and-sticks, triangles, etc. All the P-k-d tree needs to guarantee correctness is a conservative R max value that, when used to shift a subtree's planes, properly bounds all primitives in that subtree. The tightness of the bounding primitive (i.e., how tightly the sphere with radius R max bounds the actual primitive) will impact traversal performance. In cases where a handful of large particles are mixed with many tiny particles, performance will suffer. There are ways of addressing this (e.g., storing a maximum radius per sub-tree); we leave them outside the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Ray Tracing and Shading</head><p>By implementing the P-k-d traversal routine within OSPRay <ref type="bibr" target="#b18">[19]</ref>, we are automatically able to use the material, rendering and shading pipeline of that ray tracing engine. When a ray terminates in traversal, the OSPRay renderer is given a geometry ID (a pointer to the particle), from which it can look up the material via the chosen attribute and transfer function. This material is then passed to the chosen OSPRay renderer (ray cast, ambient occlusion, path tracing, etc.), which integrates the color accordingly and generates secondary rays as necessary. Like Embree <ref type="bibr" target="#b26">[27]</ref>, OSPRay allows for progressive refinement an option, ensuring consistent interactivity and allowing path-traced images to converge to production-quality renderings. Examples of diffuse-only ray casting, ambient occlusion and path tracing are shown in <ref type="figure" target="#fig_5">Figure 5</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Tree Construction</head><p>Generally, balanced k-d trees rely on a dimensional sort, and pick the literal median element as the pivot point. Unlike spatial k-d trees <ref type="bibr" target="#b10">[11]</ref>, they offer no flexibility in placing split planes: once the split dimension has been chosen, the balance of the tree dictates exactly which particle along that axis has to be the root node. Nevertheless, there are a variety of choices in particular with respect to data layout that we want to briefly discuss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Round-Robin vs Maximum-Extent Partitioning</head><p>Traditional balanced k-d trees <ref type="bibr" target="#b1">[2]</ref> chose the partitioning dimension in a round-robin (RR) manner, in which case each node's dimension is implicit in the node's depth in the tree. As shown by Jensen <ref type="bibr" target="#b11">[12]</ref>, it is often advantageous to instead partition along the axis of the current subtree's maximum extent, and since such a maximum extent (ME) splitting scheme will minimize the surface area of the two child nodes, this will also be advantageous for ray traversal. Generally, we found that ME splitting gave a 30% performance advantage over round robin.</p><p>Maximum-extent partitioning also simplifies our algorithm, as we no longer have to track the tree depth on the stack. However, we now must store the chosen split axis. We currently squeeze this two-bit information into the particle position, i.e. the lowest two bits of the x, etc. Alternately, one could employ unused bits of the min-max tree, or of the atom type attribute, etc. In the worse case, one could store these bit explicitly in an separate array, requiring two additional bits per particle. Range Trees, Queries and Multi-Attribute Data The balanced P-k-d tree is different from standard balanced kd trees in that it is designed for volumetric particle data with queryable attributes. Our goal is to efficiently traverse the tree and cull unwanted branches based on a transfer function or other range query. This is useful, for example, in materials science when isolating atoms of one or more types, or in cosmology to filter out low-density particles to better reveal structure ( <ref type="figure" target="#fig_6">Figure 6</ref>).</p><p>In the P-k-d tree, each attribute is its own array of attribute values. Attributes are ordered in the same way as particles, i.e. for given attributes M, D, and V, the V value for particle i is stored at pkd.attribute <ref type="bibr">[V]</ref>.value <ref type="bibr">[i]</ref>. Range trees are built on top of attributes, and traversed alongside the P-k-d tree as in Algorithm 2. To build the range tree, we first build the P-k-d tree, then simply compute min-max information of the component attributes. To store the minmax tree, we currently use one integer per inner node of the tree, which gives us a 32-bit mask of which attribute values are present in the given sub-tree. While this adds some overhead, it is typically small compared to the size of the attribute data in the inner nodes; moreover one mask suffices for multi-attribute data. This mask is computed as a pre-process every time the transfer function changes. While the added cost of the mask is relatively small (13%), it is purely optional; the user can traverse all data without culling sub-trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Construction Algorithm</head><p>For actual tree construction we use an in-place partitioning scheme inspired by the well-known quick-sort algorithm. The method proceeds as follows: first, using either round-robin or maximum extent, we pick the axis on which to sort. Then, using the current root particle as a pivot we iterate through left and right sub-trees (in heap indexing), to find "wrong" particles in the left and right sub-tree; i.e., a particle on the left that is larger than, and a particle on the right that is smaller than, that pivot. If these exist (at, say, positions i and j) we swap these two particles, and continue scanning at i + 1 and j + 1.</p><p>If a wrong particle could only be found on one side-say, i on the left-then i becomes the new pivot by swapping with the root, and we again search for wrong nodes in both subtrees (but noting that from now on, we will no longer have to scan any earlier than i on the left); the right-side case is analogous. If no wrong particle could be found on either side, then the current root is the proper pivot, the tree is properly partitioned in that node, and we can recursively build its children.</p><p>For thread parallelization, we fork a new thread to handle the left sub-tree when sub-trees contain more than a certain number of (currently, 16K) elements. Though this strategy does not achieve perfect scalability, it works reasonably well for larger data for which scalability is needed most, e.g., delivering around 70% scalability to 16 threads on a 16-core 2.7 GHz SandyBridge CPU <ref type="table">(Table 4)</ref>.</p><p>The P-k-d tree is currently built in a pre-processing step when we convert from the external input file formats to OSPRay's internal XML-based binary data format; this saves re-building the tree every time a model is loaded, and since our data structure is very compact there was no obvious reason not to store readily built trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">OSPRay Implementation</head><p>We implemented our P-k-d method in the OSPRay <ref type="bibr" target="#b18">[19]</ref> framework. With its object-oriented design, all ray-intersectable geometric ob-jects are derived from a common, abstract Geometry type. All other components of OSPRay-camera, materials, renderers, parallel rendering mode, etc. -to work "out of the box", requiring no new implementation.</p><p>OSPRay internally implements all objects in a hybrid C++/ISPC fashion, where components that aren't performance critical (bookkeeping, reference counting, etc) are implemented in C++, while performance-critical traversal routines are implemented in ISPC; the interface to all such functions-ray generation, traversal, intersection, shading, etc-is based on varying rays (i.e., they internally operate on N rays in parallel, one per vector lane, where N is the architecture's vector width). A naïve implementation of Algorithm 2 in ISPC would-just like in other SPMD languages like OpenCL or CUDA-lead to each lane simply executing its own independent traversal, with each lane having (and maintaining) its own stack, traversing its own path through the tree, typically traversing different nodes and intersecting different particles, etc. However, as ISPC allows a programmer to explicitly specify which data is uniform (i.e., scalar) vs which is varying (i.e., once per vector lane) it is relatively easy to also implement a "packet" traversal in which the different rays remain ganged together (see e.g., <ref type="bibr" target="#b25">[26]</ref>), and either all rays skip a sub-tree, or the entire packet enters this sub-tree (even those rays that would not have needed to). Despite worse SIMD utilization, packet traversal is consistently faster: The naïve SPMD implementation is limited by the the efficiency of gathering of up to N different particles (in general very different memory locations) in each traversal step. Moreover, stack operations and masked traversal logic, executed in uniform, are far simpler for the packet code. For the 180 million atom Uintah data set, for example, the packet code is roughly 2× faster than the naïve SPMD method for primary rays, and even 3× faster for ambient occlusion rays. We thus use the packet variant in all our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>We evaluate our implementation on several different hardware platforms enumerated in <ref type="table">Table 1</ref>. These cover a wide range of machines from personal laptops to high-end workstations and HPC nodes. In all cases, we only use the systems' CPUs, the GPUs (where available) are only used to display the final rendered image. Unless otherwise noted, all benchmarks are performed at 1024 × 1024 (1 megapixel) resolution, on the 72-core Intel R Xeon R E7-8890 v3 workstation with 3 TB RAM, using ambient occlusion with 1 sample per pixel and progressive refinement.  <ref type="table">Table 1</ref>: Hardware used to evaluate P-k-d performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overall Performance</head><p>In <ref type="table" target="#tab_5">Tables 2 and 3</ref>, we evaluate our technique by comparing a range of data sets from 740 thousand atoms to 29 billion particles on the 72-core Xeon E7-8890 v3 workstation. Overall, we achieve solidly interactive results for ray casting (29-135 fps) and both ambient occlusion (24-90 fps) and path tracing (5-33 fps) at 1 sample per pixel with progressive refinement rendering. More expensive ray tracing modalities (ambient occlusion at 16 spp, path tracing at 64 spp) perform non-interactively, but at rates suitable for efficient batch rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison to the Embree BVH</head><p>With an Embree quad-BVH at default (i.e., performance-optimal) settings (1 primitive per leaf), the total memory overhead is over 5 ×; however performance is on average 1.48× faster than our P-k-d tree. For far views, this difference is not as great as for close views (7% slower vs 43% slower); and in some cases the P-k-d traversal is actually faster. This is particularly interesting given that Embree uses hand-tuned, low-level SIMD routines for BVH traversal  <ref type="table">Table 4</ref>: Build time, and scalability up to 16 cores, for select data sets measured on the 2.7 GHz 16-core E5-2650 workstation.</p><p>(the ray-sphere intersection is the same in both variants), while our traversal is, so far, coded exclusively in ISPC, thus leaving potential for low-level optimizations. Uing a shallower BVH (e.g., with up to 8 primitives per leaf) can indeed cut Embree's memory overhead by half, but it is still 2.7× larger than the P-k-d tree's. Even shallower BVHs would reduce this overhead further, but we already achieve performance parity at a leaf threshold of 8. We note that the Embree BVH is built only around raw particles; it does not encode any range information. Prior to implementation of the P-k-d tree, we experimented with standard range trees in a binary BVH, both performance and memory proved worse with this approach than with the P-k-d tree; generally by about 2× and 3×, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Range Tree and Query Costs</head><p>From <ref type="table" target="#tab_5">Table 2</ref>, we see that range trees cost a relatively minor 13% of the original data size. However, the time to compute the range tree is O(N), which is interactive for megascale data but can take on the order of minutes for 29 billion CosmicWeb dataset. Once computed, the range tree accelerates traversal of a subsets of data by skipping entire P-k-d subtrees. Frame rate is generally slower when performing these queries than when rendering full data, due to the extra branching and worse overall cache behavior. When changing the transfer function, in addition to the time required to rebuild the range tree, one may see temporary performance hits of 2x, which recover quickly as cache is filled appropriately. This behavior varies with data set and chosen classification. While it falls outside the scope of our work in this paper, it would be worth further investigation. <ref type="table">Table 4</ref> shows scalability for several data sets, and <ref type="table">Table 3</ref> shows construction time for our reference data sets. We achieve roughly 70% scalability up to 16 threads; while we did not explicitly measure the time to build larger data sets we anticipate their scalability would be comparable. Overall, P-k-d construction times are small compared to the time to read from disk. Surprisingly, for the data we tested all build times were slightly lower than those of the Embree BVH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Build time</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Scalability to Data and Image Size</head><p>In <ref type="figure" target="#fig_7">Figure 8</ref> (left), we examine the scalability of our algorithm to data size, rendering varying subsets of the CosmicWeb data from 1 <ref type="bibr" target="#b2">3</ref> (51 million particles) up to 8 <ref type="bibr" target="#b2">3</ref> (29 billion particles) on the 4socket, 72-core Xeon E7-8890 v3 workstation. We used default camera positions that render the full extents of the particle volume into a full-screen window. As expected, performance varies linearly with logarithm of data size, with notable drops due to NUMA.</p><p>In <ref type="figure" target="#fig_7">Figure 8</ref> (right), considering performance with respect to frame buffer size, we plot number of pixels against the square root of frame rate, and find a mostly linear curve, rendering the 51M     <ref type="table">Table 3</ref>: Performance for (far / close) views, in frames per second at 1024x1024 resolution for the reference data sets shown in <ref type="figure" target="#fig_8">Figure 7</ref>, on different CPU and Xeon Phi coprocessors. All results shown for ambient occlusion, 1 sample per pixel.</p><p>Cosmic 1 3 subset. Effective throughput increases as we process larger frame buffers, likely due to improved memory coherency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Comparison to GPU Techniques</head><p>There is no readily-available GPU ray tracer for large molecular and particle data with which to compare. State-of-the-art GPU methods <ref type="bibr" target="#b8">[9]</ref> employing OpenGL-rasterized impostors are capable of real-time performance -for kiloscale or megascale data these would be faster than our ray tracing approach, particularly on laptop or tablet CPUs. To render gigascale and larger particle data on the GPU, one must use simplification, out-of-core approaches, or distributed-parallel rendering. Geometric simplification methods on the GPU <ref type="bibr" target="#b15">[16]</ref> have handled up to 10 billion (simplified to 200 million) atoms at 10 fps at 2 MP, combining illustrative rendering with screen-space ambient occlusion; the p-k-d technique on our workstation exhibits roughly comparable performance (10-20 MRays/sec) on the full, unsimplified data. Out-of-core LOD methods (e.g., <ref type="bibr" target="#b4">[5]</ref>) are capable of even greater performance, but more are difficult to explicitly compare to. In more recent work involving parallel compositing on the GPU <ref type="bibr" target="#b22">[23]</ref>, the authors render 32 billion particle imposters without LOD on a 128-GPU cluster in roughly 3 seconds for an 18 MP image (6 million primary rays/ second). With a LOD strategy picking 10% of the full number of particles, they achieve linearly better performance (60 MRays/second). While comparison between splatting transparent imposters and ray tracing (mostly opaque) sphere glyphs is not completely fair, we are able to achieve comparable performance for primary rays on our single 72-core workstation. Moreover, though current GPUs support up to 12 GB RAM per device (750 million particles), Rizzi et al. <ref type="bibr" target="#b22">[23]</ref> suggest rasterization performance would drop below interactive rates at 50-200 million particles depending on the GPU and technique used. Though outside the scope of this work, ray tracing with the P-k-d structure may prove useful on future distributedmemory GPU architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SUMMARY AND DISCUSSION</head><p>We have presented a method for fast ray tracing of massive particle data on CPU architectures, with virtually no memory overhead. With this approach, a suitably fast CPU with enough memory can handle extremely large particle data, with no level-of-detail. Data size has relatively little impact on rendering performance: kiloscale and giga-scale particle data exhibit similar frame rates. The data chosen in our experiments include some of the largest molecular and materials simulations data, and significant subsets of cosmology simulation runs. With the balanced P-k-d structure, we are able to handle 5× larger data than BVH methods, with performance (using a naïve ISPC implementation for our P-k-d tree) on average 67% that of state-of-the-art BVH ray tracing (using handtuned kernels). Our performance is competitive with state-of-theart distributed-parallel, out-of-core and LOD-based GPU methods. Thanks to its implementation in OSPRay and ISPC, it can be deployed on a wide range of CPUs.</p><p>Some remaining problems merit discussion. Balanced k-d tree addressing leads to huge jumps in memory address when travers-ing up and down the tree (in particular close to the leaves), posing a challenge for any memory system. A hybrid structure, such as a separate grid or BVH containing P-k-d trees, may greatly improve performance at some small memory cost. At large scale, the time to read and write from disk remains the main bottleneck for both interactive and batch visualization. The time to build a P-kd tree on a single machine is also non-trivial. While it would be possible to improve on our thread-parallel build, a better strategy might be a data-parallel approach in which different nodes build Pk-d trees over their own data, thus enabling distributed-parallel IO, distributed build of the acceleration structure, and interactive ray tracing -offline, in coprocessing or in situ. Alternately, one could pursue true in-memory in situ rendering, i.e., distributed parallel ray tracing on the compute resource.</p><p>Rendering up to billions of particles on millions of pixels means that thousands of particles can project to a single pixel. Though a ray tracer can handle this cost-wise, it creates challenges in terms of aliasing, and ultimately one must question whether glyph representation is the best way of visualizing such data. We believe the capability to visualize full particle data at high resolution <ref type="figure" target="#fig_0">(Figure 2</ref>) is compelling, particularly for production-quality still images. However, antialiasing solutions borrowing from LOD techniques would be desirable to remove artifacts and improve overall image quality, particularly during rapid camera movement and animation.</p><p>Lastly, the balanced P-k-d structure's optional range trees enable fast query and classification of multi-attribute data. Simulations such as Uintah or CosmicWeb may have tens to hundreds of attributes. Choosing how to efficiently traverse and classify multifield particle data, e.g., detecting halos or correlating combustion variables, could be of interest from an applications standpoint.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Half-4K (3840x1080) rendering of the 432 GB Cosmic Web 8 3 dataset (29 billion particles), rendering at 6.4 frames per second (fps) with ambient occlusion -1 sample per pixel (spp) with progressive refinement -on a 72-core 2.5 GHz Xeon E7-8890 v3 with 3 TB RAM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>tracing) a) BVH (ray c) (point−) k−d tree b) BSP/kd−tree (ray tracing)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>BVHs (left) and k-d trees (center) as used in ray tracing to hierarchically organize geometric primitives. Right: Balanced point k-d trees (such as our P-k-d tree) encode k-dimensional points. Point k-d trees (right) and ray tracing k-d trees (center) share similarities, but also have important differences (see Section 3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Recursive traversal of a balanced k-d tree assuming each primitive is represented by a point, and bounded by a sphere with a radius of, at most, R max . Given a bounding box known to enclose all the primitives in a sub-tree, the plane P x associated with the subtree's root node x implicitly defined two planes P x,lo and P x,hi . Clipping the subtree's bounds against those two planes gives two (conservative) bounding boxes for the left and right child trees, allowing for recursive traversal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Rendering modalities, illustrated on a 3500-atom zeolite structure. Left to right: ray casting (106 fps), ambient occlusion (5 fps at 16 spp; 45 fps at 1 spp with progressive refinement) and path tracing (0.041 fps at 512 spp; 18 fps with progressive refinement).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Attribute-based query, based on atom type, in the Al 2 O 3 -SiC fissure data set. Left to right: full data set; silica carbide particles only; indentations in the alumina.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Top: CosmicWeb subsets from 1 3 to 8<ref type="bibr" target="#b2">3</ref> . Left: frame rate vs log 10 (data size). Right: square root of frame rate vs pixels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Reference scenes (ambient occlusion, 16 spp). Left to right: nanosphere (740K), SiO 2 fissure (5M), Al 2 O3 − SiC fissure (105M atoms), Uintah detonation (180M particles), large Uintah (1G particles), CosmicWeb 6 3 (12.2G particles), CosmicWeb 8 3 (29G particles).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Advanced Vector Instructions (AVX, AVX2, and AVX-512), and the Intel R Many Core Instructions (IMCI) used by the current version of Intel R Xeon Phi</figDesc><table><row><cell>The Intel R SPMD Program Compiler (ISPC) [20, http://</cell></row><row><cell>ispc.github.io] is an open-source Single-Program Multiple Data</cell></row><row><cell>(SPMD) compiler that performs vectorization by mapping different</cell></row><row><cell>instances of a scalar program to different vector lanes. ISPC is sim-</cell></row><row><cell>ilar in spirit to other SPMD languages like OpenCL or OpenMP</cell></row><row><cell>4.0, but is designed to better allow for using CPU-like program-</cell></row><row><cell>ming models. ISPC supports all major CPU instruction set architec-</cell></row><row><cell>tures (ISAs), including Intel R Streaming SIMD Extensions (SSSE),</cell></row><row><cell>Intel R</cell></row></table><note>TM processors.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>sub-tree. This then leads to the simple recursive traversal depicted in Algorithm 1.</figDesc><table><row><cell>function recurse(Object Q, Node n, box aabb)</cell></row><row><cell>if (Q does not intersect aabb)</cell></row><row><cell>return;</cell></row><row><cell>Q.process(n);</cell></row><row><cell>box aabb_l = aabb.clip(n.Plane + Rmax);</cell></row><row><cell>box aabb_r = aabb.clip(n.Plane -Rmax);</cell></row><row><cell>if (has left child)</cell></row><row><cell>recurse(Q,leftChild,aabb_l);</cell></row><row><cell>if (has right child)</cell></row><row><cell>recurse(Q,rightChild,aabb_r);</cell></row><row><cell>function traverse(Object Q, K-D tree tree)</cell></row><row><cell>box aabb_root = tree.bounds().extend(Rmax);</cell></row><row><cell>recurse(Q,tree.root,aabb_root);</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Memory cost and frame rate for (far / close) views, on the 72-core Xeon E7-8890 v3 workstation, rendered at 1024x1024 pixels. We report numbers for ray casting, ambient occlusion (AO), and path tracing (PT, using a diffuse-metal material), at 1-64 samples per pixel (spp).</figDesc><table><row><cell>Data Set</cell><cell>nanosphere</cell><cell>SiO 2</cell><cell cols="2">Al 2 O 3 -SiC Uintah180M</cell><cell>Uintah1B</cell></row><row><cell>#particles</cell><cell>740K</cell><cell>5M</cell><cell>105M</cell><cell>180M</cell><cell>.96B</cell></row><row><cell>data/P-k-d size</cell><cell>11 MB</cell><cell>73 MB</cell><cell>1.7 GB</cell><cell>2.7 GB</cell><cell>36 GB</cell></row><row><cell>Xeon E7-8890 v3 (2.5 GHz, 72 cores, 3 TB)</cell><cell>67 / 49</cell><cell>90 / 49</cell><cell>75 / 44</cell><cell>53 / 37</cell><cell>26 / 24</cell></row><row><cell>IvyBridge laptop (2.7 GHz, 4 cores, 16 GB)</cell><cell>6.4 / 4.3</cell><cell>10.3 / 3.6</cell><cell>9.6 / 3.5</cell><cell>2.7 / 1.4</cell><cell>-/ -</cell></row><row><cell>SandyBridge 2.7 GHz (2.7 GHz, 16 cores, 64 GB)</cell><cell>18 / 13</cell><cell>30 / 12</cell><cell>27 / 11</cell><cell>15 / 9.1</cell><cell>5.5 / 5.1</cell></row><row><cell>Xeon Phi 7110P (1.33 GHz, 61 cores, 16 GB)</cell><cell>14.3 / 12.5</cell><cell>27 / 13.5</cell><cell>20 / 10.1</cell><cell>14.5 / 8.3</cell><cell>-/ -</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This research was supported by the Argonne Leadership Computing Facility under the U.S. Department of Energy, Office of Science, Office of Basic Energy (Award Number DE-AC02-06CH11357); by the NSF CISE ACI-0904631 at the University of Utah; and by the Intel R Parallel Computing Center program. The authors would like to thank Paul Navratil at Texas Advanced Computing Center for access to the CosmicWeb data. We thank the DOE IN-CITE program for access to data sets at ALCF, as well as Martin Berzins, Todd Harman and Jacqueline Beckvermitt at the University of Utah for the Uintah data sets; Ken-ichi Nomura, Aiichiro Nakano and Ying Li at University of Southern California for the SiO 2 and Al 2 O 3 -SiC data sets; and Kah Chun Lau and Larry Curtiss at Argonne National Laboratory for the Nanosphere. We also thank Mark West at Intel, and Janene Ellefson and Ryan Baxter at Micron, for their generous donations of hardware. Intel, Xeon, and Xeon Phi are trademarks of Intel Corporation in the United States and other countries. Other names and brands may be claimed as the property of others.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">SPHRAY: a smoothed particle hydrodynamics ray tracer for radiative transfer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Altay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Croft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Pelupessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Monthly Notices of the Royal Astronomical Society</title>
		<imprint>
			<biblScope unit="volume">386</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1931" to="1946" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="509" to="517" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Splotch: visualizing cosmological simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dolag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reinecke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gheller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Imboden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Journal of Physics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page">125006</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient high-quality volume rendering of SPH data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fraedrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Auer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transȯn Visualization and Computer Graphics (TVCG)</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Exploring the millennium run: scalable rendering of large-scale cosmological datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fraedrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics (TVCG)</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Technical strategies for massive model visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kasik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-E</forename><surname>Yoon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 ACM symposium on Solid and physical modeling</title>
		<meeting>the 2008 ACM symposium on Solid and physical modeling</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="405" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A coherent grid traversal approach to visualizing particle-based simulation data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">P</forename><surname>Gribble</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ize</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kensler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics (TVCG)</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Point-based graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">MegaMol Projektseite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grottel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
		<respStmt>
			<orgName>Universität Stuttgart VISUS</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Visualization of Electrostatic Dipoles in Molecular Dynamics of Metal Oxides</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grottel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Reina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-R</forename><surname>Trebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics (TVCG)</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2061" to="2068" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Heuristic Ray Shooting Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Havran</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Faculty of Electrical Engineering, Czech TU in Prague</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Realistic Image Synthesis Using Photon Mapping. A K Peters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">W</forename><surname>Jensen</surname></persName>
		</author>
		<idno>1-56881-147-0</idno>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Simultaneous GPU-assisted raycasting of unstructured point sets and volumetric grid data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kähler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Abel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth Eurographics/IEEE VGTC conference on Volume Graphics</title>
		<meeting>the Sixth Eurographics/IEEE VGTC conference on Volume Graphics</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">RBF Volume Ray Casting on Multi-core and Many-core CPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Navratil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bowen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Reda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gaither</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="71" to="80" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Ray tracing and volume rendering large molecular data on multi-core and many-core architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Navrátil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Gaither</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Ultrascale Visualization</title>
		<meeting>the 8th International Workshop on Ultrascale Visualization</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Illustrative visualization of molecular reactions using omniscient intelligence and passive agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Le</forename><surname>Muzic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Parulek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-K</forename><surname>Stavrum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Viola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="141" to="150" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">CHC+RT: Coherent Hierarchical Culling for Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mattausch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bittner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jaspe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Avetisyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Willert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="2329" to="2334" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Topology-caching for dynamic particle volume raycasting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Orthmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kolb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Vision, Modeling and Visualization</title>
		<meeting>Vision, Modeling and Visualization<address><addrLine>Siegen, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="147" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ospray</surname></persName>
		</author>
		<ptr target="https://ospray.github.io" />
		<title level="m">Ray Tracing based rendering engine for High-Fidelity Visualization</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ISPC -A SPMD compiler for highperformance CPU programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pharr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Innovative Parallel Computing (inPar)</title>
		<meeting>Innovative Parallel Computing (inPar)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">SPLASH: An interactive visualisation tool for Smoothed Particle Hydrodynamics simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Publications of the Astronomical Society of Australia</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="159" to="173" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Visualizing large-scale atomistic simulations in ultra-resolution immersive environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Reda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nomura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leigh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Large Scale Data Analysis and Visualization (LDAV)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="59" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Large-Scale Parallel Visualization of Particle Datasets using Point Sprites and Level-of-Detail</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rizzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hereld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Insley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Uram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vishwanath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Symposium on Parallel Graphics and Visualization (EGPGV)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">yt: A multi-code analysis toolkit for astrophysical simulation data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Oishi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Skory</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Skillman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Abel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Norman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Astrophysical Journal Supplement Series</title>
		<imprint>
			<biblScope unit="volume">192</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Faster Isosurface Ray Tracing using Implicit KD-Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Marmitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Slusallek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="562" to="573" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Interactive Rendering with Coherent Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Slusallek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Benthin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Embree-A Ray Tracing Kernel Framework for Efficient CPU Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Woop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Benthin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGGRAPH)</title>
		<meeting>ACM SIGGRAPH)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
