<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hardware-Software-Balanced Resampling for the Interactive Visualization of Unstructured Grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manfred</forename><surname>Weiler</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Visualization and Interactive Systems Group</orgName>
								<orgName type="institution">University of Stuttgart</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Hardware-Software-Balanced Resampling for the Interactive Visualization of Unstructured Grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>In this paper we address the problem of interactively resampling unstructured grids. Three algorithms are presented. They all allow adaptive resampling of an unstructured grid on a multiresolution hierarchy of arbitrarily sized cartesian grids according to a varying element size. Two of the algorithms presented take advantage of hardware accelerated polygon rendering and 2D texture mapping. In exploiting new features of modern PC graphics adapters, the first algorithm tries to significantly minimize the number of polygons to be rendered. Reducing rasterization requirements is the main goal of the second algorithm, which distributes the computational workload differently between the main processor and the graphics chip. By comparing them to a new pure software approach, an optimal software-hardware balance is studied. We end up with a hybrid approach which greatly improves the performance of hardwareassisted resampling by involving the main processor to a higher degree and thus enabling resampling at nearly interactive rates.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the last couple of years great advances have been made in the rendering of unstructured volume data. Still the performance of all reported algorithms is below the interactive frame rates which can be achieved for high resolution regular grids using texture based volume rendering <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> or dedicated graphics hardware <ref type="bibr" target="#b5">[6]</ref>. Resampling the unstructured volume data on cartesian grids seems therefore to be one promising approach to achieve interactive visualization.</p><p>Accurate resampling, however, has to adjust the resolution for the regular grid to the size of the smallest element of the unstructured grid, producing huge amounts of data for meshes of practical sizes. Since cells may vastly vary in size, large elements of the grid will lead to regions of only small data variation. Hardware assisted volume rendering of such reconstructed large scale data sets is severely hampered by the limited amount of physical texture memory available. Once texture paging is required frame rates drop significantly.</p><p>Adaptive resampling is therefore highly indicated. Instead of a single regular grid a multiresolution hierarchy is used for the reconstruction of the unstructured grid. Methods for artifact-free texturebased interactive rendering of multiresolution 3D scalar fields have recently been reported <ref type="bibr" target="#b9">[10]</ref>. The resolution for a certain area can either be based on static characteristics of the unstructured grid like the size of cells contained in that area or based on dynamic criteria, e.g. the user focus. As the latter usually is not defined prior to the visualization and may change during this process, we are highly interested in an interactive resampling algorithm, since storing a cartesian grid with the full resolution is time consuming and introduces a huge memory overhead. The fastest resampling algorithms that can be found in the literature exploit the graphics hardware and are based on slicing. As such approaches render a huge number of polygons, they are heavily limited by the rasterization performance of the graphics chip. Therefore, a worthwhile objective is to reduce the number of polygons required for resampling. Hardware accelerated resampling, however, has the main drawback that the capacity of ever faster main processors is not used. The CPU degenerates to a pure triangle generator. High performance resampling requires to balance workload between the main processor and the graphics chip in order to minimize the time for resampling. This paper addresses the problem of workload distribution for the interactive construction of a resampling hierarchy. Three different algorithms are introduced. While one of them uses only the CPU the other two also exploit graphics hardware for optimal performance. The difference between the hardware accelerated algorithms introduced lies in the distribution of certain computational tasks between the CPU and the graphics processor, thereby allowing the evaluation of the optimal workload balancing.</p><p>The remainder of this paper is organized as follows. After a brief look at related work we first describe a hardware accelerated resampling algorithm highly exploiting features of modern PC graphics adapters in Section 3. In contrast to that a pure software solution is introduced in Section 4. A hybrid hardware-software algorithm with a much better workload balance is described in Section 5. We conclude with some results and areas of future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>Techniques for resampling an unstructured grid can be classified into image order and object order algorithms. Image order algorithms iterate over the elements of the destination cartesian grid and try to figure out the data value for these grid points. This includes two tasks. The first is to determine the element of the unstructured grid enclosing this position, also refered to as point location. The second step is the data interpolation within the located element. The major drawback of this approach is the cost of the point location process. Although it can be significantly accelerated by the use of an octree <ref type="bibr" target="#b12">[13]</ref>, it still dominates the time for data interpolation. A different idea is to use connectivity information of the unstructured grid which induces an additional overhead of memory and of computational effort for the initialization.</p><p>Object order algorithms on the other hand iterate over the elements of the unstructured grid, determining all cartesian grid points enclosed within the boundary of the element. Each of these points is assigned a data value interpolated from the nodes of the currently considered element. On this account object order resampling is very closely coupled with the problem of 3D-scan conversion also refered to as voxelization, which has been studied for quite a while. Besides the software solutions <ref type="bibr" target="#b2">[3]</ref>, which fundamentally extend 2Dscan conversion to the 3D case, more recently several authors tried to exploit graphics hardware for fast voxelization.</p><p>Similar to techniques for the direct rendering of unstructured grids <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref> slicing is used taking advantage of hardware accelerated polygon rendering. The cartesian grid into which the unstructured grid is being resampled is considered in slices perpendicular to the z-axis, one slice per voxel layer. For each slice the set of intersection polygons of the slice plane with all unstructured grid elements is rendered. The graphics hardware will then interpolate data during the rasterization process without interference of the main processor and the result can be read back from the framebuffer or directly loaded into a texture map for visualization purpose.</p><p>Computing the intersection polygons can either be done explicitly <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref> or implicitly on a per-pixel basis by taking advantage of dedicated graphics hardware providing per-fragment tests and operations <ref type="bibr" target="#b10">[11]</ref>. The most recent approach doing so was reported in <ref type="bibr" target="#b11">[12]</ref>. Their idea, however, requires computing the decomposition of the projected tetrahedron according to the Shirley-Tuchmanclassification (ST) <ref type="bibr" target="#b7">[8]</ref>. Besides introducing computational overhead and the need for rendering the ST-decomposition twice for every slice, this approach also suffers from the overall polygon count, which significantly exceeds the number of elements in the grid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Hardware-supported slicing</head><p>As stated before our objective is the construction of a multiresolution hierarchy of cartesian grids from unstructured grids by resampling. The core element of this process is the resampling of (parts of) the unstructured grid into a single cartesian grid of predefined resolution. The first algorithm we introduce makes extensive use of the graphics hardware by utilizing a slicing technique similar to those reported in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref>. The destination grid is considered on a slice-by-slice basis, one slice per voxel layer along the z-axis. For each slice the set of intersection polygons of a plane in the middle of the slice with all elements of the unstructured grid is rendered. After processing a single slice the result can be read back from the framebuffer for rendering or saving the result on disk. However, our algorithm neither computes intersection polygons explicitly nor renders more than two polygons per tetrahedron. In this point our algorithm is superior to <ref type="bibr" target="#b11">[12]</ref>. In fact the core idea of our algorithm is simply to render a single slightly larger polygon and let the rasterization hardware determine the intersection with the tetrahedron via fragment operations. As the rendered polygon does not necessarily need to consist of tetrahedral faces we call it substitute geometry.</p><p>Using texture mapping and programmable fragment operations of modern graphics adapters we ensure that only fragments of the substitute geometry on the intersection polygon will actually be written into the framebuffer. In addition to that the rendering must correctly interpolate data values for each fragment written into the framebuffer. Both can be achieved by using barycentric coordinates as texture coordinates (see <ref type="figure" target="#fig_0">Figure 1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The substitute geometry</head><p>In order to gain an optimal resampling performance the polygon rendered for each tetrahedron has to be selected quite carefully with respect to the computational cost of its calculation and the size of the area in the framebuffer which is covered by the polygon. On the one hand it must at least cover the silhouette of the considered tetrahedron. On the other hand larger polygons result in higher rasterization costs for that primitive, decreasing the overall performance.</p><p>Therefore, a triangle strip consisting of either the front faces or the back faces of the tetrahedron is selected as a substitute geometry. The decision between front faces and back faces is made with respect to a minimal number of polygons. We usually select the front faces unless the number of back faces is smaller than the number of front faces. The three different cases can be seen in <ref type="figure" target="#fig_1">Figure 2</ref>. By this scheme we can guarantee that the projection of the substitute geometry onto the image plane is equal to the tetrahedron's silhouette and that it is either a single triangle or a set of two triangles which -considered as a tristrip -can be rendered with three or four vertices, respectively. Furthermore, no vertex of the tristrip has to be computed since they are all given by the tetrahedron data structure. The vertex order for the tristrips can efficiently be determined by a lookup-table holding all possible vertex orderings. The table is indexed by the front-back-classification of the tetrahedron's faces.</p><p>Note that the ST-decomposition requires two more triangles and vertices on average. It produces either three or four triangles, which must be rendered using at least five or six vertices, respectively. At least one vertex, the interior vertex, of the ST-triangulation has to be computed from the intersection of two selected edges projected onto the image plane. Although this calculation is not very expensive, it introduces a significant overhead compared to the table lookup.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Identifying the intersection</head><p>At this point, we have to ensure that data should only be drawn at pixels covered by the intersection between the slice plane and the tetrahedron. Thus we need a suitable characterization for points within a tetrahedron. A well known fact is that every 3D-point can also be defined by the four components of the barycentric coordinate system of a tetrahedron. The components are proportional to the distance of the point from one face of the tetrahedron. Considering barycentric coordinates the following statement holds: A 3Dpoint lies within a tetrahedron iff each component of the barycentric coordinates of this point with regard to the considered tetrahedron is included within the interval 0 1].</p><p>This fact paves an elegant way to refrain fragments outside the intersection polygon from being written into the framebuffer. Suppose each fragment could be equipped with its barycentric coordinates according to the tetrahedron under consideration. We can use a texture map to assign α = 1 only to fragments inside the tetrahedron and α &lt; 1 elsewhere. Thus all fragments outside will automatically be removed by enabling the OpenGL alpha test.</p><p>This basic idea though would require a 4D-texture map since we need four components for barycentric coordinates. However such multidimensional textures are only supported by high end graphics systems. On the other hand a 4D-texture map would be an unnecessary waste of texture memory as will be illustrated now.</p><p>Fortunately, the relation stated above can also be considered for each component independently. We start by taking the first component. If it is included in the interval 0 1], then the fragment will possibly be inside the tetrahedron otherwise it can definitely be rejected. This also holds for the remaining three components. Taking into account the definition of the alpha values as stated above we can individually map each component of the barycentric coordinates to alpha values and compute the combined fragment classification by multiplying the four alpha values. Only if each of the factors is equal to 1 the product will also be equal to 1 denoting that each component of the barycentric coordinates is included in 0 1]. Thus we can make use of standard OpenGL 1.2 multitextures and a modulate environment which will exactly perform the mentioned operations using a 1D-texture map as illustrated in <ref type="figure" target="#fig_2">Figure 3</ref>. However, conceptually four texture stages would be required. Only the first and the last element of the texture map has an alpha value of 0. The rest of the elements are set to α = 1. A simple linear mapping from barycentric coordinates b i to texture coordinates t i assures that b i = 0 and b i = 1 will be mapped to the centers of the first and last non transparent texels at t i = 3=(2N) and at t i = 1 ;3=(2N), respectively:</p><formula xml:id="formula_0">α = 0 α = 1 α = 0 b i = 0 b i = 1 3/(2N) 1-3/(</formula><formula xml:id="formula_1">t i = b i 1 ; 3 N + 3 2N</formula><p>This is performed using the OpenGL texture matrix, which is multiplied with each of the texture coordinates.</p><p>Note that we also could have used the texture border facility of OpenGL instead of defining a surrounding shell of transparent texels, but as this functionality is only available on certain graphics hardware this would have introduced unnecessary hardware restrictions.</p><p>Another problem arises from the four texture stages required. Most of the graphics hardware nowadays available does either support not more than two hardware accelerated multitextures or is optimized for two texture stages. Thus we slightly adapt the introduced concept and take two 2D-textures instead. The four components of the barycentric coordinates are distributed between two 2D texture maps, where the first map covers the components (b 0 b 1 ) and the second map uses (b 2 b 3 ) as texture coordinates. The content of both maps is actually the same built conceptually by the orthogonal product of the former described 1D function, which results in a one texel wide transparent border surrounding a block of elements with α = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Rasterization of intersection polygons</head><p>With texturing set up as described we just have to render the substitute geometry of the tetrahedron for each slice. Every vertex of the substitute geometry is assigned the set of four barycentric coordinates as two 2D texture coordinates for the first and second texture state, respectively. But instead of using the vertex positions of the rendered triangles to determine the barycentric coordinates we take the coordinates of the projection of those points onto the current slice plane. As illustrated in <ref type="figure" target="#fig_3">Figure 4</ref> this leads to the correct rendering of the intersection polygon. Consider the rightmost case in <ref type="figure" target="#fig_3">Figure 4</ref>. The gray line denotes the substitute geometry to be rendered, the slightly shifted line denotes the fragments that will pass the alpha test. The area of the substitute geometry which is not removed by the alpha test exactly covers the same pixels as the black intersection polygon of the slice plane and the tetrahedron when projected onto the image plane by the model-view transformation.</p><p>Note that this only works because the barycentric coordinates vary linearly in the same way as the texture coordinates along the rendered triangles. In order to handle negative barycentric coordinates correctly we have to use the clamp texture environment.</p><p>We also state that although our implementation uses orthographic projection for the resampling on a cartesian grid this also works for rendering the intersection polygons with perspective projection. It is also not required that the orientation of the slice plane is perpendicular to the view direction. So the same method can be applied to rendering an arbitrary oriented slice probe within the unstructured grid as proposed in <ref type="bibr" target="#b8">[9]</ref>. We demonstrate this in <ref type="figure">Figure</ref> 14.</p><p>Determining the texture coordinates as stated seems to be a quite costly operation since the point projection requires the computation of a dot product and a vector addition. The transformation of the projected point into barycentric coordinates takes four dot products. We will show in Section 3.5, however, that the computations necessary can actually be reduced to a single product and a scalar sum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Hardware-supported data interpolation</head><p>We have shown that the restriction of the fragments written into the framebuffer to the intersection of the tetrahedron with the slice plane can be achieved via standard OpenGL 1.2 functionality. This does not apply to the interpolation of the data values. Our approach uses the programmable fragment arithmetic provided by current PC graphics hardware, i.e. NVidia's GeForce family of GPUs. The chip allows for the flexible combination of fragment color and texture samples during rasterization <ref type="bibr" target="#b3">[4]</ref>.</p><p>Using this functionality we additionally apply a primary and a secondary color to each substitute geometry on a per-element basis. Each vertex of the geometry gets assigned the same color. Only the R and G values of the colors are actually used, B and A are set to zero. The primary color holds the data values of the first and the second tetrahedral node. The R and G channel of the secondary color are set to the data values of the third and fourth node.</p><p>Taking this into account the data interpolation within the tetrahedron actually consists of a dot product of the barycentric coordinates and a vector built from the non-zero components of the primary and secondary color.</p><formula xml:id="formula_2">s(b) = 3 ∑ i=0 b i s i = b 0 b 1 R P G P + b 2 b 3 R S G S</formula><p>In order to provide the fragment arithmetic with the barycentric coordinates we have to add further information to the texture map. The R and G channel of the texture map is set to the first and second component of barycentric coordinates, therefore identically mapping the provided texture coordinates to texture lookup values. Note that we do not have to take special care of coordinates outside the tetrahedron. Although clamping of texture values would lead to incorrect results, the alpha setting of our texture still guarantees that no incorrectly interpolated value will be written to the framebuffer. The required setup of the register combiners is shown in <ref type="figure" target="#fig_6">Figure 5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Implementation details</head><p>In order to gain optimal performance we use an active-element list similar to that introduced in <ref type="bibr" target="#b14">[15]</ref>. This significantly reduces the number of elements that have to be considered for a single slice. After the slice direction was stated the model coordinate space is divided into a certain predefined number of indexed slabs parallel to the slice plane. Every element of the grid is inserted into at most two slabs. These are exactly the slabs with the lowest and highest index containing one of the element's nodes. Note that there may also be elements only belonging to a single slab if all nodes are contained within this slab.</p><p>Each time a new resampling slice has to be processed we determine whether the slice is still covered by the current slab. If this is not the case the elements contained in the new slab will be inserted into the active-element list and those already there will be removed instead. After this step the active-element list contains a subset of all elements which are potentially hit by the current slice and we only have to process these elements. Special care has to be taken of the elements only contained in a single slab since they will not be removed from the active-element list by the scheme mentioned above.</p><p>An additional speedup has been achieved by the incremental computation of the barycentric coordinates. For each tetrahedron inserted into the active-element list, the increments of the barycentric coordinates along the slice direction are computed. These increments specify how the barycentric coordinates of a point change if it is moved perpendicularly onto the next slice plane. For a fixed slice distance and a specific tetrahedron these values are constant. They can be computed from the partial derivatives of the barycentric coordinate transform along the slice direction. Using the increments, computing the barycentric coordinates of the element's nodes projected onto the new slice plane is straight forward. We just have to add the increments to the coordinates used on the former slice.</p><p>Even for the first slice hitting the element an explicit computation of the barycentric coordinates for projected nodes can be avoided as is illustrated in <ref type="figure">Figure 6</ref>. We take the barycentric coordinates of the tetrahedron vertices as a reference and add the computed increments scaled by the distance of the vertex form the slice plane normalized by the slice plane distance. The barycentric coordinates of the tetrahedral nodes are given by a vector with a single 1 as the component with the same index as the node. All other components are zero. E.g. the barycentric coordinates of the 0 th node are (1 0 0 0) and the coordinates of the 2 nd node are (0 0 1 0).</p><p>The barycentric coordinates of the projected nodes can thus be computed without knowing the position of the projected nodes. A projection actually never has to take place which saves much computational effort. (refer to Section 3.3).  <ref type="figure">Figure 6</ref>: The barycentric coordinates of the nodes of an element projected onto the slice plane can be computed without actually projecting. We add the scaled barycentric coordinate increment to the barycentric coordinates of the nodes. The scale factor is the distance of each node divided by the slice plane distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Software-resampling</head><p>As we stated before hardware accelerated voxelization and resampling algorithms suffer from the limited memory bandwidth between the graphics chip and its associated memory. Another problem of using the graphics hardware for resampling is that the accuracy of the result is limited by the framebuffer depth and the number of bits in the hardware for compositing the RGBα channels. On PC graphics cards fragment operations and framebuffer depth are typically 8 bits per channel, on high end graphics sometimes 12 bits can be found. Software resampling can be performed with float or double precision instead. In order to investigate this combination of circumstances in more detail we want to compare our hardware accelerated approach with a pure software solution.  We utilize a cell order rather than an image order algorithm since this has proven to be the superior approach followed by many authors before <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref>. For each tetrahedron of the unstructured grid we determine the voxels of the resampling grid covered by that tetrahedron. Data values are interpolated from the scalar values given at the nodes of the tetrahedron. The results are written to the appropriate location of the resampling grid. The main advantages of this approach are that voxels of the unstructured grid not covered by any tetrahedron do not have to be touched and that the voxel processing within the tetrahedra can take advantage of spatial and data coherence.</p><p>Following this idea, each tetrahedron of the unstructured grid is processed individually. After determining the bounding box of the tetrahedron within the resampling grid, it is processed on a perscanline basis. The orientation of the scanline is selected according to the size of the bounding box. We choose the orientation of the largest extent of the bounding box, maximizing the average scanline length and thus taking most benefit from the data coherence. For the rest of this section the scanlines are considered to be parallel to the x-axis without loss of generality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Scanline processing</head><p>Looking at a single scanline within the bounding box of a tetrahedron it can be noticed that only a small portion of the line actually lies within the tetrahedron. Starting outside, the scanline enters the tetrahedron at a certain voxel. After leaving the tetrahedron at the so called exit voxel, the scanline ends outside again. Since outside voxels do not contribute to the resampling result fast resampling requires efficient skipping of these voxels. This is even more important as the number of outside voxels within the bounding box exceeds the number of inside voxels by an average factor of 5-6. We therefore explicitly compute the indices of the entry and exit voxel for every scanline employing barycentric coordinates.</p><p>As <ref type="figure" target="#fig_7">Figure 7</ref> illustrates we consider the start voxel j 0 and the end voxel j 3 of each scanline. We compute the positionsx s andx e of the centers of this voxels in the coordinate system of the unstructured grid. Using the corresponding barycentric coordinate vectorsb s and b e of that points we define component-wise distance vectors∆ s and ∆ e as follows: Note that in the following equations the partial derivatives have to be scaled with respect to the grid spacing along the scanline axis.</p><formula xml:id="formula_3">∆ s i = 8 &lt; : b s i ;1 if b i &gt; 1 0 i f 0 b i 1 b s i</formula><formula xml:id="formula_4">j 1 = j 0 + &amp; max i ;∆ s i ∂b i ∂x ' j 2 = j 3 ; &amp; max i ∆ e i ∂b i ∂x '</formula><p>So we can limit the processing of each scanline to those voxels between j 2 and j 3 including both border voxels.</p><p>Note that for a point on the scanline to the left of the tetrahedron the following can be shown: If a component of the distance vector ∆ s of that point is negative, then the corresponding component of the partial derivative will be positive and vice versa. For a point to the right of the tetrahedron the components of the direction vector ∆ e and the corresponding partial derivative share the same sign.</p><p>The data interpolation of each voxel along the scanline can benefit from the linear variation of data values within the tetrahedron. Thus, the interpolated data values of two adjacent voxels along the scanline differ by a constant increment δ. It can be precomputed per tetrahedron as follows:</p><formula xml:id="formula_5">δ = ∂b 0 ∂x ∂b 1 ∂x ∂b 2 ∂x ∂b 3 ∂x (s 0 s 1 s 2 s 3 )</formula><p>Our algorithm needs to compute an interpolated data value only once at the beginning of each scanline. For the following voxels it just adds δ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Optimization</head><p>One drawback of the scanline processing as introduced above is the computational overhead for the initialization of each scanline. Especially computing the barycentric coordinates of the start and end voxel of the scanline is a quite time consuming operation. However, this can be reduced by exploiting incremental coordinate computation. In the same way as we use partial derivatives along the x-axis for fast skipping of empty voxels, we can use the partial derivatives along y-and z-axis for incrementally updating the barycentric coordinates of the start and end point of each scanline. Explicit computation of the barycentric coordinates is only performed once for the first scanline of the tetrahedron's bounding box.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Hybrid resampling</head><p>As the hardware-assisted resampling technique proposed in this paper tries to shift as much of the computational expense onto the graphics chip, the pure software solution denotes the other extreme. We therefore propose a hybrid technique for optimally exploiting both CPU and GPU to gain best performance in resampling.</p><p>In Section 3 we stated that hardware-assisted approaches are mainly rasterization bound, which is influenced by the memory bandwidth between the graphics processor and its associated memory. This encourages two optimizations of our approach.</p><p>Reduce memory bandwidth requirements of rasterization by rendering color shaded polygons instead of using (multi-)textures. The need for texture lookups and bilinear texture interpolation is thus completely omitted. This significantly decreases the complexity of rasterization.</p><p>Reduce the total number of fragments to be processed by limiting the rendered polygons to the area for which actually pixels are written into the framebuffer.</p><p>The latter means that we have to explicitly compute the intersection polygon of the tetrahedron with every considered slice plane. Note that this polygon can also be interpreted as an isosurface of a scalar field mapping each node of the tetrahedron to its distance from the slice plane. Taking this into account we utilize an adaption of the marching cubes <ref type="bibr" target="#b4">[5]</ref> classification scheme to tetrahedra to determine the number and the location of the vertices of the intersection polygon. For each edge of the tetrahedron that is identified to be intersected by the isosurface, the actual position and data value are linearly interpolated from the endpoints of the edge.</p><p>In order to minimize the number of tetrahedra to be processed for a certain slice plane our implementation of the hybrid slicing method also makes use of the active-element list described above. The distance of each node from a slice base plane which is used for inserting elements into the list can now be reused for optimization purposes. Subtracting the distance of the current slice plane from the base plane gives us a signed value for each node. The sign of these values can be used as the inside-outside-classification needed for the lookup of the correct triangle setup. In addition to that these values also define the correct interpolation weights for the intersection of the edges with the isosurface and the linear interpolation of data values.</p><p>We thus render the intersection polygons with the data values color-mapped at the triangle vertices. With the triangle setup as described the graphics hardware computes the trilinearly interpolated data values on the slice plane intersection into the framebuffer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results and analysis</head><p>In this section we analyze the performance of the different resampling algorithms introduced in this paper. All tests were per-formed on a Linux PC with an AMD Athlon 900 MHz processor, an NVidia GeForce2 GTS graphics adapter with 32 MB DDR RAM and 256 MB main memory. The graphics adapter was connected to the mainboard via AGP4x. The experiments used the bluntfin data set converted to 220K elements and a finite element data set consisting of 120K elements.</p><p>We directly compared our hardware accelerated algorithm using multitextures and register combiners (MultiComb) and the hybrid resampling algorithm (Hybrid) with a reimplementation of the most recently published approach by Westermann <ref type="bibr" target="#b11">[12]</ref>. As can be seen in <ref type="figure" target="#fig_0">Figures 8 -10</ref> our reimplementation achieved timings comparable to those published in <ref type="bibr" target="#b11">[12]</ref>. In the tables WestSingle denotes to the algorithm which renders the ST-triangulation of each tetrahedron two times with a single texture, the improved version using multitextures and register combiners we named WestM/C.</p><p>The tables show the total time (ToT) for rendering which can be divided into the time needed for building the active-element list (Ael) and the time the graphics subsystem consumes for rendering the elements (Rnd).</p><p>Note that we did not take into account the time for reading the interpolated slices from the framebuffer nor the time to define a 2D or 3D texture via direct copy from the framebuffer. When comparing the hardware accelerated approaches this time can be neglected since all algorithms require the same read operations and therefore the same time. We state though, that resampling time is dominated by the rendering. It took 0.12s to read the 64 slices of the heat-sink data set at resolution 64 <ref type="bibr" target="#b2">3</ref> into main memory and 0.72s to read the 256 slices at resolution 256 <ref type="bibr" target="#b2">3</ref> . The copy operation from the framebuffer to a stack of 2D texture maps was about three times faster. Taking a look at <ref type="figure">Figure 9</ref> the first noticeable point is that Westermann's resampling algorithm already suffers from rasterization limits. This can be seen from the fact that the multitexture version only gains a speedup factor of approximately 1.2 although it renders only half of the polygons of the single texture version. This speedup factor improves slightly with increasing number of resampling slices as the time for constructing the active-element list remains nearly constant.</p><p>Our hardware accelerated algorithm (MultiComb) requires only about one third of the polygons and half of the vertices used by WestM/C for the same resampling result. This reflects the fact that we render 1.5 polygons per slice and tetrahedron whereas the STdecomposition used in <ref type="bibr" target="#b11">[12]</ref> produces 3.5 polygons on average. Note that for small resolutions our algorithm is significantly faster than WestM/C. The performance benefit results from the saved time for ST-decomposition, which can be seen from the Ael columns in <ref type="figure">Figures 8 and 9</ref> including the time of decomposition. However, the Rnd columns indicate that rendering is also significantly faster although the same polygonal area has to be rasterized. Applied to a high resolution cartesian grid the performance of our hardware accelerated resampling algorithm significantly drops. Obviously it is even more rasterization bound than WestM/C due to the quite expensive fragment operations used. In reducing only the x-and y-resolution and leaving the number of slices constant we have verified that slice processing and triangle composition is not the limiting factor. However, this is no restriction for the construction of a multiresolution hierarchy of cartesian grids for adaptive rendering of unstructured grids. This hierarchy will not consist of a single large cartesian grid into which the unstructured grid will be resampled. A number of small sized cartesian grids only covering parts of the unstructured grid will rather be used instead.</p><p>The hybrid resampling algorithm achieves speedup factors between 1.5 and 2.5 compared to WestM/C for the tested datasets. The pure time for rendering could be reduced by a factor of 1.4-1.8. The remainder results from a significantly faster per frame initialization (Ael). Compared to the hardware accelerated algorithm we also save the computation of the partial derivatives of the barycentric coordinate transform along the slice direction. With the timings presented here realtime resampling actually comes into reach based on the hybrid approach.</p><p>Although our current implementation of the software resampling algorithm can still be optimized the achieved timings shown in <ref type="figure" target="#fig_0">Figure 11</ref> are quite noticeable. As we expected the software approach is slower than hardware and hybrid resampling. However, in many cases, especially for small resampling resolutions it beats WestSingle and WestM/C. Note that when comparing them to one of the hardware approaches the time for reading the interpolated slices back from the framebuffer has to be taken into account. Unexpectedly, switching the scanline direction according to the largest dimension of the tetrahedra's bounding box has proven to be a key feature for good performance. Especially for the bluntfin data set the average length of incremental voxel processing within the tetrahedron could be dramatically increased, e.g. from 2.95 to 7.38 voxels for resampling on a 256 3 grid and from 5.00 to 14.41 voxels for a 512 <ref type="bibr" target="#b2">3</ref> . Processing the cartesian grid in y-or z-direction normally should be slower due to the awkward memory access scheme with a high probability of cache misses. However, in our implementation the increased scanline length seems to over-compensate this fact, at least on the AMD Processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>heat-sink</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Resolution</head><p>Further tests have shown that for small sizes of the cartesian grid the runtime of our algorithm is nearly linear with the number of elements, since the initialization time for each tetrahedron dominates the time for traversing the scanlines. For cartesian grids larger than 256 <ref type="bibr" target="#b2">3</ref> we observe a more linear behaviour with the number of voxels. Still the main advantages remain: Software resampling allows higher order interpolation and provides higher resampling accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and future work</head><p>In this work we have studied different algorithms for resampling unstructured grids. We demonstrated three different approaches trying to estimate which is most promising for (nearly) interactive resampling.</p><p>Our hardware accelerated resampling approach has proven to be as fast as recently reported nearly interactive resampling algorithms. Our algorithm, however, requires 2-4 times fewer polygons for the same result. Performance improvements have been below our expectations, because slicing algorithms are mainly rasterization bound. Though suffering from lower accuracy due to the limited framebuffer and pixel-path resolution, the hardware approach is significantly faster than our software solution.</p><p>We have demonstrated that exploiting graphics hardware to the maximum extent may not result in optimal performance. Instead subtle workload balancing leaving more computational effort to the main processor can gain much better results. We have shown this with our hybrid algorithm.</p><p>Currently we are investigating our algorithms on different platforms including PC and graphics workstations. The performance of software resampling may heavily depend on hardware characteristics like integer or floating point performance, cache sizes and caching strategies. The timings of our hybrid approach will surely depend on the rasterization performance and the computational power of the CPU.</p><p>Additional time should be spent on optimizing software resampling. Another problem that should be addressed is the accuracy of hardware accelerated techniques.</p><p>With a fast resampling algorithm for unstructured grids available we now can use an adaptive multiresolution hierarchy of regular grids for interactive rendering of unstructured grids. Future work will concentrate on the dynamic construction of this hierarchy. The adaption of this hierarchy to the characteristics of the unstructured grid like the element size and to visualization parameters like the user focus will be of further interest.   An arbitrary oriented cut plane is rendered within the bluntfin data set and the heat-sink data set with perspective projection. The plane is rendered using our hardware accelerated slicing algorithm. We use an octree for determining the tetrahedra hit by the cut plane and render the front faces of this tetrahedra only. The actual intersection polygons and the interpolated scalar values are determined by the graphics hardware via fragment operations. In both cases the frame rate was faster than 8 fps on an AMD Athlon 900 processor with GeForce2 GTS graphics adapter.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>The basic principle of the method is demonstrated. On the left, slicing perpendicular to the view direction is performed by rendering the substitute geometry (silhouette of the tetrahedron). Texture mapping and alpha test ensures that only the fragments of the intersection polygons are actually written into the framebuffer. On the right a visualization of the texture coordinate mapping is demonstrated. The semi transparent polygons show the projection of the substitute geometry onto the slice plane. The barycentric coordinates of the vertices of that polygon with respect to the tetrahedron are coded as texture coordinates of the rendered geometry.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>The tree different cases of substitute geometry. We render front faces of the tetrahedron unless the number of front faces exceeds the number of back faces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Texture that maps a single component of the barycentric coordinates to alpha values according to inside-outside classification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Sectional views of the three different cases of substitute geometry sorted by the number of front faces from left to right. The gray lines denote the faces of the tetrahedron to be rendered as a substitute geometry. The texture coordinates assigned to its vertices are conceptually determined by projecting the vertices onto the slice plane and computing the barycentric coordinates of the projected points with respect to the tetrahedron to be sliced. With texture mapping and alpha test appropriately set up only fragments are written which coincide with the intersection polygon of the slice plane and the tetrahedron viewed from a direction perpendicular to the slice plane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>The register combiner setup for correct data interpolation. The RGB-portion computes the interpolated value, the alpha portion simulates the multitexture modulate environment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>otherwiseFigure 7 :</head><label>7</label><figDesc>The distance vectors consist of four components. A component is set to zero if the corresponding component of the barycentric coordinates is included within the interval 0 1]. Otherwise the component of∆ s measures the distance to this interval. The value of ∆ e i is defined analogously.∆ ∆ The figure illustrates the computation of the indices of entry and exit voxel within a bounding box scanline. for that particular tetrahedron the indices j 1 and j 2 of the entry and exit voxel can be easily computed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 :</head><label>12</label><figDesc>Both images show the bluntfin data set resampled on a 256 128 64 (left) and a 512 256 128 (right) cartesian grid and rendered via texture based volume rendering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Both images show the heat-sink data set resampled on a 128 3 (left) and a 256 3 (right) cartesian grid rendered with texture based volume visualization. We chose a non linear transfer function in order to emphasis the differences.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: An arbitrary oriented cut plane is rendered within the bluntfin data set and the heat-sink data set with perspective projection. The plane is rendered using our hardware accelerated slicing algorithm. We use an octree for determining the tetrahedra hit by the cut plane and render the front faces of this tetrahedra only. The actual intersection polygons and the interpolated scalar values are determined by the graphics hardware via fragment operations. In both cases the frame rate was faster than 8 fps on an AMD Athlon 900 processor with GeForce2 GTS graphics adapter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Thomas.Ertlg@informatik.uni-stuttgart.de .</figDesc><table><row><cell cols="4">Universität Stuttgart, IfI, Abt. VIS, Breitwiesenstr. 20-22,</cell></row><row><cell>70565 Stuttgart,</cell><cell>Germany;</cell><cell>E-mail:</cell><cell>fManfred.Weiler |</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>We like to thank Rüdiger Westermann for providing us a preprint of his paper and helping us with the re-implementation of his algorithms.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nancy</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Foran</surname></persName>
		</author>
		<idno>0-89791-741-3</idno>
	</analytic>
	<monogr>
		<title level="m">Symposium on Volume Visualization</title>
		<imprint>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Accelerating volume reconstruction with 3d texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Cullip</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Neumann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science,University of North Carolina, Chapel Hill</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report TR93-027</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">3D scan-conversion algorithms for voxel-based graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eyal</forename><surname>Shimony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Workshop on Interactive 3D Graphics</title>
		<meeting>of ACM Workshop on Interactive 3D Graphics<address><addrLine>Chapel Hill, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-10" />
			<biblScope unit="page" from="45" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">From Multitexture to Register Combiners to Per-Pixel Shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kirk</surname></persName>
		</author>
		<ptr target="http://www.nvidia.com/Developer" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Siggraph &apos;87 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The volumepro real-time ray-casting system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanspeter</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Hardenbergh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Knittel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugh</forename><surname>Lauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><surname>Seiler</surname></persName>
		</author>
		<idno>0-20148-560-5</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 99</title>
		<meeting>SIGGRAPH 99<address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-08" />
			<biblScope unit="page" from="251" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Volume rendering of unstructured grids-a voxelization approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Manohar</surname></persName>
		</author>
		<idno>0097-8493</idno>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="711" to="726" />
			<date type="published" when="1995-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the San Diego Workshop on Volume Visualization</title>
		<meeting>the San Diego Workshop on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1991-11" />
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Volume probes: Interactive data exploration on arbitrary grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Don</forename><surname>Speray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Kennon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (San Diego Workshop on Volume Visualization)</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="5" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Level-Of-Detail Volume Rendering via 3D Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zimmerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Volume Visualization and Graphics Sympsium</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficiently using graphics hardware in volume rendering applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH 98 Proceedings)</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="169" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Rendering of Unstructured Grids Revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruediger</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE Symposium on Visualization 2001 (Proceedings)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hierarchical and Parallelizable Direct Volume Rendering for Irregular and Multiple Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tarantino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="57" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Hardware Assisted Volume Rendering of Unstructured Grids by Incremental Slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Volume Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="55" to="63" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
