<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Normal Bounds for Subdivision-Surface Interference Detection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eitan</forename><surname>Grinspun</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">San Diego Paradise Point Resort</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">Schröder</forename><surname>Caltech</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">San Diego Paradise Point Resort</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Normal Bounds for Subdivision-Surface Interference Detection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: I.3.5 [COMPUTER GRAPHICS]: Computational Geometry and Object Modeling -Constructive solid geometry (CSG), Geometric algorithms, Hierarchy, Splines</term>
					<term>I.6.m [SIMULATION AND MODELING]: Miscellaneous -Collision detection</term>
					<term>G.1.2 [NUMERICAL ANALYSIS]: Approximation -Spline and piecewise polynomial approximation Subdivision Surfaces, Multiresolution Surfaces, Selfinterference, Gauss map, Loop&apos;s Scheme</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Collision detection in a thin-shell simulation. Given a control mesh of a bent tube, our algorithm identifies interfering regions on the limit surface up to a user-specified precision. Above, we have resolved interference with progressively increasing precision.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Interference detection algorithms are vital for simulation and animation. As examples, consider cloth simulation <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b25">26]</ref> and deformable object animation <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b31">32]</ref>. These applications must detect and correct self-interference and interference between surfaces. In constrained settings, when (a) the motion of objects can be expressed as a closed function of time, (b) the configuration of objects is simple or highly symmetrical, or (c) objects undergo only polynomial deformation, interference detection can be handled in simple ways through specific geometric optimizations. However, in a general setting, with complex deformations-such as wrinkling of cloth or buckling of aluminium-interference detection is difficult and time-consuming <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>Our particular interest in interference detection was born of a larger project-we simulate structures governed by the thin-shell equations, and produce physically realistic animations of crushing, crumpling, wrinkling, and other non-linear phenomena (see <ref type="bibr">Figure 1)</ref>. Previous publications on the Subdivision Element Method, by Cirak and other members of our team, describe the benefits of using subdivision surfaces in this setting <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>Subdivision surfaces are now widely deployed in many computer graphics and geometric modeling tasks (for an overview see <ref type="bibr" target="#b33">[34]</ref>). They are desirable for many modeling, animation, and simulation applications, in part because they efficiently and robustly generate smooth surfaces from an arbitrary topology control mesh. However, (self-)interference detection for subdivision surfaces has never been explored and we present the first algorithm of its kind for this task. Our algorithm targets a general setting with arbitrary deformations. In particular, we make no assumptions on the • motion of the surface,</p><p>• symmetry or simplicity of the surface configuration, or</p><p>• type of deformation applied to the surface.</p><p>To appreciate various algorithmic choices we must distinguish between interference/collision detection and surface intersection. Collision detection asks whether a surface coincides/intersects with itself or other surfaces. In contrast, surface intersection involves finding the actual intersection curves. In this paper we describe a hybrid approach tailored to simulation applications. The algorithm produces a list of interfering regions up to some user-specified resolution (see the red marked patches in <ref type="bibr">Figures 1,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">and 12)</ref>, but it does not trace the exact intersection curve. Our thin-shell simulator uses this algorithm to place contact forces between abutting or interpenetrating surfaces. While the algorithm caters to simulations, its mathematical foundation is widely applicable. Our approach and math derivations apply to all popular subdivision schemes. We shall make our discussion more concrete by focusing on Loop's scheme <ref type="bibr" target="#b22">[23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>We introduce:</p><p>• a new framework for collision and self-collision detection of subdivision surfaces undergoing arbitrary deformations, with optimizations specifically for self-collision detection; • techniques to bound the direction of surface normals of subdivision surfaces. In particular, we address irregular patches, which cannot be treated with approaches reported for splines.</p><p>Our bounding technique is useful for a number of algorithms in constructive solid geometry <ref type="bibr" target="#b2">[3]</ref>, machining and milling <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b17">18]</ref>, simulation <ref type="bibr" target="#b4">[5]</ref>, animation <ref type="bibr" target="#b9">[10]</ref>, and trimming <ref type="bibr" target="#b21">[22]</ref>. It is also applicable to surface area approximations, silhouette curve computations, and rendering <ref type="bibr" target="#b17">[18]</ref>. We will however not pursue these different applications and instead focus on the basic bound construction and its use in (self-)interference detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Review of Related Work</head><p>Interference detection has been studied extensively (see the excellent survey of Lin and Gottschalk <ref type="bibr" target="#b20">[21]</ref>). Most previous work deals with polygonal meshes and spline surfaces. A complete treatment for subdivision surfaces has not appeared in the literature. Unfortunately, subdivision surface interference tests cannot be based in a straightforward way on polygonal interference algorithms run on the control mesh (see <ref type="figure" target="#fig_0">Figure 2</ref>). The collision detection problem is very difficult. Given N separate objects, there are O(N 2 ) potential pair-wise collisions. Furthermore, if the objects are patches of a surface, then (typically) there are O(N ) pairs of adjacent objects whose shared seam should not be considered an interference region (see <ref type="figure" target="#fig_1">Figure 3</ref>). Most approaches employ a hierarchical bounding volume structure to avoid expensive intersection tests between well separated parts of the surface or multiple surfaces. Algorithms that do not specifically optimize self-interference queries perform poorly (if at all): they rely on spatial separation between non-interfering objects, and such separations do not exist between adjacent patches.</p><p>Our algorithm to detect (self-) interference for subdivision surfaces employs and builds on a number of previous ideas. Collision Detection for Subdivision Surfaces was discussed by DeRose et al. <ref type="bibr" target="#b9">[10]</ref> as part of a comprehensive treatment of character animation. As their approach is based on pointwise sampling of the subdivision surface at its control vertices, it may miss (self-)collisions. Also, they do not discuss optimizations specific to self-interference. In contrast, our approach will not miss (self-)collisions, and is particularly efficient for self-interference queries.</p><p>Collision Detection for Spline Surfaces Hughes et al. <ref type="bibr" target="#b16">[17]</ref> describe an accurate algorithm for objects undergoing polynomial deformation. The algorithm uses linear programming, hierarchies, sweep-and-prune <ref type="bibr" target="#b6">[7]</ref>, and loop detection <ref type="bibr" target="#b14">[15]</ref> to check for interference of B-spline (and Bézier) surface patches. The regular patches of a subdivision surface are splines, and many of these ideas could be applied if the surface deformation is polynomial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Collision Detection for Polygonal Surfaces Volino and</head><p>Thalmann present an algorithm for self-collision detection of polygonal surfaces <ref type="bibr" target="#b32">[33]</ref>. They create a patch hierarchy, use surface curvature tests to rule out self-intersections, and use a combination of surface curvature and bounding box tests to rule out intersection between pairs of subsurfaces. Provot <ref type="bibr" target="#b25">[26]</ref> confirms the soundness of this approach for polygons. Ponamgi et al. <ref type="bibr" target="#b24">[25]</ref> present an algorithm for exact collision detection between non-convex polyhedral models. They describe a hierarchical sweep and prune strategy which allows them to exploit temporal coherence. Although we could incorporate this approach, we found that our patch hierarchy (Section 2.2 and <ref type="figure" target="#fig_4">Figure 5</ref>) effects similar pruning if each node in the hierarchy has a small number of children.</p><p>Interval Arithmetic has been used successfully for collision detection with many objects undergoing deformable motion in complex environments. Snyder et al. <ref type="bibr" target="#b28">[29]</ref> described such a method, but it does not address self-collision nor subdivision surfaces. Extending this work to handle self-collision would involve a development akin to that presented in Section 3.1, in which we use interval analysis to bound normal variation over a surface patch. Surface Intersection Hohmeyer presents a general framework for robust surface-surface intersection based on loop detection <ref type="bibr" target="#b15">[16]</ref>. His work covers quadric, parametric, as well as implicit surfaces. Krishnan and Manocha <ref type="bibr" target="#b19">[20]</ref> treat algebraic and NURBS surfaces using a lower-dimensional formulation. Other notable work was published by Ma <ref type="bibr" target="#b23">[24]</ref> and by Sederberg <ref type="bibr" target="#b26">[27]</ref>. A commonality amongst all of these approaches is their use of bounds for the Gauss map of a surface patch (see <ref type="figure" target="#fig_2">Figure 4</ref>). We derive an interval bound for the Gauss map of a subdivision surface, allowing us to leverage much of the collision detection work based on such bounds.</p><p>Our approach extends the framework presented by Thalmann and Volino <ref type="bibr" target="#b32">[33]</ref>, which effectively treats self-interference detection of arbitrary topology polygonal meshes. There are several possible ways to extend this framework to smooth subdivision surfaces. The naïve approach, detecting interference of the surface control mesh, leads to erroneous results (see <ref type="figure" target="#fig_0">Figure 2</ref>). An approximate approach, for applications that tolerate missed or false collisions, is to first discretize the limit surface into a polygonal mesh and then detect interference of the mesh. With this approach, our novel Gauss map bound can be used to guide the discretization and to bound the discretization error. The more precise approach we adopt applies the interference detection problem to the smooth limit surface, as in prior treatment of spline patches. We retain the general structure presented in <ref type="bibr" target="#b32">[33]</ref> but instead of working with polygonal meshes we treat smooth surfaces of arbitrary topology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Algorithm</head><p>In this section we describe the interference detection problem and present our solution.</p><p>The limit surface of subdivision is trivially parameterized over the control mesh triangles, implying a decomposition of the surface into coarse triangular limit patches. Since a refined control mesh describes the same limit surface, the decomposition of the surface may consist of arbitrarily fine triangular limit patches. We use the terms patch and subpatch (in contrast with limit patch) to denote a connected group of limit patches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Collision Detection Problem</head><p>The goal of the algorithm is to identify all self-intersecting limit patches, as well as all pairs of intersecting limit patches. The user provides a tolerance oracle that decides whether a pair of intersecting limit patches should be subdivided into finer limit patches in order to isolate the interfering regions more precisely (see <ref type="figure">Figures</ref> 1, 11, and 12).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Overview of Our Algorithm</head><p>We represent the limit surface at different resolutions via a hierarchy of patches (see See Garland et al. <ref type="bibr" target="#b11">[12]</ref> for an excellent treatment of such hierarchies. To detect interference, we begin at the root patch of the hierarchy, and examine progressively finer subpatches at higher indexed levels. If we are able to guarantee that a patch does not selfintersect, we prune the search-we do not consider descendants of that patch. The detection algorithm has two significant routines: DetectPairwiseInterference accepts a pair of input patches, and returns a list of interfering regions between the patches. An interference region is represented as a pair of limit patches, where each input patch contributes one subpatch to the pair. This routine may make recursive calls to itself.</p><p>DetectSelfInterference accepts a single patch as input, and returns a list of interfering regions within the patch. An interference region is represented by a pair of limit patches belonging to the input patch. This routine may make recursive calls to itself, and it may call DetectPairwiseInterference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Discussion of Pseudo-Code</head><p>We now turn to the definition of the detection algorithm given in <ref type="figure">Figure 6</ref>. In this discussion, SP(a) denotes the immediate subpatches of patch a.</p><p>DetectPairwiseInterference accepts a pair of patches {a, b} and returns an interference list, each element an interfering pair {ca, c b } of limit patches with ca ∈ SP(a) and c b ∈ SP(b). The algorithm is recursive: first, we attempt to rule out interference between a and b (Section 2.4); if interference cannot be ruled out, we check if both patches are sufficiently flat to be approximated as polygons. If so, interference is checked between the polygonal approximations. Otherwise we subdivide one of the patches, say b, into its constituent subpatches, and recursively check for interference between a and every subpatch of b.</p><p>DetectSelfInterference accepts a patch a and returns an interference list containing interfering pairs {c1, c2} of limit patches with c1, c2 ∈ SP(a). The algorithm is recursive: first, we attempt to rule out the possibility of self-interference in patch a (Section 2.4). If self-interference cannot be ruled out, we subdivide patch a into its constituent subpatches SP(a), find all self-interferences within each subpatch via a recursive call to DetectSelfInterference, and find all interferences between pairs of subpatches through a call to DetectPairwiseInterference. DetectPairwiseInterference(a, c b ) <ref type="figure">Figure 6</ref>: Pseudo-code for interference-detection algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Details</head><p>The routines described above use bounds on the volume of a patch ("spatial bounds") and the Gauss map of a patch ("normal bounds") when they attempt to rule out interference between non-adjacent and adjacent patches respectively. Let us examine each test in more detail: The test to rule out interference between two patches depends on whether or not the patches are adjacent on the limit surface (we present an efficient adjacency test below). If the patches are not adjacent, then spatial bounds such as axis-aligned bounding boxes (AABBs) or oriented bounding boxes (OBBs) are used to rule out interference <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13]</ref>. The bounding box for a limit patch is built by bounding its control mesh, taking advantage of the local convex hull property. Note that repeated refinement of the control mesh of a patch yields progressively tighter spatial bounds. However subdivision is costly. In practice three steps of refinement are a good compromise for AABBs. The bounding boxes of the remaining patches are built by bounding the union of bounding boxes of their subpatches.</p><p>The test to determine if two patches are adjacent is defined as follows: given two patches a and b, with level(a) ≥ level(b), then the patches are adjacent iff b is an ancestor of some neighbor of a. This reflects the notion that patches are adjacent iff they are connected, regardless of the location of each patch in the hierarchy. To make this efficient the data structure representing a patch includes a list of all its immediate neighbors at the same level.</p><p>The test to rule out interference between two adjacent patches follows from the observation that the union of the two patches is itself a proper connected patch. Simply put, we apply the self-interference test to the union of the two patches.</p><p>The test to rule out self-interference is similar to the test given by Volino <ref type="bibr" target="#b32">[33]</ref>. Two conditions must hold for ruling out selfintersection. First, there must exist a plane separating the image of the Gauss map from the origin (see <ref type="figure">Figure 7</ref>, top left). Secondly, the projection of the patch boundary onto this plane must lie in the plane and have no self-intersections ( <ref type="figure">Figure 7</ref>, top right). For many applications it is reasonable to ignore the second condition; this has been independently noted by Provot <ref type="bibr" target="#b25">[26]</ref> and Thalmann <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b32">33]</ref>, and we have confirmed this in our application to thin-shell simulation. We now consider the check for a separating plane in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Self-Interference</head><p>The self-interference test requires that two conditions be met. Sections 3.1 discusses the first condition ( <ref type="figure">Figure 7</ref>, top left) and Section 3.6 the second condition ( <ref type="figure">Figure 7</ref>, top right). We shall focus on Loop's scheme <ref type="bibr" target="#b22">[23]</ref>. All the results extend to the Catmull-Clark scheme and other popular schemes. In particular, our results rely on diagonalizing the extended subdivision matrix. This is not possible for some schemes, such as the Doo-Sabin scheme <ref type="bibr" target="#b29">[30]</ref>, but the results are easily extended to handle matrices which have non-trivial Jordan blocks. We have used this extension to handle valence three vertices in Loop's scheme. Our final computations require interval analysis. An interval A = [a, b] is a closed subset of R with the usual arithmetic operations on intervals <ref type="bibr" target="#b0">[1]</ref>. In the following, interval quantities are typeset in Sans Serif (e.g., F(X), Φi(Ω)), matrix and vector values in boldface (e.g., f (x), C), and scalar values in lowercase Roman (e.g., f (x), ci, φi(v, w)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Gauss Map Image Restricted to Hemisphere</head><p>As shown in <ref type="figure">Figure 7</ref>, to rule out self-interference we must prove the existence of a separating plane between the origin and the image of the Gauss map of the patch. An equivalent condition is that the set of all oriented normal vectors of the surface is contained in a non-degenerate cone (i.e., a cone with half-angle less than π/2). To determine if this cone exists, we derive analytic bounds on the normal vectors of a limit patch. The bounds we present are guaranteed to converge during subdivision.</p><p>When a patch has three regular corners (for Loop's scheme, these are vertices of valence six), we refer to the patch as regular; otherwise we refer to it as irregular. Regular patches define quartic box spline surfaces, and previous work has established effective approaches for bounding their Gauss map <ref type="bibr" target="#b15">[16]</ref>. The literature does not address irregular patches; that is our focus.</p><p>To simplify the problem (without loss of generality), we shall: (a) consider only a single limit patch, (b) assume that at most one corner of any patch is an irregular vertex, and (c) apply a rigid-body transformation to the patch such that the irregular corner lies at the origin and the associated surface normal is collinear with the z-axis. Patches, i.e., groups of limit patches, have their Gauss map bounded by the union of the bounds over their constituent limit patches. The condition that a limit patch may have at most one irregular corner is easily satisfied by a single global subdivision step.</p><p>We begin by formulating expressions for tangent vectors of the irregular patch. In Section 3.3 we proceed to bound the tangent directions and then the normal directions of the patch. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Scaled Tangent Vectors</head><p>Consider one step of subdivision around the irregular control triangle, as shown in <ref type="figure" target="#fig_6">Figure 8</ref>. Quadrisection produces three regular triangles and one irregular triangle. Let p be the N × 3 vector of 3D control points at the coarsest level around the irregular triangle <ref type="figure" target="#fig_6">(Figure 8 top left)</ref>, and let p 1 be the N × 3 vector of 3D control points in a similar neighborhood at the next level. Let S be the N × N subdivision matrix, such that p 1 = Sp. Similarly define S1 (respectively S2 and S3) as a rectangular subdivision matrix that relates p to the vector of control points q 1 1 (respectively q 1 2 and q 1 3 ) around triangle T <ref type="bibr" target="#b0">1</ref> 1 (respectively T 1 2 and T 1 3 ). Note that after one step of subdivision, three quarters of the limit patch are defined by quartic box splines.</p><p>Our derivation is based on observing the eigenstructure of the subdivision matrix; this idea can be traced back to Doo and Sabin <ref type="bibr" target="#b10">[11]</ref>. Assume that S is non-defective (if this assumption is relaxed a similar argument follows), and decompose the control vector p with respect to the eigenbasis {x n }, n = 0 .. N − 1, of S:</p><formula xml:id="formula_0">p = x 0 c0 + x 1 c1 + x 2 c2 + . . . ,</formula><p>where x n is an N × 1 column eigenvector and ci is a 1 × 3 vector. We write the x i in order of non-increasing magnitudes of the eigenvalues λi. For simplicity, we further assume that λ1 = λ2 = λ and λ0 &gt; λ &gt; |λ3|.</p><p>Suppose that the projection into the eigenbasis results in exactly one non-zero coefficient ci, so that p = x i ci. One subdivision step produces the regular triangle T <ref type="bibr" target="#b0">1</ref> 1 surrounded by control points q <ref type="bibr" target="#b0">1</ref> 1 = S1p = S1x i ci. Since x i is an eigenvector of S, each step of subdivision scales the control points by the eigenvalue: the j th step of subdivision generates the control points around T j 1 given by</p><formula xml:id="formula_1">q j 1 = S1S j−1 p = S1λ j−1 i x i ci = λ j−1 i q 1 1 .<label>(1)</label></formula><p>Recall that for a regular patch the limit surface is a box spline, hence for the patch defined by q 1 1 we can express the limit surface as s(u, <ref type="figure">)</ref> is a row vector of box spline basis polynomials defined over the unit triangle T0. Furthermore, using the scaling relation given above, we can express the limit surface of the patch defined by q j 1 as</p><formula xml:id="formula_2">v)| T 1 1 = B(2u, 2v − 1)q 1 1 , where B(u, v</formula><formula xml:id="formula_3">s(u, v)| T j 1 = λ j−1 i B(2 j u − 1, 2 j v)q 1 1 . The u-tangent of patch s(u, v)| T j 1 , defined as the vector function ∂ ∂u s(u, v)| T j 1</formula><p>, describes its tangents in the u parameter direction. Recall that we want to bound the direction of the tangent vectors, and not the magnitude. We multiply the tangent vector by the positive scalar (2λ) 1−j , noting that this does not alter its direction. The resulting scaled tangent vector is</p><formula xml:id="formula_4">hu(u, v) T j 1 = (2λ) 1−j ∂ ∂u s(u, v) = 2(λi/λ) j−1 Bu(2 j u − 1, 2 j v)S1x i φ i u (u,v) T j 1 ci (2)</formula><p>where Bu(u, v) = ∂ ∂u B(u, v), and</p><formula xml:id="formula_5">φ i u (u, v) : R 2 →</formula><p>R is a partial derivative of the scaled eigenbasis function corresponding to the eigenvector x i (with its restriction over T j 1 defined above). <ref type="figure">)</ref> is also defined over T j 2 and T j 3 (by an analogous derivation), thus it is well-defined over the entire domain T0. Consequently, the scaled u-tangent has the simple expression hu(u, v) = ciφ i u (u, v). A similar derivation establishes the expression for the <ref type="figure">)</ref>. Up to this point, we have assumed that the expansion of the control vector p in the eigenbasis of S is p = x i ci (with fixed i). We now lift this restriction, and treat the case of the general expansion p = N−1 i=0 x i ci. Since the subdivision operator S, the differentiation operator ∂ ∂u , and multiplication by a scalar (2λ) 1−j are all linear operators, the scaled tangents are given by</p><formula xml:id="formula_6">φ i u (u, v</formula><formula xml:id="formula_7">scaled v-tangent, hv(u, v) = ciφ i v (u, v</formula><formula xml:id="formula_8">hu(u, v) = N−1 i=1 ciφ i u (u, v) hv(u, v) = N−1 i=1 ciφ i v (u, v).</formula><p>The terms corresponding to i = 0 have been dropped because they are always zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analytic Bound of Surface Normals</head><p>We want to bound the scaled normal, hu(u, v) × hv(u, v). The desired quantity hu × hv is a 3D vector with scalar interval components, and it can be interpreted geometrically as an axis-aligned bounding box around the heads of the scaled normal vectors. We would like the bound to be tight if we apply it to a sufficiently fine limit triangle; if the bound is not sufficiently tight, we shall subdivide the limit triangle and apply the bound separately to each sub-triangle. The shape of a sufficiently fine limit triangle with eigen-coefficients ci is governed by the subdominant eigenterms of its eigenbasis expansion. Hence it is critical to find an expression for hu × hv that is tight when {c1, c2} <ref type="figure">)</ref> as the sum of the subdominant terms h s.d. <ref type="figure">)</ref>. By the distributive property of the cross product, the scaled normal is the sum of four terms, which we shall bound individually and then add using interval arithmetic:</p><formula xml:id="formula_9">|ci|, i &gt; 2. Let us rewrite hu(u, v) = h s.d. u (u, v) + h h.o.t. u (u, v</formula><formula xml:id="formula_10">u (u, v) = c1φ 1 u (u, v) + c2φ 2 u (u, v) and higher order terms h h.o.t. u (u, v) = N−1 i=3 ciφ i u (u, v). Sim- ilarly we rewrite, hv(u, v) = h s.d. v (u, v) + h h.o.t. v (u, v</formula><formula xml:id="formula_11">hu × hv = (h s.d. u × h s.d. v ) + (h s.d. u × h h.o.t. v ) + (h h.o.t</formula><p>rotate the control mesh so that the normal vector associated with the irregular vertex is aligned with the z-axis. The detection algorithm examines progressively smaller neighborhoods around the irregular patch; eventually all the normal vectors in the neighborhood will be sufficiently aligned with the z-axis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Self-Interference of Projected Contour</head><p>We now turn our attention to the second condition in the interference test: The projection of the patch contour onto the separating plane is a curve, and it must not self-interfere. In essence, this selfintersection problem for curves is a lower-dimensional version of the self-intersection problem for patches.</p><p>Consider applying a rigid-body transformation to the separating plane and the patch such that the separating plane is the xyplane. A projection onto the separating plane amounts to setting the z-coordinate to zero. Since the subdivision operator affects each coordinate independently, we note that the projected contour is a subdivision curve defined by the projection of part of the control mesh onto the plane. Specifically, only the control triangles in the two-ring of the contour are required to define the limit contour. Self-interference detection for the contour curve is simply a lower-dimensional instance of the problem addressed in this paper.</p><p>One simplification that is possible in the curve setting is that instead of bounding normal directions, we may bound tangent directions, since for curves the normal and tangent directions are related by a rotation through π/2. Also note that in this two-dimensional setting, the self-interference test analogous to that described in Section 2 has only one condition: the tangent directions must be bounded by a wedge with half-angle less than π/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results</head><p>We have implemented the algorithm described in the previous section as part of a larger system for thin-shell simulation. We derived and then tabulated the bounds on the eigenfunction derivatives, Φ i u , Φ i v , and normals, Φ1×2, in a symbolic algebra package. At run time the bounds, together with the left eigenvectors needed to compute the eigencoefficients ci, are loaded. The bounds hu × hv are then computed as described in Section 3.3.</p><p>We ensure that the half-angle of our normal bounding cone is tight within π/180 (1 degree) of the exact infinite series of bounds over the regular subpatches. To achieve this, we subdivide a given patch by multiplying the eigencoefficients by the eigenvalues (without actually altering the mesh data structure), extracting the three regular subpatches (by multiplying the eigencoefficients by the right eigenvectors and using picking matrices), and finally computing a normal bound over the regular subpatches. If the half-angle of the normal bounding cone over the entire patch is not within π/180 of the corresponding half-angle over the three regular subpatches, we recursively bound the normals of the irregular subpatch until the bound is tight enough; at this point, we have conceptually subdivided the original patch into a set consisting of regular subpatches and a single small irregular subpatch (without altering the mesh data structure). The bound over the original patch is computed as the union of the bounds over this set of subpatches.</p><p>Since the bound over regular subpatches is based on known methods for splines, and the number of iterations is typically only four or five, our bounding method runs within a small constant factor of the speed of methods based on splines. In practice only a small portion of the total detection time is spent in functions associated with irregular limit patch Gauss map bounds. Consequently there is very little runtime difference between a spline patch interference detection code and our more general subdivision surface interference detection code. Our prototype implementation uses rudimentary bounding primitives: spatial bounds are represented as axis-aligned bounding boxes, and normal bounds are represented by normal cones <ref type="bibr" target="#b17">[18]</ref>. Researchers have established that the performance of collision detection algorithms benefits greatly from using tighter spatial and normal bounds. In particular we believe that our approach would benefit from using ShellTrees <ref type="bibr" target="#b18">[19]</ref> or QuOSPO trees <ref type="bibr" target="#b13">[14]</ref> as spatial bounds, since they have superior convergence properties compared to AABBs. Similarly we would benefit from using convex pyramids <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b27">28]</ref> to represent normal bounds. For the examples we present in this paper, the collision detection time ranges from 0.1 s to 30 s. <ref type="figure" target="#fig_7">Figure 10</ref> demonstrates our algorithm's ability to rule out selfinterference. The coloring of the mannequin, lyase molecule energy field, and bent tube was generated by traversing down the patch hierarchy, and pruning the traversal at those patches for which we ruled out self-interference; the colors delineate those patches of the hierarchy that did not require further subdivision. Note that in flat regions of the surface (such as the base and top of the tube, and the forehead of the mannequin) the extent of the patches is relatively large, whereas in regions with high curvature (such as the nose and ear of the mannequin, and more notably some peaks in the lyase model), the extent of the patches is rather small. These examples demonstrate the dependence of our self-interference criterion on the curvature of the surface patch.</p><p>We have used our algorithm to find self-interfering regions of various models, ranging from geometric curiosities to physically simulated objects. <ref type="figure" target="#fig_0">Figures 1, 11, and 12</ref> show the interference regions we found for three models, with progressively higher precision (recall that the user may provide an oracle that determines whether a pair of interfering limit patches should be subdivided further to increase precision). The bent tube model was generated using a thin-shell physical simulator <ref type="bibr" target="#b4">[5]</ref>. The other two models were created specifically to illustrate self-interference of closed surfaces. The multi-handled torus illustrates complex topology while the partially everted sphere consists mostly of regular patches and simple topology. Given equal implementation effort our runtime for the latter kind of example will be close to that for a corresponding spline model.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have derived an interval bound on the normal directions of a subdivision surface near an irregular vertex using eigenbasis functions induced by the local subdivision operator. The bounds have been found to work well in practice, i.e., they are tight and require only a small number of multiplications in the eigenbasisequivalent to standard subdivision, but without any change to the mesh data structures.</p><p>Such normal bounds have many applications since they are a central element in a large number of algorithms related to interference detection <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b21">22]</ref>. We demonstrated an example application of these bounds to self-collision detection. In future work we hope to include more optimizations for other parts of the collision detection algorithm <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b27">28]</ref> and pursue stable collision response methods in the context of thin-shell modeling.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Control mesh check is insufficient. Two self-intersecting control meshes (left) and (not shown at same scale) associated limit surfaces (right). A control mesh may be self-intersecting while the associated limit surface may (top) or may not (bottom) intersect.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Self-interference check. The detection algorithm should ignore the seam between patches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>The Gauss map, (u, v) → (fu × fv)/ fu × fv 2, maps every point on the surface of an orientable 2-manifold to its unit normal vector [4]. An illustrative surface patch (left) and the image of its Gauss map on the unit sphere (right). Each point on the surface (arrow's tail, left image) has an associated surface normal (arrow, left image) that corresponds to a point on the unit sphere (arrow's head, right image).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 ): 1 .</head><label>51</label><figDesc>every level of the hierarchy represents the entire surface as a disjoint set of patches, 2. each patch is a disjoint union of its subpatches, 3. the root of the hierarchy is a single patch comprising the entire surface, 4. the leaves are limit patches, and 5. conceptually, every leaf patch has an infinite hierarchy of descendant limit patches, corresponding to the hierarchical parameterization induced by recursive subdivision of the control mesh.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Hierarchy. Illustrative example of a patch hierarchy whose leaves are limit patches. Note that level numbers increase towards finer levels and that the coarsest level of any surface consist of a single patch, i.e., the union of all limit patches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>algorithm</head><label></label><figDesc>DetectSelfInterference(a) if RuleOutSelfInterference(a) return: ∅ else return: c ∈ SP(a) DetectSelfInterference(c) c 1 , c 2 ∈ SP(a) DetectPairwiseInterference(c1, c2) // Assume level(b) ≥ level(a). algorithm DetectPairwiseInterference(a,b) if RuleOutPairwiseInterference(a,b) return: ∅ else if a and b sufficiently flat if poly. approxs. of a and b interfere return: {a, b} else return: ∅ else if a not sufficiently flat return: ca ∈ SP(a) DetectPairwiseInterference(b, ca) else // b not sufficiently flat return: c b ∈ SP(b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Loop subdivision. One step of local subdivision around the irregular patch. On the left the parametric layout of an irregular patch. Applying the subdivision matrix S1, for example, produces the control points of the subpatch T<ref type="bibr" target="#b0">1</ref> 1 (shaded triangle).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Experimental verification of self-interference test. In relatively flat regions large patches, i.e., groups of limit patches, are determined to be without self intersection based on the Gauss map criterion. Each such group is indicated with a single color. Note that the groups are smaller in extent near high curvature areas.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Self-interference detection. Control mesh and interference resolved limit surface of higher genus torus with two tubes crossing in the center.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>User-controlled tolerance. A partially everted sphere and its interference region resolved to different resolutions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Sufficient conditions that a patch does not self-intersect are the existence of a separating plane between the origin and the image of Gauss map of the patch (top left), and the absence of interference in the projection of the patch contour onto the separating plane (top right). The intuition behind these criteria is as follows. The first ensures that the patch does not self-interfere due to bending (bottom left), while the second ensures that the patch does not self-interfere due to planar stretching and shearing (bottom right).</figDesc><table /><note>Figure 7: Self-interference test.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements The research reported here was supported in part through NSF (DMS-9874082, DMS-9872890, ACI-9982273), the Packard Foundation, Pixar, Alias|Wavefront, Intel, and Lucent. Special thanks to Adi Levin, Mathieu Desbrun, Mika Nyström, Nathan Litke, Denis Zorin, Jos Stam, Jeff Bolz, Zoë Wood, Yuval Grinspun and Khrysaundt Koenig.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>).</p><p>(3)</p><p>The first term is a bound over the function h s.d. <ref type="bibr">(u, v)</ref>. We precompute the scalar interval bound Φ1×2 on φ1×2(u, v) over T 0 , and at runtime evaluate h s.d.</p><p>To compute the remaining terms we compute interval bounds for the intermediate factors:</p><p>where</p><p>over T 0 (we shall develop these bounds in Section 3.4). Taking interval cross products of the above factors the three remaining terms are formed.</p><p>The proof of convergence follows from the observation that |a × b| ≤ |a||b|, and hence the three terms in Equation 3 that involve h h.o.t.</p><p>vanish during subdivision. The remaining term, Φ1×2(c1 × c2), is the product of a scalar interval and a vector almost parallel to the z-axis. If the scalar interval Φ1×2 does not include some finite neighborhood around zero then interval arithmetic will produce a tight bound on the (z-axis) direction,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Analytic Bound on Partial Derivatives of Scaled Eigenbasis Functions</head><p>In this section we describe how to precompute the scalar intervals</p><p>These functions depend on the eigenvectors of S (and hence on the valence of the irregular corner vertex), but since they are independent of the control vector p, these intervals are precomputed.</p><p>It is easy to bound φ i u (u, v) over the domain</p><p>, since the scalar function is a polynomial over each of the three subdomains. Elementary Calculus yields the analytic bound Φ i</p><p>To extend this bound over the entire domain T0, we observe a scaling relation on φ i u (u, v) that is evident from Equation 2:</p><p>whence it follows directly that the bound over the entire domain T0 is the union of an infinite sequence of bounds over the domains T j :</p><p>Let us examine how this expression can be simplified. We examine three cases: i = 0, i ∈ {1, 2}, and i &gt; 2.</p><p>• i = 0 We assume that x 0 = [1, 1 . . . 1] T , as this is required for the subdivision surface to be affine invariant <ref type="bibr" target="#b33">[34]</ref>. Then by the partition of unity property of the box spline basis, Bx 0 is unity and Bux 0 is zero, and from Equation 2 we conclude that φ 0 u (u, v) is zero everywhere and Φ 0 u = [0, 0].</p><p>• i ∈ {1, 2} Since λ1 = λ2 = λ, the geometric scaling factor λi/λ is unity. In this case, our simplified expression is Φ 1 u = Φ 1 u | T 1 , i.e., the bound over T 1 is a bound over T0.</p><p>In this case, the geometric scaling factor λi/λ is less than unity, hence the sequence of intervals (λi/λ) j−1 Φ i u | T 1 vanishes as j → ∞ and the interval Φ i u = min 0, Φ 1</p><p>is a conservative bound on φ i u (u, v) over T0. Simply put, we compute a bound over T <ref type="bibr" target="#b0">1</ref> , and extend that bound to include zero. Recall that in Equation 2 we scaled the tangents by (2λ) 1−j . We now see the effect: the scaling factor (in Equation 5) is |λi/λ| ≤ 1, i &gt; 0; consequently the infinite geometric sequence converges. If the tangents were not scaled, the scaling factor would be 2λi &gt; 1 for some valences and the union over the infinite sequence would not converge. The second consequence of scaling the tangent vectors is that the scaling factor is now unity for i ∈ {1, 2}, hence the bound on the subdominant eigenbasis functions is tight.</p><p>The scalar interval bound Φ1×2 on φ1×2(u, v) over T 0 is computed in the same manner. It is easy to bound φ1×2(u, v) over the domain T 1 , since the scalar function is a polynomial over each of the three subdomains. Elementary Calculus yields an analytic bound, and since all the component eigenbasis functions are associated with subdominant eigenvalues, the function φ1×2(u, v) obeys a scaling relation analogous to Equation 4, with the scaling factor unity. Hence the bound on φ1×2(u, v) over the domain  <ref type="figure">Figure 9</ref>: Tight bounds. Top row: Axis-aligned bounding boxes provide tight bounds for axis-aligned directions, favoring rotation of the coordinate system. Bottom row: We scale the tangent vectors by (2λ) 1−j , which results in normalized scaling factors |λi/λ| for the eigenfunctions; consequently the tangent vectors are wellbehaved near the irregular vertex (middle). If we omit this scaling, the tangent vectors may be poorly behaved (left and right).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Obtaining Tighter Bounds</head><p>We noted previously that hu and hv can be interpreted as axisaligned bounding boxes (AABBs) around heads of the tangent vectors. Let us examine the consequence of using an AABB as a bounding volume. If we want to express a bound over a single point, or an axis-aligned line segment, the bounding box is tight. However, if we want to express a bound over an arbitrary line segment, an AABB may have significant slack and present a poor choice.</p><p>It is important for us to have a tight bound on the tangents (and normals) when the patch is flat. Note that when the patch is flat, the heads of all the normals vectors will lie along some line segment. An AABB will give a tight bound on the normal direction only if this line segment is aligned with an axis. This explains why we</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Introduction to Interval Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Alefeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Herzberger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Large steps in cloth simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Baraff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Witkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="43" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Approximate boolean operations on free-form solids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Biermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kristjansson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 2001 (Los Angeles</title>
		<meeting>SIGGRAPH 2001 (Los Angeles</meeting>
		<imprint>
			<publisher>In Press</publisher>
			<date type="published" when="2001-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Differential Geometry of Curves and Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Carmo</surname></persName>
		</author>
		<idno>ch. 3</idno>
		<imprint>
			<date type="published" when="1976" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Subdivision surfaces: A new paradigm for thin-shell finite-element analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Cirak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. J. Numer. Methods Engrg</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="2039" to="2072" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Integrated modeling, finite-element analysis, and engineering design for thinshell structures using subdivision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Cirak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">K</forename><surname>Antonsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design</title>
		<imprint>
			<date type="published" when="2001" />
			<publisher>In Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">I-collide: An interactive and exact collision detection system for large-scale environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Ponamgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Interactive 3D Graphics Conf</title>
		<meeting>ACM Interactive 3D Graphics Conf</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="189" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Versatile and efficient techniques for simulating cloth and other deformable objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Courshesnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Volino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">M</forename><surname>Thalmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 95</title>
		<meeting>SIGGRAPH 95</meeting>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="137" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Using a convex pyramid to bound surface normal vectors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Daniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="219" to="227" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Subdivision surfaces in character animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Truong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="85" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Analysis of the behaviour of recursive division surfaces near extraordinary points</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Doo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="356" to="360" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hierarchical face clustering on polygonal surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Willmott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="2001-03" />
			<biblScope unit="page" from="49" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Obb-tree: A hierarchical structure for rapid interference detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gottschalk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 96</title>
		<meeting>SIGGRAPH 96</meeting>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast collision detection using quospo trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1999-04" />
			<biblScope unit="page" from="55" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A surface intersection algorithm based on loop detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hohmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computational Geometry and Applications</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="473" to="490" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Robust and Efficient Intersection for Solid Modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Hohmeyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
		<respStmt>
			<orgName>UC Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient and accurate interference detection for polynomial deformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dimattia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Computer Animation &apos;96</title>
		<meeting>Computer Animation &apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Tangent, normal, and visibility cones on bézier surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.-S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">Y</forename><surname>Papalambros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">C</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="305" to="320" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Rapid and accurate contact determination between spline models using shelltrees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gopi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pattekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="315" to="326" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An efficient surface intersection algorithm based on lower-dimensional formulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="74" to="106" />
			<date type="published" when="1997-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Collision detection between geometric models: A survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gottschalk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IMA Conference on Mathematics of Surfaces</title>
		<meeting>IMA Conference on Mathematics of Surfaces</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Trimming for subdivision surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Litke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="463" to="481" />
			<date type="published" when="2001-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Loop</surname></persName>
		</author>
		<title level="m">Smooth subdivision surfaces based on triangles. Master&apos;s thesis</title>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics, University of Utah</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Detection of loops and singularities of surface intersections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1059" to="1067" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Incremental algorithms for collision detection between polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Ponamgi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="51" to="64" />
			<date type="published" when="1997-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Collision and self-collision handling in cloth model dedicated to design. Computer Animation and Simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Provot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-09" />
			<biblScope unit="page" from="177" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Loop detection in surface patch intersections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sederberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Meyers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="161" to="171" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Pyramids that bound surface patches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">W</forename><surname>Sederberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">K</forename><surname>Zundel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Graphical Models and Image Processing</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="75" to="81" />
			<date type="published" when="1996-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Interval method for multi-point collision between time-dependent curved surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Snyder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Woodbury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fleischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Currin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 93</title>
		<meeting>SIGGRAPH 93</meeting>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Exact evaluation of catmull-clark subdivision surfaces at arbitrary parameter values</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="395" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Elastically deformable models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Terzopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Platt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fleischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proceedings of SIGGRAPH 87)</title>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="205" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Heating and melting deformable models (from goop to glop)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Terzopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Platt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fleischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface &apos;89</title>
		<imprint>
			<date type="published" when="1989-06" />
			<biblScope unit="page" from="219" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient self-collision detection on smoothly discretized surface animations using geometrical shape regularity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Volino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">M</forename><surname>Thalmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="155" to="166" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Subdivision for Modeling and Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zorin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Course Notes. ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
