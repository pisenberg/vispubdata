<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Memory Insensitive Technique for Large Model Simplification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Applied Scientific Computing</orgName>
								<orgName type="institution">Lawrence Livermore Na-tional Laboratory</orgName>
								<address>
									<addrLine>7000 East Avenue</addrLine>
									<postCode>L-560, 94551</postCode>
									<settlement>Livermore</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Llnl</forename><surname>Cláudio</surname></persName>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Silva</surname></persName>
							<email>csilva@research.att.com</email>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">† AT&amp;T Labs-Research</orgName>
								<address>
									<addrLine>180 Park Avenue, Room D265, Florham Park</addrLine>
									<postBox>PO Box 971</postBox>
									<postCode>07932</postCode>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<addrLine>San Diego</addrLine>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Memory Insensitive Technique for Large Model Simplification</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CR Categories: E.5 [Files]: Sorting; I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-Surface and object representations polygonal surface simplification</term>
					<term>large data</term>
					<term>out-ofcore algorithms</term>
					<term>external sorting</term>
					<term>quadric error metrics</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper we propose three simple, but significant improvements to the OoCS (Out-of-Core Simplification) algorithm of Lindstrom [20] which increase the quality of approximations and extend the applicability of the algorithm to an even larger class of compute systems. The original OoCS algorithm has memory complexity that depends on the size of the output mesh, but no dependency on the size of the input mesh. That is, it can be used to simplify meshes of arbitrarily large size, but the complexity of the output mesh is limited by the amount of memory available. Our first contribution is a version of OoCS that removes the dependency of having enough memory to hold (even) the simplified mesh. With our new algorithm, the whole process is made essentially independent of the available memory on the host computer. Our new technique uses disk instead of main memory, but it is carefully designed to avoid costly random accesses. Our two other contributions improve the quality of the approximations generated by OoCS. We propose a scheme for preserving surface boundaries which does not use connectivity information, and a scheme for constraining the position of the &quot;representative vertex&quot; of a grid cell to an optimal position inside the cell.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>In recent years there has been a rapid increase in the raw size of polygonal datasets. Several technological trends are contributing to this effect, such as the development of high-resolution 3D scanners, and the need to visualize ASCI-size (Accelerated Strategic Computing Initiative) datasets. A useful paradigm for visualizing large datasets is to generate levels of detail. Over the last decade, there has been substantial research in designing algorithms for generating level-of-detail approximations of triangle meshes. In this paper, our focus is on algorithms which have low memory complexity.</p><p>A simplification algorithm receives an input mesh of complexity n, and outputs a mesh of complexity m (where m &lt; n). Often, the user sets the target size of the output, and the algorithm attempts to minimize the overall error of the approximation. One important aspect of the design of a surface simplification algorithm is its memory usage. In general, different algorithms have different main memory dependencies on n and m. For different applications, it is useful to have algorithms which are memory efficient with respect to n or m (but ideally both). The memory dependency on n affects the usefulness of a given algorithm in the sense that it limits the size of models that can be simplified.</p><p>In general the memory requirement of a given algorithm grows with both m and n (for exceptions, see e.g. <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref>). The dependency on m has direct implications on the maximum accuracy of the approximation. As an example, an efficient terrain simplification algorithm is presented in <ref type="bibr" target="#b12">[13]</ref>, whose memory complexity is analyzed to be 3n + 192m bytes, where n and m are the number of vertices in the input and output, respectively. In order to generate a high-quality approximation with one eighth of the input points, i.e., m = <ref type="bibr" target="#b0">1</ref> 8 n, one would need to have 27n bytes of memory, or nine times as much as the size of the input. Often, the memory complexity is much higher on both n and m (e.g., <ref type="bibr" target="#b20">[21]</ref> uses 160n bytes for general surface simplification), and generating approximations of large datasets is usually quite hard.</p><p>The OoCS algorithm proposed by Lindstrom <ref type="bibr" target="#b19">[20]</ref> is a big step forward in that it has no dependency on n, thus allowing for simplification of extremely large datasets. One contribution of our work is to remove the main memory dependency on m from OoCS, thus allowing for an arbitrarily accurate approximation of an arbitrarily large dataset. Our new algorithm, OoCSx, uses constant memory, no matter how large the dataset or approximation error.</p><p>One might argue that the ability to produce simplified models that are still too large to represent in-core is of little practical value, since the main reason for simplifying the model in the first place is to reduce its complexity to something more manageable. However, we see several important uses of our new algorithm. First, in many situations it is not known beforehand how much RAM will be available on the client machine on which the simplified mesh is to be used, as is generally the case with multi-level-of-detail datasets provided through data repositories. Second, OoCS does not provide a mechanism for specifying the exact size m of the simplified model, and trial and error may be necessary to find a grid resolution that leads to a detailed simplification that, along with the auxiliary data structures used in OoCS, fits in-core. Our memory insensitive algorithm, on the other hand, is able to finish and output a simplified model regardless of the grid resolution. Third, many applications demand a strict error bound, in which case trading memory for mesh accuracy is not a practical option. As we shall see, even when an explicit error bound is not given, the mesh may be so geometrically complex that the most detailed simplification to fit in-core is of unacceptable visual quality. Finally, our work nicely complements the recent trend of developing efficient out-of-core scientific visualization techniques (see, e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b31">32]</ref>). With tools like these in hand, further out-of-core processing of a simplified mesh becomes practical.</p><p>Our new technique uses disk instead of main memory. In fact, OoCSx generally needs more disk space than OoCS needs main memory. On the other hand, disk is often much cheaper and more readily available than random access memory. The naive use of disk has the potential for considerable slowdown (as in the case of operating system paging). Our algorithm is carefully designed to avoid random accesses, thus achieving simplification speeds which, although slower than OoCS, are still quite practical. Our experiments show that OoCSx is typically between two to five times slower than OoCS, while using constant main memory. However, when insufficient main memory is available for OoCS to store the simplified model, OoCSx runs faster. Of course, for large enough models, OoCS is not able to finish at all.</p><p>Because OoCS does not make use of connectivity information, it has no way of detecting whether an edge is a boundary edge or not. As a consequence, boundaries are generally poorly preserved by OoCS. We propose a technique for preserving boundaries that does not use any connectivity information. Finally, we sketch a technique for enforcing maximum errors, which constrains the optimal cluster representative to lie inside its grid cell while minimizing the approximation error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Polygonal simplification has been a hot topic of research over the last decade, with a vast number of published algorithms. Many of the early simplification algorithms were designed to handle modest size datasets of a few tens of thousands of triangles. Recent improvements in scanning and storage technology, however, have lead to datasets as large as billions of triangles <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b22">23]</ref>. As a result, a number of methods, particularly for out-of-core visualization, have been proposed for coping with models that are too large to fit in main memory, e.g. <ref type="bibr">[3, 5-8, 17, 24, 28, 31, 32]</ref>.</p><p>Rossignac and Borrel proposed one of the earliest simplification algorithms <ref type="bibr" target="#b25">[26]</ref>. Their algorithm partitions space into cube-like cells from a uniform rectilinear grid, and replaces all mesh vertices within a grid cell by a single representative vertex. While simple and fast, their method produces rather low quality meshes, in part due to the simple vertex positioning scheme used in their original algorithm. Lindstrom's OoCS algorithm <ref type="bibr" target="#b19">[20]</ref> is also based on vertex clustering on a uniform grid, but has a lower time and memory complexity, and uses a quadric error metric to improve the mesh quality. This method was recently extended by Shaffer and Garland <ref type="bibr" target="#b26">[27]</ref>, who make two passes over the input mesh. During the first pass, the surface is analyzed and an adaptive (instead of uniform) partitioning of space is made. Using this approach, a larger number of irregular grid cells (and thus samples) can be allocated to the more detailed portions of the surface. However, their algorithm requires more RAM than OoCS in order to maintain a BSP-tree and additional quadric information in-core.</p><p>Bernardini et al. describe a radically different approach to outof-core simplification <ref type="bibr" target="#b3">[4]</ref>. Their method splits the model up into separate patches that are small enough to be simplified individually in-core using a conventional simplification algorithm. Special care has to be taken along the patch boundaries. A similar technique was proposed by Hoppe for creating hierarchical levels of detail for height fields <ref type="bibr" target="#b14">[15]</ref>, which was later generalized by Prince to arbitrary meshes <ref type="bibr" target="#b24">[25]</ref>. While conceptually simple, the time and space overhead of partitioning the model and later stitching it together adds to an already expensive in-core simplification process, rendering such a method less suitable for simplifying very large meshes.</p><p>El-Sana and Chiang <ref type="bibr" target="#b9">[10]</ref> propose an external-memory algorithm to support view-dependent simplification of datasets that do not fit in main memory. Similar to <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b24">25]</ref>, they segment the model into sub-meshes that can be simplified independently and later merged in a preprocessing phase. The segmentation and stitching are made simple by ensuring that edges are collapsed in edge-length order, and guaranteeing that sub-mesh boundary edges are longer than interior edges. During run-time, only the portions of the viewdependence tree that are necessary to render the given level of detail are kept in main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OUT-OF-CORE SIMPLIFICATION</head><p>In order to describe our new simplification algorithm, we will first provide a brief review of OoCS. For full details see <ref type="bibr" target="#b19">[20]</ref>. The input to the algorithm is a set of triangles, stored as triplets of vertex coordinates in a file, and the resolution of a three-dimensional grid. (See the appendix for a disk-based technique on how to transform from indexed meshes to this dereferenced format.) The algorithm, which is loosely based on the clustering algorithm by Rossignac and Borrel <ref type="bibr" target="#b25">[26]</ref>, computes for each cluster grid location a representative vertex. (A set of vertices constitute a "cluster" if they all lie inside the same grid cell.) The position of the representative vertex is chosen so as to minimize the quadric error <ref type="bibr" target="#b13">[14]</ref> measured with respect to the triangles in the cluster. For each triangle t</p><formula xml:id="formula_0">= (x t 1 ,x t 2 ,x t 3 )</formula><p>, an associated quadric matrix Q t is computed:</p><formula xml:id="formula_1">Q t =n tn T t (1) n t = x t 1 × x t 2 + x t 2 × x t 3 + x t 3 × x t 1 −[x t 1 , x t 2 , x t 3 ]<label>(2)</label></formula><p>wheren t is a 4-vector made up of the area-weighted normal of t and the scalar triple product of its three vertices. 1 Q t is then distributed to the clusters associated with each of t's three vertices by adding Q t to their quadric matrices.</p><p>After summing up all per-triangle quadric matrices in a cluster, we obtain a quadric matrix Q S that contains shape information for the piece of surface passing through the grid cell:</p><formula xml:id="formula_2">Q S = ∑ t Q t = A −b T −b c<label>(3)</label></formula><p>Using this decomposition of Q S , the 3 × 3 linear system Ax = b is solved for the "optimal" representative vertex position x that minimizes the quadric error. That is, x is the position that minimizes the sum of squared volumes of the tetrahedra formed by x and the triangles in the cell. When clustering vertices together, the majority of triangles degenerate into edges or points and can be discarded, thereby reducing the complexity of the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">OoCSx</head><p>The main idea of our modification of the OoCS algorithm is to eliminate the list of occupied clusters which OoCS allocates in main memory and uses for keeping track of their quadrics. Instead of directly computing quadrics, OoCSx computesn t for the current triangle t and outputs this information to a file, three times for each of the three vertices, together with the information for what grid cell the vertex belongs to. At the same time, we also output another file which contains the non-degenerate triangles (those triangles that have vertices in three different clusters) represented as indices to the grid cells. Then, we externally sort the file containing the vectorsn t using the grid locations as the primary key. After this, all the information related to one grid cell is placed contiguously in the file. By scanning it, it is possible to compute the quadrics and the optimum location of the representative vertex for a particular grid cell. After the vertices in the simplified mesh have been computed, we are left with the task of associating the grid cell references in the triangle file with vertex representatives. This step is described in more detail below.</p><p>Here are the steps of OoCSx in detail:</p><p>(1) Read triangles, compute quadric information for later use.</p><formula xml:id="formula_3">For each triangle t = (x t 1 ,x t 2 ,x t 3 )</formula><p>in the input mesh, we computen t (Equation 2). Note that we do not compute any quadric matrices at this point. For each vertex x t i of t, we also determine the grid location G(x t i ) (as an integer ID) that the vertex will be mapped to. As triangles are read, we output this information to two files: -A "plane equation" file, which contains 3 entries for each triangle, one for each vertex. Each entry is of the form: G(x t i ),n t . Using 32-bit integers to represent G and 32-bit floats forn t , this file takes 20 bytes of disk per entry.</p><p>-A "triangle cluster" file, which contains records of</p><formula xml:id="formula_4">the form G(x t 1 ), G(x t 2 ), G(x t 3 )</formula><p>. Each record takes 12 bytes, and is written only when G(</p><formula xml:id="formula_5">x t 1 ) = G(x t 2 ) = G(x t 3 )</formula><p>.</p><p>(2) Sort "plane equation" file using G as the sort key. This step is performed using an external sort algorithm, which is discussed below.</p><p>(3) Compute quadrics and output optimal vertices. In order to find the representative vertex for a given cluster, we need to sum up all the quadrics that contribute to its position. Because the "plane equation" file has been sorted on cluster IDs (i.e., G), all the vectorsn t that contribute to a given grid cell are together in the file. That is, in a single scan, we can sum all then tn T t into a quadric matrix Q S , which is used to compute the representative vertex position. <ref type="bibr" target="#b1">2</ref> As we find the representative vertex x for a given grid cell G, we output 16-byte records G(x),x . Note that we get this file already in "sorted" order for free. A more useful format for this data is to "dereference" the triangle cluster file and create a file which lists the vertices of each triangle. This can be done in three passes, one for each of the three fields G(x t i ). In each pass, the triangle file is sorted on the current vertex field. After each sort, the cluster IDs are scanned and replaced with entries from the representative vertex file, which is read sequentially, in tandem. Many applications prefer an indexed mesh representation, for which one would replace the cluster IDs with vertex indices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Time and Space Complexity</head><p>The memory usage of the OoCSx algorithm we have described does not depend on the size of the input dataset. The algorithm just needs to have enough memory to hold the data structures for one triangle and perform the other calculations for computing the quadrics and optimal vertices. In fact, we use slightly more memory in our external sort implementation, which by default uses four megabytes of memory. Overall, on a PC running Linux, the code never uses more than five megabytes of memory (eight megabytes on IRIX due to larger executables) regardless of the size of the input dataset or the level of approximation desired.</p><p>The time complexity of OoCS is O(n), since it only performs a single scan over the mesh file and keeps all the information regarding the quadrics in main memory. Because of the need to sort several files, OoCSx has time complexity O(n log n). <ref type="bibr" target="#b1">2</ref> Although our input and output files use single-precision floating point numbers, we perform the in-memory computations in double precision. 32bit floats do not provide enough precision for the computations done for very large models like the St. Matthew statue and fluid isosurface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>External Sorting</head><p>At the center of OoCSx are a series of external sorts. External sort algorithms are very important for the design and implementation of I/O-efficient algorithms (see <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b15">16]</ref>). There are several issues in implementing external memory algorithms, and these issues can greatly affect the overall performance of a system. In general trying to mimic the interface of the C qsort routine, although often pursued, does not seem the most efficient implementation technique. In our experience with different external sorts <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b17">18]</ref>, the most efficient implementation uses a combination of radix and merge sort, for which the keys are compared lexicographically. A particularly efficient external sort is rsort written by John Linderman at AT&amp;T Research <ref type="bibr" target="#b17">[18]</ref>. We use rsort for the results presented in this paper. Luckily, it is relatively easy to generate keys which can be compared lexicographically (see the man page for fixcut, also from Linderman). In OoCSx, we only need integer keys. For these, we simply have to write them in big-endian format.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Quality Improvements Surface Boundary Preservation</head><p>Because OoCS does not make use of connectivity information, it has no way of detecting whether an edge is a boundary edge or not. Consequently, surface boundaries are not well preserved by the method. We propose a variation on the technique used by Garland and Heckbert <ref type="bibr" target="#b13">[14]</ref>, which makes use of planes parallel to the boundary edges and orthogonal to their incident triangles.</p><p>Building on this idea, we can create an edge quadric. For each half-edge e of each triangle, we compute a planem e that passes through the two vertices of e. The normal vector m e of this plane is orthogonal to both e and the normal of the face that e belongs to <ref type="figure">(Figure 1)</ref>. The distance of a point to this plane provides a measure of how close the point is to the associated edge. We are here only concerned with distances parallel to the plane of the incident face-the per-triangle quadrics from Equation 2 already penalize deviations orthogonal to the face. Using these definitions, we distribute for each half-edge e = (x e 1 ,x e 2 ) its plane equationm e to the clusters corresponding to its two vertices. After adding up all the plane equations (4-vectors) in a cluster, we compute a quadric matrix Q B for the boundary as: </p><formula xml:id="formula_6">Q B = ∑</formula><p>Note that all edges, whether manifold or on the boundary, are treated equally. What makes the algorithm sensitive to boundary edges is that, when adding the implicit plane equationsm e , there is no opposing half-edge from the neighboring triangle to cancel m e . This is illustrated in <ref type="figure">Figure 1(b)</ref>, where the plane equations for two adjacent coplanar faces exactly cancel each other. For noncoplanar faces, the plane equations will not totally cancel, but a residual vector (the normal vector of a new plane) remains that penalizes positions away from the edge in the plane that bisects the dihedral angle formed by the two triangles. The sharper an edge is, the larger this penalty becomes. When used as part of an error measure, this would tend to preserve sharp edges, which is often desired. Based on this argument, non-manifold edges would also tend to be preserved, which is likely desirable since they typically form sharp creases in the mesh. Note that this scheme makes no use  <ref type="figure">Figure 1</ref>: Illustration of the vectors used for surface boundary preservation. The boundary normal m is orthogonal to the face normaln and the vector e along the edge e. For manifold edges that share two coplanar faces, the boundary normals cancel. In the case of non-coplanar faces, the residual vector m 1 + m 2 lies in the plane that bisects e's dihedral angle.</p><p>of connectivity information, yet implicitly accounts for the feature edges in the mesh.</p><p>The final quadric for the cluster is computed as a linear combination λQ S + (1 − λ)Q B of the surface quadric and the new boundary quadric. Note that we have been careful to weight the boundary quadric so as to ensure scale invariance and compatibility with the area-squared weighted triangle quadrics. We have found that weighting the quadrics equally (λ = <ref type="bibr" target="#b0">1</ref> 2 ) tends to give good results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Constrained Optimization over Cell Boundaries</head><p>As discussed in <ref type="bibr" target="#b19">[20]</ref>, the minimum quadric error sometimes falls outside the cluster's grid cell. While rare, the minimum may be arbitrarily far from the grid cell given the right conditions. Our previous approach to handling these degeneracies was to use one of a number of ad hoc methods for clamping the vertex coordinates, such as projecting the vertex onto the grid cell boundary. To ensure that the vertex is contained in the grid cell, but also results in the smallest possible quadric error, we perform a linearly constrained optimization over the grid cell boundary whenever the global optimum is outside it. Because the quadric functional is quadratic and the grid cell constraints are linear, the solution to this optimization problem can be found by solving a set of linear equations (cf. <ref type="bibr" target="#b21">[22]</ref>). This optimization problem is made particularly easy by the fact that the linear constraints are all perpendicular to each other and parallel to the coordinate axes, and can therefore generally be solved as a 2D or 1D problem. <ref type="table" target="#tab_1">Table 1</ref> summarizes our experimental results. We used two machines for our experiments, most of which were performed on a Linux PC with 512 MB of main memory and two 800 MHz Pentium III processors. The simplification of the statue and fluid isosurface was performed on one processor of a SGI Onyx2 with fortyeight 250 MHz R10000 processors and 15.5 GB of main memory. On the SGI, we used one of its one-terabyte striped disks. Overall, OoCSx was between two to five times slower than OoCS, but sometimes the speed difference was even smaller. In one case, for a high-resolution simplification of the blade, OoCSx was faster than OoCS. The reason for this is that OoCS ran out of memory, and numerous page faults occurred. This happened while trying to simplify the blade to one quarter of its initial size. The ratio in memory usage of OoCS and disk usage of OoCSx varied widely, going from a low of 6 to a high of 245! These variations are due to the dependency on n, the size of the input model, in OoCSx, whereas the memory usage of OoCS is proportional to m, the size of the output model. For the external sort code rsort used in our implementation, we empirically determined the maximum disk usage of OoCSx to  be 172T in + 12T out bytes. <ref type="bibr" target="#b2">3</ref> These results indicate that rsort requires roughly twice the input size of additional storage. If necessary, there are techniques for lowering the disk overhead of OoCSx. For instance, it would be possible to perform multiple sorts, instead of a single one, and accumulate phases if disk space is at a premium. <ref type="figure" target="#fig_0">Figure 4</ref> shows the effect of using edge quadrics in the simplification of the boundary (shown in red) of the bunny. From this figure, it is evident that the boundaries have been preserved with better visual accuracy. This subjective result is also supported numerically by <ref type="figure" target="#fig_3">Figure 2</ref>, which shows the maximum (Hausdorff) and root mean square (RMS) distances between closest points on the boundaries for several levels of detail of the bunny. These error measures were evaluated symmetrically by considering all points on the boundaries of both the original and the simplified model. Clearly, the use of boundary quadrics greatly reduced the boundary errors. In addition, we found that the use of boundary quadrics did not negatively impact the errors measured over the surface interiors. Instead, using boundary quadrics reduced both boundary and surface errors for models with boundaries, and did not result in a measurable increase in surface error for models without boundaries. <ref type="figure" target="#fig_4">Figure 3</ref> is an isosurface of a time slice from a large-scale turbulent-mixing fluid dynamics simulation, consisting of 2, 048 × 2, 048 × 1, 920 voxels at 27,000 time steps <ref type="bibr" target="#b22">[23]</ref>. This surface is challenging to simplify due to its highly complex topology and wispy geometry. <ref type="table" target="#tab_1">Table 1</ref> lists the performance data for simplifying the entire isosurface. To avoid too much clutter in the images presented here, we also extracted a small piece (one third of a percent) of the volume and simplified it independently ( <ref type="figure">Figure 6</ref>). As can be seen in <ref type="figure">Figure 6</ref>(e), there is significant loss in topological structure and geometric detail as the triangle count drops to a few million. A simplification of a complex dataset like this requires more triangles than can be stored in RAM on most computers, and must be simplified using a memory insensitive method such as OoCSx.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTAL RESULTS</head><p>Notice also the improved boundaries in <ref type="figure">Figure 6</ref>(d) over the model simplified without boundary quadrics ( <ref type="figure">Figure 6(b)</ref>). Finally, we evaluated the effect of performing constrained optimization over the cell boundary in those cases where the optimal vertex position lies outside the cell. We compared this approach to (1) leaving the vertex outside the cell, and (2) projecting it onto the cell boundary. In all cases, the constrained optimization performed as well or better than the other two approaches, both in terms of maximum and RMS error. <ref type="figure">Figure 5</ref> shows an example where constrained optimization resulted in nearly a factor of six reduction in the maximum error over leaving the vertices unclamped. Notice how the artifacts near the lower jaw, ears, and hind leg are eliminated by clamping and optimizing the vertices, leaving a more visually pleasing model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSIONS</head><p>In this paper, we proposed improvements to the out-of-core simplification (OoCS) technique <ref type="bibr" target="#b19">[20]</ref>. First, we described OoCSx, a memory insensitive variation of OoCS. The key feature of OoCSx is its ability to efficiently simplify arbitrarily large datasets using a constant amount of main memory. OoCSx uses a disk-based technique for storing information about the simplified mesh and arranging it in a cache-coherent manner. We also discussed an efficient implementation of OoCSx and compared its performance with OoCS. Second, we proposed a technique for preserving surface boundaries without making use of connectivity information. Our approach is to compute and minimize an edge-based quadric error for all edges of the mesh, regardless of their topological type. We showed that this technique can dramatically improve the shape of boundary curves, with little or no loss in geometric quality over the remaining surface. Finally, we proposed using a linearly constrained optimization over grid cell boundaries to compute vertex positions whenever the global optimum is outside the grid cell.</p><p>One shortcoming of the current approach is that the overall simplification has constant feature size. Similar to <ref type="bibr" target="#b26">[27]</ref>, it would be interesting to extend OoCSx to simplify the mesh adaptively. Taking this one step further, we will investigate how to adapt our out-ofcore algorithms to perform dynamic view-dependent refinement of the mesh for interactive visualization. Another drawback of OoCSx is that it requires significant amounts of disk space. The per-triangle quadric information stored on disk constitutes a large portion of the overall space requirements. We believe that careful encoding of these 4-vectors, using normal quantization <ref type="bibr" target="#b8">[9]</ref> and per-grid-cell coordinate representations, will allow this information to be represented using as little as 32 bits per vector. Finally, many datasets come with surface attributes such as scalar field values, normal and curvature information, and color. We hope to extend our simplification code to take into account and preserve such information.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>( 4 )</head><label>4</label><figDesc>Replace cluster IDs in triangle file with corresponding vertices. At this point, the file with the representative vertices and the "triangle cluster" file hold the complete simplified mesh.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>e 1 + x e 2 ) T m e ( 5 )</head><label>25</label><figDesc>m e = e e (e e ×n e ) (6) e e = x e 2 − x e 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>boundary quadrics (max error) w/ boundary quadrics (max error) w/o boundary quadrics (rms error) w/ boundary quadrics (rms error) Maximum and root mean square boundary error for bunny model, simplified with and without boundary quadrics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>470 million triangle isosurface of entire fluid dynamics dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Run-time performance of OoCS and OoCSx. The results reported for the dragon, buddha, and blade were computed on a Linux PC. The statue and fluid models were simplified on a SGI Onyx2. Even on the 15.5 GB SGI, not enough RAM was available for OoCS to produce the finest level of detail of the fluid dataset.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">In this paper,ā denotes a 4-vector, andâ is a unit-length 3-vector.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">This usage is for the intermediate files only, and does not include the space needed for the input and output files.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was performed under the auspices of the U.S. DOE by LLNL under contract no. W-7405-Eng-48. We would like to thank the reviewers for useful comments. Many thanks to Glenn Fowler and John Linderman for several discussions and access to their external sorting code. We wish to thank Stanford University and the Digital Michelangelo Project for providing the bunny, dragon, Buddha, and St. Matthew datasets, and Kitware for the turbine blade model. Thanks to David Bremer, Mark Duchaineau, and Randy Frank for preparing the fluid dynamics dataset.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix: Dereferencing Indexed Meshes</head><p>The file format we assume in our algorithm is different from the indexed mesh formats commonly used for main memory techniques. In main memory, it is common to store a list of vertex coordinates (x, y, z), and a list of triangles, represented by three integers that refer to the vertices of the given triangle. Before such datasets can be used in our algorithm, they need to be "normalized", a process that dereferences the pointers to vertices. This process is thoroughly explained in <ref type="bibr" target="#b6">[7]</ref>. For completeness, we briefly explain how to normalize such a file with V vertices and T triangles. In an initial pass, we create two (binary) files, one with the list of vertices, and another with the list of triangles. Next, in three passes, we dereference each index in the triangle file, and replace it with the actual position for the vertex. In order to do this efficiently, we first (externally) sort the triangle file on the index we intend to dereference. This takes time O(T log T ) using an (external memory) mergesort. Then, we perform a synchronous scan of both the vertex and the (sorted) triangle file, reading one record at a time, and appropriately outputting the deferenced value for the vertex. Note that this can be done efficiently in time O(V + T ) because all the vertex references are sorted. When we are done with all three passes, the triangle file will contain T records with the "value" (not reference) of each of its three vertices.  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">External Memory Algorithms and Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vitter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>American Mathematical Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Algorithms and Data Structures in C++. Addison Wesley</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parallel Accelerated Isocontouring for Out-of-Core Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thompson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Parallel Visualization and Graphics Symposium</title>
		<meeting>IEEE Parallel Visualization and Graphics Symposium</meeting>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="97" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Case study: Scanning Michaelangelo&apos;s Florentine Pietà</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bernardini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mittleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Rushmeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIG-GRAPH 1999 Course notes</title>
		<imprint>
			<date type="published" when="1999-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Ball-Pivoting Algorithm for Surface Reconstruction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bernardini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mittleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Rushmeier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="349" to="359" />
			<date type="published" when="1999-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">I/O Optimal Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97</title>
		<imprint>
			<date type="published" when="1997-11" />
			<biblScope unit="page" from="293" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Interactive Outof-Core Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Application-Controlled Demand Paging for Out-of-Core Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97</title>
		<imprint>
			<date type="published" when="1997-11" />
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Deering</surname></persName>
		</author>
		<title level="m">Geometry Compression. Proceedings of SIG-GRAPH 95</title>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">External Memory View-Dependent Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Out-of-Core Rendering of Large Unstructured Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Farias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="42" to="50" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">AST sort</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Fowler</surname></persName>
		</author>
		<ptr target="http://www.research.att.com/sw/download" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Fast Polygonal Approximation of Terrains and Height Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<idno>CMU-CS- 95-181</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Surface Simplification Using Quadric Error Metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 97</title>
		<meeting>SIGGRAPH 97</meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Smooth View-Dependent Level-of-Detail Control and its Application to Terrain Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">of The Art of Computer Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
	<note>Sorting and Searching</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast Retrieval of Disk-Resident Unstructured Volume Data for Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Leutenegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">External Memory Algorithms and Visualization, DIMACS Book Series</title>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1999" />
			<biblScope unit="volume">50</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">rsort and fixcut man pages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Linderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rusinkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ginzton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ginsberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fulk</surname></persName>
		</author>
		<title level="m">The Digital Michelangelo Project: 3D Scanning of Large Statues. Proceedings of SIGGRAPH 2000</title>
		<imprint>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="131" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Out-of-Core Simplification of Large Polygonal Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 2000</title>
		<meeting>SIGGRAPH 2000</meeting>
		<imprint>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="259" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast and Memory Efficient Polygonal Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;98</title>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Evaluation of Memoryless Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="98" to="115" />
			<date type="published" when="1999-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Mirin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Dannevik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Dimitis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Eliason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">R</forename><surname>Woodward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Shieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>White</surname></persName>
		</author>
		<title level="m">Very High Resolution Simulation of Compressible Turbulence on the IBM-SP System. Proceedings of Supercomputing 99</title>
		<imprint>
			<date type="published" when="1999-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Rendering Complex Scenes with Memory-Coherent Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pharr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kolb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gershbein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 97</title>
		<meeting>SIGGRAPH 97</meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="101" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Progressive Meshes for Large Models of Arbitrary Topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Prince</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
		<respStmt>
			<orgName>University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">M.S. thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Multi-Resolution 3D Approximation for Rendering Complex Scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<title level="m">Efficient Adaptive Simplification of Massive Meshes. IEEE Visualization &apos;01</title>
		<imprint>
			<date type="published" when="2001-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<title level="m">A Fast Volume Rendering Algorithm for Time-Varying Fields Using a Time-Space Partitioning (TSP) Tree. IEEE Visualization &apos;99</title>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="371" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatic Generation of Triangular Irregular Networks Using Greedy Cuts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95</title>
		<imprint>
			<date type="published" when="1995-11" />
			<biblScope unit="page" from="201" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Greedy Cuts: An Advancing Front Terrain Triangulation Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th ACM Workshop on Advances in GIS</title>
		<meeting>the 6th ACM Workshop on Advances in GIS</meeting>
		<imprint>
			<date type="published" when="1998-11" />
			<biblScope unit="page" from="137" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Accelerated Isosurface Extraction in Time-Varying Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="98" to="107" />
			<date type="published" when="2000-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Out-of-Core Streamline Visualization on Large Unstructured Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-K</forename><surname>Ueng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sikorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="370" to="380" />
			<date type="published" when="1997-12" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
