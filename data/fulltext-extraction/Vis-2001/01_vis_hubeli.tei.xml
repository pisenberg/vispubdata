<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multiresolution Feature Extraction for Unstructured Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Hubeli</surname></persName>
							<email>hubeli@inf.ethz.ch</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Gross</surname></persName>
							<email>grossm@inf.ethz.ch</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science ETH Zentrum</orgName>
								<address>
									<postCode>8092</postCode>
									<settlement>Zurich</settlement>
									<region>CH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Multiresolution Feature Extraction for Unstructured Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Surface Representations</term>
					<term>Geometric Modeling</term>
					<term>Triangle Decimation</term>
					<term>Multiresolution Models</term>
					<term>Feature Extraction</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present a framework to extract mesh features from unstructured two-manifold surfaces. Our method computes a collection of piecewise linear curves describing the salient features of surfaces, such as edges and ridge lines. We extend these basic techniques to a multiresolution setting which improves the quality of the results and accelerates the extraction process. The extraction process is semi-automatic, that is, the user is required to input a few control parameters and to select the operators to be applied to the input surface. Our mesh feature extraction algorithm can be used as a preprocessor for a variety of applications in geometric modeling including mesh fairing, subdivision and simplification.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivation</head><p>Recent advances in acquisition systems have resulted in the ready creation of very large, densely sampled surfaces, usually represented as triangle meshes. The impossibility of real-time interaction with these large models has motivated many researchers in the computer graphics community to design advanced mesh processing methods including subsampling, restructuring, fairing and others.</p><p>The early approaches, such as the vertex removal algorithm of W. Schröder <ref type="bibr" target="#b18">[19]</ref> or the progressive mesh algorithm of H. Hoppe <ref type="bibr" target="#b9">[10]</ref>, use local error norms to construct multiresolution approximations of meshes by iteratively removing information from the input mesh. More recent representations are based on the generalization of fairing techniques from signal processing <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b10">[11]</ref>, or on subdivision surfaces <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b13">[14]</ref>. These approaches combine advanced operators with multiresolution techniques to enable interaction with large datasets and provide additional functionality, such as editing.</p><p>In this paper we investigate a related problem: the detection of mesh features. Our goal is to extract piecewise linear features from meshes which can then be used to construct more sophisticated</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Previous Work</head><p>In his pioneering work <ref type="bibr" target="#b1">[2]</ref>, Canny constructed an optimal filter to detect and extract certain types of features from images. The criteria used to design the filter include detection performance, sharp localization of the features and a unique detection of edges.</p><p>The theory of snakes <ref type="bibr" target="#b11">[12]</ref> uses deformable models to track features. A polygonal curve is assigned an energy function and is deformed until its associated energy is minimized. The choice of particular energy functions ensures that the polygonal curve traces a feature to its end configuration.</p><p>Anisotropic diffusion, as used in <ref type="bibr" target="#b16">[17]</ref>, is a powerful tool that allows to remove high-frequency noise while preserving the feature information. Thus, the technique enables the construction of robust edge detection algorithms. This operator has been extended to the non-parameterized setting of triangle meshes with arbitrary connectivity in <ref type="bibr" target="#b2">[3]</ref>.</p><p>A problem related to feature extraction is image segmentation <ref type="bibr" target="#b8">[9]</ref>, where input images must be subdivided into regions that possess similar characteristics. A robust segmentation algorithm was used to extract features being defined as the piecewise linear curves that bound different regions in the mesh.</p><p>Most of the techniques discussed in this section apply to images. There are several advantages of handling images over triangle meshes: images have both a regular connectivity and a well known parameterization, properties that triangle meshes do not possess. These differences complicate the extension of these techniques to the more general domain of unstructured triangle meshes. Rossl et al. <ref type="bibr" target="#b17">[18]</ref> addressed this problem by constructing an extraction technique based on morphological operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Paper Organization</head><p>The paper is organized as follows: in section 2 we provide some basic definitions and give an overview of the framework. In section 3 we present the first major component of our framework, the set of classification operators, followed in section 4 by a discussion of the second component, the detection operators. In section 5 we describe a multiresolution feature extraction technique. In section 6 we present some of the results we obtained using this technique and we discuss some application domains. We will conclude the paper with the description of some future challenges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview of the Technique</head><p>The goal of the framework presented in this paper is to extract a set of mesh features from two-manifold polygonal meshes with arbitrary connectivity. To this end, we first formalize the notion of a mesh feature and the domain of our operators:</p><p>Definition: A mesh feature is a piecewise linear curve that describes an important characteristic of the input mesh. We restrict any mesh feature as being represented by a collection of edges of the mesh. That is, our extraction operators are not required to modify the connectivity of the mesh.</p><p>Definition: a surface is a two-manifold with boundaries, where every point has an open neighborhood homeomorphic to either or .</p><p>The approach that we introduce is independent of the feature semantics, i.e. the operators are not trained to recognize particular patterns. Instead, we decided to use application-neutral operators which are based on notions such as Laplacian or curvature. The resulting framework is subdivided into two components, as shown in figure 1:</p><p>• In a classification phase, every edge in the model is assigned a weight proportional to the probability that the edge lies on a mesh feature. The operators used in this step are not based on any assumption on the input mesh, except that it has to be a two manifold surface with boundaries. • In a detection phase, mesh features are reconstructed from the information computed in the previous step. By our definition, this step constructs piecewise linear curves, defined as collections of edges.</p><p>The distinction between the classification and detection operators has several advantages: first, it is possible to easily swap between classification operators and thus choose the best suitable operator for the particular input mesh. Furthermore, if additional information on the application domain is available, new optimized operators can be included into the framework more easily.</p><p>In the next two sections we will describe the two components in detail and present the set of operators that we constructed and tested in our framework. We illustrate the results by applying them to surfaces with different properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Classification Phase</head><p>The goal of the classification phase is to assign a weight to every edge in the input mesh. Ideally, the weight should be proportional to the probability that the edge belongs to a mesh feature: edges close to mesh features should be assigned larger weights than edges that are farther away. The information computed in this first phase will then be used to extract a set of the most important edges, which in turn will be used to reconstruct the mesh features.</p><p>In the classification step we are faced with different problems. First, the operators must be capable to handle meshes with different resolutions. Some meshes are highly optimized meaning that the number of triangles is reduced to a minimum, while others are oversampled. In addition, the classification process is aggravated by the presence of high frequency noise in the input meshes, which could mistakenly be recognized as useful information.</p><p>To alleviate some of these problems we provide a set of different operators, each with different properties, and better suited to handle certain classes of meshes. In addition, we can optionally prefilter the input meshes using standard approaches, such as the umbrella <ref type="bibr" target="#b12">[13]</ref>, second order differences <ref type="bibr" target="#b7">[8]</ref> and curvature flow <ref type="bibr" target="#b3">[4]</ref> operators.</p><p>In the remainder of this section we will introduce the operators we use in our framework and discuss their capabilities and limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Second Order Difference (SOD)</head><p>The SOD is the simplest classification operator. It assigns a weight to every edge in the mesh proportional to the dihedral angle defined by the normals of its two adjacent triangles. The idea is based on the second order difference operator constructed in <ref type="bibr" target="#b7">[8]</ref>, which was used to fair meshes of arbitrary connectivity. The operator, described by equation <ref type="formula">1</ref>, is locally bound and can be evaluated efficiently.</p><p>(1)</p><p>The variables and correspond to the normals of the two triangles that share edge , as shown in figure 2.</p><p>This technique is best suited for coarse, pre-optimized meshes. However, SOD performs poorly on highly detailed or noisy meshes, since all computations are carried out within a small region of support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Extended Second Order Difference (ESOD)</head><p>The ESOD operator extends the SOD operator by using a larger support to evaluate the weight of an edge . Instead of defining and as the normals of the two neighboring triangles of , we define them as the average normals computed from the triangles on the one-ring of the vertices and opposite to and apply the them in equation <ref type="bibr" target="#b0">(1)</ref>. The extended support of ESOD is illustrated in figure 3.</p><p>The increased support of the operator has the expected consequences: the influence of noise on the classification process is attenuated. However, as a the support of the operator is larger and cannot be adapted to the input mesh, ESOD does not perform well on very coarse meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Best Fit Polynomial (BFP)</head><p>The BFP operator uses a different philosophy than the previous operators, in that it makes use of a parameter domain associated with every edge in the mesh. The weight assigned to an edge is computed as follows: first, a subset of the mesh vertices are projected onto the parameter domain and a best fit polynomial of degree n is computed. The curvature of the (planar) polynomial is then evaluated at the parameter position of , as described by equation <ref type="formula" target="#formula_0">2</ref>:  </p><formula xml:id="formula_0">n i n i --------- n j n j --------- ⋅     cos = n i n j e e n i n j e n i n j e x i x j e n j n i e x j x i e p u ( ) e<label>(2)</label></formula><p>The major challenges of this approach are the definition of the parameter domain and the proper projection of the set of vertices from 3-space. An intuitive definition of the parameter space is given in figure 4.</p><p>We propose to set the parameter plane to be perpendicular to the vector defined by the edge . A unique plane is defined by requiring the midpoint of to lie on the plane. The points used in the best fit process are computed from the intersection of the plane with a set of neighboring triangle edges, as shown in figure 4.b. The most important advantage of this strategy is that the support of the operator can be chosen freely and that it can be adapted locally for each edge. An additional degree of freedom is given by the degree of the fitting polynomial which can be adjusted to the size of the support of the operator.</p><p>This approach has the advantage of being very flexible, because the support can be adapted both globally and locally. Thus, it is less influenced by noise which is filtered out during the best fit process. Furthermore, it has the potential to be used for any type of mesh, provided that an appropriate set of parameters is chosen. The main disadvantage of the approach is that its computational cost is higher than the cost of the previous operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Angle Between Best Fit Polynomials (ABBFP)</head><p>The ABBFP operator is a variation of the BFP operator which is also based on best fit polynomials. As for the previous approach, polynomials are fitted in the parameter domain of every edge (figure 5). The ABBFP operator fits two polynomials: one for the vertices that lie on one side of in the parameter domain and another for the vertices lying on the other, as illustrated in figure 5.c. The weight assigned to is chosen to be proportional to the angle between tangents of the two curve evaluated at the parameter position of . The weight is then computed according to equation <ref type="formula">3</ref>:</p><formula xml:id="formula_1">(3)</formula><p>As for the BFP operator, the user is allowed to specify both the size of the support and the degree n of the polynomial used in the best fit process. A potential advantage of this variant is that it is adept in capturing discontinuities at the parameter position of , which hints at the presence of a mesh feature in the neighborhood of .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Comparison of the Operators</head><p>In order to compare the different operators that were described in this section, we apply them to two different types of meshes. <ref type="figure" target="#fig_4">Figure 6</ref>.a depicts a coarse mesh that represents a motor part using few triangles. <ref type="figure" target="#fig_4">Figure 6</ref>.b-c illustrate the result computed using the SOD and BFP operators respectively. In this example SOD is better suited than BFP, since it captures all important information and it can be evaluated efficiently. The BFP operator is capable of generating good results, but its parameters must be tuned carefully. <ref type="figure" target="#fig_6">Figure 7</ref>.a shows a highly detailed mesh that represents a geological surface using a large number of triangles. The results computed using the SOD and BFP operators are depicted in figure 7.bc respectively. The SOD operator recognized important regions in the mesh, but noisy regions were also recognized as a result of the limited support of the operator. The BFP operator performed better, since its support has been tuned to filter out most of the noise present in the surface.</p><p>For both examples presented in figure 6 and figure 7 the same parameters were chosen for the hysteresis which was used to select the set of most important edges. A description of the hysteresis function is given in section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Detection Phase</head><p>The classification step discussed in the previous section assigns a weight to every edge in the input mesh, which is proportional to the probability that the edge belongs to a mesh feature. The detection phase analyzes these values and reconstructs a set of important mesh features in four steps: • First, the set of the most important edges is computed. The importance of an edge is defined both by its weight and by the weight of the neighboring edges.   • The set of edges is analyzed to construct a set of patches. A patch is a mesh region that is likely to contain one or more mesh features. • The mesh features are extracted from the patches using a skeletonizing algorithm which iteratively simplifies every patch to a collection of piecewise linear curves. • Optionally, unimportant mesh features can be removed from the result. The importance of a mesh feature is computed from its length and from the weights associated with its edges. In the next three subsections we will describe each of these steps in detail and illustrate the results with an example.</p><formula xml:id="formula_2">p l ' e ( ) , ( ) 1 p l , ' e ( ) ( ) ----------------------------- 1 p r , ' e ( ) ( ) 1 p r , ' e ( ) ( ) ----------------------------- ⋅     1 - cos = e e</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Selection of Important Edges</head><p>The first step in the detection phase is crucial, since it identifies the edges close to the mesh features. This process is heavily mesh dependent: meshes contain a varying number of mesh features and their edge density is variable. Furthermore, the process is also influenced by the user who might be interested in only a subset of the mesh features. Hence, we require the user to specify the bounds of the hysteresis function used to mark the set of important edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hysteresis Thresholding</head><p>This approach requires two user-defined values which serve as a lower bound and as an upper bound of the hysteresis. An edge in the mesh is selected if it satisfies one of two conditions: </p><p>If neither condition is satisfied, the edge is discarded. <ref type="figure">Figure 8</ref> illustrates the binary hysteresis function with upper bound and lower bound and as implemented in our framework:</p><p>A hysteresis has several advantages versus standard thresholding strategies: first, thresholding can be simulated by the hysteresis function by setting the upper and lower bounds to the same value: <ref type="bibr" target="#b5">(6)</ref> Furthermore, the hysteresis clusters edges better than thresholding. As a result, the patching algorithm is capable of generating less patches with larger area, which in turn allows us to extract mesh features more robustly. <ref type="figure">Figure 9</ref> illustrates the set of patches obtained by using different bound values for the same set of input weights. If the upper and lower bounds are set to the same value, as in <ref type="figure">figure 9</ref>.b, the hysteresis process is reduced to standard thresholding and the selected edges have not been clustered well. The use of different bounds, as illustrated in <ref type="figure">figure 9</ref>.c, enables us to remove some of the isolated edges and generate better clusters. The choice of a very large upper bound and a small lower bound allow us to select edges close to the most important features, as shown in figure 9.d.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Patch Construction</head><p>The construction of the patches is actually not required in the detection phase. However, the use of patches allows us to apply extensions of standard skeletonizing algorithms from the field of computer vision <ref type="bibr" target="#b5">[6]</ref>. This is advantageous, since the problem has been well studied in that field and many robust skeletonizing algorithms are available.</p><p>As mentioned in section 4.1, the hysteresis operator has good clustering capabilities. The goal of the patching algorithm is to transform these clusters into uniform patches, where all edges are marked. Additionally, the algorithm is not allowed to increase the size of the clusters, but only fill the interior. The result is a simple condition that is checked to select additional edges and insert them into the set created in section 4.1:</p><p>Condition: An edge is inserted into a patch if it was marked in the previous step, or if both of its endpoints belong to other edges present in the patch, regardless of the weight of .</p><p>This condition is similar to the second condition used by the hysteresis function. Again, edges with a small weight are inserted into   </p><formula xml:id="formula_4">B l B u B l B u = a) b) c) d)</formula><p>e w e ( ) e the set of patches if they are close to important edges. The requirement that important edges are present on both sides of ensures that patches do not grow unnecessarily large. The absence of requirements for the weight of guarantees that all unmarked edges in the interior of a cluster will be added to the cluster thus resulting in more uniform patches. Note that the holes in the patches depicted in <ref type="figure" target="#fig_8">figure 10</ref>.b are a consequence of the requirement that patches should not grow more than needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Skeletonizing</head><p>The most important step in the detection phase consists in the extraction of the final mesh features from the patches computed in the previous step. We accomplish this goal using a skeletonizing algorithm similar to the ones used computer vision. In particular, we constructed a thinning technique: patches are thinned to a set of mesh features by burning the edges from the boundary of the patches down to a set of piecewise linear curves. We do not use existing algorithms from computer vision, since the skeletonizing algorithm is expected to handle meshes with arbitrary connectivity and not only height field data. The thinning algorithm is described by the following pseudo-code fragment: The thinning operation is initialized by inserting all the edges that lie on the boundary of a patch into a linked list. The function isBoundaryEdge checks the following condition for the edge :</p><p>Condition: consider an edge that belongs to a patch and its two adjacent triangles</p><p>and . If any of the other four edges of and do not belong to the patch, then is a boundary edge.</p><p>The boundary edges are extracted from the list one at a time, and they are analyzed. The function belongsToPatch inspects two conditions to decide whether an edge belongs to a mesh feature: Condition 1: If only one of the endpoints of belongs to another edge in the patch, is only preserved if the endpoint belongs to only one other marked edge. If the endpoint belongs to multiple edges in the patch, then must be removed. This condition enables us to remove edges that are perpendicular to the mesh feature being extracted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Condition 2:</head><p>If both endpoints of belong to other edges in the patch, then can only be removed if it does not disconnect the patch locally. The patch is not disconnected by the removal operation if and only if one of the two adjacent triangles and of is defined by three marked edges. Consider the example in <ref type="figure" target="#fig_12">figure  11</ref>: the edge in the configuration displayed in <ref type="figure" target="#fig_12">figure 11</ref>.a can be removed safely, since all the edges in are marked. Conversely, the edge in <ref type="figure" target="#fig_12">figure 11</ref>.b cannot be removed without disconnecting the patch locally.</p><p>If an edge is removed from a patch, at most two new edges will become boundary edges and they must be inserted into the list. After the edge has been analyzed, the next edge is extracted from the list. This process continues until the list is empty.</p><p>The end configuration is guaranteed to be a collection of piecewise linear curves. Since the patches were not disconnected in the thinning process, the mesh features are also guaranteed to be connected. The mesh features can intersect, i.e. a vertex can belong to more than two edges that belong to mesh features. Therefore, complex features can be recognized and extracted by the algorithm. <ref type="figure" target="#fig_0">Figure 12</ref> illustrates the mesh features extracted from the set of patches computed in the previous section. The input data is visualized in <ref type="figure" target="#fig_0">figure 12</ref>.a and the set of output mesh features in <ref type="figure" target="#fig_0">figure  12</ref>.b. By analyzing the result thoroughly, one can notice that one of the patches has been thinned into two mesh features implying that the patch has been disconnected. The two features were connected by a third feature that has been removed from the result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Importance Function</head><p>The set of mesh features can be optionally reduced so that only "important" features are returned to the user. In our opinion, the importance of a mesh feature is determined by two factors: its length, i.e. the number of edges present in the mesh feature and the average weight of the edges. The elimination of "unimportant" features is performed by ranking the mesh features according to an importance function such as (7)     </p><formula xml:id="formula_5">I F i ( ) F i 1 n --- w e ( ) e F i ∈ ∑ ⋅ =</formula><p>The term describes the length of the mesh feature and the weight of an edge that belongs to . Next, the mesh features with smallest importance are removed from the result and the remaining features are returned to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Multiresolution Feature Extraction</head><p>The classification and detection techniques that we discussed in the previous two subsections are efficient and generate meaningful mesh features. However, as already shown in image processing <ref type="bibr" target="#b15">[16]</ref>, the use of multiresolution techniques can improve the overall framework, both in terms of efficiency and in terms of quality of the results. In particular, the use of a multiresolution representation of the input mesh enables us to better capture low frequency mesh features than by extending the support of the classification operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Multiresolution Representation</head><p>The literature offers many different multiresolution representations for triangulated two-manifold meshes, based on operators such as vertex removal <ref type="bibr" target="#b18">[19]</ref> and edge collapse <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b4">[5]</ref>. We selected a progressive mesh algorithm <ref type="bibr" target="#b10">[11]</ref> in our framework, since the edge collapse and vertex split operators naturally complement our own operators.</p><p>In addition, we obtain the following advantageous properties: • The coarse approximation of the input mesh only contains the structural information on the mesh, i.e. the collapse operator preserves the salient features of the mesh during the simplification process.</p><p>• During the refinement process, the vertex split operations can be analyzed on the fly to update the set of mesh features. Thus we obtain the full-resolution features after all the vertices have been re-inserted into the mesh. • A multiresolution approach has the potential of accelerating the extraction process. This can be accomplished by computing the weight of a subset of the edges of the input surface that are close to mesh features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Multiresolution Feature Extraction</head><p>As mentioned in the previous subsection, multiresolution and in particular the edge collapse operator can be used effectively to extract features incrementally from a full resolution mesh. This process is implemented in three steps: I. Given an input mesh, its progressive mesh representation is first constructed. The result consists of a coarse approximation of the mesh and a set of vertex split operations that allow us to reconstruct the original surface. II. The techniques described in section 3 and section 4 are applied to the coarse representation of the mesh to extract the most important mesh features. This operation can be performed efficiently, since both the classification and the detection steps are applied only to a subset of the edges of the input mesh. III. Finally, the input mesh is reconstructed from the coarse mesh by re-inserting the vertices and edges using the set of vertex split operations. During this process, it is crucial to update the mesh feature information which needs to adapt to the changes of the underlying mesh. The set of masks needed to perform these updates is illustrated in <ref type="figure" target="#fig_1">figure 13</ref>. During the insertion of a vertex which is split from a vertex , the neighborhood of the vertex split is analyzed. If belongs to a mesh feature, we need to check whether the feature needs to be modified. In principle however, many different configurations could be investigated in order to compute the best possible update. In practice, the masks displayed in figure 13 proved to be adequate and only three configurations must be considered:</p><p>• The case depicted in <ref type="figure" target="#fig_1">figure 13</ref>.a is unambiguous: the new edge must be included into the mesh feature, otherwise the insertion operation would split the feature into two components.</p><p>• The second case shown in <ref type="figure" target="#fig_1">figure 13</ref>.b is also straightforward:</p><p>the insertion of the new edge does not affect the feature. Therefore is not inserted into the feature.</p><p>• The third case shown in <ref type="figure" target="#fig_1">figure 13</ref>.c is more complex. The two edges that are split by the vertex split operation belong to the mesh feature. Therefore, the mesh feature can be updated in four different ways. The choice of the best path for the mesh feature is determined by analyzing the weights of the edges locally. The mesh feature is updated by the path with the largest average weight.</p><p>Of course, there are special cases that must be analyzed, such as the split of vertices at the end of a mesh feature, or the split of vertices where two or more mesh features meet. These configurations can also be handled using straightforward variations of the masks discussed previously and will not be discussed further.</p><p>Consider   is then continuously updated during the refinement process. An intermediate state is shown in <ref type="figure" target="#fig_2">figure 14</ref>.c, where 50% of the vertices were already re-inserted. The end configuration is displayed in <ref type="figure" target="#fig_2">figure 14</ref>.d. This approach could be further improved, since the coarse approximation of the input surface does not necessarily contain all the mesh features. Therefore, the algorithm should support the creation of new mesh features in the reconstruction process. This results in a multilevel feature detection strategy where the operators discussed in section 3 and section 4 are applied at different levels of resolutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results and Applications</head><p>In this section we present some of the results generated by our framework. We use both well known meshes, such as the "Stanford bunny", the "mannequin" and the "golf club", as well as models from the domain of geoscience. Most of these meshes have irregular connectivity and possess a set of features readily identifiable. The exception is the geological surface displayed in figure 17 which does not contain any prominent feature.</p><p>In <ref type="figure" target="#fig_3">figure 15</ref> we applied the framework to the mannequin head. To test the capabilities of the framework we first applied three Loop subdivision steps to the input data, so that the algorithm had to work on a very smooth domain. The results illustrated in <ref type="figure" target="#fig_3">figure  15</ref> have been computed using the BFP operator and a large support. The most important components of the face, such as the eyes, nose, ears and mouth, have been properly recognized. The localization of the mesh features is good given the amount of information present in the mesh.</p><p>Next, we present the mesh features extracted from the Stanford bunny in <ref type="figure" target="#fig_4">figure 16</ref>. For this mesh we used the ABBFP classificator and selected a support that filtered out most of the noise present in the fur of the bunny. The important components, such as the ears, tail, neck, legs and even some of the paws of the bunny, have been properly recognized. The hysteresis function removed other important features, such as the eyes and mouth. However, it should be noted that the magnitude of these features is almost the same as the magnitude of the noise present in the fur.</p><p>We believe that automatic feature extraction algorithms for meshes with arbitrary connectivity can be applied in different processes of geometric modeling. The first application we discuss is feature preserving fairing that has been proposed in our non-manifold fairing framework <ref type="bibr" target="#b10">[11]</ref>. Using the techniques presented in this paper, high frequency noise can be removed from complex models without removing important features. Mesh features can be used in conjunction with other operators as well in order to preserve information about the input model. Any subdivision operator can be extended to preserve features. This is accomplished by handling the mesh features as boundaries <ref type="bibr" target="#b0">[1]</ref> and by applying the one-dimensional subdivision operators on them. An example is displayed in <ref type="figure" target="#fig_22">figure 18</ref>. The input mesh ( <ref type="figure" target="#fig_22">figure 18.a)</ref> is first analyzed and its most important mesh features are extracted. The use of standard subdivision generates results of decent quality, but the magnitude of features is attenuated, as shown in <ref type="figure" target="#fig_22">figure  18</ref>.b. The use of a feature-preserving subdivision operator enables us to preserve the important mesh features much better, as illustrated in <ref type="figure" target="#fig_22">figure 18</ref>.c.</p><p>Finally, mesh features could also be used to govern a simplification algorithm: an edge collapse operator should not collapse edges perpendicular to a mesh feature, but rather parallel edges. Of course, error norms that control the simplification already strive to preserve features, but explicit feature preservation would guarantee that important information will not be removed from any of the approximations constructed by the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Work</head><p>In this paper we presented a framework for the detection of features in meshes with arbitrary connectivity. We proposed a twostage process consisting of a classification phase and a detection phase. In order to handle a variety of different meshes, we provide a set of operators with different properties. We extended our framework to a multiresolution setting, which clearly improves the quality of the results and the performance of the algorithms.</p><p>The user must select the operators as well as a few parameters for the classification and detection steps. As such, the process is not fully automatic and requires manual assistance and tuning for optimal performance. We do not consider this as a drawback, since all components of the framework can be computed efficiently: the complexity of the classification phase is and the com-   , where corresponds to the number of edges present in the mesh and denotes the support of the classification operator. The progressive mesh algorithm is the only component with a non-linear complexity of . We believe that the results produced by our framework are of useful quality. We envision the following optimizations and extension on these techniques:</p><p>• Improved classification operators: one of the major difficulties encountered in the classification phase is to distinguish between high frequency noise and feature information, a well known problem in computer vision. We addressed this problem by constructing operators with adjustable support, which worked well in practice. However, we believe that further improvements could be obtained by mesh decomposition <ref type="bibr" target="#b6">[7]</ref>. • Improved skeletonizing operators: the quality of the results generated by the thinning algorithm could be improved by using the weights computed in the classification phase more aggressively. Currently, only a topological measure is used. The advantage of a topology-driven thinning algorithm is improved robustness at the cost of an inferior localization of the mesh features. • Improved interaction: the final goal of this project is, of course, to provide a sophisticated mesh analysis tool able to determine the optimal operators and most of the parameters autonomously, requiring only a few intuitive parameters from the users. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Overview of the feature extraction framework Support of the SOD classification operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Support of the ESOD operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>The BFP operator: a) Parameter plane. b) Intersection between the parameter plane and the mesh. c) Best fit polynomial fitted in parameter space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>The ABBFP operator: a) Parameter plane. b) Intersection between the parameter plane and the mesh. c) Two polynomials are fitted on both sides of e and the angle between their tangents at e is measured.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Classification operators applied to an optimized mesh: a) Input mesh. b) Result computed using the SOD operator. c) Result computed using the BFP operator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Condition 1 : 4 ) 2 :</head><label>142</label><figDesc>the weight of is larger than the upper bound of the hysteresis function: (Condition The weight of is larger than the lower bound of the hysteresis function and the set of neighboring edges contains a selected edge :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Classification operators applied to a highly detailed mesh: a) Input mesh. b) Result computed using the SOD operator. c) Result computed using the BFP operator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Hysteresis function for threshold values B l and B u Edges selected by the hysteresis function: a) Input mesh. b) Result generated using the parameters B u = 0.92, B l = 0.92. c) Result generated using the parameters B u = 0.96, B l = 0.92. d) Result generated using the parameters B u = 0.995, B l = 0.9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 depicts</head><label>10</label><figDesc>the result obtained by our patching algorithm. The algorithm is initialized with the set of edges displayed in figure 10.a. The insertion of edges according to the condition specified in this section yields the set of patches illustrated in figure 10.b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>void patchThinning(list&lt; int &gt; patch) { for all edges e in patch if (isBoundaryEdge(e) == true) edgeList.insert(e); while edgeList is not empty do { e = edgeList.front(); // Retrieve the first edge edgeList.pop_front(); // Remove it from the list if(belongsToPatch(e) == false) { removeFromPatch(e); edgeList.insert(newBoundaryEdges); } } }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Patch construction: a) Set of edges selected by the hysteresis function. b) Patches generated by the framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 11 :</head><label>11</label><figDesc>Thinning operator; selected edges marked as a bold polyline: a) Edge e is removable. b) Edge e is not removable, since it would disconnect the feature locally.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 12 :</head><label>12</label><figDesc>Mesh features generated by the thinning algorithm: a) The set of patches used to initialize the algorithm. b) The set of resulting mesh features.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>figure 14 which illustrates our multiresolution approach. A coarse mesh is computed from the input surface (figure 14.a) and its mesh features are computed using the techniques discussed in section 3 and 4 (figure 14.b). The set of mesh features</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 13 :</head><label>13</label><figDesc>Feature update masks; feature displayed as a thicker polyline: a) The new edge e is inserted into the feature. b) The new edge e is not inserted into the feature. c) The new edge e changes the shape of the feature locally.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 14 :</head><label>14</label><figDesc>Multiresolution mesh feature extraction: a) Full-resolution input mesh (34'834 vertices). b) Mesh features extracted from the base domain (3'483 vertices). c) Mesh features reconstructed from an intermediate representation (19'158 vertices). d) Full-resolution mesh features.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>As an example consider figure 17 depicting a geological model. The noise of the input surface can be eliminated either using standard fairing techniques (figure 17.b) or using feature-preserving fairing (figure 17.c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 15 :</head><label>15</label><figDesc>The features of the mannequin.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 16 :</head><label>16</label><figDesc>The features of the Stanford bunny.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 17 :</head><label>17</label><figDesc>Feature-preserving fairing: a) The input model. b) Smooth model generated by standard fairing. c) Smooth model generated by feature preserving fairing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 18 :</head><label>18</label><figDesc>Feature-preserving subdivision: a) The input mesh. b) Smooth surface generated by standard subdivision. c) Smooth surface generated by feature preserving subdivision.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research was made possible by grants from Schlumberger ATC, Austin, TX. The authors would like to thank Richard Hammerlsey and Karen Lu for many helpful discussions. Further thanks to Kuno Meyer and Philippe Zürcher who implemented parts of this framework.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Piecewise smooth subdivision surfaces with normal control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Biermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Proceedings</title>
		<editor>K. Akeley</editor>
		<imprint>
			<biblScope unit="page" from="113" to="120" />
			<date type="published" when="2000" />
			<publisher>ACM Press / ACM SIGGRAPH / Addison Wesley Longman</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A computational approach to edge detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Canny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI)</title>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="679" to="698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Anisotropic geometric diffusion in surface processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Clarenz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Diewald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 11th Ann. IEEE Visualization Conference (Vis) 2000</title>
		<meeting>of the 11th Ann. IEEE Visualization Conference (Vis) 2000</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Implicit fairing of irregular meshes using diffusion and curvature flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Series. ACM SIGGRAPH</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999-08" />
		</imprint>
	</monogr>
	<note>SIG-GRAPH &apos;99 Proceedings</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings, Annual Conference Series</title>
		<editor>T. Whitted</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="0" to="89791" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Addison-Wesley</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Woods</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Image Processing</title>
		<meeting><address><addrLine>Reading, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Eigenmeshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hubeli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-03" />
			<pubPlace>ETH Zurich</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multiresolution signal processing for meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Guskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;99 Proceedings</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999-08" />
		</imprint>
	</monogr>
	<note>Computer Graphics Proceedings</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Image segmentation techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shapiro</forename><surname>Haralick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applications of Artificial Intelligence II</title>
		<imprint>
			<date type="published" when="2011-04-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GRAPH 96 Conference Proceedings, Annual Conference Series</title>
		<editor>H. Rushmeier</editor>
		<meeting><address><addrLine>New Orleans, Louisiana</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="4" to="09" />
		</imprint>
	</monogr>
	<note>ACM SIGGRAPH</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fairing of non-manifolds for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hubeli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 11th Ann. IEEE Visualization Conference (Vis) 2000</title>
		<meeting>of the 11th Ann. IEEE Visualization Conference (Vis) 2000</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Snakes: Active contour models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Witkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Terzopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Conference on Computer Vision</title>
		<meeting>of IEEE Conference on Computer Vision<address><addrLine>London, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="8" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Interactive multi-resolution modeling on arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Campagna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vorsatz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer graphics: proceedings: SIGGRAPH 98 Conference proceedings</title>
		<editor>M. F. Cohen, editor</editor>
		<meeting><address><addrLine>New York, NY 10036, USA and Reading, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press and Addison Wesley</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="105" to="114" />
		</imprint>
	</monogr>
	<note>Computer Graphics -proceedings-1998</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">MAPS: Multiresolution adaptive parameterization of surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W F</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cowsar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer graphics: proceedings: SIGGRAPH 98 Conference proceedings</title>
		<editor>M. F. Cohen</editor>
		<meeting><address><addrLine>New York, NY 10036, USA and Reading, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press and Addison Wesley</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="95" to="104" />
		</imprint>
	</monogr>
	<note>Computer Graphicsproceedings-1998</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Smooth Subdivision Surfaces Based on Triangles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Loop</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
		<respStmt>
			<orgName>Utah University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multiresolution edge-detection techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="229" />
			<date type="published" when="1995-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Scale-space and edge detection using anisotropic diffusion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Perona</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Extraction of feature lines on triangulated surfaces using morphological operators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rossl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Smart Graphics, Proceedings of the 2000 AAAI Symposium</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="71" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;92 Proceedings)</title>
		<editor>E. E. Catmull</editor>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A signal processing approach to fair surface design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 95 Conference Proceedings, Annual Conference Series</title>
		<editor>R. Cook</editor>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="6" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Interactive multiresolution mesh editing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zorin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings, Annual Conference Series</title>
		<editor>T. Whitted</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="0" to="89791" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
