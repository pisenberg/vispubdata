<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Circular Incident Edge Lists : a Data Structure for Rendering Complex Unstructured Grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename><surname>Lévy</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Caumon</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stéphane</forename><surname>Conreaux</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Cavin</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">ISA (Inria Lorraine) Loria, rue du Jardin Botanique</orgName>
								<address>
									<postCode>54500</postCode>
									<settlement>Vandoeuvre</settlement>
									<country key="FR">FRANCE</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Circular Incident Edge Lists : a Data Structure for Rendering Complex Unstructured Grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Volume Rendering</term>
					<term>Iso-Surfaces</term>
					<term>Unstructured Grids</term>
					<term>Combinatorial Topology</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present the Circular Incident Edge Lists (CIEL), a new data structure and a high-performance algorithm for generating a series of iso-surfaces in a highly unstructured grid. Slicing-based volume rendering is also considered. The CIEL data structure represents all the combinatorial information of the grid, making it possible to optimize the classical propagation from local minima paradigm. The usual geometric structures are replaced by a more efficient combinatorial structure. An active edges list is maintained, and iteratively propagated from an iso-surface to the next one in a very efficient way. The intersected cells incident to each active edge are retrieved, and the intersection polygons are generated by circulating around their facets. This latter feature enables arbitrary irregular cells to be treated, such as those encountered in certain computational fluid dynamics (CFD) simulations. Since the CIEL data structure solely depends on the connections between the cells, it is possible to take into account dynamic changes in the geometry of the mesh and in property values, which only requires the sorted extrema list to be updated. Experiments have shown that our approach is significantly faster than classical methods. The major drawback of our method is its memory consumption, higher than most classical methods. However, experimental results show that it stays within a practical range.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivation</head><p>In numerical simulations, a physical phenomenon is represented by a differential equation discretized at the vertices of a mesh. Regular grids have been widely used, since their structure enables a direct access to their elements. Therefore, visualization algorithms are easier for this kind of grids. On the other hand, unstructured grids offer a higher flexibility in terms of the discretization and numerical scheme used to represent the phenomenon. Recent works in numerical simulations involve heterogeneous grids, where the elements can have an arbitrary number of facets, for instance, the computational fluid dynamics (CFD) methods developed by <ref type="bibr">Verma et. al. in</ref>  <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b19">20]</ref>, and the Natural Neighbor finite element <ref type="bibr" target="#b16">[17]</ref> used in <ref type="bibr" target="#b15">[16]</ref> both involve cells derived from a Voronoï diagram. These unstructured grids are known to be difficult to visualize, especially when interactivity is desired, since the natures, the sizes and shapes of the elements can be heterogeneous. Moreover, such CFD numerical simulations produce sets of several scalar fields, corresponding to the evolution of the phenomenon over a period of time, and it is desirable to be able to interactively browse the whole period of time.</p><p>In this paper, we present the Circular Incident Edge Lists (CIEL), a new data structure and algorithms that enable a series of iso-surfaces to be generated, and can also be used for direct volume rendering. By representing all the topological information contained in the grid, it is possible to replace the geometric tests, sorts and searches used in classical approaches by efficient traversals of a combinatorial data structure. This enables a faster response, and results in fast updates when the scalar field changes.</p><p>The paper is organized as follows: the remainder of the introduction is a review of existing visualization algorithms for unstructured grids, and the associated acceleration techniques. In Section 2, our algorithm is introduced, and we show how it can be used for both volume rendering and iso-surface visualization. Section 3 gives the details concerning the rendering and shading phase of the method. In Section 4, some images and timings are shown, obtained by applying our algorithm to various data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related work</head><p>As with most visualization problems, the visualization of unstructured grids consists in finding an order structuring the set of elements to be displayed. Depending on the space where this order is computed, these approaches can be classified into two main categories: screen-space and object-space methods.</p><p>In screen-space methods, or ray casting approaches, the image is basically constructed one pixel at a time. For each pixel, its color is computed by launching a ray through the pixel and accumulating the colors of the polyhedra traversed by the pixel <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b4">[5]</ref>. Several ways to accelerate this type of methods have been described. In <ref type="bibr" target="#b14">[15]</ref>, Silva et al. introduce the Lazy Sweep Algorithm, based on a spatial coherence of the grid. Another approach proposed in <ref type="bibr" target="#b21">[22]</ref> consists in computing the ray paths in object space, which allows to avoid complex ray intersection computations. The major drawback of screen-space methods is the fact that the computation time strongly depends on the image size.</p><p>In object-space methods, the cells of the grid are sorted (in depth order), then projected on the screen <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b3">[4]</ref>. Several approaches have been proposed to project the cells on the screen. In splatting approaches, a filter is applied to the cells when they are projected to the screen ( <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b23">[24]</ref>). In <ref type="bibr" target="#b26">[27]</ref>, an accurate method is proposed for meshes composed of linear or quadratic tetrahedra. In <ref type="bibr" target="#b22">[23]</ref>, a method to visualize shaded iso-surfaces is proposed, based on advanced frame buffer operations. In <ref type="bibr" target="#b12">[13]</ref>, the grid is re-sampled using a set of randomly distributed points, provided with an ellipsoid which approximates the anisotropy of the scalar field in their neighborhoods. Yagel et al. propose in <ref type="bibr" target="#b27">[28]</ref> to perform volume rendering by slicing a tetrahedral grid by a set of parallel planes. The method proposed here is also a slicing-based approach, where coherency between two consecutive slices is taken into account by propagating over the topology of the mesh. To optimize the computations, all the approaches mentioned above use data structures representing different spaces, corresponding respectively to the geometry, the values (i.e. the scalar field to represent) or the topology (i.e., the combinatorial information) of the grid :</p><p>• geometrical space: Wilhelms et. al. propose to use Octrees in <ref type="bibr" target="#b24">[25]</ref>. In <ref type="bibr" target="#b27">[28]</ref> and <ref type="bibr" target="#b22">[23]</ref>, an active edges list is maintained thanks to a sorted list of vertices. Silva proposes in <ref type="bibr" target="#b14">[15]</ref> the Lazy Sweep method, a ray-casting algorithm accelerated thanks to several levels of data structures (two vertices heaps and an active edges list). We show further in this paper how topological information can efficiently replace these data structures for our purpose.</p><p>• value space: The two-dimensional span space structuring the set of cells by their minimum and maximum property values is used in <ref type="bibr" target="#b10">[11]</ref>. Similarly, interval trees are proposed in <ref type="bibr" target="#b2">[3]</ref>. In <ref type="bibr" target="#b0">[1]</ref>, the contour seeds method is presented, where a particular set of cells is used as seeds to compute iso-surfaces.</p><p>• combinatorial data structures: The second step of the contour seeds approach mentioned above consists in using the connections between the cells of the mesh for traversing an iso-surface (see also <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>). Since our goal is to generate a series of iso-surfaces, it is suitable to exploit the coherency between two consecutive iso-surfaces, which is not taken into account by those approaches. Our method can efficiently propagate from one iso-surface to the next one, by traversing our combinatorial CIEL data structure. This is more efficient than using a sorted list of edges as in <ref type="bibr" target="#b27">[28]</ref>. In <ref type="bibr" target="#b7">[8]</ref>, a data structure is introduced, made of a graph connecting the local extrema, where each arc stores the list of cells it traverses. The preprocessing times reported to construct this data structure show that it is not suitable in a dynamic environment, where the scalar fields change. Our approach only requires a sorted list of local minima, which can be updated very efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">TOPOLOGICALLY BASED INCREMEN-TAL ISO-SURFACES GENERATION</head><p>The idea developed in this section consists in making an optimum use of the grid topology to compute a set of intersections incrementally. Our CIEL data structure provides all the information required by the algorithm. The computed intersections can be a set of slices perpendicular to a given axis, in the case of slicing-based volume rendering, or a set of iso-surfaces. Before giving a detailed description of our data structures and algorithms, we first give an outline. Then, our topologically-based incremental intersection algorithm will be described in depth. We will then show how to display the intersection polygons computed by this algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">General Idea</head><p>The slicing-based approach to volume rendering and the problem of visualizing a set of iso-value surfaces can be considered to be two particular instances of the same problem: given a mesh with values ν attached to its vertices, and given a value ν0, find the isosurface defined by ν = ν0. If ν refers to a property, then this means finding an iso-value in the mesh, and if ν is the z coordinate in screen-space, this corresponds to computing a slice parallel to the screen. Slicing-based volume rendering requires a large number of slices to be computed, and it may be suitable to display a set of iso-surfaces rather than a single one. We will then suppose in what follows that the intersections should be computed for a series of values of ν, ranging from νmin to νmax, and spaced by a distance ∆ν. For large meshes, the naive algorithm will lead to high computation times, preventing the algorithm from being used in an interactive environment. Even with a contour seeds and mesh propagation approach <ref type="bibr" target="#b0">[1]</ref>, the coherence between two consecutive slices is not taken into account. We propose here to maintain the list of edges having an intersection with the iso-surface under consideration. This active edges list is then updated by using the topology of the mesh, which is more efficient than using a sorted list of segments as in <ref type="bibr" target="#b27">[28]</ref>. The method is outlined in Algorithm 1, where an edge intersected by the iso-surface is referred to as an active edge. In this algorithm, stepping from ν to ν + ∆ν means removing the edges that are not intersected anymore from the active edges list, and adding the newly intersected edges to it. It will be shown in the next sextion how this can be done, by using the topology of the mesh and the underlying order structuring it. As shown in <ref type="figure" target="#fig_0">Figure 1</ref>-A, it is easy to retrieve the active polyhedra given the active edges, by "turning around" them. Therefore the extra cost of maintaining an active polyhedra list can be avoided. For a given polyhedron, it is well known (see, e.g., <ref type="bibr" target="#b1">[2]</ref>) that the intersection polygon can be obtained by "turning around" the faces of the polygon (see <ref type="figure" target="#fig_0">Figure 1</ref>-B). Classical approaches use a pre-computed table of the different possible  <ref type="figure">Figure A</ref>). An half-edge also has a pointer mate polyhedron enabling the adjacent polyhedron to be retrieved ( <ref type="figure">Figure B</ref>). In addition, one half-edge per edge starting from the same vertex appears in a circular linked list implemented by the next around vertex pointer ( <ref type="figure">Figure C</ref>).</p><p>cases, created off-line. Our approach enables to compute the intersection polygon on the fly, which makes it possible to treat arbitrary cells, encountered in the highly heterogeneous grids used in recent research on computational fluid dynamics. Moreover, using our CIEL combinatorial representation of the grid, the iso-surface can be efficiently constructed from a single active edges list, whereas other approaches require several levels of dynamic data structures (heaps, active cells lists, . . . ).</p><p>The problem of ambiguities encountered with this kind of approach will be discussed further in the paper. What follows is a more detailed description of the algorithm, that will be introduced by successive refinements. The data structures on which the algorithm acts will be first described.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data Structure and Algorithms</head><p>Our CIEL data structure is depicted in <ref type="figure" target="#fig_1">Figures 2 and 3</ref> (using C-like notations). As in DCEL <ref type="bibr" target="#b8">[9]</ref> and in classical Half-edge representations <ref type="bibr" target="#b11">[12]</ref>, CIEL is structured around the notion of oriented half-edge. In addition, CIEL provides operators for finding all half-edges incident to a given vertex <ref type="figure" target="#fig_1">(Figure 2</ref>-C), which will be used by our topological propagation algorithm. As shown in <ref type="figure" target="#fig_1">Figure 2</ref>-A, each half-edge points to its successor next around face in the face, and has a pointer mate face designating the opposite half-edge of the adjacent face within the same polyhedron. The pointer mate polyhedron refers to the opposite half-edge in the adjacent polyhedron <ref type="figure" target="#fig_1">(Figure 2-B)</ref>. In order to efficiently update the active edges list we use, the pointer  Using this data structure, it is then possible to implement the active edges list algorithm (Algorithm 2), using the two functions update active edges and draw polyhedra around edge described below. What follows focuses on update active edges, enabling the active edges list to be kept up to date when ν is incremented. The mesh is used as an optimizing data-structure to update the active edges list between two consecutive slices. Since the considered meshes can be non-convex, and since the contoured properties may have local minima, it is necessary to take these minima into account in the algorithm (see <ref type="figure" target="#fig_3">Figure 4</ref>). Koyamada et. al. propose in <ref type="bibr" target="#b9">[10]</ref> to check local extremum points to avoid missing the disjoint parts of spherical slices. In the method proposed in <ref type="bibr" target="#b7">[8]</ref>, the set of local minima is structured in a graph, where each arc is provided with the list of cells it intersects. Our approach only requires a sorted list of local minima, which is much faster to recompute when the scalar field changes. The remaining information is provided to the algorithm by the CIEL data structure, which solely depends on the connections of the cells, and therefore does not need to be updated if the values or the geometry of the grid change.</p><p>A locally minimum vertex is a vertex such that its value ν is smaller than the values of its neighbors. These vertices can be detected in O(k.n) time, where n denotes the total number of vertices, and where k is the average number of neighbors of a vertex. They are then sorted by increasing value of ν, which takes O(m. log(m)), where m denotes the number of minima. Note that in most cases, m is much smaller than n. Moreover, this pre-processing has to be done only once in the case of iso-values, and it has to be done once per frame if the grid is volume-rendered using slices parallel to the screen. It is also possible to compute slices perpendicular to the axes of a local (x, y, z) basis of the grid, and select the axis which is the "most perpendicular" to the screen. This enables us to avoid transforming the vertices of the grid from world to screen coordinates, and this allows to pre-compute the minimum lists in the six directions (x+, x−, y+, y−, z+, z−).</p><p>We now outline the algorithm updating the active edges list. A detailed implementation and some explanations will be then given.  <ref type="figure">Figure A</ref>, and the shaded polygon between C1 and C2 in <ref type="figure">Figure B</ref>. Local minima (v3 in <ref type="figure">Figures A and B)</ref> are also taken into account.</p><p>Incremental iso-surfaces generation:</p><p>1. insert the edges starting from each minimum vertex passed by the current iso-ν.</p><p>2. update the active edges list by propagating along the topology of the mesh.</p><p>Using the data structures introduced above, these two steps can be implemented as follows:</p><p>The first step, which takes the minima into account, is straightforward to implement. In the second step, when an edge becomes inactive, the idea consists in replacing the newly inactive edge with the active edges starting by its second extremity. The list of the potential successors of an active edge can be easily traversed by using the next around vertex pointer. <ref type="figure" target="#fig_3">Figure 4</ref>-A shows a simple example in 2D, where ν is the x coordinate. In this figure, when stepping from the cutting plane P1 to P2, the edge e1 is not active anymore, and is replaced by its successors e2 and e3. The edge e4 is not inserted, since it does not point in the right direction (i.e., x is smaller at v2 than at v1). <ref type="figure" target="#fig_3">Figure 4</ref>-B shows the algorithm used to generate a series of iso-contours for a contoured ν property, attached to the vertices of the mesh. In this example, the successors of the edge e1 are the edges e2,e3 and e4. The edge e5 is not a successor of e1 since ν is smaller at v2 than it is at v1. The algorithm needs to take into account small polyhedra that may be skipped by a slice, as the shaded triangle and quadrilateron shown in <ref type="figure" target="#fig_3">Figure 4</ref>-A. For instance, the successors of the edge e5 are e6 and e7, which are not edges connected to e5. This problem is dealt with by appending the successors of an edge at the end of the active edges list, while the list is traversed. This means a newly inserted active edge is reconsidered in a further iteration of the loop on the active edges. It is therefore removed from the active edges list and replaced by its successors if it was skipped by the current iso-ν.</p><p>Using this algorithm, it is possible to efficiently compute the list of active edges and compute the intersection for each of them. For each active edge, the (x, y, z) coordinates, the property value and gradient are linearly interpolated from the two vertices of the segment. Then, it is possible to implement the idea of "turning around" the active edges and the intersected polyhedra, as in <ref type="figure" target="#fig_0">Figure  1</ref>. The corresponding algorithm is given below: In these algorithms, the functions begin polygon, end polygon and vertex refer to the graphic library (for instance OpenGL). The term "isect . . . " corresponds to the information computed at the intersection (geometry, property value and gradient). This information is linearly interpolated by the compute intersection function. The active edges list makes it possible to call this function only for the edges known to be intersected, and also enables the active polyhedra to be traversed for the drawing phase. Note that the halfedges are marked when they are traversed, to avoid drawing the same intersection polygon several times. At that point, it should be mentioned that the algorithm does not take into account ambiguities when used for iso-surfaces extraction. Ambiguities occur when the same polygon intersects the iso-surface more than twice. Such polyhedra can be easily detected during a pre-processing phase, and marked. Then, during the rendering phase, it is possible to apply a disambiguation method to those polyhedra, such as using the gradient in the polyhedron to choose the most likely iso-surface <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b17">18]</ref>. Since these gradients are computed for the shading (see the next section), they are available for disambiguation as well. Most ambiguities where more easily solved by normalizing all coordinates in an "integer space", then forcing the grid values (geometry and properties) to be even and slicing coordinates to be odd, thus avoiding the case where an iso-ν passes exactly through a vertex of the grid. Other ambiguities have been seldom encountered in our experiments, (statistics are given in the results section) thus we have not taken them into account in our system, since our goal was efficiency rather than precision. The next section gives more details concerning the way the intersection polygons are drawn, and describes a simple method to approximate gradients in an arbitrary polyhedral grid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RENDERING</head><p>In order to implement volume rendering, by using a graphic API such as OpenGL, it is possible to use the "blending" functionalities to make the graphic hardware combine the different slices while they are drawn in back-to-front order. In each intersection polygon, red, green, blue and transparency values (R,G,B,α) can be efficiently interpolated and combined with the color previously stored in the frame buffer, thus approximating the volume rendering integral. Interpolating property values rather than colors yields a more precise result, but as pointed out by Yagel et al. in <ref type="bibr" target="#b27">[28]</ref>, OpenGL does not implement blending in colormap mode. However, the same effect can be obtained by using 1D textures, which means interpolating a single texture coordinate rather than (R,G,B,α) values.</p><p>Shading is another technique that can improve the visual perception of the volume, by improving the perception of the shapes and relative positions of heterogeneities. It is also useful to enhance the visual aspect of iso-surfaces. Shading requires a normal vector to be specified at each vertex of the polygons passed to the graphic library. For an iso-surface, the normal vector is given by the gradient gradν of the property ν. In a (linear) tetrahedra, the components [a, b, c] of the gradient are constant, and given by:</p><formula xml:id="formula_0">                 ν(x, y, z) = a.x + b.y + c.z + d    x0 y0 z0 1 x1 y1 z1 1 x2 y2 z2 1 x3 y3 z3 1    .    a b c d    =    ν0 ν1 ν2 ν3    denoted A.X = B (1)</formula><p>where (νi)i=0,1,2,3 and (xi, yi, zi)i=0,1,2,3 denote the values of the property and the coordinates at the four vertices of the tetrahedron respectively. Similarly to what is commonly done for shading surfaces, the gradient at a given vertex is set to the average of the gradients at all the tetrahedra sharing this vertex, weighted by their volumes. In a general polyhedral grid, an arbitrary polyhedron may have more than four vertices, which means the system A.X = B is over-determined. For this reason, we propose to approximate the gradient in a least squares sense. The least-square system is A t A.X = A t B, and the (approximated) gradient [ã,b,c] is then given by  </p><formula xml:id="formula_1">   x 2 i x i .y i x i .z i x i x i .y i y 2 i y i .z i y i x i .z i y i .z i z 2 i z i x i y i z i 1      ã b c d    =    x i .ν i y i .ν i z i .ν i ν i   </formula><p>(2) In practice, the so-obtained gradient gives visually acceptable results, as soon as the variability of the property is small enough as compared to the density of the mesh, which corresponds to the well known law of Nyquist for digital sampling. Note that the related computations only need to be performed once at initialization time, or when the property values change. These two techniques (1D textures and least-squares gradient shading) have been both used to generate the images shown in the results section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Datasets</head><p>We have used several data-sets to test our approach (see <ref type="table" target="#tab_4">Table 1</ref>). The first three data sets are hexaedral grids (see <ref type="figure" target="#fig_4">Figure 5</ref>). The ARBEN data set is a tetrahedralized volume, and the STEH data set an irregular heterogeneous grid, made of arbitrary polyhedra (see <ref type="figure">Figure 6</ref>). Our slicing-based volume renderer and incremental isosurface visualization methods have been applied to these data sets, on a graphics workstation (900 Mhz Pentium III, 1Gb RAM). All the times appearing further have been measured on this workstation.   <ref type="table" target="#tab_3">Table 3</ref>: Loading and preprocessing times (in seconds). The first line corresponds to the times for loading the file and constructing the CIEL, which is performed at the same time. The second line corresponds to the times to approximate the gradients, and the last two lines to the times to create the sorted lists of minima for the geometry (in six directions) and for the property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Memory consumption</head><p>Memory consumption for the five data sets is summarized in <ref type="table" target="#tab_2">Table  2</ref>. Our data structure consumes more memory than classical ones. One of the reasons for this is the large number of pointers per halfedge, required by the traversal algorithms. The other reason is that the edge structure we use in our current representation reserves space for the intersections and an additional pointer implementing the active edges list. It should be possible to dynamically allocate such structures to represent the active edges list, therefore decreasing the overall memory consumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pre-processing</head><p>Loading and preprocessing times are given in <ref type="table" target="#tab_3">Table 3</ref>. Our CIEL data structure can be efficiently constructed, by an algorithm operating in linear complexity (Appendix A). Once the CIEL is constructed, the sorted lists of local minima are constructed. For box-aligned volume rendering, we construct six   sorted lists, corresponding to the six possible slicing directions (X+, X−, Y +, Y −, Z+, Z−) ("geometry local minima" line in the table). For iso-surfaces rendering, the list of the property local minima is constructed ("property local minima" line in the table). Note that when property values are modified, no additional data structure updating is necessary for volume rendering, and isosurfaces rendering only requires the sorted list of local minima to be updated. <ref type="table" target="#tab_8">Table 4</ref> shows the timing results when using our approach for volume rendering. For each data set, the reported times comprise the naive algorithm (that does not use the active edges list, but still use the topology to "turn around" the intersected edges). Box-aligned volume rendering consists in using planes parallel to the local coordinates of the object. The axis which is the more perpendicular to the screen axis is used for slicing. This makes it possible to use the pre-computed lists of local minima corresponding to the six possible slicing directions (X+, X−, Y +, Y −, Z+, Z−). Times are also given for the higher quality screen-aligned slicing approach, which requires more time since the coordinates needs to be evaluated on the fly (by using a scalar product), and since the sorted list of local minima needs to be computed for each image. However, only the boundary vertices need to be traversed, since an interior vertex cannot correspond to a geometric local minimum. In table 5, timings for iso-surface generations are displayed. For the same number of iso-surfaces, the algorithm requires more time than when operating in slicing mode, since the topology of the iso-contour is often more complex than the intersection of the whole grid with a plane. The last line indicates the time needed to propagate an iso-surface from the previous one. This enables the user to interactively change the contoured value. As far as ambiguities are concerned, most of them have been handled by forcing the geometry and property values to be even numbers, and the slices to have odd coordinates. The remaining potential ambiguous polygons are then detected by counting the local extrema in each polygon of the grid. The percentage of potentially ambiguous polygons is less than 2 percent for all the data sets we have tested. We think that, given these experiments, it is not worth adding a disambiguation method, but as previously mentioned in Section 3, it is easy to introduce one in the algorithm if necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rendering</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSIONS</head><p>Our topologically based incremental algorithm seems to be well suited to the visualization of unstructured grids in an interactive environment. As compared with other methods, besides its ability to treat more general grids (arbitrary convex polyhedra, multiple connected components, concavities and voids), the execution times obtained by our algorithm with the standard "blunt fin" and "oxygen post" data sets are significantly faster than those reported in <ref type="bibr" target="#b27">[28]</ref>.</p><p>Compared with the lazy sweep algorithm <ref type="bibr" target="#b14">[15]</ref>, our method is also based on an active edges list, but geometrical data structures are replaced with more efficient combinatorial ones, and rather than sweeping sideways, it sweeps back to front. This makes it possible to use the coherency between two successive slices, and stepping from one slice to the next one is performed in a time proportional to the number of elements in the slice (assuming a continuous variation of the cell sizes). Making use of this coherency would have been difficult with the contour seeds method <ref type="bibr" target="#b0">[1]</ref>, which sweeps sideways within an iso-surface.</p><p>The algorithm is compact and easy to implement, its kernel is given in extenso in the paper, and the whole code consists of less than 2000 lines of C++ code. The genericity of the algorithms makes it possible to use C++ templates, so that the same code can be used to display a set of shaded iso-surfaces, their meshes or an alpha-blended slice for volume rendering.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A: Given an edge known to be intersected, all the polyhedra around that edge are intersected as well. B: Starting from an intersected edge in a given polyhedron, it is possible to retrieve all the intersections by "turning around" the faces of the polyhedron;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>The notion of half-edge (white-headed arrows) plays a central role in the CIEL data structure. Each half-edge has a pointer to its successor next around face in the polygon, and a pointer mate face to an half-edge of the adjacent polygon (black-headed arrows in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Vertex, Edge and HalfEdge Data Structures next around vertex, allows the algorithm to efficiently traverse the list of half-edges starting from a given vertex (Figure 2-C).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>ABFigure 4 :</head><label>4</label><figDesc>The algorithm computes a series of slices (A) or iso-surfaces (B) incrementally, by maintaining a list of active edges. Small cells are taken into account, even if they are skipped by the slicing surfaces, such as the shaded triangle and quadrilateron between P2 and P3 in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Volume rendering of the blunt-fin grid, and iso-surfaces in the oxygen post</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Algorithm 2</head><label>2</label><figDesc>Updating the active edges list</figDesc><table><row><cell>update active edges:</cell></row><row><cell>// Step 1: insert edges starting from a crossed minima</cell></row><row><cell>while sorted minimum[minimum index].ν &lt; ν</cell></row><row><cell>and minimum index &lt; number of minima</cell></row><row><cell>half-edge succ ← sorted minimum[minimum index].half edge</cell></row><row><cell>do</cell></row><row><cell>succ.edge.is active ← true</cell></row><row><cell>append succ to active edges</cell></row><row><cell>succ ← succ.next around vertex</cell></row><row><cell>while succ = sorted minimum[minimum index].half edge</cell></row><row><cell>minimum index ← minimum index + 1</cell></row><row><cell>end while</cell></row><row><cell>// Step 2: topology-driven propagation</cell></row><row><cell>for each half-edge h in active edges</cell></row><row><cell>if h.vertex.ν &lt; ν // h is not active anymore</cell></row><row><cell>h.edge.is active ← false</cell></row><row><cell>remove succ from active edges</cell></row><row><cell>half-edge succ ← h</cell></row><row><cell>do</cell></row><row><cell>// test whether succ property values increase</cell></row><row><cell>// and is not active already.</cell></row><row><cell>if succ.vertex.ν &gt; h.vertex.ν</cell></row><row><cell>and not succ.edge.is active</cell></row><row><cell>succ.edge.is active ← true</cell></row><row><cell>append succ to active edges</cell></row><row><cell>// note that succ will be reconsidered</cell></row><row><cell>// /quad in further loop iterations</cell></row><row><cell>end if</cell></row><row><cell>succ ← succ.next around vertex</cell></row><row><cell>while succ = h</cell></row><row><cell>end if</cell></row><row><cell>end for</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Algorithm 3 while not cur</head><label>3</label><figDesc>Incremental iso-surfaces generation Drawing intersections around an active edge in face.edge.is active cur in face.is marked ← true cur in face ← cur in face.mate face while cur in face = cur end polygon end if cur ← cur.mate face.mate polyhedron while cur = start</figDesc><table><row><cell>incremental iso surfaces:</cell></row><row><cell>ν ← νmin</cell></row><row><cell>active edges ← ∅</cell></row><row><cell>minimum index ← 0</cell></row><row><cell>while ν &lt; νmax</cell></row><row><cell>update active edges</cell></row><row><cell>for all half-edge h in active edges</cell></row><row><cell>compute intersection(h.edge)</cell></row><row><cell>end for</cell></row><row><cell>for all half-edge h in active edges</cell></row><row><cell>draw polyhedra around edge(h)</cell></row><row><cell>end for</cell></row><row><cell>for all half-edge h in active edges</cell></row><row><cell>half-edge cur ← h</cell></row><row><cell>do</cell></row><row><cell>cur.is marked ← false</cell></row><row><cell>cur ← cur.mate face</cell></row><row><cell>cur.is marked ← false</cell></row><row><cell>cur ← cur.mate polyhedron</cell></row><row><cell>while cur = h</cell></row><row><cell>end for</cell></row><row><cell>ν ← ν + ∆ν</cell></row><row><cell>end while</cell></row><row><cell>Algorithm 4 draw polyhedra around edge(half-edge start):</cell></row><row><cell>half-edge cur ← start</cell></row><row><cell>do // iterate on polyhedra around edge</cell></row><row><cell>if not cur.is marked</cell></row><row><cell>begin polygon</cell></row><row><cell>half-edge cur in face ← cur</cell></row><row><cell>do // iterate on faces around polyhedron</cell></row><row><cell>cur in face.is marked ← true</cell></row><row><cell>vertex(cur in face.edge.isect . . . )</cell></row><row><cell>do // iterate on edges around face</cell></row><row><cell>cur in face ←</cell></row><row><cell>cur in face.next around face</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>List of the datasets used for testing. For each data set, the number of vertices, edges, polyhedra and half-edges is indicated</figDesc><table><row><cell></cell><cell>blunt</cell><cell>oxygen</cell><cell>launch</cell><cell cols="2">ARBEN STEH</cell></row><row><cell></cell><cell>fin</cell><cell>post</cell><cell>vehicle</cell><cell></cell><cell></cell></row><row><cell>v</cell><cell>40960</cell><cell>109744</cell><cell>205920</cell><cell>18802</cell><cell>95376</cell></row><row><cell>e</cell><cell cols="2">119296 322012</cell><cell>606708</cell><cell>106700</cell><cell>219076</cell></row><row><cell>p</cell><cell>37479</cell><cell>102675</cell><cell>195054</cell><cell>77255</cell><cell>36835</cell></row><row><cell cols="5">he 811416 2464200 4681296 92760</cell><cell>1326600</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 :</head><label>2</label><figDesc>Memory consumption (in Megabytes) for the data structures</figDesc><table><row><cell></cell><cell cols="3">blunt oxygen launch</cell><cell cols="2">ARBEN STEH</cell></row><row><cell></cell><cell>fin</cell><cell>post</cell><cell>vehicle</cell><cell></cell><cell></cell></row><row><cell>loading +</cell><cell>4.33</cell><cell>11.86</cell><cell>23.85</cell><cell>7.43</cell><cell>8.95</cell></row><row><cell>CIEL constr.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>gradients</cell><cell>0.58</cell><cell>1.59</cell><cell>3</cell><cell>0.92</cell><cell>0.73</cell></row><row><cell>g. loc. min.</cell><cell>0.20</cell><cell>0.54</cell><cell>0.98</cell><cell>0.05</cell><cell>0.32</cell></row><row><cell>p. loc. min.</cell><cell>0.03</cell><cell>0.07</cell><cell>0.22</cell><cell>0.01</cell><cell>0.05</cell></row><row><cell>total</cell><cell>5.14</cell><cell>14.06</cell><cell>28.06</cell><cell>8.41</cell><cell>10.05</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Volume Rendering results for the five data sets. 100 slices are generated, and shading is enabled. The result is computed using the naive algorithm, the boxaligned slicing and the higher quality screen-aligned slicing. All the times are given in seconds.</figDesc><table><row><cell>number of</cell><cell cols="3">blunt oxygen launch</cell><cell cols="2">ARBEN STEH</cell></row><row><cell>iso-surfaces</cell><cell>fin</cell><cell>post</cell><cell>vehicle</cell><cell></cell><cell></cell></row><row><cell>50</cell><cell>0.91</cell><cell>2.47</cell><cell>1.82</cell><cell>0.82</cell><cell>0.51</cell></row><row><cell>100</cell><cell>1.58</cell><cell>3.59</cell><cell>3.33</cell><cell>1.65</cell><cell>0.94</cell></row><row><cell cols="2">1 (propagate) 0.15</cell><cell>0.24</cell><cell>0.22</cell><cell>0.16</cell><cell>0.05</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 5 :</head><label>5</label><figDesc>Shaded Iso-surfaces results for the five data sets. All the times are given in seconds.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors want to thank the members of the Gocad research consortium 1 , for their support and their CFD grids. Thanks to the NASA for their publicly available data sets 2 .</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A CIEL CONSTRUCTION ALGORITHM</head><p>The input of the algorithm is an array of vertices and an array of polyhedra, where each polyhedron is an array of faces, and each face an array of vertices indices. This type of file format is commonly used in CFD applications. From this data, the CIEL data structure is constructed in O(k.n) by the algorithm outlined below, where n denotes the number of polyhedra, and k =f .v.ē is the product of the average number of faces per cellf times the average number of vertices per facev times the average number of edges incident to a vertexē (for an hexaedral grid, k = 96, for a tetrahedral grid, k = 192). Note that if the vertices of each polyhedron are provided as independent (x, y, z) coordinates instead of vertices indices, co-located vertices need to be retrieved using a geometric search structure, and then the algorithm operates in O(n. log(n)). As can be seen in Algorithm 5, the construction algorithm makes use of the incident edges lists while they are constructed. Due to space consideration, the complete algorithm could not be given here, and will be described in depth in a future paper. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 5 Outline of the CIEL construction algorithm</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast isocontouring for improved interactivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 symposium on Volume visualization</title>
		<meeting>the 1996 symposium on Volume visualization</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Polygonalization of implicit surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bloomenthal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="53" to="60" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Speeding up isosurface extraction using interval trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paola</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Scopigno</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fast polyhedral cell sorting for interactive rendering of unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">João</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cláudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
		<idno>1067-7055</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="369" to="376" />
			<date type="published" when="1999-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Raycasting of non regularly structured volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Frühauf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="303" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The mesh propagation algorithm for isosurface construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Howie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">H</forename><surname>Blake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="65" to="74" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automatic isosurface propagation using an extrema graph and sorted boundart cell lists</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="319" to="327" />
			<date type="published" when="1995-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Designing a data structure for polyhedral surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kettner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Symposium on Computational Geometry</title>
		<meeting>the 14th ACM Symposium on Computational Geometry</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast generation of spherical slicing surfaces for irregular volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Visual Computer</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="166" to="175" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using the span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yarden</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="1996-03" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">An Introduction to Solid Modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mäntylä</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Computer Science Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Splatting of non rectilinear volumes through stochastic resampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoyang</forename><surname>Mao</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1996-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The lazy sweep ray casting algorithm for rendering irregular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cláudio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">S B</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mitchell</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Natural neighbor galerkin methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sukumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">Yu</forename><surname>Semenov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">V</forename><surname>Belikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. J. for Numerical Methods in Engineering</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Natural neighbor finite elements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Traversoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Hydraulic Enginnering Software, Hyfrosoft Proceedings</title>
		<imprint>
			<publisher>Computational Mechanics Publications</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="291" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Corrigendum: Topological considerations in isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>0730-0301</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="307" to="308" />
			<date type="published" when="1995-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Topological considerations in isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>0730-0301</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="337" to="375" />
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Two-and three-dimensional flexible grids for reservoir simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Aziz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th European Conference on the Mathematics of Oil Recovery (ECMOR)</title>
		<meeting>the 5th European Conference on the Mathematics of Oil Recovery (ECMOR)</meeting>
		<imprint>
			<date type="published" when="1996-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A control volume scheme for flexible grids in reservoir simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Aziz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPE 37999. Proceedings, SPE Reservoir Simulation Symposium</title>
		<imprint>
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Accelerating techniques in volume rendering of irregular data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen-Cheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding-Hong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">En-Hua</forename><surname>Wu</surname></persName>
		</author>
		<idno>0097-8493</idno>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="295" />
			<date type="published" when="1997-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficiently using graphics hardware in volume rendering applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
		<idno>ISBN 0-89791-999-8</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98<address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Direct volume rendering of curvilinear volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Judy</forename><surname>Challinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="41" to="47" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<idno>0730-0301</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hierarchical and parallelizable direct volume rendering for irregular and multiple grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><forename type="middle">P</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Tarantino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Gibbs</surname></persName>
		</author>
		<idno>0-89791-864-9</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A high accuracy volume renderer for unstructured data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clifford</forename><forename type="middle">M</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stein</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="54" />
			<date type="published" when="1998-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Hardware assisted volume rendering of unstructured grids by incremental slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">M</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asish</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Po-Wen</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naeem</forename><surname>Shareef</surname></persName>
		</author>
		<idno>0-89791-741-3</idno>
	</analytic>
	<monogr>
		<title level="m">Volume Visualization Symposium</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="55" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m">iso-surfaces in the &quot;oxygen post&quot; and volume rendering of the</title>
		<imprint/>
	</monogr>
	<note>blunt fin&quot; vortices in the &quot;blunt fin&quot; (volume rendering and iso-surfaces</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
