<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Obvious: A Meta-Toolkit to Encapsulate Information Visualization Toolkits -One Toolkit to Bind Them All</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Daniel</forename><surname>Fekete</surname></persName>
							<email>jean-daniel.fekete@inria.fr</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Baudel</surname></persName>
							<email>baudelth@fr.ibm.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">INRIA Pierre-Luc Hémery † INRIA</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">IBM Jo Wood § City University</orgName>
								<address>
									<settlement>London</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Obvious: A Meta-Toolkit to Encapsulate Information Visualization Toolkits -One Toolkit to Bind Them All</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.11 [Software]: Software Architectures-Data abstraction</term>
					<term>D.2.13 [Software]: Reusable Software-Domain engineering</term>
					<term>K.6.3 [Software]: Software Management-Software process</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This article describes &quot;Obvious&quot;: a meta-toolkit that abstracts and encapsulates information visualization toolkits implemented in the Java language. It intends to unify their use and postpone the choice of which concrete toolkit(s) to use later-on in the development of visual analytics applications. We also report on the lessons we have learned when wrapping popular toolkits with Obvious, namely Prefuse, the InfoVis Toolkit, partly Improvise, JUNG and other data management libraries. We show several examples on the uses of Obvious, how the different toolkits can be combined, for instance sharing their data models. We also show how Weka and Rapid-Miner, two popular machine-learning toolkits, have been wrapped with Obvious and can be used directly with all the other wrapped toolkits. We expect Obvious to start a co-evolution process: Obvious is meant to evolve when more components of Information Visualization systems will become consensual. It is also designed to help information visualization systems adhere to the best practices to provide a higher level of interoperability and leverage the domain of visual analytics.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Over the past few years, several information visualization (InfoVis) toolkits have flourished in various languages such as Java <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b38">41]</ref>, C++ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>, Flash/Flex <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b22">23]</ref> or JavaScript with HTML5 <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b10">11]</ref> to name a few. When starting a visual analytics (VA) project, the choice of the toolkit is a major initial decision and the resulting proliferation of toolkits can be confusing for VA software developers who know that an inappropriate choice can lead to unanticipated limitations during the development of the application.</p><p>Historically, this proliferation of toolkits can be explained by several factors: each created toolkit addresses a specific set of problems, is designed with a specific application domain in mind, or simply offers different tradeoffs. However, it results in dispersion in terms of capabilities since each toolkit has unique and useful techniques for visualization and interaction. For example, the Prefuse <ref type="bibr" target="#b24">[25]</ref> and JUNG <ref type="bibr" target="#b31">[33]</ref> toolkits offer several graph layout algorithms whereas Improvise <ref type="bibr" target="#b38">[41]</ref> supports very sophisticated coordinated views with limited graph capabilities.</p><p>The choice of an InfoVis toolkit should be made early in the software development process because it affects not only the visualization techniques but also the data structure to work with. For an application dealing with small quantities of data, copying data from one structure to another is possible in interactive time but not for VA applications that usually manage data sets too large to be duplicated at all. Therefore, most data-management and analysis will be made on data structures compatible with the visualization and tied to the visualization toolkit.</p><p>Once the choice is made, any missing components have to be added specifically to the toolkit: if a special data manager is required (e.g., reading a particular data format), it has to be implemented specifically for the data structure managed by the toolkit. Any analysis not supported by the toolkit requires the authoring or adaptation of analytical toolkit components. Likewise, if visualization techniques are required that are not supported by the chosen toolkit they must be added, creating a strong dependency that usually prevents changes of toolkit later-on in the development.</p><p>The effort required by one application to implement the missing components cannot easily be reused in other applications that are based on another toolkit. Therefore, important resources are wasted for the re-implementation of data converters, analysis modules, and visualization techniques.</p><p>To address this proliferation problem, this article introduces Obvious: a meta-toolkit that abstracts and encapsulates InfoVis toolkits implemented in the Java language as a way to unify their use and postpone the choice of which concrete toolkit(s) to use later-on in the development process. Obvious is mainly targeted at VA software developers, but also library or toolkits developers if they want to promote sharing of data managers, converters, or algorithms not restricted to one toolkit. This article presents three contributions:</p><p>1. it describes the design and implementations of Obvious, 2. it reports some lessons learned when wrapping existing toolkits with Obvious, and 3. it presents rationales for the social process we started and want to follow for the future of Obvious. The main benefits offered by Obvious are:</p><p>1. it improves the reusability of code and components; 2. it improves the interoperability of code, data models and visualizations; 3. it defers the choice of which concrete toolkits to use to a later stage of the VA development; 4. it enforces a better separation of concerns in VA applications so that the data models can be specified independently of the visualizations and views; 5. it allows toolkit and library developers to easily integrate their tool into the rich environment of Obvious-compatible systems; 6. it clarifies issues with notification and allows VA to scale up using a standard architecture; and 7. it specifies a set of interfaces and a stable vocabulary which simplifies learning. The article is organized as follows: in section 3, after the related work section, we describe the design of Obvious. Section 4 reports on the wrapping of several toolkits and components with Obvious. Section 5 shows examples of Obvious in action to assess its usefulness. Section 6 discusses the social process we have used and how we envision the evolution of Obvious before concluding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IEEE Symposium on Visual Analytics Science and Technology</head><p>October 23 -28, Providence, Rhode Island, USA 978-1-4673-0013-1/11/$26.00 ©2011 IEEE </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Obvious is a set of interfaces and extension classes for wrapping around existing InfoVis toolkits. It generalizes and extends the standard architecture as defined in the InfoVis reference model to try to abstract all the existing implementations. In this section, we list some major existing toolkits and explain what they share and how they differ. In the second section, we describe the most common standardization processes for software systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Visualization Toolkits</head><p>Pretty much all existing InfoVis toolkits follow the InfoVis reference model initially specified by Ed Chi and refined by Card, Mackinlay and Shneiderman <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref> and has been described as a design pattern in <ref type="bibr" target="#b23">[24]</ref>. The model defines three stages: DataSet or Data Tables, Visualization or Visual Structure, and View ( <ref type="figure" target="#fig_0">Figure 1</ref>). One of its main benefits is that it explicitly represents interaction, in contrast to older visualization: models. Several articles have described the concrete design of an InfoVis toolkit. We report here on the common and the specific parts.</p><p>The InfoVis Toolkit (IVTK) <ref type="bibr" target="#b15">[16]</ref> implements an in-memory database manager where data is organized in columns, contrary to most persistent relational databases, to improve the memory footprint, to allow addition of new attributes that are needed to manage the interaction (e.g., selection or filtering), and to hold attributes computed on demand; the main challenge being the support of interactive performance for rendering and dynamic queries with a small memory footprint. The visual structure is managed using a monolithic architecture <ref type="bibr" target="#b5">[6]</ref>: each visualization technique is implemented as a specific class (e.g., ScatterPlotVisualization, Parallel-CoordinatesVisualization, or TreeVisualization) that performs the mapping between the data set and the graphic items to render. Finally, the view component is the same for each of the visual structures and takes care of scrolling, zooming, and overlaying magic lenses (e.g. Fisheye or Magic Lenses). A notification mechanism implements the communication between the data tables and the visual structures: each time a data table is modified, it notifies all the registered handlers of the details of the modification. The interaction is managed by Interactor objects that are associated with the visual structures; the views are generic and forward interaction managements to the Interactors. One specific feature provided by IVTK is layering: visualizations can be stacked on top of each others. Composite visualizations are useful to build complex visualizations by breaking them into simple parts. For example, node-link diagrams are split into links managed as one layer and nodes as another. Magic lenses and Fisheyes are also managed as layers on top of other visualizations.</p><p>Prefuse <ref type="bibr" target="#b24">[25]</ref> also relies on an in-memory database with notifications but implements the visual structure using an extension of the data model <ref type="table" target="#tab_3">(a visual table is derived from a data table)</ref>. It then transforms the data into a polylithic graphic structure whereas all the other toolkits use a monolithic architecture. In a polylithic architecture, there is only one component in charge of all the visual structures. A visualization object is responsible of managing a visual structure: it contains visual tables that augment data tables with graphic attributes (shape, color, etc.). Visualizations are in charge of computing the layout (assigning a position and shape to visual items), the graphic attributes, and animations. Visualizations use a Renderer object to actually display visual items. Users can control which renderer is used depending on the visualization, and the object itself. In Prefuse, data managers, visual managers and views are generic, offering a clean interface to the application programmer. However, as noted by Bederson et al. <ref type="bibr" target="#b5">[6]</ref>, polylithic toolkits have a steeper learning curve than monolithic ones because the polylithic components do not work out of the box, they always need to be configured. To address this issue, Prefuse comes with code samples that show how to do the initial setup.</p><p>Building upon their experience in the Prefuse toolkit <ref type="bibr" target="#b24">[25]</ref>, Heer and Agrawala <ref type="bibr" target="#b23">[24]</ref> have derived software design patterns that are common to InfoVis applications, and toolkits.</p><p>Improvise <ref type="bibr" target="#b38">[41]</ref> relies on an in-memory database with notification that is row-oriented and its visual structures are monolithic. The main characteristic of Improvise lies in its management of coordinated views. To achieve this aim, it relies on several design patterns not supported by Prefuse; compared to the other InfoVis toolkits, it adds a coordination component that is central and extends the notification mechanism implemented by IVTK or Prefuse.</p><p>Discovery <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref> shares most of its characteristics with Prefuse: it uses an in-memory, column-oriented database and a polylithic graphic model. Its two main features are (1) the absence of a scene graph, replaced by a dataflow pipeline made of short operations called functors that render directly from the data-model, and (2) a deferred notification strategy to allow data editing.</p><p>Other InfoVis toolkits can mostly be described using the four toolkits above, even if they use a different programming language. Tulip <ref type="bibr" target="#b0">[1]</ref> is a graph-oriented toolkit programmed in C++ that uses data tables for vertices and edges, like IVTK and Prefuse. It implements several complex graph layout algorithms and uses OpenGL for its rendering, but the conceptual architecture is table-based and monolithic. Therefore, InfoVis toolkits share a global organization: they all implement an in-memory database with two variants (row-based or column-based), a visual structure with two variants (monolithic or polylithic), and several specific features. Even if some choices made by toolkits designers were carefully decided, others were probably made without being aware of alternatives. Combining the best possible features for a next-generation toolkit might be tempting but there are still tradeoffs that cannot be solved. For example, the power of coordinated and linked views offered by Improvise comes at the cost of maintaining caches that should be flushed when the data change so more research is needed to maintain linked and coordinated views on dynamic data.</p><p>There are also lower-level toolkits that can be used to build VA applications. Two popular families are graphics libraries and graph libraries, which we discuss next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graphics Libraries</head><p>VA applications can manage their own data structure and take care of the mapping from data to visualization on their own. At this point, they can use scene-graphs or direct-graphics libraries.</p><p>Scene-Graph toolkits can manage the visual structure and view as described in the reference model. They are focused on computer graphics and interaction: they only deal with the visual structure and view. Piccolo and Jazz <ref type="bibr" target="#b5">[6]</ref> are popular 2D scene-graph managers that have been used to create several information visualization applications (e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b32">35]</ref>.) An early version of Piccolo has also been used as graphics engine for the Cytoscape graph visualization system <ref type="bibr" target="#b34">[37]</ref> but dropped for performance reasons.</p><p>High-performance InfoVis applications use scene-graph optimization techniques to speed-up the rendering of scenes. Tulip <ref type="bibr" target="#b0">[1]</ref> and Gephi <ref type="bibr" target="#b1">[2]</ref> maintain a spatial indexing structure to avoid rendering objects that are not visible.</p><p>Although scene-graph technologies are mature and used in a wide variety of graphics applications such as games, virtual-reality applications and scientific visualization systems, they are not always adequate for InfoVis systems because they require the explicit specification of geometry and graphic attributes for each displayed objects. Very often, InfoVis can quickly compute graphic attributes and even geometry from data attributes. For example, the position of an item using a scatter-plot visualization is computed using a simple affine transformation the data attributes using the x and y dimensions. There is no need to store the computed values when computing them on the fly is cheap. The same is true for color and other properties. In contrast, copying and storing this information is costly in terms of time and memory. Direct-graphics libraries such as Processing or OpenGL can also be used to implement the visualization techniques.</p><p>Still, when separating the data-model from the visual model, scene-graph managers offer more flexibility than information visualization systems for complex graphics and sophisticated interaction. This is why several InfoVis systems still use them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Graph Libraries</head><p>While most table-based visualization toolkits rely on an in-memory database, several graph-based visualization systems manage their data-structures using a model inspired from graph theory where topology is the main focus and data associated with graph entities is less important. This is the case for the JUNG library <ref type="bibr" target="#b31">[33]</ref> or the Boost Graph Library (BGL) <ref type="bibr" target="#b35">[38]</ref>, as well as for the graph library used by Cytoscape <ref type="bibr" target="#b34">[37]</ref>.</p><p>These libraries support graphs as set of vertices and edges (the topological entities) that can be associated with arbitrary data. This data is just stored by the graph entities as a convenience for the application: the library does not implement any integrity check between data and graph entities. In contrast, IVTK, Prefuse, and Tulip maintain a close consistency between graphs and data tables: removing a data table entry associated with a graph entity (vertex or edge) also removes the entity from the graph structure.</p><p>Thus, there is no clear consensus on how a graph data structure should be managed internally; the design choices are quite different depending on the communities such as graph theory, information visualization, database, and semantic web.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Standardization Processes</head><p>Standardization is a well established habit in the software community; several standardization models have been used in the past and these models tend to evolve due to the accelerating pace of software development taking place nowadays.</p><p>According to Wikipedia: "The goals of standardization can be to help with independence of single suppliers (commoditization), compatibility, interoperability, safety, repeatability, or quality." The goals raised in this article are well among them: compatibility, interoperability, and quality. Standardization roughly follows four models:</p><p>1. Specified by national and international organization such as the International Organization for Standardization (e.g. ISO, ASCII), 2. Specified by a private or public consortium (e.g. the Unicode Consortium, the OMG, and the World Wide Web Consortium (W3C)). Closer to the InfoVis community, "The Open Geospatial Consortium" [34] which is an international industry consortium of companies, government agencies, and universities participating in a consensus process to develop publicly available interface standards for geospatial data. 3. Community-driven: looser groups can be faster and allow for more experiments than formal standardization bodies or consortia. Communities, such as the Boost Community [9]designing libraries for the ISO C++ language -experiment, develop, and document software that sometimes become part of formal ISO standards. The Java Community Process [28] plays a similar role for the Java language and programming environment.</p><p>Standards specified by established organizations go through a formal process that take substantial time; usually years. On the other side, ad-hoc organizations such as consortia can issue standards or recommendations faster. In particular, the W3C or community-drive consortia define stages for their "recommendations" (the name for standard issued by the W3C) before they are considered final. In all cases, these organizations establish steering committees to control the processes and require substantial involvements from many organizations to achieve standards. 4. De facto: At the other extreme are the application domains</p><p>where one system becomes the standard. For example, in scientific visualization, VTK <ref type="bibr" target="#b25">[26]</ref> has become, in the latest years, the de facto standard toolkit: it is used by researchers and practitioners, and newer solutions are getting integrated quickly into VTK. This is possible when either a system reaches a certain level of popularity -such as Microsoft Word for Word Processors -or when the quality and features of the system are unmatched -such as VTK. At the current stage, InfoVis toolkits are not understood wellenough to start a formal standardization process. It seems that one toolkit will not become a de facto standard due to the stretch in scope and capabilities of existing toolkits. Two models remain: consortium-driven or community driven. Obvious has started as a community-driven initiative. It is up to the community to decide how it wants to coordinate its software development for better compatibility, interoperability, and quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DESIGN</head><p>Beyond proposing a unifying design, perhaps the most novel approach of Obvious is the process carried-out to obtain this design. The project started through a sequence of InfoVis Infrastructure workshops <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18]</ref>, during which consensus was reached that:</p><p>1. many common traits were shared among toolkits, often in slightly incompatible ways, 2. much mundane work was needlessly repeated across toolkits, and 3. creating a unified toolkit from scratch was out of reach due to varying needs and design tradeoffs. Based on those observations, an attempt was made for a new approach of defining a "meta-toolkit" that would allow sharing and implementing cross-compatible services (such as data readers); then design and implement, one by one, the components on which common consensus could be reached for a unified design.</p><p>For this reason, Obvious is organized according to the InfoVis reference model in three main packages: data, visualization, and view. It provides utility classes in the "util" package in addition. Next, efforts were focused on designing a consensual data model. For now, the data model is the most elaborated and successful part of the framework.</p><p>Resting on these foundation modules (data, visualization, view), some actual service packages have been developed, such as data readers, writers, and conversions to provide immediate utility to both the Obvious users and the toolkit designers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data Model</head><p>This section describes the data model used in Obvious to represent and manipulate data structures. This model has been specified for the most part during the 2008 workshop <ref type="bibr" target="#b16">[17]</ref> as consensus has emerged, tediously but rapidly on its central and annex features.</p><p>The Obvious data model ( <ref type="figure" target="#fig_1">Figure 2</ref>) is centered on the proxy tuple design pattern exposed in <ref type="bibr" target="#b23">[24]</ref>. Obvious adopts this design pattern to offer high extensibility and good usability. Among all the patterns introduced in <ref type="bibr" target="#b23">[24]</ref>, the proxy tuple pattern enables both as it encompasses graphs in an object-oriented manner -many developers are used to manipulation of object oriented graphs --and as it unifies the data model around the same standard structure (tuples and tables). In our data model, tuples are standards elements of all structures: tables are composed of tuples and graphs/trees are implemented as networks, i.e., graphs built around two tables one for the nodes and the other for the edges.</p><p>This model is instantiated via factories that allow cross-toolkit interoperable data structure instantiation. With those factories, it is possible to instantiate tables and networks from a schema or from an existing object from a targeted Obvious implementation (e.g. a Prefuse table or a JUNG graph). This also provides the possibility to use parameters to provide more arguments used in targeted toolkits. For example, in the Prefuse implementation of Obvious, parameters are used to specify the source and target node columns for a graph in an edge table.</p><p>In addition to data access, our data model provides 3 optional, interoperable, features: introspection, batch editing, and notification. Those features are not found in all target toolkit implementations and, thus, sometimes had to be emulated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Introspection</head><p>Introspection means the capability of a program to inspect its own content. In the context of the data model it means mostly that objects expose their own schema explicitly and allow manipulating it as a full-fledged object. As an improvement over <ref type="bibr" target="#b23">[24]</ref>, our data model uses a meta-circular schema design (the schema is itself a table) instead of a column object, that does not exist in Obvious. Schemas have been introduced because they are an efficient an elegant mean to gather all meta-data for the columns of a table in one unique structure, allowing easy table and network instantiations with a factory. The main use of introspection in a toolkit, though, is to enable generic implementation of a variety of side services as varied as generic persistence, undo/redo, and universal object editors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Batch Editing</head><p>Batch editing means that one or many cells in a data model may be edited at the same time. This happens when the toolkit manages analytical columns (e.g. computing the centrality of each vertex in a network), with selection and dynamic queries if their effect is reported to a data column or simply if a user wants to change values interactively, either in the data table or through a visualization by direct manipulation <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Notification</head><p>All the popular InfoVis toolkits (e.g. <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b3">4]</ref>) implement notification using the "Observer" pattern from <ref type="bibr" target="#b18">[19]</ref> to propagate information about changes affecting the data model. This pattern specifies two roles: Observable and Observer; in our case, data models are Observables meaning that they allow Observers to register and be notified when they are changed. During the design of Obvious, we realized there were some variants in the way toolkits implemented this pattern. This is why the notification system  introduced in Obvious is designed to support a wide variety of notification models, even those not currently implemented in current toolkits but that will be required to scale. The notification system in Obvious is also based on the Observer design pattern with extensions to supports transaction and batch techniques usually found in database system. Combining Notification and batch editing raises a challenge: since one operation can affect a large amount of data, a flow of notifications concerning the same action will be generated. If each change is managed in isolation, the application can spend a large amount of time updating visual structures, e.g. recomputing a layout for each modified item. This typically leads to the application being unresponsive for a long time.</p><p>Thus, Obvious introduces a method to control the management of batch notifications: the beginEdit/endEdit mechanism. <ref type="figure">Figure</ref> 3 shows the sequence diagrams of the notification manager. Each time a data table is changed, the change is transmitted to the Observer with a call to the tableChanged method. This method takes several arguments describing the current event (affected Table, rows, columns, and operation type): this is the typical Observer pattern.</p><p>When the beginEdit method is called on an Obvious data table, the Observer's beginEdit method is called to start a batch editing transaction. Different strategies can be applied by the observer. A mode parameter allows the observer to select a specific strategy depending on the type of transaction (atomic or batched). Note that the observer will still receive a tableChanged call for each tuple modified. The observer is in charge of implementing a strategy to optimize atomic/batch edition. If it does not, the standard behavior will happen and batch editing will flood the observer -which is acceptable in some cases. The following strategies have already been developed in one or more Obvious implementations:</p><p>Lazy strategy after a beginEdit, the observer ignores all the tableChanged calls until the endEdit method is called; then, the observer's actions are performed e.g. a layout is recomputed.</p><p>Batch strategy after beginEdit, the observer buffers the information sent by tableChanged. When endEdit is called, the actions are performed on each of the buffered items. Note that buffering can be complicated when items are created, deleted or changed many times. The burden is left to the observer since this management can be heavily optimized depending on the action to perform.</p><p>Transaction strategy after beginEdit, the observer buffers the information sent by tableChanged. When endEdit is called, it first checks structural invariants (for example, no null value for a specific field) before performing its actions on the modified items.</p><p>The beginEdit/endEdit mechanism has been added to support batch editing and also database transactions. When the data model implementation relies on a transactional database, atomic and batch transactions will occur and notifications (e.g. implemented as database triggers) will arrive in batches. The semantic of Obvious notification handles this case correctly but the observer should be aware that the tableChanged method can be called much later than when the table is actually changed. This is the case for database atomic transactions: the actual notification is propagated after the end of the transaction when the database engine has done all the integrity checks.</p><p>In practice, the three strategies we have described have been sufficient so far to handle all the cases required inside toolkits. We performed experiments using MySQL and Oracle systems wrapped by Obvious with negligible overhead. Managing notifications using the batch or transaction strategies increased performance typically by a factor 100 compared to the "one notification per operation" strategy exposed by standard toolkits. The impact on performance is therefore substantial, in particular when managing dynamica very standard situation in VA applications that has not been well addressed in InfoVis so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.4">Other services</head><p>To leverage our core implementation and offer some immediately useful services to Obvious users, we have defined a utility package "obviousx", named in the same way as the Java extension package "javax". This package provides different kinds of utility classes for the Obvious data model. First, we have defined reader and writer interfaces allowing the creation of gateways between the Obvious data model and common data formats such as CSV and GraphML. It provides software developers a standard way to import and export data in Obvious whatever the underlying implementation of the data model is. In addition, for data providers, it simplifies their work because they only have to develop one reader and one writer to be compatible with a large number of toolkits.</p><p>With the same logic, obviousx provides compatibility classes to use with standard Java components such as a Java Table Model that allows the creation of a JTable from an Obvious table. Finally, obviousx also provides wrappers to map obvious data structures into common existing data structures (e.g. for Prefuse, IVTK, and Jung) to share data structures when using more than one data model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Visualization and View models</head><p>Unlike the data model, no consensus emerged concerning the Visualization and View models during the workshop <ref type="bibr" target="#b16">[17]</ref>; the main reason being the different approaches chosen among toolkits. One important issue is the monolithic vs. polylithic approach. Another one is related to tables vs. objects: some toolkits keep the visualization data in tables (e.g. Prefuse, IVTK, and Tulip) whereas others create objects for displaying (e.g. Improvise, Cytoscape) or nothing at all when there is a pipeline as in Discovery. So, more work is needed to design the abstractions required to wrap the different implementations. Further discussions and workshops will address the problem.</p><p>Still, Obvious provides a solution: it wraps visualizations into a black box with a small set of methods and -for the creation of these visualizations -it relies on a Factory design pattern <ref type="bibr" target="#b18">[19]</ref>. For example, creating a scatter-plot visualization from a data table requires the following lines: The variable "param" contains parameters to configure the visualization, here to specify which attribute will be used for the x and y axes.</p><p>With this mechanism, it looks as if Obvious were a monolithic toolkit but the actual implementation of the Obvious wrapper for a polylithic toolkit can easily translate a monolithic specification into a dedicated configuration for the underlying polylithic component. The code above will work for the Prefuse toolkit and return a polylithic component wrapped as an Obvious visualization and configured as a scatter-plot visualization.</p><p>If a developer needs a visualization component that does not exist in the default implementation (e.g. an IVTK time-series with a Prefuse-wrapped data table), the visualization can be created directly from a specified factory or from the Obvious class:</p><p>new IvtkTimeSeriesVis( table , null , " timeseries " , params)</p><p>An Obvious visualization works with any Obvious data model. The data model will be either wrapped to become compatible with the native model if the underlying implementations are different or unwrapped when the visualization and the data model are from the same implementation (e.g. Prefuse).</p><p>This mechanism avoids copying data from one structure to another, which is a crucial point for VA. Alternatively, Obvious also provides a default mechanism to quickly copy and synchronize data models when no wrapper has been defined for a specific toolkit. Current wrappers are lightweight, adding very little overhead to the system.</p><p>At this point, the application developer can choose one of the existing visualizations from one of the wrapped toolkits or decide to create a new one which can derive from one of the wrapped toolkits or be implemented from scratch. Obvious substantially increases the number of possible visualizations and toolkits to use and does not limit the developer in any way at this stage.</p><p>A View is simply specified as a black box implementing a simplified version of the camera pattern introduced in <ref type="bibr" target="#b23">[24]</ref> to support standard operations such as zoom and pan. Like the visualization interface, future workshops should enrich it when a more consensuses are reached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATIONS</head><p>This section describes the implementation of Obvious and points the lessons learned during implementations binding Obvious interfaces to wrappers around concrete toolkits. Each toolkit has its own design choices that are discussed in articles but some of the implications came to light when implementing the bindings, for example differences of interpretations of design patterns. We briefly describe the most important lessons here.</p><p>The core of Obvious is a small (40Kb) Java project <ref type="bibr" target="#b30">[32]</ref> managed by Maven <ref type="bibr" target="#b13">[14]</ref> to facilitate its deployment. It consists in 44 java files, 23 interfaces and 21 utility classes organized in 5 top-level packages: data, viz, view, util and impl. It has been designed to be small and lightweight. Therefore, the substantial parts are in each concrete toolkit binding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Prefuse</head><p>Prefuse was the first binding implemented because its architecture is, by design, very close to Obvious. The binding implements all the abstractions described in the core Obvious interfaces for all data models, visualizations and views.</p><p>For the visualization, Prefuse is currently the only polylithic In-foVis toolkit with a binding for Obvious. As explained in 3.2, Obvious does not offer a visualization abstraction for polylithic components. Thus, Obvious provides components pre-configured for well know visualization techniques such as scatter-plots or force directed graphs. Currently, if a software developer wants to visualize an Obvious table using a Prefuse visualization not offered in the Obvious visualization factory, the only requirement is to convert the data model to a Prefuse data table using an obvious component contained in the Prefuse binding.</p><p>Several interfaces defined by Obvious are based on a Prefuse concrete class. Therefore, Prefuse was used as a complete implementation of Obvious to check its model and syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">IVTK</head><p>Since IVTK is monolithic and follows the reference InfoVis model, its Obvious binding realizes all the interfaces for the data model, visualization and view introduced in Obvious. IVTK has monolithic visualizations, providing them simply consists in wrapping an Obvious visualization around their class and implementing a factory to create them by name.</p><p>However, the data model of IVTK differs from Obvious for trees and networks: in IVTK, the Graph interface is not a super-interface of the Tree interface. In addition, some data model classes are more specialized in IVTK than in Obvious. For example, tables can be described as static tables or dynamic tables. The binding was therefore complicated by these mismatches that needed a more complicated code than for Prefuse. Nevertheless, IVTK binding is operational and reliable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Improvise</head><p>The Obvious implementation based on Improvise only implements the data model part for tables. Even if Improvise is a monolithic toolkit, Obvious cannot directly bind Improvise visualization components because the toolkit does not expose its visualization pipeline publicly: Improvise components are intended to be complete black boxes. Addressing this problem would require some changes inside the current version of Improvise. In addition, Improvise does not support well dynamic data, which is a functionality intended to be in every obvious implementation. Providing a complete binding for Improvise in Obvious would require some changes in Improvise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">JDBC</head><p>JDBC is the standard Java interface to standard SQL databases. We wrapped JDBC in an Obvious data table to prove that Obvious can support a large variety of data model, not only models coming from InfoVis toolkits. JDBC was chosen because databases are frequently used as data sources for applications and since JDBC provides additional features not available in the toolkits data tables such as atomic and batched transactions. We used it to test the notification model introduced formerly. As expected, this implementation only supports the data model of Obvious.</p><p>Concretely, this implementation translates Obvious methods into SQL queries. For example, the data table "get" methods are implemented as SELECT queries, the "set" methods as UPDATE queries, the "add" methods as INSERT queries, and the "remove" methods as DELETE queries. Queries are written in standard SQL and several applications have been written to work with different DBMS such as MySQL and Oracle. In addition, for the notification system,  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">JUNG</head><p>JUNG is a graph library in Java that mainly manages the graph topology but associates arbitrary attributes with vertices and edges. Concretely, this implementation realizes all interfaces defined in Obvious, except for tables and schemas since these notions do not exist in JUNG. Schemas are mandatory in Obvious, so this implementation uses a default schema implementation from the Obvious core package. The network structure of Obvious is similar to JUNG's graph; therefore, the data model of JUNG was easy to wrap as an Obvious Network. Concerning the visualizations and views, JUNG provides monolithic visualizations. The Obvious implementation simply binds existing JUNG visualization components to Obvious visualizations. This implementation was the easiest to create since Obvious and JUNG share common hypotheses: for their data model (Obvious network and JUNG graph are equivalent) and JUNG and Obvious are both compatible with the monolithic approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Units tests</head><p>Obvious is specified using Java interfaces and some comments in the implementation files but without any formal specification of the precise behavior of the defined interfaces. To verify that all the implementations behave correctly and consistently, we have implemented Unit Tests: a suite of classes and methods aimed at testing all the methods of all the classes.</p><p>Currently, the tests are only defined on the data model of Obvious. The level of specification of Obvious visualizations and views is not sufficient to perform useful tests.</p><p>Unit tests need an implementation to work; they cannot test abstract classes or interfaces. Due to the similarities of Obvious and Prefuse, the Prefuse binding has been used to set up the unit tests for the data model of Obvious. They have then been moved to the core Obvious module to be usable by all the bindings. Unit tests allow authors of Obvious bindings to automatically test whether their implementation behaves in conformance with the intended semantics of Obvious. Also, authors are able to extend these existing tests in their own module to perform more advanced ones for their binding.</p><p>Concretely, unit tests have been defined with JUnit <ref type="bibr" target="#b36">[39]</ref> for the following interfaces: Schema (14 tests), <ref type="table" target="#tab_2">Table (11</ref>  With the exception of Improvise, all the toolkits we wanted to support are now available with Obvious. The extra code required for binding a concrete toolkit is quite modest compared to the toolkit itself and the overhead in time has always been negligible. <ref type="table" target="#tab_2">Table 1</ref> summarizes the footprint of the implemented Obvious modules and the services they support. At this point, Obvious is usable with a wide range of concrete implementations and we report on its uses in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION</head><p>Formally evaluating the effectiveness of a meta-toolkit for VA is complex. Arguably the most convincing method would require two groups of programmers of equivalent skills to implement the same set of VA programs with and without Obvious. Then, a judgment could be made from the time spent and the quality of the results. This methodology has been used to assess IVTK <ref type="bibr" target="#b15">[16]</ref> with students but is impractical for real VA applications that are more complex and would not fit the scope of student projects.</p><p>Another method -used to validate Prefuse <ref type="bibr" target="#b24">[25]</ref> -would be to re-implement complex VA applications using Obvious and assess the results, again in term of time and quality. This is what we have done and we report on our results here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Coding applications with Obvious</head><p>This section shows how Obvious can implement common applications in InfoVis such as the creation of a scatter-plot or of a network visualization. These examples explain how to combine Obvious components to build an application, how to create data structure and spot patterns to use. The first use-case concerns the coding of a network visualization with the Obvious-IVTK implementation and the second based on the coding of a scatter-plot by combining component from different Obvious implementations.</p><p>For both examples and more generally for every creation of an Obvious application, developers have to follow the following steps:</p><p>Step 1: creation of an Obvious data structure, either directly with a standard constructor or through a factory. Three ways exist to fill the data structure:</p><p>1. wrapping an existing data structure from a targeted toolkit as shown in the first example, 2. using an Obvious reader to load an Obvious structure from a well known file format (CSV, GraphML...) as shown in the second example, 3. using Obvious methods to directly manipulate the data structure (addRow, addNode, addEdge...); an example would be too long for this article.</p><p>Step 2: Creation of an Obvious visualization from the created data structure and additional parameters. This can be done directly with a class constructor or through a factory. The parameters allow customization of the Obvious monolithic components. As shown in the second example, it is possible to use the data structure from one Obvious implementation with a visualization from another.</p><p>Step 3: Creation of an Obvious view with the created visualization directly with a constructor or through a factory.        // Creates the parameter map for the monolithic object .  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Integration of Weka and RapidMiner</head><p>Weka <ref type="bibr" target="#b21">[22]</ref> and RapidMiner <ref type="bibr" target="#b29">[31]</ref> are suites of machine-learning algorithms and data structures widely used to design machinelearning applications. The obviousx package of Obvious supports two mechanisms to build the main data structure of Weka and RapidMiner from an Obvious <ref type="table" target="#tab_3">Table:</ref> • an Obvious This "Instances" can be used by all the machine-learning algorithms defined in Weka. Creating this wrapper took about three days to one developer who knew Obvious well but was discovering Weka and two for RapidMiner for the same developer.</p><p>This example demonstrates an important gain of Obvious: a toolkit with a binding in Obvious can immediately benefit from a substantial set of additional features, such as Weka and RapidMiner for advanced machine-learning capabilities and several format converters. Furthermore, Weka and RapidMiner provide rich extensions such as connecting to the R statistical environment <ref type="bibr" target="#b33">[36]</ref> that are now accessible from Obvious. Conversely, developers of new analysis algorithms could port them to use Obvious data structures so that they become usable by a substantial number of toolkits and application programmers to build VA systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">EdiDuplicate</head><p>The French National Institute of Research in Computer Science and Control (INRIA) maintains a repository called HAL-INRIA [21] to store, index and give access to its publications. Entering publications is a manual process done by researchers who make mistakes. These mistakes can result in duplicated authors, institutions, or articles. Thus, INRIA needs to clean the HAL database with tools that can detect potential duplicates and ask skilled users to resolve them. Currently, INRIA leaves that task to librarians with very primitive tools.</p><p>EdiDuplicate is a VA system designed to detect and merge duplicated entities in the HAL-INRIA publication database; it has been built with Obvious. It is an adaptation of the D-Dupe software <ref type="bibr" target="#b27">[29]</ref> with extensions to cover needs specific the HAL-INRIA database [21] to perform specific operations in a workflow.</p><p>Each time a new entity is created in the database, multiple similarity metrics are automatically computed between this entity and all the ones already in the database. When a user connects to the editing interface of EdiDuplicate, this information is loaded in an Obvious table and displayed, as shown on the left pane of <ref type="figure" target="#fig_14">Figure 4</ref> using a standard Java table. Each row refers to one pair of names and the columns contain the multiple similarity measures with a green-red color coding; the table can then be sorted according to any column order.</p><p>When a pair is selected by clicking on a row, a network view is created that visualize the neighborhood network of the pair of entities, as shown on the right of <ref type="figure" target="#fig_14">Figure 4</ref>. The neighborhood is computed from publication data: for a target entity, it contains all the entities already connected to it through co-authorship relations. This information helps the user decide if the pair of entities has to be merged. The application mainly combines Obvious components and Swing components (derived from Obvious structures). For the data model, an Obvious Network is used with the IVTK implementation of Obvious; the visualization and the view parts are also provided by this implementation. Building this application took less than a week.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">DBMS Caching Tables</head><p>We have extended the JDBC implementation of Obvious to allow caching and notification management directly from a table stored in a DBMS. Currently, this mechanism works with the Oracle and MySQL DBMSs. The Obvious data table component reads data on demand from a table in the DBMS, stores it in memory and serves it from memory while keeping a bidirectional link with the DBMS. When the DBMS table is modified from any application, a database trigger is invoked that notifies the Obvious table implementation that some rows are invalid. They are then flushed from memory and will be read again when the application needs them. The communication between the DBMS and the Obvious component is done through a fast network connection (UDP packets). Oracle provides a standard API to send UDP packets whereas we had to add an extension written in C to MySQL to support them (200 lines of C).</p><p>The cached tables are implemented using Obvious (different bindings have been used: Prefuse, IVTK, JDBC and JUNG). Several applications have been built around Obvious DBMS caching tables; one of them is presented in the next section. Cached tables can be used as an initial step to implementing out-of-core algorithms but the caching strategy will always need to be adapted to the algorithm. Again, that adaptation can be done later on when the algorithm already works on smaller datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Network Visualization on a Large Wall</head><p>INRIA shares with other institutions a Wall-Size display called WILD [42] made of 32 high-resolution 32" screens. Using Obvious, we have developed an application for visualizing co-authorship networks on WILD. WILD is made of 16 machines serving 2 screens each and connected to a gigabit Ethernet network.</p><p>Our application uses a client-server approach: the server program loads the network using Obvious, computes its layout and stores the result as a set of graphic primitives in a database table using an Obvious-JDBC data table. For each screen, one client program is launched that uses the DBMS caching data-structure to load its visible portion of the nodes and links, i.e., the area that is visible on the portion of the screen managed by the client.</p><p>An Oracle DBMS is used to store publications data in two tables: one for the authors (containing id and name) and one for the publications (containing pairs of publication id and author id).</p><p>Our application uses Obvious-Prefuse in the server and in the clients, with Obvious-caching data-structures. A polylithic architecture is particularly well suited to this kind client-server approach sharing the visualization through the network.</p><p>Since cached tables are synchronized with the DBMS, the whole pipeline is dynamic: when a data table containing the network is modified (e.g. a new author is added), it is reloaded by the server, the layout is recomputed by Prefuse and the visual table is stored in the DBMS. When the DBMS visual table is changed, the clients are notified and they reload and redisplay the content.</p><p>Designing the application boiled down to having a first version using Obvious-Prefuse in memory, then changing the data tables to use the JDBC caching, then changing the visualization to store its results in the database through an Obvious-JDBC table and then implementing the clients. A step-by-step development where the application logic can be tested first on a standard desktop computer and then deployed to a more specific setup.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Implementing a Cross-Toolkit Layout Component</head><p>We have also tested a more advanced usage scenario: devising a novel layout algorithm and using the Obvious toolkit to make it available in a variety of toolkits. This layout component is a generalized treemap algorithm. Its interface makes it easy to port as this algorithm takes as input a data model and renders using a Visitor design pattern <ref type="bibr" target="#b18">[19]</ref> to a renderer object, making it very convenient to implement across polylithic toolkits such as Prefuse or Discovery. Considering that the current visualization model is mostly targeted at enabling monolithic patterns, Obvious in its current state turns out to be of limited use for our purpose.</p><p>Still, we have found that the existing data model and utilities have made developing our layout algorithm on top of Obvious worthwhile: we could implement very easily a simple monolithic visualization and view instances, and relying on the default data model already saves us time in the development of our prototype, while we have the assurance that only minimal work may be needed to port our method to the toolkits targeted by Obvious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Conclusion</head><p>The examples described in this section assess an important strength of Obvious: it allows a clear separation of concerns in the development of VA applications with a small memory and performance footprint. The data model of the application can be chosen independently from the visualization components as long as all these components fit the Obvious model. From our experience, a large number of the VA application fit the Obvious model and they will benefit from the meta-toolkit in term of richness and extensibility.</p><p>Richness comes from the already large choice of visualizations and interaction techniques provided by the wrapped toolkits. Extensibility comes from the large choice of toolkits that can be used as basis for the implementation of novel visualizations and interaction techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FUTURE WORK 6.1 Extending Obvious Supported Features</head><p>Obvious aims at covering all the features of an InfoVis toolkit for which a consensual interface can be specified. Relying on a common reference model helps tremendously but falls short on some implementation design choices. Still, a few specific services have already been mentioned during workshops that could give rise to a shared implementation:</p><p>1. selection management: to implement cross-toolkit brushing and linking, 2. Mappings of data value to scalar value: this feature is used by all the visualizations to map data dimensions to screen coordinates, color gradients and many other visual attributes. Because the interface of such features is small and well understood, consensus is reachable, 3. visualization scale, tick-mark and tick-label management, 4. graph layout computation. While most of those features would be of high value and we feel consensus can be reached, we have not, as of yet, proposed unifying designs. The main reason is that while the core structure of those services is consensual, they rely on parts which are not yet consensual, such as the application architecture and more elaborated view, visualization and interaction models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Adding Additional Toolkits and Languages</head><p>Regarding porting Obvious to other languages, two competing approaches are being considered. One involves making the API as language neutral as possible; the other considers that widespread adoption is only possible on a particular platform and language if its idioms are respected.</p><p>With the first approach, a wished extension would consist in porting Obvious to other languages and platforms, such as C++, JavaScript and C#. Obvious has been designed to avoid using idioms too specific to Java so we believe it could be done without much difficulties. There would be at least two benefits: the availability of a meta-toolkit is these languages to wrap InfoVis toolkits, and the availability of a common application programmer's interface (API) for InfoVis that would simplify learning and spreading the best practices. Multi-language APIs already exist and are popular in recommendations of the W3C. For example, the Document Object Model API (DOM, see http://www.w3.org/ DOM/) used to manipulate HTML or XML documents has official bindings for Java and JavaScript and non-standard bindings for several of the major languages (http://www.w3.org/DOM/ Bindings) with slight variations to cope with the language idioms.</p><p>With the second approach, the Obvious design patterns should leverage the support platform/language conventions and blend as well as possible with its context. Interoperatbility -which is still strongly wished -should focus on communication formats and protocols rather than code similarity in the various languages.</p><p>A real-world test of how generalizable and unifying Obvious would be post-hoc integration with an industrial toolkit. For example, IBM ILOG JViews <ref type="bibr" target="#b26">[27]</ref> is a commercial monolithic toolkit and framework including data models, monolithic visualizations, views, a graph model, an extensive library of graph drawing algorithms. Interfacing JViews with Obvious would provide JViews users access to novel features brought by the research community, and open a venue for research results to make their way into commercial products.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Community Building</head><p>Perhaps the most novel experience we retain from Obvious is the community-driven process to reach consensus and realize a reference implementation. We intend to formalize this process, either through a formal consortium of with a less formal communitydriven process, depending on the response of the community.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Obvious and Other Visualizations</head><p>VA often needs to combine InfoVis with Scientific Visualization and/or GeoSpatial Visualization. These two domains are more mature than InfoVis for standardization: the Scientific Visualization community is converging towards using VTK <ref type="bibr" target="#b25">[26]</ref> as a de facto standard whereas the GeoSpatial Visualization community already has a mature GeoSpatial Consortium producing software <ref type="bibr">[34]</ref>.</p><p>Geometrical data structures are much less sophisticated in Info-Vis than in the two others visualization fields. Pre-computing complex geometries and maintaining them dynamically is a main concern in Scientific Visualization and GeoSpatial Visualization; not so much in InfoVis. Moreover, even if at the abstract level Scientific Visualization and GeoSpatial Visualization share this concern, at the implementation level; their geometrical structures are quite different, adding another level of complexity to the problem.</p><p>Currently, the state of the art in combining these visualizations is to put them side-by-side with coordinated interactions (brushing and linking, dynamic queries) <ref type="bibr" target="#b28">[30]</ref>. This kind of integration can be implemented by maintaining separate data structures, separate visualizations and views; coordination being done through ad-hoc item identifiers shared across the visualizations and acting as pivots. From a user-centered viewpoint, unifying the interactions would also improve the usability of mixed visualization applications.</p><p>Combining two or the three fields at the software infrastructure level will require more discussions and experiments between the communities and seems like a long-term goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>We have presented Obvious 1 , a meta-toolkit whose goal is to facilitate the development of Visual Analytics applications. Obvious provides concrete, immediate benefits to Visual Analytics application programmers: it improves reusability and interoperability of code and software components, and defers the choice of the which toolkit(s) to use to a later stage of the Visual Analytics application and provides bridges between tools instead of another competing toolkit. It also allows toolkit and library developers to integrate their tool into the rich environment of Obvious-compatible systems. It exposes programmers to state of the art design patterns as well as a wealth of convenience features. Overall, we believe it clarifies and simplifies the implementation of Visual Analytics system.</p><p>Obvious shall remain a work in progress by design, at least in the foreseeable future. All members of the Visual Analytics community are invited to contribute to its design, make it evolve, and of course to use it.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>The Information Visualization Reference Model<ref type="bibr" target="#b23">[24]</ref> </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Class diagram of the Obvious data model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Sequence diagram for the notification system</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Listing 1 : 5 .</head><label>15</label><figDesc>Creating a visualization using a Factory 1 Map params = new HashMap(); 2 params.put("x", "id" ); 3 params.put("y", "age" ); 4Visualization vis = VisualizationFactory . getInstance () createVisualization ( table , null , " scatterplot " , params);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>tests), Network (13 tests) and Tree (8 tests); all part of the Obvious core package. These tests have been systematically run for each new Obvious data model development: all presented implementations successfully passed those tests.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Listing 2 :</head><label>2</label><figDesc>Visualizing a graph with Obvious 1 // Creates the graph structure . First , set the factory to use ( ivtk ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2 //</head><label>2</label><figDesc>Then loads the native data structure , and get a factory instance .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>3 /</head><label>3</label><figDesc>/ Finally , calls the convenient method of the factory .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>the associated visualization using the 11 // factory for visualization . No predicates and extra 12 // parameters are given to the constructor .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>13 16 /</head><label>16</label><figDesc>Visualization vis = new IvtkVisualizationFactory ()<ref type="bibr" target="#b13">14</ref> . createVisualization (network, null , "network", null );15 / Creates the view. No predicates and extra parameters are given to // the constructor .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>18Listing 3 : 1 / 2 /</head><label>312</label><figDesc>View view = new IvtkObviousView(vis, null , "graphview", null );19 // Standard Java window creation 20 JFrame frame = new JFrame(); 21JScrollPane panel = new JScrollPane(view.getViewJComponent()); Combining different Obvious implementations to display a scatter-plot / Defines the data factory to use , / Obvious−Prefuse will be used for the data structures .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>5 / 6 // Obvious table 7</head><label>567</label><figDesc>/ Creates an Obvious CSV reader and loading an CSVImport csv = new CSVImport(new File("example.csv"), ' , ' ); 8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>11 Map&lt;String, 15 /</head><label>1115</label><figDesc>Object&gt; param = new HashMap&lt;String, Object&gt;(); 12 param.put("x", "id" ); // xfield 13 param.put("y", "age" ); // yfield 14 / Creates the visualization then the view. No predicates are given to 16 // the constructor .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>17</head><label></label><figDesc>Visualization vis = new IvtkScatterPlotVis ( table , null , " plot " , param); 18 19 View view = new IvtkObviousView(vis, null , " plot " , null ); 20 // Standard Java window creation 21 ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 4 :</head><label>4</label><figDesc>The EdiDuplicate application</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table Listener</head><label>Listener</label><figDesc></figDesc><table><row><cell>addRow(Tuple tuple)</cell></row><row><cell>tableChanged(...)</cell></row><row><cell>Change propagated</cell></row><row><cell>beginEdit(int mode)</cell></row><row><cell>addRow(Tuple tuple)</cell></row><row><cell>tableChanged(...)</cell></row><row><cell>Custom strategy</cell></row><row><cell>addRow(Tuple tuple)</cell></row><row><cell>tableChanged(...)</cell></row><row><cell>Custom strategy</cell></row><row><cell>endEdit(int mode)</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>table listeners compatible with transaction and batch strategies presented in 3.1.3 have been developed and help validate the Obvious notification model.</figDesc><table><row><cell>Bindings</cell><cell>obvious</cell><cell>obvious</cell><cell>obvious</cell><cell>Binding</cell><cell>Toolkit</cell></row><row><cell></cell><cell>.data</cell><cell>.vis</cell><cell>.view</cell><cell>Size</cell><cell>Size</cell></row><row><cell>Prefuse</cell><cell>10 classes</cell><cell>7 classes</cell><cell>2 classes</cell><cell>120KB</cell><cell>3.3MB</cell></row><row><cell></cell><cell>1235 lines</cell><cell>446 lines</cell><cell>94 lines</cell><cell></cell><cell></cell></row><row><cell>IVTK</cell><cell>6 classes</cell><cell>5 classes</cell><cell>1 class</cell><cell>115KB</cell><cell>10MB</cell></row><row><cell></cell><cell>1404 lines</cell><cell>460 lines</cell><cell>105 lines</cell><cell></cell><cell></cell></row><row><cell>Improvise</cell><cell>3 classes</cell><cell></cell><cell></cell><cell>27KB</cell><cell>5.7 MB</cell></row><row><cell></cell><cell>519 lines</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>JDBC</cell><cell>8 classes</cell><cell></cell><cell></cell><cell>75KB</cell><cell>3MB</cell></row><row><cell></cell><cell>1936 lines</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>JUNG</cell><cell>3 classes</cell><cell>1 class</cell><cell>2 classes</cell><cell>93KB</cell><cell>4.3MB</cell></row><row><cell></cell><cell>714 lines</cell><cell>139 lines</cell><cell>114 lines</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Footprint of Obvious bindings.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table table =</head><label>table</label><figDesc></figDesc><table><row><cell>csv . loadTable ();</cell></row><row><cell>9</cell></row><row><cell>10</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>table can be copied into a Weka or RapidMiner data table, which are data structures specially optimized for the fast execution of machine learning algorithms. With this approach, running-time is optimized but data is duplicated. • an Obvious table can be wrapped as a Weka or a RapidMiner data table: it then translates its methods calls into Obvious equivalents. With this approach, memory-footprint is optimized since data is not copied at the expense of speed. Both methods are equivalent in terms of lines of code and can be applied to the same machine learning algorithms from Weka and RapidMiner. For example, wrapping the table from the code sample 3 into a Weka structure requires the following line:</figDesc><table><row><cell></cell><cell>Listing 4: Wrapping an Obvious Table into Weka Instances</cell></row><row><cell>1</cell><cell>Instances inst = new ObviousWekaInstances(table, " Instances " );</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Obvious can be downloaded at: http://code.google.com/p/obvious</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors wish to thank the participants of the VisMaster Workshop on Visual Analytics Software Architecture: Fanny Chevalier, Christophe Favart, Jeffrey Heer, Joshua O'Madadhain, Harald Piringer, Danyel Fisher, Giueseppe Santucci, Mike Smoot, Martin Theus, and Chris Weaver. This work has been partially funded by the VisMaster Project <ref type="bibr" target="#b37">[40]</ref>.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tulip : A huge graph visualisation framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Auber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing Softwares, Mathematics and Visualization</title>
		<editor>P. Mutzel and M. Jünger</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="105" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Gephi: An open source software for exploring and manipulating networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bastian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heymann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jacomy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International AAAI Conference on Weblogs and Social Media</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visualisations compactes: une approche declarative pour la visualisation d&apos;information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Baudel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th Frenchspeaking conference on Human-computer interaction (Conference Francophone sur l&apos;Interaction Homme-Machine), IHM &apos;02</title>
		<meeting>the 14th Frenchspeaking conference on Human-computer interaction (Conference Francophone sur l&apos;Interaction Homme-Machine), IHM &apos;02<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="161" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Browsing through an information visualization design space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Baudel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI &apos;04 extended abstracts on Human factors in computing systems, CHI EA &apos;04</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">From information visualization to direct manipulation: extending a generic visualization framework for the interactive editing of large datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Baudel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th annual ACM symposium on User interface software and technology, UIST &apos;06</title>
		<meeting>the 19th annual ACM symposium on User interface software and technology, UIST &apos;06<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Toolkit design for interactive structured graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Grosjean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="535" to="546" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Javascript infovis toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename><surname>Belmonte</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Geneaquilts: A system for exploring large genealogies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bezerianos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Dragicevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bae</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1073" to="1081" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<ptr target="http://www.boost.org/.3" />
	</analytic>
	<monogr>
		<title level="j">Boost c++ libraries</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Borner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Herr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<ptr target="https://nwb.slis.indiana.edu/events/ivsi2007/" />
		<title level="m">workshop on information visualization software infrastructures</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Protovis: A graphical toolkit for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1121" to="1128" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Readings in information visualization: using vision to think</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An operator interaction framework for visualization systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">H</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Riedl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 IEEE Symposium on Information Visualization</title>
		<meeting>the 1998 IEEE Symposium on Information Visualization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Maven: The Definitive Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Company</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<pubPlace>O&apos;Reilly Media</pubPlace>
		</imprint>
	</monogr>
	<note>Inc., 1 edition</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Visual discovery and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="58" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The infovis toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualization</title>
		<meeting>the IEEE Symposium on Information Visualization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<ptr target="http://code.google.com/p/obvious/wiki/Motivation" />
		<title level="m">Vismaster workshop on visual analytics software architecture</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Borner</surname></persName>
		</author>
		<ptr target="http://vw.indiana.edu/ivsi2004/,Novem-ber2004.3" />
		<title level="m">workshop on information visualization software infrastructures</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Design patterns: elements of reusable object-oriented software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Addison-Wesley Professional</publisher>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Axiis open source data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gonzales</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vandaniker</surname></persName>
		</author>
		<ptr target="http://ww.axiis.org" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<ptr target="http://hal.inria.fr.8" />
		<title level="m">The hal iniria publication site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The weka data mining software: an update</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pfahringer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Reutemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">H</forename><surname>Witten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGKDD Explorations</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="10" to="18" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">flare data visualization for the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Software design patterns for information visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agrawala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="853" to="860" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Prefuse: a toolkit for interactive information visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Landay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI conference on Human factors in computing systems, CHI &apos;05</title>
		<meeting>the SIGCHI conference on Human factors in computing systems, CHI &apos;05<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
	<note>ACM. 1, 2, 4</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ibanez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cates</surname></persName>
		</author>
		<ptr target="http://www.itk.org/ItkSoftwareGuide.pdf" />
		<title level="m">The ITK Software Guide. Kitware, Inc. ISBN 1-930934-15-7</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Ilog visualization for java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ibm</surname></persName>
		</author>
		<ptr target="http://www-" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Interactive Entity Resolution in Relational Data: A Visual Analytic Tool and Its Evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bilgic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Licamele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="999" to="1014" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Interactive coordinated multiple-view visualization of biomechanical motion data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Keefe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ewert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1383" to="1390" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Yale: rapid prototyping for complex data mining tasks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Mierswa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wurst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klinkenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Euler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining, KDD &apos;06</title>
		<meeting>the 12th ACM SIGKDD international conference on Knowledge discovery and data mining, KDD &apos;06<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="935" to="940" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<ptr target="http://code.google.com/p/obvious.5" />
		<title level="m">Obvious source repository</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">The jung (java universal graph/network) framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>O'madadhain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-B</forename><surname>Boey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>UCI-ICS</publisher>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Spacetree: Supporting exploration in large node link tree, design evolution and empirical evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Grosjean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualization (InfoVis&apos;02), INFOVIS &apos;02</title>
		<meeting>the IEEE Symposium on Information Visualization (InfoVis&apos;02), INFOVIS &apos;02<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page">57</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Development Core</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Team</surname></persName>
		</author>
		<idno>3-900051-07-0. 7</idno>
		<imprint>
			<date type="published" when="2011" />
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cytoscape: a software environment for integrated models of biomolecular interaction networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shannon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Markiel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ozier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">S</forename><surname>Baliga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ramage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Amin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schwikowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ideker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2003-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">The Boost Graph Library: User Guide and Reference Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">G</forename><surname>Siek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L.-Q</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lumsdaine</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">An Informal Formal Method for Systematic JUnit Test Case Generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Stotts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lindsey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Antley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>D. Wells and L. A. Williams</editor>
		<imprint>
			<biblScope unit="volume">2418</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="131" to="143" />
			<date type="published" when="2002" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<ptr target="http://www.vismaster.eu.10" />
		<title level="m">Vismaster european fet-open coordination action project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Building highly-coordinated visualizations in improvise</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Weaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualization</title>
		<meeting>the IEEE Symposium on Information Visualization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
