<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Model and a System for Data-Parallel Program Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Wagner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Massachusetts at Amherst</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">Daniel</forename><surname>Bergeron</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of New Hampshire</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Model and a System for Data-Parallel Program Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Parallel program visualization and debugging require new techniques for gathering and displaying execution trace and profile data. Interaction with the program during execution is also required to facilitate parallel debugging. We discuss the dijkulties associated with runtime user/program interaction and how the data-parallel programming paradigm facilitates much more liberal runtime interaction than typical MIMD-based models. We present a model for data-parallel program visualization that addresses both data collection/interaction and visualization issues. We follow our model presentation with the design and implementation of a subset of our visualization model. We discuss our preliminary findings and propose fiture research directions.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Writing, debugging, optimizing, and understanding the runtime behavior of parallel programs is very difficult. Multiple threads of execution and interaction between the parallel processors turns even the most robust parallel trace data into an incomprehensible jigsaw puzzle. Graphical visualization is a powerful supplement to human perception and understanding <ref type="bibr">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref>. Through visualization we can make sense of large, interrelated, parallel program trace data sets, see trends, and evaluate algorithm behavior. Like any large complex data set, parallel trace data must be visualized using different displays that compare and contrast different aspects of program performance, such as communication usage, processor interaction, and idle time.</p><p>In addition to profile trace visualization, however, a visualization tool must provide both visualization displays and programmer/program interaction.</p><p>Debugging and trace visualization tools are a natural pairing for programming in a parallel environment. While trace visualization provides the programmer with an understanding of what is happening during execution, a parallel debugger gives the programmer the flexibility to probe single execution threads, peek at values, and make changes at a single node or across groups of processors simultaneously.</p><p>To address this need we have developed a model for data-parallel program visualization and debugging. There are three fundamental issues surrounding parallel program visualization and interactive parallel debugging: interaction with the program, visualization of trace data, and user/debugger interaction. The proper selection of a parallel programming paradigm is critical to resolving these issues. We discuss paradigm selection, visualization and debugging issues, and describe our model in the following pages. We also describe DPV, an experimental system that implements a subset of the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Parallel Programming Issues</head><p>Unlike sequential programs, parallel programs may lack localized or centralized control at any given point during program execution. This lack of deterministic synchronization makes profiling data difficult to collect and difficult to assemble for visualization. If data is obtained without synchronization, it must be ordered coherently prior to visualization. Ordering requires either a buffer between the visualization and execution activities, or the visualization of the data as a post-execution trace <ref type="bibr" target="#b3">[4]</ref>. Liberal synchronization of a parallel algorithm to allow coherent concurrent program visualization is also difficult because the behavior of the parallel algorithm can be changed by introducing communications or synchronization points that are not part of the given algorithm.</p><p>The choice of parallel programming paradigm can greatly facilitate, or hinder, attempts at concurrent visualization and debugging.</p><p>The two major architectures for parallel computing are multiple-instruction-multiple-data (MIMD) and single-instruction-multiple-data (SLMD). Analogous parallel programming models are called process-parallel (PP) and dataparallel (DP).</p><p>At the fine-grained end of the spectrum reside dataparallel language models implemented on SIMD computers. The DP/SIMD coupling is characterized by rigidly controlled interaction and communication, globally synchronous execution semantics, and deterministic behavior. At the other end of the spectrum lies the PP/MIMD coupling, which is characterized by loosely controlled interaction and communication between nodes, asynchronous execution semantics, and potentially non-deterministic behavior.</p><p>With properly defined semantics, data-parallel languages can be implemented on either SIMD or MIMD hardware <ref type="bibr" target="#b4">[5]</ref>. The current version of C* <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref> is a data-parallel language based on a hypothetical SPMD (single-program-multiple-data) architecture. C* programs feature the determinism of SIMD synchronous execution and the benefits of limited MIMD asynchronous execution. C* programs contain blocks of explicit parallelism where execution takes place asynchronously. We use the term parallel block to denote a block within a parallel context that contains no interactions between virtual processors. When the program counter enters or exits a parallel block, all processors are synchronized. Additionally, each instruction outside a parallel block that contains data dependencies or potential race conditions is performed with all processors in lock-step fashion, much like a traditional sequential program. While a parallel programmer may define a parallel context with the intent that all instructions within that context be executed in parallel, instructions that may cause interactions between processors result in synchronizations being inserted by the compiler. Our model and initial system are designed around the UNH implementation of C*.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Related Work</head><p>ParaGraph <ref type="bibr" target="#b7">[8]</ref> is a multipurpose tool for the post-execution visualization of parallel program trace data from a MIMD environment. It provides the programmer with several useful views and displays that can be selected interactively during visualization. Visualization can be paused, run in slow motion, or executed in single step mode by the programmer. ParaGraph relies on PICL <ref type="bibr" target="#b8">[9]</ref> to provide both portability and the execution trace. Because ParaGraph is implemented as a post-execution tool, it is completely ill-suited to interactive debugging or profiling.</p><p>Concurrent execution and visualization is particularly difficult using the MIMD model. Our choice of a language that guarantees DP semantics even on MIMD hardware is the critical decision that allows us to propose runtime interaction with the parallel program.</p><p>Xab <ref type="bibr">[lo]</ref> is a system for visualizing and debugging (non-concurrent) parallel applications in a heterogeneous PVM [l l] simulated environment. Unlike ParaGraph, Xab monitors program execution in a concurrent fashion, although the interaction is strictly one-way and process centered.</p><p>Prism <ref type="bibr">[ 12,</ref>131 is the closest approximation to our model. Prism is a commercial product that provides performance analysis, debugging, and data visualization tools for Connection Machine programs. Prism uses both GUI point-and-click and text-based command techniques to interact with the user. Program data visualization in Prism is achieved via a subset of tools called visualizers. Prism provides visualizers for text based browsing, simple colormap/grid representation, and more complex graphical representations using surfaces and vector plots. Visualization in Prism is viewed as a supplement to the debugging activity and as such does not provide the flexibility we view as necessary. All visualizations are from the point of view of a single data variable --multiple variables cannot be mapped to the same display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Data-Parallel Profile Data Collection</head><p>The global synchronizations required by the synchronous execution semantics of the DP model greatly enhance our ability to interact with the program during execution without affecting its execution semantics. However, we must decide what data to collect and when and how to forward it to the host processor and on to the visualization system. We group the different program visualization tasks and their information needs into three categories: 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>Program performance analysis --requires runtime data such as inter-processor communication, processor utilization, and processor scheduling, for both virtual and physical processors. Data profiling/monitoring --requires reporting of program variable values at given intervals or significant program events. Program Debugging --requires all of the above plus the ability to make changes interactively during execution and the ability to break or halt program execution if a specified condition is met.</p><p>In this section, we address issues related to collection of program statistics and variable values at arbitrary points during program execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Synchronous and Asynchronous Collection</head><p>In a DP environment, collection of runtime statistics and program variable values can occur synchronously at the natural synchronization points. Synchronous collection can also occur inside a parallel block (not at a natural synchronization point) if we implement the collection mechanism carefully and if there is sufficient memory available. Rather than reporting variable and program values immediately, we store the intermediate data at the local node and report the data to the host processor at the next natural synchronization point.</p><p>Asynchronous collection occurs when data is collected and reported inside a parallel execution block. Inside the block, the DP program exhibits MIMD behavior --each virtual processor may be at a different program state. This can result in a loss of visual coherence between displays associated with different processors.</p><p>However, asynchronous collection that may lead to loss of visual coherence is still useful as long as visualization takes place without comparison between processors that may be at completely different program points. It is important to note that it is not necessary to synchronize the processors when one processor is performing an asynchronous collection activity.</p><p>The processors that do not engage in the collection activity, engage elsewhere, or engage for different durations of time, all synchronize and wait at the end of the parallel block, allowing the straggler to catch up.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Parallel Program Visualization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Interface and Interaction</head><p>The user must be able to control execution and display speed, pause, stop, and start. The application and the visualization system are allowed to run asynchronously. In other words, visualization can lag behind the parallel application execution. The loose coupling between execution and visualization requires the use of a buffer that gathers execution data that has not yet been requested by the visualization system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Physical versus Virtual Processor Display</head><p>In C*, parallel variables are defined using a parallel type specifier, shape. Shape is used to specify the mapping of parallel data to virtual processors. There is a I:1 relation between virtual processors and parallel data elements --each element of a parallel data item is allocated to its own virtual processor.</p><p>The dimension of a shape does not have to match the physical configuration of the physical processors. C* first creates virtual processors for each position of a shape, then maps the virtual processors to the physical hardware. The shape of the parallel variable, and the corresponding assignment of virtual processors to physical processors plays an important role in the visualization of processors (virtual or physical). For example, a shape that denotes an array of data values (hence an array of virtual processors) leads us to conclude that one way to display the processors, virtual or physical, is to use a row of icons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Views</head><p>Program visualization is accomplished through visualization views and displays. While these terms are often used loosely when describing visualization systems, we use them in a more exact manner. A view denotes the perspective from which the information is gathered.</p><p>A display is a graphical representation of the given data from the selected view.</p><p>Processor utilization views show processor load and load distribution from the perspective of the host processor, or processor zero. Communication views display information about the interactions between the processors, both physical and virtual. These views depend on communication metrics such as: who communicated with whom, time of communication, size of message, and time spent communicating the message.</p><p>Variable views are most meaningful from the perspective of a single execution thread. Multiple simultaneous views for different threads, or arrays of views, can be used to compare and contrast the threads. However, direct comparison based on execution time is generally only meaningful if synchronous reporting schemes are used. In this case "time" is equivalent to the ordering of synchronization points. Parallel blocks that contain asynchronous reporting mechanisms can be compared, but comparison between the displays is arbitrary when the parallel application is between synchronization points. Synchronization points am particularly important because they mark a point in the execution where comparison between the different threads is valid. Execution time comparisons aside, variable views that do not explicitly include time are very good for direct comparisons between threads --or to study a single thread's behavior during execution. Variable displays include value average over time, value standard deviation, and value history.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">System Design Overview</head><p>For experimentation purposes, we have designed and implemented a portion of the model outlined in the preceding pages. Our system, DPV (Data-Parallel Visualizer), provides facilities for the visualization of parallel variable values (data behavior) and trace data. We regard this as an adequate subset of our model for the experimentation necessary to better understand user and parahel program visualization interaction.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Parallel Application Side Design</head><p>All activity on the parallel application side of the DPV system centers around our primary goal of providing trace and variable value information to the front-end visualization system during execution. To achieve this goal, our C* methods perform three subtasks: collection of data, organization of data, and communication of data. Data collection can be classified as either asynchronous or synchronous. In our initial implementation, all collection activities are synchronous, although the methods can be implemented using an asynchronous approach.</p><p>There are three types of data that we collect during C* program execution: parallel variable values, sequential variable values, and profile statistics. Both types of variable value collection require that the programmer identify the shape, the variable of interest, and points where the variable values should be noted and recorded. Sequential variables do not require an explicit shape identification --the system automatically defines and describes a shape, SequentialShape, for them. Profile data, including processor usage and communication statistics, is gathered automatically without any user involvement. Profile data, unlike user variable data, is gathered on a per physical processor basis, not on a per virtual processor basis. In keeping with our shape orientation, we map the physical processors to a standard predefined shape, PhysicalShape.</p><p>Unlike variable and shape definition information, which is stored in the sequential context, the variable trace information is stored in the physical parallel context. This is significant because it means that a value for a given variable of a particular virtual processor of a particular shape, may be intermixed with values belonging to other variables from the same or different shapes on a single physical processor. For performance reasons, we do not wish to order or sort values by shape or variable on the parallel application side. Ordering the values could require expensive point to point communication. Consequently, each value must have accompanying supplemental information that specifies its variable and shape and from where and when the data was collected. We leave it to the visualization side of the DPV system to sort the values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">DPV Visualization Side Design</head><p>The visualization side of the DPV system is designed using a layered software architecture, shown in <ref type="figure">Figure 2</ref>. As we move upward in the software architecture, the services provided by the class objects become less detailed and more abstract and conceptual. Visualization in DPV is handled by software objects called visualization modules which are applications in and of themselves. Visualization module clients such as the ModuleManager, external application frameworks, and the GUI are above the modules in the hierarchy.</p><p>The layers of our software architecture can be organized into three broad levels describing functionality, purpose, and level of detail --the Internals, Module and Application Levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">The DPV Internals Level</head><p>The class objects that inhabit the Internals Levels are primarily responsible for data organization, management, and access control. These objects cooperate to manage the C* data input  <ref type="figure">Figure 2</ref> -Layered Architecture Overview source, parse incoming messages, organize and sequence the raw C* data, handle storage and retrieval of static data representations (save/restore files), provide data access to client objects, optimize data access for clients, and provide system clock functions to client objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.1">Important Objects</head><p>Central to all these services, and pivotal to the entire DPV system, is the Visualization Data Structure, or VDS, object. The VDS serves as the librarian for all C* data. Using the services of other related objects, the VDS catalogues and organizes incoming data, and provides access to the data in a simplified manner. The ApplicationContext, or AC, manages and organizes all the resources necessary for visualization. Objects allocated by, or accessible through the AC include our application clock, the VDS, and handles for any active input or output sources. Through the AC and various lower-level classes, DPV accepts C* trace data via three distinct input sources: a live Berkeley socket connected to the executing C* program, a static message file, and a static (file) representation of the VDS. The static input sources allow users to visualize C* applications in a post-execution fashion or to explore former visualizations without re-executing their C* applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.2">Values</head><p>Values in DPV correspond to items stored in a block of memory that is associated with a single position of a parallel variable, i.e., a single virtual processor's instance of a parallel variable. To facilitate machine independent representation of variables, values are sent from the application side in the form of character strings.</p><p>Values within value lists are organized in order of their virtual processor index. Conceptually, each list of values contains a value for each virtual processor in the parallel variable shape. Actually, each list of values contains a value only for each virtual processor that is active when the record activity occurs in the C* program. Therefore, it is possible for a list of values to have fewer value nodes than the shape has positions. If a position is missing from the very last value list, its value is assumed to be unchanged from its previous value.</p><p>Sparse value lists can drastically increase value access time.</p><p>Value access occurs most frequently during visualization, but it can also occur during an internal VDS operation (file I/O or packing). A visualization algorithm typically iterates over each value slice list, and over each position in the relevant shape. Though consecutive accesses are optimized internally by our list object, a sparse value list can cause significant overhead as shown in <ref type="figure" target="#fig_1">Figure 3</ref>. To address the problem of sparse value lists and to speed data access, the VDS has the ability to pack data values into contiguous and regular blocks of memory. A packed value list contains a value for every position in the shape, regardless of whether or not a given position reported a value for that slice. When a value slice list is packed, the value nodes are discarded in favor of a block of memory that contains all values for that slice. Access into the memory block is very fast because direct address calculations are used in lieu of the list search techniques. In addition to reducing access times, packing can also reduce memory overhead. Value nodes, by necessity, contain information other than values, which is eliminated by packing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">The Module Level</head><p>All DPV visualization activities, regardless of the technique used, are performed exclusively by visualization modules.</p><p>Modules are distinct objects that reside in the upper levels of our layered architecture. Visualization techniques and display policies are decided by each individual module independently from the rest of the system. For example, one module may use shaded surfaces to display data while another may simply print textual information to standard output. Activity within a module centers around parallel variables that belong to various shapes. At creation time modules are given a list of one or more shape and parallel variable pairs that the user wishes the module to display. Internal control is entirely the decision of the module programmer and is algorithm dependent. However, a typical action is for a module to loop over each slice of data and for each virtual processor in the shape to obtain the value of the parallel variable and use that value in its display algorithm.</p><p>Although module programmers are free to create modules to perform any action, the average module performs a visualization using either an X/Motif widget or some type of text technique. The base module classes and some sample derived module classes are shown in <ref type="figure" target="#fig_2">Figure 4</ref>. Modules are created, activated, updated, managed, and destroyed by the ModuleManager object. Application level classes and functions do not access modules directly, but instead direct abstract information, such as "some data has arrived," to the ModuleManager who then decides what specific action to take with each module. The ModuleManager interacts with the modules using a standard set of messages to communicate directives such as create, update, rewind, and destroy.</p><formula xml:id="formula_0">I , 1 ' \ User/Derived Modules</formula><p>All modules that are to be used by the DPV system must be registered. Registration describes each module class to the ModuleManager and provides the manager with a handle to the module's creation function. Items described during registration include the module's name, its creation function, and a series of tuples that describe the number and type of shape/variable pairs that the module can use during visualization. Registration entries can also indicate that the module accepts a variable number of parameters that match its last defined parameter port.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.2">External Module Frameworks</head><p>Modules can be compiled with the application, internal, or run in a separate process using an application framework, external ( <ref type="figure">Figure 5</ref>). External modules are functionally identical to internal modules.</p><p>External modules imply more communication overhead but allow the use of user-defined modules without re-compilation and re-linking of the main application. This also facilitates module debugging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>-System</head><p>External Framework <ref type="figure">Figure 5</ref> -External Modules</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">The DPV Application Level</head><p>The main DPV application, embodied by the Graphical User Interface (GUI), handles all high-level system control and user interaction. All lower level objects, such as modules and the VDS, are ultimately controlled by the user's actions and the high level actions that correspond to various input sources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.1">Event Handling and Clock Processing</head><p>Messages, via socket or tile, can be directed to the DPV application. If the selected input source is of a message type, the system sets up an event handler that passes control to message handling objects any time input appears on the input source. In addition to event driven input handling, DPV also runs its local visualization clock during "idle" moments. From a user's perspective these activities take place in the background. Our sequential visualization application clock is analogous to the parallel application side's system clock which ticks during execution. All data access and control on the visualization side is governed by the tick of the visualization clock.</p><p>While the visualization clock is completely asynchronous from the parallel application clock, its boundaries are defined by the range of the ticks of the application clock. In other words, the visualization clocks range starts at zero, representing time zero on the parallel application side, and ends with the last tick number sent by the application side.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.2">The GUI</head><p>The GUI furnishes direct access to all important visualization control functions and provides current status information. Users can move the visualization time to a particular application clock tick using the visualization clock slider and can control the direction and size of each visualization clock tick using the increment slider.</p><p>Users indicate areas of interest by selecting shape and parallel variable pairs from the pick list in the upper left of the GUI, shown in <ref type="figure">Figure 6</ref> (Color Plate 1). Selected pairs are copied to the Selected List. The Matching List contains the names of all registered modules that can be used with the current Selected List. Each time a new pair is selected, the ModuleManager updates the Matching List. Users activate modules by selecting them from the Matching List. Active modules am listed in the Active List. Highlighting a selection in the Active List causes the shape/variable pairs selected for the module to be shown in the Selected List. This facilitates visualization exploration by providing a short cut, along with some user feedback, for specifying pairs of repeated interest.</p><p>Supplementing the controls found on the main window is a set of commands selected via a pull down menu attached to the menu pane at the top of the window. Using these commands, users can include additional external modules, save or load the VDS data structure, or set the input source to a file or live C* socket.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Jacobi Temperature Distribution</head><p>We have tested the DPV system using a variety of programs from the UNH C* compiler test suite, our own test suite, and other C* applications. <ref type="figure">Figure 6</ref> shows a DPV session displaying a C* Jacobi algorithm to find the steady-state temperature distribution of an insulated two-dimensional plate given constant boundary conditions. The plate is characterized by a 32x32 grid of values. As we can see by looking at the XSliceHistogram module (upper center), twelve separate slices of values were recorded. The difference between the initial state, slice 1, in the lower left comer and the final state in the lower center, slice 12, is quite noticeable. Plates from slices 1 and 12 are displayed as images, along side their surface counterparts, with temperature mapped to color rather than surface height. The XSnapShot module in the center displays the change matrix (applied to the plate at each step) in the early stages of the program (the module was locked by the user to prevent further updates). The change matrix values flatten out as the plate reaches its steady-state during the later stages of the program. In <ref type="figure">Figure 7</ref> (Color Plate 2), the first row contains time slices 1,5, and 11 of the two dimensional plate. The second row contains time slices 2,6, and 12 of the change matrix applied to the plate at each iteration. Each plate surface is shaded using the change matrix from the next time step. Colored regions on the surface indicate areas of change and the color denotes degree of change relative to that change matrix's maximum value. In plate 1 the area of change is localized to the border between low, medium, and high temperatures. In plate 11, many regions are affected by change, denoted by the widespread coloration. However, the degree of change in plate 1 is much greater than the degree of change in plate 11 as indicated by the decrease in the height of the respective change matrix surfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusion and Future Directions</head><p>We have designed and presented a model for concurrent visualization of data-parallel programs. To experiment with and refine our model, we have designed and implemented a system, DPV, based on a subset of our model. We have experimented with DPV and are satisfied with our preliminary implementation and the validity of our model. While DPV is usable in an experimental spirit, there is room for improvement, particularly when large data-parallel shapes are considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Application Side Issues</head><p>Presently, DPV data collection primitives are inserted into C* code by hand. This task must be integrated with the UNH C* compiler. Additionally, our application side data collection methods are too slow and inefficient for large scale parallel applications. This problem will be partially alleviated by the new version of the UNH C* compiler, but a complete solution requires a different approach discussed below. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Visualization Side Issues</head><p>A visualization issue that we have not yet thoroughly examined is the multi-dimensional visualization aspect of parallel variable data. How do we display, in a meaningful manner, multidimensional data, such as a 2D array of integers that belongs to a three dimensional shape? Other issues, such as mapping virtual processors to physical processors or displaying according to shape or virtual processor, also need to be further addressed.</p><p>We have taken steps towards optimizing data access within the VDS but future work should center around such issues as when it is best to pack, and whether or not packing should take place across multiple time slices, or just for a single slice of values, and when to discard "aged" data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3">Parallel Data Management/Visualization</head><p>The primary performance bottleneck in our system design is the potentially large volume of user data generated by the parallel application. Rather than placing the data management objects on the sequential machine with the rest of the visualization system, we could distribute the data management duties on the parallel side. Under this scenario, each physical processor would be responsible for managing its own data locally. Thus, large data sets would remain on the side of the system best equipped to handle them. This would require parallel I/O and multitasking features on the parallel machine --both of which are becoming more common.</p><p>The only drawback to this approach is that we must either parallelize and move the visualization objects to the parallel machine or repeatedly send large amounts of potentially duplicate data over a network connection to the visualization system. It would also be desirable to implement a mechanism that would support a dynamic specification of a sampling rate for choosing a subset of the data values to be sent to the visualization module. The ability to work with sampled data is dependent on the visualization module and type of visualization technique used.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 -</head><label>1</label><figDesc>System OverviewOur system design is split between two distinct sides of our visualization equation, the parallel application and the visualization system, as shown inFigure 1. On the parallel application side, we require methods for the collection and storage of trace and variable data values. The parallel program side components also address communication of the stored data over a communication channel to the visualization system. On the visualization side, the visualization system design includes methods for visualization data storage, management, and organization. Communication with the parallel application side is also an issue, as are more obvious concerns such as the methods that implement the user interface and visualization displays.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 -</head><label>3</label><figDesc>Sparse Value Lists Cause Backtracking</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4</head><label>4</label><figDesc>Figure 4 -Module Hierarchy 8.2.1 The Module Manager</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 -Figure 7 -</head><label>67</label><figDesc>DPV Session of the Jacobi Application First Row: Slices 1,5, and 11 of the Plate Matrix Shaded by the Next Change Matrix Second Row: Slices 2,6, and i2 of the Next Change Matrix</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Acknowledgements</head><p>We would like to thank Phil Hatcher and Roy Turner for their participation in a portion of this project. We would also like to thank Karen Jourdenias from Thinking Machines for her insight on the PRISM tool.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">EXVIS: An exploratory visualization environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Grinstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pickett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Inte$ace &apos;89</title>
		<meeting>Graphics Inte$ace &apos;89<address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-06" />
			<biblScope unit="page" from="254" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Visualization-Based Model for a Scientific Database System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Spat-R</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">D</forename><surname>Bergeron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">D</forename><surname>Meeker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Focus on Scientific Visualization</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactive Data Exploration with a Supercomputer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Grinstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">D</forename><surname>Bergeron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;91</title>
		<meeting>IEEE Visualization &apos;91</meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="248" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Debugging Parallel Programs with Instant Replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Mellor-Crummey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="471" to="482" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hatcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Quinn</surname></persName>
		</author>
		<title level="m">Data-Parallel Programming on MIMD Computers</title>
		<meeting><address><addrLine>Cambridge, MA.</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A Reference Description of the C* Language, Thinking Machines Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Frankel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A production-quality C* compiler for hypercube multicomputers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Hatcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Lapadula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Quinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="73" to="82" />
			<date type="published" when="1991-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Visualizing the Performance of Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Etheridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="39" />
			<date type="published" when="1991-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Geist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Peyton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Worley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>User's Guide</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>To Picl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A PORTABLE INSTRUMENTED COMMUNICATION LIBRARY</title>
		<imprint>
			<date type="published" when="1993-04" />
		</imprint>
		<respStmt>
			<orgName>Oak Ridge National Laboratory</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Visualization and Debugging in Heterogeneous Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Beguelin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dongarra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Geist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sunderam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="1993-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">PVM: A Framework for Parallel Distributed Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sunderam</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>Emory University, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Prism User&apos;s Guide, Thinking Machines</title>
		<imprint>
			<date type="published" when="1994" />
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Scalable Debugger for Massively Parallel Message-Passing Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sistare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bowker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Jourdenais</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Parallel &amp; Distributed Technology</title>
		<imprint>
			<biblScope unit="page" from="50" to="56" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
