<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatic Generation of Triangular Irregular Networks using Greedy Cuts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cliudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Applied Mathematics &amp; Statistics State</orgName>
								<orgName type="institution">University of New York at Stony Brook Stony Brook</orgName>
								<address>
									<postCode>11794</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">S B</forename><surname>Mitchells</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Applied Mathematics &amp; Statistics State</orgName>
								<orgName type="institution">University of New York at Stony Brook Stony Brook</orgName>
								<address>
									<postCode>11794</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Applied Mathematics &amp; Statistics State</orgName>
								<orgName type="institution">University of New York at Stony Brook Stony Brook</orgName>
								<address>
									<postCode>11794</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automatic Generation of Triangular Irregular Networks using Greedy Cuts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We propose a new approach to the automatic generation of triangular irregular networks from dense terrain models. We have developed and implemented an algorithm based on the greedy principle used to compute minimum-link paths in polygons. OUT algorithm works by taking greedy cuts (&quot;bites&quot;) out of a simple closed polygon that bounds the yet-to-be triangulated region. The algorithm starts with a large polygon, bounding the whole extent of the terrain to be triangulated, and works its way inward, performing at each step one of three basic operations: ear cutting, greedy biting, and edge splitting. We give experimental evidence that our method is competitive with CUTrent algorithms and has the potential to be faster and to generate many fewer triangles. Also, it is able to keep the structural terrain fidelity at almost no extra cost in running time and it requires very little memory beyond that for the input height array.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>A terrain is the graph of a function of two variables. The function gives the elevation of each point in the domain. Terrain models are widely used in visualization and computer graphics applications; such as flight simulators, financial visualization tools, strategic military analyzers, geographic information systems, and video games. Thus, it is of the utmost importance that primitive operations can be performed in realtime. Several factors may affect the efficiency of algorithms that operate on terrain; the most important are probably the size of the input and its underlying data structure.</p><p>The most common source of digital terrain elevation data is the DEM (Digital Elevation Model), supplied by the U.S. Geological Survey. A DEM is basically a two-dimensional floating point height array. It contains an extremely high level of redundancy, which in turn usually forbids real-time applications from us-ing it. Several alternative data structures have been proposed, including contour lines, quad-trees, and TINS ( fiiangular Irregular Networks). TINS stand out as being one of the most convenient to use for rendering and other geometric manipulation operations. A TIN is a set of contiguous non-overlapping triangles whose vertices are placed adaptively over the DEM domain <ref type="bibr">[8]</ref>. The automatic generation of TIN models from DEM models is an important area of research and is the main topic of this article. Visual accuracy -usually assessed by inspection and by number of ".&amp;very" triangles; Size of the model -measured as the number of output triangles;</p><p>Algorithm complexity -measured in terms of the time to generate the TIN and the memory requirement . <ref type="bibr">Fowler and Little [8]</ref> have introduced one of the first (and still very popular) methods to address the problem of automatic generation of TINS directly from DEMs. Their method is very simple. First, they classify the points by automatically choosing some "important" features of the terrain, such as ridges and peaks. They describe this phase of the algorithm as constructing the "structural fidelity" of the model; i.e., the TIN representation should have the same geographical features as the DEM. Then, they incrementally compute a triangulation of the points: in their case, they chose to use the Delaunay triangulation. At each step, a new point is added to the triangulation until no points are farther from the original surface than a certain predefined threshold. This phase is designed to preserve the "statistical fidelity" (i.e, to make it fit the specified error bound).</p><p>Franklin <ref type="bibr">[9]</ref> has proposed a similar approach back in 1973. It appears that his method had no notion of structural fidelity, and he did not use the Delaunay triangulation as the basis for his method. A new version of his code is publically available, and we used it for comparison with our method.</p><p>A detailed description of his algorithm and code is given in Section 4. Recently, substantial research has been conducted on creating hierarchical structures on top of TINS [7, 211, and on techniques to improve the quality of TIN meshes <ref type="bibr">[22]</ref>. S carlatos' dissertation [19] is a good survey of terrain modeling and representation. A very recent approach to building hierarchical models of terrains is given by <ref type="bibr">de Berg and Dobrindt [6]</ref>, who apply a hierarchical refinement of the Delaunay triangulation to represent terrain TINS at many levels of detail. See also [13, 141 for an approach called the "drop heuristic" and its comparison with other methods. Common to all these previous methods is the necessity to have a complete starting triangulation that is either refined by adding new points, or decimated [23] by removing redundant points. These approaches require that the algorithm maintain in memory a complete triangulation representation of the input, extended with various pieces of global information (e.g., most deviant point per triangle). The need for global information impacts the running time and memory requirements of these algorithms.</p><p>Our work is based on an entirely different approach for the triangulation and simplification of the data. It is based on an idea in the method developed by <ref type="bibr">Mitchell and Suri [17]</ref>, where a greedy set cover approach has been developed for approximating convex surfaces, and used recently by <ref type="bibr">Varshney [25]</ref> in heuristics for simplifying CAD models. We can consider the input DEM to be an instance of a TIN with very high resolution. In particular, each pixel of the DEM corresponds to four elevation data points, and we consider these to define two adjacent triangles of a surface. (A square pixel can be triangulated in one of two ways. We triangulate all pixels uniformly, with diagonals at 45-degrees.) Our goal is to simplify this input TIN surface to create a new TIN that has far fewer triangles, but is still within a specified error bound of the original surface. From an algorithmic point of view, terrain simplification is hard (NP-hard) [5, 41, but some polynomial-time algorithms are known for computing a nearly-optimal (i.e., nearly minimum-facet) approximating surface, guaranteed to be within a factor O(log n) of optimal (see <ref type="bibr">[l, 3, 15, 17]</ref>), or within a constant factor of optimal, if the surface is convex (see <ref type="bibr">[2]</ref>). Unfortunately, the polynomial-time bounds for these theoretically good approaches is rather high (at least cubic). In contrast, from the practical point of view, most of the previous computer graphics and geography research in the area is based on heuristics for generating triangulations that "fit" the original data, but have no guarantees, either in terms of the closeness to optimal or in terms of the worst-case running time.</p><p>The principle that drives our method (and is related to that of <ref type="bibr">[3,</ref><ref type="bibr">17,</ref><ref type="bibr">251)</ref> is the same greedy principle that is used to compute minimum-link paths in simple polygons. This problem is well studied in computational geometry <ref type="bibr">[12,</ref><ref type="bibr">16,</ref><ref type="bibr">241</ref> and can be used to find an optimal piecewise-linear approximation to a function of a single variable (see <ref type="bibr">[lo]</ref>). Our problem is of one higher dimension. We use a greedy-facet approach, selecting large triangles (bites) by which to extend an approximating surface, based on their feasibility (i.e., they must lie within an e-fattening of the original surface) and on their size (e.g., area of projection in the 2-y plane). The use of greedy algorithms is known to give provably good approximation results in many combinatorial optimization problems, for example, the set cover problem is approximated within a log factor of optimal by a natural greedy algorithm, and this fact leads [17] to a provably good approximation algorithm for the convex case of our problem. We have not yet been able to prove that our algorithm has a guaranteed effectiveness with respect to optimal, but we are hopeful that interesting properties can be proved about its performance. Currently, our code only handles inputs in the form of eleva,tion arrays, but in principle, there is no reason why it cannot be extended to arbitrary polyhedral terrains, or, for that matter, polyhedral surfaces in general. Extensions to higher dimensions also seem possible, that is, for simplifying piecewise-linear functions of three variables defined over tetrahedralizations of 3-space. Instead of a top-down approach that starts with a feasible Delaunay triangulation and tries to generate finer and finer Delaunay triangulations by adding points to the already created triangulations, our algorithm works bottom-up.</p><p>At each step a greedy cut is taken from an untriangulated polygon. The greedy cuts are an attempt to sample the data at the lowest possible resolution, thus minimizing the number of triangles in the output.</p><p>A full description of our algorithm is given in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Algorithm</head><p>This section gives a high-level description of our algorithm. The problem definition is as follows:</p><p>Given an input array, H, of heights H(z, y), 0 2 x &lt; m and 0 5 y &lt; n, whose data points are sampled from a regular grid on a rectangle R, and some E &gt; 0 specifying an error tolerance. Find a triangulated surface (TIN) that represents a terrain on R, such that the TIN has a small number of triangles (Ti), and each data point given by the array H(z, y) lies within vertical distance E of the TIN.</p><p>The algorithm maintains a list of untriangulated simple polygons, P, which represents the portion of R over which no triangulated surface has yet been constructed.</p><p>At each step, our goal is to select a maximum area triangle T within one of the polygons P E P, such that (1) the vertices ~1 = (FZ,YZ), and ~3 = (zg ~3) of T a!r:,iii&amp; zini (points (z, y) for which we have the altitude H(a, y)); (2) at least t wo of these vertices are vertices of P (i.e., T shares at least one edge with P); and (3) th e t riangle T corresponds to a triangle T' in space (with coordinates (21, yi, H(ai, yi)), (~312, H(Q, ~2))~ (333, ~3, H(Q, ~3))) such that T' is "feasible" with respect to e (see below for a precise definition). Because input data is sampled using a regular grid, the area of T is a good estimation of its combinatorial coverage (how many data points it covers). The ideal version of our algorithm searches all candidate triangles T and picks the best at each stage. However, for the sake of efficiency, the implemented version of our algorithm does not search all possible triangles T; instead, we do an approximate (limited) search for the best T, based on three basic operations, which will be described below.</p><p>Since each polygon P E P corresponds to an independent subproblem, we can work on each separately. (There is no particular ordering in how we store the polygons P E P.) Thus, at each step of the algorithm, a Cite (triangle) T is taken out of the polygon P at the head of the list P, until P is reduced to a single feasible triangle, or it is divided into two new simple polygons, each of which is inserted into the list. The final result of our algorithm is the list of all triangles (bites), 7. There is no need to store in memory the list 7 of triangles as it is generated. Each triangle can be written out directly to a file. No triangle connectivity information is saved at this point. Each polygon P E P is saved as a simple list of vertices, in counter-clockwise order. Thus, only very small and simple data structures are required.</p><p>We ought to define precisely what we mean by a triangle (in space) being "feasible" for input terrain H, with respect to a given E. As already mentioned, we can consider the input DEM H to be an instance of a TIN (a polyhedral surface, S), even though no triangulation is explicitly given. Specifically, to fix that one of the many triangulations we consider to be the input surface, we consider point (2, y, H(z, y)) to have six neighbors, namely, those data points corresponding to (z f 1, y&amp; 1) (the standard four grid neighbors) and the diagonalpoints <ref type="bibr">(z+l,y+l)</ref> and (z-l,y-1). We say that a triangle T' (in space) satisfies vreal feasibility with respect to E if, for every grid point (z, y) that lies within the projection T of T' onto the (z, y)-plane, T' intersects the vertical segment joining (;e, y, H(a, y) -e) and (z, y, H(z, y) + E). In other words, T' fits the function at the relevant internal grid points. Note that if T' has a very "skinny" or "small" projection (e.g., so that T contains no grid points at all), then it will certainly satisfy weak feasibility.</p><p>We say that triangle T' (in space) satisfies strong feasibility with respect to e if T' lies completely above the surface S-" and completely below the surface ,!?, where S-' (resp., S+') is the polyhedral surface (TIN) obtained by shifting S downwards (resp., upwards) by E. Note that if T' satisfies strong feasibility, then it certainly satisfies weak feasibility (but the converse is clearly false). The notion of strong feasibility applies directly to approximating arbitrary input terrains (e.g., given by a TIN rather than a DEM).</p><p>In order to test weak feasibility of T', we only have to examine the elevations at grid points internal to the projected triangle T. Such internal grid points are identified using a standard scan conversion of T. In <ref type="figure" target="#fig_1">Figure 1</ref>, we indicate these grid points with small squares. Strong feasibility, however, requires that we also check the altitudes corresponding to those points (indicated with circles in <ref type="figure" target="#fig_1">Figure 1</ref>) that lie at the intersections of an edge of T with a grid edge. The algorithm works by performing three basic operations, one at a time: ear cutting, greedy biting, and edge splitting. Each operation is applied to a current active polygon. The next sections describe each of these operations in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ear Cutting</head><p>This operation traverses a polygon P E P looking for possible "ears" to cut. An ear of a simple polygon P is a triangle contained within P that shares two of its edges with P. We simply traverse the boundary of the polygon, "cutting off' any ear which we discover that corresponds to a feasible triangle (i.e., one that meets the feasibility criterion for E). Given a vertex vi, we check if the edge (vi, ~i+r) is an internal diagonal to the polygon, that is, it is to the inside of the polygon and it does not intersect any other edge. This operation can easily be done in linear time by a simple traversal of the boundary of P. Using a dynamic triangulation of P, and performing "ray shooting queries", one can actually check in time O(log k) if (vi, 2)i+s) is an ear of a simple k-gon <ref type="bibr">[ll]</ref>, but the simple lineartime method is likely to be more practical (since k is typically small) and is what we currently have implemented.</p><p>Each cut we perform lowers the complexity (number of edges) of polygon P by one, thus taking the algorithm closer to completion. Ear cutting is essential for the algorithm to terminate. In general, it will be the final step in any run of the algorithm. Also, it has a tendency to turn obtuse angles into acute ones, which eventually leads to larger edges (hence triangles) in the triangulation.</p><p>Ear cutting is the mechanism the algorithm uses to adapt itself to lower sampling rates (larger triangles).</p><p>Ear cutting fails when no more feasible ears exist. This happens when the size of the edges of P are too large, and the ears cover too much area in the polygon. In this case, there must be some way to make edges smaller, which leads to higher sampling rates. In order to adapt to more complicated terrains, we introduce two additional basic operations: greedy biting and edge splitting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Greedy Biting</head><p>In this basic operation, we find a point v inside the polygon P and an edge, (vi,vi+i) of P, such that <ref type="bibr">(vi,v,vi+i)</ref> forms a triangle, T, inside P that meets the feasibility criterion.</p><p>We accomplish two things with this operation:</p><p>(1) subdividing an edge of P in two (replacing (w;,zli+l) with (vi,w) and (v,~)i+l thereby achieving a higher "sampling rate"; and, 1 ), 2) taking a bite out of the polygon P, thus progressing further in "eating away" all of P. The actual operation is a bit more complicated, as it needs to handle choices of v that may be a vertex of P and lead to P being split into two disjoint new simple polygons.</p><p>The greedy biting operation works as follows: l Bite. For the polygon P, for each edge (vi, Vi+l) search for a point v E P such that (wi, V, Vi+l) corresponds to a feasible triangle. For efficiency, we search for such a point w in a neighborhood of (wi,q+i). Currently, we limit the search to grid points along (close to) the vector perpendicular to (wi, wi+l) at the midpoint of (Vi, wi+l). We use a binary search, starting at a point whose distance from (wi, w;+l) is roughly ]wiw~+l), then halving the distance at each step until a point is found (or we fail). (By trying 0th er search strategies for v, we can likely improve the algorithm performance. This is being investigated.) l Split. If the "Bite" step succeeds in finding a point v for which <ref type="bibr">(vi, v, wi+i)</ref> corresponds to a feasible triangle, we will potentially split polygon P. We search for the closest edge (vi, ~j+~) to v. If the triangle (wj, w, wi+i) also corresponds to a feasible triangle, we subdivide (split) the polygon P into two simple polygons, outputting both triangles ((wi, w, v;+l) and (vi, w, wj+i)); otherwise, we simply output (wi, w, wi+i) without splitting P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Edge Splitting</head><p>It may happen that both ear clipping and greedy biting fail to find a feasible triangle. In this case, our algorithm attempts to split some edge of the polygon P. Checking each edge of P in succession, starting with the longest, we look for an edge to split (roughly) in half (or possibly in smaller pieces, if splitting in half fails). When we split edge (wi, wi+i) at a (grid) point w, we are actually creating a skinny (feasible) triangle, <ref type="bibr">(vi, w, vi+i)</ref>. Since the triangles created in this way are small or "&amp;very", we prefer not to perform this operation very often, Indeed, in practice this phase of the algorithm is seldomly needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initialization</head><p>Each phase of our algorithm works to triangulate the interior of a simple polygon P, with feasible triangles. In order to generate the first such polygon, bounding the whole domain R, we apply a one-dimensional version of our algorithm in each of the four cross sections (defined by the vertical planes a: = 0, m, y = 0, n) that correspond to the boundary of the region R. The algorithm can be considered to be a simplified version of the standard min-link path method of <ref type="bibr">Suri [24]</ref>, applied to the discrete data points between the offset curves obtained by shifting the terrain surface up/down by E. See <ref type="figure" target="#fig_2">Figure 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Main Algorithm</head><p>The algorithm simply applies the above three operations, one at a time, giving priority (in order) to ear cutting, greedy biting, and then edge splitting. A complete description of our algorithm is outlined as follows:</p><p>Greedy Cuts Algorithm (0) Initialize P to be a list of one element -the single polygon obtained by the initialization procedure above.</p><p>(1) While P is not empty, do (a) Let P E P.</p><p>(b) If P is a single feasible triangle, output this triangle, and remove P from P.</p><p>(c) Else, while P is not fully triangulated,</p><p>Perform ear cutting on P, until no feasible ears exist. (ii) Perform greedy biting on P. If this results in a greedy bite that splits P, then remove P from P, add the two new polygons to P, and go to (1). Otherwise, if at least one greedy bite is found (for some edge of P), go to (1) (without splitting P). (iii) Perform an edge split for P. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Discussion</head><p>Terrain Sampling</p><p>One of the most interesting properties of our algorithm is the way it samples the dataset. It generates large triangles in places of relatively little change and small triangles in areas of more radical change. It is interesting to try to analyze how this happens, and here is where we can see the nice coupling of properties between the ear cutting phase and the others. If the terrain is largely uniform, ear cutting generally leads to longer and longer edges of P, until we encounter a region of high complexity, at which point edges are subdivided by greedy biting or edge splitting (a method of increasing the sampling resolution). Once we triangulate the high complexity region, ear cutting again makes the edges on the boundary larger and larger, i.e., making the triangles larger. Our algorithm therefore has a natural mechanism for attempting to minimize the number of triangles required. (Of course, as we have already said, our algorithm is not guaranteed to find a true minimum (an NP-hard problem).) The strategy of where/when to apply each of our three operations affects which regions get sampled at higher resolutions. Thus, we continue to experiment with further variants of our search strategy in hopes of obtaining better and smaller triangulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Maintaining Structural Fidelity</head><p>A primary objective in any algorithm that simplifies (compresses) data is to maintain as much of the important structure of the input as possible. Our algorithm generates a TIN that is close to the input DEM, according to the given tolerance E. However, beyond the constraint of being e-close, one may wish to place further restrictions on the structural fidelity; for example, one may wish to preserve a selected set of point features or of edge features, requiring that the surface approximation include these points and segments in the output TIN. In top-down algorithms, such requirements can be incorporated using constraints; for example, line segments can be preserved using con-strained Delaunay triangulation (e.g., <ref type="bibr">[S]</ref>). In our bottom-up algorithm, we can incorporate such constraints directly, at low cost, within the test for triangle feasibility:</p><p>A triangle T' is not feasible if its projection, T, contains a point feature on its interior or boundary, except at a vertex, or intersects an edge feature, except if the edge is an edge of T. Further, our algorithm can maintain the structure of an edge or a ridge, at a lower resolution (within, say, E) than the full resolution, by executing the (lower dimensional) initialization step in a vertical wall (plane) through each constraint edge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Termination</head><p>It is important to consider whether or not our algorithm ever terminates. Could it ever get "stuck" and fail to generate any further triangles, even though the list of untriangulated regions, P, is not empty? The answer is "no" for the case of the weak feasibility condition, assuming that greedy biting is done by searching over all possible bites. As a proof, consider a polygon P E P. If P has no grid points, then any ear of P is feasible. (Any simple polygon with at least 4 vertices has at least two ears, by the "Two Ear Theorem" [18].) If P has grid points in its interior, then there must exist a triangulation of these points within P (since any polygonal domain can be triangulated). All triangles in this triangulation must obey weak feasibility. In particular, there must exist a triangle T that shares at least one of its edges with P. Such a triangle is either a (feasible) ear of P (found in ear cutting) or a potential bite (found in greedy biting, assuming that we do a full search). This proves termination.</p><p>In the strong feasibility case, however we get a different situation. Because of the discrete nature of the allowed output (i.e., triangles must use original data points, since we do not allow Steiner points), and the continuous nature of the strong feasibility condition (which joins data points to form a polyhedral surface constraint), there are (rare) instances in which the al-gorithm, as implemented, can get stuck when using strong feasibility. In response to this, we have implemented a simple feature that will guarantee termination in all cases. If the algorithm cannot find a feasible triangle, then it relaxes the feasibility condition in ear cutting, and finds, instead, an ear that has the smallest deviation from the original DEM. (This same feature allows us to limit our search in greedy biting and still guarantee termination in the weak feasibility case.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Complexity</head><p>We first remark that our algorithm uses very little internal memory. Other than the input data array, we keep track only of the list P of polygons, each of which is (typically) very small. Triangles that we generate do not need to be stored, but can be written out directly to disk. In contrast, methods that rely on triangulation refinement must maintain some sort of topological data structure for the full set of triangles. Typically, one would expect that if the output size (number of triangles) is k, then the boundary of the polgyons P at any given instant will have roughly size 4.</p><p>It is difficult to prove a bound on the expected run time of the algorithm. Clearly, the worst-case running time is polynomial in the input size, since each primitive test or computation can easily be performed, usually in worst-case linear time (linear, generally, in the size of P E P). H owever, our experimental evidence suggests that the algorithm runs in time roughly linear in the input size.</p><p>The output complexity for our algorithm is again hard to estimate from a theoretical point of view. The problem we are trying to solve approximately is known to be NP-hard, in general. Thus, the best we can hope for is that we may be able to prove a worst-case bound on the ratio of our output size (number of triangles) to the number of triangles in an optimal TIN. There is good theoretical basis (e.g., from greedy set cover heuristics) to suggest that our algorithm (or a close variant thereof) will never produce more than a small (e.g., logarithmic) f ac or more triangles than is possi-t ble for a given E. Proving such a fact remains an open (theoretical) problem. Perhaps the best indication we have of the effectiveness of the algorithm is the experimental data we have, which suggests that our algorithm is obtaining substantially fewer (roughly 20-30 percent) triangles than the competing algorithm, for the same error tolerance E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Results</head><p>Our algorithm is relatively simple to implement. Our C implementation has only about 4,000 lines of code. The code uses several computational geometry primitives, many of which come from O'Rourke <ref type="bibr">[18]</ref>, including segment intersection testing, diagonal classification, point classification (point location with respect to a simple polygon). With these primitives in hand, and routines to handle simple polygon opera-tions (e.g., splitting an edge of a polygon, inserting a vertex.), it is fairly easy to implement the algorithm described in Section 2. As with all geometric algorithms, care has to be taken with special (degenerate) cases that arise from collinearities.</p><p>In order to study its performance, we have conducted tests of our algorithm and compared it with Franklin's algorithm, which is a top-down approach. We compared the speed, average error bound (over all the triangles), and the complexity of the output (measured in the number of triangles). We ran both algorithms on the following types of input: real terrain datasets, artificially generated terrains arising from performing cuts to generate faults, and artificially generated terrains arising from lifting triangulations.</p><p>Franklin's algorithm Franklin's algorithm is described in <ref type="bibr">[9]</ref>, and is a nice and efficient example of a top-down triangulation method. Initially, the algorithm approximates the DEM by 2 triangles. Then, a general step of the algorithm involves finding the most deviant point in each already generated triangle and inserting this new point into the triangulation, splitting one triangle into three. Each time a point is inserted, the algorithm checks each quadrilateral that is formed by a pair of adjacent triangles, at least one of which is a new triangle (one of the three incident on the new point). A local condition on the quadrilateral determines whether or not to perform a diagonal swap. The original code works by performing a pre-determined number of splits. We have changed the code to make as many splits as necessary in order to meet a prespecified error bound e. Franklin's implementation is done carefully, with emphasis on efficiency. For the sake of speed, it uses internal memory as much as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experimental</head><p>Data Our experiments were conducted on a Silicon Graphics ONYX, equipped with two 1OOMhz R4400 processors and 64MB of RAM. Only one of the processors was used. The time to read the terrain datasets from the disk was not included in our runtimes.</p><p>In <ref type="table" target="#tab_0">Table 1</ref>, we show the results of running three algorithms on seven real terrain datasets. We ran Franklin's algorithm (f), and two versions of our algorithm -one using weak feasibility (w), and one using strong feasibility (s). The table shows the choice of E, the running times, and the total number of triangles in the output TIN, for each of the seven terrains. The input terrains were all scaled to be 120-by-120 elevation arrays, for uniformity of testing.</p><p>In summary, greedy cuts with weak-feasibility beats Franklin's code in the number of output triangles in all instances. Greedy cuts with strong-feasibility loses in most cases, but it applies a stricter accuracy requirement than Franklin's algorithm (which uses weak feasibility . Franklin's optimized code is usually faster 1 than our relatively naive) implementation.</p><p>We expect that with fine tuning and optimization, our algorithm will be able to run much faster. But perhaps more significant is the comparison of memory requirements. On average, Franklin's algorithm used more than an order of magnitude the memory our algorithms require. Color plate 1 and Color plate 2 show rendering examples of real terrain rendered with both Franklin's and our algorithm. Our algorithm generates noticebly larger polygons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusions and Future Work</head><p>We have presented a new method to generate Triangular Irregular Networks (TINS) from dense terrain grids. Our algorithm differs from previous methods in its use of a bottom-up approach to terrain sampling. Its key features include: a Low Complexity Output TIN. Our method generates very few triangles for a given E. Indeed, a primary objective in using the greedy optimization step is the minimization of the number of triangles in the output. l Memory Eficiency.</p><p>It can be run on very large terrains, potentially even those whose grids cannot simultaneously fit in memory. l Maintenance of Structural Fidelity. Our method is able to maintain with very little additional overhead any pre-specified set of features of the terrain, without the need for adding additional (Steiner) points. 0 Speed. Our running times are comparable to the fastest available methods, and we can probably improve the performance dramatically with a careful refinement of our code.</p><p>Our experimental results so far have focussed on the quality of the output TIN. The running time can certainly be improved through more careful coding. Also, further experimentation with the heuristics, especially the greedy biting operation, should yield even better results with respect to the output size. On the theoretical side, we are also attempting to prove worst-case bounds on the performance of the approximation (e.g., that we obtain a number of triangles that is guaranteed to be within a small factor of optimal).</p><p>A straightforward modification of our code will permit the algorithm to work on arbitrary TIN terrain inputs, rather than just on DEM arrays. Conceptually, there are no changes needed to the algorithm. A somewhat less trivial modification will be to generalize the algorithm to approximate arbitrary (nonterrain) polyhedral surfaces and to find approximations to a minimum-facet separating surface (as done in <ref type="bibr">[2,</ref><ref type="bibr">3,</ref><ref type="bibr">171</ref>, in the convex case).</p><p>Another straightforward extension of our method allows one to use it to build hierarchical representations of terrain.</p><p>For example, we can simply start with an extremely crude terrain approximation (e.g., just two triangles), and then adjust e to be smaller and smaller, making each corresponding TIN a refinement of the previous one, until we have the full resolution grid. An ideal such hierarchy would have logarithmic height, as the intermediate <ref type="bibr">TINS have sizes 2,</ref><ref type="bibr">4,</ref><ref type="bibr">8,</ref><ref type="bibr">16,</ref><ref type="bibr">etc.</ref> Another extension that we are pursuing is to approximate functions (terrains) of three variables. Approximating such functions is very important in scientific visualization.</p><p>One can apply our same paradigm to this problem, biting off tetrahedra that satisfy the E-fitness criterion.</p><p>The tricky issue in implementing this algorithm is in maintaining the regions P of untetrahedralized domain, since this will be a polyhedral space, possibly of high genus.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Several factors are important in judging the quality of the TIN representation of a given DEM (list partially adapted from [as maximum, mean, or standard deviation error;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Weak and strong feasibility.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>The solid line is calculated bu a areedu method. In linking data points, go as far as possible withoutv.s I eziting the strip defined by the dashed lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Running times (in set) of three algorithms on seven real terrain data sets. (f) indicates FTanklin's code; (w) and (s) indicate our algorithm with weak and strong feasibility, respectively. All terrains are 120x 120 elevation arrays. The.error bounds (E) were chosen to keep the number of triangles ('I'rgs.) in the output approzimately in the 1000 to 3000 range. Memo$usaie-is the nu&amp;beT of 8Kbyte pages allocated.</figDesc><table><row><cell>Terram</cell><cell>E</cell><cell>Time</cell><cell cols="2">%s* Memory</cell></row><row><cell></cell><cell>2.5 (f)</cell><cell>3.2</cell><cell>1994</cell><cell>6229</cell></row><row><cell>Buffalo</cell><cell>2.5 (w)</cell><cell>8.12</cell><cell>1641</cell><cell>428</cell></row><row><cell></cell><cell></cell><cell>21.86</cell><cell>2279</cell><cell>592</cell></row><row><cell></cell><cell></cell><cell>5.03</cell><cell>2688</cell><cell>8731</cell></row><row><cell></cell><cell></cell><cell>17.38</cell><cell>2137</cell><cell>572</cell></row><row><cell></cell><cell></cell><cell>27.57</cell><cell>2849</cell><cell>700</cell></row><row><cell></cell><cell></cell><cell>2.23</cell><cell>1564</cell><cell>4781</cell></row><row><cell></cell><cell></cell><cell>4.24</cell><cell>1214</cell><cell>315</cell></row><row><cell></cell><cell></cell><cell>8.1</cell><cell>1578</cell><cell>454</cell></row><row><cell></cell><cell></cell><cell>4.5</cell><cell>2822</cell><cell>8621</cell></row><row><cell></cell><cell></cell><cell>12.87</cell><cell>2073</cell><cell>488</cell></row><row><cell></cell><cell></cell><cell>37.96</cell><cell>3115</cell><cell>844</cell></row><row><cell></cell><cell></cell><cell>2.44</cell><cell>1297</cell><cell>4084</cell></row><row><cell></cell><cell></cell><cell>2.6</cell><cell>859</cell><cell>231</cell></row><row><cell></cell><cell></cell><cell>3.62</cell><cell>1127</cell><cell>296</cell></row><row><cell></cell><cell></cell><cell>4.03</cell><cell>2561</cell><cell>8082</cell></row><row><cell></cell><cell></cell><cell>10.27</cell><cell>1836</cell><cell>495</cell></row><row><cell></cell><cell></cell><cell>21.09</cell><cell>2430</cell><cell>628</cell></row><row><cell></cell><cell></cell><cell>5.28</cell><cell>2671</cell><cell>8365</cell></row><row><cell></cell><cell></cell><cell>9.70</cell><cell>2011</cell><cell>486</cell></row><row><cell></cell><cell></cell><cell>26.75</cell><cell>2763</cell><cell>672</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 Â© 1995 IEEE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>A. Kaufman is partially supported by the National Science Foundation under grants CCR-9205047 and DCA 9303181 and by the Department of Energy under the PICS grant. J. Mitchell is partially supported by National Science Foundation grant CCR-9204585, and by grants from Boeing Computer Services and Hughes Aircraft.</p><p>C. Silva acknowledges partial support from CNPq-Brazil under a PhD fellowship. We thank Martin Held for supplying us terrain data and a program that decodes the DEM terrain datasets. We thank Pat Crossno, Juliana Freire, Paul Heckbert, and Amitabh Varshney for their comments on the paper. Special thanks to Wm. Randolph Franklin for making his triangulation code freely available on the Internet.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Surface approximation and geometric partitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fifth Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>Fifth Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="34" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Almost optimal set covers in finite VC-dimension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Brannimann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Annu. ACM Sympos. Comput. Geom</title>
		<imprint>
			<biblScope unit="page" from="293" to="302" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Algorithms for polytope covering and approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Joseph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Workshop Algorithms Data Struct</title>
		<meeting>3rd Workshop Algorithms Data Struct</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">709</biblScope>
			<biblScope unit="page" from="107" to="135" />
		</imprint>
	</monogr>
	<note>Theoret. Comput. Sci.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the complexity of approximating and illuminating three-dimensional convex polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gautam</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Workshop Algorithms Data Struct</title>
		<meeting>4th Workshop Algorithms Data Struct</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On levels of detail in terrains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dobrindt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. iith Annu. ACM Sympos</title>
		<meeting>iith Annu. ACM Sympos</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="26" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A pyramidal data structure for triangle-based surface representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">De</forename><surname>Floriani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Graph. Appl</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="67" to="78" />
			<date type="published" when="1989-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Triangulated irregular network to approximate digital terraiu, Section 2.3, Research Interests</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J R</forename><surname>Little ; W</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Franklin</surname></persName>
		</author>
		<ptr target="ftp://ftp.cs.rpi.edu/pub/franklin/" />
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="199" to="207" />
			<date type="published" when="1979-08" />
		</imprint>
		<respStmt>
			<orgName>Electrical, Computer, and Systems Engineering Dept., Rensselaer Polytechnic Institute</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>Automatic extraction of irregular network digital terrain models. Manuscript</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient piecewise-linear function approximation using the uniform metric</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Annu. ACM Sympos</title>
		<meeting>10th Annu. ACM Sympos</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dynamic ray shooting and shortest paths via balanced geodesic triangulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Annu. ACM Sympos</title>
		<meeting>9th Annu. ACM Sympos</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="318" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Approximating polygons and subdivisions with minimum link paths</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Hershberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Snoeyink</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">31</biblScope>
		</imprint>
	</monogr>
	<note>Internat</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Geom. Appl</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="383" to="415" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A drop heuristic conversion method for extracting irregular network for digital elevation models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GIS/LIS &apos;89 Proc</title>
		<imprint>
			<publisher>American Congress on Surveying and Mapping</publisher>
			<date type="published" when="1989-11" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="30" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Comparison of existing methods for building triangular irregular network models of terrain from grid digital elevation models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. J. of Geographical Information Systems</title>
		<editor>J. S. B. Mitchell, G. Rote, and G. Woeginger</editor>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="8431" to="459" />
			<date type="published" when="1991-09" />
		</imprint>
		<respStmt>
			<orgName>Dept, of Applied Math, University at Stony Brook</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>Approximation algorithms for geometric separation problems. Minimum-link paths among obstacles in the plane. Algorithmica</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Separation and approximation of polyhedral surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd ACM-SIAM Sympos. Discrete Algorithms</title>
		<meeting>3rd ACM-SIAM Sympos. Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="296" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>O'rourke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry in C</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">C code and errata available by anonymous ftp from grendel</title>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
	<note>csc.smith.edu (131.229.64.23), in the directory /pub/compgeom</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Spatial data representations for rapid visualization and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Scarlatos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Stony Brook, NY 117944400</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, State University of New York at Stony Brook</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hierarchical triangulation using terrain features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Scarlatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pavlidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE Conference on Visualization -Visualization &apos;90</title>
		<meeting>of the IEEE Conference on Visualization -Visualization &apos;90</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="168" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Hierarchical triangulation using cartographics coherence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Scarlatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pavlidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CVGIP: Graph. Models Image Process</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="147" to="161" />
			<date type="published" when="1992-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Optimizing triangulation by curvature equalization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Scarlatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pavlidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE Conference on Visualization -Visualization &apos;92</title>
		<meeting>of the IEEE Conference on Visualization -Visualization &apos;92</meeting>
		<imprint>
			<biblScope unit="page" from="333" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;92</title>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">On some link distance problems in a simple polygon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Autom</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="108" to="113" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Hierarchical Geometric Approximations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<idno>TR-050-1994</idno>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Chapel Hill</publisher>
			<biblScope unit="page" from="27599" to="3175" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of North Carolina</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
