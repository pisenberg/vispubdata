<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sweeping Simplices: A fast iso-surface extraction algorithm for unstructured grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
							<email>hwshen@cs.utah.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Utah Salt Lake City</orgName>
								<address>
									<postCode>84112</postCode>
									<region>UT</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Utah Salt Lake City</orgName>
								<address>
									<postCode>84112</postCode>
									<region>UT</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sweeping Simplices: A fast iso-surface extraction algorithm for unstructured grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present an algorithm that accelerates the extraction of iso-surfaces from unstructured grids by avoiding the traversal of the entire set of cells in the volume. The algorithm consists of a sweep algorithm aad a data decomposition scheme. The sweep algorithm incrementally locates intersected elements, and the data decomposition scheme restricts the algorithm&apos;s worstcase performance. For data sets consisting of hundreds of thousands of elements, our algorithm can reduce the cell traversal time more than 90% over the naive isosurface extraction algorithm, thus facilitating interactive probing of scalar fields for large-scale problems on unstructured three-dimensional grids.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Displaying iso-surfaces is an effective way to visualize three-dimensional scalar fields. Used to represent regions where the physical field is constant, isosurfaces allow visualization with a full range of visual depth. By visualizing the spatial distributions of several iso-surfaces, scientists are able to obtain a greater understanding of a field's underlying structure; however, displaying multiple contours in a single frame has proved difficult.</p><p>Dynamically probing the scalar field interactively by varying the iso-value has proven effective, but this method has been difficult to perform in real time. We present a new algorithm that overcomes the previous obstacles for interactive iso-surface extraction on unstructured grids.</p><p>The marching cubes algorithm proposed by Lorensen and Cline <ref type="bibr">[l]</ref> has become a standard technique to generate iso-surfaces. Although the algorithm originates from medical applications, which typically use structured grids, the algorithm can be extended to problems using unstructured grids of tetrahedral elements. A naive implementation of the algorithm works as follows. Each cell in the field is traversed. Depending on the scalar values at the cell's corners, the geometry of surfaces inside each tetrahedron is determined. For a field represented by tetrahedral elements, there are only three different types of surface-cell intersection geometry, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Although the naive algorithm is straightforward to implement, it is computationally inefficient. Given a particular isovalue, only a portion of cells in the field will intersect with the given value; for this reason, the traversal of the entire set of cells in the volume is unnecessary. Theoretically, the upper bound for the number of intersected cells is approximately O(N2i3).</p><p>In this paper we present an algorithm that addresses the cell traversal problem to achieve fast isosurface extraction within unstructured grids. The algorithm comprises two parts: a data decomposition scheme and a sweep algorithm. The data decomposition scheme minimizes the number of cells that need to be inspected for a particular iso-value. The sweep algorithm incrementally locates the intersected cells for the specified value. Our algorithm significantly reduces cell traversal time not only when the iso-value changes smoothly, but also when the iso-value changes dramatically.</p><p>In the following sections, we begin by surveying related work. We then describe our sweep algorithm and data decomposition scheme. Finally, we conclude with a detailed algorithm analysis and results of simulation (See color plates, page CP-17) 143 1070-2385/95$4.00@1995IEEE</p><p>Proceedings of the 6th IEEE Visualization Conference (VISUALIZATION '95) 1070-2385/95 $10.00 Â© 1995 IEEE studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Octrees: Wilhelms and Van Gelder <ref type="bibr" target="#b1">[2]</ref> use an octree data structure to accelerate iso-surface extraction.</p><p>The algorithm starts with a setup phase that creates the octree. Each node of the octree contains the maximum and minimum scalar values among the data elements in the sub-volume. When the user specifies an iso-value, the algorithm starts the surface-finding phase, which examines the volume by traversing from the root of the octree. All the sub-volumes with minimum values higher than the iso-value or maximumvalues lower than the iso-value are then excluded. When a leaf node is visited, this node's eight cells are examined to generate surfaces.</p><p>Octrees can substantially reduce cell traversal time because visits to non-intersected regions can be entirely avoided. However, octree data structures have primarily been implemented for data on structured grids. Moreover, octree methods are often sensitive to high-frequency noise within the data. Active List: Giles and Haimes <ref type="bibr" target="#b2">[3]</ref> have developed an algorithm that accelerates the cell traversal process by sorting the elements by their maximum and minimum values to form two separate lists. They also calculate a global maximum, AZ, among the differences of all cells' two extreme values. When an iso-value S is initially specified or has changed from its previous value by more than AZ, all the cells with minimum values between [S -AZ, S] are placed into an "active list." The active list is then purged of all cells that do not cross the iso-value. If the iso-value has changed less than Ax and is greater than its previous value, then the cells in the minimum list that have minimum values between [old S, new s] are placed into the active list. If the iso-value has changed less than AZ and is smaller than its previous value, then the elements in the maximum list with maximum values between [new S, old S] are placed into the active list. The updated active list is then purged of all cells that do not cross the iso-value.</p><p>While it can accelerate the cell traversal process, Gile's and Haimes' algorithm has several disadvantages. First, Az cannot be too large, otherwise the range of [S -AZ, S] can include a very large number of cells. The algorithm then degenerates to the naive method. Unfortunately, the range of AZ is hard to control because any cell with a large gradient could increase the global maximum by a large amount. One often sees this phenomenon in boundary value problems solved using a finite element method. Second, the algorithm performs well only when the user changes the iso-value smoothly. Third, keeping the active list updated requires list insertions and purges that further slow the process if either of the two previous conditions occur. Span Filter:</p><p>Gallagher designed a span filter to optimize the performance of his iso-surface extraction algorithm <ref type="bibr" target="#b3">[4]</ref>. Initially, the range of the scalar values in the field is subdivided into several subranges termed buckets. The number of buckets that a cell's scalar values cross is defined as the span length. Cells are then distributed into different span lists according to their span lengths. Within each span list, the cells are further grouped into different buckets based on their lower bounds. For a given iso-value, the algorithm examines each span list. Within each span list, buckets that have bounds at and lower than the iso-value, depending on the span length of the list, are retrieved, and the elements inside are visited.</p><p>Gallagher's algorithm allows the user to specify isovalues randomly without performance penalties. However, because the cells are divided into different groups statically, and because within each group there is no ordering between cells, the algorithm cannot exploit coherence when two given iso-values are very close to each other. Because the data range is not divided based on the field's scalar distribution, there may be cells clustering in only a few groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Algorithms</head><p>In this section, we present the details of our isosurface extraction algorithm. The algorithm is divided into two main parts: a sweep algorithm and a data decomposition scheme. The sweep algorithm incrementally locates the surface-intersected cells with a minimal amount of cell traversal. The data decomposition scheme guards the algorithm's worst case performance. We describe the sweep algorithm first because it is the kernel of the process and is applied to each subdivided group. We then explain our data decomposition scheme. Finally, we describe the integration of both the techniques that make up the Sweeping Simplices Algorithm. The algorithm starts by sorting the SWNodes in the sweeping list by their represented cells' maximum values. All SWNode flags are initially set to 0. To make cross-references from the minimumlist to the sweeping list, we record each SWNode's address into its corresponding MinNode's reference field in the minimum list and then sort the minimum list by the represented cells' minimum values. <ref type="figure" target="#fig_1">Figure 2</ref> illustrates the two lists for a scalar field containing five cell elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sweep Algorithm</head><p>When an iso-value has been initially specified, a binary search algorithm is invoked to find the limit Imin in the minimum list where all the cells with MinNodes before 1min have lower minimum values than the iso-value. The algorithm then sweeps through those nodes before Imin and follows their references to the sweeping list to set the flags of the SWNodes. A limit, I Inax, is identified in the sweeping list so that all cells with SWNodes after that limit have higher maximum values than the iso-value.</p><p>It is then clear that all cells with SWNodes remaining in the sweeping list after Immax and having their flags set are intersected cells. In <ref type="figure" target="#fig_2">Figure 3</ref>, the shad-  owed node is the SWNode for the cell B, which is an iso-surface intersected cell.</p><p>If the iso-value is changed, the sweep algorithm locates a new Imin from the minimum list. Then all the MinNodes between the previous Imin and the new Imin are swept through and the references in the nodes are followed to their corresponding SWNodes in the sweeping list. If the new iso-value is larger than the previous iso-value, then those affected SWNodes' flags are set to 1 because their represented cells now have lower minimum values than the new iso-value. If the new iso-value is smaller than the previous iso-value, then those affected SWNodes' flags are reset to 0 because now their represented cells have higher minimum values than the new iso-value. A new lmax is found again and all the cells after that limit that have SWNodes with a flag set are the cells intersected by the iso-surfaces.</p><p>The algorithm is efficient because the minimum and sweeping lists can be updated incrementally.</p><p>In addition, there is no list insertion or purge operation needed. Thus, although the algorithm has its best performance when the iso-value is changed smoothly, it still has very good performance even when the isovalue is changed abruptly. While some of the flags in the sweeping list must be examined sequentially for detecting non-intersected cells, we have found that sequential flag checking can be performed rapidly.</p><p>In general, the performance of the sweep algorithm is linearly proportional to the size of the sweeping list and also varies depending on the scalar distance between two consecutive iso-values. To avoid degenerative cases and to guarantee a good average performance when the user changes the iso-value randomly, we have developed a data decomposition scheme that divides the cell elements in the entire field into several subgroups according to the ranges of scalar values within cells. The sweep algorithm is then applied only to a subset of the entire field for a given iso-value. In the following section we discuss the data decomposition algorithm and then explain the interaction of the sweep algorithm and the decomposition scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Data Decomposition</head><p>The data decomposition scheme begins by subdividing the field's scalar range into subranges, which serve as the scalar boundaries to subdivide the cells into subgroups.</p><p>A cell is assigned to a subgroup if both its minimum and maximum extremes are within the subgroup's scalar range. Obviously, the resultant subgroups can contain only cells that do not have boundary-crossing extreme values. We classify such subgroups as the bottom level, or level 0, in our data decomposition scheme. To include those cells crossing the boundaries, we combine the scalar ranges of every pair of even and odd numbered subgroups to form a new set of scalar boundaries for subgroups at one higher level, level 1. Of course, there might still be cells crossing the group boundaries at this level, so we need to follow the same rule to create higher levels of subdivision. This process continues until we arrive at the level in which only one group has the field's entire scalar range as its boundary. In <ref type="figure">Figure 4</ref> cell A is put into group 0 at level 0. Cell B crosses the boundary of group 0 and group 1 at level 0, so it is in group 0 of level 1. Cell C crosses the boundary of group 2 and group 3 of level 1, so it is sent to group 1 of level 2. Cell D is in group 0 of level 3 because it crosses the group 0 and group 1 of level 2.</p><p>To select the initial scalar subranges, the algorithm first sorts the cells' maximumvalues into a list. It then selects the scalar ranges that can evenly subdivide the list as the scalar boundaries for the subgroups at level 0. We use the cells' maximum values to estimate and balance the size of each subgroup. For example, if 10% If each subgroup is to have a corresponding subgroup to combine with at each level, the number of subgroups at the bottom level needs to be a power of two. Assuming that we have 2N subgroups at the level 0, then there will be a total of N + 1 levels, and the total number of subgroups will be 2Nf1 -1. For a given iso-value, if this value is in the range of group G at level 0, then the value's corresponding subgroup at level K is G/2", assuming that the indices of subgroups at each level start from 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Sweeping Simplices Algorithm</head><p>After subdividing the entire set of cells into subgroups of different levels, we create first a sweeping list and then a corresponding minimum list for each subgroup by invoking the initialization method described previously. The initialization work of each subgroup can be performed right after the cells are distributed or can be delayed until the first time the group is selected for a given iso-value. The overall performance is the same either way because the initialization needs to be done only once. When a new iso-value is specified, one subgroup at each level is selected. The sweep algorithm is then invoked to find the intersected cells. <ref type="figure">Figure 5</ref> contains pseudo code that illustrates the algorithm outline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithm Analysis and Simulation Results</head><p>We have implemented our algorithms in C++. The Open Inventor libraries <ref type="bibr" target="#b4">[5]</ref> along with OpenGL <ref type="bibr" target="#b5">[6]</ref> are used to facilitate three-dimensional viewing. In this section, we discuss the effectiveness of our data decomposition scheme, the performance of the sweep algorithm, and the respective memory allocations of each. We evaluate our algorithms using four sets of for (int level=O; level&lt;MAX-LEVEL; level++) 1 { // find the target group at each level groupid = find-group( level, iso-value) ; // update minimum and sweeping lists update-lists(groupid, iso-value); // scan through the sweeping list // and reconstruct triangular surfaces find-triangle(groupid); I <ref type="figure">Figure 5</ref>: Pseudo code for the sweeping simplices algorithm. <ref type="table">Table 1</ref>: Data sizes scalar data on unstructured grids. Three data sets consist of bioelectric field problems solved using the finite element method. The fourth data set is generated from an algebraic function. The data sets range in size from thirty thousand elements to four hundred thousand elements. <ref type="table">Table 1</ref> lists the size of each data set. All simulation results were performed on a 100 MHz MIPS R4400 processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Data Decomposition Scheme</head><p>The data decomposition scheme restricts the sweep algorithm's worst case performance by subdividing the elements in the field into different levels. The elements at each level are further subdivided into several subgroups. For a given iso-value, only one subgroup at each level needs to be investigated. The total size of the matched subgroup at each level, termed the active size, is the number of cell elements involved in the sweep algorithm at a give instance in time. <ref type="figure" target="#fig_5">Figure 6</ref> shows the ratio of active sizes to the size of the entire field. We experimented with different numbers of subdivisions at the bottom level to see how the average active size is affected. Each number presented here is an average result of ten thousand executions with randomly generated iso-values.</p><p>The figure shows that our data decomposition scheme effectively subdivides the elements into several subdomains. The active sizes become smaller as we increase the number of subdivisions at the bottom level. When the number of subdivisions exceeds a certain level, the active sizes converge to a stable state. This occurs because the scalar range of each subgroup becomes too narrow to subdivide the elements effectively and thus pushes them into subgroups at a higher level. The appropriate number of subdivisions at the bottom level is empirically determined and depends primarily on the scalar value distribution of the data set. Generally, we subdivide the field in such a way that the active size is approximately l/8 -l/20 the size of the entire element set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Sweep Algorithm</head><p>Initialization:</p><p>In the initialization phase, the elements at each subgroup are sorted by their maximum and minimum values to form a minimum list and a sweeping list. In our implementation, we find the extreme value for each element when we input the scalar data and we use a quick-sort algorithm to sort the elements. <ref type="table" target="#tab_1">Table 2</ref> lists the CPU time for data input and maximum and minimum value sorting. Iso-Surface Extraction:</p><p>We divide the total isosurface extraction time into cell traversal time and surface construction time. The cell traversal process includes all the necessary work to locate the iso-surface intersected cells. The surface construction process includes the operations of cell classification and interpolation on each of the intersected cells. The cell classification process checks the values at each of a cell's vertices and maps that cell into the lookup table. The interpolation locates the vertices of triangular surfaces. For the surface construction process, our sweeping simplices algorithm spends the same time as the naive algorithm because we adopt the same divideand-conquer paradigm to locate the surface within each cell. Assuming that there are N elements in the field, that the percentage of cells intersected by the iso-surfaces is f, that the cell classification time per cell is a, and that the interpolation time per cell is b, then the execution time of surface construction for a given iso-value is:</p><p>Nf(a + 6) + C,</p><p>where C represents a constant time involved in the execution.</p><p>The cell traversal process in the sweep algorithm includes a constant time to find a matched subgroup at each level. Within each of those subgroups, binary searches for Imin and Imax, a sequential flag set, and a sequential flag checking operation are required. Assuming that there are L levels in the decomposition, that the average size for a subgroup is M, that the average time to set one flag is d, that the average time to check one flag is e, and that the binary search time for a group sized K is clog(K), then for a given iso-value, the average cell traversal time is:</p><formula xml:id="formula_1">L(2clog(M) + d(M/2) + e(M/2)) + C<label>(2)</label></formula><p>In the second and third terms of the expression, we use M/2 as the average size of nodes whose flags need to be set and checked at a time. The C is a constant time involved in the program execution.</p><p>In the naive algorithm, the cell traversal time is the cell classification time spent on those non-intersected cells, which is:</p><formula xml:id="formula_2">N(1 -j-)a + c<label>(3)</label></formula><p>To estimate constants a through e, we repeatedly performed a large number of executions and averaged the accumulation time. <ref type="table">Table 3</ref> lists our estimates for the constants. As for the average subgroup size M and number of levels L, we know from <ref type="figure" target="#fig_5">Figure 6</ref> that if we cut our data domain into 6 levels (32 subgroups at the <ref type="table">Table 3</ref>: Execution time for different operations.</p><p>bottom level), the active size is approximately 10% of the total numbers of the cells. Therefore, if we 'assign L equal to 6, then the average size of a subgroup M is approximately N . 10%. (l/L) = N/60. Substituting these constants into the performance expressions above and ignoring the constant C, we find that the naive algorithm's execution time for an isovalue is 9Nf + 5N(l-f). The execution time for the sweep algorithm is 9Nf+ 12 log( 1/60N) + 1/25N. The sweep algorithm spends the same time, 9Nf pseconds, as the naive algorithm to construct the surfaces within the surfaces-intersected cells. However, when we compare the 5N(l -f) p seconds in cell traversal time of the naive algorithm with the sweep algorithm's 121og(l/60N) + 1/25N for additional processing, we see a significant advantage. When N is large, the logarithmic term can be ignored. Unless the percentage of non-intersected cells is lower than l%, the sweep algorithm will always outperform the naive algorithm. <ref type="table">Table 4</ref> lists the average execution times for the naive algorithm and for the sweeping simplices algorithm. To demonstrate the incremental ability of our algorithm, we smoothly change the iso-value. In Table 5, we randomly select the iso-value to show our algorithm's average performance. <ref type="table" target="#tab_3">Table 6</ref> lists the savings of our algorithm for smoothly and randomly changed iso-values. Figures 7-10 depict a single isosurfaced image for each of the data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.3</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Memory Consumption</head><p>Assuming that there are M grid nodes and N tetrahedral elements in the field, the minimum space required to create a scalar field of unstructured mesh is 4N + 4M. This includes 3M words to store the grid nodes' [z, y, Z] positions, 4N words to store the connectivity information for each tetrahedron, and an additional M words to store the scalar data on each grid point. We use word as a memory unit to avoid involving implementation details. Besides the minimum space 4N + 4M required to accommodate unstructured grid data, our sweeping <ref type="table">Table 4</ref>: Execution time: Iso-value smoothly changed (in milliseconds).</p><p>simplices algorithm needs an additional 2N words to store the maximum and minimum values for each cell element, 2N words for storing the cell's indices in the nodes of minimum lists and sweeping lists, N words to store the pointers from nodes of minimum lists to sweeping lists, and N bits assigned to the flags in the sweeping list. Therefore, the additional space required by the algorithm sums to 5N words +lNbits. Considering that N is typically 4 to 5 times as large as M, the sweeping simplices algorithm requires about twice as much space as the minimum memory required to represent a scalar field on an unstructured grid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion and Summary</head><p>We have presented a fast iso-surface extraction algorithm for data on unstructured grids. The algorithm comprises two parts, a sweep algorithm and a data decomposition scheme. The sweep algorithm can incrementally locate the cells that are intersected by iso-surfaces while the data decomposition scheme can restrict the algorithm's worst case performance by decomposing the data elements into subdomains.</p><p>Currently, we are in the process of designing a better data structure that utilizes spatial coherence between iso-surfaces so we can reduce interpolation costs. In addition, we are developing a parallel version of our algorithm.     in a model of the human scalp and brain.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Surface-cell intersection geometry.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>AFigure 2 :</head><label>2</label><figDesc>cell's extreme values are defined as the maximum and minimum scalar values at the corners of the cell. Straightforwardly, only those cells that have lower minimum values and higher maximum values than a Minimum list and sweeping list after initialization.given iso-value are intersected by an iso-surface. To efficiently and accurately locate candidate cells without searching the entire set of data, one must inevitably sort the field's cell elements by extreme values. To accomplish this sorting, the sweep algorithm maintains two lists, a minimum list and a sweeping list.Each cell in the field has a corresponding node in both lists. The minimum list is sorted by the cells' minimum values, and the sweeping list is sorted by the cells' maximum values. A node in the minimum list, termed MinNode, contains a represented cell's global index and a reference to that cell's corresponding node in the sweeping list. The corresponding node in the sweeping list, SWNode, contains the represented cell's global index and a flag, indicating whether the cell's minimum value is smaller than the current iso-value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Sweep algorithm: Finding intersected cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>of cells have maximum values less than 0.1 and greater than 0.0, and a total of 20% of cells have maximum values less than 0.2, then there is a high probability that approximately 10% of cells are located in each of the ranges [O.O,O.l] and [0.1,0.2], assuming that the majority of the cells have smooth scalar transitions at their vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>5 Figure 4 :</head><label>54</label><figDesc>Data decomposition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>_._____ __ ________ ..-+ . . .._.__________........--.--.------......... -----------.---. .._ ._,_ ,,___ 5% -~---i Ratio of average active size to the entire filed size for different numbers of subdivisions at the bottom level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>An iso-surface within an algebraic scalar field.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Iso-surfaces of constant voltage from a finite element simulation of cardiac defibrillation within the ventricles of the human heart.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 .</head><label>9</label><figDesc>An iso-surface of constant voltage fromFigure 10. An iso-surface of constant voltage fron a finite element simulation of cardiac defibrillation a finite element simulation of temporal lobe epileps: within a human thorax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc></figDesc><table><row><cell>: Initialization</cell><cell>time: Data input and min/max</cell></row><row><cell>sorting (in seconds).</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 5 :</head><label>5</label><figDesc>Execution time: Iso-value randomly changed (in milliseconds).</figDesc><table><row><cell></cell><cell cols="3">Sweep algorithm savings</cell><cell></cell></row><row><cell></cell><cell>Smoothly</cell><cell></cell><cell>Randomly</cell><cell></cell></row><row><cell></cell><cell>Cell Trav.</cell><cell>Total</cell><cell>Cell Trav.</cell><cell>Total</cell></row><row><cell>Algebraic</cell><cell>99%</cell><cell>64.1%</cell><cell>93.4%</cell><cell>58.0%</cell></row><row><cell>Heart</cell><cell>99%</cell><cell>70.9%</cell><cell>95%</cell><cell>68.7%</cell></row><row><cell>Torso</cell><cell>99.5%</cell><cell>82.6%</cell><cell>97.5%</cell><cell>80.5%</cell></row><row><cell>Brain</cell><cell>99.2%</cell><cell>83.0%</cell><cell>97.2%</cell><cell>80.8%</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 6 :</head><label>6</label><figDesc>Execution savings: Iso-value smoothly and randomly changed.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 Â© 1995 IEEE</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by awards from the NIH and NSF. The authors would like to thank J. Schmidt and D. Weinstein for the biomedical simulation data. We would also like to thank C. Hansen, Y. Livnat and K. Coles for their helpful comments and suggestions. Furthermore, we appreciate access to facilities which are part of the NSF STC for Computer Graphics and Scientific Visualization.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A CM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Advanced interactive visualization for CFD. Computing Systems in Engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Giles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="51" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Span filter: An optimization scheme for volume visualization of large finite element models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wernecke</surname></persName>
		</author>
		<title level="m">The Inventor Mentor</title>
		<imprint>
			<publisher>Addison-Wesley Publishing Company</publisher>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Open GL Programming Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Neider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Addison-Wesley Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
