<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Optimization of Time-Dependent Particle Tracing Using Tetrahedral Decomposition</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">N</forename><surname>Kenwright</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Mail Stop</orgName>
								<orgName type="institution" key="instit1">Computer Sciences Corporation</orgName>
								<orgName type="institution" key="instit2">NASA Ames Research Center</orgName>
								<address>
									<postCode>T27A-2, 94035</postCode>
									<settlement>Moffett Field</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Lane</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Mail Stop</orgName>
								<orgName type="institution" key="instit1">Computer Sciences Corporation</orgName>
								<orgName type="institution" key="instit2">NASA Ames Research Center</orgName>
								<address>
									<postCode>T27A-2, 94035</postCode>
									<settlement>Moffett Field</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Optimization of Time-Dependent Particle Tracing Using Tetrahedral Decomposition</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>An efSicient algorithm is presented for computing particle paths, streak lines and time lines in time-dependent flows with moving curvilinear grids. The integration, velocity interpolation, and step size control are all perfotmed in physical space which avoids the need to transform the velocity field into computational space. This leads to higher accuracy because there are no Jacobian matrix approximations, and expensive matrix inversions are eliminated. Integration accuracy is maintained using an adaptive step size control scheme which is regulated by the path line curvature. The problem of point location and interpolation in physical space is simplified by decomposing hexahedral cells into tetrahedral cells. This enables the point location to be done analytically and substantially faster than with a Newton-Raphson iterative method. Results presented show this algorithm is up to six times faster than particle tracers which operate on hexahedral cells and produces almost identical traces.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Unsteady particle tracing is a relatively new visualization technique that has emerged because of the need to visualize unsteady or time-dependent datasets. Whereas steady-state flow simulations only require one set of grid and solution data to describe a flow, unsteady flow simulations may comprise of hundreds or thousands of time steps of data; each having an associated grid and solution file. The size of these datasets can run into hundreds of gigabytes <ref type="bibr">[ 1,</ref><ref type="bibr" target="#b1">2]</ref>.</p><p>The techniques used for visualizing unsteady flows in experimental fluid mechanics include path lines, time lines and streak lines. They are generated by injecting foreign material such as particles, dye or smoke into the fluid l path line: generated by tracing the path of a single particle (also called a particle path). l rime line: generated by tracing a line of particles which are all released at the same time.</p><p>l streak line: generated by continuously injecting particles from a fixed location.</p><p>In this study we were interested in generating streak lines from large time-dependent computational fluid dynamics (CFD) simulations. In computational flow visualizaltion, streak lines are generated by releasing particles at discrete intervals, usually in accordance with the simulation time steps. This continuous injection leads to a rapid growth of the number of particles in the flow, all of which must be tracked until they leave the flow-field or until the simulation ends, which ever comes first. It is not uncommon for there to be several thousand active particles in an unsteady flow, so it is essential that the advection or tracing process is as efficient as possible.</p><p>A time-accurate particle tracing algorithm is presented in this paper which offers improved scalar performance without sacrificing accuracy. The algorithm can be used to compute path lines, time lines, or streak lines in structured or unstructured grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Previous work</head><p>Many algorithms have been presented for particle tracing in steady flows yet relatively few consider the extension to unsteady flows. This extension is not always trivial because the time varying nature of the flow and grid adds complexity to almost every part of the algorithm <ref type="bibr" target="#b1">[2]</ref>. Also, techniques used to speed-up steady flow algorithms, such as loading the entire solution into memory or preevaluating computational space velocities, are not possible with large time-dependent datasets.</p><p>To improve particle tracing performance, <ref type="bibr">Shirayama [3]</ref> transformed the velocity vector field into a uniform (computational) space and decomposed hexahedral cells into tetrahedra. The particles were then traced in computational space. Shirayama's approach significantly reduces the number of calculations although accuracy suffers because of approximations made in the transformation to computational space. This problem is discussed further in section 3.</p><p>Signjiiicant gains in performance can be achieved by particle tracing on parallel <ref type="bibr">[4,</ref><ref type="bibr">5]</ref> and multi-processor systems 1163. Particle tracing is easily parallelized since each particle can be traced independently. The algorithm presented here improves scalar performance although could be parallel&amp;d to achieve even greater speed-ups.</p><p>(See color plates, page <ref type="bibr">W-38)</ref> 3. Physical vs computational space Particle tracing algorithms for structured curvilinear grids can divided into those that trace in computational space and those that trace in physical space. Computational space schemes require the curvilinear grid and the associated velocity field to be mapped onto a uniform rectangular grid using Jacobian transformations. This can either be done as a preprocessing step for the whole grid <ref type="bibr">[7]</ref> or locally on-the-fly as required by the tracking process <ref type="bibr">[8]</ref>. Particles are then advected in the logical grid space rather than in physical space.</p><p>The main disadvantage of tracing in computational space is that the transforming Jacobian matrices are only approximations and so the transformed vector field may be discontinuous. Also, if there are irregularities in the grid, such as cells with collapsed edges, the transformed velocities may be infinite <ref type="bibr">[9]</ref>. Analyses by <ref type="bibr">Sadarjoen et al. [lo]</ref> and <ref type="bibr">Hultquist [ll]</ref> in steady flows have shown that this mapping technique produces significant errors in distorted curvilinear grids. Calculating Jacobian matrices in unsteady flows with moving grids is more inaccurate because each matrix has three additional time-dependent terms which must be approximated <ref type="bibr">[12]</ref>.</p><p>Physical space tracing schemes are more accurate because the interpolation and integration processes are done in Cartesian space which eliminates the need to evaluate Jacobian matrices and transform the velocity field. The only disadvantage is that the task of locating particles is more complicated and hence more expensive. This problem is addressed in this paper. An explicit point location technique is presented which has yielded a significant speed-up over the most common point location technique: the Newton-Raphson iterative method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Physical space tracing algorithm</head><p>Physical space tracing algorithms proceed by firstly searching out the element or cell which bounds a given point. This is termed the cell search or point locution process. Once found, the velocity is evaluated at that point by interpolating the nodal velocities. In unsteady flows, the velocity components usually need to be interpolated temporally as well as spatially. This necessitates loading two or more time steps of data into memory. Intermediate positions of the grid may also have to be interpolated if the grid changes in time. The particle's path is determined by solving the differential equation for a field line:</p><formula xml:id="formula_0">dr iii = v( mt &gt; (1)</formula><p>where r is the particle's location and v the particle's velocity at time t. Integrating (1) yields:</p><formula xml:id="formula_1">r(t+At) = r(t) + / '+*'v( r(t),t &gt; dt (2) t</formula><p>The integral term on the right hand side of this equation can be evaluated numerically using a multi-stage method (e.g., Runge-Kutta, Bulirsch-Stoer) or a multi-step method (e.g., Backwards differentiation, Adams-Bashforth). Issues concerning the accuracy and stability of these methods are discussed by <ref type="bibr">Darmofal and Haimes [13]</ref>. Regardless of how it is solved, the end result is a displacement which when added to the current position, r(t), gives the new particle location at time t+At.</p><p>The essential steps in a time-dependent particle tracing algorithm are as follows:</p><p>1. Specify the seed point for a particle in physical space, (x,y,z,t). 2. Perform a point location to locate the cell that contains the point. 3. Evaluate the cell's velocities and coordinates at time t by interpolating between simulation time steps. 4. Interpolate the velocity field to determine the velocity vector at the current position, (x,y,z). 5. Integrate the local velocity field using equation <ref type="formula">2</ref>to determine the particle's new location at time t+At. 6. Estimate the integration error. Reduce the step size and repeat the integration if the error is too large. 7. Repeat from step 2 until particle leaves flow field or until t exceeds the last simulation time step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Point location in tetrahedral cells</head><p>The core problem in all particle tracers is: given an arbitrary point x in physical space, which cell does this point lie in and what are its natural coordinates. The natural coordinates are local non-dimensional coordinates (see <ref type="figure" target="#fig_0">Figure 1</ref>) and are different from the computational coordinates which are globally defined.</p><p>The widely used trilinear interpolation function (3) provides the opposite mapping to that required, that is, it determines the location of x from a given natural coordinate (@l,&lt;). Unfortunately, equation <ref type="formula">3</ref>cannot be inverted analytically because of the non-linear products, so it has to be solved numerically using an iterative scheme such as the Newton-Raphson method.</p><formula xml:id="formula_2">x(%rlL) = 1 (x,(1-Q + x,,,~U-T)) + bolo(l-El + xllom 1(1-O + [ boo&amp;l-El + "&amp; x1-w + (x()Jl-~~ + Xl&amp;l IC (3)</formula><p>An alternative point location scheme has been developed based on tetrahedral elements which allows the natural coordinates to be evaluated directly from the physical coordinates. The mathematical basis of this method will now be described. The simplest interpolation function for tetrahedral cells is a linear one of the type in equation <ref type="formula" target="#formula_3">4</ref>. It has four coefficients which, in this case, are expressed in terms of the nodal positions. The natural coordinates &lt;@l&amp;J are taken as per usual to vary from 0 to 1 in the nondimensional cell (see <ref type="figure" target="#fig_0">Figure 1</ref>).</p><p>x@lJJ</p><formula xml:id="formula_3">-Xl + (xp&amp; + (x3-qbl + bq-Xl)6<label>(4)</label></formula><p>This function does not have any non-linear terms like the trilinear function and can therefore be inverted analytical1 y. This is done by expanding and rearranging (4) into the matrix form below. Note that xr, yr, and zP are the coordinates of a given physical point and x1, yl, zi,... etc. are the physical coordinates at the vertices of the tetrahedron.</p><p>This system of equations can be solved by inverting the 3x3 matrix on the right and then premultiplying it with the vector on the left. The end result can be written as:</p><p>where the constants in the 3x3 matrix are given by:  and the determinant, V (actually 6 times the volume of the tetrahedron), is given by:</p><formula xml:id="formula_4">a,, = (Q-zi)(ys-y4) -(x+J(Y4-YJ a21 = (z&amp;(y,-y2) -(Z&amp;(Y4-Y1) a31 = (Z2-z3)(y1-)'2) -(z1-z2)(Y2-Y3) a12 = (x4-xJz3-ZJ -(x3-x4&amp;-q) a22 = (x4-x&amp;-z2) -(xp&amp;4-74 a32 = (X2-K&amp;-ZJ -(X1-X2Xz2-z3) a13 == (Y4-YJ(X3-X4&gt; -(Y3-Y4xx4-xI&gt; %,, q = (Y4-YJ(XpJ - (Yl-Y2xx'&amp; $3 =: (Y2-Y3)(XImQ -(Y1</formula><formula xml:id="formula_5">v = (x,-x,x (Y3-Y1)(zq-z1)-(zj-z1)(Y4-Y1) 1 + f@3+4[ (Y~'Y~)(z4-z~)~zI-z2)(Y~-YI) 1 + ~CXq-X1)[ (Y~'YI&gt;(Z~-ZI&gt;-(Z~-~~)(Y~-Y~) 1</formula><p>The natural coordinates (E,q,&lt;) can be evaluated in 104 floating point operations by implementing the equations above. This figure can be halved by precomputing common terms before evaluating the matrix coefficients and determinant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Tetrrahedral decomposition</head><p>Equat.ion (6) can be applied directly to unstructured grids containing tetrahedral cells. However, structured curvilinear grids containing hexahedral cells or hybrid grids containing mixed element types must be decomposed into tetrahedra in order to use it. Since the datasets for time-dependent flows are usually extremely large, it is impractical to do the decomposition as a preprocessing step. It must therefore be performed locally as particles enter cells,, A hexahedral cell can be divided into a minimum of five tetrahedra ( <ref type="figure" target="#fig_1">Figure 2</ref>). This decomposition, however, is not unique because the diagonal edges alternate across a cell. Since the faces of a hexahedron are usually nonplanar, it is important to ensure that adjoining cells have matching diagonals to prevent gaps. This is achieved by alternating between an odd and even decomposition as illustrated in <ref type="figure" target="#fig_1">Figure 2</ref>. In a structured grid, the correct configurat.ion is selected by simply adding up the integer indices of a specific node (the node with the lowest indices was used in practice). Choosing the odd configuration when the s,um is odd and the even configuration when the sum is even guarantees continuity between cells. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Cell-search scheme</head><p>The previous sections discussed how to sub-divide hexahedral cells into tetrahedra and how to evaluate the natural coordinates of points within them. Those concepts are now combined with an efficient point location scheme to produce a cell-search technique which locates the tetrahedron that bounds the physical <ref type="figure">point (xr,,y,,z,)</ref>.</p><p>Equation <ref type="formula">6</ref>allows the natural coordinates to be evaluated directly from the physical coordinates with relatively little effort. There are four conditions which must be valid for the point <ref type="figure">(xp,y,,z,)</ref> to lie within the tetrahedron. They are:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>520</head><p>: q120 : (20 : l-C-Tl-&lt;&gt;O</p><p>If any one of these conditions is invalid then the point is outside the tetrahedron. In particle tracing algorithms, this happens when particles cross cell boundaries. The problem arises then of which tetrahedron to advance to next. The solution is quite simple since the natural coordinates tell you which direction to move. For example, if &amp;O, the particle would have crossed the I$=0 face. Similarly, if qc0 or c&lt;O, the particle would have crossed the q=O or &lt;=O face respectively. If the fourth condition is violated, i.e. (1-E-q-&amp;O, then the particle would have crossed the diagonal face. The cell-search proceeds by advancing across the respective face into the adjoining tetrahedron. Occasionally, two or more conditions in (7) may be violated if a particle crosses near the comer of a cell or if it traverses several cells at once. In such cases, the worst violator of the four conditions is used to predict which next tetrahedron to try next. Even if the bounding tetrahedron is not found in the immediate neighbour, by always moving in the direction of the worst violator it will converge upon the correct cell. The cell search procedure described above should only be used if the cell being sought is nearby, that is, within a few cells of the previous one. This is usually the case during particle tracing since the majority of particles only cross one cell at a time. There are, however, two situations when the cell being sought is not likely to be nearby, these being: i) at the start of a particle trace and ii) after jumping between grids in multi-grid datasets. Under these circumstances the cell search should be preceded by another scheme in order to prevent weaving across a large grid one tetrahedron at a time. We use the 'boundary search' technique described by <ref type="bibr">Buning [ 151.</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Velocity interpolation in tetrahedra</head><p>The velocity components must be evaluated whenever a particle changes position or whenever the integration time step changes. They can be interpolated on the geometric cell in physical space using linear interpolation [ 141 or volume weighting [ 151, or on the unit cell in nondimensional space using linear basis functions <ref type="bibr">[16]</ref>. All three have been assessed in the present study and shown to be equivalent, i.e., they produce identical interpolation functions. However, one of them is much more efficient and ties in with point location algorithm already described.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Physical space linear interpolation</head><p>The physical space linear interpolation function can be written as:</p><formula xml:id="formula_7">u(x,y,z) = aU+b,,x+cUy+dUz<label>(8)</label></formula><p>where u is one of the three velocity components and x, y, z the Cartesian coordinates. The constants a,, b,, c, and d, are evaluated by substituting the known values of u, x, y and z at each of the nodes into this expression. The resulting set of simultaneous equations can be written as:</p><formula xml:id="formula_8">1-l I = 1 Xl Yl Zl 1 x2 Y2 z2 1 x3 Y3 z3 1 x4 Y4 z4 ii Ul u2 u3 I (9 u4</formula><p>where ul, u2, u3, and u4 are the velocity components at each of the four nodes. Note that the constants a, b, c, and d differ for each velocity component but the 4x4 matrix is the same for all because it only depends on the cell geometry. It turns out that nine of the coefficients in the inverted 4x4 matrix are identical to those in equation (6). Using this approach, the velocity components can be evaluated in approximately SO floating point operations assuming that the matrix coefficients are reused from the point location scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Volume weighted interpolation</head><p>Volume weighting is a more popular interpolation technique and has been used in several particle tracing algorithms <ref type="bibr">[10,</ref><ref type="bibr">15]</ref>. The interpolation strategy is to use the volumes of four sub-tetrahedra as weights applied to the velocity components at each node. These subtetrahedra are created by connecting the interpolation point, P say, to the four comers of the original tetrahedron. The ratio of the volume of each subtetrahedron to the volume of the whole tetrahedron gives the weight assigned to the vertex opposite the subtetrahedron. Using the notation in <ref type="figure" target="#fig_0">Figure 1</ref>, the volume weighted interpolation function at point P is given by:</p><formula xml:id="formula_9">UP = Ul v432P V134P -+ uz- v421P v1234 v1234 + u3 -+u4 v1234</formula><p>The volume of a generic tetrahedron, VAucn, is given by:</p><formula xml:id="formula_10">V *B(JD -$6. L&amp;d)<label>(11)</label></formula><p>By expanding equation <ref type="formula">10</ref>using the volume definition in (1 l), it can be shown that this interpolation function is identical to the previous one. However, it takes 192 floating point operations to evaluate the four weights in equation <ref type="formula">10</ref>which makes it more expensive than the previous linear interpolation technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Linear basis function interpolation</head><p>The third and most popular technique for interpolating within a tetrahedron is the linear basis function approach. Using the same node numbering as before, the linear basis function can be written as:</p><formula xml:id="formula_11">u&lt;5Jl*6&gt; = q + (u&amp;5 + (U3-Ulh + (u,-u,&gt;T<label>(12)</label></formula><p>where 5, rl and C, are the coordinates in the transformed tetrahedron (see <ref type="figure" target="#fig_0">Figure 1)</ref>. By substituting the expressions for E, ?l, and &lt; from equation <ref type="formula">6</ref>into <ref type="formula" target="#formula_11">12</ref>, it can be shown that this interpolant is identical to that in (9). That is, both the linear physical and linear basis interpolation functions give the same interpolation result.</p><p>Since the natural coordinates are evaluated as part of the point location scheme, it is clearly more efficient to use the linear basis functions to evaluate the velocity components than either of the other two methods. The velocity components can be computed in just 27 floating point operations by using linear basis functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Numerical integration scheme</head><p>The numerical integration of equation <ref type="formula">2</ref>was performed with a standard 4th order Runge-Kutta scheme which comprises of the following stages:</p><formula xml:id="formula_12">a = v(r(t),t)At b = v(r(t)+$t+$)At c = v( r(t)+, t+$) At d = v( r(t)+c, t+At &gt; At r(t+At) = r(t)+i(a+2b+2c+@ (13)</formula><p>where r is the particle position, v the velocity vector at that position, and At the time step which is set by the adaptive step size procedure described in the following section. A consequence of multi-stage schemes such as this one is that the velocities (and grid positions in a moving grid) must be frequently interpolated between the simulation time steps. In past [ 171 and present algorithms, these quantities are linearly interpolated. <ref type="bibr">Darmofal and Haimes [13]</ref> have shown that linear interpolation in time reduces the temporal accuracy of the Runge-Kutta scheme from 4th to 2nd order. The four stages of the Runge-Kutta scheme span three time values (t, t+At/2, and t+At) and therefore require new grid and velocity data at each one. Fortunately, these only need to be interpolated in the cell surrounding a particle. However, because a particle moves in time and space during thLe integration, it may lie in different cells at different stages of the integration, so point location is required after each stage.</p><p>There is an important difference in the way the integration is governed in unsteady flows compared with steady flows. In steady flows the integration is usually governed by the grid geometry, that is, particles are traced from one face to another across a cell. In unsteady flows the integration is governed by time and proceeds from one time step to the next. The point location and velocity interpolation procedures are called from the Runge-Kutta scheme as required.</p><p>Step size adaption occurs after each complete integration step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Curvature-based step size adaption</head><p>If the integration step size is fixed at a constant value along the entire particle path, or regulated to achieve a specified number of steps-per-cell, a particle may understeer around bends if the flow changes direction rapidly. This can be prevented by using an adaptive step size control scheme where the integration step size is changed according to an error tolerance.</p><p>The error tolerance can be computed using a standard numerical technique such as step doubling [ 181 whereby a particle is advanced forward from a given point using a step size At and then the process is repeated from the same point using two half steps of size At/2. The step size is reduced if the distance between the end-points is greater than a specified tolerance; a number usually deduced by trial and enor.</p><p>We ilmplemented the step doubling algorithm and tested it in several flows. The step size adaption worked well, particularly in the vicinity of critical points, although tihe performance was worse than a scheme which used 5 ste:ps-per-cell. That was because the step doubling algorithm performed approximately twice the number of numerically expensive point locations.</p><p>A heuristic technique for adapting step size was suggested by <ref type="bibr">Darmofal and Haimes [19]</ref>. They measured the angle between velocity vectors at successive points along a particle path to estimate the change in velocity direction. If the velocity direction changed too much (over 15 degrees) the step size was halved, whereas if it changed too little (less than 2 degrees) the step size was doubled.</p><p>We implemented this scheme and a very similar one which measured the angle between successive line segments on the path line ( <ref type="figure">Figure 3)</ref>. The latter scheme adapted the step size according to the path line curvature. Step adaption is based on the pathline curvature.</p><p>Both of these schemes worked well in practice and ran approximately three times faster than the step doubling algorithm. In both cases, the initial step size was estimated using: <ref type="formula">14</ref>where lul is the magnitude of the velocity at the current position and V is the determinant from equation <ref type="formula">6</ref>. Following this initial estimate, the step size was halved if the angle 6, was too acute (8,&gt;15"), doubled if it was too obtuse (0,~ 3"), or kept the same if it was in between these limits ( 3'10,I</p><p>15"). Through experimentation in several datasets we found the curvature-based algorithm produced similar particle traces to the step-doubling scheme when adaption angles of 15 degrees (upper limit) and 3 degrees (lower limit) were used. The curvature-based algorithm produced particle traces of superior accuracy when the upper limit was lowered below 12 degrees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Performance evaluation</head><p>The performance of the tetrahedral algorithm was compared with a conventional hexahedral algorithm <ref type="bibr">[17]</ref> in two time-dependent datasets. The conventional algorithm used trilinear functions for spatial and velocity interpolation and an iterative Newton-Raphson method for point location. Both algorithms used 4th order Runge-Kutta integration schemes but used different step adaption techniques. The conventional algorithm used a semiadaptive (5 steps-per-cell) scheme whereas the tetrahedral algorithm used the heuristic curvature-based method.</p><p>The missile dataset <ref type="table" target="#tab_0">(Table 1)</ref> comprised of a single static grid with 500,OOCl grid points and 795 time-varying velocity fields. Each velocity field was approximately 4 MB (Megabytes) in size which yielded a total of 3.3 GB (Gigabytes) for the entire dataset. Sixteen particles were released at each simulation time step.</p><p>The V-22 tiltrotor dataset consisted of 26 grids (9 of which moved) containing 2.5 million grid points. We used 140 out of a total 1,400 simulation time steps, each one consisted of 100 MB of data. There were 120 particles released at each time step resulting in over 15,000 active particles being traced by the end of the simulation. The execution times shown in <ref type="table" target="#tab_0">Tables 1 and 2</ref> have been divided up into the main algorithmic tasks and are given in both seconds and as a percentage of the total execution time. Computations were performed on a Convex 3420 with a striped disk system (16 heads).   <ref type="table" target="#tab_0">Table 1</ref> shows that the tetrahedral algorithm ran about six times faster than the hexahedral algorithm in the missile dataset. Every aspect of algorithm is more efficient although the most significant gain comes from the velocity interpolation. This is because the point location and velocity interpolation are closely coupled in the new tetrahedral algorithm and the majority of the work, namely, computing the natural coordinates (@l,c), is done during the point location.</p><p>In the V-22 dataset <ref type="table">(Table 2)</ref>, the speed advantage of the tetrahedral algorithm was obscured because of the addition of grid jumping: the process by which particles cross grids in a multi-grid dataset. Grid jumping is an infrequent process, it occurs on average once every 1,000 point locations, yet it takes the majority of the execution time in this case (57.4%). Results from the hexahedral algorithm show that the point location and velocity interpolation are the most expensive tasks, grid jumping is much less significant taking only 11% of the execution time. Clearly, the performance of the new tetrahedral algorithm could be significantly improved in multi-grid datasets with faster grid jumping code.</p><p>Future work will involve testing alternative grid jumping schemes such as the donor-receiver point method <ref type="bibr">[20]</ref> in which a pre-computed look-up table is used to predict where a particle 'lands' after a grid jump. <ref type="table">Table 2</ref>. Breakdown of execution times for the tetrahedral and hexahedral algorithms in a multi-zone dataset.</p><p>Plates 1 and 2 show stills at time steps 550 and 654 from an animation of streak lines flowing around the missile. Streak lines generated using both the hexahedral (magenta dots) and tetrahedral (cyan lines) algorithms are shown in these pictures. As can be seen, there is virtually no difference between the particle paths generated by each algorithm.</p><p>Plates 3 and 4 show stills from an animation of the V-22 at time steps 56 and 140. The particles could not be rendered as streak lines because the flow was turbulent and had a great deal of recirculation which made it difficult to connect the points. Particles were released from a fixed location above the rotor blades which resulted in the distinct gaps as the blades cut through the descending sheet of particles. Considering the turbulent nature of this flow, there is very good agreement between particles computed with the tetrahedral and hexahedral algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Tetrahedron geometry in natural (nondimensional) and physical coordinate spaces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Subdivision alternates between two configurations to ensure continuity between cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure</head><label></label><figDesc>Figure 3. Step adaption is based on the pathline curvature.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Break-down of execution times for the new tetrahedral algorithm and a conventional hexahedral algorithm in a single-zone dataset. Times are given in seconds and as a percentage of the total execution time.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1070">-2385195 $4.00 0 1995 IEEE Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Carl Hsieh of the Naval Surface Warefare Center provided the missile dataset and Robert Meakin of Overset Methods Inc. provided the V-22 dataset. We thank Michael Gerald-Yamasaki for the simple technique he suggested for choosing the appropriate cell sub-division, and all our other colleagues in the NAS Division for providing ideas and information. This work was supported by NASA under contract NAS 2-12% 1.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Plate 1. Streak lines from the missile dataset at time steps 550 and 654. Cyan lines depict those generated by the tetrahedral algorithm and magenta dots (unconnected for clarity) depict those by the hexahedral algorithm.</p><p>Plate 2. Time-dependent particle traces from the V-22 tiltrotor dataset at time steps 56 and 140. Particles generated by the tetrahedral and hexhedral algorithms are coloured cyan and magenta respectively.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Software Model for Visualization of Large Unsteady 3-D CFD Results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Globus</surname></persName>
		</author>
		<idno>AIAA 95-0115</idno>
	</analytic>
	<monogr>
		<title level="m">AIAA 33rd Aerospace Sciences Meeting and Exhibit</title>
		<meeting><address><addrLine>Reno</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lane</surname></persName>
		</author>
		<title level="m">Scientific Visualization of Large Scale r31</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nielson</surname></persName>
		</author>
		<title level="m">Unsteady Fluid Flow, Scientific Visualization: Surveys, Methodologies and Techniques</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Processing of Computed Vector Fields for Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shirayama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Physics</title>
		<imprint>
			<biblScope unit="volume">106</biblScope>
			<biblScope unit="page" from="30" to="41" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Vectorized Particle Tracer For Unstructured Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes ; R</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lohner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ambrosiano</surname></persName>
		</author>
		<idno>AIAA 94-0321</idno>
	</analytic>
	<monogr>
		<title level="m">pv3: A Distributed System for Large-Scale Unsteady CFD Visualization</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="22" to="31" />
		</imprint>
	</monogr>
	<note>AIAA 32nd Aerospace Sciences Meeting and Exhibit</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lane</surname></persName>
		</author>
		<title level="m">Parallelizing a Particle Tracer for Flow Visu;alization, Proceedings from the Seventh SIAM Conference on Parallel Processing for Scientific Comlputing</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="784" to="789" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Virtual Wiudtunnel: An Environment for the Exploration of Three-dimensional Unsteady Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bryson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Levit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Stream 3D: Computer Graphics Program for Streamline Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eliasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Oppelstrup</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rizzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Engineering Software</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="162" to="168" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Sources of Error in the Graphical Analysis of CFD Results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Scientific Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="164" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Particle Tracing Algorithms for 3-D Curviliuear Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sadarjoen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Van Walsum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Eurographics Workshop on Visualization in Scientific Computing, Restock</title>
		<meeting>the 5th Eurographics Workshop on Visualization in Scientific Computing, Restock<address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Interactive Numerical Flow Visualization Using Stream Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hultquist</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-05" />
		</imprint>
		<respStmt>
			<orgName>University of North Carolina at Chapel Hill</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Efficient Solution Methods for Navier-Stokes Equations, Lecture notes from the von Karman Institute for Fluid Dynamics Lecture Series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pulliam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-01" />
			<biblScope unit="page">78</biblScope>
			<pubPlace>Belgium</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Analysis of 3-D Particle Path Integration Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dalrmofal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 AIAA CFD Meeting</title>
		<meeting>the 1995 AIAA CFD Meeting</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chung</forename></persName>
		</author>
		<title level="m">Finite Element Analysis iu Fluid Dynamics</title>
		<imprint>
			<publisher>McGraw Hill</publisher>
			<date type="published" when="1977" />
			<biblScope unit="page" from="60" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Burring</surname></persName>
		</author>
		<title level="m">Compuer Graphics and Flow Visualization in Computational Fluid Dynamics, von Karman Institute for Fluid Dynamics Lecture Series</title>
		<imprint>
			<date type="published" when="1989-09" />
			<biblScope unit="page" from="1989" to="1996" />
		</imprint>
	</monogr>
	<note>Numerical Algorithms iu CFD Post-Processing</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The Finite Element Method Displayed</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dhatt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Touzot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<publisher>Wiley</publisher>
			<biblScope unit="page" from="110" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lane</surname></persName>
		</author>
		<title level="m">Visualization of Time-Dependent Flow Fields, Proceedinrrs of Visualization &apos;93</title>
		<imprint>
			<publisher>IEEE Commuter Socieity P&amp;s</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="32" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>F'ress</surname></persName>
		</author>
		<title level="m">Numerical Recites</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<biblScope unit="volume">986</biblScope>
			<biblScope unit="page" from="554" to="560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Visualization of 3-D Vector Fields: Variations on a Stream</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Darmofal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
		<idno>AIAA 92-0074</idno>
	</analytic>
	<monogr>
		<title level="m">AIAA 30th .Aerospace Sciences Meeting and Exhibit</title>
		<meeting><address><addrLine>Rena, Nevada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Improving the Performance of Particle Tracing in Curvilinear Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hultquist</surname></persName>
		</author>
		<idno>AIAA 94-0324</idno>
	</analytic>
	<monogr>
		<title level="m">AIAA 32nd Aerospace Sciences Meeting and Exhibit</title>
		<meeting><address><addrLine>Reno, Nevada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-01" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
