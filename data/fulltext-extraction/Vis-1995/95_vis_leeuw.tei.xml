<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Enhanced Spot Noise for Vector Field Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willem</forename><forename type="middle">C</forename><surname>De Leeuw</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Netherlands Energy Research Foundation ECN Faculty of Technical Mathematics and Informatics F!O</orgName>
								<orgName type="institution">Delft University of Technology</orgName>
								<address>
									<postBox>Box 1, P.O.Box 356</postBox>
									<postCode>1755 ZG, 260O AJ</postCode>
									<settlement>Petten, Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarke</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Netherlands Energy Research Foundation ECN Faculty of Technical Mathematics and Informatics F!O</orgName>
								<orgName type="institution">Delft University of Technology</orgName>
								<address>
									<postBox>Box 1, P.O.Box 356</postBox>
									<postCode>1755 ZG, 260O AJ</postCode>
									<settlement>Petten, Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Enhanced Spot Noise for Vector Field Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Spot noise is a technique for texture synthesis, which is very useful for vector field visualization. This paper describes improvements and extensions of the basic principle of spot noise. First, better visualization of highly curved vectorjields with spot noise is achieved, by adapting the shape of the spots to the local velocity field. Second, filtering of spots is proposed to eliminate undesired low frequency components from the spot noise texture. Third, methods are described to utilize graphics hardware to generate the texture, and to produce variable viewpoint animations of spot noise on su$aces. Andfourth, the synthesis of spot noise on grids with highly irregular cell sizes is described.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Although numerous techniques have been proposed [ 11, vector field visualization remains a challenging subject. Most methods use mappings of the vector field to shape and color. Texture is a visual primitive that has been much less explored. An advantage over other techniques is that texture can give a continuous view of a 2D field opposed to discrete positions, as with arrow plots or streamlines.</p><p>This paper is based on earlier work of van Wijk <ref type="bibr" target="#b1">[2]</ref>. We will refer to the technique described in that paper as standard spot noise. A texture can be characterized by a scalar function f of position x. A spot noise texture <ref type="bibr" target="#b1">[2]</ref> is defined as f(x) = c aiqx -Xi),</p><p>in which h(x) is called the spot function. It is a function everywhere zero except for an area that is small compared to the texture size. ai is a random scaling factor with a zero mean, xi is a random position. In non-mathematical terms: spots of random intensity are drawn and blended together on random positions on a plane (figure 1).</p><p>The use of a spot as a basis for a texture has two nice consequences. First the shape of the spot determines the characteristics of the texture; the appearance of the texture can be controlled by the shape of the spot. Different textures result from different spot shapes. Second, local control of the texture is possible. Vector fields can be effectively visualized, if the shape of the spot is adapted to the data at the position of the spot (figure 2). Other texture synthesis techniques for vector field visualization are texture splats <ref type="bibr" target="#b2">[3]</ref> and Line Integral Convolution (LIC) <ref type="bibr" target="#b3">[4]</ref>. Texture splats are small textures used for volume rendering. They can be adapted to show vector fields by slight disturbance of the reconstruction function used to generate the splat. LIC was proposed by Cabral and Leedom <ref type="bibr" target="#b3">[4]</ref> and extended by Forssell <ref type="bibr" target="#b4">[5]</ref>. A LIC texture is generated by convolution of an input texture with a one dimensional filter kernel, aligned with the streamline through the filter center.</p><p>Experiments with standard spot noise showed that it gives satisfactory results in many cases, but in some cases problems occur. In areas where the curvature of the vector field is high, the texture does not show the vector field very well. A better representation of highly curved vector fields using spot bending will be described in section 2. In section 3 filtering of spots is discussed, to remove undesired low-frequency components from the texture. Section 4 deals with implementation problems of spot noise. We will describe techniques to accelerate the texture synthesis of spot noise by using graphics hardware. In section 5 we describe a general technique to generate spot noise textures for highly non-uniform grids. Examples of enhanced spot noise are presented in section 6. Finally, the conclusions can be found in section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Spot bending</head><p>In standard spot noise the spots are rotated and scaled to reflect the local flow. First the spot is aligned with the flow direction by a rotation, then it is scaled. In the direction of the flow it is scaled proportional to 1 + /VI and perpendicular to the flow by l/(1 + [vi), where /VI is the velocity magnitude. This scaling ensures that the total area of the spot and thus the average spot density in the texture remains constant. A zero velocity results in a round spot.</p><p>The spot influences a region in the texture while its shape is based on data at a single point. If the velocity varies strongly over this region, the shape of the spot does not reflect the data properly. The result is a blurred texture (figure 4). The solution of using smaller spots would only partially solve the problem, for there are always cases in which the velocity gradient is too high to be well represented by a spot of a certain size.</p><p>For a better representation of the flow field we need deformation of the spot such that a better representation of the flow field is achieved. Cabral and Leedom suggested using a stream line to warp the major axis of an elliptical spot <ref type="bibr" target="#b3">[4]</ref>. This results in a correct representation of the flow along a stream line. However, because the spot is 2D, not only effects of curvature have to be taken into account, but also effects of convergence and divergence of the flow.  The stream surface is generated as follows: the velocity v at the center of the spot is determined. Next, a rake is positioned perpendicular to the velocity. The length of the rake 1, is defined by 1 zT=wl+lv17 <ref type="bibr" target="#b1">(2)</ref> where [VI is the velocity magnitude at the center of the spot, and w a factor that determines the size of the spot with respect to the texture. The length of the rake is equal to the width of a standard spot, inversely proportional to the velocity magnitude. From the rake, streamlines are traced forward and backward at regular intervals. While the width of the spots is reduced according to the velocity(equation 2), the length of the spot I, is increased, such that the total area of the spot is constant:</p><formula xml:id="formula_1">1,1, = w2.<label>(3)</label></formula><p>Hence the total time interval T for which the stream surface is traced is Note that this is an approximation, since we assume here that the velocity magnitude does not change over the surface of the spot. However due to the conservation of mass the spot area will not change. For example, if the velocity decreases along the stream line the length of the spot will decrease but also it will get wider due to conservation of mass, and thus the area will not change. The streamlines are traced forward and backward for an equal time interval: T/2. The mesh of triangles resulting from the stream surface generation is rendered using the spot as a texture.</p><p>The effect is clearly visible in the vertical flow in figure 4. If standard spots are used, the center of the vortex looks cluttered and the velocity cannot be deduced from the texture. The picture generated using bent spots at a resolution of 16 in the w-direction and 8 in the u-direction gives a good result even very near to the vortex core.</p><p>Synthesis of bent spots is expensive because streamlines have to be traced and a mesh must be rendered for each spot. For performance reasons we implemented an option of conditional spot bending. The difference between a bent spot and a standard spot is determined by the change of velocity over the surface of the spot. In regions where the velocity changes are small, the difference between a standard spot and a bent spot is also small. We use the difference vectors between the velocity vector in the center of the spot and those at the four corners to decide if a bent spot or a standard spot should be used. Bent spots are rendered if the magnitude of the largest difference vector is larger than one tenth of the length of the spot. In experiments this value proved to result in a good balance between image quality and rendering speed.</p><p>As shown in <ref type="bibr" target="#b1">[2]</ref> spot noise can also be generated by convolution of white noise with the spot function. From this fact it can be seen that LIC with white noise as input is very similar to spot noise using adaptive spots. LIC uses a one dimensional convolution kernel along a streamline. If we reduce the dimension of the spot function perpendicular to the flow to zero and use a spot of fixed length the result would be equal to LIC. In this case the shape of the (one dimensional) spot in spot noise is the equivalent of the shape of the convolution filter in LIC. However, the additional options in spot noise allow us to visualize the magnitude of the how.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Spot filtering</head><p>Spot noise pictures often have a coarse, low-frequency component. This component is not related to the shape of the spot, but only to its size. Irrespective if we use circular or a square spots , this low frequency component remains. If we can remove it, changing the shape of the spot will have more effect, and details in the texture will stand out more clearly. Because the power spectrum of a single spot and the resulting texture are equal, removal of the low frequencies from a spot results in textures without the undesired low frequencies. To remove low frequencies from a spot it is prefiltered with a high-pass filter.</p><p>As a high-pass filter f (z, y) we used a negative Gaussian with an impulse at the origin (See figure 5):</p><p>f(z, y) = 6(x, y) -;dz2+y2).</p><p>c is a parameter which controls the width of the Gaussian and thus the cut-off frequency of the filter. The filter function is discretized over an area of finite size. The value of the pixel in the center of the filter is chosen such that the average value over the discretized filter is zero. A Gaussian filter is a suitable choice, that effectively reduces low-pass components. However, experiments showed that the choice is not very critical, other filters which approximate the sine function can also be applied. The result of filtering a single spot is shown in figure 5. The result of using filtered spots is shown in <ref type="figure" target="#fig_5">figure 6</ref>. In this figure a vertical slice from a data set of a simulated storm is visualized using spots with a triangular shape. In the left image unfiltered spots are used. The low frequency components can be clearly seen as large dark and light areas. In the right image a Gaussian filter is used. Here the texture is more homogeneous and shows the vector field accurately. Note also that the texture shows the magnitude of the flow. In the center area in the lower part the textures are fine-grained, while in the vortices at the left and right edge the texture is coarser. The use of a triangle as the basic spot shape results in a texture in which also lines perpendicular to the flow are present. Visualization is an interactive process, therefore fast generation of pictures is essential. We used the graphics hardware available on current high performance graphics workstations such as the SGI Onyx to speed up both the texture synthesis and the image rendering. In a preprocessing step we generate the textures; next these textures are mapped onto polygons for image rendering. The synthesis and inspection of spot noise textures is done in a sequence of steps, depicted in figure 7. First the spot is transformed to reflect the data; then it is blended with the rest of the spots to produce the texture; finally, this texture is mapped onto the surface.</p><p>A typical spot noise texture consists of tens of thousands of spots. The transformation and blending of these spots takes a considerable amount of computation time. However, the nature of spot noise allows us to take advantage of the polygon rendering and texture mapping hardware. We represented the spot as a single texture <ref type="bibr" target="#b5">[6]</ref>. This texture is mapped onto a unit polygon centered at the origin. To obtain a final spot in texture space, this polygon is scaled and rotated as a result of adapting the shape of the spot to the vector value. Finally, the spot is translated to its position in texture space and blended. This series of transformations is achieved by using the matrix stack of the graphics hardware normally used for the viewing pipeline.</p><p>If bent spots are used, scaling and rotation transformations are not needed, because we generate the stream surface in texture space. The points on the generated stream surface can be used as positions for rendering the mesh which represents the spot. This mesh is rendered with the texture of the spot. The time and stream line number of a particular point are used to determine the corresponding location in the spot texture.</p><p>The variation in intensity of the spot is achieved by using the possibility of weighted blending of the rendered object with the picture generated so far. The hardware compositing only supports addition of intensities, but spots can also have a negative intensity, thus subtraction of intensity is needed. Solving this problem without losing the advantage of the hardware is done by splitting equation 1: </p><p>This way positive-valued spots and negative-valued spots can be accumulated separately by the hardware and only a single subtraction per pixel is needed. Two separate textures are generated, one for positive spots and one for the negative spots. The two resulting textures are then subtracted in software to produce the final texture.</p><p>After synthesis of the textures, an interactive rendering module displays them in three dimensions. The textures are mapped onto a model description of the surface. The model can be inspected by varying the viewpoint with the mouse. Animated texture is achieved by cyclic display of a number of frames with advected texture. As the mapping from texture to physical space is done on the fly by the hardware the viewpoint can be varied during the animation. Times to generate a spot noise texture range from less than a second for a single texture of reasonable quality, to several minutes for a high-quality sequence of textures for animation purposes.</p><p>Color can be used to visualize an independent variable on the same surface. A color map and a spot noise texture are blended by using the value from the spot noise texture as the intensity and the hue from the color map as the hue in the blended picture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Non-uniform grids</head><p>AS stated in the previous section, spot noise texture is generated on a uniform grid, whereas data often is defined on a non-uniform curvilinear grid. The spot noise textures generated in texture space are transformed to physical space. To prevent distortion of the texture, and thus wrong visualization of the data, the spots have to be predistorted in texture space. The transformation of a cell in computational space to a cell in physical space is specified by the Jacobian matrix. By applying the inverse Jacobian matrix transformation to the spots before they are rendered, the spots will have the desired shape in physical space.</p><p>We used linear interpolation to calculate the position and data values between grid points. For this purpose each cell is split into two triangles. Also for the transformation between texture space and physical space we used the decomposition in triangles. Each triangle of the surface has its own transformation, Because many spots have to be rendered all these transformations are precalculated and stored. The performance penalty for using this transformation is very small because it can be appended to the series of transformations needed to map a unit spot to the final spot in texture space as described in the previous section.</p><p>The advantage of this method of interpolation is that processing is fast. The surface can be rendered by rendering flat triangles instead of bilinear patches which must be rendered if bilinear interpolation is used. Also the interpolation of values needs less computation compared to bilinear interpolation.</p><p>As the result of this triangular mapping from physical space to computational space, the velocity field transformed to texture space becomes discontinuous. This can be seen in figure 8, which shows a constant field on a single trapeziumshaped cell with spot noise rendered onto it. In texture space there is a discontinuity along the diagonal of the square. The velocity in computational space at a grid point depends on the triangle bordering the point chosen.</p><p>Because each triangle has its own transformation a problem occurs if we want to apply the predistortion to a standard spot if it covers more than one cell. Several parts of the spot should be transformed differently depending on the cell the part lies in. This problem does not occur if bent spot are used. If a streamline crosses a cell boundary velocity will also change such that the spot will have the desired shape in the final image. In figure 8 bent spots were used.</p><p>Many curvilinear grids are highly irregular with respect to cell sizes. In regions where high velocity gradients are expected, such as boundary layers, the simulation is carried out at a higher resolution. If a uniform grid is used for texture synthesis, the pixel density of the generated texture is equal for each cell. If the texture is transformed back into Hence, it is more efficient to adapt the size of the texture cells to the size of the physical cells. We realized this by using a rectilinear texture space instead of a uniform texture space. The distance between two lines in the rectilinear texture space is chosen such that the area of the strip between the two lines has the same proportion to the total area as the equivalent strip in physical space (figure 9). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Examples</head><p>We present a number of examples of the use of enhanced spot noise in flow data sets.</p><p>Stream surfaces are created by advecting particles released along a line in the flow. Visualization of a stream surface gives only gives partial information of the flow on the surface. The magnitude and direction within the plane is lost. Spot noise generated for the curvilinear stream surface can be used to visualize this information. The result of mapping spot noise onto a stream surface is shown in <ref type="figure" target="#fig_0">figure 10</ref>.</p><p>Elow simulations often produce other data along with velocity, such as pressure and temperature. The spot noise texture can be blended with color to show such a quantity. In figure 11, pressure is mapped to color. The surface is a slice through a data set of a backward facing step. The use of spot bending is essential here to show the main flow in which the velocity is high together with the recirculation behind the step. In wind tunnel experiments the near wall velocity can be visualized using pigmented oil. We simulated pictures from these experiments using enhanced spot noise <ref type="bibr" target="#b6">[7]</ref>. As input for the spot noise algorithm we used the wall friction, the derivative of the velocity perpendicular to the wall. This results in pictures which are very similar to the photographs obtained from the described windtunnel experiments. <ref type="figure">Figure</ref> 12 is a spot noise picture of the wall friction on a fin/wedge configuration. Some slight modifications were made to obtain images comparable to the windtunnel picture. Opposed to standard spot noise, only positive spot intensities were used to emulate the white pigment on the black fin surface. Further, the intensity of the spots was scaled by the value of the convergence (-Vv) of the wall </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper we described several enhancements of spot noise for surface vector field visualization. The enhancements we proposed are spot bending and spot filtering. Spot bending is useful for the visualization of vector fields with high curvature. Prefiltering of spots can be used to generate more homogeneous textures. The use of graphics hardware for faster image generation was described, as well as methods for texture synthesis on data sets defined on a curvilinear grid. As a result of the enhancements described, spot noise can be applied to a large variety of vector field visualization problems.</p><p>If we compare enhanced spot noise with LIC, it has the advantage that the vector magnitude is visible in a single image. Although it is possible to show magnitude using LIC by varying the kernel length <ref type="bibr" target="#b3">[4]</ref>, it has a negative effect on the image quality. Another advantage is that animations of (time dependent) flow are easily generated by treating a spot as a particle which is advected by the flow. No special precautions are needed to show local variations in speed. Direct speed comparison between spot noise and LIC is not possible because the end results are not equal. For LIC images, a function has to be evaluated for each pixel in the texture. In spot noise the generation time depends on the number of spots used to generate the texture. By chasing the number of spots a trade-off can be made between image quality and rendering speed.</p><p>In this paper spot noise is only used in two dimensions.</p><p>However, the concept can be extended to three dimensions, using a density function as a spot and volume rendering to display results. We think texture is a useful visual primitive for the visualization of vector fields, and spot noise with the enhancements presented above is an efficient and accurate technique for the generation of such textures.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Principle of spot noise: single spot (left) spot noise texture (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>spot noise used to visualize a vector field (See co2orplates, page </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Spot bendingFor this deformation of the spot we used a stream surface (figure 3). A stream surface is constructed by integration that is parameterized in the same way. The effect of this method of deformation is that the spot is 'shaped' by the flow. The problem now is to keep the spot area constant regardless of the flow field; all spots should cover an equal area.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Standard spots (left) and locally adaptive spots (right) compared, using a data set of a vortex with velocity inversely proportional to distance from the center.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Spot filtering: the shape of the filter function (left) and the result of filtering a single spot (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Data set visualized using unfiltered (left) and filtered (right) spots 4 Using graphics hardware</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Steps in the synthesis of a spot noise texture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>f(x) = Cc&amp;(x -Xj) = c b&amp;(x -Xi) -c cjqx -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Texture space (left) and physical space (right) for spot noise texture. The field is constant and in the vertical direction physical space, in small cells many texels (texture elements) are squeezed into a small area while texel-resolution is low in large cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Less irregular scaling results if rectilinear texture space (middle) is used instead of uniform texture space (left) to represent the curvilinear physical space (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Two views of spot noise on a stream surface in a data set of a storm. Left: detail, right: combination with other techniques, streamlines and velocity magnitude mapped to color. Data courtesy: R. Wilhelmson (NCSA).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Slice of a backward facing step, color showing pressure. Data courtesy: Dept. of Numerical Mathematics, Delft University of Technology</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Wall friction data on blunt fin visualized using spot noise. Data courtesy: T. Gerhold and H.G. Pagendarm (DLR Gottingen, Germany) friction field. to simulate the effect of the transport of oil over the surface during the experiment, and thus accumulation in regions of high convergence.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1070">-2385/95$4.00@1995IEEEProceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Frits Post for useful discussions on spot noise, and comments on earlier versions of the paper. The fin data and many valuable ideas with regard to the visualization of wall friction were provided by Hans-Georg Pagendarm. We would also like to thank Remko Vaatstra for his help with the implementation of the algorithm. This work is supported by the Netherlands Computer Science Research Foundation(SION), with financial support of the Netherlands Organization for Scientific Research (NWO).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Visual representation of vector fields: Recent developments and research directions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ScientiJic Visualization: Advances and Challenges</title>
		<editor>L.J. Rosenblum et al.</editor>
		<imprint>
			<publisher>Academic press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="367" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Spot noise -texture synthesis for data visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;91 Proceedings)</title>
		<editor>T.W. Sederberg</editor>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Texture splats for 3D scalar and vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;93</title>
		<editor>G.M. Nielson and D. Bergeron</editor>
		<meeting>Visualization &apos;93<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="261" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Imaging vector fields using line integral convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;93 Proceedings)</title>
		<editor>J.T. Kajiya</editor>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Visualizing flow over curvilinear grid surfaces using line integral convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">K</forename><surname>Forssell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;94</title>
		<editor>D. Bergeron and A. Kaufman</editor>
		<meeting>Visualization &apos;94</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="240" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Visualizing 3D velocity fields near contour surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;94</title>
		<editor>D. Bergeron and A. Kaufman</editor>
		<meeting>Visualization &apos;94</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="248" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Visual simulation of experimental oil-flow visualization by spot noise images from numerical flow simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>De Leeuw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">G</forename><surname>Pagendarm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Walter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization in Scienttjic Computing &apos;95</title>
		<editor>R. Scateni, J.J. van Wijk, and P. Zanarini</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="135" to="148" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
