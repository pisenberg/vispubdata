<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Vector Plots for Irregular Grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Don</forename><surname>Dovey</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Lawrence Livermore National Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Vector Plots for Irregular Grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>A standard method for visualizing vector fields wnsists of drawing many small uglyphs&quot; to represent the field. This paper extends the technique from regular to curvilinear and unstructured grids. In order to achieve a uniform density of vector glyphs on nonuniformly spaced grids, the paper describes two approaches to resampling the grid data. One of the methods, an element-based resampling, can be used to visualize vector fields at arbitrary surfaces within threedimensional grids.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Numerous algorithms for visualizing vector fields have been published. One well-known method, some times called an "arrow plot," draws many small line segments or "glyphs" to represent the field. The algorithm is relatively inexpensive and can be used with both 2D and 3D data.</p><p>The "arrow plot" algorithm is usually applied to curvilinear and unstructured grids by drawing the glyphs at the grid nodes or at the element centers. There are several disadvantages to this approach. One drawback is that more glyphs are placed in areas where the elements are small than in areas where the elements are large. This variation in glyph density is unrelated to the vector values themselves. A second drawback is that regularity in the grid causes distracting patterns in the output image. Lastly, the user has no control over the glyph spacing in thii scheme. In order to alleviate these problems, it is necessary to re sample the grid data. Two approaches to resampling the grid are described and compared in this paper.</p><p>In the next section, related previous work in the area of vector visualization is reviewed. Section 3 summarizes the algorithm for regular grids. Sections 4 through 7 extend the algorithm to unstructured grids. Some practical techniques for interactively rendering the vector glyphs are described in section 8. Examples and conclusions are discussed in the last two sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>A set of visualization techniques for flow fields is based on particle advection. Examples include particle paths, particle streams, flow ribbons and flow volumes. These techniques work well for velocity fields but are not necessarily applicable to other vector fields. In electromagnetic wave data, for example, there are periodically-spaced regions at which the magnitude of the electric and magnetic fields is zero -so the data doesn't lend itself to long flow curves. Another consideration with advection-based techniques is that in order to gain a global picture of a flow field, one may need to advect many particles through a volume. This incurs a substantial computational expense and is difficult to achieve at interactive rates.</p><p>Craw&amp; and Max <ref type="bibr" target="#b2">[3]</ref> describe a method for direct volume visualization of vector glyphs (drawn as small line segments) which allows them to be displayed in combination with a scalar field on regular grids. Since our method is derived from theirs, we will return to this paper later.</p><p>In <ref type="bibr" target="#b3">[4]</ref>, Craw&amp; and Max modify their technique for volume visualization of vector and scalar fields by rendering textured splats to the screen. The splatting algorithm makes use of hardware support for polygon texturemapping in order to achieve interactive performance. Splatting-based techniques and other methods for rendering velocity fields near contour surfaces are discussed in <ref type="bibr" target="#b8">[9]</ref>. All of these methods were developed for regular grids.</p><p>An algorithm by van Wijk <ref type="bibr" target="#b11">[12]</ref> shows flow direction on a parametric surface by rendering an oriented texture on the surface. Cabral and Leedom <ref type="bibr" target="#b1">[2]</ref> developed a "Line Integral Convolution" (LIC) algorithm for textured display of flow fields. The method generates an oriented texture by convolving a local streamline with random noise at each cell in a 2D regular grid. The LIC algorithm was extended to surfaces of curvilinear grids by Forssell <ref type="bibr" target="#b4">[5]</ref>. Some weaknesses of the algorithm are that it only shows the component of the vector field that lies in the surface being textured and that it has not been (See color plates, page CP-29) extended to unstructured grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Regular grids</head><p>The algorithm for regular grids is reviewed in this section, and extended to unstructured grids in later sections. Following <ref type="bibr" target="#b2">[3]</ref>, we overlay the computational grid with a second regular grid: the vector grid. The algorithm selects a random point in each cell of the vector grid and linearly interpolates the vector field values from the computational grid to the selected point. An oriented, anti-aliased line segment centered about the point is then drawn. We refer to the points at which the glyphs are drawn as vector grid points. Essentially, the algorithm samples the data on a jittered regular grid. Jittering is required in order to avoid aliasing that occurs with a regular sampling grid <ref type="bibr" target="#b2">[3]</ref>. The user selects the spacing of the vector grid and also controls the absolute length of the glyphs.</p><p>If the vector field is three-dimensional, the rendering order is important.</p><p>Back-to-front rendering is necessary because of the way most hardware implements anti-aliased line drawing: partially covered pixels along a line are blended with the previous values in the display buffer. Since the vector points are generated on a semi-regular grid, drawing the glyphs from back to front (or approximately back to front) is trivial. Of course, there is no guarantee that a line segment with its center behind another won't extend in front of the second line segment, but occurence of this case tends to be minimized by the coherence of the field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Finite elements and interpolation</head><p>Sections 5 and 6 introduce two different methods for displaying vector plots on curvilinear and unstructured grids. Before the methods are introduced, it is helpful to review some concepts from finite element analysis.</p><p>In this paper, we restrict ourselves to unstructured grids composed of linear elements. The element types of most interest are hexahedral and tetrahedral volume elements and quadrilateral and triangular thin shell elements.</p><p>For isoparametric finite elements, a set of shape functions or interpolation functions both defines the geometry of an element based on the element nodes and interpolates quantities from the nodes to the interior of the element. Points in the interior of a hexahedral or quadrilateral element are defined by their </p><formula xml:id="formula_0">P(u,v,w) = ~Nj(U,V,W)P,<label>(1)</label></formula><formula xml:id="formula_1">i=l Nj = i(1+ uui)(l+ In&amp;)(1 + WuIi)</formula><p>Here, (u, ZI, w) are the natural coordinates of the interior point, Ni are the shape functions, Pi are the global coordinates of the corner nodes, and (ui, vi, wi) are the natural coordinates of corner node i. Similarly, for a 2D or 3D quadrilateral element,</p><formula xml:id="formula_2">P(u, v) = k Ni(u, v)Pi (2) a=1 Nj = $1 + uui)(l + vvi)</formula><p>Linear interpolation is accomplished on triangular and tetrahedral elements with barycentric coordinates. For a triangle with vertices PI, P2, and Ps, a point P inside the triangle is given by its barycentric coordinates (r, 8, t) in the range (0, 1). P(r, s, t) = r4 + SPZ + tP3  <ref type="formula" target="#formula_0">r+s+t+zl=1</ref>In either case, the shape functions are simply Nl =r,N2 =s,...</p><p>Note that barycentric coordinates lie on a different interval than natural coordinates. Interpolating a result value to an arbitrary point in an unstructured grid involves locating the element that contains the point, calculating the natural coordinates or barycentric coordinates of the point with respect to the element, and then interpolating the re sult value from the element nodes to the point. Interpolation is performed with the shape functions. For an element with n nodes, the result value at the point is given by n.</p><p>R=xN&amp; i=l <ref type="bibr" target="#b4">(5)</ref> Ri in the above equation is the result value at node i. The reader may refer to a finite element text such as <ref type="bibr" target="#b12">[13]</ref> for more information on this topic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Physical space resampling</head><p>A natural solution to the problem of varying grid density is to resample the vector field data on a regular or jittered regular grid. The main issue that must be addressed with this method is the cost of initializing the vector grid.</p><p>The most expensive step in the procedure for interpolating a result value to an arbitrary point is locating the element that contains the point. This requires a search through the grid elements until the enclosing element is found. The search can be made more efficient with techniques such as hierarchical bounding boxes or spatial partitioning or by making use of spatial coherence. Even with one of these acceleration methods, the search is expensive when repeated for thousands of vector points in a large grid. Our implementation utilizes hierarchical bounding boxes to accelerate the point tests. At startup, the grid is partitioned into groups of adjacent elements. (Partitioning algorithms are surveyed in <ref type="bibr">[6]</ref>.) The candidate point is tested against the bounding box for a group of elements before being tested against the bounding box of each element in the group. If both tests pass, then an iterative procedure determines whether the point actually lies inside the element. For efficiency, all bounding boxes are cached in advance. Using hierarchical bounding boxes, we find that it takes from several seconds to several minutes to solve the "point in element" problem for all vector grid points within a 3D unstructured grid.</p><p>The discussion that follows assumes a static computational grid. To support interactive animation of transient vector fields, we process the vector grid once during an initialization step and calculate, for each vector point, the element that contains the point and the natural coordinates of the point on that element. This information is stored and used to update the re sult values at the vector points as the animation steps through time. The sequence of steps for rendering a vector glyph is: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Parameter space resampling</head><p>In an effort to avoid the expense of initializing the vector grid points, parameter space resampling was developed. The idea is to generate random points directly in the natural coordinates of the elements using an area-weighted (or volume-weighted) distribution. The natural coordinates are then mapped to physical coordinates in the grid. This method relies on the assumption that, with a relatively dense resampling, the precise distribution of the individual points is not critical as long as the overall density is correct. The key to the approach is to make sure the vector points are distributed with uniform probability in physical space.</p><p>To begin, consider a 2D grid composed of quadrilateral or triangular elements. The user selects a vector grid density, D, which is the number of vector glyphs to be drawn per unit area. The rendering algorithm visits each element in turn. The number of vector points to be generated for the element is calculated by multiplying the area of the element, Ai, by the vector density. We use a random number generator to decide whether a vector point will be generated for a particular element as a result of the fractional part of the vector count.</p><p>The number of vector glyphs to be drawn in an element is given by N,,,, in the pseudocode below.</p><formula xml:id="formula_4">N vet = floor( D.Ai &gt; if ( random() &lt;= mod@- Ai, 1) &gt; N vet = Nvec + 1</formula><p>The floor0 function rounds a number down to the closest integer, mod 0 returns the remainder of the first argument divided by the second, and random0 generates uniformly distributed pseudo-random numbers in the range (0, 1).</p><p>Once the number of vector points for a quadrilateral element has been calculated, the natural coordinates of each point are randomly generated in the range (-1, 1) by two calls to random(). The vector field is interpolated to each vector point from the ele ment nodes (Equation 5) and the physical coordinates of the points are computed (Equation 2.) We may then render the vector glyphs at the points.</p><p>This approach deposits points in a quadrilateral element with uniform probability as long as opposite sides of the element are nearly parallel. If an element has a trapezoidal shape, one can obtain a uniform probability for the vector points by splitting it into two triangles and then using the method for triangles.</p><p>The method for obtaining a proper distribution of vector points within a triangular element is baaed on barycentric coordinates. Recall that a point P inside a triangle is given by its barycentric coordinates (r, s, t), where P(r, 8, t) = rP1 + SPZ + tP3</p><p>Holding the value of r constant yields a line segment parallel to the triangle edge m <ref type="figure">(Figure 2</ref>.) To find the proper distribution of points on the triangle, we compute the length of a line segment m which is defined by a constant value of r <ref type="figure">(Figure 2.</ref>) From the definition of barycentric coordinates, lpml = (1 -~)II~l~3ll</p><p>By similar triangles,</p><formula xml:id="formula_5">IIpafill = (1 -T)llfifili</formula><p>The line segment defined by r = 0.5 is half as long as P2P3.</p><p>By comparing the area of thin strips centered about the two line segments and taking the limit as the width of the strips approaches zero, we find that the probability that r = 0.5 is half the probability that r = 0. In general,</p><formula xml:id="formula_6">Probability(r) = (1 -r)Probability(O) = (1 -r)C</formula><p>where C is a constant. In other words, the probability distribution is a linear ramp with zero probability at r = 1 and maximum probability at r = 0. We are interested in the relative probability of different values of T, so C is arbitrary. A random value in the range (0,l) with the desired linear ramp probability distribution can be generated as follows (see <ref type="bibr" target="#b6">[7]</ref>.) r = 1 -sqrt (random()) A point is equally likely to fall at any position along the line segment defined by a constant value of r, so s and t may be chosen at random with the constraint that r + s + t = 1. The constraint implies that s and t must be in the range (0, 1 -r). Random barycentric coordinates may be generated: r = 1 -sqrt (random()) s = (1 -r&gt;*random() t=l-r-s Given these randomly distributed points in 2D, one can draw the vector glyphs interactively as before.</p><p>The previous approach extends trivially to surfaces in 3D. For example, it can be used to show a vector field on the exterior faces of a 3D curvilinear grid. The only change is that we need to insure that the vector points are rendered in back-to-front order. One could sort the faces back-to-front <ref type="bibr">[lo]</ref> before generating and drawing the vector glyphs, but it is simpler and usually more efficient to generate the vector points and sort the points in back-to-front order before rendering.   Thii increases the rendering cost (particularly for 3D vectors) and can clutter a dense image. An alternate way to show vector direction is to vary the hue along the length of the line segment. For example, make the tail end of the vector green and the head end red, with linear interpolation of the two colors in between. If the vector glyphs are being colormapped, one can colormap one end of the glyphs and set the other end to a constant color in order to show direction. Max <ref type="bibr" target="#b8">[9]</ref> points out that the 2D projection of a 3D .line segment is ambiguous, since many 3D segments can have the same projection. Hence, it is difficult to see how 3D vector glyphs are oriented with respect to the viewer unless the view is rotated interactively or unless the glyphs themselves are animated. One way to partially overcome this problem is to modulate the brightness over the length of the glyph. If the vector is parallel to the view direction, the brightness of the farthest end from the viewer is scaled to zero (or to some value between zero and one) while the closest end is drawn at full brightness. If the vector is perpendicular to the view direction then both ends are drawn at full brightness. At other angles, the end values are interpolated between these extremes. The purpose of this technique is to give the vector glyphs an exaggerated appearance of perspective scaling. Another way to help show line orientation is with simulated lighting, a subject which other researchers have covered well <ref type="bibr">[l]</ref>.</p><p>If the vector grid is dense then vectors that are close to each other may overlap, making them indistinguishable. This can be addressed by jittering the brightness of the vectors as in <ref type="bibr" target="#b8">[9]</ref>.</p><p>When rendering 3D data, values in the middle or rear of the volume tend to be obscured by values at the front of the volume. Often, the best technique for visualizing the interior of a 3D grid is to display the vector glyphs at a planar slice through the grid. The slicing plane can be moved through the volume to let the user view all parts of the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Examples</head><p>Figures 6 to 10 illustrate a fluid dynamics problem in which an incompressible fluid flows past a cylindrical post and a plate (the plate is at the bottom of the grid.) The grid in this example was treated as unstructured. <ref type="figure">Figures 7 and 8</ref> show the velocity at a horizontal cut plane. Vortices which form behind the post and are carried downstream by the flow are visible in the images. The relative magnitude of the velocity field is shown in <ref type="figure">Figure 7</ref>; the direction of flow is emphasized in <ref type="figure">Figure 8</ref>. In <ref type="figure">Figure 8</ref>, the tails of the vector glyphs are magenta and the heads are yellow. Regions of the cut plane that are more yellow or more magenta show areas where the flow direction is partially out of the cut plane. <ref type="figure">Figure 9</ref> shows vorticity at the cut plane. Vorticity is a vector field which measures the local change in velocity. <ref type="figure" target="#fig_0">Figure 10</ref> shows the flow velocity at six isosurfacea of pressure.</p><p>A snapshot of the electric field in an electromagnetic wave simulation is shown in <ref type="figure" target="#fig_0">Figure 11</ref>. The wave travels from left to right in the image, and its energy is deflected downward by the window in the center.</p><p>Figures 7 to 10 were generated with parameter space resampling, and <ref type="figure" target="#fig_0">Figure 11</ref> was generated with physical space resampling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion</head><p>Vector plots provide a way to interactively visualize vector fields. The technique can be used with 2D and 3D vector data on regular and irregular grids. For unstructured grids, physical space and parameter space resampling methods were described. Parameter space resampling is efficient and allows us to visualize vector fields at arbitrary 3D surfaces. Physical space resampling guarantees that sample points are well-distributed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Natural coordinates for a hexahedral and a quadrilateral element. natural coordinates on the interval (-1, 1) (Figure 1.) For a hexahedral element, interior points are specified by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3 .</head><label>3</label><figDesc>1. Interpolate the vector field to the vector point (Equation 5.) 2. Calculate the physical coordinates of the vector point (Equations l-4.) Draw the oriented glyph at the point.The vector glyphs are drawn from back to front by traversing the vector grid in the proper order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 21 :</head><label>21</label><figDesc>Isoparametric lines in barycentric coordinates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Velocity field with vectors drawn at the grid nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Physical space resampling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Parameter space resampling (same sampling density asFigure 4.)The standard technique for showing vector direction is to draw an arrowhead at one end of the line segment.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 Â© 1995 IEEE</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The author would like to thank Roger Crawfis, Dan Schikore, and the reviewers for their helpful comments on this paper. Datasets in the images were generated by Mark Christon, Scott Nelson and Teresa Swatloski.</p><p>This work was performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under contract number W-7405-ENG-48.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Illumination in Diverse Codimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Banks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings &apos;94, ACM Siggraph</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Imaging Vector Fields Using Line Integral Convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings &apos;93, ACM Siggraph</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Direct Volume Visualization of Three Dimensional Vector Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Volume Visualization</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Siggraph</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="55" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<title level="m">Texture Splats for 3D Scalar and Vector Field Visualization</title>
		<meeting><address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="261" to="266" />
		</imprint>
	</monogr>
	<note>Proceedings, Visualization &apos;93</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Visualizing Flow Over Curvilinear Grid Surfaces Using Line Integral Convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, Visualization &apos;94</title>
		<meeting>Visualization &apos;94<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="240" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Chaco User&apos;s Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hendrickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Leland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="93" to="2339" />
			<pubPlace>Sandia National Laboratories; Albuquerque, NM</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Art of Computer Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seminumerical Algorithms</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1969" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings &apos;87, ACM Siggraph</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="44" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Visualizing 3D Velocity Fields Near Contour Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Craw&amp;</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grant</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>IEEE Computer Society Press</publisher>
			<biblScope unit="page" from="248" to="255" />
			<pubPlace>Los Alamitos, CA</pubPlace>
		</imprint>
	</monogr>
	<note>Proceedings, Visualization &apos;94</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Solution to the Hidden Surface Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Newell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Newell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sancha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM National Conference</title>
		<meeting>the ACM National Conference</meeting>
		<imprint>
			<date type="published" when="1972" />
			<biblScope unit="page" from="443" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Interactive Animated Visualization of Flow Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, 1992 Workshop on Volume Visualization, ACM Siggraph</title>
		<meeting>1992 Workshop on Volume Visualization, ACM Siggraph<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="47" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Spot Noise</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings &apos;91, ACM Siggraph</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="309" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The Finite Element Method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">0</forename><forename type="middle">C</forename><surname>Zienkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fourth Edition</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
