<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Normal Estimation Using Surface Characteristics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byeong</forename><forename type="middle">Seok</forename><surname>Shin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Engineering</orgName>
								<orgName type="institution">Seoul National University Seoul</orgName>
								<address>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fast Normal Estimation Using Surface Characteristics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>To visualize the volume data acquired from computation or sampling, it is necessary to estimate normals at the points corresponding to object surfaces. Volume data does not holds the geometric information for the surface comprising points, so it is necessary to calculate normals using local information at each point. The existing normal estimation methods have some problems of estimating incorrect normals at discontinuous, aliased or noisy points. Yagel et al solved some of these problems using their context-sensitive method. However this method requires too much processing time and it loses some information on detailed parts of the object surfaces. This paper proposes the surface-characteristic-sensitive normal estimation method which applies different operators according to characteristics of each surface for the normal calculation. This method has the same advantages of the context-sensitive method, and also some other advantages such as the less processing time and the reduction of the information loss on detailed parts.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Visualization is a fast growing field in computer graphics.</p><p>It refers to every work that is necessary to show existing natural and artificial objects or to simulate the natural and imaginary phenomena which require special operations to make visible to human eyes[1] <ref type="bibr">[2]</ref>. Among these, the research on volume visualization to visualize the 3D data obtained by diverse means is most active. Much work has been done in flow visualization, medical imaging, geoscience, all sorts of simulation and animation fields <ref type="bibr">[3]</ref>[4][5] <ref type="bibr">[S]</ref>. A well known example is the visualization of scanned data of a human organ or skeleton by computed tomography (CT) or magnetic resonance imaging (MRI).</p><p>Adequate shading is necessary to make any phe-Yeong Gil Shin</p><p>Dept. of Computer Science and Statistics Seoul National University Seoul, Korea nomena or imaginary objects visible. Shading is deciding the light intensity of each pixel of an object on the screen. The most important factor to consider in deciding the intensities is the angle of the object's surface against the incident light. This angle is represented as a unit vector perpendicular to the object surface and is called a normal vector. It is fairly easy to obtain a normal from a geometric model but that is not the case when a volume data is used. An image sampled by CT or MRI is the most popular example of volume data. These devices sequentially photograph the object's cross-sections in specified resolution and produce 2D slides. It is possible to render a volume data by stacking them[7] <ref type="bibr">[8]</ref>. Sampled values of points in the volume do not include any geometric information of the surface to which they belong, and this makes difficult to obtain normals with only the sampled values of the points.</p><p>This paper proposes an efficient method of obtaining normals of an object from its volume data. This method uses the characteristics of each surface and calculates the normals more rapidly and accurately than other methods ever proposed. Important factors on accurate normal estimation is considered in section 2 and the other previously proposed normal estimation methods and their drawbacks are presented in section 3. The method proposed in this paper is presented in section 4. In section 5, the advantages of this method are discussed with the results of experiments using actual sampled data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Factors to consider in normal estimation</head><p>The input data used in this paper is a binary depth image obtained by preprocessing CT scan data. In the preprocessing stage, the value of each volume data point is compared with a threshold value for binary segmentation, and then parallel projected onto a sur-(See color plates, page  face perpendicular to the viewing direction to get the depth value of each projected point. The binary depth image is widely used as the input data despite its drawback of having to recalculate every time the viewing direction changes, because it is easy to get information for constructing a 3D object surface with little amount of data.</p><p>Normal estimation is the restoration of geometric information from the sampled values. In the case of using the volume data, the normal cannot be obtained by using the depth value of only one point. However, it is possible to get the normal of a surface approximately using depth values of points which are adjacent to each other. In this paper the analytic normal of a point refers to the normal calculated by the object comprising surface equation and the estimated normal is the normal obtained by depth information with regard to that point.</p><p>The analytic normal is calculated by the cross product of gradient vectors of X and Y axis direction :</p><p>The estimated normal vector @d at the point on the surface can be expressed by :</p><p>where AZ/AX is the amount of depth value change for each pixel in X direction and Az/Ay is the amount of depth value change in Y direction.</p><p>There are several problems in estimating the normal with approximated values. At first, normals are incorrectly estimated on discontinuities. There are Co discontinuity where the surface is discontinuous, and Cl discontinuity which occurs on points with rapid gradient change. On these points the differences in the depth value between neighboring points do not represent the gradient correctly. Secondly, the error from staircasing may occur from the difference between the true value and the sampled value. And lastly, error may occur by noises produced when the volume data is projected onto a binary depth image. When the noise is produced, its vicinity has an incorrect normal that is very different from the real value. This causes a white or black dot in shading.</p><p>The efficiency of a normal estimation method is evaluated in both speed and accuracy.</p><p>Processing speed is to evaluate how fast the shading is carried out. As the need for real time graphics increase, fast shading becomes as an important, requirement. The accuracy may be quantitatively evaluated by comparing the estimated normal vector to the calculated analytic normal, or it may be qualitatively measured by evaluating how satisfactory the final shaded result appears. From now, we compare existing methods and the newly proposed method in processing speed and visual reality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head><p>Previous research</p><formula xml:id="formula_0">3.1,</formula><p>The depth gradient method</p><p>The depth gradient method is the most simple normal estimation method[9] <ref type="bibr">[10]</ref>. It uses the difference of the depth values of two neighboring points with that point as gradients in X and Y direction. Let the depth value of the point (i, j) be Di,j. The gradient in X and Y direction can be obtained by :</p><formula xml:id="formula_1">AZ = Di-l,j -Di,j Gi,j = = (Di+l,j - Di-l,j)/z = Di+l,j - Di,j AZ = Dij-1 -Di,j - = AYi,j r fi:j+l -Di,j-1)/2 z,j+l -Di,j<label>(3)</label></formula><p>where Bi,j is the backward difference, Fi,j is the forward difference and Ci,j is the central difference.</p><p>The normals acquired from this method have low resolution because it uses integer values as the gradients. Also the considerable difference in the analytic normal and the estimated normal may result from using the depth value of two neighboring points which belong to different surfaces. These cause dark bands when shaded. It can be verified that parts where staircasing occurs or noise is included generate tremendous errors because of using only local information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.2</head><p>The N-neighbor depth gradient met hod</p><p>The N-neighbor depth gradient method uses more neighboring points than the depth gradient method to solve the problems caused by just using two. If the number of neighboring points used is N, the gradient in X direction at point (i, j) is calculated by :</p><formula xml:id="formula_2">N &amp;,j = &amp;CDi--k,j -D;,j k=l A.2 -= Axi,j I ci,j/2 = &amp; 5 Di+k,j -Di,j (4 k=-N N</formula><p>the gradient in Y direction can be obtained in the same way. This method reduces the error originating from staircasing and noise by using the depth values of more than t.wo p0int.s. However this causes an error occurred at a discontinuity which affects normals at more point,s. This propagation of error results in wider dark bands on the shaded image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3</head><p>The context-sensitive method</p><p>Yagel et al proposed the context-sensitive method to solve problems of previous methods <ref type="bibr">[11][12]</ref>. This method estimates the normal by segmenting an image into several contexts and applying the contextsensitive operator which operates only on points within a context. A context includes neither Cc nor Ci discontinuity and the differences of normals between points are very small. The algorithm of the context-sensitive method consists of four phases such as segmentation, prefiltering, normal calculation and postfiltering.</p><p>In the segmentation phase an input image is segmented into contexts at discontinuous points. Cc discontinuity is where the depth difference of a pair of adjacent points exceeds the threshold The, and Ci discontinuity is where the difference of central difference for a pair of adjacent points exceeds the threshold Thl which implies the sudden change in gradient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cc discontinuity</head><p>: ]Di,j -Q+i,j ] 2 The (5) Ci discontinuity : (C;,j -C;+i,j ( 2 Thl, where C;,j is the central difference</p><p>A 3 x 3 weighted smoothing filter is applied in the prefiltering phase. This may take a considerable time, but because the values of result are real it overcomes the low resolution drawback of previous methods, and reduces errors caused by staircasing and noise. This filter is a context-sensitive filter which applies to the depth values of points included in the same context. The filtered value Ri,j at point (i, j) is :</p><formula xml:id="formula_4">R, = k=-If=-1 "J 1 1<label>(7)</label></formula><p>where the function P(pi,j, pk,r) returns 1 only when point (i,~') and (Ic, I) both belong to the same context, otherwise returns 0, and wi,j is the weight where CkC , wk,l = 1 .</p><p>The normal calculation uses t,he difference in depth values of two adjacent points as in the depth gradient method, but this method applies filtered depth values of points within a context to the calculation as represented in Eq(8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AZ</head><formula xml:id="formula_5">-= Axij (&amp;+l,j -R;-l,j)/2 if P(/%,j, Pi+l,j)AP(Pi,j j Pi-l,j) Ri+l&gt;j -&amp;,j if P(pi,j, Pi+l,j)AIP(Pi,j j Pi-l,j) (8) R-l,i -Ri,j if+(pi,j, Pi+l,j)AP(Pi,j, Pi-l,j) 0 otherwise</formula><p>The last. postfiltering phase uses the weighted smoothing filter as in prefiltering and smooths out calculated normal vectors once more.</p><p>The context-sensitive method prevents the incorrect estimation of normal vect.ors at Cs or Ci discontinuous points and removes errors caused by noise or st,aircasing by applying the filter repeatedly. However, processing through the four phases for each image requires much more processing time than other methods. Also applying the smoothing filter twice before and after the normal calculation causes blurring at detailed parts and has the drawback of losing information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4</head><p>The surface-characteristic-sensitive normal estimation method</p><p>The surface-characteristic-sensitive method proposed in this paper applies different normal calculation operators according to the characteristics of each surface, and the processing time is improved by reducing processing phases to two phases. These phases are segmentation and gradient calculation phase and filtering phase.</p><p>The segmentation and gradient calculation phase concurrently carries out segmenting an image into several contexts at Cc or Ci discontinuities, detecting and restoring noises and calculating gradients using the surface characteristics. Processing this phase uses a 5 x 1 mask as shown in <ref type="figure">Figure 1</ref> and the difference queue for storing depth differences of five contiguous points to which the mask is applied. Segmenting and calculating the gradients is carried out as the mask advances a unit position at a time in X or Y direction, starting at the origin of the image. The difference queue is a linear queue where a new difference value is appended at the end and the obsolete value is discarded at the head as the mask advances.</p><p>To find C's or Cr discontinuous points, a threshold comparison method is used as in the contextsensitive method.</p><p>However this method simult,ane-a point to be, examined ously checks the discontinuities between point (i, j) and point (i + l,j), and between point (i +-l,j) and point (i+2, j) when processing point (i, j). If both are discontinuous the point (i, j) is considered as a noise, and we cannot calculate the gradient because the calculation at a point requires at least one neighboring point. If a noise is detected, its depth value is amended to be included in the current context. Otherwise if a discontinuity is detected the context is segmented.</p><p>When calculating the gradient within a context, according to the surface characteristic one of the four different operators is applied. The state of the surface that includes the current processing point is defined as FLAT-STATE if the gradient is 0, SINCLINE-STATE or FINCLINESTATE if the gradient is constant, and OTHER-STATE for the rest. As the mask advances, the differences Di-l,j -</p><formula xml:id="formula_6">Di-~,j, Di,j-Di-l,i,</formula><p>Di+l,j-Dt,j, and Di+z,j -Di+l,j are stored sequentially into the queue for point (i, j). If every value in the queue is 0, the current state becomes FLAT-STATE and the gradient is set to zero. When the incoming difference is also 0 as the mask advances FLATSTATE is maintained. If it is 1 or -1 then the state changes to SINCLINE-STATE, otherwise the state changes to OTHER-STATE. If every value in the queue is the same constant whose absolute value is bigger than or equal to 1, the current state becomes FINCLINE-STATE.</p><p>Since the gradient stays the same during this state the gradient is fixed to the value calculated at the transition to this state.</p><p>When other value enters the difference queue the state changes to OTHER-STATE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AZ -= Axi,j i</head><p>Di+l,j -Di,j at the transition az Axi-1,j otherwise : FINCLINE-STATE (10)</p><p>If the absolute value of the gradient is smaller than 1, the current state becomes SINCLINE-STATE where the difference queue has values 0 or &amp;l. In this case the number of 0 inbetween adjacent fl's does not change and the gradient is decided by this number. That is, the gradient can be calculated by counting the number of O's inbetween adjacent &amp;l's and taking the reciprocal of the count after adding 1 to it. :  where N is the number of O's inbetween two fl's. If the number of O's exceeds the size of the queue, the state changes to FLAT-STATE.</p><p>Therefore in SIN-CLINESTATE, the gradient has the value between l/4 and 1. When the number of O's changes or the difference bigger than 1 enters the queue the state changes to OTHER-STATE. In OTHERSTATE the surface is curved or irregular. The mean of all four differences in the queue is used as the gradient. The calculation is carried out by averaging the values in the queue. Only the points in the same context as the point (i,j)is considered in this calculation. where &amp;k is the kth element of the difference queue and its value is Di+k-i,j -Di+k-2,j. The function P(h) returns 1 if the value of /?th element is in the same context.</p><p>When the gradient calculation in X direction is completed, the same method is applied in Y direction and then normals are calculated.</p><p>There is an additional state other than the aforementioned four states. It is NOISE-STATE where a noise is detected. In this state the depth value of a noisy point is corrected by referring the previous state as represented in Eq(13).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I</head><p>Di-l,j prev state = FLAT-STATE DC;" = Di-l,j + C, where C = Oor -f 1 i -prev state = S(F)INCLINE-STATE D;-1 j + &amp;O = 2D;-1 -Di-2 . prev state = OT&amp;RSTA'??E (13) The automata for calculating the gradients is shown in <ref type="figure">Figure 5</ref>.</p><p>Like the context-sensitive method, the 3 x 3 contextsensitive weighted smoothing filter is applied after the segmentation and gradient calculation phase. Filtering reduces the error by smoothing out the gradient, differences generated at aliased parts.</p><p>This method gets the more accurate normal vector at discontinuous or aliased parts compared to the 33 All QrOorfl <ref type="figure">Figure 5</ref>: The automata of the gradient calculation phases context-sensitive method. This implies that the image shaded with the proposed method expresses the original object more accurately than the context-sensitive method.</p><p>Also errors caused by noises are reduced compared to the context-sensitive method because this new method corrects the depth value of a noise rather than just filtering it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments and results</head><p>The comparisons of the surface-characteristicsensitive method's efficiency to the other existing method such as the depth gradient method, the Nneighbor depth gradient method, and the contextsensitive method are carried out by implementing all the methods on SPARC2, SPARClO, and SGI2 workstation. Each program is tested with a binary depth image for the shading process. We experiment with two sampled data acquired from CT. The one is for a human spine and the other is for cadaver's skull with 256 x 256 x 256 resolution.</p><p>A spine and a skull are scanned by CT to produce a set of 2D slices. The resulting slices are binary segmented, interpolated, then projected to generate depth images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.1</head><p>Processing time <ref type="table" target="#tab_1">Table 1</ref> shows the comparison of the processing time taken by each method in processing the depth image on several workstations. The depth gradient method or the N-neighbor depth gradient met,hod produces insufficient image quality, but the processing time is relatively short since filtering is not done. The  results show that the surface-characteristic-sensitive method is about 60-90% faster than the contextsensitive method. Also if filtering is omitted, the surface-characteristic-sensitive method is only about 12-34% slower than the N-neighbor depth gradient method. This implies that the proposed method can be used in adaptive refinement where the image quality and the image generating time are adjusted by the updating rate in animation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SPARC2</head><p>For animating fast moving scenes, the filtering can be omitted to reduce the processing time in case of little changes in scenes the filtering may be applied to offer a better quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Visual reality</head><p>Visual reality is the measure of how real an image shaded by each method appears. <ref type="figure">Figure 6</ref> and 7 show a side view of a spine and front view of a skull with 256 x 256 resolution. They show the shading results of the spine and skull by each method. Shading by the depth gradient method produces dark bands at the boundary of the bone because of the incorrect estimation of normal at Co or Cl discontinuity.</p><p>The wave patterns on the bone surface is caused by aliasing. The N-neighbor depth gradient method reduces wave patterns on the surface, but dark bands at the boundary become thicker. The context-sensitive method removes wave pat,terns and dark bands at. the boundary and produces more realistic result compared to the other two methods. The dark bands at the boundary and the wave patterns are also removed in the surface-characteristic-sensitive method.</p><p>Compared to the context-sensitive method, the bone sur-face appears with less wave patterns and the contrast between dark and light parts is more distinct since the smoothing filter is applied only once to prevent excessive blurring. The bottom-right image of <ref type="figure">Figure 6</ref> and 7 show the result of the surface-characteristic-sensitive method without filtering.</p><p>If high speed processing is required, the filtering can be optionally omitted at the expense of image quality. Even when unfiltered, the dark band does not appear and the quality is far better than the result of the N-neighbor depth gradient method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>The existing methods for estimating normals from volume data have the problems of obtaining incorrect normals at the discontinuous, noisy or aliased parts. The context-sensitive method solves the most of these problems using the notion of context. However this method requires considerable processing time compared to the other methods and is unable to express the detailed part accurately because of the excessive smoothing operation.</p><p>We proposed a new method, the surfacecharacteristic-sensitive normal estimation method, that has the same advantages of the context-sensitive method in addition to the much faster processing time and the ability to express the detailed parts more accurately.</p><p>This method reduces the processing time by scanning an image only twice whereas the contextsensitive method scans four times. The normals are calculated by four different operators to get an accurate image. The simple operator is used on the flat or inclined surface, and the operator using the difference in the depth values of several adjacent, points is used on the curved surface or aliased part. The object surface is segmented into several contexts to handle the discontinuous parts, and the detection and correction of a noise is allowed to increase the reality of the shaded image.</p><p>Up to now, we only consider the normal calculation for a binary depth image, but with a 3D edge detector and a 3D filter we can apply the same met,hod to calculate normals directly from a binary volume data without projection.</p><p>When a binary depth image is used the image must be regenerated and the normal is recalculated as the viewing direction changes, however if the normal is obtained directly from a 3D data, recalculation is not required for each viewing specification and the shading can be processed in a very short time. We also need to use more efficient discontinuity detection algorithm[l3], and to expand our method to a gray level image[14] <ref type="bibr">[15]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Noise detection and correction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 3: Four characteristics of a surface : (a) gra-dient=O (b) gradient=C (ICI 1 1) (c) gradient=C</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 4: Surfaces with gradients smaller than 1 (a gra-dienk0.5 (number of O's = 1) (b) gradienk0.25 number of O's = 3) 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>: The comparison of image generation</cell><cell>time (set)</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">lOTO-2385/95$4.00@1995 IEEE Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 6th IEEE Visualization Conference(VISUALIZATION '95)1070-2385/95 $10.00 © 1995 IEEE</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The author would like to thank Chul-Hi Lee and Hyae-Kyung Lee for their help.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="figure">Figure 6</ref><p>: Shading results of a spine by each method </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Survey of Algorithms for Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd</forename><forename type="middle">T</forename><surname>Elvins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="194" to="201" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Survey of Modeling Representations and Their Application to Biomedical Visualization and Simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jay</forename><forename type="middle">S</forename><surname>Hersh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Conference on Visualization in Biomedical Computing</title>
		<meeting>the First Conference on Visualization in Biomedical Computing</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="432" to="441" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Volumetric Rendering of Computed Tomography Data: Principles and Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Ney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">K</forename><surname>Fishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Magid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="24" to="32" />
			<date type="published" when="1990-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Three-Dimensional Segmentation of MR Images of the Head Using Probability and Connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wiiiam</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Kikinis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ferenc</forename><surname>Jolesz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Assisted Tomography</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">51</biblScope>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Visualization of Time-Dependent Flow Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;93</title>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="32" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Rendering Algorithm for Visualizing 3D Scalar Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="51" to="58" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Overview of Computerized Tomography with Emphasis on Future Developments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Garden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Peter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="356" to="372" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Introduction to MRI Imaging : From the Bloch Equation to the Imaging Equation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">S</forename><surname>Hinshaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">H</forename><surname>Lent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="338" to="350" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Real-time discrete shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bakalash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bergman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Visual Computer</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="16" to="27" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Image Space Shading of 3-Dimensional Objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">Anthony</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics, and Image Processing</title>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="361" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Normal estimation in 3D discrete space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Visual Computer</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="278" to="291" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bakalash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Spector</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Proceedings Visualization &apos;90</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="160" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Comprehensive rendering of 3D shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Takahashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="197" to="206" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Shading 3D-Images from CT Using Gray-Level Gradients</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Hohne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Medical Imaging</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Investigation of Medical 3D-Rendering Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Tiede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hoehne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bomans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pommert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wiebecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="41" to="53" />
			<date type="published" when="1990-03" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
