<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Local Statistical Analysis via Integral Histograms with Discrete Wavelet Transform</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Teng-Yok</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
						</author>
						<title level="a" type="main">Efficient Local Statistical Analysis via Integral Histograms with Discrete Wavelet Transform</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>WaveletSAT</term>
					<term>integral histograms</term>
					<term>discrete wavelet transform</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Histograms computed from local regions are commonly used in many visualization applications, and allowing the user to query histograms interactively in regions of arbitrary locations and sizes plays an important role in feature identification and tracking. Computing histograms in regions with arbitrary location and size, nevertheless, can be time consuming for large data sets since it involves expensive I/O and scan of data elements. To achieve both performance-and storage-efficient query of local histograms, we present a new algorithm called WaveletSAT, which utilizes integral histograms, an extension of the summed area tables (SAT), and discrete wavelet transform (DWT). Similar to SAT, an integral histogram is the histogram computed from the area between each grid point and the grid origin, which can be be pre-computed to support fast query. Nevertheless, because one histogram contains multiple bins, it will be very expensive to store one integral histogram at each grid point. To reduce the storage cost for large integral histograms, WaveletSAT treats the integral histograms of all grid points as multiple SATs, each of which can be converted into a sparse representation via DWT, allowing the reconstruction of axis-aligned region histograms of arbitrary sizes from a limited number of wavelet coefficients. Besides, we present an efficient wavelet transform algorithm for SATs that can operate on each grid point separately in logarithmic time complexity, which can be extended to parallel GPU-based implementation. With theoretical and empirical demonstration, we show that WaveletSAT can achieve fast preprocessing and smaller storage overhead than the conventional integral histogram approach with close query performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Histograms computed in local regions are used in many data analysis and visualization applications. For example, it can be used to determine the locations of material interface <ref type="bibr" target="#b28">[30]</ref>  <ref type="bibr" target="#b29">[31]</ref>, to design transfer functions for highlighting specific features in volume rendering, <ref type="bibr" target="#b12">[13]</ref>, and to analyze the complexity of data for vector field visualization <ref type="bibr" target="#b36">[38,</ref><ref type="bibr" target="#b35">37]</ref>. It can also be used as a feature descriptor for a block to track features in time-varying data <ref type="bibr" target="#b3">[4]</ref>. Although most of the existing methods only consider histograms of pre-defined local data blocks, having the ability to query histograms interactively in arbitrary regions is crucial for feature identification and tracking when the precise size and location of the feature is unknown.</p><p>Recently several research results have been reported to support efficient query of histograms from arbitrary regions. One straightforward approach to achieve this is to compute the histogram of the queried region on the fly which involves loading the data if they are not in main memory, and linearly scanning through the data elements. Because such a brute force approach is time-consuming for large data, different acceleration strategies have been used, including parallelizing the computation <ref type="bibr" target="#b0">[1]</ref> and performing incremental updates of histograms for overlapping regions to avoid redundant data scan <ref type="bibr" target="#b7">[8]</ref>  <ref type="bibr" target="#b32">[34]</ref>. Another approach is to pre-compute the histograms. Rather than generating the histograms of all possible locations and sizes, Porikli presented an idea called Integral Histograms <ref type="bibr" target="#b18">[20]</ref>, which can be treated as an extension of the summed area tables (SAT) <ref type="bibr" target="#b1">[2]</ref>. To create the integral histograms for a regular grid data, the histogram in the rectilinear region bounded by the origin and every grid point is computed. With the integral histograms, the histogram for any arbitrary axis-aligned region can be computed by combining the pre-computed histograms at the region corners in a manner similar to that of SAT. Since the combination involves a constant number of histograms, histograms in arbitrary re- gions can be efficiently computed regardless of the size and location of the queried region. Integral histograms have been widely used in computer vision, including the selection of feature sizes <ref type="bibr" target="#b9">[10]</ref> and the computation of local statistics for feature tracking <ref type="bibr" target="#b30">[32]</ref>.</p><p>In spite of the advantages, storing pre-computed integral histograms at all grid points can be quite expensive if the number of bins per histogram is large. While such a storage overhead might be affordable for an image of small to medium sizes, it will be too large for large images, videos, and high dimensional data. An alternative approach called Span Histogram was presented by Martin and Shen <ref type="bibr" target="#b14">[15]</ref>, which decomposes each volume interval into smaller spans and use a subset of the spans to control the working set size at run time. While the span histogram can reduce the run-time memory usage, issues related to the preprocessing and storage costs are not fully addressed.</p><p>In this paper, we present a new histogram query algorithm that simultaneously addresses issues related to the following aspects: storage efficiency, query performance, and preprocessing overhead. Essentially, our algorithm compresses integral histograms via Discrete Wavelet Transform (DWT). As the integral histogram can be considered as an extension of SAT, our algorithm is called WaveletSAT. The contribution of this paper is multi-fold: <ref type="bibr" target="#b0">1</ref>. We show that the integral histograms can be transformed to a sparse set of wavelet coefficients, and the histogram of an arbitrary region can be efficiently reconstructed from the wavelet coefficients.</p><p>2. Rather than computing the integral histograms first before applying wavelet transform, which requires an enormous amount of storage space, we discover that the wavelet transform can be achieved without pre-computing the integral histograms. The asymptotic time complexity of N D elements in D dimensions is O((N log 2 N) D ), which is independent to the number of bins.</p><p>3. We also show that the computation of WaveletSAT can be easily parallelized because each grid point can be transformed independently. A GPU-based implementation is presented to demonstrate this benefit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Applications of Local Histograms The applications of local histograms span across multiple areas, including image processing, com-puter vision, computer graphics, and visualization. In image processing, histograms are often used as feature descriptors of local regions because it is invariant to rotation and translation. Recently a similar concept has been applied to scientific visualizations. <ref type="bibr">Thompson et al.</ref> present the idea of HIXEL, which stores one histogram per grid point or per block <ref type="bibr" target="#b29">[31]</ref>. For time-varying feature tracking, <ref type="bibr">Gu and</ref> Wang use block histograms to search for the locations of features in different time steps <ref type="bibr" target="#b3">[4]</ref>. <ref type="bibr">Lundstrom et al.</ref> analyze the models in block histograms and design transfer functions accordingly to separate the models <ref type="bibr" target="#b12">[13]</ref>. From the data distribution, multiple statistics can also be derived. Examples include median filtering for noise removal <ref type="bibr" target="#b32">[34]</ref> [21], Shannon's entropy for local data complexity measure of vector fields <ref type="bibr" target="#b35">[37]</ref>  <ref type="bibr" target="#b36">[38]</ref>, and higher order statistics for detecting regions with different materials interface <ref type="bibr" target="#b28">[30]</ref>. More image statistics for computer graphics applications are discussed in a comprehensive survey by Pouli et al. <ref type="bibr" target="#b20">[22]</ref>.</p><p>Local Histogram Computation Driven by the wide applications, different approaches have been devised for fast query of local histograms. For applications that need to compute per-point statistics (such as median <ref type="bibr" target="#b32">[34]</ref> and local entropy <ref type="bibr" target="#b35">[37]</ref>) from the local neighborhood, the histograms from the earlier queries can be re-used such that only the grid points outside the overlapped region are scanned to update the histogram <ref type="bibr" target="#b7">[8]</ref>  <ref type="bibr" target="#b32">[34]</ref>. If the queried regions are arbitrary and non-overlapping, because the integral histogram approach <ref type="bibr" target="#b18">[20]</ref> support the query in constant time, it has been used in different image processing algorithms, including efficient median filtering and bilateral filtering <ref type="bibr" target="#b19">[21]</ref>, feature scale detection <ref type="bibr" target="#b9">[10]</ref>, and the computation of covariance matrices for feature tracking <ref type="bibr" target="#b30">[32]</ref>.</p><p>When the data size is large, computing and storing integral histograms is challenging. If the data are stored in supercomputers, the query can be accelerated via parallel algorithms. Chaudhuri et al. <ref type="bibr" target="#b0">[1]</ref> discussed the issues and solutions for computing local histograms on parallel machines. If the data can be represented in a multi-resolution grid such as octrees, the local histograms at different levels can be precomputed. At run time, the histogram in a region can be approximated from those in lower resolutions to reduce the I/O and memory costs. Examples of this approach include the span histograms presented by Martin and Shen <ref type="bibr" target="#b14">[15]</ref> and the sparse PDF presented by Hadwiger et al. <ref type="bibr" target="#b4">[5]</ref>.</p><p>Applications of Wavelet Transforms Wavelet transform, originally proposed by Wallat <ref type="bibr" target="#b13">[14]</ref>, has been widely applied to various scientific and engineering applications, including computer graphics <ref type="bibr" target="#b23">[25]</ref>, data mining <ref type="bibr" target="#b10">[11]</ref>, and visualization. One key advantage of wavelet transform is its ability to represent data in multi-resolutions. Based on this property, Shen et al. presented time-space partitioning trees that transform the volume at each time step to different levels of detail for fast volume rendering <ref type="bibr" target="#b25">[27]</ref>. Jenicke et al. used wavelet transform to analyze weather phenomena of different scales <ref type="bibr" target="#b8">[9]</ref>.</p><p>Also, because the input grid is converted to a more sparse representation, wavelet transform can be used for data compression. An example is the standard JPEG2000 <ref type="bibr" target="#b26">[28]</ref>. Recently Woodring et al. utilized JPEG2000 to transmit large scale climate data with bit rate control for remote data analysis and visualization <ref type="bibr" target="#b33">[35]</ref>. Wavelet can be also used to represent area sums <ref type="bibr" target="#b34">[36]</ref> and cumulative distribution functions (CDF) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>. Although the later works are highly relevant to ours, there are two fundamental differences. First, their works apply wavelet transform to a single CDF or a single summed area table, while we need to process one integral histogram at each grid point. Second, while their works directly use conventional wavelet transform for CDFs, our work presents a new wavelet transform algorithm that is optimized for integral histograms and can be easily parallelized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">INTEGRAL HISTOGRAMS 3.1 Summed Area Tables and Integral Histograms</head><p>As our algorithm WaveletSAT essentially transforms integral histograms to a sparse representation, we first review the concept of integral histograms. Integral histograms can be treated as an extension of Summed Area <ref type="table">Table (SAT</ref>   </p><formula xml:id="formula_0">u x ∑ x=l x u y ∑ y=l y I[x, y] = S[u x , u y ] − S[l x − 1, u y ] − S[u x , l y − 1] + S[l x − 1, l y − 1] (1)</formula><p>The computation of Equation 1 is also illustrated in <ref type="figure">Figure 1</ref>. It can be seen that by using SATs to compute the sum of a region, regardless of the size of this region, the area sum can be always computed in 4 operations.</p><p>Conceptually, the integral histograms of a 2D array are similar to its SAT except that each integral histogram element H[x, y] stores not a scalar but the histogram of values in the rectangle bounded by the origin <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b0">1]</ref> and <ref type="bibr">[x, y]</ref>. Similar to the computation of region sum via SAT, the histogram of a rectangle can be computed according to Equation 1, which is the combination of integral histograms at the 4 corners. As SATs can be applied to arrays of dimensions higher than 2, the concept of integral histograms can be extended as well.  </p><formula xml:id="formula_1">h R [b] = ∑ x 1 ∈{l 1 −1,u 1 } s u 1 (x 1 ) × • • • ∑ x D ∈{l D −1,u D } s u D (x D ) × H[x 1 , . . . x D , b] (2)</formula><p>where x i takes values from the lower and upper bound of the region in the i-th dimension, and:</p><formula xml:id="formula_2">s u (x) = +1 x = u −1 otherwise (3)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Properties of integral histograms</head><p>Although integral histograms support efficient query of range histograms, the space of integral histograms is B times larger than the original data. Besides, in order to store the sum, which can be a very large value, the number of bits allocated for each histogram bin to store the integer number should be increased too. Consequently, given a medium sized array, its integral histograms can be quite large. For instance, given a regular grid of 256 3 cells of bytes, in order to store the sum, the depth must be increased to at least 32 bits, requiring 8GB of total storage space. This prohibits the usage of integral histograms for large data. While integral histograms can be large, this paper shows that they can be transformed to a much more compact representation. The reason is that for each bin, its hyperslice H[x 1 , . . . , x D , b] in the integral histograms is a monotonically increasing function that can be transformed to few coefficients via Fourier or wavelet transform. Given a grid point, it contributes one step function to a bin of the integral histograms based on its function value. This step function has a value of one for any point whose coordinates are greater than those of this grid point in all dimensions, zero otherwise, as listed in Equation 4:  <ref type="figure" target="#fig_0">Figure 2</ref> illustrates the relationship among integral histograms, bin SATs, and the steps functions for a 1D function. Because the bin SAT is a sum of step functions, it is monotonically increasing. <ref type="figure" target="#fig_2">Figure 3</ref> shows the 32 bin SATs for the image Mandrill. While the original image contains small sharp features such as hairs, all bin SATs vary smoothly. In the next section, we describe how we can apply DWT to integral histograms efficiently, more specifically, at a time complexity independent of the number of bins and logarithmic to the number of points. </p><formula xml:id="formula_3">S y 1 ,...y D [x 1 , . . . , x D ] = 1 y d ≤ x d ∀d ∈ [1, D] 0 otherwise<label>(4)</label></formula><formula xml:id="formula_4">W 0,0 : +H 8 +H 8 +H 8 +H 8 +H 8 +H 8 +H 8 +H 8 W 1,0 : +H 8 +H 8 +H 8 +H 8 −H 8 −H 8 −H 8 −H 8 W 2,0 : +H 4 +H 4 −H 4 −H 4 0 0 0 0 W 2,1 : 0 0 0 0 +H 4 +H 4 −H 4 −H 4 W 3,0 : +H 2 −H 2 0 0 0 0 0 0 W 3,1 : 0 0 +H 2 −H 2 0 0 0 0 W 3,2 : 0 0 0 0 +H 2 −H 2 0 0 W 3,3 : 0 0 0 0 0 0 +H 2 −H 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">WAVELETSAT</head><p>Based on the property that each bin SAT</p><formula xml:id="formula_5">H[x 1 , . . . , x D , b]</formula><p>in the integral histograms is the sum of step functions</p><formula xml:id="formula_6">S x 1 ,...,x D where f (x 1 , . . . , x D )</formula><p>falls in the value range of bin b, we design our fast DWT algorithm for integral histograms. We call this fast DWT algorithm WaveletSAT because it essentially computes the wavelet transform for bin SATs.</p><p>Rather than directly computing DWT for bin SATs, WaveletSAT applies DWT to the step function of each grid point. This allows us not having to perform an explicit construction of the integral histograms followed by wavelet transform, resulting in more storage saving in the preprocessing stage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Discrete Wavelet Transform</head><p>Given a vector f [x] of N elements where N is a power of two, Discrete Wavelet Transform (DWT) converts the vector to N coefficients that describe the vector f in different levels of detail. One of the most commonly used wavelet transform is the Haar transform, which recursively decomposes f [x] into different levels of detail. First, the average and difference between f</p><formula xml:id="formula_7">[2i] and f [2i+1], i = 0, . . . , N/2−1,</formula><p>are computed into two separated vectors of length N/2. After the average and detail are normalized with 1/ √ 2, the vector of local average is decomposed again to its average and detail, each of which has N/4 elements. This process is recursively applied till the length of both detail vector and average vector becomes 1. This leads to log 2 N levels of detail vectors and one single value as the average of the entire f . The level is indexed by label ℓ = 0, . . . L where L = log 2 N represents the smallest scale.</p><p>The recursive process of DWT can be considered as a linear transform that projects f to N basis vectors derived from the Wavelet Functions as well. These basis vectors, which are called Wavelet Bases hereafter, can be categorized into 1 + log 2 N levels where each level corresponds to the wavelet function at a different scale. The wavelet function at level ℓ is denoted as W ℓ , and the length of the wavelet function is denoted as w ℓ . The basis vector of level L is constructed by using a wavelet functions called the Mother Wavelet. In this paper, only Haar wavelet is used, while the approach can be easily extend to other mother wavelets such as the Daubechies wavelet. More detail about these wavelets can be seen in other materials such as the SIGGRAPH course notes by Schröder et al. <ref type="bibr" target="#b23">[25]</ref>. <ref type="figure" target="#fig_3">Figure 4</ref> presents the wavelet basis vectors in a matrix form for N = 8. By using Haar wavelet as an example, the basis vector</p><formula xml:id="formula_8">W L,i [2i] = +1/ √ 2, W L,i [2i + 1] = −1/ √ 2, and W L,i [x] = 0 otherwise. For level ℓ = 1 . . . L − 1,</formula><p>the length w ℓ of the wavelet function is 2w ℓ+1 , thus the length becomes 2 L+1−ℓ . The number of wavelet basis at level ℓ is denoted as n ℓ , which is equal to the vector length N divided by the length of the wavelet function w ℓ , namely, n ℓ = N/w ℓ = 2 ℓ−1 for ℓ &gt; 0. Level 0 in DWT is a special case. As level 0 essentially represents the average of the entire f , the corresponding basis vector W 0,0 has N elements of the same value 1/ √ N, and only one wavelet basis exists at ℓ = 0.</p><p>The inner product between f and the wavelet basis W ℓ,i is denoted as F ℓ,i , which is also the projection from f to W ℓ,i because W ℓ,i has unit length. Hereafter F ℓ,i is called the wavelet coefficient for this wavelet basis, indicating the change of f in different scales: </p><formula xml:id="formula_9">Case 1: &lt; S 5 ,W 3,1 &gt;= 0 Case 2: &lt; S 5 ,W 3,3 &gt;= 0 Case 3: &lt; S 5 ,W 3,2 &gt;= −H S 5 : 0 0 0 0 0 1 1 1 W 3,1 : 0 0 + − 0 0 0 0 S 5 : 0 0 0 0 0 1 1 1 W 3,3 : 0 0 0 0 0 0 + − S 5 : 0 0 0 0 0 1 1 1 W 3,2 : 0 0 0 0 + − 0 0 (a) (b) (c)</formula><formula xml:id="formula_10">F ℓ,i =&lt; W ℓ,i , f &gt; ,ℓ = 0, . . . , L, i = 1 . . . n ℓ , where L = log 2 N (5)</formula><p>Given the wavelet coefficients F ℓ,i for ℓ = 0, . . . , L, i = 0, . . . , n ℓ −1, the original function vector f can be reconstructed by a linear combination of these wavelet basis vectors. This reconstruction is called Inverse DWT, which can be expressed as Equation 6:</p><formula xml:id="formula_11">f [x] = L ∑ ℓ=0 n ℓ −1 ∑ i=0 F ℓ,i W ℓ,i [x]<label>(6)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">DWT for 1D Step Functions</head><p>While there exist fast DWT algorithms in linear time complexity such as the lifting scheme <ref type="bibr" target="#b27">[29]</ref>, if DWT is applied to each bin SAT separately, the computation time will be proportional to the number of bins. Since the histograms should have more bins for more accurate representation of the distribution, transforming the integral histograms can be very time-consuming. Besides, conventional fast DWT algorithms require all data points to be available, which can be challenging for large data.</p><p>Rather than applying conventional DWT, our algorithm is based on the fact that the linear projection is additive and thus the DWT of a bin SAT is equal to the DWT of all contributing step functions. Furthermore, the DWT of a 1D step function S y (x) of length N only has 1 + log 2 N non-zero wavelet coefficients. This is because given a step function S y (x), except the point x = y − 1, every other point x and its neighbor x + 1 have the same function value. The wavelet basis at the same level can be categorized into three cases based on their relative locations with respect to the location y, as shown in <ref type="figure">Figure 5</ref>. Because wavelet transform essentially calculates the local difference at different points of a function, among the wavelet basis at the same level, only one of them can cover y and thus only this wavelet basis can have a non-zero projection. Hereafter the index i of this wavelet basis W ℓ,i at level ℓ is denoted as y(ℓ). Because this wavelet basis covers y, or namely y(ℓ)w ℓ ≤ y &lt; (y(ℓ) + 1)w ℓ , the index i = y(ℓ) = ⌊ y w ℓ ⌋ can be computed in constant time. The projection from the step function S y and W ℓ,i can be also efficiently computed. As shown in Equation 7, the projection is equal to the value sum after the location y − iw ℓ , which can be computed in a closed form for Haar wavelet or via a pre-computed look up tables for other wavelets.</p><formula xml:id="formula_12">&lt; S y ,W ℓ,i &gt; = (i+1)w ℓ −1 ∑ x=iw ℓ S y [x] ×W ℓ,i [x] = y−1 ∑ x=iw ℓ S y [x] ×W ℓ,i [x] + (i+1)w ℓ −1 ∑ x=y S y [x] ×W ℓ,i [x] = (i+1)w ℓ −1 ∑ x=y W ℓ,i [x] = w ℓ −1 ∑ x=y−iw ℓ W ℓ [x]<label>(7)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">WaveletSAT Algorithm</head><p>As a result, given a point y, its step function can only contribute to 1+log N wavelet coefficients because &lt; S y ,W ℓ,i &gt; is non-zero for only one wavelet basis per level ℓ. This leads to our WaveletSAT algorithm for a 1D regular grid: For each element y, we first decide the bin b y that contains its value f (y), and then update the 1 + log 2 N wavelets Because WaveletSAT updates 1 + log 2 N wavelet coefficients per data point, and each update can be achieved in constant time, its time complexity is O(N log 2 N) for N data points. It can be seen that the time complexity is independent of the number of bins. Compared to applying the conventional fast DWT algorithms to each bin SAT, a time complexity of O(BN), our algorithm is more efficient if the number of bins is larger than log 2 N. Besides, while conventional DWT requires all data points, WaveleteSAT can work for each data point independently, making the algorithm easy to parallelize, as is described in Section 6.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Query of Integral Histograms</head><p>From the wavelet coefficients, we can reconstruct the integral histogram at location x by applying the inverse DWT according to Equation 6. It should be noted that at each level ℓ, only one wavelet basis vector can have a non-zero value at x. The index of this wavelet basis is</p><formula xml:id="formula_13">x(ℓ) = ⌊ x w ℓ ⌋ since x(ℓ)w ℓ ≤ x &lt; (x(ℓ) + 1)w ℓ .</formula><p>As a result, Equation 6 can be reduced to Equation 8, requiring less multiplications. Here the subscript b is added to denote the value and coefficient of bin b.</p><formula xml:id="formula_14">f b [x] = L ∑ ℓ=0 n ℓ −1 ∑ i=0 F b,ℓ,i W ℓ,i [x] = L ∑ ℓ=0 F b,ℓ,x(ℓ) W ℓ,x(ℓ) [x]<label>(8)</label></formula><p>The computation of Equation 8 can be significantly reduced by utilizing the fact that the wavelet coefficients are sparse. As one data point can only contribute to the wavelet coefficients of a single bin, conversely, this basis can have at most w ℓ wavelet coefficients if a wavelet basis covers w ℓ data points. As a result, at least B − w ℓ bins will be 0. To fully utilize the sparse property, given a wavelet basis, the wavelet coefficients from all bins can be stored in a sparse array that skips the bins with zero values. During the query, we fetch the sparse array of wavelet coefficients and only need to update the bins with non-zero values. Section 4.6 further derives the time complexity to query a single integral histogram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Optimize Query of Region Histograms</head><p>As the main goal of integral histograms is to support the query of the histogram in an arbitrary region, which is a combination of several integral histograms, region query can be further accelerated using our algorithm.</p><p>To query the histogram in a 1D interval [y + 1, x], which involves the inverse DWT of f b [x] and f b [y], these inverse DWT can share the same wavelet coefficients. One example is shown in <ref type="figure">Figure 7</ref>. To query the region histogram for <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13]</ref>, the integral histograms at x = 8 and x = 13 will be needed. As the integral histogram of each point is reconstructed by the wavelet bases whose non-zero part covers this point, it can be seen that the wavelet basis W 0,0 , W 1,0 , and W 2,1 are shared by x = 8 and x = 13.</p><p>If a shared wavelet basis has C non-zero coefficients, which requires 2C multiplications for both grid points, we can first combine the corresponding wavelet basis values and then use the combined result to weight the vector of wavelet coefficients, requiring only C multiplications. Furthermore, if the weighted result is 0, the multiplication can be totally skipped. Two examples here are W 0,0 and W 1,0 . By weighting -1 to the wavelet basis values that cover x = 8, which is 1/ √ 8, and +1 to those that cover x = 13, which is also 1/ √ 8, the weighted sum becomes 0.</p><p>It should be noted that for Haar wavelet, as all wavelet value of W 0,0 is constant, such a combination is always 0 for region query. Because W 0,0 covers the entire domain and can have more non-zero wavelet coefficients than other wavelet bases, skipping its wavelet coefficients can obviously accelerate the query performance, which will be demonstrated in Section 7.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Space and Time Complexity</head><p>As described in Section 4.4, given a wavelet basis W ℓ,i , the number of bins with non-zero counts is bounded by both the number of bin B and length w ℓ of the wavelet function W ℓ . If the number of bins B is power of 2, the top 1 + L − log 2 B levels of wavelet basis will have more than B coefficients, and thus at most B bins will be needed. The basis of the other log 2 B levels will have at most w l coefficients, which are B, B/2, B/4, . . . 2. This is also illustrated in <ref type="figure" target="#fig_5">Figure 6</ref>.</p><p>Because of this property, we can derive the upper bound of the space complexity by considering the maximal number of non-empty bins. If we skip the zero wavelet coefficients, the space complexity is the total number of non-zero coefficients from all wavelet bases. For the later log 2 B levels from ℓ = L − log 2 B + 1 to L, the length w ℓ of the wavelet function where w ℓ = N/2 ℓ−1 , is smaller or equal to B. For each of these levels, the total number of coefficients from the n ℓ wavelet bases is n ℓ × w ℓ = N coefficients.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approach</head><p>Brute Force Computation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Integral Histograms</head><p>WaveletSAT</p><formula xml:id="formula_15">Storage O(N) O(BN) O(N(log 2 B)) Creation O(1) O(BN) O(NL) Query O(W ) O(B) O(B(L − log 2 B)) A 2D Step Function After Row-wise 1D DWT</formula><p>After Column-wise 1D DWT <ref type="figure">Fig. 8</ref>. Separable DWT for a 2D step function. The gray cells represent non-zero value. After applying a 1D DWT along the row, the row with the step functions are mapped to log 2 n + 1 non-0 coefficients. The step function of each of these log 2 n + 1 columns is transformed to log 2 n + 1 non-zero coefficients.</p><p>We can also derive the time complexity of the query algorithm in Section 4.4. The query is achieved by performing inverse DWT, which essentially combines the coefficients of one wavelet basis at each level. For the first 1 + log 2 N − log 2 B levels, each level has B coefficients to access. For the later log 2 B levels, the total number of accessed coefficients is B</p><formula xml:id="formula_16">+ B/2 + B/4 + • • •+ 2 = 2B − 2. Thus the total number of coefficient from all levels is B(1+log 2 N −log 2 B)+2B−2 = B(3+ log 2 N − log 2 B) − 2 = O(B(log 2 N − log 2 B).</formula><p>It can be seen that the performance of using WaveletSAT is close to that of using integral histograms, which is O <ref type="figure">(N(B)</ref>), if B is close to N. <ref type="table" target="#tab_4">Table 1</ref> summarizes the complexities of WaveletSAT. It also lists the complexities of integral histograms and the brute force approach that computes the histograms of the query region at run time. Although re-computing histograms by scanning through the data uses the least amount of storage, its query performance is proportional to the query region size. Integral histograms are efficient for run-time query but require most storage space. In contrast, WaveletSAT achieves a balance among storage size, preprocessing cost, and run time query speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DWT FOR HIGH DIMENSIONAL INTEGRAL HISTOGRAMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Separable DWT</head><p>The discrete wavelet transform can be extended to D dimensional grids. For multi-dimensional volume, we can apply a 1D DWT along each dimension separately. Once the 1D DWT has been applied to all scanlines along the first dimension, it is then applied to the scanlines along the second dimension of the transformed data and so on till the DWT has been applied to all dimensions. Such an approach is called Separable Discrete Wavelet Transform (Separable DWT). As the DWT for a 1D step function of length N only has 1 + log N non-zero coefficients, here we show that the number of non-zero wavelet coefficients for a D-dimensional step function is (1 + log N) D .</p><p>To illustrate this, we will first show that the DWT can transform a 2D step function S y 1 ,y 2 (x 1 , x 2 ) to (1 + log N) 2 non-zero coefficients. We first apply the 1D wavelet along the row dimension. A sample 2D step function is shown in <ref type="figure">Figure 8 (a)</ref>, and the result of the rowbased 1D DWT is shown in <ref type="figure">Figure 8 (b)</ref>. It can be seen that the rows with index r &lt; y 2 , the values are all 0 and thus the wavelet coefficients are all zero. Meanwhile, the rows with index r ≥ y 2 , the values form a step function S y 1 (x), and thus its wavelet transform has 1 + log 2 N non-zero wavelet coefficients at wavelet basis W 0,y 1 (0) ,W 1,y 1 (1) , . . . ,W L,y 1 (L) . Because the step functions for rows r ≥ y 2 are the same, their wavelet coefficients are identical too, and thus their wavelet coefficients of the same wavelet basis form a new step function along the column. For each of these wavelet bases W ℓ,y 1 (ℓ) , this new step function is S y 2 (x 2 ) scaled by &lt; S y 1 ,W ℓ,y 1 (ℓ) &gt;. By applying 1D DWT to the columns, the step function S y 2 is transformed to 1 + log N wavelet basis W ℓ,y 2 (ℓ) , 0 ≤ ℓ ≤ L, with the wavelet coefficients &lt; S y 2 ,W ℓ,y 2 (ell) &gt;, as shown in <ref type="figure">Figure 8</ref> (c). As a result, after separable DWT, the 2D step function S y 1 ,y</p><formula xml:id="formula_17">2 (x 1 , x 2 ) is transformed to (1 + log N) 2 wavelet coefficients &lt; S y 1 ,W ℓ 1 ,y 1 (ℓ 1 ) &gt;&lt; S y 2 ,W ℓ 2 ,y 2 (ℓ 2 ) &gt;.</formula><p>The process of separable DWT can be extended to higher dimensions. We can show that after the 1D DWT, a high dimensional step function</p><formula xml:id="formula_18">S y 1 ,...,y D (x 1 , . . . , x D ) in D dimensions is transformed to 1 + log 2 N step functions in D − 1 dimensions. Each step function corresponds to a wavelet basis W ℓ,y 1 (ℓ) with weight &lt; S y 1 ,W ℓ,y 1 (ℓ) &gt;, 0 ≤ ℓ ≤ L.</formula><p>By recursively applying the 1D DWT to these step functions in D − 1 dimensions till D = 0, we can generate (1 + log 2 N) D wavelet coefficients. Each of these wavelet coefficients is the projection of </p><formula xml:id="formula_19">S y 1 ,...,y D (x 1 , . . . , x D ) to the wavelet basis W ℓ 1 ,y 1 (ℓ 1 ) , . . . , W ℓ D ,y D (ℓ D ) ,</formula><formula xml:id="formula_20">(x 1 , . . . , x D ) is ∏ D d=1 W ℓ d ,i d [x d ]</formula><p>, and the size of non-zero sub tensor is ∏ D d=1 w d . One 2D example is shown in <ref type="figure" target="#fig_8">Figure 9</ref> (a) for W 1,0 along the x dimension and W 2,1 along the y dimension.</p><p>In this section, the non-zero sub tensor is called a kernel. In <ref type="figure" target="#fig_8">Figure  9</ref>  For each tensor, if its kernel size is smaller than B, its number of non-zero histogram bins will be bounded by its kernel size. Therefore S <ref type="figure">(N, D, B)</ref> is the sum of the bounded histogram bin counts from all tensors. When querying the integral histogram of any grid point, we only need to consider the wavelet basis tensor whose kernel covers  <ref type="figure">S(N, D, B</ref>) for 2D and 3D grids, respectively. Each ratio provides a theoretical upper bound of the compression rate, and thus higher is better. It shows that when B increases, the compression rate increases too. When the data length N increases, the compression rate also increases, although this rate will be bounded for large N. <ref type="figure" target="#fig_11">Figures 10f and 10h show the ratios Q(N, D, B</ref>)/B for 2D and 3D grids, respectively, where B is the query time with uncompressed integral histograms. Here smaller ratios mean that the query performance of WaveletSAT is closer to the performance with integral histograms. It shows that when more bins are used, the query performance of WaveletSAT is getting closer to that of integral histogram.</p><p>It should be noted that the ratios here are the theoretical bounds. For the real data sets, not all bins will have counts. This is especially true for a small wavelet basis tensor whose kernel can cover a region of values in the same bin and thus all except 1 bin have zero counts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">IMPLEMENTATION 6.1 Sparse Arrays for Wavelet Coefficients</head><p>The main implementation issue to consider for WaveletSAT is the data structure to store the wavelet coefficients. As the output of Wavelet-SAT is essentially the wavelet coefficients of all bin SATs, if all wavelet coefficients are stored, each bin SAT of N data item requires O(N) coefficients, which will be too large. Fortunately, we can utilize the sparse property of the wavelet coefficients to lower the storage consumption. In our data structure, each wavelet basis is associated with a sparse array to store the coefficients of all bins. Given a point y, &lt; S y ,W ℓ,y(ℓ) &gt; is added to the contributing bin in the sparse array for W ℓ,i . This sparse array only stores elements with non-zero values, and thus the storage requirement is reduced.</p><p>To implement the sparse arrays, both storage overhead and time complexity need to be considered.</p><p>We use the std::unordered map class in the C++ standard template library to implement the sparse array. As std::unordered map classes are essentially hash tables, they can be accessed in O(1) time on average <ref type="bibr" target="#b17">[18]</ref>. One issue for using std::unordered map is that additional storage for the hash tables is required. To minimize this storage overhead, our implementation counts how many times a wavelet basis has been updated. When the count reaches the size of the wavelet basis, this basis will not be updated anymore, and thus there is no need to keep the hash table. The sparse array is then released to save the storage after the elements with non-zero values are moved to a separate memory pool to be stored later.</p><p>Since using sparse arrays require a trade-off between performance and space, full arrays are still preferred if affordable. Starting from level 0, our implementation allocates full arrays to the wavelet basis until the total size of all full arrays exceeds an upper limit. The impact of this upper limit to the performance is discussed in Section 7.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">WaveletSAT Encoding via GPGPU</head><p>As WaveletSAT transforms each data point independently, the encoding stage can be easily parallelized by GPUs. The basic idea is assigning each grid point to a GPU thread to compute its wavelet coefficients, and then summing up the wavelet coefficients of the same bin and wavelet basis. To implement this idea, we need to consider the required memory space on the GPU. Because the texture memory is much more limited than the system memory, the wavelet coefficients of all grid points cannot be stored simultaneously.</p><p>To overcome this issue, first, our implementation partitions the grid into blocks. Since the grid points are transformed independently, the grid can be partitioned arbitrarily as long as each block can fit in the texture memory. Second, other than computing the O((log 2 N) D ) wavelet coefficients for each grid point in a single GPU kernel call, which requires O(K(log 2 N) D ) memory entries for block size K, a single GPU kernel only computes one wavelet coefficient. In the CPU side, our implementation iterates through all wavelet functions. For each wavelet function W ℓ , we invoke a GPU kernel to compute the wavelet coefficient W ℓ,y(ℓ) for each grid point y. In such a case, only O(K) memory space is required.</p><p>Once the transform is done, our implementation reduces the wavelet coefficients by summing up the coefficients of the same bin and wavelet basis into a single value. The sums are copied back to the CPU to update the bin SATs. As the memory transfer between CPU and GPU is a major bottleneck, such a reduction can reduce the amount of data to transfer. In order to efficiently add the wavelet coefficients together, which are scattered in the memory, it is desired to put the coefficients of the same bin and wavelet basis in consecutive memory locations so the sums can be efficiently computed by parallel prefix sum computation <ref type="bibr" target="#b24">[26]</ref>. <ref type="figure" target="#fig_12">Figure 11</ref> illustrates the process to sum the coefficients, which is similar to the concept behind MapReduce <ref type="bibr" target="#b2">[3]</ref>. For each grid point y, in addition to compute its wavelet coefficient, we also compute a key that combines its bin and the index of the wavelet basis. To reduce wavelet coefficients of the same key, we first order the coefficients by their keys via GPU-based radix sort <ref type="bibr" target="#b21">[23]</ref>. After a parallel prefix sum <ref type="bibr" target="#b24">[26]</ref> is applied, the sums of consecutive coefficients of the same key are downloaded back to the CPU. Our implementation uses the radix sort function in nVidia Thrust library [19] and prefix sum implementation in the library CUDPP <ref type="bibr" target="#b5">[6]</ref>. By reducing the coefficients on the GPU,</p><formula xml:id="formula_21">HydrogenAtom (128 3 ).</formula><p>Foot (256 3 ).</p><p>Ocean (3600×2400). The intensity of the white current over the ocean represents the local vector magnitude. Our tests used the vector orientation to form the histograms. MJO (2699 × 599). Our tests used the quantity QVAPOR at 583hPa at time stamp 00:00:00, January, 01, 2008.  <ref type="figure" target="#fig_2">Fig. 13</ref>. Encoding performance of WaveletSAT and integral histograms. The red curves are for WaveletSAT and the blue ones are for integral histograms. Top row: The encoding time (logarithmic scale) for WaveletSAT with GPU (✷), WaveletSAT without GPU (✸), integral histograms without zip compression ( ), and integral histograms with zip compression (×). Bottom row: The detailed encoding time, including the timings for DWT and file writing. Each pair along the Y axis indicates the number of bins and the testing architecture (C for CPUs and G for GPUs).</p><p>the memory transfer time is significantly reduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULT</head><p>This section presents the performance of WaveletSAT, including the encoding time, query time, and the compression rate. The test data sets are listed in <ref type="figure" target="#fig_0">Figure 12</ref>, which include 2D and 3D regular grids. We used Haar wavelet as the mother wavelet. The wavelet coefficients were computed and stored in double precision.</p><p>We compare WaveletSAT with integral histograms to demonstrate the benefit of WaveletSAT. As computing the entire integral histograms can be quite expensive storage wise, we implemented a memory-efficient approach that requires the space for only one bin SAT. This approach maintains a temporary grid which has the same size as the input grid when iterating through the bin SATs. For a given bin, each grid point outputs its contribution to the corresponding point in the temporary grid. Then the SAT of this temporary grid is computed and saved to disk. This temporary grid can be re-used for the next bin. The integral histograms were stored in the NetCDF 4.0 file format <ref type="bibr" target="#b31">[33]</ref>. The reason to use NetCDF is multifold. First, NetCDF provides flexible APIs to access subarrays in arbitrary dimensions, which can be used to query the integral histograms of arbitrary points. Second, since version 4.0, NetCDF supports built-in zip compression/decompression. Therefore, when saving integral histograms, they can be immediately compressed by zip. This also allows us to compare WaveletSAT with zip, a conventional lossless compression standard. As zip has 9 compression levels, our experiments tested level 1 (the fastest one with reasonable compression rates) and level 9 (the one with the highest compression rate). For WaveletSAT, we store the wavelet coefficients from all wavelet bases into a 1D array as the pool. Each coefficient is associated with its bin, which is stored in the same location of another array. Each wavelet basis is associated with the count of non-zero coefficients and a pointer to the pool. The counts and pointers of all wavelet bases are stored in two separate lookup tables of the same size as the input grid. The two 1D pools and the two lookup tables are stored in a single NetCDF file, which can be further compressed by zip compression. The WaveletSAT files were compressed with z = 1. <ref type="figure" target="#fig_2">Figure 13</ref> summarizes the performance of WaveletSAT and integral histograms. The test system has an Intel Core i7 2600 CPU, 16GB of system memory, and one nVidia GeForce GTX 560 graphics adapter. The OS was Windows 7 and the compiler was Visual Studio 2010. The GPU-based implementation partitions the grid into blocks of at most 4 million entries. 8GB of memory space was allocated as the upper limit for full arrays. More discussion about the upper limit is provided in Section 7.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Encoding Time</head><p>The top row of <ref type="figure" target="#fig_2">Figure 13</ref> lists the encoding time of WaveletSAT and our integral histogram implementation. It can be seen as the time of integral histograms increases when more bins are computed, the performance of both CPU-based and GPU-based WaveletSAT remains stable. The GPU-based WaveletSAT is always faster than integral histogram computation. The CPU-based implementation is also faster than computing integral histograms with more than 64 bins. When computing integral histograms, more than 60% of time was used to write the bin SATs to NetCDF files. As a result, although there also exist GPU-based implementations of SAT computation <ref type="bibr" target="#b6">[7]</ref>, the acceleration will be limited for large integral histograms.</p><p>The WaveletSAT timing includes two stages: DWT and file writing, which are depicted in the bar charts in the bottom row of <ref type="figure" target="#fig_2">Figure 13</ref>. We can see that the acceleration of our GPU-based WaveletSAT is more apparent for 3D datasets. Besides, compared to WaveletSAT, the time of file I/O is proportional to the number of coefficients, which is more correlated to the number of bins. <ref type="figure" target="#fig_3">Figure 14</ref> lists the compression rates of different compression approaches. It can be seen that when more bins are used, the compression rate (CR) of all compression algorithms increases. This indirectly demonstrates that when more bins are used, because the data become sparser, there is more space to compress the integral histograms. Meanwhile, even without ZIP compression, WaveletSAT can already reduce the size of integral histograms of 128 bins by more than 8 times (the Ocean data set). We can achieve higher compression rate by combining WaveletSAT and zip compression. This allows us to further compress the original integral histograms of 128 bins by more than 40 times. The compression rate can be even higher than 150 for Hydro-genAtom and MJO.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Compression Rates</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Query Performance</head><p>The top row of <ref type="figure">Figure 15</ref> shows the query performance of integral histograms. For the timing of integral histograms without WaveletSAT, our tests loaded all integral histograms to the memory if the total size was smaller than 8GB. Otherwise, the integral histograms were left in the disk. In such an out-of-core case, NetCDF API is used to fetch the integral histograms. In contrast, when using WaveletSAT, we can load the entire wavelet coefficients to the memory since they are more compacted. Our tests randomly queried integral histograms at different locations. Here the numbers are the average query time. 8192 queries were made with wavelet coefficients and in-core integral histograms. For the query with out-of-core integral histograms, only 128 queries were made since the response time is much slower. Among these charts, it is not surprising that using in-core integral histograms is the fastest approach since no decompression is needed. Nevertheless, because of the size limitation, not all integral histograms can be loaded. The examples include Foot with more than 32 bins and Ocean with more than 64 bins. Consequently, their performance numbers are missing.</p><p>Loading wavelet coefficients is also much faster than loading integral histograms. The loading times of different cases are shown in <ref type="figure" target="#fig_5">Figure 16</ref>. It can be seen that the loading time of integral histograms grow faster than that of wavelet coefficients when the number of bins increases. For more than 64 bins, loading wavelet coefficients becomes faster. It should be noted that zip compression can also impact the query performance, especially for out-of-core cases. On the one hand, because zip compression can reduce the file size, the loading time can be shortened. On the other hand, when the zip compression level is increased, decompression requires extra CPU cycles. This explains why loading integral histograms compressed with z = 9 can be slower than z = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Query Optimization by Merging Coefficients</head><p>As our ultimate goal is to query the region histograms, here we discuss the performance of our optimized scheme for region histogram query described in Section 4.5. The bottom row of <ref type="figure">Figure 15</ref> lists the query times with the optimization that merges coefficients, plotted as black curves. The numbers were measured for different region sizes. In each chart, the red curves represent the timing of WaveletSAT, which is essentially the corresponding red curve in the top chart scaled by 2 D because one region query is combined by 2 D integral histograms.</p><p>Similarly, each blue curve represents the timing of conventional integral histograms for region query, which is equivalent to the blue curve in the top chart scaled by 2 D as well. It can be seen the performance of smaller region size becomes closer to that of the conventional integral histograms. As the query can be optimized by merging the shared wavelet coefficients, the performance gap between integral histograms and wavelet coefficients is reduced. The performance of WaveletSAT depends on how the memory is utilized, as described in Section 6.1. More precisely, the performance depends on the upper limit of the size for full arrays. <ref type="figure" target="#fig_16">Figure 17</ref> shows the test results with different upper limits. We only show the result for Foot and Ocean in 128 bins because their integral histograms require more than 8GB memory space. <ref type="figure" target="#fig_16">Figure  17</ref> also shows the encoding performance with and without GPUs. It can be seen that when the upper bound is reduced, the encoding time becomes larger. On the other hand, when GPUs are used, the impact of full arrays becomes smaller than the CPU-only performance. This is because the coefficients are reduced on GPUs, and thus the sparse arrays will be accessed less frequently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Impacts of Full Array Limits</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">DISCUSSION 8.1 Applications</head><p>The original motivation behind our work is to extend the informationtheoretic framework presented by Xu et al. <ref type="bibr" target="#b35">[37]</ref> for flow visualization. A key step of this framework is to measure the local flow complexity. For each point, the histogram of vector orientations within its local neighborhood is collected to compute the Shannon entropy. The entropy values at all grid points form a scalar field called Entropy Field, which can indicate the divergence of flow direction in the local regions and thus can assist the placement of graphical primitives such as glyphs and streamline seeds. A major issue in this framework is the local neighborhood size, which was manually specified. Our original motivation was to automatically select the local neighborhood sizes. Similar to the Shift-invariant Feature Transform (SIFT) <ref type="bibr" target="#b11">[12]</ref>, our plan was to compute the entropy fields of different neighborhood sizes. For each grid point, we can evaluate how the entropy value changes along the neighborhood size to decide the appropriate feature scale. Then we realized that an efficient way to compute local histograms is needed, or the collection of local histograms can be time consuming when the window size increases.</p><p>Our first trial was using integral histograms to compute entropy fields for 2D vector fields. Because the histogram of a 2D region is the combination of 4 integral histograms with fixed offsets, the computation time becomes independent to the region size. Besides, the operation can be easily parallelized in vector operators. This property makes the entropy computation also efficient on the MATLAB. Although MATLAB is an interpretive language, because its implementation is optimized for matrix/vector operators, only 1.8 seconds were used to compute 19 entropy fields of neighborhood sizes from 2 to 20 for a 2D vector filed of 100 × 100 grid points However, when we extended integral histograms to 3D flow fields, the storage became an issue, and thus WaveletSAT was developed to overcome this issue. To demonstrate that WaveletSAT can benefit the collection of local histograms, <ref type="figure" target="#fig_17">Figure 18</ref> presents the average query time of WaveletSAT and the brute force approach with different query length N. It can be seen that the larger the query region is, the larger the gap between the brute force approach and WaveletSAT becomes. As a result, WaveletSAT can assist applications that need the local histograms at different locations with different scales. One target application is transfer function design because local histograms can be used as the feature descriptor for different regions, as the work presented by Lundstrom et al. <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Limitations</head><p>The main limitation of both WaveletSAT and integral histograms is that they are mainly designed for regular grids. To extend this work for irregular grids, regular sampling of the domains might be needed. As WaveletSAT can efficiently compress the integral histograms, combining WaveletSAT with regular sampling can be one way to support region query for irregular grids.</p><p>Besides, both are for axis-aligned rectilinear regions. One way to support non-axis aligned regions or even regions of arbitrary shapes is to approximate the queried region as multiple axis-aligned rectangles. Such an approach has been used to compute the sum of arbitrary regions in SATs, which can be applied to fast global illumination computation on GPUs <ref type="bibr" target="#b22">[24]</ref>.</p><p>Another limitation in our model is that we assume each grid point only contributes to one bin in the histogram. If we consider the value distribution within the grid cells as well, one cell can contribute to multiple bins, which can increase the encoding time and storage by the average length of non-zero bins per grid cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>This paper presents WaveletSAT, an algorithm that supports efficient query of histograms for arbitrary rectangular regions. Our approach essentially uses discrete wavelet transform to compress integral histograms. Similar to the summed area tables (SAT), integral histograms support efficient range query but require more storage space because each grid point needs to store an integral histogram, not a scalar value. WaveletSAT facilitates more efficient computation of integral histograms and produce a more compact representation for the transformed results. In the future, we will extend the work along the following directions. First, we will apply WaveletSAT to time-varying data and in situ data analysis. Second, we will parallelize WaveletSAT for cluster environment, which is crucial when the data size exceed the capacity of a single node. Because WaveletSAT can be applied to each grid separately, such an extension should be straightforward.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>The relationship among integral histograms, bin SATs, and steps functions.(a): A sample 1D function f (x). (b): Mapping each grid point x from its value f (x) to the histogram bin. For each x, the corresponding bin is marked with the symbol 1 in blue. (c): Use bin 3 (from the bottom in (b)) to illustrate how a bin SAT is composed of multiple step functions s x where f (x) falls into this bin. (d): The sum of the corresponded 4 steps functions. As bin 3 has 4 counts, the sum becomes the SAT value for this bin. (e): The integral histograms H(x, b) for f (x), which are formed by stacking all bin SATs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Given a D-dimensional array f [x 1 , . . . x D ], its integral histograms H with B histogram bins can be represented as a D + 1-dimensional array where H[x 1 , . . . x D , b], b = 1 . . . B, represents the index of the bin in the histogram of the Ddimensional rectangle bounded by [1, . . . 1] and [x 1 , . . . x D ]. Given a region R where each dimension is bounded by l d and u d , the count in the b-th bin of the histogram can be computed by combining the counts of the same bin in 2 D integral histograms, as shown in Equation 2:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>The bin SATs of the 32-bin integral histograms of Mandrill. Brighter colors represent higher histogram counts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Wavelet basis vectors for N = 8. Here the wavelet function is the Haar wavelet, and H k = 1/ √ k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .√ 2 .</head><label>52</label><figDesc>The three cases to project a step function to the wavelet basis. The positive and negative signs represent the Haar wavelet basis, whose absolute value H is 1/ (a): The non-zero support of the wavelet basis is totally before the step. (b): The non-zero support of the wavelet basis is totally after the step. (c): The non-zero support of the wavelet basis covers the step. The projection values of both (a) and (b) are zero.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>-log B levels of basis with #coef. &gt; #bins log B levels of basis with #coef &lt;= #bins Distribution of wavelet coefficients where N = 16 and B = 8. 1 + log 2 N − log 2 B levels of wavelet basis can have at most B bins of non-zero counts because their sizes w ℓ are larger than B, shown as gray cells. log 2 B levels of wavelet basis have coefficients smaller than or equal to the wavelet size w ℓ , shown as white cells. Each pairs of numbers along the x axis represents the level and the index of the wavelet basis. coefficients of bin b y . At each level ℓ, &lt; S y ,W ℓ,y(ℓ) &gt; is added to the coefficient for the wavelet basis W ℓ,y(ℓ) of bin b y . Hereafter the wavelet coefficient for the wavelet basis W ℓ,i of bin b is denoted as F b,ℓ,i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>13 Fig. 7 .</head><label>137</label><figDesc>Shared wavelet bases for the query of region [9, 13] from 16 elements. Each cell records the sign of the Haar wavelet value. The left (right) shows the wavelet bases for x = 8 (x = 13). The cells with red (blue) colors are used to reconstruct its integral histogram with the weight -1 (+1). Both share the wavelet bases W 0,0 , W 1,0 , and W 2,1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>For other levels ℓ = 0 . . . 1 + L − log 2 B, each wavelet basis can have at most B bins of non-zero coefficients. Because the top levels totally have 1+2 L−log 2 B −1 = N/B bases, these levels totally have at most BN/B = N coefficients. Thus the total number of coefficients from all levels are O(N(1 + log 2 B)). Compared to integral histograms with space complexity O(NB), WaveletSAT algorithm can compress the integral histogram by O(B/(1+log 2 B)) times.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Wavelet basis tensors with D = 2 and N = 8. (a): A wavelet basis tensor, which is the combination of W 1,0 along the x dimension and W 2,1 along the y dimension. Here Haar wavelet is used and only the signs of non-zero tensor values are shown. The kernel size is 4 × 2. (b): Kernel sizes of all 2D wavelet basis tensors. Each combination of scales w ℓ d is plotted with a thick box.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>and the projection value is ∏ D d=1 &lt; S y d ,W ℓ d ,y d (ℓ 1 ) &gt;. This leads to the WaveletSAT algorithm for a D-dimensional grid of N D points: For each grid point, WaveletSAT computes the (1 + log 2 N) D wavelet coefficients of its step function, and then update the corresponding wavelet basis to the corresponding bin SAT. As a result, this algorithm has time complexity O(N D (log 2 N) D ), which is still independent of the number of bins. 5.2 Complexity Analysis of Space and Query Time This section describes the asymptotic analysis of space complexity S(N, D, B) and the query time complexity Q(N, D, B) for a B-bin integral histogram in a D-dimensional grid with grid length N in each dimension. Similar to Section 4.6, the asymptotic complexities are related to B and the sizes of the wavelet functions. As 1D DWT is equivalent to projecting the original grid to N wavelet basis vectors, D-dimensional separable DWT is equivalent to projecting the grid to N D tensors of rank D. Given one wavelet basis vector per dimension, says W ℓ d ,i d , d = 1, . . . , D, a tensor is formed where the value of element</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(b), for instance, each cell represents one wavelet basis tensor, and the number pairs show the corresponding kernel size. As n ℓ wavelet basis vectors are derived from the wavelet function of the same scale w ℓ , the tensors of the same kernel sizes are further grouped, as shown in the black thick boxes. Each thick box represents a combination of the scales w ℓ d . As each dimension has 1 + log 2 N wavelet functions, there are (1 + log 2 N) D combination in total.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .</head><label>10</label><figDesc>Empirical evaluation of query time complexity Q(N, D, B) and space complexity S(N, D, B). The scale of the Y axes in the top row is logarithmic. The left (right) two columns are for 2D (3D) grids. (e) and (g): O(BN D ), the space complexity of integral histograms, divided by S(N, D, B). (f) and (h): Q(N, D, B) divided by O(B), the query time complexity of integral histograms. The markers , ×, ▽, ✸, and are for N = 2 8 , 2 9 , . . . , 2 12 , respectively. this point. Because only one tensor in each combination of wavelet scales will cover the point, Q(N, D, B) can be computed by iterating through the combinations of all wavelet scales: Given a scale combination w ℓ 1 , . . . , w ℓ D , if the kernel size ∏ D d=1 w ℓ d is larger than or equal to B, B bins are added to Q(N, D, B), or its kernel size is added to Q(N, D, B) otherwise. Although the derivation of the closed forms for arbitrary D is not trivial, we can compute S(N, D, B) and Q(N, D, B). In Figure 10, the top row shows the computed S(N, D, B) and Q(N, D, B) with different N and B for 2D and 3D grids. In the bottom rows, Figures 10e and 10g shows the ratio of BN D , the space complexity of integral histogram, divided by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 .</head><label>11</label><figDesc>GPU-based MapReduce for WaveletSAT. In the Map stage, each grid point y is mapped to the index of the wavelet basis that covers y and the corresponding wavelet coefficient from its step function, and the value f (y) is mapped to the histogram bin. After sorting the output based on the bin and wavelet basis index, the Reduce stage sums the entries of the same bin and wavelet basis index. All stages can be executed on GPUs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 14 .</head><label>14</label><figDesc>Compression Rates (CR) of zip (z) and WaveletSAT in logarithmic scale. The blue curves are for conventional integral histograms (z = 1 (×) and z = 9 (▽)). The red ones are for WaveletSAT (z = 0 (✷) and z = 1 (✸)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 15 .Fig. 16 .</head><label>1516</label><figDesc>Query time (logarithmic scale) of WaveletSAT and integral histograms. The blue curves are for integral histograms. The red curves are for WaveletSAT. Top row: Average query time (Markers: in-core integral histograms (×); out-ofcore integral histograms without zip compression (✸), with z = 1 ( ), and with Z = 9 (▽)). Bottom row: Average query time of region histograms. The black curves represent WaveletSAT with the coefficient merging scheme in Section 4.4 with different sizes (1 (✷), 4 (✸), and 16 ( Loading time of WaveletSAT without zip compression (✷), WaveletSAT with zip compression (✸), integral histograms without zip compression ( ), and integral histograms with z = 1 (×) and z = 9 (▽).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 17 .</head><label>17</label><figDesc>Performance of WaveletSAT encoding under different full array sizes with 128 bins on CPUs (red) and GPUs (blue).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 18 .</head><label>18</label><figDesc>Average query time (logarithmic scale) of region histograms by WaveletSAT (red) and brute force approach (blue).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>2D example of area sum computation via SAT. The sum of the function values in the region between [l 1 , l 2 ] and [r 1 , r 2 ] (left-most figure) can be computed by adding the precomputed SAT values in each of the regions weighted with their signs shown within in the four figures on the right. Similarly, by storing the integral histogram H[x, y] at each point [x, y], the histogram in an arbitrary rectangular region between [l 1 , l 2 ] and [r 1 , r 2 ] can be computed with a constant computational complexity.</figDesc><table><row><cell cols="2">Area sum of region</cell><cell></cell><cell>SAT</cell><cell>SAT</cell><cell>SAT</cell><cell>SAT</cell></row><row><cell>l1, l2 [l1, r1] x [l2, r2]</cell><cell>=</cell><cell>+ +</cell><cell>+S[r1, r2] + +</cell><cell>r1, l2 -S[r1, l2 --1] --</cell><cell>-S[l1 --1, r2] --</cell><cell>l1, l2 +S[l1 --1, l2 --1] +</cell></row><row><cell>r1, r2</cell><cell></cell><cell></cell><cell>r1, r2</cell><cell></cell><cell>l1, r2</cell><cell></cell></row><row><cell>Fig. 1. A</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note>). Given a 2D array I[i, j], its SAT S is</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>, . . . , x D , b] is equal to the sum of the step functions S y 1 ,...,y D for all points [y 1 , . . . , y D ] whose values fall into bin b. Namely, H[x 1 , . . . , x D , b] is the SAT of a D-dimensional volume where each voxel records the contribution of f (x 1 , . . . , x D ) to bin b. Hereafter we call H[x 1 , . . . , x D , b] the Bin SAT of bin b.</figDesc><table><row><cell>Essentially, given a bin b, H[x 1</cell></row><row><cell>Mandrill</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 .</head><label>1</label><figDesc>Complexity comparison. N: Data length (L = log 2 N). B: Histogram size.</figDesc><table /><note>W : Length of the queried region.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0" />
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Scalable computation of distributions from large scale data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Peterka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LDAV &apos;12: Proceedings of the IEEE Symposium on Large Data Analysis and Visualization</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="113" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Summed-area tables for texture mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">C</forename><surname>Crow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;84: Proceedings of the ACM Conference on Computer Graphics and Interactive Techniques</title>
		<imprint>
			<date type="published" when="1984" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="207" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Mapreduce: simplified data processing on large clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="113" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Transgraph: Hierarchical exploration of transition relationships in time-varying volumetric data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2015" to="2024" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Sparse pdf maps for non-linear multi-resolution image operations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sicat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Möller</surname></persName>
		</author>
		<idno>133:1-133:12</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">CUDPP: CUDA Data-Parallel Primitives Library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tzeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Patel</surname></persName>
		</author>
		<ptr target="http://cudpp.googlecode.com/" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Parallel Prefix Sum ( Scan ) with CUDA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GPU Gems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">851876</biblScope>
			<date type="published" when="2007" />
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Two-Dimensional Digital Signal Processing II: Transforms and Median Filters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Huang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
			<publisher>Springer-Verlag New York, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Visual exploration of climate variability changes using wavelet analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Janicke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bottinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Mikolajewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1375" to="1382" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Beyond sliding windows: Object localization by efficient subwindow search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lampert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaschko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR &apos;08: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A survey on wavelet applications in data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ogihara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGKDD Explorations Newsletter</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="49" to="68" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Object recognition from local scale-invariant features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV &apos;99: Proceedings of the IEEE International Conference on Computer Vision</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1150" to="1157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Local histograms for design of transfer functions in direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lundstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ljung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ynnerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1570" to="1579" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A theory for multiresolution signal decomposition: the wavelet representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mallat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="674" to="693" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Transformations for volumetric range distribution queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PacificVis &apos;13: Proceedings of the IEEE Pacific Visualization Symposium</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Wavelet-based histograms for selectivity estimation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Matias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="448" to="459" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dynamic maintenance of waveletbased histograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Matias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB &apos;00: Proceedings of the International Conference on Very Large Data Bases</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Microsoft</surname></persName>
		</author>
		<ptr target="https://developer.nvidia.com/thrust" />
		<title level="m">map Class, Visual</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>Studio 2010 edition. [19] NVIDIA Corporation. Thrust</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Integral histogram: a fast way to extract histograms in cartesian spaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Porikli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR &apos;05: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="829" to="836" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Constant time o(1) bilateral filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Porikli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR &apos;08: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A survey of image statistics relevant to computer graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pouli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Cunningham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Reinhard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1761" to="1788" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Designing efficient sorting algorithms for manycore gpus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPDPS &apos;09: Proceedings of the IEEE International Symposium on Parallel&amp;Distributed Processing</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Extinction-based shading and illumination in gpu volume ray-casting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Makhinya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1795" to="1802" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Salesin</surname></persName>
		</author>
		<title level="m">Wavelets in Computer Graphics: SIGGRAPH &apos;96 Course Notes</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient parallel scan algorithms for many-core gpus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Scientific Computing with Multicore and Accelerators</title>
		<editor>J. Kurzak, D. A. Bader, and J. Dongarra</editor>
		<imprint>
			<publisher>Taylor &amp; Francis</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="413" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A fast volume rendering algorithm for time-varying fields using a time-space partitioning (tsp) tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Vis &apos;99: Proceedings of the IEEE Visualization</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="371" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The jpeg 2000 still image compression standard</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Skodras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Christopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ebrahimi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal processing Magazine</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="36" to="58" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The lifting scheme: A construction of second generation wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Mathematical Analysis</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="511" to="546" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Salient iso-surface detection with model-independent statistical signatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tenginakai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Machiraju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Vis &apos;01: Proceedings of the IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="231" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Analysis of large-scale scalar data using hixels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thompson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pebay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LDAV &apos;11: Proceedings of the IEEE Symposium on Large Data Analysis and Visualization</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Region covariance: A fast descriptor for detection and classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Tuzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Porikli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Meer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV &apos;06: Proceedings of the European Conference on Computer Vision</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="589" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">University Corporation for Atmospheric Research. NetCDF (Network Common Data Form)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Fast median and bilateral filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="519" to="526" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Revisiting wavelet compression for large-scale climate data using jpeg 2000 and ensuring data precision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Woodring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mniszewski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Brislawn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Demarle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ahrens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LDAV &apos;11: Proceedings of the IEEE Symposium on Large Data Analysis and Visualization</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Using wavelet decomposition to support progressive and approximate range-sum queries over data cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM &apos;00: Proceedings of the ninth international conference on Information and knowledge management</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="414" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An information-theoretic framework for flow visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-Y.</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1216" to="1224" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Parallel hierarchical visualization of large time-varying 3d vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC &apos;07: Proceedings of the ACM/IEEE Conference on Supercomputing</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
