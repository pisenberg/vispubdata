<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Toward Localized Topological Data Structures: Querying the Forest for the Tree</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pavol</forename><surname>Klacansky</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Peer-Timo</roleName><forename type="first">Attila</forename><surname>Gyulassy</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valerio</forename><surname>Bremer</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pascucci</surname></persName>
						</author>
						<title level="a" type="main">Toward Localized Topological Data Structures: Querying the Forest for the Tree</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/TVCG.2019.2934257</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Merge tree</term>
					<term>parallel computation</term>
					<term>topology</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1: Our localized merge forest data structure partitions the Foot data set, computes local merge trees, and connects them via a bridge set. On the left, the entire superlevel set at threshold 84, where the dark lines highlight the cells in the bridge set connecting the regions of the domain decomposition and the local trees of the forest. On the right, the Components query on the merge forest returns the five largest connected components in the superlevel set, shown in unique colors. The query correctly resolves the connectivity and eliminates the noise.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Direct analysis of contemporary scientific data sets remains challenging due to the complexity and high resolution of the data. The extraction, effective analysis, and visualization of complex features require advanced techniques and algorithms. Complex features of interest include ignition kernels in combustion <ref type="bibr" target="#b28">[29]</ref>, organs in CT scans <ref type="bibr" target="#b10">[11]</ref>, or galaxies in cosmology <ref type="bibr" target="#b37">[37]</ref>. However, these features are not well defined, the data may contain noise, and a range of parameters needs to be explored. In this context, topological techniques provide a rigorous mathematical framework to define and extract features across all thresholds, allowing interactive exploration. Furthermore, topological features can be ranked and simplified by persistence <ref type="bibr" target="#b16">[17]</ref> or similar metrics, which enables a multiscale analysis as well as noise removal.</p><p>Traditionally, topological analysis has been divided into two stages: a preprocessing stage to compute topological structures, such as the merge tree or the Morse-Smale complex, and an analysis stage, where we use a topological structure to answer queries. Since we do not know which specific queries might be required, we compute a global structure that will accelerate all possible queries. However, not all queries may be necessary for the analysis, and computation of the global information that can accelerate all queries limits the parallelism. Furthermore, constructing and storing the fully resolved global topological structure has a large memory overhead. As a result, the analysis of larger data sets has typically required distributed computation on a supercomputer combined with a partial representation that stores spar- sified global information on each processor <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref>. In this paper, we focus on merge trees that accelerate the extraction of locally extremal features. Merge trees have a wide range of applications <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b45">45]</ref>, and their construction has been studied extensively. Parallel algorithms for shared-memory multicore processors <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b39">39]</ref>, distributed memory computers <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref>, and accelerators <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b36">36]</ref> have been developed. Despite the substantial efforts of the research community, the best shared-memory algorithms on 16 cores still lose more than 40% of their parallel efficiency <ref type="bibr" target="#b21">[22]</ref>.</p><p>We overcome the scalability challenge by using a different split between precomputation and queries. In contrast to building a global merge tree, we decompose the domain, construct a merge forest of local trees connected by a local reduced bridge set, and compute the necessary global information at query time. The key insight is that, in practice, we rarely query the entire parameter range, and even during an automatic parameter sweep or an interactive exploration, we typically perform only a limited number of queries. Therefore, a fast and entirely local preprocessing coupled with efficient queries will significantly outperform existing solutions. The merge forest is a local structure, and thus its computation scales linearly with the available core counts and the number of regions in the domain decomposition. Although the queries are, in principle, more expensive than those in the merge tree, the merge forest reduces the first time to query by an order of magnitude. Furthermore, our queries are fast enough for an interactive data analysis. Finally, the local representation takes advantage of a smaller index space, which not only halves the memory footprint of the data structure for large data sets, but also improves the locality of the data within each region. A surprising result is that in some cases the nonlocal queries are faster than their equivalent query run on the global merge tree.</p><p>In summary, we introduce a new data structure called the merge forest that provides analysis capabilities equivalent to those of a global merge tree at a fraction of its computational cost and that can be constructed for significantly larger data sets than previously reported. We make the following contributions:</p><p>A localized data structure, the merge forest, to represent topological features traditionally represented with a merge tree;</p><p>A definition of elementary and derived topological queries independent of their underlying topological data structure, which is meant to open opportunities for research into new, nontraditional data structures with equivalent functionalities;</p><p>A set of efficient query algorithms for feature extraction that can be used on a merge forest; and An extensive empirical evaluation of the merge forest construction algorithm on structured grids, executed serially and in sharedmemory parallel, and a study of the impact of the merge forest representation on the execution time of topological queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>The construction of a merge tree (and related contour tree) has been studied extensively. We review the construction and representation of a merge tree and its applications to scientific data analysis.</p><p>Representation and construction. A merge tree captures the evolution of superlevel or sublevel sets, and thus it can be used to extract level-set-based features. The merge tree algorithm originates as a subroutine in a contour tree algorithm <ref type="bibr" target="#b9">[10]</ref>, a generalization and simplification of a 3D sweep algorithm <ref type="bibr" target="#b40">[40]</ref>. The merge tree subroutine operates in two stages: first, it sorts the data, and second, it performs a sweep from high-to low-function values while recording maxima and merge saddles by tracking connected components of a superlevel set with a disjoint-set data structure <ref type="bibr" target="#b18">[19]</ref>. A merge tree consists of a set of nodes that have pointers to their children and parent nodes. Since the algorithm visits all vertices, it can build an augmented merge tree, and thus enable data segmentation.</p><p>Alternatively, an unaugmented merge tree can be computed by identifying critical points locally, then sorting the points, and finally traversing the mesh upward to connect the points with monotone paths <ref type="bibr" target="#b12">[13]</ref>.</p><p>Sorting of critical points offers an advantage over the sweep algorithm due to the output sensitivity with respect to the topological complexity of the data. However, if the query extracts a segmentation -the set of vertices corresponding to a subtree -a mesh traversal is required because the unaugmented tree does not store all vertices. A recent result shows that only critical points along the leaf-root paths need to be sorted <ref type="bibr" target="#b35">[35]</ref>.</p><p>Both the sweep and monotone paths algorithms require the whole data set loaded in memory. Streaming algorithms construct a merge tree by processing a list of vertices and edges in any order and thus need less memory. If an added edge changes the connectivity, the corresponding subtrees are merged <ref type="bibr" target="#b7">[8]</ref>, resulting in quadratic complexity. Recently, a streaming algorithm based on a new representation of triplets <ref type="bibr" target="#b39">[39]</ref>, a form of branch decomposition <ref type="bibr" target="#b33">[34]</ref>, has provided a merge tree construction with linear complexity in practice. Triplets show that changing an underlying representation can result in a significant performance improvement. Additionally, the merge tree can be built using an I/O-efficient union-find algorithm <ref type="bibr" target="#b1">[2]</ref>.</p><p>Parallel algorithms. The parallel merge tree algorithm <ref type="bibr" target="#b32">[33]</ref> works by subdividing the domain into regions and combining the merge trees of these regions from the bottom up. The final tree is assembled on a single core, limiting scalability. Moreover, the algorithm computes an unaugmented tree that is not suitable for data segmentation tasks. The domain subdivision approach has been combined with parallel monotone path tracing <ref type="bibr" target="#b27">[28]</ref>, resulting in a hybrid algorithm <ref type="bibr" target="#b0">[1]</ref>. The hybrid algorithm computes an unaugmented merge tree by first building local trees with the parallel monotone path algorithm and then stitching the trees into a global merge tree. The computation per local region scales linearly, but the stitching step exhibits at best a factor of three speed-up and limits the overall scalability of the algorithm.</p><p>Instead of subdividing the domain, the function range can be partitioned and an augmented merge tree computed for each cell of the partition. These cells are then stitched to form the global merge tree <ref type="bibr" target="#b19">[20]</ref>. However, partitioning the range does not mesh well with the visualization tools that usually load data in regions <ref type="bibr" target="#b23">[24]</ref>. Moreover, the range partitioning is susceptible to load imbalance, because the number of boundary simplices can vary greatly.</p><p>The limitations of rigid subdivision and the extra work introduced at boundaries have inspired a more flexible task-based algorithm for computing an augmented merge tree <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>. The algorithm creates a task for each arc, starting at maxima, and grows these arcs in parallel until reaching a saddle. The last task that reaches a saddle restarts arc growth. When a single task remains active, the unprocessed arcs, trunk, are sorted and processed in parallel. The parallel efficiency reported is 58% on 16 cores, which is the fastest shared-memory parallel approach to date. We use the task-based algorithm as a baseline in our comparisons. Additionally, the flexible streaming algorithm to compute the triplet representation has been parallelized using atomic variables <ref type="bibr" target="#b39">[39]</ref>. However, the scaling trails off from two or more cores.</p><p>The presence of accelerators motivated a data-parallel merge tree algorithm <ref type="bibr" target="#b11">[12]</ref>. The algorithm builds a merge tree by iteratively executing two steps, a monotone path construction and peak pruning, until no peak remains. As an optimization, a new graph can be constructed after the first iteration, which includes only candidate saddles and maxima, leading to improved performance. However, the algorithm then builds an unaugmented merge tree, and a postprocessing step is required to augment the tree. The algorithm executes either on a GPU or a CPU. The reported results are limited to 2D data sets, and the parallel efficiency is 33% on 32 cores. This data-parallel algorithm also has been combined with the domain and range subdivision approaches <ref type="bibr" target="#b36">[36]</ref>.</p><p>Distributed algorithms. Data sets, and the associated merge trees, can get larger than available memory on a single computer. The distributed merge trees <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref> present a local-global representation that distributes a merge tree over multiple computers and minimizes the network communication required during queries. Consequently, these queries can be efficiently executed in situ and in parallel. The distributed representation consists of two interconnected data structures stored on each computer, a local merge tree and a sparsified global tree with respect to the local tree. In some cases, the features span only a limited amount of space, and it is wasteful to compute the sparsified global tree because these features can be extracted by growing regions of fixed size and computing the topology only to the extent of the region <ref type="bibr" target="#b25">[26]</ref>. By limiting the global computation to a predefined extent, the scaling of the algorithm has been improved. This algorithm has been further extended to CW complexes <ref type="bibr" target="#b24">[25]</ref>. We take inspiration from these approaches with the key difference of constructing only local structures and recovering the necessary global information during query. We focus on shared-memory parallel architectures.</p><p>A massive parallel communication (e.g., MapReduce) algorithm <ref type="bibr" target="#b31">[32]</ref> computes a merge tree in 2D by first constructing contour trees for the domain partitions on multiple computers, and then using these trees on a single computer as an input graph for a serial merge tree construction with the sweep algorithm.</p><p>Applications of a merge tree (and contour tree). The first application of a contour tree accelerated the relief extraction from terrain maps in a radar simulator <ref type="bibr" target="#b5">[6]</ref>. The relief is reconstructed by interpolating between nested contours, which are extracted by traversing a contour tree. Several decades later, a contour tree-based search data structure was used to answer path queries with respect to the contours of a terrain <ref type="bibr" target="#b14">[15]</ref>.</p><p>In volumetric data, seed sets <ref type="bibr" target="#b43">[43]</ref> were used to accelerate the extraction of an isosurface. Furthermore, a flexible isosurface interface <ref type="bibr" target="#b10">[11]</ref> or volume rendering interface <ref type="bibr" target="#b44">[44]</ref> enabled interactive exploration of scalar fields by using a contour tree as part of a user interface. By selecting arcs of the contour tree, a user can display contours or subvolumes without the occlusion issues present in traditional isosurface and volume rendering, where two nested objects at the same threshold obscure one another.</p><p>The increasing complexity and resolution of the data sets poses a challenge for visualization techniques, because the number of features can be too large to inspect visually. A merge tree can be used to analyze features across all thresholds and simplification levels <ref type="bibr" target="#b16">[17]</ref>, and extract statistics such as feature count or their size to guide the analysis and visualization process <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b29">30]</ref>. For example, a merge tree was used to extract and track features, such as extinction regions in combustion simulation <ref type="bibr" target="#b47">[47]</ref> or pressure perturbations in weather data <ref type="bibr" target="#b46">[46]</ref>. Both use cases rely on the Components query to extract, count, and visualize features at different thresholds. Moreover, the user interface utilizes the MergeTree query to display an unaugmented merge tree. Another example of merge tree application is extraction and tracking of ignition kernels <ref type="bibr" target="#b28">[29]</ref>. First, high values are identified with the Maxima query, and the regions around them are extracted while the Relevance query values are below a specified relevance threshold. Finally, each of these regions is adjusted if the maximum obtained with ComponentMax query is below a threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BACKGROUND</head><p>We review the necessary concepts used throughout the paper. As a reference, we use the book Computational Topology -An Introduction <ref type="bibr" target="#b15">[16]</ref>.</p><p>Let K be a simplicial complex with values at vertices. The function g is a piecewise-linear extension of g(v i ) to the simplicial complex K. The function g is generic if all vertices have different values, i.e., g( <ref type="bibr" target="#b17">[18]</ref> is used to symbolically perturb the input vertex values to ensure that g is generic.</p><formula xml:id="formula_0">v i ) = g(v j ) ⇔ v i = v j . Simulation of simplicity</formula><p>A simplex σ ∈ K is formed by the convex combination of its vertices, and its faces are simplices derived from proper subsets. The star St(v) of a vertex v is the set of all simplices that have v as a face. The upper star St + (v) is a subset of the star St(v) containing values above g(v) and the vertex v, i.e., St</p><formula xml:id="formula_1">+ (v) = {σ ∈ St(v) | u ∈ σ ⇒ g(u) ≥ g(v)}. The link of a vertex v, Lk(v)</formula><p>is the outer boundary of the star, i.e., its closure minus the star itself,</p><formula xml:id="formula_2">Lk(v) = St(v) − St(v).</formula><p>Given a complex K, vertices v i and v j are connected if there is a path between them in K. The connected components of K are the subcomplexes that partition K, such that</p><formula xml:id="formula_3">K = C k , where v i , v j ∈ C k ⇐⇒ v i is connected to v j in C k .</formula><p>Each component is the maximal subcomplex induced by its vertex set. The number of connected components is denoted #CC = {C 1 , ...,C m } = m. Because the function g is generic, we can order the vertices of K from highest to lowest</p><formula xml:id="formula_4">{v 1 , v 2 ,...,v n }, such that i &lt; j ⇐⇒ g(v i ) &gt; g(v j ).</formula><p>Moreover, since upper stars partition the complex K, an upper star filtration can be defined,</p><formula xml:id="formula_5">/ 0 = K 0 ⊂ K 1 ⊂ ••• ⊂ K n = K (1)</formula><p>where</p><formula xml:id="formula_6">g(v i ) &gt; g(v i+1 ) and K i+1 = K i ∪ St + (v i+1 ). The superlevel com- plex of a scalar value h is S h = K i , such that g(v i ) ≥ h and v i is the infimum.</formula><p>A vertex can be classified by its neighborhood as regular or critical. A regular vertex has one connected component in the upper link and one in the lower link. Critical vertices are those that remain. A vertex is called a maximum if its upper link is empty, i.e., Lk + (v) = / 0, indicating that all adjacent vertices have a lower function value. In the upper star filtration, a maximum vertex v i+1 introduces a new connected component in K i+1 with respect to the connected components of K i , and #CC(</p><formula xml:id="formula_7">K i+1 ) = #CC(K i ) +1. A vertex v i+1 is a merge saddle if K i+1 has fewer connected components than K i , i.e., #CC(K i+1 ) &lt; #CC(K i ).</formula><p>A vertex is a minimum if its lower link is empty, i.e., Lk − (v) = / 0, and is the global minimum if no other vertex has a lower value.</p><p>Let X be a topological space and f : X → R be a scalar function. The merge tree is the quotient space T = X/ ∼, where the equivalence relation ∼ is defined by a, b ∈ X, a ∼ b ⇐⇒ f (a) = f (b), and a is connected to b in the superlevel set S f (a) . In other words, T glues together all points on the boundaries of connected components of a superlevel set, and the neighborhood of each glued point in T is induced from the neighborhood in X.</p><p>For a function g defined on simplicial complex K, the merge tree T captures changes in the connected components of the superlevel complexes of the upper star filtration. Each arc of the tree tracks the growth of a single connected component. The nodes of T correspond to vertices that are a maximum, a merge saddle, or the global minimum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">QUERIES ON A MERGE TREE</head><p>Topology-based analysis seeks to understand the relationships between points of the domain and structural features, and topological data structures are merely intermediaries that distill properties of a function and accelerate answering queries. We capture the information available from a merge tree with elementary and derived queries, irrespective of the underlying data structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Elementary Queries</head><p>Three fundamental queries are: 1) find all maxima in a domain; 2) given a point in the domain, determine to which feature it belongs; and 3) find the spatial extent of a topological feature. Independent of a data structure, these three queries can then be used as building blocks for constructing other queries. The first query returns a list of all maxima. The second query returns the identifier of the highest maximum of a connected component of a superlevel complex, when given a vertex and threshold. With the third query, a connected component given a vertex and a threshold, also referred to as a segment, can be obtained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Maxima Query</head><p>The simplest topological query is understanding where new connected components are created. Definition 1. We call Maxima(K, g) a function that returns a set of vertices that are maxima in the simplicial complex K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Component Maximum Query</head><p>The maximum of a connected component in a superlevel complex query can be used to test if two vertices are connected in the superlevel complex, useful for feature tracking <ref type="bibr" target="#b47">[47]</ref>. We choose the component maximum query as a running example throughout the paper due to its simplicity and because the other queries build on it.</p><p>Definition 2. We call the vertex</p><formula xml:id="formula_8">v * C the global maximum of a connected component C if g(v * C ) &gt; g(v) for any vertex v = v * C in C.</formula><p>Definition 3. Given a function g defined on a simplicial complex K, a vertex v ∈ K, and threshold h, we call ComponentMax <ref type="bibr">(K, g, v, h</ref>) the function that returns the v * C , where C is the connected component of a superlevel complex S h such that v ∈ C. If g(v) &lt; h, the function returns bottom ⊥.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Connected Component Query</head><p>Another common query extracts a connected component in a superlevel complex given a vertex and a threshold. For example, we can extract the segmentation corresponding to the subtree given a saddle. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4. Let v i be the lowest vertex such that g(</head><formula xml:id="formula_9">v i ) ≥ h. We define Component(K, g, v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Derived Queries</head><p>The elementary queries can be used as subroutines to build more sophisticated queries. We define a collection of derived queries that are commonly used in a topological data analysis, such as extracting all connected components of a superlevel complex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Connected Components Query</head><p>Extraction of connected components, also called segmentation, is one of the applications of a merge tree data structure. For example, the connected components query can be used to perform a parameter sweep and count the number of components, their size, or surface area, to determine the appropriate threshold for the analysis <ref type="bibr" target="#b7">[8]</ref>. Moreover, the segmentation can be visualized as part of an interactive tool where a user can explore different thresholds in the context of feature tracking <ref type="bibr" target="#b45">[45]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5. We call Components(K, g, h) a function that, for a superlevel complex S h , returns a set of connected components.</head><p>Note that the number of components of the superlevel complex S h is equal to the number of connected components of K i in the filtration (Equation 1), where i is the index of the lowest valued vertex higher than h. Every pair of vertices v i , v j ∈ C k , in the same connected component C k ∈ Components(K, g, h), has the same component maximum,</p><formula xml:id="formula_10">ComponentMax(K, g, h, v i ) = ComponentMax(K, g, h, v j ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Relevance Query</head><p>In many applications, features exist as locally extremal regions relative to their surroundings, and different thresholds are needed for each connected component. For example, an indicator function has different values for vortices of different speeds, and a localized threshold is needed to extract vortices across scales <ref type="bibr" target="#b6">[7]</ref>. The relevance metric <ref type="bibr" target="#b28">[29]</ref> can be used to locally extract features by a threshold relative to the local maximum of a connected component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6. Given a vertex v and a function g on a simplicial complex K, the relevance query Relevance(K, g, v) is defined as a function that evaluates</head><formula xml:id="formula_11">g(v * )−g(v) g(v * )−g min , where v * = ComponentMax(K, g, v, g(v)).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Merge Tree Query</head><p>In some cases, a global unaugmented merge tree is visualized, either as part of an interface to control the visualization <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b44">44]</ref>, or embedded in the data as a direct visualization of feature relationships <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b42">42]</ref>. In our case, we use the merge tree query to experimentally validate the forest implementation by comparing the merge tree query output with existing implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7. Given a simplicial complex K and a generic function g, we call MergeTree(K, g) a function that outputs an unaugmented merge tree T .</head><p>Once an unaugmented merge tree with N nodes is available, a branch decomposition can be computed in O(N log N) <ref type="bibr" target="#b33">[34]</ref>, which allows adding a persistence simplification threshold to all queries. On the left are two local regions (red) with a scalar field (solid edges) connected by the bridge set (dashed edges), with three maxima (7, 9, and 8) and two saddles (6 and 4). On the right are the local trees of the two regions (filled circles are locally regular vertices) and their local copy of reduced bridge-set edges necessary for traversal between the local trees. Note that the boundary restricted maxima <ref type="bibr" target="#b29">[30]</ref> are not sufficient due to the lack of a region overlap. For example, the saddle at the vertex with value 6 is not present as a node in either of the two trees (it is either a bridge-set edge end vertex or a regular vertex).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">FOREST REPRESENTATION</head><p>We introduce an intermediate representation called the merge forest that is local with respect to a domain partition, yet allows fast computation of the queries. The domain is partitioned, and each region builds and maintains local data structures that are traversed during queries.</p><p>Domain decomposition. Consider a simplicial complex K with a set of vertices </p><formula xml:id="formula_12">V = {v 1 ,...,v n }. Let V i ⊆ V ; the region associated with V i , denoted M i , is the maximal subcomplex of K containing only vertices in V i . We partition V into m subsets V 1 ,...,V</formula><formula xml:id="formula_13">B i = v∈M i St(v) ∩ B.</formula><p>The intersection of local bridge sets of two adjacent regions contains the cells of K that have vertices in both regions, and we use B i j to denote B i ∩ B j .</p><p>Forest data structure. The forest data structure is a collection of local data structures associated with each region of a domain decomposition ( <ref type="figure" target="#fig_1">Fig. 2)</ref>. A region M i has associated three components: 1) an augmented merge tree T i , 2) a map from vertices to arcs of T i , and 3) a subset of the edges from the local bridge set B i . The local merge tree T i , the merge tree of region M i , is represented as a set of arcs. Each arc has pointers to children arcs and a pointer to a parent arc, allowing navigating the tree in both directions, toward the leaves and toward the root. Additionally, an arc has a pointer to a sorted list of vertices that project to it, called the arc segmentation. The first vertex in the list is a maximum or saddle in the local tree. The second component of the forest data structure is a map from each vertex in M i to the arc in T i that contains it. The third component is a subset of the edges of the local bridge set B i that allows navigation between regions. This subset, called the reduced bridge set RB i , locally minimizes the number of edges that must be stored to recover global information when querying the forest. We consider only edges, because the function is piecewise linear, and thus connectivity changes only at vertices <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8. A reduced bridge set RB is defined as a set RB ⊆ B, such that, for all indices i in the reduced filtration of K = RB ∪ M 1 ∪ ••• ∪ M m (Equation 1), the number of connected components of K i and the corresponding K i is the same:</head><formula xml:id="formula_14">#CC(K i ) = #CC(K i )</formula><p>Note that the number of components is sufficient to show the component equivalence because the vertex set of K and K is the same, and removing edges from a bridge set B can only split components, thereby increasing the number of components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FOREST CONSTRUCTION</head><p>We construct a local tree and find its reduced bridge-set edges independently for each region. Both stages, local tree computation and reduced bridge set construction, build on the sweep algorithm <ref type="bibr" target="#b9">[10]</ref>. The sweep algorithm processes vertices in decreasing order, building the filtration of superlevel complexes (Equation 1) one upper star at a time. The individual connected components are maintained during the sweep with a union-find algorithm operating on a disjoint-set data structure <ref type="bibr" target="#b18">[19]</ref> that allows logarithmic set membership query <ref type="bibr" target="#b41">[41]</ref> (only the path compression is used) as well as joining of sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Local Merge Tree Construction</head><p>For each region M i , a local tree is computed using the sweep algorithm. During the sweep, a vertex to arc map is created. After the local tree is built, the vertex to arc map is used to construct an arc segmentation. The arc segmentation enables output-sensitive computation of connected components of a superlevel complex.</p><p>Assuming the neighborhood size is constant, each local tree can be built in O(r log r), where r denotes the number of vertices in a region. There are n r regions; thus, the overall complexity to build all local trees is O(n log r). In contrast, the global tree requires O(n log n) steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Local Reduced Bridge Set Construction</head><p>In addition to a local tree, each region M i stores a local reduced bridge set RB i = RB i j , where M j is a neighbor of M i , to allow for an efficient traversal to the neighboring local trees. For each neighboring region M j , the local reduced bridge set is computed by the function <ref type="bibr">REDUCEDBRIDGESET(B</ref> </p><formula xml:id="formula_15">i j , vertices in the closure of B i j , B i j ).</formula><p>The reduced bridge-set algorithm (Alg. 1), similarly to the merge tree algorithm, performs a sweep through the sorted vertices while maintaining connected components with a disjoint-set data structure. However, instead of iterating over all vertices in an upper link, the edges outside the bridge set are processed first (lines 6-8) to minimize the size of the reduced bridge set. All components in the upper link are then merged, and the edges that have end vertices in different components are recorded (lines 9-12). These edges are added to the reduced bridge set, because they are necessary to maintain the connectivity between regions. We note that the disjoint-set data structure used in the reduced bridge-set algorithm is independent of the disjoint sets used during the local merge tree construction.</p><p>In total, there are n r regions, each containing r vertices. A region has 6 faces of size </p><formula xml:id="formula_16">function REDUCEDBRIDGESET(bridge set B, vertex set V ) 2: V ← SORTBYDECREASINGVALUE(V ) 3: RB ← / 0 4: for i ← 1 to |V | do 5: CREATECOMPONENT(v i ) 1. add vertex 6: for each v j in Lk + (v i ) do 2. connect inside region 7: if (v i , v j ) / ∈ B then 8: MERGE(COMPONENT(v i ), COMPONENT(v j )) 9:</formula><p>for each v j in Lk + (v i ) do 3. connect between regions 10:</p><formula xml:id="formula_17">if COMPONENT(v i ) = COMPONENT(v j ) then 11: MERGE(COMPONENT(v i ), COMPONENT(v j ))</formula><p>12:</p><formula xml:id="formula_18">RB ← RB ∪ (v i , v j ) 13:</formula><p>return RB</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ANALYSIS OF REDUCED BRIDGE SET CONSTRUCTION</head><p>The goal is to prove that the forest data structure computed with the local trees and local reduced bridge sets admits the same superlevelcomplex components as the global mesh K. First, we prove that the complex created by the local regions and the global reduced bridge set RB produce the same components as K. Finally, we show that the union of the local reduced bridge sets produced by the REDUCEDBRIDGESET function (Alg. 1) is a superset of the global reduced bridge set, and hence is guaranteed to have the same superlevel-complex components for all thresholds.</p><p>Lemma 1 (Reduced bridge set algorithm). Let RB be the set returned by the function REDUCEDBRIDGESET(B, V ), given the global bridge set B and all vertices of K, V . Then RB is a reduced bridge set.</p><p>Proof. We prove that RB is a reduced bridge set, i.e., the invariant #CC(K i ) = #CC(K i ) holds at the end of each outer loop iteration (lines 4-12), by induction on the filtration index.</p><p>Base case: i = 0, K 0 = K 0 = / 0, RB = / 0, and #CC(K 0 ) = #CC(K 0 ) = 0.</p><p>Induction step: By induction, the precondition holds #CC(K i−1 ) = #CC(K i−1 ). The first step (line 5) adds the vertex v i and the number of components increases by one, #CC(</p><formula xml:id="formula_19">K i−1 ∪ v i ) = #CC(K i−1 ∪ v i ) = #CC(K i−1 ) + 1.</formula><p>In the second step, the first inner loop (lines 6-8) adds the edges outside B, E out . Since the complexes differ only in the bridge set, i.e., K</p><formula xml:id="formula_20">\ B = K \ B, it follows #CC(K i−1 ∪ v i ∪ E out ) = #CC(K i−1 ∪ v i ∪ E out ).</formula><p>In the third step, the second inner loop (lines 9-12) adds the edges inside a bridge set B that change the number of connected components, E in , because COMPONENT( The algorithm for constructing a reduced bridge set (Alg. 1) has the property that if run on any subset of B and the vertices in its closure, it will return a superset of a minimum reduced bridge set restricted to that subset. We use this property to build a local reduced bridge set that allows us to answer global queries.</p><formula xml:id="formula_21">v i ) = COMPONENT(v j ) implies v i and v j are not connected. Therefore, #CC(K i−1 ∪ St + (v i )) = #CC(K i−1 ∪ v i ∪ E out ∪ E in</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Reduced bridge set for domain subset). Let B be the subset of B, arbitrary set Y ⊆ K, and RB the set constructed by REDUCEDBRIDGESET(B , vertex set of B ∪Y ). Then the set RB is a superset of RB ∩ B .</head><p>Proof. The sweep in REDUCEDBRIDGESET(B, V ) implicitly defines an edge sequence E, and its subsequence E * corresponds to the edges in a minimum reduced bridge set RB. Similarly, the sweep in RE-DUCEDBRIDGESET(B , vertex set of B ∪Y ) implicitly defines an edge sequence E , and its subsequence E * corresponds to the edges in the set RB . We need to show that E * ∩ B ⊆ E * , that is, the set RB contains all edges from RB restricted to the set B , and potentially some extra edges. Suppose there exists an edge e ∈ E * ∩ B , and thus it connects two components C a and C b . Assume e / ∈ E * . Then another edge e ∈ E * before e in the edge sequence must connect C a and C b . Then, however, the edge e would not be in E * ∩ B given the component test (line 10). and two thresholds, 6 and 4. The forest consists of two local trees (red) connected by a local reduced bridge set. The algorithm starts by finding an arc that contains the vertex v using the vertex to arc map, and then it traverses the whole subforest above a given threshold and performs a reduction on the visited leaves. On the left, the threshold is 6, and thus the query returns the vertex 8 (maximum of the leaves 7 and 8). On the right, the threshold is 4, and the query returns the vertex 9 (maximum of leaves 7, 8, and 9), because the saddle 4 is in the connected component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">QUERYING FOREST</head><p>We now use the forest to accelerate the elementary queries (Sect. 4.1) and derived queries (Sect. 4.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Maxima Query</head><p>The query returns all maxima in a data set. It is implemented by iterating over all leaves in each local tree, and returning only the leaves that do not have incident a bridge-set edge with a higher end vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Component Maximum Query</head><p>The ComponentMax query returns the global maximum of a connected component in a superlevel complex that contains a given vertex <ref type="figure">(Fig. 3)</ref>. Instead of traversing a mesh to find the maximum, a global merge tree (Alg. 2) can be traversed because its leaves represent maxima, and arcs connect at saddle vertices where the connectivity changes. However, in the forest representation, we have a collection of local merge trees connected by reduced bridge-set edges. Thus, compared to global tree traversal, we need to traverse between regions (Alg. 3) and keep track of already visited arcs. The COMPONENTMAX function (Alg. 2) returns the correct maximum of a component, because the forest has the same components as the underlying complex K. Effectively, COMPONENTMAX performs a depth-first search in the graph defined by the portions of the forest data structure above the given threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2</head><p>The algorithm for computing query ComponentMax that returns the highest vertex reachable from a given vertex in a superlevel complex.</p><formula xml:id="formula_22">function COMPONENTMAX(function g, forest F, vertex v, threshold h, visited set V S) if g(v) &lt; h or v ∈ V S then return ⊥ V S ← V S ∪ {v} arc v ← VERTEXTOARC(F , v) max ← arc v .maxVertex for each arc n in ARCNEIGHBORS(g, F, arc v , h) do v ← arc n .maxVertex result, V S ← COMPONENTMAX(g, F, v , h, V S) if result =⊥ and g(result) &gt; g(max) then max ← result return max, V S</formula><p>Optimizations. The ComponentMax query on a forest needs to keep track of visited vertices (or arcs) compared to the global tree, where a predecessor is sufficient. The bookkeeping adds to the cost of the traversal. This cost is minimized by traversing the local tree first and adding only the arcs with reduced bridge-set edges to the visited set. An additional benefit of the optimization is increased cache locality due to local traversal. Altogether, we observe more than a factor of two speed-up over the nonoptimized implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Connected Component Query</head><p>We implement the Component query by modifying the COMPONENT-MAX function (Alg. 2) to collect the arc's vertices during the forest traversal. For arcs that intersect the threshold, only vertices above the threshold are collected. Compared to the ComponentMax query, the forest traversal cost is, in practice, many times smaller than the cost associated with copying the vertices to the output array.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Relevance Query</head><p>Instead of traversing the complex K to compute the Relevance query, we use the forest-accelerated function COMPONENTMAX. This function is called with the queried vertex and its function value, and the returned maximum is used in the relevance metric equation (Def. 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Merge Tree Query</head><p>One of the main bottlenecks in constructing the augmented tree is the need to maintain a list of vertices per arc to support the extraction of connected components. Fortunately, such an augmented tree is not necessary, because we have the Component query on the forest, and thus we compute the unaugmented global tree that contains only critical vertices. For example, extracting a superlevel-complex component corresponding to a subtree in the global merge tree is performed by the Component query using a merge saddle and its function value.</p><p>We query the forest for the tree using the sweep algorithm <ref type="bibr" target="#b9">[10]</ref> on the forest graph. First, all local arcs and reduced bridge-set edges are collected into an array. The local bridge-set edges that have a lower end vertex in other region are ignored, because the other region will add that edge. Additionally, the higher of the two end vertices is pointed directly to the corresponding arc's highest vertex, reducing the number of edges in the array by about 10% and leading to a 10-20% speed-up. Then, the array is sorted and a sweep is performed to identify global arcs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">RESULTS</head><p>We evaluate the forest construction time and its scaling on a multicore computer and test the performance impact of the forest representation on queries. Both the construction and queries depend on a chosen region size, and we focus our attention on the region size first. Then, we evaluate the parallel scaling of the construction and conclude with a comparison of queries on a forest with those on a global tree.</p><p>Topological data structures, including a merge tree, are output sensitive, i.e., the construction and query time is impacted not only by the data size, but also by its topological complexity. Therefore, we use a wide variety of data sets <ref type="table" target="#tab_5">(Table 1)</ref>, such as imaged scans (Foot, Vertebra, Neurons) and simulations (Magnetic <ref type="bibr" target="#b22">[23]</ref>, HCCI <ref type="bibr" target="#b3">[4]</ref>, TJ <ref type="bibr" target="#b4">[5]</ref>, Miranda <ref type="bibr" target="#b13">[14]</ref>, DNS <ref type="bibr" target="#b26">[27]</ref>). Some data sets have mostly local features (TJ), but some have long, thin features that span a large portion of the data set (Vertebra). We choose these data sets to test the overhead imposed by the region decomposition, during both precomputation and the queries. For the data sets HCCI, TJ, and Neurons, a subset with a total size of local reduced bridge sets <ref type="figure" target="#fig_5">Fig. 4</ref>: The region size affects the performance of the serial forest construction. Due to better locality and a smaller log factor from the sort, we can build the forest faster than the global tree. Moreover, we use a smaller index data type to reduce the memory needed to store the forest, i.e., the two jumps, from 32 3 to 64 3 and from 1024 3 to 2048 3 , are caused by switching to a larger index type. We do not split arcs in local trees with bridge-set end vertices, and thus the cost of the domain decomposition is mainly reflected in the total size (number of edges) of the local reduced bridge sets. resolution that is a multiple of the region resolution is extracted. Data sets are represented as structured grids and are implicitly triangulated.</p><p>In the comparison with the global augmented tree construction, we use FTC <ref type="bibr" target="#b21">[22]</ref> and TTK <ref type="bibr" target="#b42">[42]</ref>. We show that forfeiting the goal of computing the global tree results in an order of magnitude speed-up in precomputation with a small impact on queries. All algorithms use the same six-subdivision neighborhood and build a forest or a superlevel-complex merge tree (the split tree setting in FTC and TTK).</p><p>All tests are run on a machine with four Intel Xeon CPU E7-8890 v3 @ 2.5 GHz (18 cores each) and 3 TB RAM (1.6 GT/s) running CentOS Linux 7.5. The compiler used is GCC 7.3.1 with optimizations enabled (-O3), and FTC and TTK 0.9.7 are compiled with additional libraries Boost 1.69.0 and VTK 8.2.0. All reported precomputation times are a mean of 3 runs with a coefficient of variation (standard deviation divided by mean) less than 15% for forest and 30% for FTC and TTK. Some of the runs with FTC did not complete successfully, and thus can have a mean of less than three runs. The queries are run serially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Forest Construction</head><p>The forest algorithm computes, for each region in a domain partition, a local tree and a local reduced bridge set. The region size determines the size of a partition, and we focus on exploring its impact on the serial construction time. From the complexity analysis (Sect. 6), we know that local trees take O(n log r) and local reduced bridge sets take O( n r 3 √ r 2 log 3 √ r 2 ) time, and thus both depend directly on the region size. Moreover, data locality can play a role in the forest construction performance, especially for larger data sets that do not fit into a cache, because modern processors rely on several layers of a cache hierarchy to minimize the latency of memory accesses.</p><p>We vary the region size ( <ref type="figure" target="#fig_5">Fig. 4)</ref> and also the necessary index type. For example, a region size 32 3 can use 16-bit integers as indices, but a size 64 3 to 1024 3 requires 32 bits, and with size 2048 3 , 64-bit indices are required. The use of 32-bit indices halves the memory overhead of the vertex to arc map and arc segmentation compared to 64-bit indices, which allows us to analyze the DNS data set.</p><p>The spectrum of region sizes has two extremes, a region with a single vertex and a region with all vertices. For practical reasons, we start with the region size 16 <ref type="bibr" target="#b2">3</ref> . As we sweep the region size range, we observe the serial construction reaching a minimum around size 64 <ref type="bibr" target="#b2">3</ref> and 128 <ref type="bibr" target="#b2">3</ref> . The computation of the global tree (the region size is the same as the data size) is slower than that of the forest, due to both algorithmic complexity of sorting and worse data locality. The locality of the global sort is improved by duplicating the data set and combining each vertex with its value to avoid an indirection to read the scalar value from the data set. However, duplication may not always be possible due to limited memory capacity. Since the region size is much smaller than the data size, the optimization has negligible memory overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Parallel Forest Construction and Comparison with Parallel Merge Tree Construction</head><p>The serial algorithm iterates over all regions and processes them independently, and the natural next step is to execute the iteration in parallel.</p><p>In parallel tests, we use a region size 64 3 because it minimizes the time per region for most of the data sets (   . FTC and TTK do not scale over multiple sockets, whereas the forest scales linearly. The exception is the Foot data set that has only 64 regions, which limits its scalability and increases load imbalance. On the right, scaling with the spread configuration shows that the forest benefits from more cache available across sockets and is more robust to the system configuration.</p><p>The close runs start with 1 core, and then 2, 4, 8, 16, and 18 cores, all on the same socket (a workstation-like configuration). Then one socket is added at a time <ref type="bibr">(19 and 36, 54</ref>, and 72 cores) to explore the nonuniform memory access effects on scaling. However, the processor cache is underutilized with the close configuration, and thus we also <ref type="table">Table 2</ref>: Construction times (in seconds) of a merge tree with FTC and TTK and a forest (region size 64 3 ). We run these scaling tests in the close configuration (environment variables OMP PROC BIND=close and OMP PLACES=cores) to force the 18 core runs to reside on a single socket, because FTC and TTK are designed for a workstation. The forest is an order of magnitude faster than FTC and TTK and scales to 72 cores. The missing results did not run successfully with FTC and TTK, and the DNS data set took excessive time for the forest on a single core. run the tests in a spread mode, which maximizes the available cache by evenly distributing the work across sockets <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr">64</ref>, and 72 cores). We compare the scalability of the forest construction with the shared-memory augmented merge tree construction algorithms, FTC and TTK. All reported times exclude the I/O and measure the time from the start of the precomputation until we are able to run the first query.</p><p>We were unable to process the Neurons and DNS data sets with FTC or TTK. The DNS data set is run only in the close configuration at 18 and 72 cores due to excessive runtime. We start with the close runs ( <ref type="table">Table 2</ref>) and observe forest construction times under 10 seconds for most of the data sets on 18 cores (a workstation scenario). Furthermore, if all 72 cores are employed, only the DNS data set cannot be preprocessed under a minute. Moreover, the linear scaling of the forest construction exhibits a mean 87% parallel efficiency on 8 cores, 82% on 18 cores, and 65% on 72 cores. The decrease in parallel efficiency on 72 cores can be attributed to greater load imbalance on the small data set (Foot) and increased resource contention. Furthermore, the spread configuration increases the parallel efficiency to 92% on 8 cores because it maximizes the cache utilization ( <ref type="figure" target="#fig_7">Fig. 5)</ref>. In contrast to the forest parallel efficiency, FTC achieves a mean 27% parallel efficiency on 8 cores and 14% on 18 cores, and the scaling trails off on more cores. Similarly, TTK has a mean parallel efficiency of 34% on 8 cores and 17% on 18 cores.</p><p>The memory overhead of a construction algorithm and data structure limits the size of data sets that can be processed. Due to the localized organization of the forest, the overhead during construction is negligible compared to the global approach <ref type="table">(Table 3)</ref>. Moreover, 32-bit indices are used to halve the size of the data structures needed to support the data segmentation. The low computation overhead and smaller data structure combined allow us to analyze the large DNS data set.</p><p>Overall, the linear scaling and reduced memory footprint allow us to process up to 10 times larger data than previously reported. <ref type="table">Table 3</ref>: Memory usage (in GB) of FTC and TTK and the forest, measured as the peak resident set with the time utility. The forest construction uses an order of magnitude less memory compared to the construction of the global augmented tree, enabling the analysis of larger data sets. The reported memory usage is on 18 cores with the coefficient of variation less than 30% between different core counts.    : Distributions of execution times for 1000 ComponentMax queries on the forest with region size 64 3 and the global tree. The query vertices are selected randomly and use thresholds equal to the function value at a given vertex. Generally, we observe that the forest-query histograms are scaled to the right compared to the global-tree-query histograms, as expected. The queries on the far right require traversal of a large portion of the forest, because the superlevel complex includes almost the entire data set. Furthermore, this difference indicates that for queries traversing small components, the running time is effectively the same between forest and tree. However, responding to queries that require traversing virtually the entire data set may incur a measurable overhead. Fortunately, this tends to happen only for query vertices in the noise/background of the data that are, therefore, not interesting for many applications where the range of features is known a priori. We conclude that the proposed change in data structure is a good choice in most practical situations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Component Maximum Query</head><p>We now demonstrate that queries on a forest perform comparably to those on a global tree, and any slowdown is acceptable for the interactive data analysis that is typical for a visualization environment. The main difference between the global merge tree and a forest is that the forest contains the bridge-set edges, and these edges increase the cost of the traversal during a query. Because the region size is an input parameter, we can develop different trade-offs by shifting more cost to the precomputation by increasing the region size, which reduces the cost of traversing the bridge set at runtime. Note that the global merge tree is a special case of a forest with a single region. Therefore, we compare the forest to the query on the global tree (no bridge-set edges needed) and explore the impact of region size on the query time.</p><p>We evaluate the query performance by randomly sampling 1000 vertices in the domain and by running the query with a threshold set to the function value of a given vertex. We run the query on a forest and global tree, and for each run we compute the distribution by splitting the elapsed time range into 16 bins and counting the number of queries that fall into each bin. From the experiments, we observe the performance of the forest representation is comparable to that of the global tree ( <ref type="figure" target="#fig_10">Fig. 6)</ref>, with a surprising result for the Magnetic and TJ data sets, where the forest outperforms the tree despite the extra overhead imposed by the local reduced bridge set. These data sets have an order of magnitude more arcs than other similarly sized data sets, and thus the better locality of the traversal outweighs the extra overhead imposed by the merge  <ref type="figure">Fig. 7</ref>: The ComponentMax query on the Miranda data set with varying region size on the global tree and forest. We clamped the histogram (a) after 0.5 second. As the region size increases, the overhead decreases, and the absolute time difference is negligible and well within interactive time. We expect most practical queries to be in the left to the middle of the histogram (the ones on the right traverse the whole forest).</p><p>forest. The absolute time differences at region size 64 3 are less than 100 milliseconds and are unlikely to impact an interactive data analysis.</p><p>We look closer at the impact of the region size on the Miranda data set <ref type="figure">(Fig. 7)</ref>, because it is the largest data set we use to test queries, and the number of regions is higher than the number of cores even for larger regions. For the region size 64 3 , the ComponentMax queries are 2.1 times slower, but at the region size 256 3 , we get only a 1.3x slowdown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">Connected Component Query</head><p>The connected component query needs to collect vertices to construct a segment, which serves as an opportunity to amortize the overhead of the forest traversal. We test the query by extracting the components of 1000 superlevel complexes evenly spaced in the range. The first superlevel complex has a single component containing all vertices in the domain.</p><p>We observe times to extract the components using the forest that are similar to the times using the global tree <ref type="figure">(Fig. 8)</ref>. The difference between the query times is, in most cases, on the order of 10 milliseconds, which is acceptable for an interactive analysis. Furthermore, when the topological complexity increases, the forest outperforms the global tree due to better data locality. Similarly to the ComponentMax query, increasing the region size narrows the gap between the forest and the global tree, both the speed-ups and the slowdowns. For example, in the largest tested data set (Miranda), the worst case slowdown is 2.8x at the region size 64 3 , 1.7x at 128 3 , and only 1.2x at 256 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5">Merge Tree Query</head><p>The MergeTree query returns a global unaugmented merge tree. Compared to the global approach where the tree is readily available, the forest requires an additional computation. The query time increases with the input graph size <ref type="table">(Table 4</ref>) and on most of the data sets is below 10 seconds. However, for the Neurons data set, the query takes several minutes, further corroborating our pursuit of localized data structures. <ref type="table">Table 4</ref>: The MergeTree query times for all data sets with the input graph size in millions. An unaugmented merge tree can be constructed in a few seconds for most of the data sets. However, the more topologically complex data sets (Magnetic, Neurons) take an order of magnitude longer than the forest preprocessing.</p><p>Region size 64 <ref type="bibr" target="#b2">3</ref> Region size 128 3   <ref type="figure">Fig. 8</ref>: Measuring the query time (log scale) as a function of threshold for the Components query on the forest with region size 64 3 and the global tree. In each case, a threshold of 0 extracts every data point. We observe the queries execute in comparable time, and more topologically complex data sets perform better with the forest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">LIMITATIONS</head><p>The forest construction requires an input parameter, the region size, which may be challenging to choose appropriately a priori. Even though our experiments suggest the region size 64 3 is a reasonable default for the precomputation, the region size choice affects the performance of the queries <ref type="figure">(Fig. 7)</ref>. If we had a way of determining that a region size is not appropriate given the number of expected queries to be executed, we could quickly recompute the forest with a larger region size. However, it is unclear what a good technique would be to judge if such recomputation is beneficial.</p><p>Persistence simplification enables the reduction of noise by removing features with low persistence; however, the presented queries do not support such a simplification directly. Currently, we need to compute the unaugmented global tree with the MergeTree query first, forming a bottleneck to the scalability of analysis. Moreover, the queries presented are executed serially, and thus underuse the resources available. Additionally, 1000 queries may be insufficient to adequately sample the ComponentMax query parameter space.</p><p>The forest representation is limited to a simplicial complex, because we assume that critical points are vertices inside a region. For example, a trilinear interpolant can cause critical points to be inside a face or a cell <ref type="bibr" target="#b32">[33]</ref>, and thus potentially in a bridge set. The simplicial complex requirement forces an implicit triangulation of a grid cell, potentially changing its topology <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">CONCLUSION</head><p>We present the merge forest, a localized data structure that processes each region in the domain decomposition in parallel and with linear scaling. We define a set of queries useful for data analysis and describe algorithms that can execute them quickly using the forest. Through an extensive evaluation, we confirm that these queries are only marginally slower on the forest compared to the global tree, and in some cases, even faster. The linear scaling and fast queries combined enable analysis of an order of magnitude larger data sets than previously possible.</p><p>As future work, we would like to explore the applicability of localized data structures to different topological structures, such as the Morse-Smale complex. Moreover, an extension of the merge forest to distributed-memory computers would be interesting, and it remains an open question if the queries can execute quickly despite the communication cost. Another possibility is to evaluate the forest construction and queries on a wide variety of unstructured meshes. Especially interesting would be a study of the impact of different mesh partitioning schemes <ref type="bibr" target="#b38">[38]</ref> and mesh layouts <ref type="bibr" target="#b48">[48]</ref> on the forest performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>, h) as a function that returns the vertices of the connected component containing v from the subcomplex K i associated with v i , where i is the index in the upper star filtration (Equation 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: On the left are two local regions (red) with a scalar field (solid edges) connected by the bridge set (dashed edges), with three maxima (7, 9, and 8) and two saddles (6 and 4). On the right are the local trees of the two regions (filled circles are locally regular vertices) and their local copy of reduced bridge-set edges necessary for traversal between the local trees. Note that the boundary restricted maxima [30] are not sufficient due to the lack of a region overlap. For example, the saddle at the vertex with value 6 is not present as a node in either of the two trees (it is either a bridge-set edge end vertex or a regular vertex).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>m such that the associated regions M 1 ,...,M m are simply connected. This partition can be obtained, for example, by a recursive bisection on the vertex coordinates. The global bridge set is the set of cells not included in any region, i.e., B = K − m i=1 M i . Note that the intersection of any two regions is empty, M i ∩ M j = / 0, and the intersection of a region with the global bridge set is also empty, M i ∩ B = / 0. The local bridge set B i with respect to a region M i is the intersection of the global bridge set with all cells incident on M i . Formally, the local bridge set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 √ r 2 , 3 √ r 2 log 3 √ r 2 ) 3 √ r 2 log 3 √ r 2</head><label>32332332</label><figDesc>12 edges of size 3 √ r, and 8 corners of size 1. The faces dominate the number of processed elements. Each region does O( work, and thus the time complexity of building all local reduced bridge sets is O( n r ). Algorithm 1 A reduced bridge-set algorithm. The arguments determine if the algorithm computes a minimum reduced bridge set or a local reduced bridge set.1:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>( a ) 9 Fig. 3 :</head><label>a93</label><figDesc>ComponentMax(v = 6, h = 6) = 8 (b) ComponentMax(v = 6, h = 4) = The ComponentMax query for a vertex v with function value 6</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 )</head><label>4</label><figDesc>and still provides a sufficient amount of work for 72 cores. An exception is the Foot data set with only 64 regions. Moreover, the larger number of small regions reduces the load imbalance. The parallel tests are run in two configurations by setting the OpenMP environment variables close with OMP PROC BIND=close and OMP PLACES=cores spread with OMP PROC BIND=spread and OMP PLACES=cores</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(a) Scaling with close configuration. (b) Scaling with spread configuration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 :</head><label>5</label><figDesc>On the left, scaling with the close configuration (a single socket left of the stippled vertical line)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(b) Vertebra data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(c) Magnetic data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6: Distributions of execution times for 1000 ComponentMax queries on the forest with region size 64 3 and the global tree. The query vertices are selected randomly and use thresholds equal to the function value at a given vertex. Generally, we observe that the forest-query histograms are scaled to the right compared to the global-tree-query histograms, as expected. The queries on the far right require traversal of a large portion of the forest, because the superlevel complex includes almost the entire data set. Furthermore, this difference indicates that for queries traversing small components, the running time is effectively the same between forest and tree. However, responding to queries that require traversing virtually the entire data set may incur a measurable overhead. Fortunately, this tends to happen only for query vertices in the noise/background of the data that are, therefore, not interesting for many applications where the range of features is known a priori. We conclude that the proposed change in data structure is a good choice in most practical situations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Region size 256 3 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Pavol Klacansky, Attila Gyulassy, and Valerio Pascucci are with the Scientific Computing and Imaging Institute, University of Utah. E-mail: {klacansky,jediati,pascucci}@sci.utah.edu. Peer-Timo Bremer is with Lawrence Livermore National Laboratory. E-mail: bremer5@llnl.gov.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Manuscript received 31 Mar. 2019; accepted 1 Aug. 2019. Date of publication 16 Aug. 2019; date of current version 20 Oct. 2019. For information on obtaining reprints of this article, please send e-mail to: reprints@ieee.org, and reference the Digital Object Identifier below. Digital Object Identifier no. 10.1109/TVCG.2019.2934257</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Algorithm 3 A function that returns all neighboring arcs of an arc. The set may include arc's children, parent, and all arcs reachable through the arc's bridge-set edges. function ARCNEIGHBORS(function g, forest F, arc arc v , threshold h) neighbors ← arc v .children ∪ {arc v .parent} for each edge in arc v .bridgeSet do if g(edge.localVertex) ≥ h then arc n ← VERTEXTOARC(F , edge.neighborVertex) neighbors ← neighbors ∪ {arc n } return neighbors</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>16<ref type="bibr" target="#b2">3</ref> 32 3 64 3 128 3 256 3 512 3 1024 3 2048 3 32 3 64 3 128 3 256 3 512 3 1024 3 2048 3 region size 32 3 64 3 128 3 256 3 512 3 1024 3 2048 3</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>16 bits</cell><cell>32 bits</cell><cell>64 bits</cell><cell>10 9</cell><cell></cell></row><row><cell>time (sec)</cell><cell>10 1 10 2 10 3</cell><cell>Foot Vertebra Magnetic HCCI TJ Miranda</cell><cell>memory (GB)</cell><cell>10 0 10 1 10 2</cell><cell></cell><cell>total number of local arcs</cell><cell>10 5 10 6 10 7 10 8</cell><cell></cell><cell>10 4 10 5 10 6 10 7 10 8</cell></row><row><cell></cell><cell>region size</cell><cell>Neurons</cell><cell></cell><cell>16 3 10 −1</cell><cell></cell><cell></cell><cell>10 4</cell><cell>16 3 region size</cell><cell>10 3</cell><cell>16 3</cell><cell>32 3</cell><cell>region size 64 3 128 3 256 3 512 3 1024 3</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1 :</head><label>1</label><figDesc>A list of data sets used for the evaluation. The selected data sets have a wide range of sizes and topological complexity.</figDesc><table><row><cell>Data set</cell><cell>Resolution</cell><cell>Size (GB)</cell><cell>Arc count</cell></row><row><cell>Foot</cell><cell>256x256x256</cell><cell>0.01</cell><cell>380,654</cell></row><row><cell>Vertebra</cell><cell>512x512x512</cell><cell>0.25</cell><cell>1,419,062</cell></row><row><cell cols="2">Magnetic 512x512x512</cell><cell>0.5</cell><cell>13,661,086</cell></row><row><cell>HCCI</cell><cell>512x512x512</cell><cell>0.5</cell><cell>16,342</cell></row><row><cell>TJ</cell><cell>512x1024x512</cell><cell>1</cell><cell>9,619,909</cell></row><row><cell>Miranda</cell><cell>1024x1024x1024</cell><cell>4</cell><cell>1,162,520</cell></row><row><cell>Neurons</cell><cell>2048x2048x2048</cell><cell>16</cell><cell>910,677,279</cell></row><row><cell>DNS</cell><cell cols="2">10240x7680x1536 900</cell><cell>138,601,501</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">(a) Two regions and bridge edges.(b) Local trees for the two regions.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors wish to thank reviewers, Amy Gooch, Duong Hoang, John Holmen, and Christine Pickett. The Neurons data set was provided by Alessandra Angelucci and Frederick Federer. This work was supported in part by NSF:CGV Award: 1314896, NSF:IIP Award: 1602127, NSF:ACI Award:1649923, DOE/SciDAC DESC0007446, PSAAP CCMSC DE-NA0002375, NSF:OAC Award: 1842042, and Intel Graphics and Visualization Institutes of XeLLENCE program.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A parallel and memory efficient algorithm for constructing the contour tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<idno type="DOI">10.1109/PACIFICVIS.2015.7156387</idno>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Pacific Visualization Symposium (PacificVis)</title>
		<imprint>
			<date type="published" when="2015-04" />
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">I/O-efficient batched union-find and its applications to terrain analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1868237.1868249</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Algorithms</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2010-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Critical points and curvature for embedded polyhedral surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">F</forename><surname>Banchoff</surname></persName>
		</author>
		<idno type="DOI">10.2307/2317380</idno>
	</analytic>
	<monogr>
		<title level="j">The American Mathematical Monthly</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="475" to="485" />
			<date type="published" when="1970-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Direct numerical simulations of autoignition in stratified dimethyl-ether (DME)/air turbulent mixtures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.combust-flame.2014.08.021</idno>
	</analytic>
	<monogr>
		<title level="j">Combustion and Flame</title>
		<imprint>
			<biblScope unit="volume">162</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="688" to="702" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Numerical and experimental investigation of turbulent DME jet flames</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhagatwala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Chen</surname></persName>
		</author>
		<idno>doi: 10. 1016/j.proci.2014.05.147</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Combustion Institute</title>
		<meeting>the Combustion Institute</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1157" to="1166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hybrid techniques for real-time radar simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Boyell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ruston</surname></persName>
		</author>
		<idno type="DOI">10.1145/1463822.1463869</idno>
	</analytic>
	<monogr>
		<title level="m">Fall Joint Computer Conference, AFIPS &apos;63 (Fall)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1963" />
			<biblScope unit="page" from="445" to="458" />
		</imprint>
	</monogr>
	<note>Proceedings of the November</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Identifying turbulent structures through topological segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gruber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kolla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Grout</surname></persName>
		</author>
		<idno type="DOI">10.2140/camcos.2016.11.37</idno>
	</analytic>
	<monogr>
		<title level="j">Commun. Appl. Math. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="53" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive exploration and analysis of large-scale simulations using topology-based data segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Day</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Bell</surname></persName>
		</author>
		<idno>doi: 10.1109/ TVCG.2010.253</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1307" to="1324" />
			<date type="published" when="2011-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Artifacts caused by simplicial subdivision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2006.22</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="231" to="242" />
			<date type="published" when="2006-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Computing contour trees in all dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Axen</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0925-7721(02</idno>
	</analytic>
	<monogr>
		<title level="m">Special Issue on the Fourth CGC Workshop on Computational Geometry</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="93" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Flexible isosurfaces: Simplifying and displaying scalar topology using the contour tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van De Panne</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.comgeo.2006.05.009</idno>
	</analytic>
	<monogr>
		<title level="j">Comput. Geom. Theory Appl</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="42" to="58" />
			<date type="published" when="2010-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Parallel peak pruning for scalable SMP contour tree computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Ahrens</surname></persName>
		</author>
		<idno type="DOI">10.1109/LDAV.2016.7874312</idno>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE 6th Symposium on Large Data Analysis and Visualization (LDAV)</title>
		<imprint>
			<date type="published" when="2016-10" />
			<biblScope unit="page" from="75" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Simple and optimal outputsensitive construction of contour trees using monotone paths. Computational Geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lenz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Rote</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.comgeo.2004.05.002</idno>
	</analytic>
	<monogr>
		<title level="m">Special Issue on the 19th European Workshop on Computational Geometry</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="165" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The mixing transition in Rayleigh-Taylor instability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cabot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<idno type="DOI">10.1017/S0022112004009681</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Fluid Mechanics</title>
		<imprint>
			<biblScope unit="volume">511</biblScope>
			<biblScope unit="page" from="333" to="362" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Trekking in the alps without freezing or getting tired</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<idno>doi: 10.1007/ PL00009159</idno>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="306" to="323" />
			<date type="published" when="1997-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Harer</surname></persName>
		</author>
		<idno type="DOI">10.1090/mbk/069</idno>
	</analytic>
	<monogr>
		<title level="j">Computational Topology: An Introduction</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<date type="published" when="2010" />
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Topological persistence and simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Letscher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zomorodian</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00454-002-2885-2</idno>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="511" to="533" />
			<date type="published" when="2002-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Simulation of simplicity: A technique to cope with degenerate cases in geometric algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">P</forename><surname>Mücke</surname></persName>
		</author>
		<idno type="DOI">10.1145/77635.77639</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="66" to="104" />
			<date type="published" when="1990-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">An improved equivalence algorithm. Commun</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Galler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Fisher</surname></persName>
		</author>
		<idno type="DOI">10.1145/364099.364331</idno>
		<imprint>
			<date type="published" when="1964-05" />
			<publisher>ACM</publisher>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="301" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Contour forests: Fast multi-threaded augmented contour trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gueunet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fortin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jomier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<idno type="DOI">10.1109/LDAV.2016.7874333</idno>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE 6th Symposium on Large Data Analysis and Visualization (LDAV)</title>
		<imprint>
			<date type="published" when="2016-10" />
			<biblScope unit="page" from="85" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Task-based augmented merge trees with Fibonacci heaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gueunet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fortin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jomier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<idno>doi: 10. 1109/LDAV.2017.8231846</idno>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE 7th Symposium on Large Data Analysis and Visualization (LDAV)</title>
		<imprint>
			<date type="published" when="2017-10" />
			<biblScope unit="page" from="6" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Task-based augmented contour trees with Fibonacci heaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gueunet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fortin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jomier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<idno type="DOI">10.1109/TPDS.2019.2898436</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1889" to="1905" />
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Formation of hard power laws in the energetic particle spectra resulting from relativistic magnetic reconnection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Daughton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-H</forename><surname>Liu</surname></persName>
		</author>
		<idno>doi: 10.1103/ PhysRevLett.113.155005</idno>
	</analytic>
	<monogr>
		<title level="j">Phys. Rev. Lett</title>
		<imprint>
			<biblScope unit="volume">113</biblScope>
			<biblScope unit="page">155005</biblScope>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Sparse-Leap: Efficient empty space skipping for large-scale volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">K</forename><surname>Al-Awami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2744238</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="974" to="983" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Notes on the distributed computation of merge trees on CW-complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Landge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-44684-420</idno>
	</analytic>
	<monogr>
		<title level="m">Topological Methods in Data Analysis and Visualization IV</title>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="333" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">In-situ feature extraction of large scale combustion simulations using segmented merge trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Landge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kolla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<idno type="DOI">10.1109/SC.2014.88</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, SC &apos;14</title>
		<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis, SC &apos;14<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1020" to="1031" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Direct numerical simulation of turbulent channel flow up to Re τ ≈ 5200</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">D</forename><surname>Moser</surname></persName>
		</author>
		<idno type="DOI">10.1017/jfm.2015.268</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Fluid Mechanics</title>
		<imprint>
			<biblScope unit="volume">774</biblScope>
			<biblScope unit="page" from="395" to="415" />
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A hybrid parallel algorithm for computing and tracking level set topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Maadasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doraiswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<idno type="DOI">10.1109/HiPC.2012.6507496</idno>
	</analytic>
	<monogr>
		<title level="m">2012 19th International Conference on High Performance Computing</title>
		<imprint>
			<date type="published" when="2012-12" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Tracking flame base movement and interaction with ignition kernels using topological methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Grout</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1088/1742-6596/180/1/012086</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Physics: Conference Series</title>
		<imprint>
			<biblScope unit="volume">180</biblScope>
			<biblScope unit="page">12086</biblScope>
			<date type="published" when="2009-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Distributed merge trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Morozov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<idno type="DOI">10.1145/2442516.2442526</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPoPP &apos;13</title>
		<meeting>the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPoPP &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="93" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Distributed contour trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Morozov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-04099-86</idno>
	</analytic>
	<monogr>
		<title level="m">Topological Methods in Data Analysis and Visualization III</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="89" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Massively parallel algorithms for computing TIN DEMs and contour trees for large terrains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Munagala</surname></persName>
		</author>
		<idno type="DOI">10.1145/2996913.2996952</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems, SIGSPACIAL &apos;16</title>
		<meeting>the 24th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems, SIGSPACIAL &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Parallel computation of the topology of level sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cole-Mclaughlin</surname></persName>
		</author>
		<idno>doi: 10.1007/ s00453-003-1052-3</idno>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="249" to="268" />
			<date type="published" when="2004-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The TOPORRERY: computation and presentation of multi-resolution topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cole-Mclaughlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scorzelli</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="19" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heidelberg</forename><surname>Springer Berlin</surname></persName>
		</author>
		<idno>doi: 10.1007/ b106657 2</idno>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Avoiding the global sort: A faster contour tree algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Raichel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Seshadhri</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00454-017-9901-z</idno>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="946" to="985" />
			<date type="published" when="2017-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A hybrid solution to parallel calculation of augmented join trees of scalar fields in any dimension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Piegl</surname></persName>
		</author>
		<idno>doi: 10.1080/ 16864360.2017.1419648</idno>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design and Applications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="610" to="618" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Felix: A topology based framework for visual exploration of cosmic filaments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shivashankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pranav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van De Weygaert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G P</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rieder</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2015.2452919</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1745" to="1759" />
			<date type="published" when="2016-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Partitioning of unstructured problems for parallel processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">D</forename><surname>Simon</surname></persName>
		</author>
		<idno type="DOI">10.1016/0956-0521(91</idno>
	</analytic>
	<monogr>
		<title level="m">Special Issue on the Parallel Methods on Large-scale Structural Analysis and Physics Applications</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">90014</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Triplet merge trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Morozov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Topology-based Methods in Visualization (TopoInVis)</title>
		<imprint>
			<date type="published" when="2017-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Construction of contour trees in 3D in O(n log n) steps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Tarasov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">N</forename><surname>Vyalyi</surname></persName>
		</author>
		<idno type="DOI">10.1145/276884.276892</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth Annual Symposium on Computational Geometry, SCG &apos;98</title>
		<meeting>the Fourteenth Annual Symposium on Computational Geometry, SCG &apos;98<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Worst-case analysis of set union algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</author>
		<idno type="DOI">10.1145/62.2160</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="281" />
			<date type="published" when="1984-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The Topology ToolKit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Favelier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gueunet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Michaux</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2743938</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="832" to="842" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Contour trees and small seed sets for isosurface traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Oostrum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
		<idno type="DOI">10.1145/262839.269238</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth Annual Symposium on Computational Geometry, SCG &apos;97</title>
		<meeting>the Thirteenth Annual Symposium on Computational Geometry, SCG &apos;97<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="212" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Topologycontrolled volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Dillard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2007.47</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="330" to="341" />
			<date type="published" when="2007-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Interactive exploration of large-scale time-varying data using dynamic tracking graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Widanagamaachchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<idno type="DOI">10.1109/LDAV.2012.6378962</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Large Data Analysis and Visualization (LDAV)</title>
		<imprint>
			<date type="published" when="2012-10" />
			<biblScope unit="page" from="9" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Exploring the evolution of pressureperturbations to understand atmospheric phenomena</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Widanagamaachchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jacques</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Crosman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Horel</surname></persName>
		</author>
		<idno>doi: 10. 1109/PACIFICVIS.2017.8031584</idno>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Pacific Visualization Symposium (PacificVis)</title>
		<imprint>
			<date type="published" when="2017-04" />
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Tracking features in embedded surfaces: Understanding extinction in turbulent combustion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Widanagamaachchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Klacansky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kolla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhagatwala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<idno type="DOI">10.1109/LDAV.2015.7348066</idno>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 5th Symposium on Large Data Analysis and Visualization (LDAV)</title>
		<imprint>
			<date type="published" when="2015-10" />
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Mesh layouts for block-based caches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-E</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2006.162</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1213" to="1220" />
			<date type="published" when="2006-09" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
