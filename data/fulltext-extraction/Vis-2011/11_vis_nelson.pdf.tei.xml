<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.1" ident="GROBID" when="2016-09-09T14:59+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GPU-Based Interactive Cut-Surface Extraction From High-Order Finite Element Fields</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Blake</forename>
								<surname>Nelson</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Robert</forename>
								<surname>Haimes</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Robert</forename>
								<forename type="middle">M</forename>
								<surname>Kirby</surname>
								<roleName>Member, Ieee</roleName>
							</persName>
						</author>
						<title level="a" type="main">GPU-Based Interactive Cut-Surface Extraction From High-Order Finite Element Fields</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index Terms—High-order finite elements</term>
					<term>spectral/hp elements</term>
					<term>cut-plane extraction</term>
					<term>GPU-based root-finding</term>
					<term>GPU ray-tracing</term>
					<term>cut- surface extraction</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. View of the pressure field of a rotating canister moving through an incompressible fluid. A color map of the field, along with contours of constant pressure, have been applied to the cylinder and the cut-plane. Abstract—We present a GPU-based ray-tracing system for the accurate and interactive visualization of cut-surfaces through 3D simulations of physical processes created from spectral/hp high-order finite element methods. When used by the numerical analyst to debug the solver, the ability for the imagery to precisely reflect the data is critical. In practice, the investigator interactively selects from a palette of visualization tools to construct a scene that can answer a query of the data. This is effective as long as the implicit contract of image quality between the individual and the visualization system is upheld. OpenGL rendering of scientific visualizations has worked remarkably well for exploratory visualization for most solver results. This is due to the consistency between the use of first-order representations in the simulation and the linear assumptions inherent in OpenGL (planar fragments and color-space interpolation). Unfortunately, the contract is broken when the solver discretization is of higher-order. There have been attempts to mitigate this through the use of spatial adaptation and/or texture mapping. These methods do a better job of approximating what the imagery should be but are not exact and tend to be view-dependent. This paper introduces new rendering mechanisms that specifically deal with the kinds of native data generated by high-order finite element solvers. The exploratory visualization tools are reassessed and cast in this system with the focus on image accuracy. This is accomplished in a GPU setting to ensure interactivity.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p> Finite element methods are widely used for solving scientific and engineering problems. They are characterized by the discretization of the problem domain into a collection of elements, followed by the construction of an approximate global solution that is specified in terms of a series of local approximations. Many versions of the finite element method use linear interpolation to represent solution values; other versions , such as those considered in this work, represent solutions using higher-order approximating polynomials. High-order finite element simulations are often visualized using low-order (typically linear) primitives. Performing visualizations in this way is compelling for several reasons: first, there exists an extensive collection of visualization techniques that expect linear primitives as input, and second, modern graphical processing units (GPUs) can  render highly complex scenes composed of linear primitives at interactive speeds. While linear approximations can be rendered efficiently, they do not, in general, faithfully represent the high-order data. Methods designed to use the high-order data directly, without the need for an intermediate linear approximation, faithfully represent the data, but are often not interactive. Linear approximations of high-order data are created by sampling the data at a specified set of points. If the sampling is performed too coarsely, then the approximation will be unable to resolve details in the underlying data, resulting in visualization errors. Conversely, if the sampling is too fine, while the details will be preserved and the visualization may not contain error, it will have used more processing time and other resources than necessary. While there are techniques for addressing the sampling problem <ref type="bibr" coords="1,430.65,624.45,14.19,8.02" target="#b14">[15,</ref><ref type="bibr" coords="1,447.65,624.45,6.72,8.02" target="#b6"> 7,</ref><ref type="bibr" coords="1,457.19,624.45,10.64,8.02" target="#b13"> 14]</ref>, it is often desirable to skip the intermediate step and visualize the high-order data directly (i.e., in its native form) in order to avoid the associated approximation errors. By using the high-order data directly, we can know that any features present in the visualization are also present in the data and are not artifacts of the approximation. The behavior of a high-order scalar field along an arbitrary cutsurface can often be one of the primary questions that must be answered by a simulation. For example, a simulation of a proposed aircraft body may be performed to determine if it will survive the stresses of flying in a variety of scenarios. In such a simulation, users are interested in the behavior of the simulation at specific boundaries, such as the stress field along the aircraft's wing. An effective way to visualize these types of surfaces is through the application of color maps and/or contour lines. In this work, we describe a new set of methods for rendering colormaps and contour lines on arbitrary cut-surfaces (of which curvedelement boundaries are of particular interest), extending the existing methods for applying color-maps to cut-planes <ref type="bibr" coords="2,197.18,113.52,9.71,8.02" target="#b1">[2,</ref><ref type="bibr" coords="2,209.96,113.52,6.47,8.02" target="#b3"> 4]</ref>. Our system's goal is to generate accurate and interactive images, allowing users to debug the simulation's code, accurately interpret the image, and perform general exploratory visualization. The system uses the highorder data in its native state, without the need for low-order approximation , and uses the the knowledge of the structure and mathematical properties of the underlying fields to provide accurate images. The remainder of this paper proceeds as follows. In Section 2, we give a brief overview of the state-of-the-art in high-order visualization, paying particular attention to the existing methods for visualizing cutplanes . In Section 3, we give a brief overview of the relevant features of the finite element method, focusing on those features of the highorder field that we use in our algorithm. In Section 4, we discuss the accuracy issues that arise when dealing with high-order data. In Section 5, we show how the system was implemented on a GPU raytracing system. In Section 6, we show results of our system, along with timings and other relevant measurements. We conclude in Section 7 with a summary of our findings. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p> While there are no algorithms that apply color maps to arbitrary cutsurfaces directly, there are several schemes that apply color maps to planar data. In one approach, the color map is generated by what is called a polynomial basis texture <ref type="bibr" coords="2,143.96,346.81,9.52,8.02" target="#b3">[4]</ref>. Each basis function used in the high-order field is sampled onto a triangular texture map. The colors in the triangle are not generated by linear interpolation, but instead by the linear combination of the appropriate textures, based on the triangle's order. In this way, a set of basis textures can be generated in a pre-processing step, and then, assuming there is sufficient resolution in the texture, accurate images can be generated for all high-order triangles. Another method uses an OpenGL fragment shader to calculate the field's value at each fragment's location, resulting in more accurate lookup into the color map <ref type="bibr" coords="2,151.89,436.47,9.52,8.02" target="#b1">[2]</ref> . Finally, another method analytically calculates the intersection of a plane and quadratic tetrahedra, then uses a ray tracer to apply the color map to the new primitive <ref type="bibr" coords="2,255.69,456.39,13.74,8.02" target="#b19">[21]</ref>. Most of the work dealing with the generation of contour lines deals only with 2D high-order elements. A common theme is to generate the contours in an element's reference space (which we will define in Section 3) and then transform them into global (world) space for display. One approach <ref type="bibr" coords="2,74.26,506.57,10.45,8.02" target="#b7">[8] </ref>creates contour lines in an element's reference space by subdividing the domain and using linear interpolation within these sub-domains to create a piecewise linear contour. Another approach steps along a direction orthogonal to the field's gradient <ref type="bibr" coords="2,234.62,536.45,9.52,8.02" target="#b0">[1]</ref>, where each step is controlled by a user-defined step size. A method for generating contour lines over quadrilateral elements by determining the shape of the contour in reference space and then generating a linear polyline to approximate it was developed in <ref type="bibr" coords="2,181.17,576.30,14.94,8.02" target="#b16">[17] </ref>and later extended to linear and quadratic triangles in <ref type="bibr" coords="2,138.29,586.27,13.74,8.02" target="#b17">[18]</ref>. The only 3D contouring algorithm <ref type="bibr" coords="2,162.71,596.59,10.45,8.02" target="#b5">[6] </ref>generates contour lines on cut-planes through finite element volumes. The procedure first locates a seed point for the contour line along the element's boundary. It then steps in a direction orthogonal to the field's gradient, using a usercontrolled step size, to generate a polyline representing the contour. It differs from the previously described methods in that the plane is a three-dimensional entity. At each step, the contour can, and often does, move off of the cut-surface. The method introduces a correction term to fix this problem and keep the contour on the cut-plane. As with the other object-space contour methods described, the step size is useful to determine how accurately the polyline represents the contour in world space, but is not as useful in expressing how accurate the final image is, as it can be accurate from one view but have large error in another. Approaches that use interval methods for generating contours <ref type="bibr" coords="2,257.93,736.42,14.94,8.02" target="#b18">[19] </ref> assume that, once a suitable region has been isolated, that the intersection between the implicit and a line segment can be computed effi- ciently. Several approaches have been developed for volume rendering high-order fields. An analytic solution to the volume rendering integral was developed in <ref type="bibr" coords="2,349.72,103.20,14.94,8.02" target="#b21">[23] </ref>for linear and quadratic tetrahedra. Numerical, point-based solutions for high-order tetrahedra were presented in <ref type="bibr" coords="2,518.31,113.16,13.74,8.02" target="#b22">[24]</ref>, and solutions for arbitrary elements and order have been developed as well <ref type="bibr" coords="2,303.34,133.09,13.74,8.02">[20]</ref>. Approaches for isosurface rendering have been developed for quadratic tetrahedra using analytical calculation of the isosurface in reference space <ref type="bibr" coords="2,343.98,153.01,14.94,8.02" target="#b20">[22] </ref>and through ray-tracing approaches <ref type="bibr" coords="2,493.44,153.01,13.74,8.02" target="#b19">[21]</ref>. Other approaches include using a ray tracer for arbitrary elements of arbitrary order <ref type="bibr" coords="2,328.01,172.94,14.94,8.02" target="#b10">[11] </ref>and a point-based approach that uses particles that actively seek and distribute themselves on the isosurface <ref type="bibr" coords="2,489.55,182.90,9.52,8.02" target="#b8">[9]</ref>. In <ref type="bibr" coords="2,305.25,192.86,10.45,8.02" target="#b2">[3] </ref> a method for calculating accurate streamlines through highorder fields was developed, and it not only follows the high-order flow more accurately, it also correctly handles the transitions between elemental faces. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">HIGH-ORDER FINITE ELEMENTS</head><p> A finite element volume is represented by the decomposition of a domain Ω into a mesh of n smaller, non-overlapping elements Ω i such that Ω = i≤n Ω i . The four basic element types that are used in this work are the hexahedron, prism, tetrahedron, and pyramid. Each element is associated with three different spaces: world, reference, and tensor. The world space represents the element in its physical position and orientation. In reference space, each element is transformed to a common, element-specific representation. The mapping from the reference space to the world space element is given by the bijection χ : R 3 → R 3 . The tensor space element is the cube <ref type="bibr" coords="2,481.38,342.83,24.39,8.16">[−1, 1] </ref>3 for all elements, and has a mapping to the reference element T : R 3 → R 3 . The mapping between tensor space and world space, which is a bijection a.e., is given by Φ = χ(T (η)). Given that the composition of the mappings is a bijection a.e. allows us to convert points between spaces as needed during visualization. An diagrammatic example of these mappings for a tetrahedron is shown in <ref type="figure" coords="2,447.75,403.95,29.01,8.02">Figure 2</ref>. </p><formula>η = T (ξ ) x = χ(η) </formula><p> Fig. 2. Illustration of the mapping between tensor (left), reference (middle ), and world space (right) for a tetrahedron. Tensor points are denoted by η, reference points by ξ , and world space points by x. </p><p> For the remainder of this paper, we will use the following notation to help distinguish between points in tensor space and points in world space: points in the world Cartesian space will be indicated by x, with individual directions will be specified by x 1 , x 2 , x 3 . Similarly, in the local Cartesian space associated with the element's tensor element , points will be specified with ξ , and individual components as ξ 1 , ξ 2 , ξ 3 . The solution to a high-order finite element simulation is a polynomial function F(ξ ) ∈ P N 1 ,N 2 ,N 3 with respect to the tensor element, where N 1 , N 2 , N 3 denote (possibly) different polynomial orders in the three principle directions. Since Φ is a bijection a.e. (with special care being needed only at a collapsed vertex), we can invert it to calculate the tensor point for a given world point, and then use the tensor point to calculate the field value. While Φ −1 exists for each element, it is, in general, not known analytically and must be calculated numerically when needed. It is also, in general, a non-linear transformation that, when applied to the polynomial field in tensor space, produces a function in world space that, while smooth, is not necessarily a polynomial. The implications for our implementation are that any algorithm that operates in world space cannot assume the field will be a polynomial. This work deals with Continuous Galerkin (CG) formulations of the finite element method, which require that the fields are continuous across element boundaries, but impose no restrictions on the continuity of any derivatives. Therefore, while the field is C p on the interior of each element (with p ≥ 1 indicating higher levels of smoothness depending on the element's approximating polynomial order and its mapping to world space), the field over the domain Ω is C 0 . This assumption of continuity allows us to develop a contouring algorithm, described further in Section 5.3, that is accurate across element bound- aries. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMAGE ERROR CHARACTERIZATION</head><p> Generating accurate visualizations of high-order finite element volumes is contingent upon identifying and controlling the sources of error in the visualization pipeline. This pipeline takes as input the high-order field as well as a description of the cut-surfaces on which to render the field. The output is a rasterization of the field and cutsurface . A typical implementation, using linear approximations, can contain several different types of error. The first error is that of approximating the cut-surface. Triangular mesh approximations of cut-surfaces are generally constructed by first sampling the surface at a specified collection of points, then creating a mesh that joins each of these points. When rendering the mesh, the only points that do not contain approximation error are the initial mesh points; all other points in the mesh will be located, at most, some non-zero distance ε from the true surface. As the number of triangles approximating the surface increases, ε gets smaller, but it will not, in general, become 0. If the surface is linear, as in the case of a cut-plane, there will be no error between the approximation and the surface. The error only occurs when the surface is of a higher-order than the approximation. The second type of error is interpolation error. High-order fields are represented by a polynomial F(ξ ) = ∑ i a i φ i (ξ ), where φ i is the i th basis function. Approaches that approximate the field with linear interpolation introduce error whenever the field is not sampled at nodal points. Finally, error can be introduced by the process of sampling onto a regular grid of pixels. If the scene contains features that are too fine to be resolved by the pixel spacing, then an error called aliasing can occur. The focus of this work is on how to minimize triangulation and interpolation errors while producing interactive visualizations. We refer to the combination of these errors as the sampling error. Since rasterization error occurs for all types of visualizations, not just high-order visualizations, we do not address it directly in our analysis. If aliasing error is noticeable in a high-order visualization, it can be addressed through one of the available anti-aliasing techniques. We define an accurate image of a cut-surface through a high-order data set as one in which each pixel's color is generated based on accurate sampling of the high-order field (i.e., the sampling error is reduced to machine precision). We call this type of image a pixel-exact image. Visualizations based on linear methods are not, in general, pixel-exact, since the triangulation of the cut-surface is not exact and the field between vertices is represented with linear interpolation. It is possible for linear methods to generate nearly pixel-exact images for particular viewpoints. Assuming that each triangle's vertex is generated by sampling the high-order field, if every pixel in the resulting image contains at least one vertex, then the image will be nearly pixel-exact. The difficulty associated with this approach is that a particular mesh will only generate these images for a subset of all possible viewing parameters and, as we will show in Section 6, it can incur significant costs in terms of computation time required and resource consumption. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RENDERING HIGH-ORDER CUT-SURFACES</head><p> In this section we describe the implementation of our high-order rendering system. While the system supports only cut-surface rendering at the present time, it has been designed to be extensible, which will allow for additional visualization techniques to be added in the future. The accuracy issues discussed in Section 4 can best be handled by a rendering system that operates on each pixel directly. A ray-tracer is the natural choice in this scenario. Assuming appropriately accurate intersection routines are available, the error associated with locating a point on the cut-surface and calculating the field value is reduced to machine precision. We have implemented high-order ray-tracing systems in the past, and have found them to be too slow to be useful for the types of exploratory visualization we want to perform <ref type="bibr" coords="3,527.31,83.27,13.74,8.02" target="#b10">[11]</ref>. Therefore, we have implemented this system on the GPU, leveraging the highly parallel nature of the GPU to process rays simultaneously. Rather than implement our own ray-tracer, we have decided to use the OptiX framework from NVIDIA <ref type="bibr" coords="3,430.69,123.12,13.74,8.02" target="#b12">[13]</ref>, enabling us to provide an implementation that can run interactively on a typical workstation. It is interesting to note that recent work with volume rendering has been able to reach interactive speeds with a GPU implementation <ref type="bibr" coords="3,511.15,153.01,13.74,8.02">[20]</ref>. OptiX provides a number of extension points that allow users to write custom intersection and shading programs. Details can be found in the OptiX programmer's guide <ref type="bibr" coords="3,414.87,182.90,13.74,8.02" target="#b11">[12]</ref>. The initial customization point is a ray generation program, which is generally responsible for generating one or more rays per pixel. In our system, the modules described in the following sections are ray generation programs. Because OptiX is implemented using CUDA, we were able to optimize performance by using strategies common to all CUDA programs, such as avoiding branching where possible and reducing the number of registers required during computation. However, we found it difficult to optimize memory access since access to OptiX memory is provided through an opaque pointer with no guarantees about its location. An OptiX scene is represented by a graph that controls which geometric objects are visible to a ray, as well as how the ray will traverse the scene. There are two ray-casting scenarios in our system: the initial ray that intersects cut-surfaces, and the secondary rays which are used to find the elements that contain the intersection point. This suggests a scene division where all geometric objects are placed in one graph and the high-order elements in a second. We found that, for performance reasons, the graphs should be shallow. Complicated graphs, such as a graph with a single geometry node for each element in the volume, takes significantly longer when the OptiX engine is initialized , and also adds overhead when launching an OptiX kernel. Since our system is composed of a sequence of OptiX kernels, we found that a poor graph structure can lead to overhead that dominates execution time. Each node in the graph can be customized by user-defined intersection programs, which are executed to determine if a ray intersects an object, and closest-hit programs, which are executed when the closest intersection point has been determined. The cut-surface intersections described in Section 5.1.1 are implemented as intersection programs associated with the cut-surface nodes. If a ray intersects a cut-surface, the surface's closest-hit program is executed to find the enclosing element and evaluate the field, as described in Sections 5.1.2 and 5.1.3. In the following sections we discuss the OptiX modules that comprise our system. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Primary Ray Module</head><p>Rays are represented in parametric form: </p><formula>r = O + tD (1) </formula><p>where O is the ray's origin, D is the ray's direction, and t is the distance along the ray from the origin along the specified direction. The Primary Ray Module is a ray generation program that first queries the downstream modules to determine the directions of the rays that are needed. It is assumed that a ray through the center of each pixel will be required, but any of the downstream modules can request additional rays. The module then casts rays through each of the requested locations. The behavior of the ray once it finds an intersection depends on the surface type. This surface-dependent behavior is implemented using an OptiX closest-hit program. If the surface is a cut-surface then a secondary ray is cast to determine which element encloses the intersection point, and the scalar value at the point is then calculated. Otherwise, the surface normal and color are determined. In this way, the scalar values of the field along the cut-surface are calculated and made available to downstream modules, while at the same time, any surface geometry in the simulation can also be rendered. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Ray/Cut-Surface Intersection</head><p>Cut-surfaces are generally specified as either implicit 3D surfaces or two-parameter parametric surfaces. Implicit 3D surfaces are defined as the set of all points that satisfy the equation </p><formula>f (x 1 , x 2 , x 3 ) = 0 (2) </formula><p>where f : R 3 → R. The intersection between an implicit surface and a ray can be found by substituting Equation 1 into Equation 2, yielding: </p><formula>g(t) = f (r 1 (t), r 2 (t), r 3 (t)) = f (O 1 + tD 1 , O 2 + tD 2 , O 3 + tD 3 ) = 0. </formula><formula>(3) </formula><p> Viewed in this way, the intersection test becomes a univariate rootfinding problem. For simple implicit functions, this equation can be solved analytically. For example, a cut-plane is a simple implicit function of the form f (x 1 , x 2 , </p><formula>x 3 ) = Ax 1 + Bx 2 +Cx 3 + D = 0 </formula><p>which, after substitution, becomes a linear equation in t with a trivially obtained solution. When the implicit surface is more complicated, such as when it is a high-order polynomial, it cannot be solved analytically. In these cases, numeric root-finding techniques are required <ref type="bibr" coords="4,185.80,273.47,9.52,8.02" target="#b4">[5]</ref>. In some cases, such as functions representing isosurfaces of high-order fields, the implicit function itself does not have an analytic form, and numeric techniques are required to both evaluate f and find the intersection <ref type="bibr" coords="4,222.92,303.36,13.74,8.02" target="#b10">[11]</ref>. The other type of surface of interest in a high-order setting is that of parametric surfaces, defined as x = p(u, v). If p is analytic, it may be possible to convert it into an implicit form, allowing for the direct use of methods already available for implicit forms. A class of interesting parametric surfaces is that of the faces of the elements themselves. Faces that border simulation geometry are of particular interest because of their relationship to what happens at or near these locations (e.g., pressure at specific locations on an aircraft's wing). Faces are defined as parametric functions: </p><formula>x = Φ(ξ i , ξ j ) = ∑ a ∑ b ˆ u ab φ a (ξ i )φ b (ξ j ), −1 ≤ ξ 1 , ξ 2 ≤ 1 (4) </formula><p>with the ray-face intersection specified as the values for ξ 1 , ξ 2 , and t for which the following holds: </p><formula>Φ(ξ i , ξ j ) = r(t). </formula><formula>(5) </formula><p>The function Φ is the mapping function described in Section 3 and does not, in general, have a conversion to a general implicit function. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Point Location</head><p>Once the cut-surface intersection point has been found, the next task is to determine the element in which it lies. To find the element, a new, secondary ray is cast from the intersection point in a random direction . This finds the closest element to the intersection point, which is the enclosing element. We constrain our cut-surfaces to lie entirely within the finite element volume; if this were not true, additional testing would be required to determine if the ray/cut-surface intersection point is inside the volume or not. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Field Evaluation</head><p>After finding the intersection point x and the element E that contains the point, the field can be evaluated. The field is defined in terms of the local Cartesian coordinate system associated with E's tensor element. As we discussed in Section 3, the mapping between the local tensor space and the global Cartesian coordinate system (in which x exists) is specified by the function Φ e (ξ ). Because Φ e is a bijection a.e., we can obtain the tensor space point for a given world space point by inversion. To calculate the field's value at a world point x inside the element: </p><formula>ˆ F(x) = F(Φ −1 e (x)). </formula><formula>(6) </formula><p>Unfortunately, Φ e does not, in general, have an analytic inverse. We therefore perform the inverse mapping numerically. We use the Newton-Raphson algorithm, which generates the convergent sequence </p><formula>ξ i+1 = ξ i + J −1 (Φ(ξ i ) − x) (7) </formula><p>where J is the Jacobian of the mapping function given by </p><formula>J i j = ∂ Φ i ∂ ξ j (8) </formula><p>with Φ i as the mapping in the i direction. This method has well-known stability issues and can fail to converge, even when roots do exist. In our case, since the mapping function Φ is a bijection a.e., we know that there is a unique real root inside the element, and we are able to position our initial guess close to the root, which greatly increases the probability of finding the root. Our routines do detect and report convergence errors and, in practice, they have not been encountered. Fields are represented as the tensor product of one-dimensional polynomials: </p><formula>F(ξ 1 , ξ 2 , ξ 3 ) = ∑ i ∑ j ∑ k ˆ u i jk φ i (ξ 1 )φ j (ξ 2 )φ k (ξ 3 ). </formula><formula>(9) </formula><p>Implemented as written, evaluating the field is an O(N 4 ) operation, but if we use the sum factorization technique </p><formula>F(ξ 1 , ξ 2 , ξ 3 ) = ∑ i φ i (ξ 1 ) ∑ j φ j (ξ 2 ) ∑ k ˆ u i jk φ k (ξ 3 ) (10) </formula><p>this is reduced to O(N 2 ). Due to the number of samples that must be taken to provide an accurate visualization, using the sum factorization technique can provide significant performance gains, especially as the field's polynomial order becomes large. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Color Mapping Module</head><p>To apply a color map to a cut-surface, we sample the scalar field at the center of each pixel, using the procedures just described, and then use the resulting scalar value as a look-up into the color map. As previously mentioned, this can result in aliasing, for which standard anti-aliasing techniques can be applied. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Contouring Module</head><p>A pixel (i, j) belongs to the contour curve for isovalue ρ if it satisfies ∃ u,v : P i j (u, v) = ρ </p><formula>(11) </formula><p> where P is the scalar field of the cut-surface projected onto the image plane. As described in Section 3, the field is continuous over the pixel, even if the pixel spans elements. Therefore, we can determine if the isovalue exists in the pixel by finding two points that bracket the isovalue: ∃ u a ,v a ,u b ,v b : P i, j (u a , v a ) ≤ ρ ≤ P i, j (u b , v b ). </p><formula>(12) </formula><p>Determining if the isovalue exists somewhere in the pixel can be a complicated and time consuming process that requires the determination of the global maximum and minimum scalar value over the pixel. To reduce the complexity of this test, instead of checking the pixel's interior, our algorithm looks for the isovalue along a pixel's edge. This approach is attractive because it detects the same contours as searching the interior detects except for the case where the contour exists entirely in the pixel's interior (see the lower right corner of <ref type="figure" coords="4,473.82,646.76,29.42,8.02" target="#fig_0">Figure 3</ref>). These types of contours will show up as isolated points in the image and will not help the user interpret the visualization, so the extra processing time to find them need not be taken. A simple algorithm to determine if a pixel may be part of the contour is to perform point sampling at the four pixel corners. If the values at the corners bracket ρ, then the pixel can be marked as part of the contour with no further testing. This method is appealing for several reasons. First, it is fast. Sampling the pixel corners requires (w + 1)(h + 1) samples, where w is the image width and h the height.  This is only slightly more samples than are required for color mapping , which requires wh samples. Second, if the field is monotonic over the pixel, then this test is also accurate, i.e., it only marks pixels that are part of the contour and doesn't mark pixels that are not part of the contour. Sampling the endpoints of a monotonic function produces the function's range (see <ref type="figure" coords="5,157.75,196.24,29.23,8.02" target="#fig_1">Figure 4</ref>(a)). While this algorithm cannot guarantee that it will find all contour pixels (because the highorder field is not guaranteed to be monotonic over a pixel's edge), it does find a large percentage of them. Because the field is not guaranteed to be monotonic, contours can take a variety of forms that will not be detected by the simple corner testing algorithm. As shown in <ref type="figure" coords="5,152.37,256.02,30.16,8.02" target="#fig_0">Figure 3</ref>, contours can cross edges multiple times and span many pixels and still miss detection by the corner testing algorithm. What we need is a way to obtain an estimate of the range of f using as few samples as possible (since they are expensive and will slow down rendering). An efficient way to do this is through interval arithmetic <ref type="bibr" coords="5,137.86,305.83,13.74,8.02" target="#b9">[10]</ref>. Using interval arithmetic, we replace operations on real numbers with operations on intervals. An interval X is defined as </p><formula>X = [X, X] = {x ∈ R : X ≤ x ≤ X} (13) </formula><p>and, for an arbitrary function ⊕ and intervals X and Y : X ⊕Y = {x ⊕ y : x ∈ X ∧ y ∈ Y }. </p><formula>(14) </formula><p>The set image of a function g is defined as: g(I) = {g(x) : x ∈ X} </p><formula>(15) </formula><p>and represents the true range of g. The interval extension G of g is formed by evaluating the steps to calculate g on interval numbers rather than floating point numbers. The interval extension has the following useful property: </p><formula>G(X) ⊇ g(X) = {g(x, y, z) : (x, y, z) ∈ X}. </formula><formula>(16) </formula><p>In other words, if g is evaluated using interval arithmetic on an input interval X, the result is a range that is guaranteed to contain the true range of g on that interval. The interval extension G of g can be very wide, and in some cases can be too wide to be useful. To reduce the width of the interval, we first subdivide the interval into n segments of width h, such that the subdivision of X is: </p><formula>X i = [X + ih, X + (i + 1)h]. (17) </formula><p>We define the interval hull of two intervals as: </p><formula>X∪Y = [min{X,Y }, max{X,Y }]. </formula><formula>(18) </formula><p>The interval hull of a subdivided interval is </p><formula>G n = i≤n X i . </formula><formula>(19) </formula><p>Subdividing an interval is useful because of the following property: </p><formula>G(X) ⊇ G n (X) ⊇ g(X) = {g(x, y, z) : (x, y, z) ∈ X}. </formula><formula>(20) </formula><p>In other words, we can decrease the width of an interval computation by subdividing the interval into smaller regions, evaluating each of the sub-intervals separately, then calculating the interval hull of the smaller intervals (see <ref type="figure" coords="5,109.71,736.42,28.89,8.02" target="#fig_1">Figure 4</ref>). To illustrate how this works, consider the the polynomial 3x 2 +2x − 4 which has a range of <ref type="bibr" coords="5,382.05,352.29,35.84,8.16">[−4.33, 1] </ref>over <ref type="bibr" coords="5,439.62,352.29,23.55,8.16">[−1, 1]</ref>. Using the following properties of interval arithmetic: </p><formula>x f (x) a b f (b) f (a) I = [a, b] (a) x f (x) a b I = [a, b] f (I) f (b) f (a) (b) x f (x) a b I = [a, b] f (I) F(I) f (b) f (a) </formula><formula>(c) x f (x) a b I = [a, b] f (I) F(I) f (b) f (a) (d) </formula><formula>X +Y = [X +Y , X +Y ] X −Y = [X −Y , X −Y ] X n =      [X n , X n ] </formula><p>if X &gt; 0 or n is odd, </p><formula>[X n , X n ] </formula><p>if X &lt; 0 or n is even, </p><formula>[0, |X| n ] </formula><p>if 0 ∈ X and n is even, the range can be evaluated as 3<ref type="bibr" coords="5,415.75,465.37,24.69,8.02">[−1, 1] </ref></p><formula>2 + 2[−1, 1] − 4 = 3[0, 1] + [−2, 2] − [4, 4] = [−6, 1]. Note the true range, [−4.33, 1] ⊆ [−6, 1]</formula><p>. Dividing <ref type="bibr" coords="5,328.91,485.15,24.39,8.16">[−1, 1] </ref> into 10 evenly-spaced intervals and evaluating produces a range of <ref type="bibr" coords="5,355.87,495.11,35.84,8.16">[−4.72, 1] </ref>and 100 evenly-spaced intervals produces <ref type="bibr" coords="5,294.12,505.08,35.00,8.16">[−4.37, 1]</ref>. For high-order fields, calculating the field's range over a pixel's side produces fairly good bounds, as can be seen in <ref type="figure" coords="5,486.54,525.14,29.65,8.02" target="#fig_3">Figure 5</ref>, where we show that, even without performing any subdivisions, the number of pixels that may contain the isovalue is small. One factor that can contribute to wide interval extensions is the number of operations performed when evaluating an expression. An example of this can be seen in <ref type="figure" coords="5,333.26,574.96,29.35,8.02" target="#fig_4">Figure 6</ref> , where the number of ambiguous pixels are compared between a 2 nd -order and 6 th -order data set. The 6 th -order data set has more ambiguous pixels than the 2 nd -order data set. Interval arithmetic provides conservative bounds that are obtained without using any derivatives, and are not negatively affected by the presence of extremal features. The cut-surface contouring algorithm proceeds as follows. First, sample the cut-surface at each pixel's corner. If any two pixel corners bracket an isovalue, mark the pixel. For each unmarked pixel, calculate the approximate bounds of the function along each side. If none of the contours fall within the approximate bound, reject the pixel. Otherwise, mark it as possible. Finally, for each possible pixel, subdivide the edge, taking additional samples as needed, to provide better bounds until a user defined tolerance is met. If contours fall outside the range, reject the pixel, otherwise accept. Note that, when the algorithm completes, it is possible for some pixels to be marked ambiguously. This cannot be avoided unless the Pixels that cannot contain the isovalue are white, and pixels that may contain the isovalue are teal. In 5(a), only corner testing has been performed . In 5(b), one level of subdivision has been performed. Two levels were performed in 5(c), and three in 5(d). We can see that additional testing reduces the number of ambiguous pixels. Rendering times for a 1000×1000 image are given underneath each image. While subdivisions take extra time, the rendering times are still interactive. global minimum and maximum over the pixel is calculated. Our system allows for these ambiguous pixels to be colored a different color. The user can then increase the amount of subdivision as needed to reduce the number of ambiguous pixels. In practice, we have found that dividing a pixel's side into eight sub-intervals is enough to handle most ambiguities. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Lighting and Display Modules</head><p>The lighting module can be arbitrarily complex. In our version, we implement simple OpenGL style lighting with no shadows. For display, we update the OpenGL color and depth buffers with the values obtained during ray-tracing. Additional OpenGL calls can now be made to render OpenGL data that can co-exist with the ray-traced data. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>The effectiveness of the methods described in this paper are illustrated by applying them to two high-order fluid flow data sets. Note that we will frequently refer to n th -order volumes or elements as a shorthand for saying that the field is represented by n th -order polynomials, in tensor space, in each direction. The first example consists of incompressible flow past a block with an array of splitter plates placed downstream of the block. A schematic of this regime is presented in <ref type="figure" coords="6,129.38,676.65,29.14,8.02" target="#fig_6">Figure 7</ref>(a). As the fluid impinges upon the block, it is diverted around the structure, generating vorticity along the surface. For the purposes of this paper, we will focus our attention on a configuration consisting of a plate spacing of one unit (non-dimensionalized with respect to the block height). The 3D computational mesh consists of 3, 360 hexahedra and 7, 644 prisms. All simulations were performed at a Reynolds Number (Re) of 200. </p><p>(a) 2 nd -Order (b) 6 th -Order The second data set consists of a rotating canister traveling through an incompressible fluid. A schematic of the flow regime under consideration is presented in <ref type="figure" coords="6,369.77,402.06,29.96,8.02" target="#fig_6">Figure 7</ref>(b). The 3D mesh consists of 5, 040 hexahedra and 696 prisms, with the computational problem being solved using third-order polynomials within each element. The solutions presented herein were computed at Re = 1000 and with an angular velocity of Ω = 0.2. All tests described in this section were performed on a desktop workstation equipped with an NVIDIA Tesla C2050 GPU and Intel Xeon W3520 quad-core processor running at 2.6 GHz. All code run on the GPU was implemented in OptiX. Code executed on the CPU was written as single-threaded C++ code. The GPU algorithms were run using 32 bit floating point precision, while the CPU code was run using 64 bit floating point precision. In our tests, there is a negligible performance impact between 32 and 64 bit precision on the CPU, while 64 bit precision on the GPU generally doubles overall execution time. As we will show when we discuss performance, our methods execute at 10-20 frames per second even for large image sizes, so 64 bit precision can be used when necessary without significantly impacting performance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Linear Comparison Models</head><p> Visualizations of high-order data are traditionally performed using linear primitives. Because of this, we will contrast the performance, accuracy, and resource consumption of our methods to those commonly used linear algorithms. We will show that while linear methods can produce acceptable images under the right circumstances, a more effective way to reliably achieve accurate visualizations (under reasonable resource constraints and without intervention) is through the methods described here. The linear test cases were implemented using the Visualization Toolkit (VTK) <ref type="bibr" coords="6,419.76,686.04,14.94,8.02" target="#b15">[16] </ref>because it is a well-known system, in current use, and therefore provides a good foundation on which to base our tests. Two approaches were used for representing the high-order data with the linear structures found in VTK. In the first approach we sampled the entire high-order volume onto a 3D regular grid of points, where 0 <ref type="figure" coords="7,31.50,154.53,19.85,7.37">Fig. 8</ref>. Time to sample a grid of evenly spaced points that span the high-order volume (left), and a triangular mesh representing a cut-plane through the middle of the volume (right). the spacing between points is constant. Values between grid points are calculated using linear interpolation. For the second approach a triangular mesh is created and sampled with the high-order data at the triangle vertices. As with the first volume, data values between vertices are obtained via linear interpolation. Sampling was performed using a CPU-based implementation. We used an octree data structure to accelerate the location of the element enclosing a given sample point. Timings for sampling several high-order volumes onto a grid are found in <ref type="figure" coords="7,79.29,273.97,29.73,8.02">Figure 8</ref> (a), and the timings to sample a cut-plane running through the center of the data set in <ref type="figure" coords="7,178.67,283.94,29.09,8.02">Figure 8</ref>(b). While sampling onto a 3D grid is the most flexible approach (since so many visualization algorithms can be applied), it is also the most time consuming and quickly becomes prohibitive, especially as the volume order increases. Sampling directly onto the cut-plane, while not as flexible, is fast enough to be practical. The problem with sampling onto a triangular mesh is that the memory required to store the mesh and samples grow roughly in a squared manner (by the spacing). We can produce a cut-plane with 8, 388, 608 samples using the 2 nd order block/plate data set in about 30 seconds, but it consumes 180 MB of memory, compared to 4 MB to represent the entire high-order volume. And, as shown in the examples below, there are not enough samples to produce highly-accurate visualizations. In the remainder of this section, our comparison tests are performed with the triangular mesh-based technique instead of the 3D grid-based approximation. We found that the quality of the grid-based approach is worse (sometimes significantly) than the mesh approach because the cut-surface may span between the grid samples, meaning that the contours and colors produced are interpolated from samples that do not actually lie on the surface. Using the triangular mesh, however, guarantees that all samples are on the cut-surface, providing more accurate images and better comparisons. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Contouring</head><p> While there are contouring algorithms available for high-order methods (as discussed in Section 2), we are unable to provide direct comparisons with those methods because they either are restricted by the type of element or the maximum order. Contours for the linear data were produced by the vtkContourFilter. The results are shown in <ref type="figure" coords="7,266.92,574.70,14.95,8.02;7,31.50,584.67,20.42,8.02" target="#fig_8">Fig- ure 9.</ref>The linear approximation in <ref type="figure" coords="7,147.76,595.79,30.31,8.02" target="#fig_8">Figure 9</ref> (b) is a significant improvement when compared to the more coarsely sampled volume, and it is difficult to see much difference between this image and our highorder method. However, this is only true at the current resolution, and if we zoom into the image, we can see that there are still significant errors present. While further sampling can improve the generated contour , there are limits to the sampling resolution (due to the amount of resources consumed). And importantly, the method described in this paper performs at about the same speed as the coarsely sampled image. In the coarsely sampled contour image (<ref type="figure" coords="7,183.59,686.61,27.71,8.02" target="#fig_8">Figure 9</ref>(a)), there are many errors which have been noted with a red circle: incorrect topology, missed contours, and incorrect shapes. What is interesting is that it is not possible to determine if these contours are accurate from the image alone. We need either a cut-plane with greater resolution or an image from our system to notice the inaccuracy. ). The approximation in 9(a) has several significant errors, marked in red, which disappear when using a smaller sampling. The highlighted area in 9(c) is shown in more detail in 9(d) for linear interpolation and 9(e) for our system. The contours generated by VTK, which use the same amount of time as our system, have considerably more error. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">ColorMaps</head><p>Figure 11 contrasts a comparison between linear approximations of a cut-plane through the canister data set with the renderer described in Section 5. Since the cut-plane is an inherently linear cut-surface, there is no surface approximation error, so differences between our method 1809 NELSON ET AL: GPU-BASED INTERACTIVE CUT-SURFACE EXTRACTION FROM HIGH-ORDER FINITE ELEMENT...  (f) Varying the number of elements with 8 th order solutions and 1000 × 1000 image size. <ref type="figure" coords="8,22.50,351.97,23.09,7.37">Fig. 10</ref>. Performance results and memory usage for rendering high-order data using our system. For typical usage scenarios, the parameter that impacts performance the most is image size. and the linear methods are due solely to the differences between linear and high-order interpolation. As expected, the images get progressively closer to the image generated by the techniques described in Section 5 as the number of samples increase. However, even at the very fine sampling (shown here), there are still subtle errors. Additionally, the memory required to store the mesh is large which requires a lengthy pre-preprocessing step. It is interesting to note that, unlike the contour images, it can be visually obvious when a color map needs to be further refined by the presence of sharp and " boxy " gradients. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5"></head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance</head><p>For the methods described in this paper to be useful, they must not only be accurate but interactive as well. For each test, we rendered a view of a cut-plane and cut-cylinder where the entire image was covered. Since the rendering pipeline is restarted from scratch with every view change, there was no need to run the timing tests with a variety of viewing changes. We executed the tests 100 times and reported the average time to render the entire scene. Since we did not have fluid flow simulation data higher than 6 th order, synthetic data sets were generated to obtain the timings. We were interested in how timing was related to the simulation's order, number of elements, and the overall image size. Timing results are shown in <ref type="figure" coords="8,57.40,616.87,34.73,8.02">Figure 10</ref>and, unless specifically noted otherwise, are valid for both the contouring and color mapping module (as they generally take the same amount of time). In <ref type="figure" coords="8,152.96,636.80,33.48,8.02">Figure 10</ref>(a), it can be seen how increasing the field's order impacts performance. If the order is increased significantly, then it will impact performance negatively, but for typically-used orders, around 2-14, rendering times are not significantly impacted. In <ref type="figure" coords="8,97.97,676.65,33.11,8.02">Figure 10</ref>(b), we tested our system on large data sets with up to 200,000 elements and it can be seen that our system's speed is not strongly related to the number of elements. In <ref type="figure" coords="8,249.46,696.57,23.41,8.02;8,22.50,706.53,7.05,8.02">Figure  10</ref> (c), we can see that the most important factor governing the performance of our system is the image size. This figure also illustrates the impact of using more complicated cut-surfaces, specifically bicubic patches. While overall rendering time is increased with more complicated surfaces, it is still interactive. This has several positive implications . First, if the system is not as interactive as desired, additional speed can be gained by using a smaller viewport. Second, the system is capable of handling large high-order data sets interactively, and there is no indication of an upper limit to the number of elements that can be supported (except for the size of the native solution that must fit in the GPUs memory). In Figures 10(d), 10(f), and 10(e), we show the GPU memory required by our system. We start with a 5, 000 element, 8 th order volume rendered in a 1000 × 1000 image, then vary the number of elements, polynomial order, and image size. These graphs show that our system is capable of storing large volumes of high order on a single GPU. Increasing the image size results in a linear growth in memory usage due to the constant amount of per-pixel memory required for calculation and rendering. Increasing the number of elements also scales linearly, as the number of coefficients per element is constant for a given polynomial order. When increasing the polynomial order, the number of coefficients required to support the solution grows as O(n 3 ), where n is the polynomial order, leading to the memory growth shown in <ref type="figure" coords="8,512.08,560.91,23.41,8.02;8,285.12,570.87,7.22,8.02">Figure  10</ref>(d). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p> Our system was motivated by the lack of existing visualization techniques capable of interactively and accurately rendering color-maps and contour lines on arbitrary cut-surfaces. In this paper, we have described a new system that is capable of rendering these surfaces interactively and accurately while using the high-order data in its native form (i.e., we do not need to resample onto lower-order constructs). We have also shown that the most important factor for determining rendering speed is the size of the final image, indicating that our system can efficiently handle high-order data sets with a large number of elements with a large number of modes. An additional benefit is that these interactive frame rates are achievable on commodity GPUs, meaning simulation scientists can easily perform even the most demanding visualizations at their workstations. While our system is useful in its current form, additional </p><p>(a) Cut-plane with 902,289 triangles, VTK Rendering Time = 0.08 seconds. </p><p>(b) Cut-plane with 8,388,608 triangles, VTK Rendering Time = 2.0 seconds. </p><p>(c) Pixel-exact cut-plane color map. Rendering time is 0.015 seconds for a 1800×800 image. <ref type="figure" coords="9,31.50,419.75,22.96,7.37">Fig. 11</ref>. Color maps for a cut-plane through the canister data set with a coarse sampling (11(a)), a fine sampling (11(b)), and pixel-exact using our method (11(c)). ality, such as isosurface generation and volume rendering, is required before it can become a general-purpose high-order visualization system . We have an algorithm for isosurface generation in arbitrary highorder volumes <ref type="bibr" coords="9,86.66,487.19,13.74,8.02" target="#b10">[11]</ref>, but it is currently implemented as a CPU-based algorithm and, while accurate, is far from interactive. Our current system already implements several features that are required by this algorithm, namely, sampling the field at arbitrary points and performing ray-element intersections. The additional work we anticipate is the creation of function projection and root finding modules. Moving the CPU specific code to a GPU setting is not sufficient to guarantee interactivity, as the isosurface module requires significantly more samples than cut-surface rendering, and iterative root finding can be challenging on a GPU. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="5,31.50,120.14,250.38,7.37;5,31.50,129.61,101.24,7.37"><head>Fig. 3. </head><figDesc>Fig. 3. Contour lines that are not detected by simply checking if the pixel corners bracket the isovalue. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="5,294.12,286.11,250.38,7.37;5,294.12,295.58,250.38,7.37;5,294.12,305.04,250.38,7.37;5,294.12,314.20,250.38,7.67;5,294.12,323.97,129.24,7.37"><head>Fig. 4. </head><figDesc>Fig. 4. (a) -If a function f is monotonic on an interval I = [a, b], then the range of f is bounded by f (I) = [ f (a), f (b)]. (b) -If f is not monotonic , then f (I) = [ f (a), f (b)]. (c) -An interval extension F of f provides bounds that include f (I), i.e., f (I) ⊆ F(I). (d) -Uniform subdivision of the domain produces tighter bounds. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3" coords="6,22.50,343.19,250.38,7.37;6,22.50,352.65,250.38,7.37;6,22.50,362.12,250.38,7.37;6,22.50,371.58,250.38,7.37;6,22.50,381.05,250.38,7.37;6,22.50,390.51,250.38,7.37;6,22.50,399.97,250.38,7.37;6,22.50,409.44,250.38,7.37;6,22.50,418.90,213.06,7.37"><head>Fig. 5. </head><figDesc>Fig. 5. Contours generated on a cut-plane of the block/plates data set (see Section 6). Pixels that contain the isovalue are marked in black. Pixels that cannot contain the isovalue are white, and pixels that may contain the isovalue are teal. In 5(a), only corner testing has been performed . In 5(b), one level of subdivision has been performed. Two levels were performed in 5(c), and three in 5(d). We can see that additional testing reduces the number of ambiguous pixels. Rendering times for a 1000×1000 image are given underneath each image. While subdivisions take extra time, the rendering times are still interactive. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4" coords="6,285.12,198.98,250.38,8.61;6,285.12,208.44,102.09,8.61"><head>Fig. 6. </head><figDesc>Fig. 6. Comparison of ambiguous pixels (teal) between a 2 nd -order (left) and 6 th -order (right) data set. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6" coords="6,285.12,345.06,250.38,7.37;6,285.12,354.52,189.99,7.37"><head>Fig. 7. </head><figDesc> Fig. 7. Schematic showing the basic block/splitter plate (left) and rotating canister (right) configurations under consideration. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7" coords="7,303.57,180.55,231.49,7.13;7,303.79,324.70,231.04,7.13;7,296.89,468.87,244.85,7.13;7,296.89,478.33,17.05,7.13;7,321.09,584.38,74.54,7.13;7,443.44,584.38,73.64,7.13"><head></head><figDesc>(a) 524, 288 Triangles. VTK Contour Generation Time = 0.265 seconds. (b) 8, 388, 608 Triangles. VTK Contour Generation Time = 3.5 seconds. (c) High-Order Rendering. Rendering time for 2000×2000 image = 0.3 sec- onds. (d) Detail View of 9(b) (e) Detail View of 9(c) </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8" coords="7,294.12,607.34,250.38,7.37;7,294.12,616.80,250.38,7.37;7,294.12,626.27,250.38,7.37;7,294.12,635.73,250.38,7.37;7,294.12,645.19,250.38,7.37;7,294.12,654.66,250.38,7.37;7,294.12,664.12,250.38,7.37;7,294.12,673.59,18.64,7.37"><head>Fig. 9. </head><figDesc>Fig. 9. Comparison between pressure contours of the block/plane data set generated using linear methods (9(a) and 9(b)) and our high-order method (9(c)). The approximation in 9(a) has several significant errors, marked in red, which disappear when using a smaller sampling. The highlighted area in 9(c) is shown in more detail in 9(d) for linear interpolation and 9(e) for our system. The contours generated by VTK, which use the same amount of time as our system, have considerably more error. </figDesc></figure>

			<note place="foot">IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011</note>

			<note place="foot">NELSON ET AL: GPU-BASED INTERACTIVE CUT-SURFACE EXTRACTION FROM HIGH-ORDER FINITE ELEMENT...</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS </head><p>This work is supported under ARO W911NF-08-1-0517 (Program Manager Dr. Mike Coyle) and Department of Energy (DOE NET DE-EE0004449). Infrastructure support provided through NSF-IIS- 0751152. </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct coords="9,49.76,670.85,232.12,7.13;9,49.76,680.31,129.30,7.13"  xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Akin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Gray</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Q</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Colouring isoparametric contours. Engineering Computations</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="36" to="41" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,49.76,689.77,232.12,7.13;9,49.76,699.24,232.12,7.13;9,49.76,708.70,232.12,7.13;9,49.76,718.17,43.76,7.13"  xml:id="b1">
	<analytic>
		<title level="a" type="main">Rendering planar cuts through quadratic and cubic finite elements</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brasher</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Haimes</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Visualization &apos;04, VIS &apos;04</title>
		<meeting>the conference on Visualization &apos;04, VIS &apos;04<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="409" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,49.76,727.63,232.12,7.13;9,49.76,737.10,226.91,7.13"  xml:id="b2">
	<analytic>
		<title level="a" type="main">Nonlinear particle tracking for high-order elements</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Coppola</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">J</forename>
				<surname>Sherwin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Peiró</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Phys</title>
		<imprint>
			<biblScope unit="volume">172</biblScope>
			<biblScope unit="page" from="356" to="386" />
			<date type="published" when="2001-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,54.06,232.12,7.13;9,312.38,63.52,232.12,7.13;9,312.38,72.99,144.79,7.13"  xml:id="b3">
	<analytic>
		<title level="a" type="main">Multiresolution visualization of higher order adaptive finite element simulations</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haasdonk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Ohlberger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Rumpf</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Schmidt</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">G</forename>
				<surname>Siebert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="181" to="204" />
			<date type="published" when="2003-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,82.45,232.12,7.13;9,312.38,91.92,232.12,7.13;9,312.38,101.38,232.12,7.13;9,312.38,110.85,41.84,7.13"  xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive ray tracing of arbitrary implicits with simd interval arithmetic</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Knoll</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Hijazi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Wald</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Hansen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hagen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd IEEE/EG Symposium on Interactive Ray Tracing</title>
		<meeting>the 2nd IEEE/EG Symposium on Interactive Ray Tracing</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="11" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,120.31,232.12,7.13;9,312.38,129.78,232.12,7.13;9,312.38,139.24,180.64,7.13"  xml:id="b5">
	<analytic>
		<title level="a" type="main">A predictor-corrector contouring algorithm for isoparametric 3d elements</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">D</forename>
				<surname>Kontopidis</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">E</forename>
				<surname>Limbert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal for Numerical Methods in Engineering</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="995" to="1004" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,148.70,232.12,7.13;9,312.38,158.17,232.12,7.13;9,312.38,167.63,227.22,7.13"  xml:id="b6">
	<analytic>
		<title level="a" type="main">Discontinuous finite element visualization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">O</forename>
				<surname>Leone</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Scateni</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Pedinotti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Marzano</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Marzano</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Gobbetti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Gobbetti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">S</forename>
				<surname>Pedinotti</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Symposium on Flow Visualisation</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,177.10,232.12,7.13;9,312.38,186.56,232.12,7.13;9,312.38,196.03,112.68,7.13"  xml:id="b7">
	<analytic>
		<title level="a" type="main">Contour plotting of data using isoparametric element representation</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L</forename>
				<surname>Meek</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Beer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal for Numerical Methods in Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="954" to="957" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,205.49,232.12,7.13;9,312.38,214.96,232.12,7.13;9,312.38,224.42,227.77,7.13"  xml:id="b8">
	<analytic>
		<title level="a" type="main">Particle systems for efficient and accurate high-order finite element visualization</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Meyer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Kirby</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Whitaker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1015" to="1026" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,233.88,232.12,7.13;9,312.38,243.35,232.12,7.13;9,312.38,252.81,51.29,7.13"  xml:id="b9">
	<analytic>
		<title level="a" type="main">Introduction to Interval Analysis</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">E</forename>
				<surname>Moore</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">B</forename>
				<surname>Kearfott</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Cloud</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Society for Industrial and Applied Mathematics</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,262.28,232.12,7.13;9,312.38,271.74,232.12,7.13;9,312.38,281.21,191.82,7.13"  xml:id="b10">
	<analytic>
		<title level="a" type="main">Ray-tracing polymorphic multidomain spectral/hp elements for isosurface rendering</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">M</forename>
				<surname>Kirby</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="114" to="125" />
			<date type="published" when="2006-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,290.67,232.12,7.13;9,312.38,300.14,81.25,7.13"  xml:id="b11">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">NVIDIA. NVIDIA OptiX Ray Tracing Engine Programming Guide</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>1. edition</note>
</biblStruct>

<biblStruct coords="9,312.38,309.60,232.12,7.13;9,312.38,319.07,232.12,7.13;9,312.38,328.53,232.12,7.13;9,312.38,337.99,42.95,7.13"  xml:id="b12">
	<analytic>
		<title level="a" type="main">Optix: A general purpose ray tracing engine</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">G</forename>
				<surname>Parker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Bigler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dietrich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Friedrich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Hoberock</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Luebke</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Mcallister</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Mcguire</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Morley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Robison</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,345.72,107.95,8.86;9,416.57,347.46,127.93,7.13;9,312.38,356.92,232.12,7.13;9,312.38,366.39,197.25,7.13"  xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient visualization of high-order finite elements</title>
		<author>
			<persName>
				<forename type="first">J.-F</forename>
				<surname>Remacle</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Chevaugeon</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">´</forename>
				<forename type="middle">E</forename>
				<surname>Marchandise</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Geuzaine</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal for Numerical Methods in Engineering</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="750" to="771" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,375.85,232.12,7.13;9,312.38,385.32,232.12,7.13;9,312.38,394.78,232.12,7.13;9,312.38,404.25,17.93,7.13"  xml:id="b14">
	<analytic>
		<title level="a" type="main">Framework for visualizing higher-order basis functions</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Schroeder</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Bertel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Malaterre</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Thompson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pebay</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">O</forename>
				<surname>Barall</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Tendulkar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization, 2005. VIS 05. IEEE</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,413.71,232.12,7.13;9,312.38,423.18,232.12,7.13;9,312.38,432.64,151.21,7.13"  xml:id="b15">
	<monogr>
		<title level="m" type="main">The visualization toolkit): an object-oriented approach to 3D graphics</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Schroeder</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">M</forename>
				<surname>Martin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">E</forename>
				<surname>Lorensen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Prentice- Hall, Inc</publisher>
			<pubPlace>Upper Saddle River, NJ, USA</pubPlace>
		</imprint>
	</monogr>
	<note>2nd. ed.</note>
</biblStruct>

<biblStruct coords="9,312.38,442.10,232.12,7.13;9,312.38,451.57,232.12,7.13;9,312.38,461.03,52.67,7.13"  xml:id="b16">
	<analytic>
		<title level="a" type="main">A simple and fast algorithm for the plotting of contours using quadrilateral meshes</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Singh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Sarkar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Finite Elem. Anal. Des</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="217" to="228" />
			<date type="published" when="1990-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,470.50,232.12,7.13;9,312.38,479.96,208.61,7.13"  xml:id="b17">
	<analytic>
		<title level="a" type="main">Accurate contour plotting using 6-node triangular elements in 2d</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Singh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Singh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Finite Elem. Anal. Des</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="81" to="93" />
			<date type="published" when="2009-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,489.43,232.12,7.13;9,312.38,498.89,116.11,7.13;9,294.12,506.62,33.49,8.86;9,323.41,508.36,221.09,7.13;9,312.38,517.82,232.11,7.13;9,312.38,527.28,17.93,7.13"  xml:id="b18">
	<analytic>
		<title level="a" type="main">Interval analysis for computer graphics Interactive high-quality visualization of higher-order finite elements</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">M</forename>
				<surname>Snyder</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">¨</forename>
				<surname>Uffinger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Frey</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH Comput . Graph. Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">292</biblScope>
			<biblScope unit="page" from="121" to="130337" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,536.75,232.12,7.13;9,312.38,546.21,232.12,7.13;9,312.38,555.68,232.12,7.13;9,312.38,565.14,96.09,7.13"  xml:id="b19">
	<analytic>
		<title level="a" type="main">Ray casting curvedquadratic elements</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">F</forename>
				<surname>Wiley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Childs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Hamann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Joy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE TCVG, ACM Siggraph</title>
		<editor>O. Deussen, C. D. Hansen, D. Keim, and D. Saupe</editor>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="201" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,574.61,232.12,7.13;9,312.38,584.07,232.12,7.13;9,312.38,593.54,232.12,7.13;9,312.38,603.00,188.16,7.13"  xml:id="b20">
	<analytic>
		<title level="a" type="main">Contouring curved quadratic elements</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">F</forename>
				<surname>Wiley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">R</forename>
				<surname>Childs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">F</forename>
				<surname>Gregorski</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Hamann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">I</forename>
				<surname>Joy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the symposium on Data visualisation 2003, VISSYM &apos;03</title>
		<meeting>the symposium on Data visualisation 2003, VISSYM &apos;03<address><addrLine>Aire-la-Ville, Switzerland, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>Eurographics Association</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="167" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,612.47,232.12,7.13;9,312.38,621.93,232.12,7.13;9,312.38,631.39,142.22,7.13"  xml:id="b21">
	<analytic>
		<title level="a" type="main">A high accuracy volume renderer for unstructured data</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">L</forename>
				<surname>Williams</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">L</forename>
				<surname>Max</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">M</forename>
				<surname>Stein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="37" to="54" />
			<date type="published" when="1998-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,312.38,640.86,232.12,7.13;9,312.38,650.32,232.12,7.13;9,312.38,659.79,90.87,7.13"  xml:id="b22">
	<analytic>
		<title level="a" type="main">Interactive point-based rendering of higherorder tetrahedral data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Zhou</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Garland</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">2006</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
