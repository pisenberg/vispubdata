<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.1" ident="GROBID" when="2016-09-09T14:59+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Volume Visualization of General Polyhedral Grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Philipp</forename>
								<surname>Muigg</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Markus</forename>
								<surname>Hadwiger</surname>
								<roleName>Member, Ieee</roleName>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Helmut</forename>
								<surname>Doleisch</surname>
								<roleName>Member, Ieee</roleName>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Eduard</forename>
								<surname>Gröllergr¨gröller</surname>
								<roleName>Member, Ieee</roleName>
							</persName>
						</author>
						<title level="a" type="main">Interactive Volume Visualization of General Polyhedral Grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index Terms—Volume rendering</term>
					<term>unstructured grids</term>
					<term>polyhedral grids</term>
					<term>GPU-based visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Interactive ray-casting of the temperature distribution in an exhaust manifold that was simulated using a state-of-the-art CFD solver on a complex grid composed of general polyhedral cells. Red color indicates warm, green cool regions. The complex structure of the underlying mesh is illustrated through cell faces. The cells in this mesh are not only tetrahedra or other predefined cell types, but also are very general, often non-convex, polyhedra with non-planar faces, which our approach can nevertheless visualize directly. Abstract—This paper presents a novel framework for visualizing volumetric data specified on complex polyhedral grids, without the need to perform any kind of a priori tetrahedralization. These grids are composed of polyhedra that often are non-convex and have an arbitrary number of faces, where the faces can be non-planar with an arbitrary number of vertices. The importance of such grids in state-of-the-art simulation packages is increasing rapidly. We propose a very compact, face-based data structure for representing such meshes for visualization, called two-sided face sequence lists (TSFSL), as well as an algorithm for direct GPU-based ray-casting using this representation. The TSFSL data structure is able to represent the entire mesh topology in a 1D TSFSL data array of face records, which facilitates the use of efficient 1D texture accesses for visualization. In order to scale to large data sizes, we employ a mesh decomposition into bricks that can be handled independently, where each brick is then composed of its own TSFSL array. This bricking enables memory savings and performance improvements for large meshes. We illustrate the feasibility of our approach with real-world application results, by visualizing highly complex polyhedral data from commercial state-of-the-art simulation packages.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Unstructured grids are a very important representation for volume data, such as the results of computational fluid dynamics (CFD) simulations computed using finite volume methods. Over the years, the complexity of the grids produced by state-of-the-art meshers and simulation packages, such as OpenFOAM <ref type="bibr" coords="1,169.82,488.66,10.44,8.06" target="#b1">[2] </ref>or STAR-CCM+ <ref type="bibr" coords="1,243.40,488.66,9.60,8.06" target="#b2">[3]</ref> , has increased tremendously. The volume meshes used nowadays in complex multi-physics simulations, for example, consist not only of an arbitrary combination of fixed cell types, such as tetrahedra, hexahedra, and octahedra , but contain a significant number of essentially arbitrary polyhedral cells. These cells can have an arbitrary number of faces, each of which can consist of an arbitrary number of vertices. Cells can be nonconvex and even degenerate, while their faces can be non-convex and non-planar. Moreover, different regions of a mesh are often generated using different meshing strategies. Taking all of these properties into account in visualization systems has become very important. However , most existing unstructured-grid visualization-methods are constrained to tetrahedral meshes for performance reasons and simplicity of implementation. Thus, these approaches have to tetrahedralize more complex grids before visualization. However, for meshes with complex cells, the increased number of cells resulting from tetrahedralization is a significant burden for visualization performance and memory usage. Moreover, a given tetrahedralization is not unique and introduces linearization artifacts when interpolation is used, since the original cells are split up into separate, piecewise linear constituents. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>@BULLET Philipp Muigg and Eduard Gröller are with Vienna University of </head><p> Existing visualization systems that are not constrained to just tetrahedra still only support a small number of convex cell types <ref type="bibr" coords="1,516.88,522.86,13.69,8.06" target="#b32">[32]</ref>, or essentially perform point splatting <ref type="bibr" coords="1,422.59,532.82,13.71,8.06" target="#b47">[48]</ref>. In this paper, we introduce the first interactive visualization approach for extremely complex unstructured grids, which takes into account all of the properties of stateof-the-art volume meshes outlined above. A major practical problem of complex meshes composed of general polyhedral cells is that their representation requires very flexible data structures. In order to be able to traverse these data structures for interactive visualization, e.g., during ray-casting, a lot of additional information is usually stored. Commonly, efficient traversal of mesh topology is facilitated by using both per-cell information, e.g., a list of faces a cell is composed of, as well as per-face information, e.g., pointers to the cells a given face connects. All this information consumes a significant amount of memory and book-keeping overhead for meshes with general polyhedral cells. In principle, either one of these two types of information is redundant. Nevertheless, it is usually incorporated for performance reasons. In contrast, as a basis for a variety of interactive visualization algorithms, we propose a very compact representation for such grids, which is purely face-based while still allowing for efficient traversal. Building on this data structure, we have developed a very flexible, interactive GPU ray-casting method. We note that, for similar reasons, state-of-the-art volume meshers have also switched to purely face-based grid representations <ref type="bibr" coords="2,160.08,53.42,9.67,8.06" target="#b1">[2,</ref><ref type="bibr" coords="2,171.59,53.42,6.51,8.06" target="#b2"> 3]</ref> . In this regard, our contribution is the development of an augmented face-based data structure that is almost as compact as these original mesh representations, but whose goal is efficient visualization instead of raw data storage. In summary, the main contributions of this paper are: @BULLET A very compact, purely face-based data structure for complex unstructured grids composed of general polyhedral cells. This TSFSL representation specifically targets direct visualization algorithms , such as ray-casting, not only raw data storage. @BULLET A very efficient GPU ray-casting approach that operates directly on the proposed TSFSL representation, with full support for domain decomposition (in this work, using a kD-tree and bricking). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>We discuss previous work in two distinct fields of research. First, our novel volume rendering approach for arbitrary unstructured grids is related to a multitude of volume visualization methods. Second, our method is based on a novel grid representation, which in turn is related to research conducted in the corresponding research areas. Unstructured-grid volume-rendering: Unstructured grid rendering approaches can be categorized as either object-order methods that iterate over the cells of a mesh, or image-order methods that accumulate data for each image pixel. Both classes require different mesh representations . The Projected Tetrahedra algorithm <ref type="bibr" coords="2,198.12,297.98,13.80,8.06" target="#b36">[36]</ref> , which is the basis of many object-order techniques, does not require connectivity information between neighboring cells. However, the sorting step necessary to composite individual cells in visibility order is very costly. This has resulted in several approaches that improve sorting performance by utilizing cell-to-cell connectivity information <ref type="bibr" coords="2,198.39,347.78,14.18,8.06" target="#b37">[37,</ref><ref type="bibr" coords="2,215.01,347.78,11.18,8.06" target="#b38"> 38,</ref><ref type="bibr" coords="2,228.63,347.78,10.62,8.06" target="#b46"> 47]</ref> . Objectorder methods such as HAVS <ref type="bibr" coords="2,131.93,357.74,14.88,8.06" target="#b11">[11] </ref>instead utilize a hybrid CPU/GPU sorting scheme, or avoid sorting by using special order-independent optical models <ref type="bibr" coords="2,76.83,377.66,14.24,8.06" target="#b42">[43,</ref><ref type="bibr" coords="2,93.15,377.66,10.60,8.06" target="#b47"> 48]</ref> , and thus do not require storing cell connectivity . With the exception of complex approximation techniques <ref type="bibr" coords="2,244.44,387.62,13.71,8.06">[30]</ref>, all these methods are limited to tetrahedral grids. Image-order approaches such as ray-casting <ref type="bibr" coords="2,92.32,407.54,14.26,8.06" target="#b16">[16,</ref><ref type="bibr" coords="2,108.66,407.54,11.99,8.06" target="#b41"> 42] </ref>compute the final image pixel by pixel, by casting viewing rays through the mesh. For rendering performance, cell-to-cell connectivity information is used to traverse the grid. Thus, no sorting step is necessary, which compensates for the slower rendering performance of ray-casting. However, since cell-to-cell connectivity is required to traverse the mesh, memory consumption has always been a limiting factor of these methods. Therefore, different data-organization schemes have been developed to minimize the memory footprint <ref type="bibr" coords="2,88.49,487.22,14.14,8.06" target="#b13">[13,</ref><ref type="bibr" coords="2,104.94,487.22,11.25,8.06" target="#b30"> 31,</ref><ref type="bibr" coords="2,118.51,487.22,10.68,8.06" target="#b43"> 44]</ref>. Marmitt et al. <ref type="bibr" coords="2,187.46,487.22,14.88,8.06" target="#b28">[28] </ref> provide a more detailed overview of ray-casting techniques. Since some ray-casting and cell-projection approaches require a convex volume boundary, convexification methods have been proposed <ref type="bibr" coords="2,160.26,517.10,14.24,8.06" target="#b22">[22,</ref><ref type="bibr" coords="2,176.83,517.10,10.61,8.06" target="#b34"> 34]</ref>. We avoid the need for this by employing a method similar to depth peeling <ref type="bibr" coords="2,211.99,527.06,9.68,8.06" target="#b6">[6,</ref><ref type="bibr" coords="2,223.87,527.06,11.24,8.06" target="#b14"> 14,</ref><ref type="bibr" coords="2,237.31,527.06,10.68,8.06" target="#b43"> 44]</ref>. All mentioned rendering methods target tetrahedral grids and cannot easily be generalized to polyhedral cells, which have become increasingly relevant in state-of-the-art simulation packages <ref type="bibr" coords="2,249.63,557.06,9.68,8.06" target="#b0">[1,</ref><ref type="bibr" coords="2,263.31,557.06,6.43,8.06" target="#b2"> 3]</ref>. Thus, several approaches have been developed to deal with more complex cell types. Callahan et al. <ref type="bibr" coords="2,132.40,576.98,14.89,8.06" target="#b10">[10] </ref>propose a level-of-detail extension to HAVS that selectively removes triangles from a tetrahedral grid. The resulting mesh comprises polyhedral cells and can be rendered by using piecewise linear interpolation. Contrary to the proposed approach , HAVS does not support more complex interpolation methods because only face-to-vertex connectivity information is stored. Lévy et al. <ref type="bibr" coords="2,43.59,636.74,14.99,8.06" target="#b26">[26] </ref> extend the half-edge data structure by incorporating additional links for representing general polyhedral cell complexes in a Circular Incident Edge List (CIEL). They propose isosurface extraction , as well as slice-based volume rendering algorithms, using CIEL. The main drawback of the CIEL data structure is the high memory consumption of storing half-edges with additional links, as stated by the authors. Additionally, parallelizing CIEL-based volume rendering is difficult, because a single global active edge list has to be maintained during rendering. Adaptive sampling of grid cells of different sizes is also not possible. This is a significant limitation, since the cell sizes in unstructured grids used for simulation can vary by several orders of magnitude. Muigg et al. <ref type="bibr" coords="2,373.85,53.41,15.00,8.06" target="#b32">[32] </ref>have introduced the first GPU ray-caster that renders more general cells directly. However, for reasons of memory addressing and alignment, their overall data layout targets grids with only a small number of different cell types. Cell faces are also limited to triangles or planar quadrangles, and only convex cells are supported. Space-time discontinuous Galerkin simulations are based on even more complex grids containing non-convex curvilinear cells. ¨ Uffinger et al. <ref type="bibr" coords="2,339.54,123.13,14.99,8.06">[39] </ref>have proposed a volume rendering algorithm for such grids and the corresponding simulations, which not only contain a simple scalar value but a polynomial of varying degree per cell. This polynomial representation allows for using fewer cells to resolve spatially small features. However, that work focuses mainly on solving problems related to the polynomial representation of the scalar data volume and uses a very basic grid representation. Resampling techniques create a regular <ref type="bibr" coords="2,369.80,192.85,13.79,8.06" target="#b45">[46]</ref>, or semi-regular <ref type="bibr" coords="2,447.67,192.85,13.79,8.06" target="#b35">[35]</ref>, grid representation from the original unstructured volume that can be rendered efficiently. In order to tackle large data volumes, and for parallel rendering , many approaches developed for structured grids employ a spatial subdivision scheme such as octrees <ref type="bibr" coords="2,439.45,235.45,9.68,8.06" target="#b7">[7,</ref><ref type="bibr" coords="2,453.37,235.45,11.24,8.06" target="#b24"> 24,</ref><ref type="bibr" coords="2,468.85,235.45,10.69,8.06" target="#b44"> 45]</ref> . Such bricking methods have also been applied in the context of unstructured meshes <ref type="bibr" coords="2,313.71,255.37,14.24,8.06" target="#b32">[32,</ref><ref type="bibr" coords="2,330.27,255.37,11.15,8.06" target="#b33"> 33,</ref><ref type="bibr" coords="2,343.74,255.37,10.69,8.06" target="#b39"> 40]</ref>. Progressive rendering and streaming is also used to cope with large grids <ref type="bibr" coords="2,377.96,265.33,9.51,8.06" target="#b9">[9]</ref>. Besides GPU-based unstructured-grid rendering-approaches, highly optimized CPU algorithms have also been developed for volume rendering of scalar data defined on tetra- hedral <ref type="bibr" coords="2,309.77,295.21,14.99,8.06" target="#b17">[17] </ref>and hexahedral grids <ref type="bibr" coords="2,403.72,295.21,13.79,8.06" target="#b29">[29]</ref>, as well as point clouds <ref type="bibr" coords="2,506.58,295.21,13.79,8.06" target="#b12">[12]</ref>. Unstructured-grid representations: Data structures for representing 2D regular complexes, such as the winged-edge data-structure <ref type="bibr" coords="2,522.80,318.01,9.51,8.06" target="#b5">[5]</ref>, and the half-edge data-structure <ref type="bibr" coords="2,401.69,327.97,13.79,8.06" target="#b40">[41]</ref> , are the foundation of many volumetric mesh representations (see Kettner <ref type="bibr" coords="2,437.16,337.93,14.89,8.06" target="#b21">[21] </ref>for an overview). Both CIEL <ref type="bibr" coords="2,308.40,347.89,14.89,8.06" target="#b26">[26] </ref>and the data structure proposed by Bru and Teillaud <ref type="bibr" coords="2,524.98,347.89,10.42,8.06" target="#b8">[8] </ref>are direct extensions of half-edges to 3D grids. The former is highly optimized for isosurface extraction and slice-based volume rendering, and stores redundant linking information in order to speed up traversal . The latter is an extensible general purpose data structure, which stores only one additional link per half edge in a minimal configuration . However, if necessary, additional linking information can be stored per face, vertex, cell, and half facet. There are two major drawbacks of using such data structures for GPU ray-casting. First, the use of an explicit half-edge representation increases the memory footprint, because 2n + m half-edges per edge have to be stored and addressed (with n and m being the number of internal and external faces incident to an edge, respectively). This increased memory consumption does allow for greater flexibility with regard to edge-based queries. However , these are not required for ray-casting methods. Instead, for raycasting one needs fast access to all faces of each cell. This is the second drawback of half-edge representations: In order to sequentially access all faces of one cell, without adding additional data, all half edges of that cell must be traversed. This requires using a stack or queue, as well as a way of marking already visited half-edges (e.g., a hash table ), since the underlying half-edge graph contains an arbitrary number of cycles. This is especially problematic for GPU-based visualization . There are also grid representations that are specifically targeting meshes from numerical simulations (e.g., CFD or FEM), which often contain only a limited number of cell types. For example, Alumbaugh and Jiao <ref type="bibr" coords="2,319.14,596.89,10.44,8.06" target="#b4">[4] </ref>propose an array-based half-face data structure (AHF), which is capable of representing such volumetric meshes. Similarly to our work, half faces corresponding to one cell are packed in memory in order to reduce the number of necessary links. However, the lack of flexibility with respect to cell types (only a predefined set with small variation in face count should be used), and the need to utilize additional cell-to-vertex connectivity-data, makes the AHF mesh representation unsuitable for coping with more general polyhedral grids. The simplest type of unstructured mesh contains only tetrahedral cells. Mesh data structures optimized for this case are highly efficient with respect to memory used per tetrahedron. Examples include tetrahedral strips <ref type="bibr" coords="2,307.25,706.44,13.72,8.06" target="#b43">[44]</ref>, the Compact Half Face (CHF) data structure <ref type="bibr" coords="2,491.45,706.44,13.79,8.06" target="#b23">[23]</ref>, and its extension proposed by Gurung and Rossignac <ref type="bibr" coords="2,454.24,716.40,13.80,8.06" target="#b18">[18]</ref> . Since such algorithms exploit topological properties of tetrahedral cells, a straightforward generalization to arbitrary polyhedra is not possible. <ref type="figure" coords="3,31.50,164.85,18.68,7.53">Fig. 2</ref>. Comparison of the most common representation of unstructured grids (a), with our basic TSFL (b) and extended TSFSL (c) data structures. In (a), for every cell a list of faces is stored, and every face stores which two cells it connects. In contrast, our data structure (b) stores only faces and two links per face, completely avoiding explicit per-cell storage. These two links reference the next face of the cell in front of the face ( f fl ), and behind the face ( f bl ), respectively. The face normals are indicated by red arrows in the figure. Additionally, each link requires a boolean flag ( f ff , and f bf , respectively) to indicate whether the cell is in front or behind of the next face that it is linked to. Here, blue and green colors indicate the front and back half spaces, respectively. <ref type="figure" coords="3,156.61,212.13,29.15,7.53">Figure 6</ref>gives pseudo code for efficient traversal of the TSFSL data structure, shown in (c), during ray-casting. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">POLYHEDRAL GRID REPRESENTATION</head><p>In order to develop an efficient representation and corresponding data structure for arbitrarily complex polyhedral grids, we first consider the basic requirements that such a representation has to support. The most important operation is efficient traversal of the grid topology, for example marching from cell to cell along a given ray in ray-casting. For this, one has to be able to determine which cells are intersected by a ray in what order. To achieve this efficiently, all state-of-the-art unstructured grid ray-casters rely on an adjacency graph of cell-face-cell connectivity (see <ref type="figure" coords="3,93.65,322.22,28.85,8.06">Figure 2</ref>(a)). One must also be able to obtain sample values at arbitrary positions within each cell via interpolation. In tetrahedral meshes, this can naturally be done via barycentric interpolation. For more complex polyhedra, mean value interpolation <ref type="bibr" coords="3,229.01,352.10,14.25,8.06" target="#b15">[15,</ref><ref type="bibr" coords="3,245.21,352.10,11.88,8.06" target="#b20"> 20] </ref>can be used. This, however, requires data from all faces of the enclosing cell for every sample. Finally, determining the entry face through which a ray enters the mesh must be efficient. Current unstructured-grid raycasting-methods usually achieve this by using GPU rasterization of the mesh boundary, storing a face ID in each pixel. Thus, our representation must support the following operations: </p><p>1. Query all faces of an individual cell: Provide efficient means for enumerating all faces of a given cell. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Query neighboring cell across a face:</head><p>Given a cell and one of its faces, enable fast access to the neighboring cell across this face. </p><p>These fundamental operations are not only sufficient for ray-casting, but for all algorithms that require traversing the grid from cell to cell in some order. Examples include the computation of stream, path, and streak lines or surfaces, vortex-core extraction-techniques, and many other visualization algorithms. With the exception of tetrahedral strips and CIEL, all data structures used by previous ray-casting approaches employ an explicit cell representation. This is simple and efficient for tetrahedral grids, where each cell has four vertices and four faces. When the number of faces per cell is not constant, however, a more complex representation must be used in order to allow each cell to contain an arbitrary number of links to faces comprising its boundary. <ref type="figure" coords="3,31.50,606.86,28.86,8.06">Figure 2</ref>(a) illustrates the most common data structure for representing unstructured grid topology. This example depicts three cells composed of six faces in total, where each face knows which two cells it connects (face-to-cell connectivity, column " Faces " ), and each cell knows all of its comprising faces (cell-to-face connectivity, column " Cells " ). With this information, querying all faces of an individual cell, as well as traversing from one cell through one of its faces to its adjacent cell, is trivial. Note, however, that only one of the two types of connectivity is really required to represent the entire mesh and to allow reconstruction of the other type. In principle, it is trivial to reconstruct face-tocell information from cell-to-face information, and vice versa. The advantage of storing redundant connectivity is that it allows for fast cell-face-cell traversal, which is crucial for many visualization algorithms . Thus, the trade-off is sacrificing memory for higher traversal performance. Naturally, for complex cells the memory footprint of redundant topology information rises rapidly. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Standard Unstructured-Grid Representation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">TSFL/TSFSL Unstructured-Grid Representation</head><p>In contrast to the standard representation outlined above, the flexible data structure we introduce in this paper does not store any redundant connectivity information at all. However, it still allows for very efficient grid traversal and supports the two required fundamental operations described above. This is achieved by representing all connectivity through lists of faces comprising the mesh, without any explicit cell representation. Furthermore, we have separated the actual face-geometry data, such as how many and which vertices make up a face, from the representation of mesh topology. This enables a very compact representation of polyhedral meshes generated by different meshing approaches that employ a wide variety of cell characteristics. enumeration of all faces of any cell in the entire mesh, and for traversing from any cell across any of its faces to the respective adjacent cell. That is, cell-face-cell traversal is performed by intentionally following the link corresponding to the opposite half space of a face, thus stepping from the cell on one side of the face to the cell on its other side. In the remainder of this paper, we will further use the notation that the two values that the two boolean flags ( f ff , f bf ) can assume are + and −, to indicate the front and back half space of a face, respectively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Two-sided face sequence lists (TSFSL)</head><p>We now introduce an important refinement of the TSFL representation, which results in the construction of the Two-Sided Face Sequence Lists (TSFSL) data structure that we use in the remainder of this work. A TSFSL is constructed from a TSFL by storing selected sequences of linked faces in adjacent memory locations without storing actual links. This significantly optimizes access and traversal speed, and reduces the overall memory footprint. One of the main advantages of storing a mesh via both cell and face arrays, as in <ref type="figure" coords="4,167.77,226.82,28.85,8.06">Figure 2</ref>(a), is that references can be stored sequentially in memory and thus allow for fast access. For example, enumerating all faces of cell 3 in the figure simply scans the array <ref type="bibr" coords="4,57.78,254.30,24.17,11.66">[c, d, e]</ref>. The same enumeration in the TSFL data structure involves more effort, because for each face additional linking information must be read from memory. This introduces a large number of random memory accesses that reduce performance on architectures that prefer coherent memory accesses, such as GPUs. It also inherently incurs memory access latency, because the next face can only be visited after the corresponding link has been fetched from memory. The TSFSL data structure overcomes these problems to a large extent . Considering the mesh shown in <ref type="figure" coords="4,158.45,336.86,29.38,8.06">Figure 2</ref> (b), we can observe sequences of faces that are connected by arrows of the same color. Note especially the cell with faces (c, d, e). Here, within the cell only front links have to be followed since all faces are facing toward the cell. The occurrence of such face sequences can be exploited by storing their faces sequentially in an array without links. If this sequence is stored consecutively in memory as <ref type="bibr" coords="4,148.26,394.22,24.17,11.66">[c, d, e]</ref>, we can drop the front links and flags entirely. This does not result in any loss of information, since the storage location itself now implicitly encodes these links. If face sequences are constructed using front links, which we have chosen to do, this immediately implies that the back links and flags have to be retained, because they are then required to connect to adjacent cells. This also implies that all face sequences can be constructed by collecting all the faces of each cell that are facing toward it. We guarantee at most one face sequence per cell, by putting all faces that are facing toward it into the same sequence. This is possible because the order in which the faces of a cell are linked is arbitrary. Guaranteeing at least one face sequence per cell is also possible, because simply flipping a face's normal allows removing it from one sequence and adding it to the sequence of the cell on the opposite side. Together, this allows guaranteeing exactly one face sequence per cell. We use the following two-phase face sequence generation algorithm: The first phase starts with an initially empty face sequence s i for each cell c i . Then, the number of faces n i assigned to each s i is tracked, while assigning each face to the sequence with the lower n i (outside the mesh, n i = ∞). For all meshes that we tested, creating sequences this way was already sufficient. However, in general this may produce empty sequences with n i = 0. In order to guarantee n i &gt; 0 everywhere , we process each empty s i in a second phase. For each such s i , we pick a neighboring cell c j based on two conditions: c i has to be connected to c j through a face that is not flagged as used, and n j has to be the maximum among the neighbors that fulfill the first condition . Because n i = 0, the face connecting c i to c j is assigned to s j . By re-assigning this connecting face to s i , n i is increased from zero to one, and n j is decreased by one. The face is then flagged as used. This face re-assignment is repeated as long as n j = 0. If n j = 0, all flags that identify faces as used are cleared. After each iteration of this algorithm, the number of empty face sequences is reduced by one. See <ref type="figure" coords="4,47.55,716.42,29.15,8.06">Figure 2</ref> (c) for an illustration of how face sequences can be defined in this example. Faces within a sequence are shown connected without arrows. Note that the last link e fl and flag e ff have to be  tained, in order to connect the end of the face sequence with subsequent faces of the cell. In the example of sequence <ref type="bibr" coords="4,475.38,187.94,24.17,11.66">[c, d, e]</ref>, all faces of the cell are in one face sequence. This is not true in general, as can be seen in the face sequence <ref type="bibr" coords="4,391.98,207.86,17.98,11.66">[a, f ]</ref>. Also shown in <ref type="figure" coords="4,472.26,210.26,29.88,8.06">Figure 2</ref>(c) is the face b, which is considered as a face sequence of length one, since it cannot be connected to a longer face sequence. In the following, we summarize four important properties of the TSFSL representation that result from its construction: 1. The face list corresponding to any given cell contains exactly one face sequence, which contains all the faces that are facing toward the cell. This sequence can, however, be of length one. 2. The front links/flags for faces in the sequence are not stored, with the exception of the last face in the sequence.<ref type="figure" coords="5,31.50,182.13,18.68,7.53">Fig. 4</ref>. The pipeline for ray-casting unstructured meshes given in the TSFSL representation. A large mesh is subdivided into bricks that correspond to the leaves of a kD-tree. Rendering proceeds from brick to brick in front to back order. Each brick contains the corresponding 1D TSFSL array, as well as vertex positions and IDs of the faces comprising the mesh boundary. In order to obtain ray-start positions, the mesh boundary is rasterized. Non-convex cells are treated implicitly in each rendering pass, whereas non-convex areas of the mesh are handled using depth peeling. improves memory-access coherency. The TSFSL representation stores n + 1 face links/flags for a face sequence of n faces. Interleaving this storage with actual face geometry, a face sequence of faces <ref type="bibr" coords="5,248.46,245.18,24.80,11.66">[a, b, c] </ref>is stored in memory as [</p><formula>(a bf , a bl ), a g , (b bf , b bl ), b g , (c bf , c bl ), c g , (c ff , c fl )]. </formula><p> Note that the front link/flag of the last face in the sequence is stored after the corresponding face geometry. We will call it the face sequence terminator (denoted as t i in <ref type="figure" coords="5,132.90,287.42,29.16,8.06">Figure 3</ref>). Given this memory layout, the face sequence can be traversed by alternately reading a link/flag tuple and face geometry, until the sequence terminator is read. As above, one of the most important observations to make here is that all faces of a mesh are stored as part of a face sequence. This is possible because every face of the mesh is part of exactly one face sequence. This sequence is the one corresponding to the cell in the front half space of the face. The faces' back links, also stored in the sequence, reference faces at non-sequential storage locations, which in turn are part of other face sequences. Therefore, the entire mesh can be stored in a single 1D array, as illustrated in <ref type="figure" coords="5,147.68,387.14,29.01,8.06">Figure 3</ref>. Face geometry records: The actual geometry storage format of f g can be arbitrary, with the restriction that its size can either be inferred implicitly (e.g., if all faces use an equal amount of memory), or can be derived from a small header at the start of f g . Our current implementation supports two fixed-size face geometry representations, which can store three or four vertex indices. A variable-sized version stores the number of vertices of each face in addition to its vertex IDs. The former are used for meshes (or bricks, see below) that only contain triangle and quad faces. The latter is used for more complex polyhedral meshes, for example the mesh shown in <ref type="figure" coords="5,175.67,486.74,28.93,8.06">Figure 1</ref> . A more detailed description is given in the context of ray-face intersection in Section 4.3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RAY-CASTING OF TSFSL MESHES</head><p>For efficient ray-casting of large TSFSL meshes, the grid is subdivided into bricks that are the leaves of a kD-tree (Section 4.1). Bricks are rendered individually, and composited in front to back order (Sections 4.2 and 4.3). The mesh in each brick is represented by a single 1D TSFSL array. <ref type="figure" coords="5,54.31,567.14,30.00,8.06">Figure 4</ref>gives an overview of the resulting ray-casting pipeline. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Bricking</head><p>We employ a domain decomposition of the entire mesh into bricks. Reasons are: scalability, memory management, adaptivity with respect to characteristics of the contained cells, coarse-grained culling, and the potential for direct parallelization across multiple GPUs. The brick geometry corresponds to the leaves of a kD tree, which is built using criteria similar to previous work <ref type="bibr" coords="5,152.73,646.82,13.70,8.06" target="#b32">[32]</ref>. However, we avoid explicitly clipping cells against brick boundaries. Instead, each brick is assigned a submesh that comprises all cells that are entirely or partially inside the brick boundary. Ray-casting is performed brick by brick in frontto-back visibility order, determined using the kD tree. In the following, the ray-casting procedure is described considering a single brick. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Ray-Setup Stage</head><p>The first step of ray-casting is to determine the positions where rays enter each brick. The most important part of this step is determining the ID of the face through which a given ray enters the first cell. This can be done very efficiently by encoding IDs in colors and rasterizing the grid boundary accordingly. In previous GPU ray-casting approaches <ref type="bibr" coords="5,336.43,257.54,14.24,8.06" target="#b13">[13,</ref><ref type="bibr" coords="5,352.63,257.54,11.25,8.06" target="#b32"> 32,</ref><ref type="bibr" coords="5,365.85,257.54,11.24,8.06" target="#b41"> 42,</ref><ref type="bibr" coords="5,379.05,257.54,10.69,8.06" target="#b43"> 44]</ref>, the triangle mesh representing the volume boundary had to be stored explicitly in a format suitable for fast rasterization (e.g., in OpenGL vertex buffer objects). We avoid permanently storing this redundant representation for the whole mesh. Instead, each brick's submesh boundary is extracted on-the-fly from the TSFSL data structure before a brick is rendered, and immediately discarded afterward . The size of the buffer for storing this temporary boundary geometry needs only be large enough to accommodate the largest brick of the mesh. The submesh boundary geometry is generated on-the-fly using a GPU geometry shader. The faces of the triangulated boundary are computed from an array of boundary face IDs stored with the brick data (see <ref type="figure" coords="5,327.77,367.22,28.81,8.06">Figure 4</ref>). Details on using a geometry shader for computing this triangulation are provided in Section 5.1. Special care has to be taken when bricking is used. The spatial subdivision requires that the submesh in each brick must only contribute to the volume rendering integral inside the brick boundary for correct compositing. Previous options for doing this include either explicitly clipping cells against the brick boundary, or rasterizing one quad per cell that is large enough to cover the projection of the cell/clipping plane intersection in screen space <ref type="bibr" coords="5,416.91,447.02,13.78,8.06" target="#b32">[32]</ref>. The former approach requires storing explicit geometry for the resulting cuts, which is very costly for general polyhedral cells and usually involves triangulating the cut. The latter approach requires discarding fragments outside of the cell using face geometry information. However, for a complex cell and face geometry , the inside/outside test for discarding fragments becomes very expensive. Given these drawbacks of previous approaches for complex polyhedral cells, we use a different approach. Before the actual rendering passes for each brick, we perform a setup-rasterization step that traverses rays in order to find the entry positions of rays into cells inside the brick. This setup step is illustrated in <ref type="figure" coords="5,471.32,546.61,29.49,8.06">Figure 5</ref>. Instead of rasterizing the volume boundary and the cell/brick-boundary intersections separately, we rasterize the unmodified volume boundary of the submesh that intersects a given brick, without clipping it. This rasterizes faces completely within the brick boundary, faces intersected by the brick boundary, and faces completely outside the brick boundary. <ref type="figure" coords="5,294.06,716.01,19.05,7.53">Fig. 5</ref>. Instead of explicitly clipping cells against brick boundaries (grey rectangle), the ray-setup stage of each brick determines ray-start positions by traversing rays from boundary-cell faces to the brick boundary. </p><formula>(1) </formula><formula>(4) (0) Viewing Rays (3) (2) </formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>During </head><p>this rasterization, a setup ray is cast for each fragment. If the start position is already in the brick (ray (0) in <ref type="figure" coords="6,201.07,63.38,29.95,8.06">Figure 5</ref> ), the fragment immediately writes out the ID of the face that is being rasterized. For all other rays, the ray start position is outside the brick boundary, where we distinguish the following cases: 1. Rays may enter the brick without first leaving the corresponding submesh (ray (1) in <ref type="figure" coords="6,114.02,118.46,28.81,8.06">Figure 5</ref>). At that point, these rays terminate and write out the face ID of the last face they intersected. 2. Rays may leave the submesh before they enter the brick (ray (2) in <ref type="figure" coords="6,51.63,150.86,28.96,8.06">Figure 5</ref>). These rays terminate without writing a face ID. 3. Rays that do not intersect the brick boundary at all (in the area marked with (3) in <ref type="figure" coords="6,111.37,173.30,28.92,8.06">Figure 5</ref>). These rays terminate immediately. </p><p> Note that since the entire submesh boundary is rasterized, this procedure also determines correct entry positions in non-convex areas, with respect to both non-convex mesh and cell boundaries. For example, ray (4) in <ref type="figure" coords="6,59.58,222.62,30.61,8.06">Figure 5</ref>determines and writes out the correct intersection and start position at the brick boundary, whereas ray (2) is correctly discarded, as described above. The output of the ray-setup stage is a ray-setup image that for every pixel stores a face ID and flag that identify the cell where the corresponding ray must start for volume ray-casting (Section 4.3). The face ID is encoded as a color, and the alpha channel is used for the flag. We deal with rays exiting and re-entering non-convex meshes by utilizing an approach that is similar to depth peeling <ref type="bibr" coords="6,181.41,302.42,14.25,8.06" target="#b32">[32,</ref><ref type="bibr" coords="6,198.22,302.42,10.61,8.06" target="#b43"> 44]</ref> . The grid is processed in depth layers corresponding to successive front-facing mesh boundary faces. For each depth layer, a ray-setup image is generated. However, the full ray-setup stage is only required for the first depth layer, since for all subsequent layers the ray start positions are already guaranteed to lie inside the brick. For these layers, simply clipping the submesh boundary to the brick's bounding box is sufficient. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Ray-Casting</head><p>After the ray-setup stage described above, the main volume ray-casting pass is executed. In this pass, a ray is generated for every pixel where the flag in the ray-setup image is = 0, i.e., where the ray has been determined to intersect the mesh, and the pixel's face ID is valid. Volume ray-casting proceeds in a loop from sample to sample along each ray, repeatedly carrying out the following three main tasks: 1. Mesh traversal, for traversing the mesh topology along a ray cell by cell, using the TSFSL data structure (Section 4.3.1). 2. Ray-face intersection, for determining the next face intersected by the ray, also for non-convex faces and cells (Section 4.3.2). 3. Sampling and interpolation, for determining sample values via interpolation within the current cell (Section 4.3.3). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Mesh traversal</head><p>The algorithm is illustrated in pseudo code in <ref type="figure" coords="6,185.72,547.10,28.75,8.06">Figure 6</ref>. The outer loop (lines 3-27) traverses the mesh along a ray by stepping from cell to cell through shared faces. The inner loop (lines 6-23) iterates over all faces of the current cell using the TSFSL data structure, and computes the next intersection of a ray with a cell face. Because we do not store explicit cell information, both of these tasks are performed by following face links: Either by stepping from one side of a face to the other side by following the opposite-side front/back link, or by iterating over all faces of a cell, in turn invoking the ray-face intersection (Section 4.3.2) for every encountered face. Mesh traversal is started at the face specified in the color channel of the ray-setup image: startFace. The flag stored in the alpha channel is used to decide whether to initially follow front or back links: cellInFrontOfStartFace. The result of the inner loop is the face through which the ray leaves the cell, as well as the flag indicating whether the next cell is in front or behind this face. Note that non-convex cells can be entered and exited multiple times. Before traversal is continued in the outer loop, the entire ray segment between the entry and exit faces of the inner loop is sampled and composited. The exit face and negated flag resulting from the inner loop completion then become the input to the next iteration of the outer loop. The simple operation of logically negating the flag before the next loop iteration is what performs the step from one cell to the next. The outer loop terminates when the ray has exited the brick. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Ray-face intersection</head><p>The inputs to the ray-face intersection algorithm are: a face ID, a ray direction v and origin o, and a boolean flag s that indicates whether the face normal should be flipped for the intersection test as described below. The output is the distance to the intersection, or ∞ if there is no intersection. An intersection with a face is only reported when the local face normal n x , at an intersection point x, points in the same direction as v, i.e., n x · v &gt; 0. If s is true, the face normal is flipped for this comparison. This test, together with a check whether the intersection is further down the ray than the cell entry position, correctly handles faces that are viewed edge-on. It also avoids erroneous detection of intersection with the face through which the ray has entered the cell. In the case of orthogonal projection, we further simplify the computations for ray-face intersection by transforming all vertices of a brick from world space to view space, and performing intersection in the latter . The ray direction then is (0, 0, −1), which reduces the required 3D ray-triangle intersections to computing 2D barycentric coordinates for o transformed and projected into view space. The involved dot product reduces to a single multiplication. For further optimization, our system integrates three different types of face geometry representations at a per-brick granularity (see also Section 3.3). Each type employs its own optimized ray-face intersection: 1. For purely tetrahedral bricks, the three vertex indices of each triangle are stored, which makes the ray-face intersection trivial. 2. For bricks with cells where all faces are either triangles or quads (e.g., a mixture of tetrahedral, hexahedral, and octrahedral cells), quads are decomposed on-the-fly into two triangles. The ray-face intersection is then carried out separately for these two triangles. Note that this case includes non-planar faces. 3. For bricks containing cell faces with more than four vertices, i.e., an arbitrary number of vertices describing possibly highly nonplanar faces, we use the general strategy described below. For efficiency reasons, our system triangulates cell faces with more than four vertices when a mesh is loaded, instead of triangulating them 1: <ref type="figure" coords="7,31.50,170.49,18.80,7.53">Fig. 7</ref>. The data sets used to evaluate our TSFSL ray-casting approach, with mesh statistics. Timings for ray-casting are given in <ref type="figure" coords="7,485.37,170.49,24.45,7.53" target="#tab_2">Table 2</ref>. on-the-fly during ray-casting. For this purpose, arbitrary triangulations can easily be integrated into our system. We have done extensive experiments with triangulations based on either a triangle strip or a triangle fan. Only the latter has turned out to work very well in practice. A very important consideration for face triangulations is that in complex real-world meshes the faces are often non-planar, ranging from slightly non-planar to extremely non-planar. In the meshes that we have examined, a triangle strip decomposition of each face has turned out to be infeasible. These meshes contain at least some faces that are so highly deformed that they cannot be decomposed into triangle strips without introducing mesh inconsistencies. Our current approach therefore decomposes each face into a triangle fan around the centroid of all face vertices. Such a triangulation is symmetric, while the triangle strip decomposition is not. Ray-face intersection during raycasting is then performed by intersecting the ray with each triangle of the fan individually. A drawback of triangle fans around the centroid is that an additional centroid vertex has to be stored per face. Naturally , general ray-face intersections are costly. Therefore, for each face we also store the squared radius r 2 of a bounding sphere centered at the centroid. Full ray-face intersection is only performed when the ray's intersection with the face's bounding sphere is non-empty. This test is also performed in screen space which reduces the ray-sphere intersection to simply computing the squared distance between the ray position and face centroid in 2D screen space. The proposed trianglefan face-decomposition is not feasible for faces which do not contain their centroid or are not star-shaped. To cope with such faces, a more general face-geometry representation, such as an actual triangle mesh, could be used. However, none of the real-world meshes that we have evaluated actually contained such faces. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Sampling and interpolation</head><p> The final component of ray-casting is obtaining values at sample positions by using different interpolation schemes. We switch between two different interpolation methods on a per-brick basis: 1. For vertex-centered data, we employ mean value interpolation in the interior of complex cells <ref type="bibr" coords="7,157.25,542.54,13.71,8.06" target="#b32">[32]</ref>, and barycentric interpolation in purely tetrahedral cells, as well as on all triangular faces. 2. For cell-centered data with a constant scalar value per cell, we employ piecewise constant interpolation. This is very useful in practice, because in many cases real simulation data from stateof-the-art packages <ref type="bibr" coords="7,122.20,593.66,9.77,8.06" target="#b0">[1,</ref><ref type="bibr" coords="7,133.92,593.66,6.80,8.06" target="#b1"> 2,</ref><ref type="bibr" coords="7,142.80,593.66,7.43,8.06" target="#b2"> 3] </ref> can be cell-centered. Thus, this simple approach generates visualizations that are an adequate representation of the simulation results. For mean value interpolation, we allow the user to enable two different optimizations during interaction that slightly reduce image quality while increasing rendering performance significantly. First, we can fall back to linear interpolation along a ray segment between cellray entry and exit positions. Second, we can use an adaptive scheme, which alternatively uses either linear interpolation along a ray segment or inserts one mean-value sample at the segment's center. Subsequently , linear interpolation between entry, center, and exit points is used. The additional mean-value sample is only used when the ray-segment length exceeds a user defined threshold. Even for high quality visualizations, we found it to be sufficient to use one meanvalue sample at the center of each ray segment within a cell. This can be attributed to the nature of mean value interpolation, which deviates most strongly from linear behavior in the cell interior, whereas it quickly converges toward barycentric interpolation at the cell faces. Note that in the case of non-convex polyhedra, mean value interpolation can generate negative weights for faces whose exterior side is facing toward the sample position. In order to solve this, positive mean value interpolation could be used instead <ref type="bibr" coords="7,471.13,250.34,13.72,8.06" target="#b27">[27]</ref>. However, this would come at the expense of smoothness, since positive mean value coordinates are not guaranteed to remain smooth within non-convex polytopes. As an additional consideration, using complex interpolation methods for cells that are smaller than one image pixel in the final visualization is a waste of processing resources. Thus, we automatically enable piecewise constant interpolation for bricks where all cells project to one image pixel or less. These bricks are determined by storing their maximum cell size and calculating the corresponding projected size at the distance of the brick corner closest to the view plane. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>We discuss important implementation details, give results for complex real-world meshes, and compare our approach with previous work. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Implementation</head><p>This section discusses details of how the TSFSL representation and additional mesh data are stored in memory, as well as our TSFSL raycasting implementation. Memory layout: Our ray-casting system is implemented in OpenGL and GLSL. The entire TSFSL data structure for each brick is stored in a single 1D 32-bit integer texture. Each face is represented by a 32-bit int header followed by the vertex index data. The header contains a 24-bit address for the face's back link, 6 bits for the size of the following vertex data, and two additional flag bits. One is the back flag for the back link, and the second flag indicates whether the face is the last in the sequence. If the latter bit is set, the integer value following the face vertex data is the face sequence terminator. As in the face header, the int of the face-sequence terminator is split into a 24-bit address for the front link, and one bit front flag. In the case of cell-centered data, the terminator is followed by a 32-bit int addressing the cell corresponding to the face sequence that is terminated. If triangle-fan face-decomposition is used, we store all vertex indices of a face, starting with the center vertex, as 32-bit int indices. For triangle and quad faces, each vertex is a single 32-bit int. Ray-casting: Two different kinds of temporarily derived data are generated before ray-casting each brick (see Section 4): First, all vertex positions are transformed into view space by utilizing the transform feedback capabilities of current GPUs. Then, the mesh boundary containing b faces is triangulated on-the-fly by a geometry shader. The input primitives for this shader are b points, for each of which only a single integer index is stored. This index is the address of a face in the TSFSL data structure that is subsequently triangulated according to the current face-triangulation settings. On current GPUs, we are limited to generate triangle strips in the geometry shader. We therefore generate the triangle-fan decompositions of complex cell faces by inserting degenerate triangles. This approach is preferable to restarting a new strip after each triangle since fewer vertices have to be emitted <ref type="figure" coords="8,22.50,142.29,19.05,7.53">Fig. 8</ref>. Comparison of the influence of different sampling strategies on image quality. The three bottom-row inlays depict the differences between two neighboring images, respectively, with difference-color values scaled by a factor of 16. The additional inset at the top of the image labeled " adaptive " depicts the regions using mean value interpolation (colored in blue). by the shader. After depth peeling has been performed for a brick, the triangulation data as well as the transformed vertex positions are discarded. This approach is feasible because the overall mesh is processed brick by brick, each of which contains only a fixed maximum of cells/faces/vertices. The shading effects visible in <ref type="figure" coords="8,211.71,221.06,29.93,8.06">Figure 7</ref> are generated by applying limb darkening <ref type="bibr" coords="8,148.14,231.02,13.79,8.06" target="#b19">[19]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Data Sets</head><p> In order to demonstrate the usefulness of our new volumevisualization algorithms we have selected the four representative data sets depicted in <ref type="figure" coords="8,83.54,286.34,30.25,8.06">Figure 7</ref> , which range from fairly small to reasonably large in size. Among these four data sets, two different configurations of our ray-casting approach have to be employed in order to cope with different cell characteristics. In order to compare memory requirements and rendering performance, we provide the number of tetrahedra into which the mesh can be decomposed. The tetrahedralization scheme taken to derive this number is selected based on the face-triangulation approach used for the respective mesh. Each subtriangle of an interior face results in two tetrahedra made up of the triangle vertices and the cell centroid of either the cell in front or behind the triangle. Sub-triangles of boundary faces only generate one tetrahedron. Although this is not the tetrahedralization resulting in the minimum number of cells, we have used it to obtain result images that are comparable with our results, which use mean value interpolation. The heater, manifold, and mixer data sets have been created by the same simulation package <ref type="bibr" coords="8,115.40,436.46,10.45,8.06" target="#b2">[3] </ref> and therefore share common mesh characteristics . All meshes comprise general polyhedral cells with often highly non-planar faces. We cope with this by utilizing a triangle fan decomposition of each face. Note that as soon as more complex cells are present, the number of tetrahedra generated by tetrahedralization can increase between one to two orders of magnitude when compared to the original cell decomposition. The cooling jacket data set <ref type="bibr" coords="8,257.91,496.34,15.00,8.06" target="#b25">[25] </ref>contains only a fixed set of cell types (tetrahedra, quadratic pyramids, triangular prisms, and hexahedra), which again can be non-convex. The mixer and the cooling jacket data sets are decomposed into four and ten bricks, respectively, due to their size. The increase of the number of cells that have to be stored due to bricking is shown in <ref type="figure" coords="8,240.61,546.14,28.80,8.06">Figure 7</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Evaluation and Discussion</head><p>The evaluation of the methods proposed in this work is complex and will be performed in multiple parts. First, we compare the memory requirements of the TSFSL mesh representation to other data structures that have been used to perform volume rendering. Next, we evaluate the rendering performance of different quality and sampling settings, and discuss their impact on the resulting image quality. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Memory Consumption</head><p>This comparison is difficult since to our knowledge there exist only four other GPU volume renderers capable of directly rendering convex polyhedral cells <ref type="bibr" coords="8,97.71,686.54,14.24,8.06" target="#b10">[10,</ref><ref type="bibr" coords="8,114.51,686.54,11.25,8.06" target="#b26"> 26,</ref><ref type="bibr" coords="8,128.32,686.54,11.24,8.06" target="#b32"> 32,</ref><ref type="bibr" coords="8,142.12,686.54,10.69,8.06"> 39]</ref>. Three of those <ref type="bibr" coords="8,215.31,686.54,14.13,8.06" target="#b10">[10,</ref><ref type="bibr" coords="8,232.12,686.54,11.13,8.06" target="#b26"> 26,</ref><ref type="bibr" coords="8,245.93,686.54,11.88,8.06"> 39] </ref>can process non-convex cells without requiring subdivision. The HAVS level-of-detail extension has been included in this list since it can cope with polyhedral cells on a basic level. It is, however, limited to piecewise linear interpolation along ray segments within a cell because only face-to-vertex connectivity data is available to the GPU. We compare the memory requirements of our TSFSL structure with different stateof-the-art representations by giving the number of bytes per tetrahedron in <ref type="figure" coords="8,314.00,201.13,25.79,8.06" target="#tab_1">Table 1</ref> . For non-tetrahedral meshes, this is computed by dividing the overall memory consumption by the number of tetrahedra in an equivalent tetrahedralization. The memory overhead that is introduced by our technique due to bricking is included in these figures. The hybrid ray-casting algorithm <ref type="bibr" coords="8,415.49,241.81,14.88,8.06" target="#b32">[32] </ref> is optimized for meshes containing only few cell types and requires convex cells composed of triangular or planar quadrangular faces. Slicing-based volume rendering on CIEL is mainly executed on the CPU, because only the slice rasterization is performed on the GPU, and thus requires basically no GPU memory. The per-tetrahedra memory consumption for CIEL has been estimated based on the overall memory consumption stated in the corresponding publication. Scalar data are represented as polynomials in the case of the higher-order finite-elements visualization technique (HOFEV) <ref type="bibr" coords="8,323.16,331.57,13.80,8.06">[39]</ref>. Therefore a direct comparison to the other techniques in <ref type="figure" coords="8,295.26,341.53,27.41,8.06" target="#tab_1">Table 1</ref> would be biased toward techniques dealing with conventional CFD data. In order to avoid this biasing, we have compared the memory required to store only topology information. In the case of data sets such as the heater or the manifold, the TSFSL representation uses 34% less memory than the topology data structure employed by HOFEV. For simpler data sets, such as the cooling jacket, this difference is 24%. Similarly to TSFSL, HAVS uses face data to represent a volume mesh. Only three vertex indices per face as well as vertex positions and scalar data are stored in GPU memory. This results in very competitive memory requirements on the GPU side. However, a significant amount of memory is used to perform efficient face sorting on the CPU. The per-tetrahedra memory figures are based on our four test data sets. In summary, <ref type="figure" coords="8,383.62,461.05,26.54,8.06" target="#tab_1">Table 1</ref>clearly shows that our GPU-based data structure is superior with respect to memory consumption to most state-of-the-art grid representations for volume rendering. Only HAVS utilizes a data representation on the GPU that is equally efficient. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Rendering Performance</head><p>Besides the memory footprint, the actual rendering performance of our ray-casting approach has to be evaluated. However, we note that the main goal of this work is to reduce the memory that is necessary to represent an unstructured mesh, while still allowing for efficient ray-casting. A major reason for this rationale is that recent developments in graphics hardware indicate that computing speed is growing far more rapidly than on board memory size. <ref type="figure" coords="8,444.67,586.93,25.98,8.06" target="#tab_2">Table 2</ref> compares the performance of an object-order volume-rendering-method (HAVS) and a state-of-the-art GPU-based tiled ray-casting method (TRC) to TSFSL volume rendering. All tests have been performed by rendering into a 1024x768 view port on a Core 2 Quad CPU at 2.8 GHz with 8 GB of RAM and an NVIDIA Geforce 480 GTX with 1.5 GB of memory. The different results listed for ray-casting with TSFSL are due to different quality and sampling settings. The rows labeled high quality (HQ) represent results generated by using the full 1024x768 render target. HAVS and TRC create output images with the same resolution. The low quality (LQ) figures were measured when rendering only 512x384 images that were subsequently scaled to 1024x768 while also only performing ray-casting for one depth peel per brick. The disproportionately strong performance increase between the HQ and the LQ modes for the manifold data set is caused by the fact that the data set consists of a thin layer of geometry representing solid parts surrounding fluid <ref type="figure" coords="9,31.50,172.89,23.85,7.53" target="#tab_1">Table 1</ref> . Memory footprint comparison of TSFSL with state-of-the-art unstructured grid rendering approaches (measured in bytes/tetrahedron). cells. Thus, terminating the ray-casting after one depth peel skips a considerable part of the overall data volume. When working with the mixer data set, the memory requirements for HAVS exceeded the 8 GB of RAM installed in the workstation used for benchmarking. Therefore , no conclusive results were measured due to constant swapping operations by the operating system. When assuming linear scaling in the number of grid triangles, rendering the mixer data set with HAVS should require around 16 seconds. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Interpolation and Image Quality</head><p>We have evaluated four different sampling strategies. The fastest is piecewise-constant sampling using cell-centered data. We note that all four test data sets originally contain cell-centered data, and therefore this sampling approach properly represents the original simulation results . However, if smoothed results are desired for presentation purposes , vertex-centered data can be visualized. Our rendering system uses barycentric interpolation at cell faces. Results stated in the rows labeled as " linear " have been generated by using linear interpolation between ray entry and exit positions of a cell. In order to generate higher quality images, one mean-value sample is used at the midpoint between ray entry and exit position. Performance figures for this sampling strategy are given in the rows denoted as " mean value " . As can be expected, the complex computations necessary per cell face incur a severe performance hit on the overall rendering time. This is especially prominent for data sets containing general polyhedral cells (heater, manifold, and mixer). The main differences between images generated by the fast " linear " quality setting and the " mean value " option lie in regions where large cells are located (see image quality comparison in <ref type="figure" coords="9,86.09,486.86,29.53,8.06">Figure 8</ref>). Therefore, we propose a fourth " adaptive " sampling strategy that is controlled by a user defined threshold θ . Reconstruction using mean value interpolation is only used if the length of a viewing-ray segment within a cell is greater than θ . Otherwise the much faster linear reconstruction is used within a cell. The user has the option to choose two out of the four sampling strategies in their HQ or LQ configurations for rendering preview images during interaction, and presentation quality visualizations when interaction has stopped. When compared to HAVS, our high-quality TSFSL methods are only faster for reasonably large data sets such as the cooling jacket. Here, the main limiting factor for HAVS is the number of triangles (∼53Mio), which have to be sorted by the CPU. Also note that the HAVS algorithm generates rendering artifacts on current generation graphics hardware since it performs reading from and writing to the same texture target within one GPU program. This operation results in undefined behavior in OpenGL and in DirectX. The tiled ray-casting approach scales similarly to our low quality volume rendering implementations . However, it requires much more GPU memory (see Table 1), and the publicly available open source implementation has not been able to load the cooling jacket nor the mixer data set (even though a 64 bit binary has been used). Image Quality: <ref type="figure" coords="9,105.06,696.50,31.08,8.06">Figure 8</ref> compares the image quality of the different sampling strategies that are supported by our rendering framework . The transfer function used throughout the comparison represents a worst case scenario, which highlights the differences between the sampling methods. This is because it comprises a nearly opaque <ref type="figure" coords="9,294.06,174.09,25.29,7.53" target="#tab_2">Table 2</ref>. Performance measures and comparison with state-of-the-art unstructured grid rendering approaches. Rows labeled HQ correspond to high rendering quality (1024x768), and rows labeled LQ correspond to low rendering quality (512x384). region and a completely transparent region without a smooth transition in between. <ref type="figure" coords="9,356.81,234.98,29.75,8.06">Figure 8</ref>(a) depicts the fastest sampling strategy for vertex-centered data, which interpolates linearly between ray-cell entry and exit positions. The adaptive sampling method is used in <ref type="figure" coords="9,529.46,254.90,15.00,8.06;9,294.06,264.86,17.95,8.06">Fig- ure 8</ref>(b). The linearization artifacts introduced by the first approach are reduced by incorporating one mean-value sample for ray segments that are longer than a user defined threshold θ . If θ is chosen to be larger than the diameter of the largest cell, then only the linear approximation is used, whereas if θ is set to zero, a mean-value sample is selected for every ray segment. The viewing rays for which mean-value samples have been computed are highlighted in the inset as blue re- gions. <ref type="figure" coords="9,318.55,334.58,29.06,8.06">Figure 8</ref>(c) shows a result image where one mean-value sample has been used per ray segment within a cell. In order to qualify differences between visualizations we have included difference images that have been scaled up by a factor of 16. They clearly show how linear interpolation and the adaptive sampling strategy differ in regions where mean-value samples have been included. Naturally, the largest differences between the adaptive sampling scheme and always using one mean-value sample show up in regions composed of small cells. The number of mean-value samples per ray segment within a cell is limited to one in all our sampling strategies. Additional samples only marginally add to the overall image quality. This is illustrated in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>We have presented a compact, face-based representation for general unstructured grids that does not store redundant information. Our twosided face sequence list (TSFSL) representation is flexible enough to support the efficient traversal of rays from cell to cell, as well as enabling efficient access to all information required for high-quality interpolation , such as mean value schemes. These are the two crucial components required for volume visualization via ray-casting, as well as other important visualization algorithms. In order to demonstrate the feasibility of the TSFSL representation in practice, we have presented a complete GPU-based unstructured-grid ray-casting pipeline. Our system can handle large data sets via bricking, and is able to efficiently cope with both non-convex mesh boundaries and non-convex polyhedral cells, even in the presence of highly non-planar faces. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="9,529.51,434.18,14.98,8.06;9,294.06,444.14,250.49,8.06;9,294.06,454.10,250.36,8.06;9,294.06,464.06,126.65,8.06"><head></head><figDesc>Figure 8(d). Here, two mean-value samples have been computed per ray segment. The difference image between Figures 8 (c) and (d) barely shows any distinguishable features. </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false" coords="6,285.06,445.54,250.46,296.96"><figDesc coords="6,381.42,651.60,37.74,10.36;6,285.06,663.22,10.17,7.17;6,323.26,663.22,160.46,7.17;6,285.06,672.58,10.14,7.17;6,323.22,670.44,68.59,10.36;6,285.06,682.06,10.14,7.17;6,323.22,679.92,162.21,10.36;6,285.06,691.54,10.14,7.17;6,311.22,691.54,158.40,7.17;6,285.06,701.02,56.86,7.17;6,285.06,716.01,250.45,7.53;6,285.06,725.49,250.35,7.53;6,285.06,734.97,239.72,7.53">= startFace 24: Perform sampling between startFace and minFace 25: startFace ← minFace 26: cellInFrontOfStartFace ← ¬cellInFrontOfMinFace 27: until startFace is boundary face or ray exits brick 28: end function Fig. 6. Pseudo code for mesh traversal during ray-casting using the TSFSL data structure (see Section 4.3). Note that a face in this context simply denotes a face reference (ID), not actual face geometry data.</figDesc><table coords="6,285.06,445.54,250.35,215.37">function MESHTRAVERSAL 
2: 
Read startFace and cellInFrontOfStartFace from ray-setup images 
3: 
repeat 
This loop traverses all cells along a view ray 
4: 
currentFace ← startFace, d min ← ∞ 
5: 
cellInFrontOfFace ← cellInFrontOfStartFace 
6: 
repeat 
This loop iterates over all faces of a cell 
7: 
d ← RayFaceIntersection(currentFace, cellInFrontOfFace) 
8: 
if d &lt; d min then 
9: 
d min ← d 
10: 
minFace ← currentFace 
11: 
cellInFrontOfMinFace ← cellInFrontOfFace 
12: 
end if 
13: 
if cellInFrontOfFace then 
Go to next face of cell 
14: 
advance currentFace along face sequence 
15: 
if sequence terminator reached then 
16: 
cellInFrontOfFace ←GETFRONTFLAG(currentFace) 
17: 
currentFace ←GETFRONTLINK(currentFace) 
18: 
end if 
19: 
else 
20: 
cellInFrontOfFace ←GETBACKFLAG(currentFace) 
21: 
currentFace ←GETBACKLINK(currentFace) 
22: 
end if 
23: 
until currentFace 1,538K / 1,631K / 4,707K 
17,044K (~8.5 byte/tet) 
tets/pyramids/wedges/hexas 
4/1.7% 
4.0s 

82K / 324K / 441K 
4,095K (~7.0 byte/tet) 
general (non-convex) polyhedra 
1/0% 
1.7s 

17K / 68K / 91K 
851K (~7.0 byte/tet) 
general (non-conv.) polyh. 
1/0% 
1.0s 

Heater 
Exhaust Manifold 
Cooling Jacket 

Cells/Vertices/Faces: 
Tetrahedra: 
Celltypes: 
Bricks/Cell Overhead: 
TSFSL Creation Time: 

Mixer 

1,362K / 7,432K / 8,869K 
89,417K (~7.5 byte/tet) 
general (non-convex) polyhedra 
10/8.6% 
9.0s 

</table></figure>

			<note place="foot" n="3">.2.1 Two-sided face lists (TSFL) We only store mesh faces, and exploit the fact that each face has at most two adjacent cells. Therefore, if we think of linking all faces of a given cell together, then any given face can be a part of at most two separate face lists. That is, a face is part of two face lists when it connects two cells, or is part of only a single face list when it is a boundary face. Therefore, it is sufficient to reserve only two link fields per face, including some additional information per link as described below. Because of the two sides of each face and their respective lists, we call the resulting data structure Two-Sided Face Lists (TSFL). Face links: Consider Figure 2(b), which depicts six faces, each of which has two links to other faces. The front link f fl links to another face of the cell located in its front half space; the back link f bl links to another face of the cell in its back half space. Each cell is then only represented implicitly as one cycle in the directed graph whose vertices are the cell faces, and whose edges are these front and back links, respectively. This representation has obvious similarities to the winged edge data structure for surface meshes [5]. However, instead of linking edges in adjacency order, we link the faces comprising a cell in arbitrary order, storing only minimal linking information that is sufficient to support the two queries required above. This arbitrary linking differentiates TSFL from other half-edge/face data structures, where each link represents a specific geometric relation. Face link flags: In order to enumerate all faces of a cell, the front and back links alone are not sufficient. For example, consider enumerating the faces of the cell in front of face f in Figure 2(b). At every step of following a face link, one has to know whether to follow the front link or the back link, respectively. It is not possible to orient face normals consistently with respect to every cell. This problem can be solved by augmenting every link field with a boolean flag that indicates whether the cell whose faces are being enumerated is in the front or back half space, respectively, of the face that the link refers to. Cell-face-cell traversal: The TSFL representation, consisting of the per-face front link ( f fl ) with its boolean flag ( f ff ), and the per-face back link ( f bl ) with its boolean flag ( f bf ), is sufficient for complete</note>

			<note place="foot" n="3">. The back links/flags must be stored for all faces in the sequence. 4. All faces facing away from a cell are not part of this cell&apos;s face sequence, but of the sequence of the cell they are facing toward. A crucial consequence of this construction is that all face sequence lists of an entire mesh can be stored back-to-back in a single 1D array. Memory savings of the TSFSL representation: In order to quantify the memory savings resulting from face sequences, we count the number of links that can be discarded, in comparison with the TSFL structure. For a sequence containing n faces, n − 1 links can be removed . For a mesh containing c cells, with f internal and b mesh boundary faces, the average face sequence length is ( f + b)/c, because each face belongs to exactly one face sequence, which in turn corresponds to exactly one cell. Thus, on average ( f + b)/c − 1 links can be omitted per cell, which amounts to omitting f + b − c links in total over the entire mesh. Note that with an increasing average number of faces per cell, (b + 2 f )/c, the number of links that can be discarded increases. Overall, the number of links stored in the TSFL representation is equal to b + 2 f , whereas the TSFSL representation thus contains only f + c links. For comparison, the standard approach depicted in Figure 2(a) must store 2( f + b) links from faces to cells, and b + 2 f links from cells to faces. It is interesting to note that the number of links stored in our data structure depends on the number of cells, whereas this is not the case in the standard approach. In order to directly compare both numbers, we can use the property that the number of faces per cell is at least 4 (i.e., cells are at least tetrahedra), and thus: (b + 2 f )/c ≥ 4. From this follows that (b + 2 f )/4 ≥ c. An upper bound for TSFSL can be defined as f + c ≤ 3 f /2 + b/4. For the &quot; worst &quot; case of a tetrahedral mesh this is still smaller than either the number of face-to-cell or cell-to-face links required in the standard representation. Relative memory savings increase as the average number of faces per cell goes up. Actual memory consumption numbers and comparisons for real-world meshes are reported in Section 5.3. 3.3 Face Geometry and TSFSL Storage In addition to storing mesh topology in the TSFSL data structure, the geometry of each face must also be stored. Conceptually, we completely separate mesh topology from face geometry. This enables adapting the geometry representation to a variety of characteristics of real-world meshes and the corresponding meshing algorithms and tools, which can also vary between different mesh regions or zones. Despite the important conceptual separation, we can interleave the actual storage of face geometry in memory (denoted below abstractly as f g for face f ) with the TSFSL records of the corresponding faces. This</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS </head><p>The authors thank Dr. Eberhard Schreck and Dipl.-Ing. Julian Gänz from CD-Adapco for providing us with the polyhedral data sets. The cooling jacket data set is courtesy of AVL List GmbH, Graz, Austria . Parts of this work were funded by the Austrian Research Funding Agency (FFG) in the scope of the project " AutARG " (No. 819352), as well as by the Vienna Science and Technology Fund (WWTF) project " Scale-VS " (No. ICT08-040). </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct coords="9,312.39,737.02,220.57,7.17"  xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Fluent By Ansys</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Url</forename>
				<surname>See</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.73,54.10,222.10,7.17"  xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Openfoam</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Url</forename>
				<surname>See</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.74,63.46,104.11,7.17"  xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Star</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct coords="10,174.66,63.46,97.95,7.17;10,40.74,72.94,172.16,7.17"  xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Url</forename>
				<surname>See</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.74,82.42,231.99,7.17;10,40.74,91.90,232.05,7.17;10,40.74,101.38,217.86,7.17"  xml:id="b4">
	<analytic>
		<title level="a" type="main">Compact array-based mesh data structures</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">J</forename>
				<surname>Alumbaugh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Jiao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 14th International Meshing Roundtable, IMR 2005</title>
		<meeting>. of the 14th International Meshing Roundtable, IMR 2005<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="485" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.71,110.86,232.15,7.17;10,40.74,120.34,190.74,7.17"  xml:id="b5">
	<analytic>
		<title level="a" type="main">A polyhedron representation for computer vision</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">B</forename>
				<surname>Baumgardt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of AFIPS National Conference</title>
		<meeting>. of AFIPS National Conference</meeting>
		<imprint>
			<date type="published" when="1975" />
			<biblScope unit="page" from="589" to="596" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.73,129.70,232.23,7.17;10,40.74,139.18,231.98,7.17;10,40.74,148.66,29.83,7.17"  xml:id="b6">
	<analytic>
		<title level="a" type="main">GPUbased tiled ray casting using depth peeling</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">F</forename>
				<surname>Bernardon</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">A</forename>
				<surname>Pagot</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L D</forename>
				<surname>Comba</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graphics Tools</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,158.14,231.76,7.17;10,40.74,167.62,231.80,7.17;10,40.74,177.10,17.83,7.17"  xml:id="b7">
	<monogr>
		<title level="m" type="main">Multiresolution volume visualization with a texture-based octree. The Visual Computer</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Boada</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Navazo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Scopigno</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="185" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.74,186.58,232.15,7.17;10,40.74,196.06,232.15,7.17;10,40.74,205.42,132.05,7.17"  xml:id="b8">
	<analytic>
		<title level="a" type="main">Generic implementation of a data structure for 3d regular complexes</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bru</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Teillaud</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Abstracts of 24th European Workshop on Computational Geometry</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="95" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.74,214.90,232.17,7.17;10,40.74,224.37,231.80,7.17;10,40.74,233.85,17.83,7.17"  xml:id="b9">
	<analytic>
		<title level="a" type="main">Progressive volume rendering of large unstructured grids</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">P</forename>
				<surname>Callahan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Bavoil</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Pascucci</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1307" to="1314" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,243.33,231.71,7.17;10,40.74,252.81,232.12,7.17;10,40.74,262.29,183.79,7.17"  xml:id="b10">
	<analytic>
		<title level="a" type="main">Interactive rendering of large unstructured grids using dynamic level-of-detail</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">P</forename>
				<surname>Callahan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L D</forename>
				<surname>Comba</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Shirley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization 2005</title>
		<meeting>. of IEEE Visualization 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="199" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.71,271.77,231.92,7.17;10,40.74,281.13,232.27,7.17;10,40.74,290.61,93.55,7.17"  xml:id="b11">
	<analytic>
		<title level="a" type="main">Hardwareassisted visibility sorting for unstructured volume rendering</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">P</forename>
				<surname>Callahan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Ikits</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L D</forename>
				<surname>Comba</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="285" to="295" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.71,300.09,232.20,7.17;10,40.74,309.57,232.14,7.17;10,40.74,319.05,231.94,7.17;10,40.74,328.53,129.30,7.17"  xml:id="b12">
	<analytic>
		<title level="a" type="main">A scalable, hybrid scheme for volume rendering massive data sets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Childs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Duchaineau</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K.-L</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Eurographics Symposium on Parallel Graphics and Visualization</title>
		<editor>B. Raffin, A. Heirich, and L. P. Santos</editor>
		<meeting>. of Eurographics Symposium on Parallel Graphics and Visualization</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="153" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.71,338.01,231.78,7.17;10,40.74,347.49,232.27,7.17;10,40.74,356.85,69.93,7.17"  xml:id="b13">
	<analytic>
		<title level="a" type="main">High-quality hardware-based ray-casting volume rendering using partial pre-integration</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Espinha</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">C</forename>
				<surname>Filho</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIBGRAPI</title>
		<meeting>. of SIBGRAPI</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="273" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.69,366.33,221.89,7.17"  xml:id="b14">
	<monogr>
		<title level="m" type="main">Interactive order-independent transparency</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Everitt</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2001-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,375.81,232.08,7.17;10,40.74,385.29,61.27,7.17"  xml:id="b15">
	<analytic>
		<title level="a" type="main">Mean value coordinates</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Floater</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="19" to="27" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,394.77,232.14,7.17;10,40.74,404.25,74.11,7.17"  xml:id="b16">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">P</forename>
				<surname>Garrity</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.75,413.73,232.08,7.17;10,40.74,423.09,232.11,7.17;10,40.74,432.57,151.26,7.17"  xml:id="b17">
	<analytic>
		<title level="a" type="main">Interactive simd ray tracing for large deformable tetrahedral meshes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Gross</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hagen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F.-J</forename>
				<surname>Pfreund</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposion on Interactive Ray Tracing</title>
		<meeting>. of IEEE Symposion on Interactive Ray Tracing</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="147" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.71,442.05,231.81,7.17;10,40.74,451.53,232.08,7.17;10,40.74,461.01,125.82,7.17"  xml:id="b18">
	<analytic>
		<title level="a" type="main">Sot: compact representation for tetrahedral meshes</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Gurung</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Rossignac</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2009 SIAM/ACM Joint Conference on Geometric and Physical Modeling</title>
		<meeting>. of 2009 SIAM/ACM Joint Conference on Geometric and Physical Modeling</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.73,470.49,232.17,7.17;10,40.74,479.97,218.47,7.17"  xml:id="b19">
	<analytic>
		<title level="a" type="main">Visualization of vector fields using seed LIC and volume rendering</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Helgeland</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Andreassen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="673" to="682" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.69,489.45,232.04,7.17;10,40.74,498.81,227.58,7.17"  xml:id="b20">
	<analytic>
		<title level="a" type="main">Mean value coordinates for closed triangular meshes</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ju</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Schaefer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Warren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGGRAPH 2005</title>
		<meeting>. of SIGGRAPH 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="561" to="566" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,508.29,232.19,7.17;10,40.74,517.77,211.50,7.17"  xml:id="b21">
	<analytic>
		<title level="a" type="main">Designing a data structure for polyhedral surfaces</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Kettner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Symposium on Computational Geometry</title>
		<meeting>. of Symposium on Computational Geometry</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="146" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,527.25,232.31,7.17;10,40.74,536.72,133.26,7.17"  xml:id="b22">
	<analytic>
		<title level="a" type="main">Cell-projection of cyclic meshes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kraus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>. of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="215" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,546.20,231.95,7.17;10,40.74,555.68,231.93,7.17;10,40.74,565.16,49.76,7.17"  xml:id="b23">
	<analytic>
		<title level="a" type="main">CHF: A scalable topological data structure for tetrahedral meshes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Lage</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Lewiner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Lopes</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Velho</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIBGRAPI</title>
		<meeting>. of SIBGRAPI</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="349" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.71,574.52,232.14,7.17;10,40.74,584.00,231.97,7.17;10,40.74,593.48,98.82,7.17"  xml:id="b24">
	<analytic>
		<title level="a" type="main">Multiresolution techniques for interactive texture-based volume visualization</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Lamar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Hamann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">I</forename>
				<surname>Joy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization &apos;99</title>
		<meeting>. of IEEE Visualization &apos;99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="355" to="361" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,602.96,232.13,7.17;10,40.74,612.46,231.96,7.17;10,40.74,621.94,188.46,7.17"  xml:id="b25">
	<analytic>
		<title level="a" type="main">Visual Analysis and Exploration of Fluid Flow in a Cooling Jacket</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">S</forename>
				<surname>Laramee</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Garth</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Doleisch</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schneider</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hauser</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hagen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization 2005</title>
		<meeting>. of IEEE Visualization 2005</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="623" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.72,631.42,232.16,7.17;10,40.74,640.90,232.15,7.17;10,40.74,650.26,160.74,7.17"  xml:id="b26">
	<analytic>
		<title level="a" type="main">Circular incident edge lists: a data structure for rendering complex unstructured grids</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Lévy</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Caumon</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Conreaux</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Cavin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization</title>
		<meeting>. of IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="191" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.73,659.74,231.92,7.17;10,40.74,669.22,232.22,7.17;10,40.74,678.70,226.98,7.17"  xml:id="b27">
	<analytic>
		<title level="a" type="main">GPU-assisted positive mean value coordinates for mesh deformations</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Lipman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Kopf</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Cohen-Or</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Levin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Fifth Eurographics Symposium on Geometry Processing</title>
		<meeting>. of the Fifth Eurographics Symposium on Geometry essing</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="117" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,688.18,231.99,7.17;10,40.74,697.66,210.91,7.17"  xml:id="b28">
	<analytic>
		<title level="a" type="main">Interactive Volume Rendering with Ray Tracing</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marmitt</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Friedrich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Slusallek</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics State of the Art Reports</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,40.70,707.14,232.10,7.17;10,40.74,716.50,232.15,7.17;10,40.74,725.98,232.34,7.17;10,40.74,735.46,211.74,7.17;10,285.06,54.10,250.45,7.17;10,303.42,63.46,231.96,7.17;10,303.42,72.94,100.38,7.17"  xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast ray traversal of tetrahedral and hexahedral meshes for direct volume rendering Volume rendering for curvilinear and unstructured grids</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marmitt</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Slusallek Max</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Williams</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Cook</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization Proc. of Computer Graphics International</title>
		<editor>B. S. Santos, T. Ertl, and K. Joy</editor>
		<meeting>. of the 8th Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization . of Computer Graphics International</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="235" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,82.42,232.04,7.17;10,303.42,91.90,231.78,7.17"  xml:id="b30">
	<monogr>
		<title level="m" type="main">Memory Efficient GPU-Based Ray Casting for Unstructured Volume Rendering</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Maximo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Ribeiro</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bentes</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Oliveira</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Farias</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.42,101.38,164.70,7.17"  xml:id="b31">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">Proc. of Volume Graphics</title>
		<meeting>. of Volume Graphics</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.39,110.86,232.02,7.17;10,303.42,120.33,231.87,7.17;10,303.42,129.69,37.75,7.17"  xml:id="b32">
	<analytic>
		<title level="a" type="main">Scalable hybrid unstructured and structured grid raycasting</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Muigg</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hadwiger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Doleisch</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hauser</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1592" to="1599" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.39,139.17,231.93,7.17;10,303.42,148.65,231.87,7.17;10,303.42,158.13,33.67,7.17"  xml:id="b33">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for volume visualization</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Parker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Parker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Livnat</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P.-P</forename>
				<surname>Sloan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Hansen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Shirley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="238" to="250" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.45,167.61,231.79,7.17;10,303.42,177.09,231.76,7.17;10,303.42,186.57,113.46,7.17"  xml:id="b34">
	<analytic>
		<title level="a" type="main">Convexification of unstructured grids</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Röttger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Guthe</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Schieber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Workshop on Vision, Modeling and Visualization</title>
		<meeting>. of Workshop on Vision, Modeling and Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="283" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,196.05,232.12,7.17;10,303.42,205.41,232.02,7.17;10,303.42,214.89,95.34,7.17"  xml:id="b35">
	<analytic>
		<title level="a" type="main">An image-based modelling approach to gpu-based rendering of unstructured grids</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Shareef</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T.-Y</forename>
				<surname>Lee</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H.-W</forename>
				<surname>Shen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Mueller</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Volume Graphics</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,224.37,231.88,7.17;10,303.42,233.85,189.67,7.17"  xml:id="b36">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Shirley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Tuchman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.37,243.33,231.61,7.17;10,303.42,252.81,232.03,7.17;10,303.42,262.29,106.38,7.17"  xml:id="b37">
	<analytic>
		<title level="a" type="main">An exact interactive time visibility ordering algorithm for polyhedral cell complexes</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">S B</forename>
				<surname>Mitchell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">L</forename>
				<surname>Williams</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VolVis &apos;98</title>
		<meeting>. of VolVis &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="87" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.39,271.77,231.92,7.17;10,303.42,281.13,231.89,7.17;10,303.42,290.61,17.83,7.17;10,285.06,298.41,33.50,8.85;10,314.46,300.09,221.09,7.17;10,303.42,309.57,231.80,7.17;10,303.42,319.05,17.83,7.17"  xml:id="b38">
	<analytic>
		<title level="a" type="main">Sorting and hardware assisted rendering for volume visualization Interactive high-quality visualization of higher-order finite elements</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">M</forename>
				<surname>Stein</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">G</forename>
				<surname>Becker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">L</forename>
				<surname>Max</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">¨</forename>
				<surname>Uffinger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Frey</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VolVis &apos;94</title>
		<meeting>. of VolVis &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="83" to="89337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,328.53,232.06,7.17;10,303.42,338.01,232.12,7.17;10,303.42,347.49,231.95,7.07;10,303.42,356.85,82.26,7.17"  xml:id="b39">
	<analytic>
		<title level="a" type="main">iRun: Interactive rendering of large unstructured grids</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">T</forename>
				<surname>Vo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">P</forename>
				<surname>Callahan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Smith</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">T</forename>
				<surname>Silva</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Martin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Owen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Weinstein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Eurographics Symposium on Parallel Graphics and Visualization</title>
		<meeting>. of Eurographics Symposium on Parallel Graphics and Visualization</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="93" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,366.33,231.86,7.17;10,303.42,375.81,231.79,7.17;10,303.42,385.29,71.83,7.17"  xml:id="b40">
	<analytic>
		<title level="a" type="main">Edge-Based Data Structures for Solid Modeling in Curved- Surface Environments</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Weiler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="40" />
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.45,394.77,231.85,7.17;10,303.42,404.25,231.98,7.17;10,303.42,413.73,33.68,7.17"  xml:id="b41">
	<analytic>
		<title level="a" type="main">Hardware-based ray casting for tetrahedral meshes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Weiler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kraus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Merz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Visualization 2003</title>
		<meeting>. of IEEE Visualization 2003</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="333" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.45,423.09,231.83,7.17;10,303.42,432.57,200.35,7.17"  xml:id="b42">
	<analytic>
		<title level="a" type="main">Hardware-based viewindependent cell projection</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Weiler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kraus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Merz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="163" to="175" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,442.04,231.77,7.18;10,303.42,451.54,175.97,7.17"  xml:id="b43">
	<analytic>
		<title level="a" type="main">Texture-encoded tetrahedral strips</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Weiler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">N</forename>
				<surname>Mallón</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kraus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VolVis</title>
		<meeting>. of VolVis</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.39,461.02,232.13,7.17;10,303.42,470.50,232.03,7.17;10,303.42,479.98,57.93,7.17"  xml:id="b44">
	<analytic>
		<title level="a" type="main">Level-of-detail volume rendering via 3D textures</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Weiler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Westermann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">D</forename>
				<surname>Hansen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zimmerman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ertl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VolVis</title>
		<meeting>. of VolVis</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.39,489.46,232.06,7.17;10,303.42,498.82,231.98,7.07;10,303.42,508.30,135.66,7.17"  xml:id="b45">
	<analytic>
		<title level="a" type="main">The rendering of unstructured grids revisited</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Westermann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization</title>
		<meeting>. of the 3rd Joint IEEE TCVG -EUROGRAPHICS Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,517.78,232.07,7.17;10,303.42,527.26,95.83,7.17"  xml:id="b46">
	<analytic>
		<title level="a" type="main">Visibility-ordering meshed polyhedra</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">L</forename>
				<surname>Williams</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,303.38,536.74,232.01,7.17;10,303.42,546.22,193.75,7.17"  xml:id="b47">
	<analytic>
		<title level="a" type="main">Interactive point-based rendering of higherorder tetrahedral data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Zhou</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Garland</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TVCG</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1229" to="1236" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
