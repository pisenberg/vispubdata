<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Tetrahedral Mesh Compression with the Cut-Border Machine</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">WSI/GRIS University of Tübingen</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Guthe</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">WSI/GRIS University of Tübingen</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Straßer</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">WSI/GRIS University of Tübingen</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Tetrahedral Mesh Compression with the Cut-Border Machine</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-object representations I.3.6 [Computer Graphics]: Methodology and Techniques-Graphics data structures and data types E.4 [E.4 Coding and Information Theory]: Data compaction and compression compression algorithms</term>
					<term>solid modeling</term>
					<term>scientific visualization</term>
					<term>volume rendering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In recent years, substantial progress has been achieved in the area of volume visualization on irregular grids, which is mainly based on tetrahedral meshes. Even moderately fine tetrahedral meshes consume several mega-bytes of storage. For archivation and transmission compression algorithms are essential. In scientific applications lossless compression schemes are of primary interest. This paper introduces a new lossless compression scheme for the connectivity of tetrahedral meshes. Our technique can handle all tetrahedral meshes in three dimensional euclidean space even with non manifold border. We present compression and decompression algorithms which consume for reasonable meshes linear time in the number of tetrahedra. The connectivity is compressed to less than 2.4 bits per tetrahedron for all measured meshes. Thus a tetrahedral mesh can almost be reduced to the vertex coordinates, which consume in a common representation about one quarter of the total storage space. We complete our work with solutions for the compression of vertex coordinates and additional attributes, which might be attached to the mesh.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Tetrahedral meshes have been around in finite element simulations on volumetric domains for a long time. With the growing need of visualizing simulation data, tetrahedral meshes established themselves also in volume visualization. There are several beautiful properties of tetrahedral meshes which make them the natural choice for volume data representation. The flexibility of a tetrahedral mesh is ideally suited for irregular samplings and multiresolution analysis. The convex nature of a single tetrahedron allows for a simple visibility sorting algorithm <ref type="bibr" target="#b11">[12]</ref>, which is essential in volume visualization.</p><p>In most application areas of tetrahedral meshes some data is attached to the mesh elements. The data can be attached to the vertices, edges, the faces, the border faces or the tetrahedra. A density might be attached to the vertices, the intensity of a flow to the edges or material identifiers to the tetrahedra. The tetrahedral mesh serves several different purposes. It can be used to store nearest neighbors, to subdivide a volume into convex primitives or to sample and, by £ Email: gumhold@uni-tuebingen.de using the barycentric coordinates, to parameterize the domain of a function. The function can be scalar, a vector field or even a tensor field as for example the stress tensor of an inhomogeneous material. Our compression algorithm can be extended in a natural way to support compression of all three types of data functions defined on all different types of mesh elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Basic Definitions and Notations</head><p>We deal with tetrahedral meshes in the three dimensional Euclidean space given by a set of tetrahedra such that any two tetrahedra either are disjunctive or share a face, an edge or a vertex. We denote the number of vertices, edges, faces, border faces and tetrahedra with Ú, , , and Ø respectively.</p><p>We will denote the total amount of bits consumed by a tetrahedral mesh with Ë, where we use a right subscript to express a special representation type. Ë std denotes for example the standard representation with a list of vertex coordinate triples, a list of vertex index quadruples representing the tetrahedra and additional lists for the attached data. We split the storage space Ë into the bits Ä consumed by the locations of the vertices, consumed by the connectivity and consumed by the data attached to the mesh elements. If no data is present only the geometry consisting of connectivity and vertex locations has to be encoded in bits. For reasonable representations we get:</p><formula xml:id="formula_0">Ë • • Ä</formula><p>The combined representation of two and more components of the tetrahedral mesh can be more efficient since better predictions might improve delta coding or just because the coding mechanism can combine some fractional bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Basic Equations and Approximations</head><p>The basic equation for a tetrahedral mesh as defined in the previous section is the Euler equation:</p><formula xml:id="formula_1">Ú • Ø<label>(1)</label></formula><p>where is the Euler characteristic of the mesh and in most cases negligibly small. If we count the tetrahedron-face instances once for each tetrahedron and once for each face we get a second equation including the number of border faces :</p><formula xml:id="formula_2">¾ Ø • ¾<label>(2)</label></formula><p>In the case of triangle meshes the corresponding equations are sufficient to determine the average face-order of a vertex and the number of triangles per vertex in a mesh with small Euler characteristic and few boundary edges, but not in the tetrahedral case as <ref type="figure" target="#fig_0">Figure  1</ref> illustrates. The tetrahedron-order of a vertex might vary between one as in <ref type="figure" target="#fig_0">Figure 1 a)</ref> and Ú for the mesh in b) <ref type="bibr" target="#b0">1</ref> . Thus for the number of tetrahedra in an arbitrary tetrahedral mesh we only know Ú Ø ¾ ª´Ú ¾ µ</p><p>1 The mesh is one of the delaunay tetrahedrizations of the shown set of points. None of the tetrahedral meshes of <ref type="figure" target="#fig_0">Figure 1</ref> are used to sample volumetric functions for volume visualization or finite element analysis. The tetrahedral meshes of interest normally have a limited edge-order of the vertices, a small border portion and low Euler characteristics of the mesh and of the border mesh, respectively. Therefore, we express the fraction between Ø and Ú in terms of the average number of edges around a vertex ÓÚ </p><formula xml:id="formula_4">Ø Ú ÓÚ ¾ ½ Ú Ú • • Ú<label>(4)</label></formula><p>To find a basic approximation for the relation between Ø and Ú in a typical tetrahedral mesh with small border portion and low Euler characteristics we are left with the estimation of ÓÚ for a regular tetrahedral mesh. Unfortunately, the Euclidean space can not be tetrahedralized with equilateral tetrahedra. But the fraction of over the steradian occupied by an equilateral tetrahedron yields <ref type="bibr" target="#b1">2</ref> with ½½ a good approximation of the average vertex edge-order.</p><p>The tetrahedralization of a cubic grid yields ÓÚ Ú ½ ½¾ for an ½ zoning <ref type="bibr" target="#b2">3</ref> and ÓÚ Ú ½ ½ for an ½ zoning. Considering this and the measured average edge-orders in <ref type="table" target="#tab_1">Table 1</ref>, we assume in the following an average vertex order of thirteen. For tetrahedral meshes with small Euler characteristic and border portion we get in agreement with <ref type="table" target="#tab_1">Table 1</ref> Ú Ø ½ ½ ½</p><p>Let us use this approximation to estimate the storage consumption of a tetrahedral mesh in the standard representation, where each vertex is given by three 32bit floating point coordinates and each tetrahedron by four vertex indices:</p><formula xml:id="formula_6">Ä std Ú std Ø ¡ ÐÓ ¾ Ú Ú ½¼ ¿ Ú (6)</formula><p>For a typically sized tetrahedral mesh with a hundred thousand vertices the connectivity consumes about four times more storage space than the vertex coordinates. Using our algorithm we can reduce the connectivity to about eleven bits per vertex (see <ref type="table" target="#tab_7">Table 3</ref>). This reduces the storage requirements to a quarter without loosing information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Entropy and Arithmetic Coding</head><p>Let ½ Ñ be an alphabet with Ñ different symbols and Ë ×½×¾ × Ò a sequence of Ò symbols × ¾ . Then we define the relative frequency of the symbol by</p><formula xml:id="formula_7">´Ëµ def × Ò (7)</formula><p>If besides the relative frequencies no further information about the sequence Ë is known, it can be shown that at least <ref type="bibr" target="#b7">(8)</ref> bits are needed to encode the sequence S. The quantity is called binary entropy. Arithmetic coding (see <ref type="bibr" target="#b12">[13]</ref> for an introduction) allows to encode a sequence with only slightly more bits than the binary entropy.</p><formula xml:id="formula_8">´Ëµ def ´Ò ½ Ñ µ def Ò ¡ ¾ ´ËµÐÓ ¾ ´Ëµ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>As shown in the previous section tetrahedral meshes consume disproportional storage space in comparison to the data functions they sample. There are two approaches to reduce the size of tetrahedral meshes. The first one is mesh simplification as described for tetrahedral meshes in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b6">7]</ref>. Most methods are based on the edge collapse operation introduced by Hoppe <ref type="bibr" target="#b3">[4]</ref> which is easily generalized from the triangular case. All these methods are lossy compression schemes.</p><p>In the area of lossless compression we only know of the Grow&amp;Fold method proposed by Szymczak <ref type="bibr" target="#b7">[8]</ref>. The compressed representation consists of a tetrahedra spanning tree and a folding string. The spanning tree is rooted at an arbitrary tetrahedron and grown by attaching all other tetrahedra to external triangles of the current spanning tree. For each added tetrahedron three bits encode whether further tetrahedra are attached to the three external triangles of this tetrahedron or not. The folding string contains for each external triangle of the spanning tree a 2-bit code defining one of the three edge or no edge. If an edge is specified, this external triangle is folded together with the triangle adjacent through the specified edge. As the spanning tree contains Ø tetrahedral and ¾Ø • ½ external faces the storage requirements so far are Ø • Ç´½µbits.</p><p>External triangles of the spanning tree without folding edge are either border triangles of the tetrahedral mesh or must be glued to a triangle which is not edge-adjacent. The glue operations consume over two bits but appear in reasonable meshes seldom enough such that the total storage space increases only slightly seven bits per tetrahedron. In section 6 we compare the storage space consumed by our compressed representation to the lower bound of seven bits per tetrahedron for the Grow&amp;Fold representation:</p><formula xml:id="formula_9">G&amp;F def Ø<label>(9)</label></formula><p>The limitation of the Grow&amp;Fold approach is that it cannot handle non manifold borders. Grow&amp;Fold combines ideas from the triangle mesh compression techniques "geometry compression through topological surgery" introduced by Taubin <ref type="bibr" target="#b8">[9]</ref> and "edgebreaker" proposed by Rossignac <ref type="bibr" target="#b5">[6]</ref>. Our compression scheme generalizes the cut-border machine proposed by Gumhold in <ref type="bibr" target="#b2">[3]</ref> which is similar to the edgebreaker approach. But the cut-border machine is much easier to generalize to the tetrahedral case as the edgebreaker. The ideas of the triangular cut-border machine are briefly repeated in section 3.1. Basically, the cut-border machine traverses the mesh in a region filling way, which is determined by the connectivity of the mesh, and encodes for each newly added triangle one operation, which describes how the triangle is formed upon the current border edge of the growing region.</p><p>Touma's <ref type="bibr" target="#b9">[10]</ref> triangle mesh connectivity compression scheme allows the encoding of regular triangle meshes with better space efficiency. This method is in a way similar to the cut-border machine. By encoding the vertex triangle-orders with a run-length encoding scheme half of the operations encoded by the cut-border machine can be saved. For regular triangle meshes the vertex triangle-orders can be encoded very space efficiently such that the compressed representation may only consume half the storage space of the cutborder representation. Touma also proposes a simple prediction for the vertex coordinates. The coordinates are estimated as the fourth vertex of a parallelogram which is formed from the triangle inside the growing region and adjacent to the current border edge of the growing region. The crease angle at this edge is estimated from the other crease angles at the interior triangle. Encoded is only the difference between the estimation and the actual location of the vertex. Section 4 on coordinate compression is mainly inspired by the work of Deering <ref type="bibr" target="#b1">[2]</ref> on delta encoding and the work of Touma <ref type="bibr" target="#b9">[10]</ref> on coordinate compression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Connectivity Compression</head><p>The connectivity compression is based on the generalization of the cut-border machine described in <ref type="bibr" target="#b2">[3]</ref>. Section 3.1 gives a short overview of the method. After that we generalize the ideas to the tetrahedral case in section 3.2 and describe the different cutborder operations (section 3.3) and the compressed representation (section 3.4). The best traversal strategy we found is proposed in section 3.5. In section 3.6 we introduce an improvement for the mesh border encoding which is also helpful for triangle mesh compression with the cut-border machine. In the triangular case the cut-border machine is very simple to implement and also extremely fast. The generalization to the tetrahedral case requires a more sophisticated data structure for non manifold triangle meshes as described in section 3.7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Triangle Connectivity Compression with the Cut-Border Machine</head><p>The cut-border machine compresses triangle meshes which consist of a list of vertices and a list of triangles, each triangle containing the three vertex indices and the indices of the three edge-adjacent triangles. If the latter adjacency information is not known it can be easily computed through hashing. The cut-border machine is based on a region growing traversal of the triangle mesh starting with an arbitrary triangle. The border of the growing region is called the cut-border. It divides the mesh into the inner and the outer part, which contain the already compressed and the remaining triangles respectively. Triangles are added to the inner part at a distinguished current cut-border edge which will be called the gate as proposed in <ref type="bibr" target="#b5">[6]</ref>. After each addition of a triangle the gate moves on to another cut-border edge, until all triangles of an edge-connected component of the triangle mesh have been compressed. This is done for each edge-connected component.</p><p>The compressed representation contains for each triangle a bit code of an operation identifier which tells how the triangle was formed upon the gate. There are three cases: the gate is an edge of the mesh border, the gate forms a triangle with a vertex on the cut-border or the triangle is formed with a new vertex. The different operations are called "border", "new vertex" and "connect". The "connect"-operations take one parameter which specifies the offset of the third vertex relative to the gate. The "connect"-operations with offset one and minus one are also called "connect forward" and "connect backward". All other "connect"-operations split the cut-border into two loops. As the triangle meshes describe two dimensional surfaces in three dimensional space, two cut-border loops can grow together again, actually once for each handle and each hole of the triangle mesh. The operation which unifies two loops is called "union" and takes two parameters, the index of the second loop and the offset of the third triangle vertex within this loop.</p><p>The cut-border data structure basically consists of a stack of doubly linked lists containing the vertices -or their indices -, which are adjacent to triangles of the inner and the outer part at the same time.</p><p>Data at the faces, edges or vertices such as their coordinates are included in the compressed representation each time a new meshelement is added to the cut-border -for example the vertex coordinates of vertex Ú are encoded after the "new vertex"-operation which introduces Ú into the cut-border.</p><p>The decompression algorithm builds the mesh in the same order as the compression algorithm traverses the original mesh. With the help of the indices attached to the "connect"-operations the original connectivity can be reconstructed with permuted vertices and triangles. During decompression the edge-adjacency information can be reconstructed with no additional cost.</p><p>The success of the method results from the high frequency of the "new vertex"-and the "connect forward"-operations. Together they constitute in most meshes over ± of all operations. The high frequency of the "connect forward"-operation and the low frequency of "connect"-operations with large offsets depends in a high degree on the traversal order, which is determined by the choice of the gate after each operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">From Triangle Connectivity to Tetrahedral Connectivity Compression</head><p>As in the triangular case the uncompressed tetrahedral mesh is stored as a list of vertices and a list of tetrahedra, each tetrahedron containing the indices of the incident vertices and the face adjacent tetrahedra.</p><p>The inner and the outer part consist of a set of tetrahedra. The cut-border is the triangular surface between the inner and the outer part and the gate is a triangle of the cut-border. For each faceconnected component of the mesh the traversal begins with an arbitrary tetrahedron and successively adds face-adjacent tetrahedra at the gate to the inner part. The different cut-border operations are described in the next section. The cut-border may become the surface of an arbitrary face-connected tetrahedral mesh and therefore contain non manifold vertices and edges. In section 3.7 we describe an appropriate data structure. We assume that the tetrahedral mesh is embedded in three dimensional space and that the tetrahedra do not penetrate each other.</p><p>As in the triangular case the traversal order highly influences the distribution of the "connect"-operations with different offsets. Section 3.5 describes the best heuristic we could find.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Cut-Border Operations and Situations</head><p>There are three possibilities for the fourth vertex of a newly added tetrahedron at the gate: the gate is a border triangle of the tetrahedral mesh, the gate forms a tetrahedron with a new vertex or the gate is connected through a tetrahedron to another cut-border vertex. The corresponding cut-border operations will again be called "border", "new vertex" and "connect" and are abbreviated with the symbols ¡ £ and ½ .</p><p>Although only three different types of cut-border operations exist, we distinguish ten different situations which describe the surrounding of the cut-border around the gate for the different cutborder operations. All the situations are illustrated in figures 4 and 5. <ref type="figure">Figure 4</ref> shows the situations which do not introduce non manifold vertices or edges. For the "border"-and the "new vertex"operation only one situation exists which is depicted in figure 4 c) and b), respectively. The "connect" operation comes along with a whole variety of situations. The most frequent of these is the "flip" operation shown in figure 4 a). Here the newly added tetrahedron connects the gate to an adjacent triangle of the cut-border. The common edge of these two cut-border triangles is kind of flipped if the two former cut-border triangles are replaced by the two new cut-border triangles introduced by the new tetrahedron. The "top" and the "close" operations are very similar to the "flip" operation. The only difference is that not only two faces of the newly added tetrahedron are part of the cut-border but three of them in the case of the "top" operation or even all in the case of the "close" operation. The "close"-operation eliminates or closes an edge-connected component of the cut-border triangle mesh. The "close"-situation cannot be seen from the outside of the cut-border. Therefore, in figure 4 e) the cut-border is rendered with transparent triangles. In the front long edges of outer triangles are visible.</p><p>As mentioned earlier, the cut-border can be a non manifold triangle mesh. <ref type="figure" target="#fig_4">Figure 5</ref> portrays all types of situations which introduce a non manifold vertex or edge. In figure 5 a) the non manifold counterpart of the "flip" situation is shown. Here the free edge of the "flip" situation is touched by the cut-border and therefore already belongs to the cut-border. The touched edge becomes non manifold after application of the "connect" operation. The "join" situation in figure 5 b) is the non manifold counterpart of the "new vertex" operation. The fourth vertex of the newly added tetrahedron is part of a region of the cut-border triangle mesh which is further apart from the gate. This vertex becomes non manifold. Finally, in the "join" situations depicted in figures 5 c), d) and e) not only the fourth vertex of the newly added tetrahedron belongs to the cut-border but also one two or all three free edges of the "join" situation. Thus one, two or three non manifold edges are introduced.</p><p>The situations depicted in figures 4 and 5 constitute all possible situations, which can be easily verified by considering a newly added tetrahedron: the three triangles of the tetrahedron which are unequal to the gate may all be part of the cut-border or not be part. The same holds true for the fourth vertex and the three edges not incident to the gate. All of these seven mesh elements might be present in the cut-border or not. The presence of one of the three triangles implies the presence of the fourth vertex and the two incident edges. If we take such implications into account each possible assignment of presence to the three triangles, three edges and the fourth vertex yields exactly one of the discussed situations. Thus each face-connected component of the tetrahedral mesh can be compressed without any vertex repetitions. Only if two components of the tetrahedral mesh are exclusively connected through edge-adjacency and vertex-adjacency the involved non manifold vertices are repeated. In a simple way the "border"-operation allows for the encoding of all possible border surfaces of tetrahedral meshes including non manifold borders.</p><p>The "connect" operation takes one index as parameter, which specifies the fourth vertex in the cut-border. The fourth vertex is with high probability near to the gate. We can exploit this fact for a more efficient encoding by mapping near fourth vertices to small connect indices. This is achieved by a breadth-first traversal through the triangles of the cut-border starting at the gate as shown in the illustration of algorithm 1. The enumeration is not uniquely defined before one edge of the gate is specified at which the enumeration with the zero connect index will begin. This edge will be called the zero edge and is specified by the traversal strategy (see section 3.5). Algorithm 1 gives pseudo code for the vertex enumeration. The algorithm is similar to the cut-border traversal in the case of a triangle mesh. In a fifo these edges of the cut-border are stored which are adjacent both to a visited triangle and to a not visited triangle at the same time. The zero edge is firstly placed into the fifo.</p><p>Triangles are visited by extracting the next edge from the fifo and addressing the adjacent triangle which has not been visited yet. If the third vertex of the newly visited triangle is reached the first time, the next available connect index is assigned to it. In this way the vertices obtain the indices illustrated in the figure of algorithm 1.</p><p>The "flip" situation can arise for the operations ½¼ ½½ and ½¾, the "top" situation for ½¼ and ½½ and "close" only for ½¼.</p><p>The different "join" situations correspond to "connect" operations with larger index and are less frequent. The traversal strategy described in section 3.5 optimizes the choice of the zero edge in a way that most "flip" and "top" situations are encoded with ½¼.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Compressed Representation</head><p>In the triangular case the "new vertex"-operation £ is performed in about half the cases and is most frequent. In the tetrahedral case the relative frequency of £ is only about ½ , whereas the connect operations with small index are most frequent. For optimal encoding of the operation symbols we use arithmetic coding since the relative frequencies are unequal to ¾ and therefore Huffman-coding is not appropriate.</p><p>The connectivity of the tetrahedral mesh is given by the sequence of cut-border operations. As each operation adds one tetrahedron or specifies one border face, Ø • operations are encoded. The binary entropy defined in equation 8 gives a good lower bound CB def ´Ò ¡ £ ½ ¼ ½ ½ µ adapt CB <ref type="bibr" target="#b9">(10)</ref> for the storage space adapt CB consumed by our arithmetic coder with adaptive relative frequencies, which are initialized to the average values given in the last row of <ref type="table" target="#tab_6">Table 2</ref>. <ref type="table" target="#tab_7">Table 3</ref> shows that our arithmetic coder almost achieves the optimum.</p><p>The vertex coordinates and the data at the vertices, edges, faces and tetrahedra are incorporated in the arithmetic coding stream with separate coding models. Each time a cut-border operation produces a new mesh element, the corresponding data is added to the stream. The representation of a 1:6 zoning of a cube with vertex data Ú¼ Ú ½ Ú and tetrahedral data Ø¼ Ø ½ Ø might look as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ø¼Ü¼Ý¼Þ¼Ú¼Ü½Ý½Þ½Ú½Ü¾Ý¾Þ¾Ú¾Ü¿Ý¿Þ¿Ú¿¡¡ £Ø½Ü Ý Þ Ú ¡ £ Ø¾Ü Ý Þ Ú ¡ £Ø¿Ü Ý Þ Ú ½¼Ø ¡¡ £ Ø Ü Ý Þ Ú ¡¡¡¡¡¡</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Traversal Order</head><p>The traversal strategy chooses after each cut-border operation the next gate and zero edge. The aim is to favorite a small number of different kinds of operations. To avoid most connect operations with large indices it turned out that a good strategy is to stay at one cut-border vertex until all adjacent tetrahedra have been visited. The cut-border vertices are processed in a fifo order. For the choice of the zero edge and the order in which the triangles around a cut-border vertex are added, we tried two heuristics that favorite the ½¼-operation. The first one cycles around edges and tries to close up with a ½¼-operation by setting the zero edge of the gate to the edge around which the cut-border machine cycles. The second strategy defines the zero edge of each cut-border triangle at the time when the triangle is created. The zero edge is set to the edge which is shared by the gate and the new triangle. In case of a new vertex operation it is obvious that with this choice the zero edge is the edge with the smallest angle in the outer part. This still holds true to some extent for the other operations. The first heuristic increased the frequency of the ½¼-operation to ± and the second heuristic even to ¼±. Thus we chose the second strategy, which is documented in <ref type="table" target="#tab_6">Table 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Mesh-Border Encoding</head><p>In order to allow for a non manifold mesh border, we explicitly encode the border operations. The border symbol can be avoided when an edge-adjacent triangle of the gate has already been encoded as border triangle. In this case the corresponding connect symbol can be used. This optimization helped to decrease the additional amount of storage for the mesh border to one bit per border triangle as tabulated in <ref type="table" target="#tab_7">Table 3</ref>. The same optimization improves the border encoding in the triangular case of the cut-border machine. Data structure 1 shows the cut-border data structure. Three relations between the cut-border vertices and the cut-border triangles are stored: for each triangle the three incident vertices and three edge-adjacent triangles; for each vertex all incident triangles. The latter relation is stored in a set data structure which allows insertion and elimination of elements and the intersection of two sets. This relation allows for the handling of non manifold vertices and edges. For each cut-border triangle the incident tetrahedron of the inner part is stored in order to find the new tetrahedron if the triangle becomes the gate. The meshBorder-flag tells us when the cut-border triangle has already been encoded as border triangle of the mesh and therefore does not have to be visited again. With the help of this flag the optimized border encoding is realized. As the traversal order introduced in section 3.5 defines the zero edge for each triangle at creation time, an index between zero and two is stored for each cut-border triangle defining the zero edge. The cutborder vertices are organized in a fifo as demanded by the traversal strategy chosen in section 3.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Cut-Border Data Structure</head><p>We generate for each vertex of the tetrahedral mesh a field which stores the index of the cut-border vertex and initialize it before compression to minus one. In this way we can not only map a tetrahedral mesh vertex index to a cut-border vertex index but do also know which of the tetrahedral mesh vertices are part of the cut-border. Let us describe why it is sufficient to keep for each triangle only three edge-adjacent neighbors even at non manifold edges. At any time the cut-border describes the surface of a tetrahedral mesh. Thus the faces around a non manifold edge divide the space into regions alternately belonging to the inner and the outer part. These regions around a non manifold edge are called inner/outer regions. The faces bounding the same outer region can be set to be edge-adjacent as illustrated in <ref type="figure" target="#fig_1">Figure 2</ref>. This definition correctly reflects the proximity needed in enumerating the vertices relative to the gate. Faces of different outer regions can not be connected through a tetrahedron without intersecting an inner region.</p><p>Finally, we describe the updates of the cut-border data structure for the different situations depicted in figures 4 and 5. During the "connect" operation of a manifold "flip" situation (see <ref type="figure">figure 4 a)</ref>) the two present triangles in the cut-border are replaced with two new ones where the common edge is flipped. The vertices and faceadjacent triangles of the two new triangles can be easily determined from the old triangles. For each new triangle the zero edge is set to the edge, which is incident to the gate. The innerTetra index of the newly added triangles is set to the newly added tetrahedron, as in all other situations of all operations. Finally, the old triangles are removed from the triangle sets of the vertices and the new triangles are added.</p><p>The first step during the update of the "new vertex" operation is to create a new cut-border vertex for the fourth vertex of the newly added tetrahedron and store its vertex index of the tetrahedral mesh in the corresponding field. Conversely, the index of the new cutborder vertex is stored within the corresponding field of the tetrahedral mesh vertex. Next the gate triangle is removed and three new triangles are inserted. Again their zero edges are set to the edges incident to the gate. The "border" operation just sets the border flag of the gate triangle. For the border optimization the border flags of the three edge-adjacent cut-border triangles are checked and if one of them is set, the operation is encoded with the corresponding "connect" operation. The "top" situation is similar to the "flip" situation except that three triangles are removed and only one is added. As last manifold situation the "close" operation eliminates all involved triangles and these vertices for which the set of adjacent triangles becomes empty. If a cut-border vertex is removed the index stored with the corresponding tetrahedral mesh vertex is set to minus one again.</p><p>In order to distinguish between manifold and non manifold situations we have to clear up how to decide whether an edge of the newly added tetrahedron belongs to the cut-border or not. The question is trivially answered positively if an incident triangle of the newly added tetrahedron already belongs to the cut-border. Otherwise the answer can be determined by intersecting the set of adjacent triangles of the incident vertices of the edge in question. If the intersection is empty no cut-border triangle contains the edge and therefore the edge cannot belong to the cut-border. The intersection test must be performed for all edges of the non manifold situations in figure 5 which are not incident to a cut-border triangle. In case of the "nm flip" situation this is one edge and in case of the four "join" situations these are three edges. Only if the non manifold edges are detected, the face-adjacencies can be updated according to figure 2. And this is the only difference in the update process between the "nm flip" and "flip" situations and between the four different "join" situations and the "new vertex" operation.</p><p>The "nm flip" operation is distinguished from the "flip" situation by checking if the edge connecting the two newly added triangles belongs to the cut-border or not. This check can be done after the update performed for the "flip" situation, such that the face-adjacencies of the two new triangles can be corrected if necessary. This is only possible if we assume that the vertex coordinates are known and given in three dimensional space. For more general tetrahedral meshes the neighbors of the newly added triangles must be explicitly encoded. This can be done with few bits and as the non manifold situations are much less frequent as the manifold situations, the total storage space won't increase significantly for typical meshes.</p><p>The family of "join" situations is detected whenever the three triangles of the newly added tetrahedron, which are not equal to the gate, are not part of the cut-border but the fourth vertex is part of the cut-border. The latter condition is checked with the help of the cut-border index field attached to the tetrahedral mesh vertices. The update of the "join" situations is the same as in the case of the "new vertex" operation accept that the three newly added triangles must also be inserted to the triangle set of the fourth vertex. Finally, the three potential non manifold edges are checked for their presence in the cut-border and the face-adjacencies of the corresponding triangles are corrected if necessary as in the case of the "nm flip" situation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Coordinate Compression</head><p>In a first step we quantize each vertex coordinate to 16 bits according to the diagonal of the bounding box of all vertices. Thus the compression is lossy and for some applications not appropriate. All the meshes we received came in ASCII format with six to eight valid digits which is equivalent to 19-26 bits. We loose some information in the quantization step and the shape of small tetrahedra changed slightly, but no tetrahedron changed its orientation.</p><p>To encode the 16 bit coordinates arithmetically it turned out to be economical to split each coordinate into four packages of four bits. For each package we use a different set of adaptive frequencies for the arithmetic coder. This strategy dramatically reduced the storage space consumed by the arithmetic coder and increased the compression speed.</p><p>The next step in coordinate compression is delta coding. We encode the vertex coordinates during the compression of the connectivity. After each new vertex operation the difference vector from the center of the gate triangle to the new vertex is encoded. Thus we use the proximity information given by the tetrahedralization of the vertices. We can estimate the number of bits saved through delta coding with the following simple argument. Suppose the vertices are uniformly distributed. Then there are approximately ¿ Ô Ú vertices per coordinate axis and it should be possible to save ÐÓ ¾ ¿ Ô Ú bits per coordinate. Thus the storage space consumed per vertex can be estimated with ÐÓ ¾ Ú bits, which is about three bits above the actually achieved storage space.</p><p>A final improvement of two bits less storage space per vertex could be achieved by rotating the coordinate system such that the z-axis is the normal of the gate and the x-axis parallel to the zero edge. Quantization is done after changing to the new coordinate system. To avoid accumulation of rounding errors it is very important that during compression the center of the gate is computed with the same quantized coordinates which are available to the decompression algorithm. The change of the coordinate system saved two bits in the x-and y-axes. The final storage space consumed per vertex by the coordinates is tabulated in <ref type="table" target="#tab_7">Table 3</ref>   This encouraged us to predict the z-coordinate, which is the height of the new tetrahedron in the new vertex operation, from the height of the tetrahedron of the inner part which is adjacent to the gate. But the distribution of the z-coordinate frequencies was even smoothed out and the compression became worse. We also tried to predict the x-and y-coordinates from the interior adjacent tetrahedron but with a similar failure. All these tests were also performed on the more regular meshes of section 6 with no success. The prediction of the tetrahedron height, which is proportional to its volume, should help in meshes where the sampling density changes significantly. But we still have to conclude that tetrahedral meshes are too irregular to predict vertex coordinates much better than with the proximity information of the connectivity alone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Data Compression</head><p>The last section showed that tetrahedral meshes are not regular enough for a good prediction of vertex coordinates. Therefore, we propose to encode data given for the mesh elements in a different way. In this section we restrict ourselves to a scalar data function attached to the vertices. This data is transmitted with each new vertex operation after the vertex coordinates. We propose delta encoding for the data function after an appropriate quantization. This time we can additionally use the vertex coordinates to predict the function value at the new vertex.</p><p>Let us denote the scalar data function with and the location of the new vertex with ÚÒ. A linear approximation lin of the function is of the form</p><formula xml:id="formula_10">lin´ Úµ lin Ì ¡ Ú • lin´ ¼µ<label>(11)</label></formula><p>Thus the linear approximation must be known at four locations in order to determine the unknowns lin and lin´ ¼µ. In a new vertex operation the new tetrahedron is always adjacent to a tetrahedron of the inner part, where the function is already known. We can use the corner vertices of this tetrahedron Ú¼ Ú ½ Ú ¾ and Ú¿ and the corresponding values of the data function ´ Ú µ to determine the unknowns of the linear approximation.  <ref type="figure">Figure 6</ref> shows the six tetrahedral meshes which we used for our measurements. They differ in their sizes and their origin. The "Random" mesh was generated by delaunay tetrahedralization of a cloud of randomly distributed points. In order to show that the interior of this mesh is more complex than the surface, we blended a cut through the mesh with its surface. The "Proto" mesh is a quite regular tetrahedralization of an object with non trivial boundary. The "Bubble" is the output of a simplification algorithm applied to a spherical symmetric scalar function. Again the blending technique shows part of the interior. The "Torso" meshes are regularly tetrahedralized real world meshes and the "Blunt Fin" is a curvy linear grid.  <ref type="table" target="#tab_1">Table 1</ref>: Basic quantities of the measured meshes. <ref type="table" target="#tab_1">Table 1</ref> shows the basic quantities of the different meshes and average values which confirm equation 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Measurements &amp; Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The Tetrahedral Meshes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Measurements</head><p>In <ref type="table" target="#tab_6">Table 2</ref> the distribution of the cut-border symbols is analyzed.</p><p>The first column shows for each mesh the total number Ø • of encoded operations. In the following columns the relative frequencies of the different cut-border symbols are shown. ½¼ is with ¼± the most frequent operation, followed by £, ½½ and ½¾. With the border optimization described in section 3.6 the frequency of the border symbol became negligibly small. The last column shows the fraction of the non-manifold situations in <ref type="figure" target="#fig_4">Figure 5</ref> which arose during compression. This number is important for the optimal running time of the compression and decompression algorithms as the non-manifold operations consume more computing power. <ref type="table" target="#tab_7">Table 3</ref> illustrates different aspects of the consumed storage space and running time for the cut-border machine. The first column shows the storage space consumed by our arithmetic coder for the connectivity. The second and third columns tabulate the binary entropy of the cut-border operations in bits per vertex and bits per tetrahedra. Comparison of the first two columns shows that our arithmetic coder is near the optimum. The cut-border machine consumes on average about two bits per tetrahedron, even for the randomly generated mesh which forces more connect operations with a high index. CB,¡ is the binary entropy of the sequence of cut-border operations which were used to encode the border faces. The fourth column of <ref type="table" target="#tab_7">Table 3</ref> shows that the border could be encoded with about one bit per triangle. As the best triangle mesh compression methods consume also about one bit per triangle, the initializing of the cut-border machine with the border of the tetrahedral mesh would not improve our border encoding described in 3.6. The fifth column of <ref type="table" target="#tab_7">Table 3</ref> documents the compression speed in tetrahedra per second for connectivity alone. The decompression speed is approximately the same. The speed does not depend on the size but more on the frequency of non-manifold operations (compare the last column of <ref type="table" target="#tab_6">Table 2</ref>). The last but one column contains the storage space consumed by the vertex coordinates, if compressed with the technique described in section 4. Finally, the last column shows that the vertex compression doesn't decrease the compression speed significantly. <ref type="table" target="#tab_8">Table 4</ref> compares the cut-border machine to the standard representation and the Grow&amp;Fold compression of Szymczak <ref type="bibr" target="#b7">[8]</ref>. The results of the cut-border machine are convincing and improve the standard representation by a factor of 20 to 50 depending primarily on the size of the tetrahedral mesh but also on the regularity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We presented for the first time a lossless connectivity compression scheme for tetrahedral meshes which can handle non manifold borders. Our implementation of the cut-border machine showed that it achieves very high compression rates and is able to compress tetrahedral connectivity to about two bits per tetrahedron, which is between three and four times better than previously reported results. Lossy compression of vertex coordinates turned out to be not as efficient as in the triangular case but still valuable for most applications. Future work must concentrate on more sophisticated compression techniques for the vertex coordinates and further data attached to the tetrahedral mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgements</head><p>We like to thank Hans-Christian Hege for providing the "Torso"meshes, Paolo Cignoni for the "Bubble"-mesh and Claudio T.    for the "Proto"-mesh. This work was supported by the Deutsche Forschungsgemeinschaft (DFG) and is part of the project D1 within the Sonderforschungsbereich 382. a) "flip" b) "new vertex" c) "border" d) "top" e) "close" <ref type="figure">Figure 4</ref>: The different manifold cut-border situations. The gate is shown as green triangle and the newly added tetrahedron with green edges and blue transparent faces. a) "nm flip" b) "join" c) "join, 1 nm edge" d) "join, 2 nm edges" e) "join, 3 nm edges"  <ref type="figure">Figure 6</ref>: The measured tetrahedral meshes. The transparent meshes were rendered with projected tetrahedra. To the tetrahedra of the "Torso I"-mesh a material identifier is attached. The "Blunt Fin"-mesh was rendered with false colors.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>tetrahedral meshes with a) minimum and b) maximum vertex tetrahedron-order Ø Ú .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Edge-adjacency of cut-border triangles around non manifold edge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Distribution of coordinates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3</head><label>3</label><figDesc>shows the relative frequencies of the 16 different values of each 4 bit package in the case of the randomly generated mesh in section 6. The yellow bars represent the z-coordinate and the blue bars the x-and y-coordinates. The x-and y-coordinates were united as their distributions do not differ at all. The lower eight bits are distributed quite uniformly, whereas the higher four bits are nearly exclusively zero. The bits ½½ are especially interesting. The xand y-coordinates frequencies have a Gaussian fall off, whereas the z-coordinate frequencies increase to a maximum at the value 3 and then drop of much faster than the x-and y-frequencies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>The different types of non manifold cut-border situations. a) Random b) Proto c) Bubble d) Torso I e) Torso II f) Blunt Fin</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Algorithm 1</head><label>1</label><figDesc>Vertex Enumeration fifo.pushback(gate.zeroEdge()) fifo.pushback(gate.oneEdge()) fifo.pushback(gate.twoEdge()) while not fifo.empty do edge = fifo.popfront() tgl = edge.rightTriangle()</figDesc><table><row><cell>if not marked(tgl) then</cell></row><row><cell>mark(tgl)</cell></row><row><cell>vtx = tgl.oppositeVtx(edge)</cell></row><row><cell>if not marked(vtx) then</cell></row><row><cell>mark(vtx)</cell></row><row><cell>enumerate(vtx)</cell></row><row><cell>fifo.pushback(tgl.nextEdge(edge))</cell></row><row><cell>fifo.pushback(tgl.prevEdge(edge))</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>The linear system of equations is ´ Ú µ lin Ì ¡ Ú • lin´ ¼µ ¾ ¼ ½ ¾ ¿ If this linear system is solved and the values are plugged into equation 11 with Ú ÚÒ, we get as linear prediction at the location ÚÒThe matrix ¡Î can be inverted, iff the tetrahedron´ Ú¼ Ú ½ Ú ¾ Ú ¿ µ is not degenerated. Vector valued data functions can also be compressed with this method -coordinate by coordinate.</figDesc><table><row><cell>lin´ ÚÒµ ¡ def</cell><cell>¡ Ì ¡ ¡Î ½ ¡´ ÚÒ Ú¼µ • ´ Ú ¼ µ with ´ Ú½µ ´ Ú¼µ ´ Ú¾µ ´ Ú¼µ and ´ Ú¿µ ´ Ú¼µ ¼ ½</cell></row><row><cell>¡Î def</cell><cell>´ Ú½ Ú¼µ´ Ú¾ Ú¼µ´ Ú¿ Ú¼µ</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Blunt Fin ¾¼¼ ½¼ ¼ ¼¼¼ ¼ ¾¼ ¼ ¼ ¼ ¼ ¼ ¼ ¼ ¼¼¼ ¼ ¼¼¼</figDesc><table><row><cell></cell><cell>Silva</cell></row><row><cell>mesh Random Proto Bubble Torso I Torso II</cell><cell>Ø • ½¾ ½ ¼ ¼¼½ ¼ ½ ¼ ½ ¼ ½½ ¼ ½¼ ¼ ½¼½ ¼ ½½ ¡ £ ½ ¼ ½ ½ ½ ¾ ½ ¾ nm ½ ¼ ¼¼½ ¼ ½ ¼ ¿½ ¼ ¼ ¿ ¼ ¼ ¼ ¼ ¼ ¼ ¿ ¾ ¼ ¼¼½ ¼ ½ ¼ ¼ ½¼ ¼ ¼ ½ ¼ ¼ ¼ ½¼ ¼¾ ¼ ¼¼¾ ¼ ½ ¼ ¼ ¼ ¼ ¼ ¼ ¼ ¾ ¼ ¼ ¼ ¼ ¼ ¼¼½ ¼ ½ ¿ ¼ ¼¿ ¼ ¼ ¿ ¼ ¼ ¼ ¼ ¼ ¼</cell></row></table><note>average ¼ ¼¼½ ¼ ½ ¼ ¼¾ ¼ ¼ ¼ ¼ ¼ ¼ ¼ ¼ ¼</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 :</head><label>2</label><figDesc>Total number of encoded operations; relative frequencies of cut-border operations; relative frequency of non-manifold situations.</figDesc><table><row><cell>mesh Random Proto Bubble Torso I Torso II Blunt Fin average</cell><cell>adapt CB Ú ½ ½¾ ½ ¼¾ ¾ ¿ ½ ¿ CB Ú CB Ø CB,¡ ¾ ½¾ ¼ ¼ ¿ ¼¿ ¿¼ Ø sec ¡ Ä 16bit CB Ú ¿½ ¿ ¼ ¿ Ø sec ¾ ¡ ½¿ ¾ ½¿ ¿ ¾ ¿ ½ ½½ ¿¼ ¼ ½ ½½ ¼¾ ½¼ ¾ ¼ ½ ¾ ¾ ¼ ¿¼ ½ ½½ ½ ½½ ½ ¾ ¼ ½ ¾¼ ¾ ¾ ¼¼ ½ ¿½ ¼ ¾ ¿ ½½ ¼ ½½ ¼½ ¾ ¼ ½ ¼ ½¿½¿ ¿¼ ¾</cell><cell>¾ ¿ ½</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>Cut-border machine: consumed storage for connectivity, border and quantized vertex coordinates. Running time for connectivity alone and together with vertex coordinates in tetrahedra per second on a Pentium II 350MHz.</figDesc><table><row><cell></cell><cell>adapt</cell></row><row><cell>mesh Random Proto Bubble Torso I Torso II Blunt Fin</cell><cell>std adapt CB ½ ¿ ½ ½¾ CB Ú ¾¾ ½ ¾¾ ¾¾ ½¿ ¾ ¼ ½ G&amp;F Ú ¼¿ ¿½ ¾ ¾ ¾ ½½ ¼¾ ¿ ¾ ¾ ½½ ½ ¿ ¼½ ¼ ¼¼ ¿¾ ¼</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Comparison of the different approaches.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">We applied the Euler equation for spherical triangle meshes.<ref type="bibr" target="#b2">3</ref> Each cube is split into five tetrahedra.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multiresolution representation and visualization of volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Scopigno</surname></persName>
		</author>
		<idno>1077-2626</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="352" to="369" />
			<date type="published" when="1997-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Geometry compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 95 Conference Proceedings, Annual Conference Series</title>
		<editor>Robert Cook</editor>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="6" to="11" />
		</imprint>
	</monogr>
	<note>ACM SIGGRAPH</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Real time compression of triangle mesh connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Straßer</surname></persName>
		</author>
		<idno>0-89791-999-8</idno>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 98 Conference Proceedings, Annual Conference Series</title>
		<editor>Michael Cohen</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings, Annual Conference Series</title>
		<editor>Holly Rushmeier</editor>
		<meeting><address><addrLine>New Orleans, Louisiana</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="4" to="09" />
		</imprint>
	</monogr>
	<note>ACM SIGGRAPH</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Progressive simplicial complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jovan</forename><surname>Popović</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<idno>0- 89791-896-7</idno>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 97 Conference Proceedings, Annual Conference Series</title>
		<editor>Turner Whitted</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Edgebreaker: connectivity compression for triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<idno>GIT-GVU-98-35</idno>
		<imprint>
			<date type="published" when="1998-10" />
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Progressive tetrahedralizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><forename type="middle">H</forename><surname>Staadt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<publisher>August</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Grow&amp;Fold: compression of tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<idno>GIT-GVU-99-02</idno>
		<imprint>
			<date type="published" when="1999-02" />
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Geometric compression through topological surgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarek</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="115" />
			<date type="published" when="1998-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Triangle mesh compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Costa</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Conference on Graphics Interface (GI-98)</title>
		<meeting>the 24th Conference on Graphics Interface (GI-98)<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
	<note>Wayne Davis, Kellogg Booth, and Alain Fourier</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">DECIMATION OF TETRAHEDRAL GRIDS WITH ERROR CONTROL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vivek</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Vangelder</surname></persName>
		</author>
		<idno>UCSC-CRL-97-25</idno>
		<imprint>
			<date type="published" when="1998-06-23" />
			<pubPlace>Santa Cruz, Jack Baskin School of Engineering</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Visibility ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Arithmetic coding for data compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><forename type="middle">H</forename><surname>Witten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Radford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">G</forename><surname>Neal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cleary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="520" to="540" />
			<date type="published" when="1987-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multiresolution tetrahedral framework for visualizing regular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baoquan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualiza-tion97</title>
		<editor>Roni Yagel and Hans Hagen</editor>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997-11" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
