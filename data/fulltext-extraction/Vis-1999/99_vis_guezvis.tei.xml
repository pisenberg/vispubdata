<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Compression of Non-Manifold Polygonal Meshes £</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">André</forename><surname>Guéziec</surname></persName>
							<email>gueziec@multigen.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Bossen</surname></persName>
							<email>frank.bossen@epfl.ch</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Signal Processing Lab, EPFL</orgName>
								<address>
									<postCode>1015</postCode>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Taubin</surname></persName>
							<email>taubin@watson.ibm.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Silva</surname></persName>
							<email>csilva@research.att.com</email>
							<affiliation key="aff3">
								<orgName type="laboratory">AT&amp;T Labs-Research</orgName>
								<address>
									<addrLine>180 Park Ave, Florham Park</addrLine>
									<postBox>P.O. Box 971</postBox>
									<postCode>07932</postCode>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Ý Multigen Paradigm</orgName>
								<address>
									<addrLine>550 S. Winchester Bvd., Suite 500</addrLine>
									<settlement>San Jose</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Ü IBM T.J.Watson Research Center</orgName>
								<address>
									<postBox>P.O. Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Compression of Non-Manifold Polygonal Meshes £</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Polygonal Mesh</term>
					<term>Geometry Compression</term>
					<term>Non-Manifold</term>
					<term>Stitching</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: A: cutting a non-manifold mesh (two tetrahedra sharing a face). B: representing a non-manifold mesh as a manifold mesh together with a vertex clustering. C: Overall compressed syntax for a non-manifold mesh.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Three-dimensional polygonal meshes are used pervasively in manufacturing, architectural, Geographic Information Systems, warfare simulation, medical imaging, robotics, and entertainment industries. In particular, polygons (especially, triangles) are required for generating three-dimensional renderings using available graphics architecture.</p><p>The sizes of such meshes have been steadily increasing, and there is no indication that this trend will change. For instance, a polygonal model representing a Boeing 777 airplane contains on the order of 1 Billion polygons, excluding polygons associated with the rivet models. Geometry compression deals with the compression of polygonal meshes for transmission and storage.</p><p>Many real-world polygonal meshes are non-manifold, that is, contain topological singularities, (e.g., edges shared by more than two triangles) <ref type="bibr" target="#b0">1</ref> . In fact, on a database of 300 meshes used for MPEG-4 core experiments and obtained on the Web (notably at the www.ocnus.com site), we discovered that more than half of the meshes (157 exactly) were non-manifolds. As discussed in Section 2, most of the methods currently available for geometry compression require a manifold connectivity. Meshes can be converted, but then the original connectivity is lost, as discussed in our work <ref type="bibr" target="#b0">[1]</ref>. At the time this paper is written, we are aware of only two publications treating connectivity-preserving non-manifold mesh compression <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>.</p><p>In this paper we describe a method for compressing nonmanifold polygonal meshes and recovering their exact connectivity (and topology) after decompression. Our method compares in compression efficiency and speed with the most efficient manifoldmesh compression methods, thus extending <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b1">2]</ref>, and even allows some savings by avoiding duplicate encodings of vertex coordinates and properties. method works by converting the original mesh to a set of manifold meshes, encoding the manifold meshes using an existing mesh compression technique, and clustering, or stitching together during the decompression process the vertices that were duplicated earlier to faithfully recover the original connectivity (see <ref type="figure">Fig. 1</ref>-A,B). To convert a non-manifold to a manifold by cutting (as little as possible), we are using the method described in <ref type="bibr" target="#b0">[1]</ref> and briefly recalled in Section 3. However, there is significant flexibility in the strategies used for converting to manifold meshes and compressing them, and the present method does not require using specific ones. A vertex clustering <ref type="bibr" target="#b1">2</ref> is recorded during the conversion process, such that when applied to the manifold meshes, the original non-manifold mesh is recovered. Representation for Compression. The basic idea in this paper is to encode both the manifold meshes and vertex clustering as a substitute for the non-manifold mesh. While this idea is quite obvious, efficiently encoding and decoding a vertex clustering isn't, and will be the primary focus here. The mesh is compressed as indicated in <ref type="figure">Fig. 1</ref>-C. For each manifold connected component, the connectivity is encoded, followed with optional stitches, and geometry and properties. Stitches are used to recover the vertex clustering within the current component and between vertices of the current component and previous components. In this way, for each cluster, geometry and properties are only encoded and decoded for the vertex of the cluster that is encountered first (in decoder order of traversal).</p><p>As described in Section 5, the vertex clustering is decomposed in a series of variable-length stitches, that merge a given number of vertices along two directed paths of vertices. We propose to choose between a very simple and fast decomposition technique and a more advanced one. This latter decomposition presents several challenges that are described and overcome. The bit-stream syntax supports both possibilities, and it is not required that the encoder use the more advanced feature. In Sections 6 and 7, we give details on the encoding and decoding processes and describe a proposed bit-stream syntax for stitches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Connectivity-preserving non-manifold mesh compression algorithms were proposed by Popovic and Hoppe <ref type="bibr" target="#b1">[2]</ref> and Bajaj et al. <ref type="bibr" target="#b2">[3]</ref>. Hoppe's Progressive Meshes <ref type="bibr" target="#b7">[8]</ref> use a base mesh and a series of vertex insertions (specifically, inverted edge contractions) to represent a manifold mesh. While the main functionality is progressive transmission, the encoding is fairly compact, using 30 to 50 bits per vertex with arithmetic coding <ref type="bibr" target="#b7">[8]</ref>. Utilizing more general vertex insertion strategies, this method was extended in <ref type="bibr" target="#b1">[2]</ref> to represent arbitrary simplicial complexes, manifold or not, using about 50 bits per vertex (asymptotically the cost of this method is proportional to Ò ÐÓ Ò, Ò being the number of vertices). Our present method improves upon <ref type="bibr" target="#b1">[2]</ref> by achieving significantly smaller bit-rates (about 10 bits per vertex or so) and reducing encoding time (admittedly, an off-line process) by more than four orders of magnitude (without levels-of-detail).</p><p>Bajaj et al.'s "dag of ring" mesh compression approach <ref type="bibr" target="#b2">[3]</ref> partitions meshes in vertex and triangle layers that can represent a nonmanifold mesh. Since vector quantization is used for compressing the geometry as opposed to scalar quantization in the present work, a direct comparison of the results is difficult. One advantage of the approach in this paper is that stitches may be used for encoding changes of topology (such as aggregating components) in addition to representing singularities.</p><p>Deering <ref type="bibr" target="#b8">[9]</ref> introduced geometry compression methods, originally to alleviate 3D graphics rendering limitations due to a bottleneck in the transmission of information to the graphics hardware (in the bus). His method uses vertex and normal quantization, and exploits a mesh buffer to reuse a number of vertices recently visited and avoid resending them. Deering's work fostered research on 3D mesh compression for other applications. Chow <ref type="bibr" target="#b9">[10]</ref> extended <ref type="bibr" target="#b8">[9]</ref> with efficient generalized-triangle-strip building strategies.</p><p>The Topological Surgery single-resolution mesh compression method <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> represents a connected component of a manifold mesh as a tree of polygons (which are each temporarily decomposed into triangles during encoding and recovered after decoding). The tree is decomposed into runs, whose connectivity can be encoded at a very low cost. To recover the connectivity and topology, this tree is completed with a vertex tree, providing information to merge triangle edges. The method of <ref type="bibr" target="#b11">[12]</ref> also encodes the vertex coordinates (geometry) and all property bindings defined in VRML'97 <ref type="bibr" target="#b12">[13]</ref>.</p><p>Touma and Gotsman <ref type="bibr" target="#b3">[4]</ref> traverse a triangular (or polygonal) mesh and remove one triangle at a time, recording vertex valences <ref type="bibr" target="#b2">3</ref> as they go and recording triangles for which a boundary is split in two as a separate case.</p><p>Gumhold and Strasser <ref type="bibr" target="#b4">[5]</ref> and Rossignac <ref type="bibr" target="#b5">[6]</ref> concentrate on encoding the mesh connectivity. They use mesh traversal techniques <ref type="bibr" target="#b2">3</ref> Number of incident polygons. similar to <ref type="bibr" target="#b3">[4]</ref>, but instead of recording vertex valences, consider more cases depending on whether triangles adjacent to the triangle that is being removed have already been visited. Another relevant work for connectivity compression is by Denny and Sohler <ref type="bibr" target="#b13">[14]</ref>.</p><p>Li and Kuo <ref type="bibr" target="#b6">[7]</ref>'s "dual graph" approach traverses polygons of a mesh in a breadth-first fashion, and uses special codes to merge nearby (topologically close) polygons (serving the same purpose as the vertex graph in the approach of <ref type="bibr" target="#b11">[12]</ref>) and special commands to merge topologically distant polygons (to represent a general connectivity-not only a disk).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Cutting a Non-manifold Mesh to Produce Manifold Meshes</head><p>We briefly recall here the method of Guéziec et al.</p><p>[1] that we are using. For each edge of the polygonal mesh, it is determined whether the edge is singular (has three or more incident faces) or regular. Edges for which incident faces are inconsistently oriented are also considered to be singular for the purpose of this process. For each singular vertex of the polygonal mesh, the number of connected fans of polygons incident to it is determined <ref type="bibr" target="#b3">4</ref> . For each connected fan of polygons, a copy of the singular vertex is created (thereby duplicating singular vertices). The resulting mesh is a manifold mesh. The correspondences between the new set of vertices comprising the new vertex copies and the old set of vertices comprising the singular vertices is recorded in a vertex clustering array. This process is illustrated in <ref type="figure">Fig. 1</ref>. This method admits a number of variations that moderately alter the original mesh connectivity (without recovering it after decoding) in order to achieve a decreased size of the bit-stream: polygonal faces with repeated indices may be removed. Repeated faces (albeit with potentially different properties attached) may be removed. Finally, the number of singular edges may be reduced by first attempting to invert the orientation of some faces in order to reduce the number of edges whose two incident faces are inconsistently oriented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Compressing Manifold Meshes</head><p>The method described in this section extends the Topological Surgery method <ref type="bibr" target="#b11">[12]</ref>, and is explained in detail in <ref type="bibr" target="#b14">[15]</ref>. In <ref type="bibr" target="#b11">[12]</ref> the connectivity of the mesh is represented by a tree spanning the set of vertices, a simple polygon, and optionally a set of jump edges. To derive these data structures a vertex spanning tree is first contructed in the graph of the mesh and the mesh is cut through the edges of the tree. If the mesh has a simple topology, the result is a simple polygon. However if the mesh has boundaries or a higher genus, additional cuts along jump edges are needed to obtain the simple polygon. This simple polygon is then represented by a triangle spanning tree and a marching pattern that indicates how neighboring triangles are connected to each other. The connectivity is then encoded as a vertex tree, a simple polygon and jump edges. In this paper the approach is slightly different. First, a triangle spanning tree is constructed. Then the set of all edges that are not cut by the triangle tree are gathered into a graph. This graph, called Vertex Graph, spans the set of vertices, and may have cycles. Cycles are caused by boundaries or handles (for higher genus models). The vertex graph, triangle tree, and marching pattern are sufficient to represent the connectivity of the mesh.</p><p>In <ref type="bibr" target="#b11">[12]</ref> geometry and properties are coded differentially with respect to a prediction. This prediction is obtained by a linear com-bination of ancestors in the vertex tree. The weighting coefficients are chosen to globally minimize the residues, i.e. the difference between the prediction and the actual values. In this paper the principle of linear combination is preserved but the triangle tree is used instead of the vertex tree for determining the ancestors. Note that the "parallelogram prediction" <ref type="bibr" target="#b3">[4]</ref> 5 is a special case of this scheme, and is achieved through the appropriate selection of the weighting coefficients.</p><p>Coding efficency is further improved by the use of an efficient adaptive arithmetic coder <ref type="bibr" target="#b15">[16]</ref>. Arithmetic coding is applied to all data, namely connectivity, geometry and properties.</p><p>Finally the data is ordered so as to permit efficient decoding and on-the-fly rendering. The vertex graph and triangle tree are put first into the bit stream. The remaining data, i.e. marching pattern, geometry, and properties, is referred to as triangle data and is put next into the bit stream. It is organized on a per-triangle basis, following a depth-first traversal of the triangle tree. Therefore a new triangle may be rendered every time a few more bits, corresponding to the data attached to the triangle, are received.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Representing the Vertex Clustering Using Stitches</head><p>We introduce two methods, called Stack-Based and Variable-Length. The decomposition of the vertex clustering in stitches relies on the availability of two main elements: (1) a decoding order for the mesh vertices, and <ref type="formula">2</ref>, for the variable-length method only, an unequivocal means of defining paths of vertices. We next suppose that such paths are recorded in an array called v father, representing a function ½ Ò v father ½ Ò , where Ò is the number of vertices. All of the manifold mesh compression methods reviewed in Section 2 can provide an order in which vertices will be decoded as well as unambiguous paths of vertices from the decoded connectivity (the decoding order being one example). <ref type="figure" target="#fig_0">Fig. 2</ref> shows v father for the example of <ref type="figure">Fig. 1</ref>, obtained using the Topological Surgery method. The information consigned in v father is implicit, and requires no specific encoding. In the following we assume without loss of generality that vertices are enumerated in the decoder order of traversal. (If this is not the case, we can perform a permutation of the vertices). Both the stack-based and variable-length methods take as input a vertex clustering array, which for convenience we denote by v cluster ( ½ Ò v cluster ½ Ò ).</p><p>To access vertices through v cluster, we propose the convention that v cluster always indicate the vertex with the lowest decoder order: Supposing that vertices 1 and 256 belong to different components but cluster to the same vertex, it is better to</p><formula xml:id="formula_0">write v cluster ½ v cluster ¾ ½ than v cluster ½ v cluster ¾ ¾ .</formula><p>As the encoder and decoder build components gradually, at some point Vertex 1 will be a "physical" vertex of an existing component, while Vertex 256 will be in a yet-to-beencoded component. Accessing Vertex 1 through Vertex 256 would increase code complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Stack-Based Method</head><p>We use a stack-buffer for stitches, similarly to Deering <ref type="bibr" target="#b8">[9]</ref> and other manifold mesh compression modules (see <ref type="bibr" target="#b14">[15]</ref>). In the decoding order, we push, get and pop in a stack-buffer 6 the vertices that cluster  <ref type="bibr" target="#b14">[15]</ref>, v father is a forest that also admits self-loops. In the following, we will omit to draw self-loops.</p><p>together. Connected components (i.e., clusters) can be computed for the vertex clustering, such that two vertices belong to the same component if they cluster to the same vertex. We thus associate a stitching command for each vertex that belongs to a component whose size is larger than one. The command is either PUSH, or GET, or POP depending on the decoding order of the vertices in a given component. The vertex that is decoded first is associated with a PUSH; all subsequently decoded vertices are associated with a GET except the vertex decoded last, which is associated with a POP. For the example of <ref type="figure">Fig. 1</ref> we illustrate the association of commands to vertices in <ref type="figure" target="#fig_1">Fig. 3</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Variable-Length Method</head><p>One drawback of the stack-based method is that it requires to send one stitching command (either PUSH, GET or POP) for each vertex that clusters to a singular vertex. Instead, by specifying an integer length, we could keep stitching vertex pairs when following the v father relationship. This simple idea is illustrated in <ref type="figure" target="#fig_3">Fig. 4</ref>.  reverse direction works similarly by starting with two vertices, following the path for the second vertex and storing all vertices along the path in a temporary structure, and stitching vertices along the first path together with the stored vertices visited in reverse order. In the remainder of this section, we explain how to discover such stitches from the knowledge of the v cluster and v father arrays. While our ultimate goal is to minimize the total encoding size for stitches (with manageable encoder and especially, decoder, complexities), a good working hypothesis (heuristic) states that: the longer the stitches, the fewer the commands, and the smaller the bit-stream size. We propose a greedy method that operates as follows. The method first computes for each vertex that clusters to a singular vertex the longest possible forward stitch starting at that vertex: a length and one or several candidate vertices to be stitched with are determined. As illustrated in <ref type="figure" target="#fig_5">Fig. 6</ref>-A, starting with a vertex Ú¼, Ú¼ ¾ ½ Ò , all other vertices in the same cluster are identified, and v father is followed for all these vertices. From the vertices thus obtained, the method retains only those belonging to the same cluster as v father Ú¼ . This process is iterated until the cluster contains a single vertex. The ancestors of vertices remaining in the previous iteration (Ú is the successor of Ú¼ ending the stitch in <ref type="figure" target="#fig_5">Fig. 6-A)</ref> are candidates for stitching (Ú½ in <ref type="figure" target="#fig_5">Fig. 6-A)</ref>. Special care must be taken with self-loops in v father in order for the process to finish and the stitch length to be meaningful. Also, in our implementation we have assumed that v father did not have loops (except self-loops). In case v father has loops we should make sure that the process finishes.</p><p>Starting with Ú , the method then attempts to find a reverse stitch that would potentially be longer. This is illustrated in <ref type="figure" target="#fig_5">Fig. 6</ref>-B, by examining vertices that cluster with v father Ú , such as Ú¾. The stitch can be extended in this way several times. However, since nothing prevents a vertex Ú and its v father Ú from belonging to the same cluster, we must avoid stitching Ú¼ with itself.</p><p>All potential stitches are inserted in a priority queue, indexed with the length of the stitch. The method then empties the priority queue and applies the stitches in order of decreasing length until the vertex clustering is completely represented by stitches. This simple strategy must be extended to cope with the following issues (which are irrelevant for the stack-based method). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>The representation method must respect and use the decoder order of connected components of the manifold mesh. As mentioned in the Introduction, independently of the number of vertices that cluster to a given vertex, geometry and properties for that vertex are encoded only once, specifically for the first vertex of the cluster that is decoded. Connectivity, stitches, geometry and properties are encoded and decoded on a component-per-component basis (see <ref type="figure">Fig. 1</ref>-C) to allow progressive decoding and visualization. This implies that after decoding stitches corresponding to a given component, say Component Ñ, the complete clustering information (relevant portion of v cluster) for Component Ñ as well as between Component Ñ and the previously decoded components ½ Ñ ½ should be available. If this is not so, there is a mismatch between the geometry and properties that were encoded (too few) and those that the decoder is trying to decode, with potentially adverse consequences.</p><p>The stack-based method generates one command per vertex, for each cluster that is not trivial (cardinal larger than one), and will have no problem with this requirement. However, when applying the variable-length search for longest stitches on all components together, the optimum found by the method could be as in <ref type="figure">Fig. 7</ref>-A, where three components may be stitched together with two stitches, one involving Components 1 and 3 and the second involving Components 2 and 3.</p><p>Assuming that the total number of manifold components is , Our solution is to iterate on Ñ, the component number in decoder order, and for Ñ between 2 and , perform a search for longest stitches on components ½ ¾ Ñ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>The longest stitch cannot always be performed, because of incompatibilities with the decoder order of vertices: a vertex can only be stitched to one other vertex of lower decoder order. The example in <ref type="figure">Fig. 7</ref>-B illustrates this: the <ref type="bibr" target="#b11">(12,</ref><ref type="bibr" target="#b2">3)</ref> and <ref type="bibr" target="#b11">(12,</ref><ref type="bibr" target="#b6">7)</ref> stitches cannot be both encoded.</p><p>Since problems only involve vertices that start the stitch, it is possible to split the stitch in two stitches, one being one unit shorter and the other being of length zero. Both stitches are entered in the priority queue. For stitches of length zero, the incompatibility with the decoder order of vertices can always be resolved. In <ref type="figure">Fig. 7</ref>-B, for stitching 3 vertices, we can consider three stitching pairs, only one of which being rejected. Since for stitches of length zero the direction of the stitch does not matter, all other stitching pairs are valid. <ref type="figure">Figure 7</ref>: Potential problems with variable-length stitches. A: the clustering between Components 1 and 2 is decoded only when Component 3 is. B: These two stitches cannot be both encoded, because Vertex 12 can only be stitched to one vertex of lower decoding order (either 3 or 7 but not both.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>The method generates the longest stitch starting at each vertex. It is possible that this may not provide enough stitches to encode all the clusters. In this case the method can finish encoding the clusters using zero-length stitches similarly to the stack-based method.</p><p>Once a working combination of stitches is found, the last step is to translate them to stitching commands. This is the object of the next section which also specifies a bit-stream syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Stitches Encoding</head><p>To encode the stitching commands in a bit-stream, we propose the following syntax, that accommodates commands generated by both the stack-based and variable-length methods. To specify whether there are any stitches at all in a given component, a boolean flag has stitches is used. In addition to the PUSH, GET and POP commands, a vertex may be associated with a NONE command, in case it is sole representative of its cluster (e.g. does not correspond to a singular vertex in the non-manifold mesh), or in case the information on how to cluster it was already taken care of (variable-length method only). In general, because a majority of vertices are expected to be non-singular, most of the commands should be NONE. Three bits called stitching command, pop or get, and pop are used for coding the commands NONE, PUSH, GET and POP as shown in <ref type="figure" target="#fig_6">Fig. 8</ref>. A stitch length unsigned integer is associated with a PUSH command. A stack index unsigned integer is associated with GET and POP commands. In addition, GET and POP have the following parameters: differential length is a signed integer representing a potential increment or decrement with respect to the length that was recorded with a previous PUSH command or updated with a previous GET and POP (using differential length). push bit is a bit indicating whether the current vertex should be pushed in the stack, <ref type="bibr" target="#b6">7</ref> and reverse bit indicates whether the stitch should be performed in a reverse fashion.</p><p>We now explain how to encode (translate) the stitches obtained in the previous section in compliance with the syntax we defined. Both encoder and decoder maintain an anchor stack accross manifold connected component for referring to vertices (potentially belonging to previous components). For the stack-based method, the process is straightforward: in addition to the commands NONE, PUSH, GET and POP encoded using the three bits stitching command, pop or get, and pop, a PUSH is associated with stitch length ¼ . GET and POP are associated with a stack index that is easily computed from the anchor stack.</p><p>For the variable-length method, the process can be better understood by examining <ref type="figure" target="#fig_7">Fig. 9</ref>. In <ref type="figure" target="#fig_7">Fig. 9</ref>-A we show a pictorial representation of a stitch. A vertex is shown with an attached string of edges representing a stitch length, and a stitch to arrow pointing to an anchor. Both vertex and anchor are represented in relation to the decoder order of (traversal of) vertices. The stitch to relationship defines a partition of the vertices associated with stitching commands. In <ref type="figure" target="#fig_7">Fig. 9</ref>-B we isolate a component of this partition. For each such component, the method visits the vertices in decoder order (Ú¼ Ú½ Ú¾ Ú¿ in <ref type="figure" target="#fig_7">Fig. 9-B.</ref>) For the first vertex, the command is a PUSH. Subsequent vertices are associated with a GET or POP depending on remaining stitch to relationships; for vertices that are also anchors, a push bit is set. Incremental lengths and reverse bits are also computed. <ref type="figure" target="#fig_7">Fig. 9</ref>-C shows the commands associated with <ref type="figure" target="#fig_7">Fig. 9-B</ref>. For the example of <ref type="figure">Fig. 1</ref> that we have used throughout this paper, the final five commands different from NONE are gathered in <ref type="table">Table 1</ref>.</p><p>After the commands are in this form, the encoder operates in a manner completely symmetric to the decoder which is described in detail in the next section, except that the encoder does not actually perform the stitches while the decoder does.  <ref type="table" target="#tab_0">0  PUSH  0  1  PUSH  1  5  POP  1  0  0  0  6  POP  0  0  1  0  0  POP  0  2  0  1   Table 1</ref>: Five commands (different from NONE) encoding the complete clustering of <ref type="figure">Fig. 1</ref>. The stack-based encoding shown in <ref type="figure" target="#fig_1">Fig. 3</ref> requires nine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Stitches Decoding</head><p>The decoder reconstructs the v cluster that should be applied to vertices to reconstruct the polygonal mesh. The following pseudocode shown in <ref type="figure">Fig. 10</ref> summarizes the operation of the stitches decoder: if the boolean has stitches in the current connected component is true, then for each vertex of the current component in decoder order, a stitching command is decoded. If the boolean value stitching command is true, then the boolean value pop or get is decoded; if the boolean value pop or get is false, an unsigned integer is decoded, and associated to the current vertex i as an anchor (to stitch to). The current vertex i is then pushed to the back of the anchor stack. if pop or get is true, then the boolean value pop is decoded, followed with the unsigned integer value stack index. <ref type="figure">Figure 10</ref>: Pseudo-code for the Stitches decoder. Using stack index, an anchor is retrieved from the anchor stack. This is the anchor that the current vertex i will be stitched to. If the pop boolean variable is true, then the anchor is removed from the anchor stack. Then, an integer differential length is decoded as an unsigned integer. If it is different from zero, its sign (boolean differential length sign) is decoded, and is used to update the sign of differential length. A push bit boolean value is decoded. If push bit is true, the current vertex i is pushed to the back of the anchor stack. An in-teger stitch length associated with the anchor is retrieved. A total length is computed by adding stitch length and differential length; if total length is greater than zero, a reverse bit boolean value is decoded. Then the v cluster array is updated by stitching the current vertex i to the stitching anchor with a length equal to total length and potentially using a reverse stitch. The decoder uses the v father array to perform this operation. To stitch the current vertex i to the stitching anchor with a length equal to total length, starting from both i and the anchor at the same time, we follow vertex paths starting with both i and the anchor by looking up the v father entries total length times, and for each corresponding entries (i,anchor), (</p><formula xml:id="formula_1">v father[i],v father[anchor]), (v father[v father[i]], v father[v father[anchor]])</formula><p>, we record in the v cluster array that the entry with the largest decoder order should be the same as the entry with the lowest decoder order. For instance if (j k), then v cluster[j] = k else v cluster[k] = j. v cluster defines a graph that is a forest. Each time an entry in v cluster is changed, we perform path compression on the forest by updating v cluster such that each element refers directly to the root of the forest tree it belongs to.</p><p>If the stitch is a reverse stitch, then we first follow the v father entries starting from the anchor for a length equal to to total length (from Vertices 6 through 3 in <ref type="figure" target="#fig_4">Fig. 5</ref>), recording the intermediate vertices in a temporary array. We then follow the v father entries starting from the vertex i and for each corresponding entry stored in the temporary array (from the last entry to the first entry), we update v cluster as explained above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Experimental Results</head><p>Test Meshes: 14 meshes illustrated in <ref type="figure" target="#fig_9">Fig. 11</ref> (of the color page) were considered, ranging from having a few vertices (5) to about 65,000. The meshes range from having very few non-manifold vertices (2 out of 5056 or 0.04%) to a significant proportion of non-manifold vertices (up to 88 % for the Sierpinski.wrl model). One mesh was manifold and all the rest of the meshes were nonmanifold. (The manifold mesh will be easily identified by the reader in <ref type="table" target="#tab_0">Table 2</ref>.) One model (Gen nm.wrl) had colors and normals per vertex. It was made non-manifold by adding triangles. The Engine model was originally manifold, and made non-manifold by applying a clustering operation. We synthesized the models Planet0.wrl, Saturn.wrl, Sierpinski.wrl, Tetra2nm.wrl. All other models were obtained from various sources and originally nonmanifolds. Test Conditions: The following quantization parameters were used: geometry (vertex coordinates) was quantized to 10 bits per coordinate, colors to 6 bits per color, and normals to 10 bits per normal. The coordinate prediction was done using the "parallelogram prediction" <ref type="bibr" target="#b3">[4]</ref>, the color prediction was be done along the triangle tree (see Section 4), and there was no normal prediction. Using 10 bits per coordinate, there was hardly a noticeable difference between the original and decoded models. For completeness, we illustrate the Symmetric-brain test model before compression and after decompression in <ref type="figure" target="#fig_0">Fig. 12 (of the color page)</ref>. Test Results: This paper focuses about encoding and decoding stitches, which is a small portion of the geometry compression process. Our goal in this section is to determine how stitches affect the entire compression process. We will thus provide estimates of compression ratios and decoding timings that apply to the entire process, keeping in mind that the bulk of the compression process is described in other publications <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b14">15]</ref>. The following estimates (obtained using the 14 meshes) may have to be revised as more statistical data becomes available, or as more efficient encoders and decoders are implemented.   <ref type="table">Table 3</ref>: Comparing the efficiency of the variable-length encoder vs. the stack-based encoder. The total bit-stream sizes are in bytes. 5% percent of the total bit-stream size represents a significant proportion of the connectivity (perhaps all of it) and is thus very significant for stitches. manifolds or as manifolds (i.e., without the stitching information). There is an initial cost for each mesh on the order of 40 bytes or so, independently of the number of triangles and vertices. Although we do not provide specific results on the connectivity encoding in this paper, from data that we collected independently of the present study involving non-manifolds, we expect the connectivity to generally consume significantly fewer bits than coordinates and properties once compressed and arithmetic-coded (a few bits per triangle at most: from 0.1 bits to 3 bits per triangle).</p><p>In case of smooth meshes, the connectivity coding, prediction and arithmetic coding seem to divide by three or so the size of quantized vertices: for instance, starting with 10 bits per vertex of quantization, a typical bit-stream size would be on the order of 10 bits per vertex and 5 bits per triangle (assuming a manifold mesh without too many boundaries). In case of highly non-manifold or non-smooth meshes, starting with 10 bits per vertex of quantization, a typical bit-stream size would be on the order of 20 bits per vertex and 10 bits per triangle (smooth meshes compress roughly twice as much).</p><p>The previous estimates apply to both manifold and non-manifold compression. <ref type="table" target="#tab_0">Table 2</ref> indicates that when compressing a nonmanifold as a non-manifold (i.e., recovering the connectivity using stitches) the total bit-stream size can be reduced by up to 20%  <ref type="table">Table 4</ref>: Encoding and decoding times in seconds measured on an IBM Thinkpad 600 233MHz computer. The stack-based method was used. The times include non-manifold to manifold conversion.</p><p>(21% for the tetra2nm.wrl model). This is because when encoding stitches, vertices that will be stitched together are encoded only once (such vertices were duplicated during the non-manifold to manifold conversion process). The same applies to per-vertex properties. <ref type="table">Table 3</ref> compares the efficiencies of the stack-based encoder and variable-length encoder by measuring total bit-stream sizes. The observed bitstream sizes decrease using the variable-length encoder, in three cases by about 5%. 5% of the total bit-stream size represents a significant proportion of the connectivity (perhaps all of it), while the stitches would represent a small portion of the connectivity (which includes vertex graph, triangle trees, etc.). Thus the savings of the variable-length encoder are very significant. These bits would be better used for a more accurate encoding of the geometry. <ref type="table">Table 4</ref> gathers overall encoding and decoding timings using the stack-based method <ref type="bibr" target="#b7">8</ref> . We observe a decoding speed of 10,000 to 13,000 vertices per second on a commonly available 233MHz Pentium II laptop computer. For many meshes it has been reported that the number of triangles is about twice the number of vertices: this is exact for a torus, and is approximate for many large meshes with a relatively simple topology. In this case we observe a decoding speed of 20,000 to 25,000 triangles per second. When considering non-manifold meshes the assumption that the number of triangles is about twice the number of vertices does not necessarily hold, depending on the number of singular and boundary vertices and edges of the model (for instance consider the Enterprise.wrl model). This is why for non-manifold meshes, or meshes with a significant number of boundary vertices, when measuring computational complexity the number of vertices is probably a better measure of shape complexity than the number of triangles. The above estimates apply to most meshes, including meshes with one or several properties (such as gen nm.wrl), with the exception of meshes with fewer than 50 vertices or so, which would not be significant for measuring per-triangle or per-vertex decompression speeds (because of various overheads). While these results appear to be at first an order of magnitude slower than those reported in <ref type="bibr" target="#b4">[5]</ref>, we note that Gumhold and Strasser decode the connectivity only (which is only one functionality, and a small portion of compressed data) and observe their timings on a different computer (175MHz SGI/02). Also, our decoder was not optimized so far (more on this in Section 9). Timings reported are independent of whether the mesh is a manifold mesh or not. There is thus no measured penalty in decoding time incurred by stitches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Summary and Future Work</head><p>We have described a method for compressing non-manifold polygonal meshes that combines an existing method for compressing a manifold mesh and new methods for encoding and decoding stitches. These latter methods comply with a new bitstream syntax for stitches that we have defined.</p><p>While our work uses an extension of the Topological Surgery method for manifold compression <ref type="bibr" target="#b14">[15]</ref>, there are no major obstacles preventing the use of other methods such as <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b2">3]</ref>.</p><p>We reported results showing that non-manifold compression has no noticeable effect on decoding complexity. Furthermore, compared with encoding a non-manifold as a manifold, our method permits savings in the compressed bitstream size (of up to 20%, and in average of 8.4%), because it avoids duplication of vertex coordinates and properties. This is in addition to achieving the functionality of compressing a non-manifold without perturbing the connectivity.</p><p>In terms of encoding, we presented two different encoders: a simple entry-level encoder, and a more complex encoder that uses the full potential of the syntax. The results we reported indicate that the additional complexity of the second encoder is justified in several cases. Other encoders may be designed in compliance with the syntax. One particularly interesting open question is: Is there a provably good optimization strategy to minimize the number of bits for encoding stitches?</p><p>Stitches allow more than connectivity-preserving non-manifold compression: merging components and performing all other topological transformations corresponding to a vertex clustering are possible. How to exploit such topological transformations using our stitching syntax (or other syntaxes) is another interesting avenue for future developments.</p><p>The technology described in this paper is part of the MPEG-4 standard on 3-D Mesh Coding. It hides completely the issues of mesh singularities to the user. These are arguably complex issues that creators and users of 3-D content may not necessarily want to learn about. Using the methods described in this paper, there will be no alteration of the original connectivity, whether non-manifold or manifold.</p><p>Decoder Optimization The software that was used to report results in this paper was by no means optimized. This is because non-manifold compression is only one of the functionalities of geometry compression, incremental (i.e., streamed) and hierarchical transmission being examples of other functionalities. Optimization must thus be done in harmony with all the functionalities and will be the subject of future work. The decoder may be optimized in the following ways (other optimizations are possible as well): <ref type="bibr" target="#b0">(1)</ref> limiting modularity and function calls between modules, once the functionalities and syntax are frozen; (2) optimizing the arithmetic coding, which is a bottleneck of the decoding process (every single cycle in the arithmetic coder matters); (3) performing a detailed analysis of memory requirements, imposing restrictions on the size of mesh connected components, and limiting the number of cache misses in this way.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>A: v father for the example of Fig. 1. B: in the particular case of Topological Surgery</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Stack-based method applied to the example ofFig.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Using the same example of Fig 1, we illustrate in the Fig. 5 how variable length stitches can be used to represent the vertex clustering. A stitch of length Ð greater than zero is obtained by starting with two vertices and stitching vertices along two paths starting at the vertices and defined using the v father graph, exactly Ð • ½ times. For the example of Fig. 5, 3 stitches are applied to represent v cluster: one (forward) stitch of length 1, one stitch of length zero, and one stitch of length 2 in the reverse direction. A stitch in the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>A: the stack-based method requires one command for each vertex that is clustered. B: with the variable-length method, the specification of a length can eliminate several commands.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Three stitches of variable length and direction encode the vertex clustering of Fig. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Computing the longest possible stitch starting at a vertex Ú¼. Ovals indicate clusters. A: forward stitch of length 3 with Ú½. B: backward stitch of length 4 with Ú¾.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Syntax for Stitches. "X"s indicate variables associated with each command</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Translating stitches to the bit-stream syntax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Test meshes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>A: Symmetric-brain model before compression. B. after decompression: starting with 10 bits of quantization per vertex coordinate the complete compressed bitstream uses 17.2 bits per vertex.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2</head><label>2</label><figDesc>provides compressed bit-stream sizes for the 14 meshes and compares the bit-stream sizes when meshes are encoded as non-</figDesc><table><row><cell>Model</cell><cell cols="3">Uncompressed Number of Number of</cell><cell cols="3">Compressed as</cell><cell cols="3">Compressed as Non-manifold vs</cell></row><row><cell></cell><cell>Size</cell><cell>Vertices</cell><cell>Triangles</cell><cell cols="2">Non-Manifold</cell><cell></cell><cell>Manifold</cell><cell cols="2">Manifold</cell></row><row><cell></cell><cell>bytes</cell><cell></cell><cell></cell><cell>bytes</cell><cell>bpv</cell><cell>bpt</cell><cell>bytes</cell><cell>ratio</cell><cell>savings</cell></row><row><cell>Bart.wrl</cell><cell>392,030</cell><cell>5,056</cell><cell>9,000</cell><cell>7,243</cell><cell>11.46</cell><cell>6.43</cell><cell>8,105</cell><cell>0.89</cell><cell>11%</cell></row><row><cell>Briggso.wrl</cell><cell>130,297</cell><cell>1,584</cell><cell>3,160</cell><cell>4,080</cell><cell cols="2">20.61 10.32</cell><cell>4,129</cell><cell>0.98</cell><cell>2%</cell></row><row><cell>Engine.wrl</cell><cell>4,851,671</cell><cell>63,528</cell><cell>132,807</cell><cell cols="2">139,632 17.58</cell><cell>8.41</cell><cell>167,379</cell><cell>0.83</cell><cell>17%</cell></row><row><cell>Enterprise.wrl</cell><cell>859,388</cell><cell>12,580</cell><cell>12,609</cell><cell>28,224</cell><cell cols="2">17.95 17.91</cell><cell>29,553</cell><cell>0.95</cell><cell>5%</cell></row><row><cell>Gen nm.wrl</cell><cell>49,360</cell><cell>410</cell><cell>820</cell><cell>2,566</cell><cell cols="2">50.06 25.03</cell><cell>2625</cell><cell>0.97</cell><cell>3%</cell></row><row><cell>Lamp.wrl</cell><cell>254,043</cell><cell>2,810</cell><cell>5,054</cell><cell>3,726</cell><cell>10.61</cell><cell>5.90</cell><cell>3954</cell><cell>0.94</cell><cell>6%</cell></row><row><cell>Maze.wrl</cell><cell>87,391</cell><cell>1,412</cell><cell>1,504</cell><cell>4,235</cell><cell>24.0</cell><cell>22.53</cell><cell>4855</cell><cell>0.87</cell><cell>13%</cell></row><row><cell>Opt-cow.wrl</cell><cell>204,420</cell><cell>3,078</cell><cell>5,804</cell><cell>7,006</cell><cell>18.02</cell><cell>9.66</cell><cell>7,006</cell><cell>1</cell><cell>0%</cell></row><row><cell>Planet0.wrl</cell><cell>1,656</cell><cell>8</cell><cell>12</cell><cell>82</cell><cell>82</cell><cell>54.6</cell><cell>96</cell><cell>0.85</cell><cell>15%</cell></row><row><cell>Saturn.wrl</cell><cell>61,155</cell><cell>770</cell><cell>1,536</cell><cell>1,998</cell><cell cols="2">20.75 10.40</cell><cell>2,197</cell><cell>0.91</cell><cell>9%</cell></row><row><cell>Sierpinski.wrl</cell><cell>4,702</cell><cell>34</cell><cell>64</cell><cell>193</cell><cell cols="2">45.64 24.12</cell><cell>252</cell><cell>0.76</cell><cell>4%</cell></row><row><cell>Superfemur.wrl</cell><cell>1,241,052</cell><cell>14,065</cell><cell>28,124</cell><cell>30,964</cell><cell>17.61</cell><cell>8.81</cell><cell>31,378</cell><cell>0.98</cell><cell>2%</cell></row><row><cell>Symmetric brain.wrl</cell><cell>3,092,371</cell><cell>34,416</cell><cell>66,688</cell><cell>73,789</cell><cell>17.15</cell><cell>8.85</cell><cell>73,640</cell><cell>1.002</cell><cell>-0.2%</cell></row><row><cell>Tetra2nm.wrl</cell><cell>489</cell><cell>5</cell><cell>7</cell><cell>66</cell><cell cols="2">105.6 75.42</cell><cell>83</cell><cell>0.79</cell><cell>21%</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Compression results. "bpv" stands for "bits per vertex" and bpt for "bits per triangle"</figDesc><table><row><cell></cell><cell>Stack-Based</cell><cell>Variable-Length</cell><cell></cell></row><row><cell>Non-manifold</cell><cell cols="2">Encoder</cell><cell>size</cell></row><row><cell>Model</cell><cell cols="2">bit-stream size in bytes</cell><cell>ratio</cell></row><row><cell>Bart.wrl</cell><cell>7,245</cell><cell>7,243</cell><cell>1.0003</cell></row><row><cell>Briggso.wrl</cell><cell>4,100</cell><cell>4,080</cell><cell>1.005</cell></row><row><cell>engine.wrl</cell><cell>148,601</cell><cell>139,632</cell><cell>1.064</cell></row><row><cell>Gen nm.wrl</cell><cell>2,566</cell><cell>2,566</cell><cell>1</cell></row><row><cell>Lamp.wrl</cell><cell>3,904</cell><cell>3,726</cell><cell>1.05</cell></row><row><cell>Maze.wrl</cell><cell>4,278</cell><cell>4,235</cell><cell>1.01</cell></row><row><cell>Planet0.wrl</cell><cell>82</cell><cell>82</cell><cell>1</cell></row><row><cell>Saturn.wrl</cell><cell>2,087</cell><cell>1,998</cell><cell>1.045</cell></row><row><cell>Sierpinski.wrl</cell><cell>193</cell><cell>193</cell><cell>1</cell></row><row><cell>Superfemur.wrl</cell><cell>30,971</cell><cell>30,964</cell><cell>1.0002</cell></row><row><cell>Symmetricbrain.wrl</cell><cell>73,839</cell><cell>73,789</cell><cell>1.0007</cell></row><row><cell>Tetra2nm.wrl</cell><cell>67</cell><cell>66</cell><cell>1.015</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Specifically, a manifold polygonal surface is such that the neighborhood of every vertex can be continuously deformed to a disk (to a half disk at the boundary).2 I.e., means for specifying groups of vertices, such that each group should be clustered to form a single vertex.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">A fan of polygons at a vertex is a set of polygons incident to a vertex and connected with regular edges. A singular vertex is simply a vertex with more than one incident fans.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">Which extends a current triangle to form a parallelogram, with the new parallelogram vertex being used as a predictor.<ref type="bibr" target="#b5">6</ref> A "stack" would only support "push" and "pop" operations. We denote by "stack-buffer" a data structure that supports the "get" operation as well, i.e., direct indexing.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7">Since POP and GET have an associated push bit there are fewer PUSH than POP commands (although this seems counter-intuitive). We have tried exchanging the variable length codes for PUSH and POP, but did not observe smaller bit-streams in practice; we attributed this to the arithmetic coder.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8">Which are perhaps more relevant for<ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b14">15]</ref>, the present methods representing only one module.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments We thank G. Zhuang, V. Pascucci and C. Bajaj for providing the Brain model, and A. Kalvin for providing the Femur model.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Converting sets of polygons to manifold surfaces by cutting and stitching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gueziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization&apos;98</title>
		<meeting><address><addrLine>Raleigh, NC.</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="383" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Progressive simplicial complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Popovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Siggraph&apos;97 Conference Proceedings</title>
		<meeting><address><addrLine>Los Angeles, Au</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Single resolution compression of arbitrary triangular meshes with properties</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Zhuang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Data Compression Conference</title>
		<meeting>Data Compression Conference</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="99" to="104" />
		</imprint>
	</monogr>
	<note>TICAM Report Number</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Triangle mesh compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Graphics Interface Conference</title>
		<meeting>24th Graphics Interface Conference<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Real time compression of triangle mesh connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Siggraph&apos;98 Conference Proceedings</title>
		<meeting><address><addrLine>Orlando</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Edgebreaker: Connectivity compression for triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="61" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Progressive coding of 3D graphics models. Proceedings of the IEEE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Kuo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="1052" to="1063" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient implementation of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer and Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="36" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Geometry compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Siggraph&apos;95 Conference Proceedings</title>
		<meeting><address><addrLine>Los Angeles</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optimized geometry compression for real-time rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization 97</title>
		<meeting><address><addrLine>Phoenix, AZ.</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="415" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Geometry compression through topological surgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="115" />
			<date type="published" when="1998-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Geometry coding and VRML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="1228" to="1243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The Virtual Reality Modeling Language Specification, VRML&apos;97 Specification</title>
		<ptr target="http://www.web3d.org/Specifications/VRML97" />
		<imprint>
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Encoding and triangulation as a permutation of its point set</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Denny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Ninth Canadian Conference on Computational Geometry</title>
		<meeting>of the Ninth Canadian Conference on Computational Geometry</meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="39" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m">ISO/IEC 14496-2 MPEG-4 Visual Committee Working Draft Version, SC29/WG11 document number W2688</title>
		<meeting><address><addrLine>Seoul</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-04-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Slattery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Qx-coder. IBM J. Res. and Dev</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="767" to="784" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
