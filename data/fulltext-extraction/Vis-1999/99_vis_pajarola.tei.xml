<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Implant Sprays: Compression of Progressive Tetrahedral Mesh Connectivity</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renato</forename><surname>Pajarola</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Andrzej Szymczak Graphics</orgName>
								<orgName type="institution">Visualization &amp; Usability Center Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarek</forename><surname>Rossignac</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Andrzej Szymczak Graphics</orgName>
								<orgName type="institution">Visualization &amp; Usability Center Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Implant Sprays: Compression of Progressive Tetrahedral Mesh Connectivity</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.5 Computational Geometry and Object Modeling -object representation</term>
					<term>E.2 Data Storage Representation -object representation</term>
					<term>E.4 Coding and Information Theory -data compaction and compression tetrahedral meshes, compression, multiresolution models, progressive incremental reconstruction</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Irregular tetrahedral meshes, which are popular in many engineering and scientific applications, often contain a large number of vertices. A mesh of V vertices and T tetrahedra requires 48•V bits or less to store the vertex coordinates, 4•T•log 2 (V) bits to store the tetrahedra-vertex incidence relations, also called connectivity information, and k•V bits to store the k-bit value samples associated with the vertices. Given that T is 5 to 7 times larger than V and that V often exceeds 32 3 , the storage space required for the connectivity is larger than 300•V bits and thus dominates the overall storage cost. Our &quot;implants spray&quot; compression approach introduced in this paper reduces this cost to about 30•V bits or less-a 10:1 compression ratio. Furthermore, implant spray supports the progressive refinement of a crude model through a series of vertex-splits operations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>A large portion of finite element meshes, and scientific and engineering analysis results are expressed in terms of sample points distributed through 3D space, associated scalar values, and connectivity information which defines how the sampled scalar values are to be interpolated. The simplest and most commonly used interpolation is based on a decomposition of the 3D space into a tetrahedral mesh, which may be defined by a tetrahedra-vertices incidence table that takes bits for a mesh with V vertices and T tetrahedra. In this paper we propose a compression technique which reduces this storage cost to about 5• T bits.</p><p>Our compressed format, called implant sprays , describes a coarse mesh and a series of implants, refinement operations. Each implant inserts a new vertex and a series of incident tetrahedra. The implants are simple extensions of the vertex split operation introduced in <ref type="bibr" target="#b4">[ 5 ]</ref> that are applied to tetrahedral meshes <ref type="bibr" target="#b12">[11]</ref>. The implant is defined by the selection of an existing vertex v , called the split-vertex, a displacement vector defining the location of a new vertex, and a cycle of triangle-faces incident upon the open vertex v , called the skirt . We describe here an encoding of the selection of split-vertices that requires less than 3 bits per tetrahedron. Furthermore, we propose an encoding of the skirt that requires roughly 3 bits per tetrahedron. Combined, these two techniques reduce the connectivity costs per tetrahedron from the initial bits to less than six bits. Even for modest size meshes, we obtain a compression ratio better than 10:1. These savings are important, because otherwise the connectivity data dominates the storage costs. Indeed, there are roughly 6 times as many tetrahedra as vertices -this number varies with the structure of the mesh. Even for a small mesh of 32 <ref type="bibr" target="#b2">3</ref> vertices the uncompressed connectivity cost is 360• V bits (i.e. 4•6•15• V ). In comparison, vertex location may be represented with only 48• V bits using 16-bit integer coordinates in an optimally chosen coordinate system <ref type="bibr" target="#b0">[1]</ref>.</p><p>The rest of the paper is organized as follows: Section 2 provides an overview of related work on triangular and tetrahedral meshes, in Section 3 the basic simplification and refinement operations are described, Section 4 presents detailed explanation of the implant sprays encoding and Section 5 provides an implementation framework, experiments are reported in Section 6, and Section 7 concludes the paper and gives an outlook over future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Recently, a lot of work has been done in short encodings of the connectivity of triangular meshes. With few exceptions, i.e. Progressive Forest Split Compression (PFS) <ref type="bibr" target="#b14">[12]</ref> and Compressed Progressive Meshes (CPM) <ref type="bibr" target="#b7">[8]</ref>, most methods only work for single-resolution meshes. Very successful approaches for triangular mesh encoding are the Topological Surgery method <ref type="bibr" target="#b15">[13]</ref>, Edgebreaker <ref type="bibr" target="#b10">[10]</ref>, real time connectivity compression of <ref type="bibr" target="#b3">[ 4 ]</ref>, and the triangle mesh compression presented in <ref type="bibr" target="#b17">[15]</ref>. A comprehensive overview can also be found in <ref type="bibr" target="#b10">[10]</ref> or <ref type="bibr" target="#b16">[14]</ref>. These single-resolution mesh compression algorithms are able to encode the connectivity of a triangular mesh with less than 2 bits per triangle. The multiresolution mesh compression methods PFS and CPM achieve a connectivity encoding of less than 5 (PFS) or less than 4 bits (CPM) per triangle while providing a progressive triangulation with several levels of detail of increasing approximation accuracy.</p><p>Much less work has been performed on compressing the connectivity of tetrahedral meshes, even though in the tetrahedral case the incidence information dominates the geometry data, the 3D coordinates of vertices. Only recently the Grow &amp; Fold method was presented in <ref type="bibr" target="#b19">[17]</ref> that encodes the connectivity of tetrahedral meshes with roughly 7 bits per tetrahedron. However, as most of</p><formula xml:id="formula_0">4T V ( ) 2 l og ⋅ 4 V ( ) 2 log ⋅ ‡ GVU Center, College of Computing 801 Atlantic Dr.</formula><p>Georgia Institute of Technology Atlanta, GA 30332-0280 pajarola@acm.org the triangle mesh compression methods, this approach encodes one single-resolution tetrahedralization. Thus it provides one level of detail only. Progressive multiresolution tetrahedralizations <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b18">16]</ref> have only recently been presented. However, no concise encoding of the refinement operations has been provided. Each refinement operation of the progressive tetrahedralization in <ref type="bibr" target="#b12">[11]</ref> needs to specify one vertex that will be split, the so called split-vertex, and 5 to 7 incident triangular faces that will be cut and expanded into tetrahedra, the cut-faces. The split-vertex can be identified using bits in a tetrahedral mesh with V vertices. The cutfaces can be encoded locally with respect to the split-vertex. Because a vertex in a tetrahedral mesh has about 36 incident faces, the cut-faces can be encoded with roughly bits. A similar coding scheme can also be applied to the multiresolution tetrahedralization of <ref type="bibr" target="#b18">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROGRESSIVE MESHES</head><p>In <ref type="bibr" target="#b4">[ 5 ]</ref> the edge collapse operation, and its inverse the vertex split , was introduced for triangular mesh simplification, see also <ref type="figure" target="#fig_0">Figure 1</ref> for an example. Progressive Meshes <ref type="bibr" target="#b5">[6]</ref> apply a sequence of edge collapse operations M i → M i -1 to a given triangular, high resolution input mesh M l max to create a series of simplified</p><formula xml:id="formula_1">meshes M l max , M l max-1 , …, M i , M i -1 , …, M 1 , M 0 with decreas- ing approximation accuracy. The meshes M i (0 &lt; i ≤ l max )</formula><p>can be reconstructed by performing the inverse sequence of vertex splits M i -1 → M i starting with a crude base mesh M 0 . The same basic principles of edge collapses and vertex splits can be extended and applied to more complex meshes such as simplicial complexes <ref type="bibr" target="#b8">[9]</ref> and tetrahedral meshes <ref type="bibr" target="#b12">[11]</ref>. In tetrahedral meshes, a collapse of an edge eliminates all tetrahedra incident to that edge and reduces the number of vertices in the mesh by one, see also <ref type="figure" target="#fig_1">Figure 2</ref> for a graphical example. Again, a sequence of edge collapses and its inverse, the vertex splits, define a progressive tetrahedralization , as proposed in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">11]</ref>, as a series of tetrahedral meshes T 0 , …, T l max of increasing precision. In the remainder of the paper T will refer to a tetrahedral mesh if not specified otherwise. Furthermore, we denote the vertex that results from an edge collapse as a split-vertex , in the refinement process this vertex will be split into two, and the triangular faces that result from collapsing the tetrahedra incident to the collapsed edge are called cut-faces , see also <ref type="figure" target="#fig_1">Figure 2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROGRESSIVE ENCODING</head><p>As mentioned above, a progressive tetrahedralization is defined by a crude base mesh T 0 and a sequence of vertex split refinement operations. Given an intermediate mesh T i , an individual refinement operation is fully specified by the identification of the splitvertex and the set of incident cut-faces, both given in T i . After locating the split-vertex v , identifying the cut-faces is a local process on the neighborhood of v in mesh T i . The following Section 4.1 describes our new method of locally encoding the set of cut-faces for an individual vertex split operation. Next, the progressive encoding of the split-vertex locations is described in Section 4.2.</p><p>Note that our algorithms presume the existance of a canonical ordering and numbering of the vertices of any tetrahedral mesh T i .. Such an ordering can arbitrarily be specified, i.e. sorted by coordinates, or given by a mesh traversal, i.e. depth-first vertex tree traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Cut-faces</head><p>The cut-faces around a split-vertex, also called the skirt , define how the incidence relations have to be modified for a vertex split operation. To better understand the coding of the skirt, let us define the orbital surface of a split-vertex v as the triangular surface consisting of all faces of tetrahedra incident to v that are not themselves incident faces of v , see also <ref type="figure" target="#fig_3">Figure 3</ref>. The skirt forms a connected path, a cycle, on the triangulated orbital surface, see also <ref type="figure" target="#fig_4">Figure 4</ref>. Note that the number of different cycles of length k , also called k -cycles, without repetition of edges or nodes, on a triangular planar graph G with d vertices is much smaller than the number of all subsets of edges of G of size k , also called k -sets, because the k -cycles are a subset of the k -sets. Therefore, the corresponding method to the triangular approach in <ref type="bibr" target="#b7">[8]</ref> of encoding the skirt as one particular k -set out of all 1 possible ones, is not optimal in a progressive tetrahedralization.</p><p>1. A planar triangulation has roughly three times as many edges as vertices. Corollary, a vertex in a 3D tetrahedralization has roughly three times as many incident faces as incident edges.  An optimized encoding of the skirt could be achieved by identifying the particular k -cycle of a vertex split operation out of all possible k -cycles on the orbital surface. The embedding of the triangulated orbital surface in a plane is called the triangular planar graph G orb , see also <ref type="figure" target="#fig_4">Figure 4</ref>. Given a canonical numbering of the vertices, an enumeration of all k-cycles in the graph G orb can be achieved by a recursive backtracking algorithm. For every vertex, starting with the youngest one, initiate a depth-first vertex traversal of G orb , again youngest first, for finding paths of length k. Backtracking occurs when a path is longer than k, a k-path is not a cycle, or a node or edge of G orb is used twice in the current path. Moreover, backtracking also occurs when a younger vertex than the start-vertex is found on the currently explored path because kcycles are only reported for their youngest vertex. Note that otherwise the same k-cycle would be reported several times, for each vertex in the cycle. A correct path is found when it is of length k and the end-vertex is equal to the start-vertex of the initiated traversal. For this method of encoding the skirt, the number k of cutfaces has to be known to the decoder in advance. Although providing an optimized encoding in terms of space cost (bits), the previously described approach of encoding the skirt is inefficient in time cost. Because the enumeration of all possible k-cycles for every split-vertex is quite time consuming we implemented a faster encoding of the skirt. The path on the graph G orb which defines the skirt, see <ref type="figure" target="#fig_4">Figure 4</ref> a), can be encoded as a walk along edges of G orb . The start of the path, a vertex of G orb , is encoded using bits for a split-vertex of degree d. Since the average degree of split-vertices in a progressive tetrahedralization is more than 14 -thus also the number of vertices of G orb -the start vertex encoding requires roughly 4 bits on average. The skirt can then be specified by a path of length k, forming the k-cycle, as a set of consecutive edges on G orb . Each edge can be specified using less than bits since the degree of vertices in a planar triangulation is 6 on average. Thus the cut-faces encoded as a walk along edges of G orb can be expected to cost about bits.</p><p>Note that in general the orbital surface could be non-manifold due to edge collapse operations. In the following section we describe the constraints that prevent non-manifold orbital surfaces. Also special care has to be taken at the border of the tetrahedral mesh because the orbital surface will not be homeomorph to a sphere anymore. If it is a hemisphere, the skirt will still be connected but could form an open path, however, this can still efficiently be encoded as a walk. If due to a non-manifold border of the tetrahedral mesh the skirt is not anymore connected, a special encoding would have to be used to indicate that situation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Split-vertex</head><p>Instead of refining the current mesh T i by one single vertex split at a time, we perform a series of vertex splits simultaneously, also called implants sprays, to achieve the next refined level of detail (LOD) T i+1 . Identifying one isolated split-vertex in T i would require bits in a mesh with V i vertices, which is very costly for large meshes. However, identifying a set of V i / k independent split-vertices by a flag, marking all vertices in T i with one bit only, amounts to a constant of k bits per split-vertex. The decoding process just needs to visit all vertices in T i in the same order as the encoder, and read the respective marking bits from the data stream to identify the set of vertices that are to be split.</p><p>To optimize coding efficiency one would like to maximize the fraction V i / k of independent vertex splits that form a refinement step T i → T i+1 . In a planar triangulation k can be guaranteed to be less than 4 by the vertex coloring theorem, and experiments show an average of about 3 <ref type="bibr" target="#b7">[8]</ref> for independent vertex splits. In a tetrahedral mesh k cannot be bounded easily. Vertex coloring of non-planar graphs depends on the maximal degree of incident edges on a vertex, which is not bounded in a tetrahedral mesh. Larger independent sets than induced by the vertex coloring can be constructed, however, the maximization of k is limited by the simplification process. During the construction of the progressive mesh, the choice of independent edge collapses in T i+1 is restricted. To be able to distinguish the individual vertex splits in T i without ambiguities, the following three requirements for edge collapses in T i+1 are sufficient:</p><p>1. The two sets of tetrahedra in T i+1 intersecting two edges to be collapsed in one implant sprays simplification batch are disjoint. ( <ref type="figure" target="#fig_5">Figure 5</ref>) 2. For each edge e = (v 1 , v 2 ) that will be collapsed and a vertex w that is incident to both v 1 and v 2 , the triple (v 1 , v 2 , w) must define a valid face of T i+1 . <ref type="figure" target="#fig_6">(Figure 6</ref> a) 3. For each edge e = (v 1 , v 2 ) that will be collapsed and two vertices w 1 ,w 2 such that the triangles (v 1 , w 1 , w 2 ) and (v 2 , w 1 , w 2 ) are faces of T i+1 , the quadruple (  Thus during progressive mesh construction, the simplification process must select sets of edge collapses of maximal size that form a simplification step T i+1 → T i according to the requiremenst mentioned above. In our current implementation independent edge collapses are selected greedily, see also Algorithm 2 in Section 5. Our experiments suggest that in practical situations k is in the range of 12 to 16 for the very restrictive selection of edge collapses mentioned above. A less restrictive selection of edge collapses would allow an even larger fraction V i / k of split-vertices. The average number of nearly 6 removed tetrahedra per edge collapse results in a split-vertex encoding with less than 3 bits per tetrahedron.</p><formula xml:id="formula_2">v 1 , v 2 , w 1 ,<label>w</label></formula><p>Additional geometric properties and constraints of edge collapses assure that the simplified tetrahedral meshes are good approximations of the initial tetrahedralization. However, these constraints are not the subject of this paper and the interested reader is referred to <ref type="bibr" target="#b12">[11]</ref> for further details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION</head><p>The main problem of an actual implementation is the construction of the sequence of increasingly simplified meshes T lmax , …, T 0 , or levels of detail (LODs), such that each set of edge collapses C i that forms one simplification step T i → T i-1 can unambiguously be encoded using the techniques described in the previous section. The simplification and encoding procedure EncodeOneStep() is iteratively called by the main encoding loop of Algorithm 1 for the current tetrahedral mesh starting with the best LOD T lmax . After arriving at a sufficiently simplified and small mesh T 0 , a simple single-resolution encoding can be used for this base mesh. The encoding of the crude mesh T 0 followed by popping the codes from the stack obtained by the EncodeOneStep() procedure calls builds the input data stream for the decoding procedure. The procedure EncodeOneStep(), performs one simplification step T i → T i-1 at a time and provides the respective encoding of the vertex splits on a stack. The first foreach-loop in Algorithm 2 over all edges of a mesh T i can be ordered according to an increasing simplification error of edge collapses as used in <ref type="bibr" target="#b12">[11]</ref>. Validation of edge collapses is performed by the validCollapse() procedure according to the constraints described in the previous section. Next, the method mesh.collapseEdges() performs the actual simplifications, and stores the vertex split information for every edge collapse with its respective vertex. The following foreach-loop traverses the vertices of the simplified mesh T i-1 in the inverse order of the decoding process, and marks all vertices with one bit. For the marked split-vertices the associated cut-faces code is given as well. All codes are pushed on a code stack such that popping the codes from that stack provides the correct sequence for the decoding process and its traversal of vertices. </p><formula xml:id="formula_3">v 1 v 2 w v 1 v 2 w 1 w 2 a) b)</formula><p>Decompression involves first decoding the crude mesh T 0 according to the chosen single-resolution encoding method, and then traversing the vertices of the current LOD and simultaneously reading marking bits and vertex split information from the input data stream to create the implants sprays refinement updates. In Algorithm 3 the method mesh.simpleDecoding() performs the task of reading and constructing the base LOD T 0 . The following while-and nested foreach-loops repeatedly traverse the vertices of the current mesh. While traversing the vertices of T i , the marking bits indicate the occurrences of vertex split refinement operations.If a marking bit signifies a split-vertex the respective vertex split information, the encoding of the cut-faces, is read from the input data stream by the readCutFacesCode() method in Algorithm 3. The individual vertex splits can emmediately be performed to refine the current mesh. However, note that the so newly created vertices should not affect the current vertex traversal order of T i , and that these new vertices should only be included in the vertex traversal of the next LOD T i+1 .  The marking of vertex splits is already shown in above algorithms, the cut-faces encoding depends heavily on the data structure used for maintaining a tetrahedral mesh and is described in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RESULTS</head><p>We have implemented the simplification and encoding algorithms mentioned above in a prototype system. Even though the encoding of enumerated cycles performed well in terms of coding costs, the current implementation was unreasonably slow. Therefore, we have only included results for encoding the cut-faces as walks on a planar triangular mesh. Note that the results presented here do not include an encoding of the base mesh T 0 .</p><p>With an average of 6 incident tetrahedra per edge we can conclude that a split-vertex has about 15 incident vertices. Therefore, we can expect to encode the start vertex of a skirt using roughly 4 bits, which is also supported by our experiments. The encoding of the skirt is completed by specifying a path of edges of length 6 on average, where the path could take 5 different directions at each vertex, thus requiring about 14 bits. The encoding of the split-vertex depends on the fraction of vertices which can be split in every batch. This ratio can be bounded by the size of an independent set, which for general graphs depends on the number of incident edges per vertex. In the case of tetrahedral meshes this number is about 15. Thus for every marked split-vertex we will waste about 14 zero-bits for unmarked vertices. Note that our experiments show a much better selection rate for the turbine data set. <ref type="table" target="#tab_3">Table 1</ref> presents results for a real world data set, the turbine, and a Delaunay tetrahedralization <ref type="bibr" target="#b1">[2]</ref> of a random point set. For the turbine data set an average of k = 5.77 tetrahedra were removed with every edge collapse in 49 simplification steps, whereas the random tetrahedralization reported 6.25 tetrahedra per edge collapse in 54 LODs. Overall, the connectivity of the tetrahedral meshes was encoded with less than 6 bits per tetrahedron which includes a large number of different LODs that are progressively available during decompression time. <ref type="figure" target="#fig_8">Figure 7</ref> shows the turbine volume data set that was used in our experiments. The volume data consists of solid turbine blades <ref type="figure" target="#fig_8">(Figure 7 a)</ref> and a large number of sampled data points in between the blades. All vertices of the surface of the turbine blades <ref type="figure" target="#fig_8">(Figure 7 b</ref>) and the data points are represented in one large tetrahedral mesh <ref type="figure" target="#fig_8">(Figure 7 c)</ref>. For the very common approach of storing the turbine mesh as a set of indexed tetrahedra, the connectivity cost requires 13MB in ASCII and still 4.7MB using a simple binary encoding. The Grow &amp; Fold method <ref type="bibr" target="#b19">[17]</ref> cuts this cost down to 492KB for a single-resolution representation, whereas the method presented in this paper only requires 87KB for representing the base mesh T 0 1 and 291KB for the 49 refinement steps.</p><p>1. i.e. using the grow and fold single-resolution encoding data set LODs vertices  </p><formula xml:id="formula_4">T T T T lmax vertices T T T T 0 tetrahedra T T T T lmax tetrahedra T T T T</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>The presented implant sprays method presented in this paper is a simplification, storage and transmission technique for tetrahedral meshes. Implant sprays provides a progressive tetrahedralization, starting from a crude base model, at significantly lower storage or transmission costs than previously known methods. It even improves connectivity encoding on the best known single-resolution tetrahedral mesh compression method <ref type="bibr" target="#b19">[17]</ref>. The low coding cost is achieved by grouping vertex splits into batches, called the implant sprays, and by a concise encoding of the skirt, the cutfaces of a split-vertex. Compressed multiresolution tetrahedral meshes can be used for cooperative scientific visualization, fast exploration of volumetric data sets, or provide different LODs for interactive visualization.</p><p>Combining the implant sprays simplification procedure with an edge collapse error measure for tetrahedral meshes <ref type="bibr" target="#b12">[11]</ref> provides an efficient mesh encoding of a progressive multiresolution tetrahedralization. Note that only the split-vertex encoding depends on the fraction of selected edge collapses in every batch. Based on our experience with triangular meshes <ref type="bibr" target="#b7">[8]</ref> we can expect that an error driven edge collapse selection does not lead to a worse split-vertex encoding in tetrahedral meshes.</p><p>Future work includes efforts to reduce the edge collapse selection constraints to increase the vertex split rate, thus lowering the split-vertex coding costs, while still guaranteeing locally unambiguous mesh updates. Furthermore, we will also investigate faster k-cycle enumeration and coding techniques to improve on the cutfaces encoding. However, the optimization in connectivity cost is far less important than inventing an efficient coordinate geometry compression method for tetrahedral meshes.</p><p>Because the connectivity cost of a tetrahedral mesh is less than 6 bits per tetrahedron using implant sprays, it is no longer the dominant cost factor. In contrast, uncompressed floating point coordinates now take up most of the storage space with at least 96 bits per vertex, or 18 bits per tetrahedron. However, the progressive encoding of the topological mesh connectivity allows for efficient coordinate compression as it is already exploited in triangular meshes. Based on the local mesh connectivity and geometry around a split-vertex, the displacement vector can be encoded using predictive error compression techniques <ref type="bibr" target="#b6">[7]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Edge collapse and vertex split for triangle mesh simplification and reconstruction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Edge collapse and vertex split for tetrahedral mesh simplification and reconstruction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>a) The orbital of a split-vertex v consists of all faces of tetrahedra surrounding v that are not incident to v . b) The cut-faces form a ring of triangles, also called the skirt.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>a) Shows a planar embedding of the triangular graph G orb of the orbital surface b). The boundary of the cut-faces, forming a cycle in the planar graph a), is highlighted using thick lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 .</head><label>5</label><figDesc>2 ) must define a valid tetrahedron of T i+1 .(Figure 6b) Independent edge collapses may not have common incident tetrahedra. The figure shows an analogous case in a 2D triangulation with two selected edge collapses. All faces of the forbidden area must not be incident to another edge collapses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 .</head><label>6</label><figDesc>Examples of non-valid edge collapses, where a) fails test number 2 and b) fails test number 3 of the constraints mentioned above.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 3 .</head><label>3</label><figDesc>Pseudocode for the main decoding algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 .</head><label>7</label><figDesc>Pictures a) and b) only show the solid turbine blades parts of the tetrahedralized volume data set in c) which was used in our experiments. Note that the rim where the blades are mounted on is not shown in images a) and b). (Data set courtesy of AVS Inc.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>0 edge collapses start vertex loop split- vertex total bits bits per tetrahedronTable 1 .</head><label>1</label><figDesc>Encoding results for the turbine data set and a Delaunay tetrahedralization of a random point set in space. The start vertices have been encoded with roughly 4 bits, and the cut-faces using about 15 bits for every edge collapse. The marking of all vertices in each LOD resulted in an amortized cost of 10.35 bits per edge collapse for specifying the corresponding split-vertex.</figDesc><table><row><cell cols="6">turbine 49 106795 24550 576576 101619 82245 4.14 14.5 10.35 2384643 5.020755</cell></row><row><cell>random 54 10000</cell><cell>928</cell><cell>66487</cell><cell>9799</cell><cell>9072</cell><cell>4.19 15.69 16.2 327386 5.775230</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported by the Swiss NF grant Nr. 81EZ-54524 and US NSF grant Nr. 9721358. We would like to thank Oliver Staadt for providing the turbine data set.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Geometry compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIG-GRAPH 95</title>
		<meeting>SIG-GRAPH 95</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Three-dimensional alpha shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">P</forename><surname>Mucke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="72" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Constructing Hierarchies for Triangle Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Gieng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Schussman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">J</forename><surname>Trotts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="145" to="161" />
			<date type="published" when="1998-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Real time compression of triangle mesh connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Mesh optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 93</title>
		<meeting>SIGGRAPH 93</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIG-GRAPH 96</title>
		<meeting>SIG-GRAPH 96</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Digital Image Compression: Algorithms and Standards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Kluwer Academic Publishers</publisher>
			<pubPlace>Norwell, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Compressed progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<idno>GIT-GVU-99-05</idno>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
		<respStmt>
			<orgName>GVU Center, Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Progressive simplicial complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Popovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 97</title>
		<meeting>SIGGRAPH 97</meeting>
		<imprint>
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Acm</forename><surname>Siggraph</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Edgebreaker: Compressing the incidence graph of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<idno>GIT-GVU-98- 17</idno>
		<ptr target="http://www.cc.gatech.edu/gvu/reports/1998" />
		<imprint>
			<pubPlace>Atlanta, GA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>GVU Center, Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics)</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Progressive tetrahedralizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">G</forename><surname>Staadt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization 98</title>
		<meeting>Visualization 98</meeting>
		<imprint>
			<biblScope unit="page" from="397" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Progressive forest split compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SIGGRAPH 98</title>
		<meeting>SIGGRAPH 98</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Geometric compression through topological surgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="115" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">3D geometric compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Siggraph 98 Course Notes 21. ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Triangle Mesh Compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Graphics Interface 98</title>
		<meeting>Graphics Interface 98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Simplification of tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">J</forename><surname>Trotts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Wiley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization 98</title>
		<meeting>Visualization 98<address><addrLine>Los Alamitos, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE, Computer Society Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="287" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Grow &amp; Fold: Compression of tetrahedral meshes. to appear in Solid Modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
