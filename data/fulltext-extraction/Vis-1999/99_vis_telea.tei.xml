<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Simplified Representation of Vector Fields</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandru</forename><surname>Telea</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarke</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Simplified Representation of Vector Fields</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Flow Visualization</term>
					<term>Simplification</term>
					<term>Clustering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Vector field visualization remains a difficult task. Although many local and global visualization methods for vector fields such as flow data exist, they usually require extensive user experience on setting the visualization parameters in order to produce images communicating the desired insight. We present a visualization method that produces simplified but suggestive images of the vector field automatically, based on a hierarchical clustering of the input data. The resulting clusters are then visualized with straight or curved arrow icons. The presented method has a few parameters with which users can produce various simplified vector field visualizations that communicate different insights on the vector data.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Visualization of vector data produced from application areas such as computational fluid dynamics (CFD) simulations, environmental sciences, and material engineering is a challenging task. Even though many vector data visualization methods have been developed and are in widespread use, gaining insight in complex vector fields is still difficult. In comparison with scalar data, vector fields have an inherently higher complexity and therefore pose understanding and representation problems which are more difficult to address.</p><p>As vector datasets obtained from simulations grow increasingly larger and as they have often to be presented to non-specialized audiences, there is a demand for methods that display in an effective and compact manner, such that insight in the global behavior and also a good understanding of local effects is quickly obtained. A good inspiration for such visualizations is commercial imagery displaying fluid flow or weather forecasts which convey the flow information in an intuitively understandable way using a few simple but suggestive icons, combined with a well chosen background. It would be desirable to have a method to produce such visualizations automatically from flow datasets. However, the most usual actual procedure requires a strong input from human users that have to construct the simplified visualization by tuning a multitude of parameters in a visualization package or manually place icons or probes such as streamline starting positions.</p><p>We present a compact visualization method for vector fields which produces simplified flow displays automatically. The user intervention is limited to a few parameters which allow an intuitive control of the look or complexity of the resulting image. Our method combines several ideas from existing visualization techniques, outlined in Section 2. Section 3 presents the method. The behavior of the presented algorithm under various input is outlined in Section 4, and its implementation and integration in an end-user environment is presented in Section 5. We conclude the paper with further research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>Although effective, existing methods for flow visualization still have limitations. There are several problems involved with them:</p><p>1. Although such methods generate richly detailed and shaded pictures, the process of generating them can be timeconsuming and intricate to set-up and control. Considerable trial and error and knowledge of the techniques' implementation is required to produce images that communicates the desired insight. Methods that generate such images automatically or with minimal user intervention would thus be highly useful.</p><p>2. Users must take subjective decisions while producing a visualization, e.g. which streamline start positions to select, how fine to sample a field plotted by a hedgehog, what colormap to use, etc. Visualizations in which users can and have to control all these parameters are prone to miss important aspects in the data due to uninspired tuning of these parameters.</p><p>3. Dataset aspects can be missed also when observing a visualization if there is too much or poorly structured information presented. Arrow plots show for example all the dataset information but are often hard to interprete visually.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>Datasets such as those produced from CFD simulations grow larger and larger, exceeding the visualization software capabilities and the the observation power of the users viewing them.</p><p>Numerous techniques have been developed for flow visualization. However, the above problems are usually only partially addressed. The most ubiquitous flow visualization method uses hedgehogs or similar glyphs. Hedgehog plots are intuitive but impractical for large 2D or 3D datasets due to the visual difficulty to perceive dense arrow renderings. Although subsampling can be used to reduce the arrow count, this often introduces visual artifacts and may not provide the best arrow distribution to convey insight in the dataset. For example, the hedgehog visualization in <ref type="figure" target="#fig_0">Fig. 1 a)</ref> is unclear in the region where the flow field exhibits a bifurcation. To avoid such problems, flow visualizations such as commercial advertisements or weather forecasts that must convey insight to a more diverse and often untrained audience are produced manually by a placing a few glyphs (e.g. curved arrows) over the flow regions where something 'interesting' happens. Other global techniques include texture-based methods such as spot noise and line integral convolution <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref>. Although these give good local insight and global coverage, they don't show the flow direction (see <ref type="figure" target="#fig_0">Fig. 1 b)</ref> and thus may be difficult to interpret for spatially rapid changing flows.</p><p>Advection based techiques such as streamlines, streamtubes, particles, or flow ribbons <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b7">8]</ref> give good local insight, but require strong input from the user (e.g. the positions to advect from), so are less adequate for getting a global impresion of a flow.</p><p>Vortex and feature extraction techniques <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b0">1]</ref> simplify large flow datasets efficiently into a few features that are eventually tracked in the time dependent cases <ref type="bibr" target="#b6">[7]</ref> and displayed using various iconification methods. Although compact, such techniques often require user knowledge to e.g. set various parameters to control feature detection and tracking. Since feature extraction methods convey insight in a particular flow feature, which is identified and then specifically tracked, they may be ineffective in producing a global flow picture. The above can be said also about visualization tools based on selection expressions <ref type="bibr" target="#b10">[11]</ref>.</p><p>Topological field analysis <ref type="bibr" target="#b3">[4]</ref> is an excellent, ideally automatic way to produce compact and mathematically insightful flow representations. The produced visualizations are however sometimes too abstract to be directly interpretable by non-specialists and can be unstable for fields with many critical points.</p><p>As the quality of user-steered visualizations may depend on a good guess of the steerable parameters, some work was targeted at automated visualization. However, the most widespread metaphor remains the interactively steerable visualization system in which the user experiments with different visualization techniques and parameter settings to visually fine tune the rendering until the desired images are obtained.</p><p>Visualization methods can be applied either directly on the datasets, or on simplified datasets. Simplified datasets contain less data points so visualizing them generates less visual problems such as cluttering. The flow features of interest must however be recognizable in the simplified datasets. Multiresolution techniques such as Fourier or wavelet based methods <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b13">14]</ref> represent datasets as hierarchies with different levels of detail. However useful, such methods simplify the entire domain uniformly so they can not produce visualizations containing both global and detailed information in various parts of the same image.</p><p>The challenge we identify is to generate insightful flow visualizations as automatically as possible offering a good local insight, global coverage, directional insight, and overall a simple and intuitive perception of the flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Simplification</head><p>Our aim to produce intuitive flow visualizations automatically from a flow dataset exploits the observation that (curved) arrow plots, like the ones used by weather forecasts or commercial imagery are easy to interpret: an arrow carries a visually unambiguous representation of the direction and curvature of the flow over the region covered by and immediately around its drawing. A second observation is that most of the visualizations of the above mentioned types use a few large arrows to indicate the main directions of the flow and optionally small, detail arrows to depict local behaviour. The large arrows have a stronger visual impact and thus communicate the important flow attributes quickly to the spectator by visually filling in a larger space on the illustration, while the smaller arrows cover only smaller illustration areas, and thus have a limited and well confined visual impact. The same separation of information visualization in larger, structurally more important elements and smaller detail elements can be also seen in the construction of urban maps, for example. In our case, our goal can be summarized as 'represent a given vector field with a given arrow count in the most suggestive manner'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithm Principle</head><p>To model the above we use the cluster concept. We define a cluster as a connected subdomain of a flow dataset on which the flow is approximated for visualization purposes by a single (curved) arrow, called the cluster's representative. We visualize a flow dataset on a given domain by covering that domain with a (small) number of clusters such that their representatives are as close as possible to the given field's vectors. For the time being, we shall assume that the representatives are straight arrows, so every cluster carries actually a vector.  Our input is a vector field given as a mesh of cells with one vector per cell. Datasets with node vector data can be easily converted to cell data by averaging the node data over cells. The clusters are in this case connected sets of cells, so two clusters are neighbors if they contain cells that are neighbors, i.e. share an edge in 2D or face in 3D. We start creating one initial cluster from every dataset cell, having the cell's vector data as its representative, with the origin in the cell's center. Next, we perform a bottom-up clustering algorithm by repeatedly selecting the two most resembling neighboring clusters and merging them to form a larger cluster until a single cluster emerges which covers the whole given domain and represents it by a single arrow. The algorithm produces a binary cluster tree with the initial clusters as leaves and the root as the final cluster covering the To remember at which stage of the clustering a given cluster was produced, every cluster in the tree has a level attribute. This information will be used for the visualization of the clustered data described in Section 4. Leaves have level 0, while the level of other nodes is computed from an integer incremented during the clustering algorithm. Since we use binary clustering, the algorithm will do N , 1 steps and the root's level will thus be N , 1, where N is the number of cells in the initial dataset. The pseudocode for the clustering algorithm is shown in <ref type="figure" target="#fig_2">Fig. 2</ref>. After the clustering is completed, we can easily examine the dataset at a simplification level l by displaying only the clusters with levels smaller or equal to l with parents having levels greater than l. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Similarity Evaluation and Cluster Merging</head><p>The clustering algorithm is driven by two main elements: the cluster similarity function, i.e. how we find the best clusters to merge, and the merging operation itself, i.e. how a new cluster is made by merging two existing ones. We present first the similarity function and then the merging procedure. The similarity function evaluates how similar two clusters are, and thus gives implicitly an estimate of the representation error one would get by merging them. This is so since two identical clusters, i.e. with equal representatives and sizes, can be obviously merged with no error into a larger cluster with the same representative. We compare clusters by comparing their representative vectors so we do not explicitly use the clusters' shapes. We split the comparison of these vectors into two parts: the direction and magnitude comparison and the position comparison.</p><p>To estimate the direction and magnitude similarity, we introduce first the notion of iso-error contours. Given a 2D vector v of length l taken along the x axis for simplicity, we define an iso-error contour of a given value as being the locus of the apexes of all vectors w with the same position as v that are equally similar to v. The position difference will be treated separately. Based on the remarks starting this section, we would like the similarity function to acount for similar directions, so we model the iso-error contours as ellipses with the grand axis aligned with v and centered along v at a distance c from its apex <ref type="figure" target="#fig_5">(Fig. 4 a)</ref>. The ellipse's size (half-axes a; b) and center-tovector apex distance are functions of the error magnitude such that larger ellipses having the same aspect ratio correspond to larger error magnitudes. For example, in <ref type="figure" target="#fig_0">Fig. 4 b w1 and w2</ref> are equally similar to v, but more similar than w3, since w3's apex is on a larger iso-error elliptic contour.</p><p>As outlined, the parameters a; b; c of an elliptic contour are increasing functions of the contour's error t. We can model such a contour by an equation fx; y; t = 0 with fx; y; t = x , ct</p><formula xml:id="formula_0">at 2 + y bt 2 , 1<label>(1)</label></formula><p>and the parameters a; b; c by linear functions of t at = t bt = t</p><p>(2) ct = l + t Solving fx; y; t = 0 for t leads to a second-order equation in t.</p><p>We impose the condition t 0 since we are interested in positive error values and we find t as a function of x; y, the vector length l and the coefficients ; ; . </p><formula xml:id="formula_1">t = q x , l 2 + 2 2 y 2 2 , 2 + 2 x , l 2 2 , 2 , x , l 2 , 2<label>(3)</label></formula><formula xml:id="formula_2">= 2 l = l (4) = l</formula><p>Note however that must be greater than , otherwise the ellipses intersect each other and thus do not represent iso-error contours of a well-defined error function.</p><p>The above compared only the vectors' sizes and directions. To compare the vectors' positions, we use the same idea of error isocontours, but this time around the vector's position. For example, w1 and w3 in <ref type="figure" target="#fig_6">Fig. 5</ref> are equally similar to v from their positions' viewpoint as these are on the same iso-error contour, while w2 is less similar, its position being situated on a larger iso-error contour.</p><p>If we denote w's position by xs; y s, the iso-error contours around the reference vector v's position are defined as ellipses described by sxs; y s = 0 , where s is given by:</p><formula xml:id="formula_3">sxs; y s = x 2 s d 2 + y 2 s e 2 , 1<label>(5)</label></formula><p>The value of s gives thus the dissimilarity between the positions of the two involved vectors. The coefficients d and e control the ellipse's aspect ratio and size. To model position similarity, it is useful to let the elliptic iso-error contours' aspect ratio under the user's control. For instance, an aspect ratio d=e of 3:1 favorizes clustering along the vectors' directions, one of 1:3 tends to cluster orthogonally to this direction, while a 1:1 aspect ratio favorizes all clustering directions equally, all other parameters being the same.</p><p>The functions tx; y and sxs; y s give the distance in our error space between two vectors' directions and magnitudes, and positions respectively. We can define the similarity of two vectors as any monothonically increasing function of t and s since these are independent quantities. A good candidate is a linear combination ls; t of s and t:</p><formula xml:id="formula_4">ls; t = As + 1 , At<label>(6)</label></formula><p>where the coefficient A can be used to favor clustering on similar directions and magnitudes, repectively similar positions. The similarity function l is not a distance in the strict mathematical sense (it is not symmetric since the ellipses used are sized on just one of the two vectors v1; v 2 that we compare). To make l (seen now as a function of v1; v 2) symmetric, we simply replace it by l 0 v1; v 2 = lv1; v 2+lv2; v 1. When the algorithm decides to merge two clusters using the presented similarity function, it creates a new cluster containing the union of the merged clusters' cells. Its representative vector is computed as an area-weighted (in 2D) or volume-weighted (in 3D) average of the merged clusters' representative vectors. The same is done for the representative vector's position, which coincide thus always with the cluster's gravity center. In most cases, the similarity function will generate convex clusters. However, we don't impose explicit geometric constraints on the cluster shape, so concave clusters having the gravity center outside their perimeter may appear.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Effect of Parameters</head><p>The original challenge was to generate insightful flow visualizations automatically by displaying a simplified flow. However, since different users may be interested in different aspects of the same flow, it is conceptually hard to generate a unique flow simplification method satisfying all users. In this sense, our algorithm has three control parameters. Varying these parameters one can produce a large range of visualizations emphasizing on various aspects of the flow data. These parameters are described in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Level of Detail</head><p>The presented algorithm produces a hierarchical cluster structure which describes the flow dataset at different detail levels. Visualization of the clusters is however independent on their construction. We can obtain better results if instead of plain arrows we display curved arrows, by computing streamlines from every cluster's center up and downstream and capping them with arrow hats. Using curved arrows (e.g. represented by splines) as cluster representatives would be a step further, as the clustering process itself and not just the final visualization would be driven by the curved arrow model. A second observation is that the cluster visualization, similarly to iconic visualization, is effective when only a few icons (e.g. curved or straight arrows) are displayed to show the main structure of the flow. On the other hand, texture-based visualizations as spot noise are effective in showing flow local details with an equal emphasis over the entire domain. We combined the two visualization methods by superimposing the curved arrows generated by the clustering over a spot noise texture (see <ref type="figure">Fig. 7</ref> for a couple of examples). Combining curved arrows with spot noise textures can increase the overall clarity of the visualization, especially for more complex flows for which the generated textures tend to be noisy and thus visually unclear <ref type="figure">(Fig. 7 d)</ref>. Spot noise textures can be also effectively combined with 3D curved arrow visualizations, as shown in <ref type="figure" target="#fig_0">Fig. 12</ref> e where a semi-transparent spot noise textured 2D slice adds a spatial clue to the otherwise hard to perceive 3D curved arrow rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Clustering Parameters</head><p>At the core of the clustering algorithm, the decision to merge clusters is taken by the vector similarity function presented in Section 3. shows the same vector field simplified with a small B value which favors clustering orthogonally to the vector field's direction. Users interested in the main flow directions would employ small values of A and B, as the two strengthen each other in producing clusters over which vectors having similar directions. For datasets exhibiting both laminar and high vorticity flow, this setting generates clusterings that may contain very large, respectively very small clusters in the same image. Although this conveys both global and detail information in the same image, displaying both very small and large arrow icons may sometimes be undesirable due to their high visual non-uniformity. If this is not desired, the A parameter can be increased to favor more uniformly-sized clusters. At the other extreme, users comfortable with hedgehog-like visualizations that uniformly sample the whole domain can obtain similar images by using high values of A and B. We see this ability to easily select the type of visualization by continuously interpolating between Similarly, our method can be seen as combining the advantages of fully interactive visualization systems where the user is responsible for all the parameter settings and gets no system assistance and fully automated ones, where the user can not influence the system's heuristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>The clustering algorithm has two main phases (see <ref type="figure" target="#fig_2">(Fig. 2)</ref>. First, a list of all the possible cluster pairs ci; c j that can be merged has to be produced. Since primary clusters are created from the dataset's cells and since clusters are allowed to merge only with neighbor clusters, we maintain for every cluster a list of its neighbor clusters throughout the algorithm to efficiently find the merge candidates of a cluster by scanning only its neighbors. Initially, the primary clusters get their neighbors using the cell neighboring information available from the input dataset in ON time, where N is the number of cells in the dataset. The input dataset can be either a structured or unstructured mesh since cell neighbouring information can be easily computed for any mesh type.</p><p>The second phase of the algorithm involves an iteration-merge pass over the cluster-pairs list created initially, until this list contains a single cluster. Using a hash-table of pairs which keeps its contents in increasing order of the clustering error allows us to find the next pair to merge in O1 time. As insertion of new cluster pairs in the hash-table is OlogN, we can show that the second phase has a cost of maximum ONlogN. The clustering has thus an overall cost of ONlogN.</p><p>The cluster-pair list often contains several cluster-pairs with the same clustering error. Since the domain to be clustered consists of a finite grid of finite size cells, the clustering is sensitive to which of the above pairs it picks first, since, as two clusters are merged, this influences their neighbors' chances to merge, and so on. This can be sometimes observed in the final image as regular cluster patterns which have nothing to do with the data but emerge from the clustering order. To remove this unpleasant effect, we included an option to permute the initial cluster-pair list randomly (shuffle) which maximizes the chances that clustering starts from several points randomly distributed over the whole domain.</p><p>We implemented the presented algorithm as a collection of classes written in the C++ language and integrated them with the Visualization Toolkit (vtk) package. Vtk is a powerful, comprehensive scientific visualization library which conveniently provided the data structures needed for flow data representation and manipulation. Next, we integrated our classes in the <ref type="bibr">VISSION</ref>   <ref type="figure" target="#fig_0">(Fig. 11 a)</ref> similar to systems like AVS <ref type="bibr" target="#b9">[10]</ref> or Data Explorer, steer the clustering parameters by means of GUIs <ref type="figure" target="#fig_0">(Fig. 11 b)</ref>, and monitor the results interactively in 3D cameras <ref type="figure" target="#fig_0">(Fig. 11 c)</ref>. The clustering itself takes a few seconds for datasets around 10000 cells like the ones shown in this paper's illustrations, while selecting the level of detail to display is done in real time on a SGI O2 R5000 machine. Simplification of 3D flow fields as those presented in <ref type="figure" target="#fig_0">Fig. 12</ref> b-e is however considerably slower, as these contain more cells, each having a higher neighbor count. By connecting the 'level of detail' input port of the simplification pipeline to an iterator which dynamically varies an integer value and its output to a MPEG production module, one can easily produce a simplification MPEG animation displaying a progressively simplified view of a given flow dataset. Animated visualizations of the progressively simplified data are however not always an appropriate manner to convey insight in a vector field. This is caused by the fact c b a <ref type="figure" target="#fig_0">Figure 11</ref>: Clustering pipeline and visualization in the Vission system that, as clusters get progressively merged, their representative arrows may be replaced by new arrows having sensibly different sizes and positions. Especially at the top of the hierarchy where large clusters get merged one may notice 'jumping arrows' between consecutive simplification frames corresponding to consecutive simplification hierarchy levels. This is basically due to the fact that the presented clustering algorithm tries to minimize the representation error at each individual hierarchy level but does not explicitly try to preserve a visual coherency between the visual representations (e.g. arrow icons) of consecutive hierarchy levels. Doing this would involve a totally different definition of the cluster similarity function, which should encompass both a comparison with spatial neighbor clusters and with parent and child clusters in the hierarchy. We believe that the added complexity for devising and efficiently implementing such a similarity function would not pay off as compared to its possible advantages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>This paper presented a new method for producing compact vector field visualizations using a hierarchical simplification of the vector data. The simplification is driven by a vector similarity function the parameters of which can easily be tuned to produce visualizations which stress different aspects of the vector field. After the simplification is done, one can visualize the vector data at different levels of detail by interactively choosing the simplification level to be displayed. For the display phase, we used straight or curved arrows for the simplified data over a spot noise textured background that fills the visual gaps between the arrows with local detail. We have in-tegrated our method in an interactive dataflow visualization system where one can change the parameters influencing simplification and monitor the resulting images interactively.</p><p>Put in mathematical terms, we try to approximate a vector field by a (small) hierarchical set of constant basis functions of finite supports whose union equals the field's support. The basis functions' supports are the clusters and their values are the clusters' representative vectors. The shapes of the basis functions' supports are determined such that the representation error is minimized (this is actually the clustering algorithm). The main difference between our approach and other representation techniques reducible to basis functions such as Fourier analysis or wavelets is that we do not prescribe a priori the shape of the basis functions' supports, but determine it by a minimization process. In this respect, the presented technique does not use a given set of basis functions (like the sine and cosine functions used by the Fourier analysis or the polynomial basis functions used by spline techniques) but computes a different base for each new given input dataset.</p><p>To completely automate our technique we plan to devise a method of setting the simplification parameters that are now still under the end-user's control, based on a model of the user's perception of a vector field. Such a method should be able to determine how to produce the most insightful or most easily perceivable visualizations and act as a feed-forward control on the presented simplification. In the same time we plan to devise better models for the clusters which should approximate the underlying field more accurately, e.g. by using a curved arrow model based on splines. On one hand, the introduction of such techniques would simplify the task of the user considerably by producing perceptually meaningful visualizations with a minimal or no direct user intervention. On the other hand, animations that show progressively simplified views of the same dataset on the outline of the idea sketched in Section 5 would be easier to produce, as a perceptually based simplification could guarantee a certain coherency among several simplification levels of the same dataset. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Flow visualized with hedgehog (a) and spot noise (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>ClusterSet s; for (all cells cell i in dataset) { c = makeCluster(cell i ); set level of c to 0; add c to s; } for (all clusters c i in s) for (all clusters c j neighbours of c i ) { e = clustering_error(c i ,c j ); insert pair (c i ,c j ) in increasing order of error e in a hash−table; mark c i and c j as NOT_CLUSTERED; } int l=0; for (all pairs (c i ,c j ) in increasing order of error in the hash−table) if (both c i and c j are NOT_CLUSTERED) { c = mergeClusters(c i ,c j ); set level of c to l++; mark c i and c j as CLUSTERED; for (all neighbours n i of c) { e = clustering_error(c,n i ) insert pair (c,n i ) in order in hash−table; } } return c as root of tree;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Clustering algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Clustering algorithm example whole domain. Merging two clusters produces a new cluster covering the union of its parents and having a representative computed by averaging its parents' representatives. Initial clusters represent thus the dataset exactly, while clusters higher in the tree have higher representation errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3</head><label>3</label><figDesc>shows the 16 steps taken by the algorithm on a hypothetical 4x4 2D regular grid and the produced cluster tree.The algorithm's key is the evaluation of the similarity of two clusters (function clustering error in the pseudocode) and the merging procedure mergeClusters. The fact that neighbor clusters are merged in the increasing order of this error function, i.e. in decreasing order of similarity, ensures that the obtained clustering minimizes the representation error, which is thus known at all levels. These operations are presented in the next Section.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Elliptic similarity function</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Given a vector w=[x; y], the dissimilarity as compared to the x axisaligned vector v=[0; l ] is thus t computed with the above expression. Suitable values for the coefficients ; ; are based on a heuristics saying how the error iso-contours change as the error increases. A possible setting that relates these coefficients to the vector's length Vector position similarity function l and creates ellipses with an aspect ratio of 1:2 is given by:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>For a level l, the dataset is represented with N,l clusters, where N is the initial number of dataset cells. This hierarchy allows us to easily create visualizations that answer the question "display the flow by showing its F most prominent features", by selecting the N , F th hierarchy level and displaying one flow icon per cluster. Since the flow over a cluster is approximated by the cluster's representative vector, we can directly visualize clusters by rendering their representative vectors in a hedgehog style, using the cluster size to control their magnitude. Figure 6 and Fig. 12 a show the same flow presented in Fig. 1 and a circular vortex flow, visualized with different numbers of vectors. Figures 12 b-e show simplifications of a 3D field similar to the 2D one in Fig. 1 rendered from several viewpoints and with several numbers of arrows and arrow thicknesses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>2 .Figure 6 :Figure 7 :</head><label>267</label><figDesc>The clustering process can be controlled by changing several parameters. For example, ; ; (Equation 4) influence the way we compare the vectors' directions and magnitudes; d; e (Equation 5) influence the way we compare the vectors' positions, while A (Equation 5) controls the overall interest we have in comparing directions and magnitudes versus comparing the vectors' positions.Two of the above parameters have an important influence on the clustering, namely the parameter A and the ratio B = d=e of the d and e parameters, normalized by imposing d + e = 1 . By changing the A and B parameters, we can produce several visualizations Visualization of two flow datasets at various simplification levels Flow visualizations using curved arrows on spot noise textured backgrouds communicating different insights on the input flow data. We found it useful to leave these parameters under the direct control of the enduser, as different users or the same user with different datasets may wish to perform different simplifications.Figure 8 shows several clusterings of the fork flow, for several values of the B and A parameters varying from 0 to 1 on horizontal, respectively on vertical, and displaying the same number of vectors. To get a better impresion of the clustering, we displayed also the cluster of each vector using different colors. This figure shows several aspects. Small values of A favor clustering of vectors with similar directions (table upper rows), and thus produce a subdivision of the original square domain into pie-like sectors, as the vectors' direction varies the least along a radius of the vortex. Small values of B favor clustering orthogonally to the vectors' directions (table left columns). The two effects strengthen each other in the upper-left table corner, where the images show clusters having borders almost perfectly aligned orthogonally on the vector field. Large values of A favor clustering of vectors with similar positions (table lower rows), and thus produce a domain subdivision into clusters with similar size. Large values of B favor clustering along the vectors' direction (table right columns). The two previous effects strengthen each other in the lower-right table corner, where the clustering resembles an almost regular subdi-vision. The extreme combinations of the A and B parameters are also illustrated for the vortex flow simplification in Fig. 9. The effects of the parameter B on the clustering direction can be clearly seed in Fig. 10. Figure 10 a shows a simplification of a nearly constant vector field done for a large value of B which favors clustering along the vector field's direction. In contrast to this, Fig. 10 b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>5 AFigure 8 :</head><label>58</label><figDesc>Fork flow simplification for several A and B values the mentioned extremes as an important advantage of the presented method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>interactive vi-Vortex flow simplification for several A and B values Constant flow simplification that favors clustering along the vector field direction (a) and across the vector field direction (b) sualization environment [9]. VISSION's open object-oriented architecture allowed us to easily couple our clustering pipeline's output to its available 3D rendering and direct manipulation modules, its input to various vtk flow data sets, and to the spot noise texture generation pipeline. End users can freely configure the visualization pipelines with new modules in a visual editor</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Examples of 2D (a) and 3D (b-e) flow field simplifications</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Vortex tubes in turbulent flows: Identification, representation, reconstruction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Banks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization 94</title>
		<meeting>Visualization 94</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="132" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Imaging vector fields using line integral convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;93)</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="263" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Enhanced spot noise for vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>De Leeuw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization</title>
		<meeting>Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="233" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Representation and display of vector field topology in fluid flow data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Helman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="27" to="36" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Multiresolution 3d approximations for rendering complex scenes. Modelling in Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Burrel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<editor>E. B. Falcidieno, T. L. Kunn</editor>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Springer Verlag</publisher>
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A theory for the multiresolution signal decomposition: The wavelet representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mallat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="676" to="693" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Visualizing features and tracking their evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Samtaney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Zabusky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="20" to="27" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The stream polygon: A technique for 3d vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Volpe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization 91</title>
		<meeting>Visualization 91</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="126" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">VISSION: An object oriented dataflow system for simulation and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Telea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th IEEE/Eurographics Visualization Workshop</title>
		<meeting>the 10th IEEE/Eurographics Visualization Workshop<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The application visualization system: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vroom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Selective visualization on curvilinear grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Van Walsum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Delft University of Technology, the Netherlands</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Feature extraction and iconic visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Van Walsum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="119" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Flow visualization with surface particles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="24" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Hierarchical representation of very large data sets for visualization using wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bergeron</surname></persName>
		</author>
		<editor>G. Nielson, H. Hagen, H. Mueller</editor>
		<imprint>
			<date type="published" when="1997" />
			<publisher>IEEE Computer Society Press</publisher>
			<biblScope unit="page" from="415" to="429" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
