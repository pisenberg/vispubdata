<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Splatting Without The Blur</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Mueller</surname></persName>
							<email>mueller@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torsten</forename><surname>Möller</surname></persName>
							<email>moeller@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><surname>Crawfis</surname></persName>
							<email>crawfis@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Splatting Without The Blur</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Splatting is a volume rendering algorithm that combines efficient volume projection with a sparse data representation: Only voxels that have values inside the iso-range need to be considered, and these voxels can be projected via efficient rasterization schemes. In splatting, each projected voxel is represented as a radially symmetric interpolation kernel, equivalent to a fuzzy ball. Projecting such a basis function leaves a fuzzy impression, called a footprint or splat, on the screen. Splatting traditionally classifies and shades the voxels prior to projection, and thus each voxel footprint is weighted by the assigned voxel color and opacity. Projecting these fuzzy color balls provides a uniform screen image for homogeneous object regions, but leads to a blurry appearance of object edges. The latter is clearly undesirable, especially when the view is zoomed on the object. In this work, we manipulate the rendering pipeline of splatting by performing the classification and shading process after the voxels have been projected onto the screen. In this way, volume contributions outside the iso-range never affect the image. Since shading requires gradients, we not only splat the density volume, using regular splats, but we also project the gradient volume, using gradient splats. However, alternative to gradient splats, we can also compute the gradients on the projection plane, using central differencing. This latter scheme cuts the number of footprint rasterization by a factor of four, since only the voxel densities have to be projected. Our new method renders objects with crisp edges and well-preserved surface detail. Added overhead is the calculation of the screen gradients and the per-pixel shading. Both of these operations, however, may be performed using fast techniques employing lookup tables.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Volume visualization deals with the display of volumetric data, represented as sample points on a regular or irregular 3D raster. Volumetric data may be produced by medical scanners, such as MRI, CT, PET, or SPECT, by confocal or electron microscopy, by numerical methods, such as scientific simulations and finite element analysis, or by voxelization of analytic functions. In recent years, many tools and techniques have been proposed to aid us in the visualization of volumetric datasets. On one side is the group of direct volume renderers, which seek to capture a visual impression of the complete 3D dataset by accounting for the emission and absorption effects of all data elements <ref type="bibr" target="#b6">[7]</ref>[13]- <ref type="bibr" target="#b14">[15]</ref>[30]- <ref type="bibr" target="#b31">[32]</ref> <ref type="bibr" target="#b33">[34]</ref>. On the other side is the group of indirect volume renderers that reduce the data into a set of isosurfaces <ref type="bibr" target="#b16">[17]</ref>, which are conve-niently rendered as polygonal meshes using z-buffer algorithms. The latter representation is appropriate when such isosurfaces exist in the data, but may be less effective when the volume is a spacefilling gas, such as in fluid-flow simulations, or is composed of many micro-surfaces, such as tissue in a medical dataset.</p><p>A good argument for indirect volume renderers is that they can take advantage of widely available sophisticated graphics hardware to quickly render the polygonal meshes. However, a large volumetric dataset may give rise to a huge number of polygons, so huge that it may overwhelm the graphics engine. This observation recently motivated the parallel raycaster developed by Parker <ref type="bibr" target="#b24">[25]</ref>. Although it is true that the magnitude of the polygonal mesh may be reduced to a more manageable size using the error-minimizing methods proposed by Hoppe <ref type="bibr" target="#b9">[10]</ref> and others, these methods are rather expensive, and therefore cannot be applied when the polygonal mesh is not static. This is a scenario that occurs when viewing time-varying data or when the isosurface is interactively varied, e.g., during data exploration, which requires the extraction (and simplification) of a new polygonal mesh for each new iso-interval.</p><p>Popular direct volume rendering algorithms are raycasting <ref type="bibr" target="#b13">[14]</ref> <ref type="bibr" target="#b14">[15]</ref>, Shear-warp <ref type="bibr" target="#b12">[13]</ref>, splatting <ref type="bibr" target="#b29">[30]</ref>- <ref type="bibr" target="#b31">[32]</ref>, cell-projection methods <ref type="bibr" target="#b33">[34]</ref>, and approaches using 3D texture-mapping hardware <ref type="bibr" target="#b3">[4]</ref> <ref type="bibr" target="#b27">[28]</ref> <ref type="bibr" target="#b28">[29]</ref> or custom volume rendering boards <ref type="bibr" target="#b23">[24]</ref>. All of these methods perform some sort of explicit or implicit volume interpolation at points along the viewing direction. The interpolation results are then composited in front-to-back or back-to-front order. A distinction has to be made with respect to the nature of the interpolated value, and this distinction depends on the order of the volume rendering pipeline constituents: classification, shading, interpolation, and compositing (see <ref type="figure" target="#fig_0">Fig. 1</ref>). Classification determines the (fuzzy) object or material membership of a voxel or interpolated sample point and is usually given by a range of volume densities, specified in the transfer function. Based on this classification transfer function, the voxel or interpolated sample point is assigned a color and an opacity. The color is then scaled by the result of the shading operation, which determines the amount of light, coming from one or more lightsources, that is reflected towards the eye. If the volume voxels are classified and shaded as a pre-processing step before the projection occurs, then the interpolation operations yield colors and opacities, which can be directly composited along the viewing direction ( <ref type="figure" target="#fig_0">Fig. 1a</ref>). We will refer to this mode of volume rendering as pre-shaded volume rendering. On the other hand, when the raw density volume is interpolated, then each interpolated value must first be classified and shaded before it is composited <ref type="figure" target="#fig_0">(Fig. 1b)</ref>. Since classification and shading occurs after sample interpolation, we will call this type of volume rendering post-shaded volume rendering.</p><p>Splatting traditionally uses the pre-shaded scheme: The voxels are first classified and shaded, and then each shaded voxel is projected to the screen as a fuzzy ball, i.e., the 3D interpolation kernel. The 2D screen projection of such a kernel is called a splat or footprint and can be performed very efficiently. The outcome of this rendering procedure is an object projection that has that typical pre-shaded volume rendering-look: blurred boundaries and smooth surfaces (see <ref type="figure" target="#fig_0">Fig. 1a</ref> where we have splatted a cube composed of 8 3 voxels). These blurred boundaries are due to the smooth decay of the iso-voxels' splatting kernels, located at the object edges. A positive aspect of the blurring effect is that the rendering results with splatting are almost always smooth and alias-free, even in the presence of poor gradients around the iso-surfaces. However, the blurring becomes a great nuisance when rendering intricate and detailed structures, such as nasal passageways <ref type="bibr" target="#b32">[33]</ref> or colons <ref type="bibr" target="#b8">[9]</ref> in medical fly-throughs. The blurring (i.e., lowpassing) washes out much of the crucial object detail, which greatly hampers the realism and utility of the visualization. A direct volume rendering is, however, preferable, should we desire to deform or manipulate the object in a surgical simulation scenario.</p><p>Raycasting algorithms, on the other hand, come in both flavors, i.e., pre-shaded <ref type="bibr" target="#b6">[7]</ref>  <ref type="bibr" target="#b26">[27]</ref>. (Note that we, for the sake of our discussion, refer to the raw, original grid values in a volume as densities.) See <ref type="figure" target="#fig_0">Fig. 1b</ref>, where we show the cube of <ref type="figure" target="#fig_0">Fig. 1a</ref>, now rendered with post-shaded raycasting. We observe that the edges appear very crisp. Although it is generally agreed upon in the literature <ref type="bibr" target="#b34">[35]</ref> that the post-shaded pipeline produces sharper edges than the pre-shaded pipeline, one may argue, that even when raycasting is applied in conjunction with pre-shading, one rarely notices blurring as pronounced as with splatting. This can be explained by the fact that raycasting most commonly uses trilinear interpolation filters, which cause less blurring (but possibly more aliasing). Splatting, on the other hand, usually employs relatively large, radially symmetric interpolation kernels (such as a Gaussian of radial extent 2.0). These kernel are chosen since they allow the same kernel footprint to be used for all viewing directions and ensure good footprint overlap on the screen <ref type="bibr" target="#b30">[31]</ref>. Unfortunately, these larger interpolation kernels cause a higher amount of blurring (but also reduce aliasing).</p><p>In previous work, Huang <ref type="bibr" target="#b10">[11]</ref> has proposed edge splats, i.e., specialized kernels with rapid interpolation function decay, to be used on object boundaries. These kernels, in essence, model the look of an edge. Splatting with edge splats placed at iso-surfaces and regular splats used in homogeneous volume regions provides the desired effect: crisp edges and smooth surfaces. It, however, requires the detection of directional edges in volume space as a pre-processing step. The gradient at an iso-surface provides the edge direction, while the voxel-edge distance is estimated by the gradient magnitude/direction and the difference between the voxel's value and the iso-value. In the pre-processing step, all voxels that are close to an iso-surface are augmented with values for edge direction, edge distance, and gradient-strength. The splatting process then uses these parameters at rendering time to select the edge splat with the most appropriate edge decay, location, and 3D orientation for each voxel. Although the approach is very effective for the iso-surface edges, micro-edges within the iso-range are not handled easily. Other drawbacks are: (i) The method has problems with discontinuities in the edge profile, e.g., sharp corners such as cube edges, where the direction of an edge is ambiguous in volume space and its perception is view-dependent. (ii) It requires a preprocessing step (which, however, may be performed on the fly) whenever the iso-range or transfer function is changed. This slows interactive transfer function changes. (iii) The edge splats are equivalent to applying a local high frequency filter to the volume, hence noise in the iso-contour range may be amplified.</p><p>The splatting approach presented in this paper does not add any artificial detail to the volume. Rather, it eliminates blurring by applying the volume rendering pipeline of <ref type="figure" target="#fig_0">Fig. 1b</ref> to the original density data using the splatting paradigm. In this way, only that part of a projected voxel footprint that falls within the iso-range is shaded and displayed, while the footprint portion with values outside the iso-range (or the interval volume) is culled from the shad- The raw density volume is first classified and shaded, and the volume renderer then interpolates the resulting color and opacity volumes and composites the sample values for image generation. On the right: A cube (8 3 voxels) rendered with splatting from a pre-shaded color and opacity volume (a Gaussian filter of radial extent 2.0 was used for interpolation). (b) Post-shaded volume rendering: The volume renderer interpolates the raw density volume, and these sample values are then classified and shaded and composited for image generation. On the right: The cube of (a) is rendered from the density volume with a raycaster and trilinear interpolation in post-shaded mode.</p><p>ing process and never contributes to the final image. It is this latter portion that is responsible for the blurring in the pipeline of <ref type="figure" target="#fig_0">Fig. 1a</ref>.</p><p>The outline of the paper is as follows. First, in Section 2, we describe splatting in general and then summarize a splatting method that we have proposed recently and in which we will embed our new splatting pipeline. Then, in Section 3, we provide the underlying theory of the new enhancement. Section 4 presents the new algorithm, and Section 5 presents visual and temporal results. Finally, Section 6 provides some concluding remarks, and Section 7 finishes with a list of research topics for the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>The basic element in most volume rendering applications is the volume rendering integral in its low-albedo form <ref type="bibr" target="#b2">[3]</ref>, as formulated by Kajiya and Von Herzen <ref type="bibr" target="#b11">[12]</ref> and also formally derived by Max <ref type="bibr" target="#b18">[19]</ref>. For each pixel ray, we compute I λ (x,r), the amount of light of wavelength λ coming from ray direction r that is received at point x on the image plane:</p><formula xml:id="formula_0">(1)</formula><p>Here L is the length of ray r. We can think of the volume as being composed of particles with certain densities µ (Max calls them light extinction coefficients <ref type="bibr" target="#b18">[19]</ref>). These particles receive light from all surrounding light sources and reflect this light towards the observer according to the specular and diffuse material properties of the particles. Thus, in (1), C λ is the light of wavelength λ reflected at location s in the direction of r. To account for the higher reflectivity of particles with larger densities, we must weight the reflected color by the particle density. The light scattered at s is then attenuated by the densities of the particles between s and the eye according to the exponential attenuation function.</p><p>The analytic volume rendering integral can, in most cases, not be computed efficiently, if at all, and therefore a variety of approximations are in use. An approximation of (1) can be obtained by raycasting, using a discrete Riemann sum. Rays are cast into the volume, and samples, spaced apart by a distance ∆s, are interpolated along the ray by means of a 3D interpolation kernel h. Equation (1) can be written as a Riemann sum equation as follows:</p><p>(2) A few approximations make the computation of this equation more efficient. First, the transparency t(i∆s) is defined as . Transparency assumes values in the range [0.0, 1.0]. Then opacity . The exponential term in (2) can be approximated by the first two terms of its Taylor expansion:</p><p>. Then one can write: . This transforms (2) into the familiar compositing equation: <ref type="bibr" target="#b2">(3)</ref> This equation, popularized by Levoy <ref type="bibr" target="#b13">[14]</ref>, is valid if we interpolate a discrete, pre-classified and pre-shaded color and opacity volume C d (x,y,z) and α d (x,y,z), respectively, to get C(i∆s) and α(i∆s) (pipeline of <ref type="figure" target="#fig_0">Fig. 1a</ref>). However, if we classify interpolated samples obtained from the discrete raw density volume f d (x,y,z) (pipeline of <ref type="figure" target="#fig_0">Fig. 1b)</ref>, then (3) is more appropriately written as follows:</p><formula xml:id="formula_1">(4)</formula><p>The function value f(i∆s) and the gradient vector g(i∆s) is interpolated from f d (x,y,z) using some 3D interpolation kernel, and C λ and α are now functions that translate the interpolated volume function values into color and opacity.</p><p>The splatting algorithm <ref type="bibr" target="#b29">[30]</ref>- <ref type="bibr" target="#b31">[32]</ref> was proposed by Lee Westover to provide the level of efficiency that previous raycasting approaches were lacking. It gains its speed by reordering the volume rendering integral so that each voxel's contribution to the integral can be viewed isolated from the other voxels. In splatting, an interpolation kernel h is placed at each voxel location. This enables one to view the volume as a field of overlapping interpolation kernels which, as an ensemble, make up the continuous object representation. The contribution of a voxel j with value f j is then given by , where s follows the line of kernel integration in the direction of the ray. If the interpolation kernel is radially symmetric, we may pre-integrate into a lookup-table, i.e., the kernel footprint, and use this table for all voxels. We can then map the voxel footprints, scaled by the voxel values, to the screen where they accumulate into the projection image <ref type="bibr" target="#b30">[31]</ref>. By mapping the footprint (image) onto a polygon, we can employ standard 2D texture mapping hardware for the projection process <ref type="bibr" target="#b5">[6]</ref>. However, the footprint interpolation is also easily done in software with fast DDA procedures <ref type="bibr" target="#b17">[18]</ref> <ref type="bibr" target="#b20">[21]</ref>. Thus, splatting performs all interpolations in 2D (i.e., the footprint rasterizations), while raycasting performs all interpolations more expensively in 3D (i.e., when interpolating a volume sample). In addition, as an object-order approach, splatting only needs to store and render the relevant voxels, which in many cases constitutes a mere 10-20% of the volume voxels <ref type="bibr" target="#b33">[34]</ref>. However, until recently, one of the downsides of splatting was that the pre-integrated kernels restricted the volume rendering integral, since the 3D reconstruction kernel was composited as a whole, and not piecewise, as part of an interpolated sample along a viewing ray. This caused popping artifacts in animated viewing.</p><p>The image-aligned splatting approach was recently proposed <ref type="bibr" target="#b22">[23]</ref> to eliminate these restrictions. It unifies the qualitative advantages of raycasting with the efficiency of splatting. Unlike the traditional splatting approach, image-aligned splatting does not splat the interpolation kernels as a whole. Rather, it slices the interpolation kernels by a series of cutting planes that are aligned parallel to the image plane. The kernel sections that fall within a pair of cutting planes or thin slab are summed into a sheet-buffer, and consecutive sheet-buffers are composited from back-to-front or front-toback. Again, pre-integrated kernel sections are used for fast rasterization. This approach gives rise to a volume integral calculation that is similar to the one computed by raycasting in the color-interpolation model. It mimics a set of simultaneous rays that re-sample the volume into a set of parallel sheet images, spaced apart by ∆s, which are then composited in front-to-back order. The distinction is that the composited colors and opacities are now obtained by true function integration, and not by the Riemann square integration rule. Equation (3) is then written as follows: <ref type="bibr" target="#b4">(5)</ref> We will use the image-aligned splatting algorithm along with the early splat elimination scheme proposed in <ref type="bibr" target="#b21">[22]</ref>. This scheme</p><formula xml:id="formula_2">I λ x r , ( ) C λ s ( )µ s ( ) µ t ( ) t d 0 s ∫ -     exp s d 0 L ∫ = I λ x r , ( ) C λ i∆s ( )µ i∆s ( )∆s µ j∆s ( )∆s - ( ) exp j 0 = i 1 - ∏ i 0 = L ∆s ⁄ 1 - ∑ = µ i∆s ( )∆s - ( ) exp t i∆s ( ) = α i∆s ( ) 1 t i∆s ( ) - ( ) = t i∆s ( ) µ i∆s ( )∆s - ( ) exp = 1µ i∆s ( )∆s - ≈ µ i∆s ( )∆s 1 t i∆s ( ) - ≈ αi∆s ( ) = I λ x r , ( ) C λ i∆s ( )α i∆s ( ) 1 α j∆s ( ) - ( ) j 0 = i 1 - ∏ ⋅ i 0 = L ∆s ⁄ 1 - ∑ = I λ x r , ( ) = C λ f i∆s ( ) g i∆s ( ) , ( ) αf i∆s ( ) ( ) 1 α f j∆s ( ) ( ) - ( ) j 0 = i 1 - ∏ i 0 = L ∆s ⁄ 1 - ∑ f j h s ( ) s d ∫ ⋅ h s ( ) s d ∫ I λ x r , ( ) = 1 ∆s ------ C λ s ( ) s d i∆s i 1 + ( )∆s ∫ α s ( ) s d i∆s i 1 + ( )∆s ∫ 1 α s ( ) s d j∆s j 1 + ( )Λs ∫ -     j 0 = i 1 - ∏ i 0 = L ∆s ⁄ 1 - ∑</formula><p>employs a progressively refined screen occlusion map to cull from the splatting pipeline those voxels that have no effect on the final image. The screen occlusion map is computed from the opacity image layer, each time a sheet image has been composited with the current image buffer. The volume is traversed in front-to-back order. To determine occlusion, the center of a voxel (splat) is projected, and the splat is only rasterized if the occlusion map value at the projected point is above a pre-set opacity threshold. The splat culling can lead to tremendous savings, especially when the transfer function specifies large opaque regions. In many cases, only 10% of the relevant voxels survive the visibility test. But our tests also indicate that even semi-transparent volumes benefit considerably. The scheme is similar to early ray termination acceleration for raycasting, however, it does require the calculation of the occlusion map for every sheet-buffer slice, and it also requires the projection of each voxel's center.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THEORETICAL ASPECTS</head><p>In this section, we discuss the theoretical difference between pre-shaded and post-shaded volume rendering, and we derive the gradient filter necessary to implement the latter for splatting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Pre-shaded vs. post-shaded volume rendering</head><p>We have seen in <ref type="figure" target="#fig_0">Fig. 1</ref> that the volume rendering pipeline has four components: classification, shading, interpolation, and compositing. We have also seen that two permutations of these pipeline components exist, depending on if we interpolate colors and opacities or if we interpolate raw densities. Compositing comes last in both permutations, so we will not concern ourselves with this component for the matter of this discussion. Shading, on the other hand, requires the estimation of a gradient, so we need to add this operation to our pipeline. We can write the pipeline in a terse form using four operators: T for classification with a transfer function, S for shading, D for gradient (derivative) estimation, and H for interpolation <ref type="bibr" target="#b19">[20]</ref>. Furthermore, we denote the discrete volume density function given at the volume grid points as F. For the remainder of this discussion we will use H and h interchangeably: H can both be the interpolation operator and the interpolation filter. Likewise, D can both be the derivative operator and the derivative filter. The combination of operators F, D, and H constitutes a convolution operation in the spatial domain, or alternatively, a multiplication in the frequency domain.</p><p>Splatting presently uses the pipeline in <ref type="figure" target="#fig_0">Fig. 1a</ref>, which interpolates a pre-classified and pre-shaded volume. Using the five operators from left to right, this pipeline can be written as (read from left to right). In this equation, the density volume is first classified using the iso-value transfer function, then the gradients are computed at the grid points using e.g., a central difference filter, and finally the grid samples are shaded, using the gradients and the material colors assigned in the classification step. This pipeline allows fast processing for two reasons: (i) the gradients need only to be computed once per viewing session as a pre-processing step (unless we change the gradient transfer functions), and (ii) shading occurs only as a pre-processing step once per viewpoint, and does not have to be performed each time a voxel kernel is intersected by a slab. The colors and opacities stored at the grid points are then interpolated using the interpolation filter h.</p><p>The interpolation filter, h, usually deviates from the ideal sinc filter, and it will have a lowpassing effect when used to interpolate the color and opacity volume. A filter kernel that is often used in splatting is a radially symmetric Gaussian function of radial extent 2.0: <ref type="bibr" target="#b5">(6)</ref> Here, r 2 = x 2 + y 2 + z 2 , and b = 0.214 is a scaling factor that normalizes the kernel. This kernel is pre-integrated into a 2D footprint, which gives rise to another Gaussian. <ref type="figure" target="#fig_1">Fig. 2</ref> shows what happens if this kernel is used to interpolate a step function, constituted by an iso-edge ( <ref type="figure" target="#fig_1">Fig. 2a</ref>). If the voxels store colors and opacities, the edge will appear blurred, as is evident in <ref type="figure" target="#fig_1">Fig. 2b</ref>.</p><p>The post-shading pipeline of <ref type="figure" target="#fig_0">Fig. 1b</ref> can be written as: . Here, the grid voxel densities are first interpolated, and the interpolation result is then classified and shaded. <ref type="figure" target="#fig_1">Fig. 2b</ref> illustrates that h will again have a lowpassing effect and blur the interpolated volume. However, this time the classification step is still ahead, and we can undo some of the blurring by clipping off the blurred image regions, using the iso-thresholds. The surviving pixels are then shaded, and we observe that the rendered silhouette edge is considerably crisper and is located close to the true edge <ref type="figure" target="#fig_1">(Fig. 2c</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Gradient estimation</head><p>The remaining question is: How does one compute the gradients? The post-shading pipeline indicates that the gradient is calculated by applying the two operators H and D to the discrete volume function. It was shown by Möller <ref type="bibr" target="#b19">[20]</ref> that the operators F, D, and H are both associative and commutative, i.e., the sequences (FH)D, F(DH), and (FD)H are all equivalent. Thus, we could first interpolate F and then compute the gradients (the (FH)D scheme) or we could compute the gradients at the discrete grid locations and then interpolate the gradients (the (FD)H scheme), or we could construct a filter HD and use it to interpolate F (the F(DH) scheme). In <ref type="bibr" target="#b19">[20]</ref> it was also shown that (FH)D is the most efficient of the three, as long as we provide some sort of caching of the interpolated values FH, to be utilized for the calculation of gradients nearby. An alternative, but not equivalent, form of FHD is FH', where H' is the derivative of H (see Bentum <ref type="bibr" target="#b1">[2]</ref> for further details).</p><p>In splatting, we usually employ radially symmetric filters, such as Gaussians, such that we can use the footprints for all viewing directions. However, neither Möller nor Bentum consider radially symmetric filters. Thus we find it worthwhile here to offer some further investigations on this subject. <ref type="figure" target="#fig_2">Fig. 3a</ref> shows the frequency spectrum of the Gaussian kernel of (6). The frequency response of the central difference filter is also shown (derived in <ref type="bibr" target="#b1">[2]</ref>). Since (FH)D is equivalent to F(DH), we can capture the effect of DH on F by multiplying the frequency responses of the two filters. The result is spectrum 2 in <ref type="figure" target="#fig_2">Fig. 3b</ref>. Notice that the frequency response of the ideal gradient filter is given by a linear highpass of unit slope, that stops at a frequency of π, i.e., half the grid's Nyquist frequency (spectrum 1 in <ref type="figure" target="#fig_2">Fig. 3</ref>). Finally, spectrum 3 in <ref type="figure" target="#fig_2">Fig. 3b</ref> is the frequency response of H', the derivative of the Gaussian given in <ref type="bibr" target="#b5">(6)</ref>. The spatial filter function of H' is given by: </p><formula xml:id="formula_3">FHT FHD , ( ) S FHT FHD , ( ) S h' r ( ) b -' r 2 ⋅ 2 r 2 ⋅ - ⋅ =</formula><p>where b' = 0.855 is a normalization factor. Looking at the frequency responses in <ref type="figure" target="#fig_2">Fig. 3b</ref>, we notice that DH has a faster fall-off in the stop band, but also attenuates frequencies in the upper passband. On the other hand, H' preserves the passband frequencies better, but also passes more frequencies in the stopband. It is therefore more susceptible to noise. Clearly, a trade-off must be made. If our dataset contains fine detail, like bone fractures in medical images, then we would want a gradient filter with a high acuity in the upper passband to ensure the proper accentuation of these structures in the rendered image. However, if our dataset contains much high-frequency noise, as is often the case in medical datasets (especially in MRI), then we desire a gradient filter that is less sensitive in these regions of the spectrum. Since a gradient filter is a high-pass filter and emphasizes high frequencies, noise that usually resides in these frequency bands can be greatly amplified by these filters, generating undesirable high-frequency artifacts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NEW BLUR-FREE SPLATTING</head><p>We have just established that in order to rid splatting from much of the blurring, we need to formulate splatting as a postshading pipeline. We will now describe both conceptual and implementational issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Concepts</head><p>Recall Equation (4), which gives the compositing equation for raycasting when the post-shading pipeline is used. Notice that the density (and gradients) are assumed to be constant within the sampling interval. Splatting, on the other hand, can provide the density (and gradient) integral within the sheet-buffer slab, due to its preintegration scheme. Thus the compositing equation for splatting using the post-shading pipeline can be written as follows: <ref type="bibr" target="#b7">(8)</ref> where <ref type="bibr" target="#b8">(9)</ref> Again, C λ and α are now functions that translate the interpolated volume function and gradient values into color and opacity. Notice that splatting provides the average of the integrated density and gradients within a volume slab. On the other hand, ray-tracing (as well as the Shear-warp and the 3D texture mapping approaches) interpolates a random position and then uses a square rule for integration, as per equations <ref type="bibr" target="#b2">(3)</ref> and <ref type="bibr" target="#b3">(4)</ref>. The latter approach can lead to aliasing artifacts, thus many researchers employ an expensive root-finding operation to determine the actual surface position <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation issues</head><p>The operator (FH)D can be implemented by splatting the volume densities into a sheet buffer, and computing the in-sheet gradients by convolution with two orthogonal central-difference filters. The third gradient vector is perpendicular to the sheet-buffer plane and can be efficiently computed by caching the sheet-buffers immediately following and preceding the current sheet-buffer.</p><p>H' can be implemented by constructing three extra footprint section arrays, one for , , and , respectively. The footprint integration is performed similar to that of the regular density footprint. We just use a different underlying 3D kernel, i.e., the , , and kernel, respectively, and perform each integration along z (assume that we always look down the z-axis after the viewing transformation). In (FH)D, the volume gradients are computed with respect to an orthogonal coordinate system in which two axes are aligned with the sheet-buffer plane and the other is perpendicular to the sheetbuffer plane. Thus the gradient coordinate system is always aligned with the viewing coordinate system, and its orientation changes with the view orientation. The gradient splats reconstruct the gradients along the same coordinate system: The and splats compute the in-sheet gradients, and the splats compute the gradient perpendicular to the sheet-buffer. Rotating the gradient splats in this way yields correct results, since the kernel H is radially symmetric and its gradients are identical for all viewing directions. Hence, the gradient splats can be used for all viewing directions. Due to the imperfect kernels, however, the resulting gradient vector may be somewhat view-dependent.</p><p>Once the gradient vector components g x , g y , g z have been obtained, we must normalize them by division with the gradient vector magnitude before we can use them for shading. This involves an expensive square root computation. Clyne and Dennis <ref type="bibr" target="#b4">[5]</ref> have proposed an efficient work-around: If only the gradient direction is of interest, then we can perform a mapping from cartesian space to spherical space to get the latitude/longitude angles of the gradient vector. These can then be used to obtain the normalized gradient components by mapping back into cartesian space. Briefly, the spherical mapping is computed by: <ref type="bibr" target="#b9">(10)</ref> These angles are then mapped back into normalized cartesian space: <ref type="bibr" target="#b10">(11)</ref> All major function calculations can be efficiently performed </p><formula xml:id="formula_4">I λ x r , ( ) = C λ q i∆s ( ) g i∆s ( ) , ( )αq i∆s ( ) ( )∆s 1 α q i∆s ( ) ( )∆s - ( ) j 0 = i 1 - ∏ ⋅ i 0 = L ∆s ⁄ 1 - ∑ q i∆s ( ) f s ( ) ∆s ----------s d i∆s i 1 + ( )∆s ∫ = g i∆s ( ) g s ( ) ∆s ----------s d i∆s i 1 + ( )∆s ∫ = ∂H ∂x ⁄ ∂H ∂y ⁄ ∂ H ∂z ⁄ ∂H ∂x ⁄ ∂H ∂y ⁄ ∂ H ∂z ⁄ ∂H ∂x ⁄ ∂ H ∂y ⁄ ∂H ∂z ⁄ λ g y g x ------ atan = φ g z g x 2 g y 2 + ----------------------- atan = g x n λ cos φ cos ⋅ = g y n λ sin φ cos ⋅ = g z n φ sin =</formula><p>using lookup tables, if we are willing to sacrifice some resolution, say by converting g x , g y , g z into signed bytes. Furthermore, a variety of schemes exist to efficiently compute approximate gradient magnitudes as well (see the Graphics Gems series, e.g., <ref type="bibr" target="#b25">[26]</ref>). Finally, the angles λ and φ can also be used directly, to index a lookup table that stores the result of the shading equation for a set of normals uniformly distributed on a sphere <ref type="bibr" target="#b27">[28]</ref>.</p><p>We can limit the amount of computation in the shading procedure by dividing the sheet-buffer into a set of tiles. Each tile is associated with a counter that is initialized to zero for each new sheet-buffer. This tile counter is incremented whenever a voxel center projects into the tile. Then, once all voxels have been projected onto the sheet-buffer, we only need to perform gradient and shading computations in those tiles that have been touched by a footprint. To account for the entire footprint-tile coverage, we must add a seam of half the footprint size to each tile (since only the footprint centers were used to determine what tile was hit). We have also experimented with bounding boxes that encompass the rectangular sheet area that received footprint contributions in the current sheet.</p><p>Finally, compositing the shaded sheet-buffers is performed as usual, and the occlusion map acceleration can also be employed unchanged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Cost analysis</head><p>Although extra overhead is incurred by the need for gradient estimation and shading on the image plane, post-shaded splatting offers substantial savings in another step of the volume rendering pipeline: the footprint rasterization step. These savings help balance the costs of the two methods. When a color image is generated in pre-shaded splatting, four footprints must be rasterized per kernel section: red, green, blue, and alpha. On the other hand, if we use the F(DH) scheme in post-shaded splatting, then we only have to splat one footprint per voxel, i.e., the density footprint. Savings ensue, since lookup-table assisted shading and gradient estimation requires considerably fewer operations than the over 128 multiplications and additions that are required to rasterize four footprints at one-to-one viewing.</p><p>When we use the H' gradient estimation mode, then we do not save any splat rasterization operations. Just as in pre-shaded splatting, we have to splat four footprints per voxel: the three gradients and the density. So we do not anticipate any savings for H'. Rather, we expect somewhat higher cost due to the extra work for gradient estimation and shading on the image plane.</p><p>We should add that with the new algorithm, the number of voxels to be splatted is generally larger than with pre-shaded splatting. This is simply because in order to ensure proper gradients, we also need to splat voxels with values that are slightly outside the specified iso-ranges. Otherwise we would perform a reconstruction of a binary object, which would lead to possibly large aliasing artifacts. Another consequence of not loading a seam of voxels below the isovalue can be a shrinking of the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">A hybrid method: the pre-shaded post-alpha splatting pipeline</head><p>Pre-shaded splatting is potentially faster than post-shaded splatting since it is likely that the number of visible voxels that require pre-shading is less than the number of pixels that require post-shading. Furthermore, the number of voxels to be projected in pre-shaded splatting is lower than the number of voxels in postshaded splatting, because we need only project the voxels that are classified within the iso-interval. Of course, we gain crisper images in post-shaded splatting, due to the iso-contouring on the image plane before shading, and we would like to maintain that advantage. Thus the question is, can we use the pre-shaded approach that saves us the extra voxel projections and the per-pixel shading, and still use iso-contouring on the sheet-buffer plane? In such an approach, we would pre-shade the voxels as usual, but then project this color volume along with the raw density volume. We would not pre-classify the alpha channel. Instead, we would classify the pixels on each sheet-buffer plane, similar to the post-shaded approach. All pixels that have a projected density within the isointerval are set to some alpha value, while all other pixels are reset to fully transparent. This hybrid approach seems to combine the good aspects from both the pre-shaded and the post-shaded volume rendering pipeline, and we call this approach the pre-shaded postalpha splatting pipeline, due to the delayed alpha classification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>We have applied the presented splatting pipelines to the UNC MRI dataset (256×256×145 voxels) and a ganglion nerve cell dataset (512×512×76 voxels). Our rendering results are shown in <ref type="figure" target="#fig_4">Fig. 6 (color plates)</ref>, the images have 512×512 pixels. The difference in image quality is quite striking. Consider first the UNC head dataset. The new post-shaded splatting algorithm <ref type="figure" target="#fig_4">(Fig. 6, column</ref> 2) produces images that look significantly sharper than those produced with the traditional algorithm <ref type="figure" target="#fig_0">(Fig. 6, column 1)</ref>, especially when the object is viewed under magnification. Flickering between a pair of corresponding images has the feel of a visit at the optometrist: the left image is seen with glasses off, the right is seen with glasses on.</p><p>The new algorithm accentuates fine surface detail very well and renders the object with a much sharper look than the traditional splatter. In our experiments, we have set alpha to 1.0 whenever a pixel was within the iso-interval. This provides for very crisp surfaces. However, semi-transparent transfer functions are also possible. As a matter of fact, the algorithm works anytime a transfer function is available for post-shading, both for color and opacity.</p><p>The images in the center column of <ref type="figure" target="#fig_4">Fig. 6</ref> were produced using central differencing for gradient estimation. We can even improve the image quality, to some extent, by using gradient splats instead. For example, the zoomed brain view in the right column of row 4 in <ref type="figure" target="#fig_4">Fig. 6</ref> was generated with gradient splats. We notice that the detail is somewhat crisper and the specular highlights are more pronounced. This was to be expected since the Gaussian derivative splat preserves higher frequency better than the central differenced Gaussian, as was illustrated earlier.</p><p>Row 2 and 3 in column 3 of <ref type="figure" target="#fig_4">Fig. 6</ref> show the ganglion nerve cell rendered with pre-shaded splatting and with post-shaded splatting, respectively. We again notice a crisper, almost plastic-like, appearance of the nerve cell when rendered with post-shaded splatting.</p><p>For this paper, we have stressed qualitative issues over code optimization. We have used occlusion and frustrum culling as well as bounding boxes to limit the amount of shading calculations on the image plane. But we have neither implemented the fast gradient calculation schemes nor do we use the fast shading methods that were mentioned in Section 4.2. Our timings, given in <ref type="table" target="#tab_1">Table 1</ref>, reflect this circumstance: Our traditional splatter is still significantly faster than the newly developed algorithm. This is expected to remain true as far as the H' gradient estimator is concerned, but we anticipate significant speedups for the F(DH) scheme when fast lookup-table assisted shading is implemented. We have conducted some preliminary experiments in this area, and we found that the time required for shading and gradient normalization amounts to about 75% of the value given in row 2, 'shading', of <ref type="table" target="#tab_1">Table 1</ref>. On the other hand, due to the circumstance that we use texture mapping hardware to project the splats, we do not get the anticipated savings in the footprint rasterization stage, since the texture mapping hardware projects 4-channel RGBA splats at similar speeds as it does 1-channel Luminance splats. We expect the savings in a pure software implementation to be significantly more pronounced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Results with pre-shaded post-alpha splatting</head><p>Column 3 in row 1 of <ref type="figure" target="#fig_4">Fig. 6</ref> shows an image that was obtained with the pre-shaded post-alpha splatting pipeline. We notice significant staircasing artifacts in this image. To explain this artifact, consider a simple 2D example with two slices of three voxels each (see <ref type="figure" target="#fig_3">Fig. 4</ref>). Here, the white voxels have a density f d =0, the others have f d =2•f iso , with f iso being the iso-value. Let us further assume that we have a pre-shading function that sets the white voxels to color C d =0.0 and the black voxels to C d =1.0. Consider the interpolated image pixel due to pixel ray 1. It passes halfway between the rightmost two voxels of the first slice in <ref type="figure" target="#fig_3">Fig. 4</ref>. Using simple linear interpolation, we would interpolate C=0.5 and f=f iso . Thus the isocontour traverses right between these two voxels and the assigned pixel color would be C=0.5. When using the post-shaded pipeline instead, we again get f=f iso , but now lighting is yet to be applied, yielding C=1.0 (assuming an appropriate gradient and light source position). We set α=1.0 in both cases, so no more color can be composited at that pixel. Thus in the pre-shaded post-alpha image, C=0.5 is the final color at that pixel, and this explains the dark rings right at the boundary of the stairstep. Pixel ray 2 does not receive any contribution from slice 1 (the interpolated voxels are both below the iso-threshold), but in slice 2 both interpolated voxels have f d =2•f iso and C d =1.0. Thus the interpolated color between them is 1.0. This explains the bright regions inside the dark rings.</p><p>We can avoid the slice effect, if, for example, we set the transfer function α(f(s) to a smooth ramp. Then slice 2 would have a chance to contribute to pixel 1. We have observed that this eases the staircasing artifacts, but at the cost of an X-ray effect, since we now make our object artificially transparent (see <ref type="figure">Fig. 5a</ref>). So we again get a blurring, just this time we get it in the z-direction. For the image in <ref type="figure" target="#fig_4">Fig. 6</ref>, we actually used a smooth ramp for α. Otherwise, had we set α=1.0 for all f&gt;f iso , the staircasing would have been even more pronounced (see <ref type="figure">Fig. 5b</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>Splatting has long been plagued by the blurry look of the ren-dered objects. Sharp edges appear fuzzy and fine object detail is greatly diminished. The blurriness occurs since splatting projects pre-shaded voxels with a relatively large splatting kernel, which leaves a fuzzy footprint on the screen. The overall effect is a lowpassing of the projected color and opacity volume, which cannot be easily reversed. A simple iso-contouring of each projected color slice, via classification of a simultaneously projected density slice (i.e. the pre-shaded post-alpha pipeline), does not yield the desired results. It is hence apparent that one cannot resolve the blurring with pre-shaded volumes. Thus, our solution to this problem is to use a post-shaded pipeline for splatting instead, performing both classification and shading operations after the projection of the voxels that fall into a sheet-buffer slice. In this way, the non-linear iso-surfacing can be performed after the lowpassing effect of the splatting interpolation kernel. The result is a much sharper look to the volume rendered object. Since this new method must perform the shading on the projection plane, the estimation of gradients is required. We have proposed two methods for gradient reconstruction: (i) Central differencing on the projection image, and (ii) the projection of a gradient volume using gradient splats. Here it turns out that the regrouping of the volume rendering pipeline is also advantageous in terms of efficiency. When the gradients are estimated via central differencing, then only one footprint rasterization is needed per voxel, i.e., the rasterization of the density footprint. Traditional splatting requires four such rasterizations per voxel (two, if a greylevel image is rendered), which is also required if a gradient volume is splatted to reconstruct the gradients on the screen. Although splatting the gradient volume preserves high frequencies better, it may also may cause aliasing for noisy volume data. Central differencing, on the other hand, may not preserve the gradients of fine  The new method preserves the advantages of splatting: a sparse volume representation where only the relevant voxels have to be projected (now along with a layer of boundary voxels), and a volume integration using segments of density integrals instead of point samples. The new method also allows the use of the efficient and qualitatively superior framework of image-aligned splatting, in conjunction with screen occlusion maps for early culling of occluded voxels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">FUTURE WORK</head><p>We would like to investigate better gradient kernels than the Gaussian. However, we are limited by the fact that we have to use radially symmetric kernels. Thus we cannot efficiently use the kernels presented in <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b19">[20]</ref>, but work is underway to expand the theory presented in <ref type="bibr" target="#b19">[20]</ref> to rotationally symmetric kernels. Another promising avenue of research in this respect are the Bessel-Kaiser kernels derived by Lewitt <ref type="bibr" target="#b15">[16]</ref>. These kernels have very desirable frequency characteristics, and have been shown to yield interpolation kernels superior to the Gaussian. We plan to investigate the derivative of these kernels to improve the frequency characteristics of our H' kernel. Another kernel worthwhile investigating for gradient estimation is the Crawfis-Max kernel <ref type="bibr" target="#b5">[6]</ref>, which has been designed for optimal traditional splatting.</p><p>We are currently also investigating better ways to deal with the staircasing artifacts in the pre-shaded post-alpha splatting pipeline. This pipeline may be well suited to remove blurring in presegmented, tagged, and distance volumes, where no transfer function is available for post-shading.</p><p>Much work needs to be done on speeding up the gradient estimation and shading stage. Implementing the fast schemes mentioned in Section 4.2 should make the new algorithm a lot more competitive with the traditional one in terms of speed.</p><p>Unlike the hardware employed in the 3D texture mapping approaches of <ref type="bibr" target="#b3">[4]</ref>[28] <ref type="bibr" target="#b28">[29]</ref>, the 2D texture mapping hardware currently used by our algorithm is not confined to expensive graphics workstations. Rather, it can be obtained for a few $100 in form of plug-in graphics boards for use on PCs. But we are also presently porting the footprint rasterization and compositing operations into a pure software environment. Initial results indicate that, in many cases, this software implementation is actually faster than the hardware-assisted implementation.</p><p>We have only just begun to explore the power of our new approach for the generation of higher quality images with splatting. So far we have only rendered fully opaque objects, such as the UNC head, but we have obtained initial results for semitransparent datasets as well. In future work, we seek to develop transfer functions that use the gradient and the gradient strength to enhance apparent surfaces in the volumetric dataset. The works by Levoy <ref type="bibr" target="#b13">[14]</ref> and Drebin <ref type="bibr" target="#b6">[7]</ref> shall be an initial starting point here.</p><p>rendered with pre-shaded splatting rendered with post-shaded splatting, gradients estimated with central differencing (1) head, pre-shaded w/ post-alpha, α(f iso )=0.7 (2) ganglion nerve cell, pre-shaded (3) ganglion nerve cell, post-shaded (4) zoomed brain, post-shaded with gradients estimated with gradient splats <ref type="bibr" target="#b0">(1)</ref> (2) </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Two standard volume rendering pipelines. (a) Pre-shaded volume rendering:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>original step function: the edge (b) blurred edge, after convolving the (c) crisp edge, after thresholding the edge with Gaussian filter h blurred edge with iso-value Origin of blurring, and its prevention.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>(a) Frequency spectra of Gaussian (H) and central difference filter (D). The optimal derivative filter is an ideal highpass: a line of slope=1 in frequency space, that stops at frequency=π. (b) Frequency spectra of the DH and the H' derivative filter, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :</head><label>4</label><figDesc>Interpolating two pixel rays traversing two voxel slices of three voxels each.Fig. 5: Pre-shaded post-alpha splatting: (a) using a ramp starting at α(f iso )=0.1, (b) setting all α(f)=1.0 for f&gt;f iso . (a) (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 :</head><label>6</label><figDesc>Colorplate (1) full head, (2) eye, (3) brain, (4) brain zoomed</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Timings in secs obtained on a SGI Onyx using a R10000 194MHz CPU. The columns correspond to the images inFig. 6. 2D texture mapping hardware was employed to perform the footprint rasterization, and graphics hardware was utilized for sheet-buffer compositing. However, we have recently also implemented a software splatter that runs at the same speed and better.</figDesc><table><row><cell>image</cell><cell cols="2">full head</cell><cell>eye</cell><cell></cell><cell cols="2">brain</cell><cell></cell><cell>brain zoomed</cell><cell></cell><cell cols="2">ganglion nerve</cell></row><row><cell>in Fig. 6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>cell</cell><cell></cell></row><row><cell>splatting</cell><cell>pre-</cell><cell>post-</cell><cell>pre-</cell><cell>post-</cell><cell>pre-</cell><cell>post-</cell><cell>pre-</cell><cell cols="2">post-shade</cell><cell>pre-</cell><cell>post-</cell></row><row><cell>method</cell><cell>shade</cell><cell>shade</cell><cell>shade</cell><cell>shade</cell><cell>shade</cell><cell>shade</cell><cell>shade</cell><cell>centr. diff.</cell><cell>grad. splat</cell><cell>shade</cell><cell>shade</cell></row><row><cell>footprint</cell><cell>15.6</cell><cell>11.4</cell><cell>17.4</cell><cell>14.5</cell><cell>14.5</cell><cell>13.0</cell><cell>16.7</cell><cell>16.2</cell><cell>16.8</cell><cell>9.4</cell><cell>6.5</cell></row><row><cell>rasterization</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>shading</cell><cell>1.8</cell><cell>14.0</cell><cell>0.7</cell><cell>17.1</cell><cell>1.8</cell><cell>13.6</cell><cell>0.3</cell><cell>17.8</cell><cell>17.0</cell><cell>3.5</cell><cell>15.6</cell></row><row><cell>compositing</cell><cell>3.5</cell><cell>3.5</cell><cell>2.4</cell><cell>2.7</cell><cell>3.9</cell><cell>4.3</cell><cell>1.4</cell><cell>1.4</cell><cell>1.4</cell><cell>2.7</cell><cell>3.0</cell></row><row><cell>total</cell><cell>21.0</cell><cell>29.9</cell><cell>20.5</cell><cell>35.2</cell><cell>20.3</cell><cell>31.7</cell><cell>18.5</cell><cell>36.2</cell><cell>36.0</cell><cell>15.7</cell><cell>25.6</cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">VolVis: a diversified volume visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Avila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Sobierajski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization&apos; 94</title>
		<meeting>Visualization&apos; 94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Frequency analysis of gradient estimators in volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Bentum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B A</forename><surname>Lichtenbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Malzbender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="242" to="254" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Light reflection functions for simulation of clouds and dusty surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Blinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;82</title>
		<meeting>SIGGRAPH &apos;82</meeting>
		<imprint>
			<date type="published" when="1982" />
			<biblScope unit="page" from="21" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1994 Symposium on Volume Visualization</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive direct volume rendering of timevarying data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clyne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Dennis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VisSym&apos;99</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Texture splats for 3D scalar and vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization&apos;93</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="261" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH&apos;88</title>
		<meeting>SIGGRAPH&apos;88</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A virtual body model for surgical education and rehearsal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Hoehne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pfiesser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pommert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schiemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Tiede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Virtual voyage: intercative navigation in the human colon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muraki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIG-GRAPH&apos;97</title>
		<meeting>SIG-GRAPH&apos;97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Progressive Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH&apos;96</title>
		<meeting>SIGGRAPH&apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Edge preservation in volume rendering using splatting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stredney</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="63" to="69" />
		</imprint>
	</monogr>
	<note>Symp. Volume. Vis.</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Ray tracing volume densities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Kajiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Von Herzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;84</title>
		<meeting>SIGGRAPH &apos;84</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="165" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast volume rendering using a shear-warp factorization of the viewing transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lacroute</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;94</title>
		<meeting>SIGGRAPH &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="451" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comp. Graph. &amp; Appl</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient ray tracing of volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comp. Graph</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="261" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multi-dimensional digital image representations using generalized Kaiser-Bessel window functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Lewitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Opt. Sec. Am. A</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1834" to="1846" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Marching cubes: a high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH&apos;87</title>
		<meeting>SIGGRAPH&apos;87</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient Feed-Forward Volume Rendering Techniques for Vector and Parallel Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Machiraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SUPERCOM-PUTING&apos;93</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="699" to="708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optical models for direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. and Comp. Graph</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="99" to="108" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A comparison of normal estimation schemes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Moeller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Machiraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization&apos;97</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast perspective volume rendering with splatting by using a ray-driven approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization&apos;96</title>
		<meeting>Visualization&apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="65" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">High-quality splatting on rectilinear grids with efficient culling of occluded voxels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comp. Graph</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="116" to="134" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Eliminating popping artifacts in sheet buffer-based splatting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization&apos;98</title>
		<meeting>Visualization&apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="239" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">EM-Cube: an architecture for low-cost real-time volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Osborne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ohkami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckenzie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hiatt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics Hardware Rendering Workshop</title>
		<meeting>Eurographics Hardware Rendering Workshop</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="131" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Interactive ray tracing for isosurface rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sloan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Vis&apos;98</title>
		<meeting>Vis&apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="233" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">A fast approximation to 3D euclidian distance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ritter</surname></persName>
		</author>
		<editor>A. Glassner</editor>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Academic Press</publisher>
			<biblScope unit="page" from="432" to="433" />
		</imprint>
	</monogr>
	<note>Graphics Gems</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">High quality rendering of attributed volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Tiede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schiemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Hoehne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization&apos;98</title>
		<meeting>Visualization&apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="255" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Direct volume rendering via 3D texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc</title>
		<imprint>
			<biblScope unit="page" from="23" to="30" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficiently using graphics hardware in volume rendering applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH&apos;99</title>
		<meeting>SIGGRAPH&apos;99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="169" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Interactive volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1989 Chapel Hill Volume Visualization Workshop</title>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Footprint evaluation for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-GRAPH&apos;90</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="367" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">SPLATTING: A parallel, feed-forward volume rendering algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<publisher>PhD Dissert., UNC-Chapel Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A volumetric approach to virtual simulation of functional endoscopic sinus surgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Wiet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stredney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schmalbrock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Sessanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kurzion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Rosenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Medicine Meets Virtual Reality</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A coherent projection approach for direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;91 Proceedings)</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="275" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Opacity-weighted color interpolation for volume sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wittenbrink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Malzbender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Goss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1998 Symposium on Volume Visualization</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
