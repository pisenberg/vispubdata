<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Multi-Threaded Streaming Pipeline Architecture for Large Structured Data Sets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">Charles</forename><surname>Law</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">(</forename><surname>Kitware</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kitware</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Temkin</surname></persName>
						</author>
						<author>
							<affiliation>
								<orgName>Inc. </orgName>
							</affiliation>
						</author>
						<author>
							<affiliation>
								<orgName> Inc. </orgName>
							</affiliation>
						</author>
						<author>
							<affiliation>
								<orgName> Inc.</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Multi-Threaded Streaming Pipeline Architecture for Large Structured Data Sets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Computer simulation and digital measuring systems are now generating data of unprecedented size. The size of data is becoming so large that conventional visualization tools are incapable of processing it, which is in turn is impacting the effectiveness of computational tools. In this paper we describe an object-oriented architecture that addresses this problem by automatically breaking data into pieces, and then processes the data piece-by-piece within a pipeline of filters. The piece size is user specified and can be controlled to eliminate the need for swapping (i.e., relying on virtual memory). In addition, because piece size can be controlled, any size problem can be run on any size computer, at the expense of extra computational time. Furthermore, pieces are automatically broken into sub-pieces and each piece assigned to a different thread for parallel processing. This paper includes numerical performance studies and references to the source code which is freely available on the Web.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Computer simulation and digital measuring systems are now generating data of unprecedented size. For example, Kenwright <ref type="bibr" target="#b13">[Kenwright98b]</ref> describes computational fluid dynamics data sets of sizes ranging up to 600 GByte with larger data (terabytes) foreseen. Machiraju reports computational data sets of similar sizes <ref type="bibr" target="#b14">[Machiraju98]</ref>. Measuring systems are generating large data as well. It is anticipated that the Earth Orbiting Satellite (EOS) will generate a terabyte of data daily. Volumetric data sources such as CT, MRI, and confocal microscopy generate large volumetric data sets; the addition of time-captured data will multiply the overall sizes of these data sets dramatically.</p><p>A primary goal of visualization is to communicate information about large and complex data sets <ref type="bibr" target="#b19">[Schroeder97]</ref>. Generally, the benefit of visualization increases as the size and complexity of data increases. However, as data sizes increase, current visualization tools become ineffective due to loss of interactivity; or even fail, as data overwhelms the physical and virtual memory of the computer system. If researchers, engineers, scientists, and users of large data are to take full advantage of advances in computational simulation and digital measurement systems, visualization system must be designed to handle data sets of arbitrary size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Why Visualization Systems Fail</head><p>Conventional commercial visualization systems such as AVS <ref type="bibr" target="#b1">[AVS89]</ref> and IBM Data Explorer <ref type="bibr">[DataExplorer]</ref> fail in two important ways when encountering large data. First, interactive control of the visualization process is lost when the time to transmit, process, or render data becomes prohibitively large. (Large may mean millions of cells or primitives, which is relatively small compared to the data sizes quoted previously.) This difficulty causes significant delays in processing results because the ability to rapidly explore data is replaced with a hit-and-miss batch process or other ad hoc methods to reduce data size or extract regions of interest.</p><p>While the loss of interactivity is a serious problem, visualizing larger datasets may cause complete system failure. In this second failure mode, the physical or virtual memory address space of the computer is overwhelmed, and the system thrashes ineffectively or crashes catastrophically. The typical response to this problem is to buy larger computers such as a supercomputer, but this solution is prohibitive for all but the wealthiest computer users, and in many cases, may not solve the problem on the largest datasets.</p><p>These failures are typically due to one of four problems <ref type="bibr" target="#b6">[Cox97a]</ref>  <ref type="bibr" target="#b7">[Cox97b]</ref>) 1) The data may be too large for local computer memory resulting in excessive thrashing.</p><p>2) The data may be too large for local disk (either for storage or paging to virtual memory), making the system unusable.</p><p>3) The data may be too large for the combined capacity of remote and local disk. 4) The bandwidth and latency of data transfer causes bottlenecks and results in poorly performing or unusable systems. Creating successful visualization systems for big data requires addressing each of these four problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Goals of Large Data Visualization</head><p>We see two fundamental, but opposing, design goals for large data visualization systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>The system must be able to process any size data, on any size computer, without loss of information. The ability of a computer system to treat large data must scale well with processing power and available memory.</p><p>The quandary for the visualization scientist is that these goals call for the system to be as accurate as possible, and at the same time as interactive as possible. Accuracy is necessary when observing detailed quantitative behavior or comparing data. Interactivity is necessary to understand the overall structure of data or when looking for important features or other qualitative relationships. Often users adopt both goals during a visualization session. Interactive exploration is used to identify features of interest, at which point accurate visualizations are generated in order to understand detailed behavior or data values.</p><p>In this paper we focus on the first goal: to process any size data on any size computer, with good scalable characteristics as the computer system grows in memory, computational power, and data bandwidth. We believe this goal is the necessary starting point, since it is necessary to visualize large data before we can visualize it interactively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Approach</head><p>Successfully managing large data requires breaking data into pieces, and then processing each piece separately, or distributing each piece across a network for parallel processing. To obtain interactive performance, parallel algorithms must be developed (distributed and/or multithreaded) to achieve the highest possible processing rates, and the total data to be processed must be minimized by employing segmentation algorithms, subsampling, or multiresolution methods.</p><p>A subtle but fundamental requirement of a successful system is that it must manage the hierarchy of memory efficiently to achieve maximum data throughput. The hierarchy of memory ranges from tape archival systems, to remote disk, local disk, physical memory, cache, and register memory. The speed of data access can vary by orders of magnitude between each level, and significant computational expense is required to move the data between each level. Therefore, a well designed system will manage the memory hierarchy to avoid moving data between levels, and holding it at the highest possible level until processing is complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Desirable Features</head><p>We believe that there are several important characteristics of visualization systems that successfully contend with big data. Some of these include the following. the same results as a high-end, multiprocessor supercomputer with several gigabytes of memory, the difference being the time taken to complete the visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graceful</head><p>Minimizes Disk Access. One important lesson learned from conventional virtual memory operating systems is that depending on disk storage for computer memory is undesirable. Most users have experienced running programs which scale gracefully until the system begins swapping, at which point the elapsed time to complete the computation dramatically increases. This is because the time to write or read pages from disk is large compared to the time the CPU takes to perform a single instruction. For example, typical disk access time is on the order of tens of milliseconds (primarily disk head movement). During this same period of time several million operations can be performed by the CPU.</p><p>Cached. Modern computer systems are designed with data caches to improve performance. Data caches store pieces of data close to the CPU to minimize delays during read and write operations. Caches dramatically improve performance because frequently used data or code can be accessed faster than less frequently used data or code. Appropriate use of caching when visualizing big data objects can dramatically increase the performance of the system. <ref type="bibr" target="#b7">Cox97b]</ref> have observed that the amount of data actually generated by a visualization algorithm is small compared to the total amount of data. For example, streamline generation is typically of order O(N), where N 3 is the size of the dataset. Isosurface generation is typically of order O(N 2 ) since a surface is generated from a volume of data. The implication is that sparse or parsimonious traversal methods can be created which dramatically reduce the amount of data accessed by the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parsimonious. Cox and Ellsworth [Cox97a] [</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parallel.</head><p>Parallel processing techniques have demonstrated their ability to greatly accelerate computation, and computer systems are often configured with more than one processor. Visualization systems must take advantage of this capability to deliver timely results. Current visualization systems are parallelized in two ways: either on a per algorithm basis (fine-grained parallelism) or across parallel branches of data flow (coarse-grained parallelism). Both methods of parallelism should be supported.</p><p>Hardware Architecture Independent. It is important to develop systems not tied to a particular computer architecture. For example, depending on shared memory parallel processing will fail once data size exceeds shared memory space. Similarly, systems based on a network of heterogeneous computers exclude "typical" engineers and scientists users with a modest single processor system. Visualization systems must be adaptable to a variety of hardware architectures, including the simplest single processor modest memory system of most users.</p><p>Demand-Driven. Demand-driven or lazy evaluation systems perform operations on data only when absolutely required. In many cases this avoids unnecessary work. For example, since computing streamlines in a grid requires only a portion of the original data, loading and processing only the data necessary to perform particle advection can reduce computational and memory costs significantly. Of course, the advantages of caching described earlier point to the fact that lazy evaluation must be tempered by careful consideration of the granularity of data access and evaluation.</p><p>Component Based. Commercial visualization systems such as AVS and IBM Data Explorer clearly demonstrate the benefit of component based systems. These systems enable users to run-time configure visualizations by connecting objects, or components, into data flow networks. The network is then executed to generate the desired result. Benefits of this approach include adaptability and flexibility to changing data and visualization needs. The power of component-based systems is that the components are general and can be reused in different applications. Such reuse can be a significant advantage over customized applications, since the effort to maintain and tune components has immediate impact across all applications using them. Tailored applications often suffer from a limited user base (which has impact on long-term survivability of the application), and are often difficult to modify-it is often not possible to drop in a new component to replace an older one.</p><p>Streaming. Many visualizations consist of a sequence of operations. For example, in our work we routinely use combinations of data subsampling (extract portion of data), isosurfacing, decimation (reduce mesh size), Laplacian smoothing, and surface normal generation to create high quality images of 3D contour surfaces. These operations are typically implemented by applying a pipeline of reusable components to a stream of data. In conventional use, the size of the data stream is controlled by the size of the input data. When the data is big, however, we would prefer to control the size of the data stream based on runtime configurable memory limits, perhaps on a component-by-component basis.</p><p>Other important features of a good software design such as efficiency, ease of use, extensibility, and robustness are also important and assumed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Previous Approaches</head><p>Two general approaches have been used to process large data sets: use of out-of-core algorithms and design of large data architectures. Multiresolution methods form a third approach, and are typically used in visualization systems with a primary goal of interactivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Large Data Algorithms</head><p>Feature extraction has been a successful technique for processing large data sets. The idea behind these approaches is to employ out-of-core or incremental algorithms with a controllable memory footprint.  <ref type="bibr" target="#b12">[Kenwright98]</ref>, and vortex core lines ( <ref type="bibr" target="#b11">[Kenwright97]</ref>). Typically the algorithm will extract pertinent features (e.g., an isosurface) and incrementally write the output to disk. Feature extraction is then followed by an interactive visualization of the extracted feature.</p><p>There are two difficulties with this approach. First, the approach presumes that the extracted features are sufficiently small enough to fit into system memory-a poor assumption as data sizes increase in size. Eventually, the extracted features will be large enough that they will not fit into memory. Second, the extraction of features depends on I/O from disk. Data that must be processed by a series of filters must be read and written to and from disk several times, a poor use of the memory hierarchy, and likely to result in poorer performing visualization systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Large Data Architectures</head><p>Another approach is the design of architectures to directly support large data visualization. For example, researchers at NASA Ames replace the virtual memory system, using an intelligent paging scheme that recognizes the structure and boundaries of data [Cox97a] <ref type="bibr" target="#b7">[Cox97b]</ref>. This approach has demonstrated significant improvements over standard virtual memory. It is best suited for the application of a single algorithm. We believe this approach is not as effective for supporting a pipeline of filtering operations. Using the virtual paging scheme, memory is repeatedly swapped as each algorithm processes the entire dataset, one after the other. Instead, we believe that ingesting a piece (subset of the entire dataset) of data, and then processing the entire piece-without any swapping-through the pipeline can achieve dramatically better results. This approach, which we call data streaming, has the benefit that data remains in higher-performing memory as it is processed.</p><p>Another successful system was developed by Haimes. This system, pv3, is an implementation of the Visual3 visualization application in the pvm environment. The application operates on a network of heterogeneous computers that process data in pieces, ultimately sending output to a collector that gathers and displays the results. While successful, pv3 is not a general application solution since it is a custom application, and offers no reusable components. Furthermore, depending on a collector is problematic in the larger data environment. This solution also seems vulnerable to network bandwidth and latency limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Multi-Threaded Data Streaming</head><p>The key to the structured data streaming pipeline is the ability to break data into pieces. By controlling the piece size carefully, we can avoid swapping and insure that the data is processed in physical memory (or better). The piece size is set at run-time depending on the size of computer memory, the number of filters in the visualization pipeline, and the size of data. In addition, using the same process to break data into pieces, we can break pieces into sub-pieces for the purpose of multi-threading, each processor taking one sub-piece. Thus our approach naturally supports shared-memory parallel processing.</p><p>The overarching goal of this work was to create a multithreaded, streaming architecture for the structured points (i.e., images and volumes) portion of the Visualization Toolkit (VTK) <ref type="bibr" target="#b19">[Schroeder97]</ref>. Limiting the problem to structured data greatly simplified the design. In the future we plan on extending our approach to unstructured data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Key Principles</head><p>The following three principles guided the design of the multi-threaded data streaming architecture for structured data.</p><p>1. Data Separability. The data must be separable. That is, the data can be broken into pieces. Ideally, each piece should be coherent in geometry, topology, and/or data structure. The separation of the data should be simple and efficient. In addition, the algorithms in this architecture must be able to correctly process pieces of data.</p><p>2. Mappable Input. In order to control the streaming of the data through a pipeline, we must be able to determine what portion of the input data is required to generate a given portion of the output. This allows us to control the size of the data through the pipeline, and configure the algorithms.</p><p>3. Result Invariant. The results should be independent of the number of pieces, and independent of the execution mode (i.e., single-or multi-threaded). This means proper handling of boundaries and developing algorithms that are multi-thread safe across pieces that may overlap on their boundaries.</p><p>Structured data is readily separable-the topological i-j-k coordinate scheme naturally breaks data into coherent pieces and was employed as the separation mechanism in the architecture. Most structured (i.e., imaging) algorithms are mappable since the input pixels required to produce an output pixel are known. And finally, careful design of the algorithms enables proper treatment of the boundary of each piece, thereby insuring that the output remains invariant as the number of pieces changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Architectural Overview</head><p>As previously mentioned, the basic idea behind our design is to control the amount of data passing through the pipeline at any given time. To do this, we replace the typical visualization pipeline architecture shown in Figure1(top) with that shown in Figure1(bottom). As shown in the figure, we augment the usual process object/data object pair with a third object-a data cache. The purpose of the cache is to manage allocation and access to the data. Fur-thermore, the cache negotiates with its upstream and downstream filters to configure the pipeline for execution. The negotiation process considers available memory (memory limits are set on a per cache basis), requested memory, algorithm kernel size (to determine whether boundary padding is required), and the size of the input and output data. In addition, each algorithm (i.e., filter) expects to operate on a piece of data rather than the entire data set. In fact, because the filters are designed to operate on pieces of data, it is possible to break a piece into subpieces and assign them to separate processor threads for parallel processing with little to no changes in the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Configuring the Pipeline</head><p>We will use Figure1(bottom) to illustrate the streaming architecture. Three process objects (a source R, filter F, and mapper object W), associated caches, and data objects are shown. In this example assume that the mapper is generating output data that may be written to disk or rendered, and further assume that the input data size is greater than a user-specified memory limit.</p><p>When the request comes to write the data, a two stage process is initiated (the pipeline is demand driven, so the pipeline only executes when data is requested). In the first stage, the pipeline configures itself for streaming. The writer object requests a portion of data of size S from its input cache F c . F c has a memory limit S c != S. Assume in this example that F c grants a request of size S c with S c &lt; S. W accepts this grant and configures itself to process data in pieces of size S c . The configuration process continues with filter F. The filter is limited to generate an output of size S c (its cache limit), and has knowledge of the algorithm it implements such as kernel size (how many input pixels are required to generate an output pixel) and the relative difference in size between input and output (e.g., vtkImageMagnify can change output size by integer multiples of input size). This information is translated into a request for input of a particular size S R from cache R c . The negotiation process is repeated and filter F configures itself to operate on pieces of appropriate size, S R . Finally, In the second stage, the pipeline begins execution and begins streaming data through it. Note that each process object may operate on different number of pieces depending on the results of the negotiation process. In the worst case, filters like image histogram may have to revisit their input several times (in pieces) to generate a piece of output. This is because the histogram filter requires visiting all input pixels to generate the correct results for a single output pixel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Multithreading</head><p>Adding multi-threading to the pipeline configuration process is straightforward. Once the initial piece size is negotiated for each filter, pieces are further subdivided into sub-pieces depending on the number of available processors. Then each thread operates on a sub-piece in exactly the same way that pieces are operated on. For best performance each piece should fit in main memory and then each sub-piece will be 1/N the size of the piece, where N is the number of processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Handling Boundaries</head><p>Many algorithms require a kernel of data around an input data location to generate a single output value. For example, a Gaussian smoothing operation may take a 2x2 or 3x3 input kernel to generate an output data value. Such algorithms impact the process of generating pieces (and sub-pieces) since the pieces must be enlarged to support algorithm execution. This means that pieces may be generated with overlap, as shown in Figure2. As long as the overlap size relative to the piece size is relatively small, the impact on performance is minimal. Also, such overlap remains thread-safe, since separate threads can read from the same memory location-only when writing to the output that overlap must be eliminated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Object-Oriented Implementation</head><p>The structured data pipeline in the VTK visualization system contains several dozen filters. One of our concerns for implementing this architecture-which is much more complex than the typical visualization system-is that a complex implementation might result in a brittle or unmaintainable system. Fortunately, we were able to embed the complexity of the architecture into three superclasses, including an abstract superclass from which most all filters are derived. Subclasses (i.e., filters) remain relatively simple to create, with the usual care required with multi-threaded implementations.</p><p>The three superclasses encapsulating the stream architecture are:</p><p>1. vtkImageSource -the superclass for vtkImageFilter and all other process objects; synchronizes pipeline execution.</p><p>2. vtkImageFilter -the superclass for most structured filters. It performs the breaking of data into pieces and coordinates multithreading.</p><p>3. vtkImageCache -manages the interface between the data objects and the process objects.</p><p>Source code for the C++ implementation is available in VTK Version 2.2 (and later versions) from http://www.kitware.com/vtk.html.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results &amp; Discussion</head><p>To demonstrate the effectiveness of the streaming architecture, we evaluated it against the three different pipelines shown in Figure3. Each pipeline was run on a volumetric dataset of size 256x256x93 by 2 bytes, for a total input data size of 12.19 MBytes. Once read into the pipeline, the data was further expanded by the addition of an vtkImageCast filter (transformed the 2-byte short data to 4-byte floats, i.e., doubled the data size) and/or was passed through a vtkImageMagnify filter to further increase data size by 3x3x1 (i.e., a nine-times increase in data size). In addition, the filters were configured to retain their output data as the pipeline executed, and some filters (such as vtkImageGradient) expand their data during execution (vtkImageGradient by a factor of three because a scalar is expanded to a 3-vector). The total data processed by Pipeline #1 is 780 MBytes; by Pipeline #2: 3.76 GBytes; and by Pipeline #3: 475.4 MBytes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Effect of Swapping</head><p>The first numerical experiment demonstrates the effect of swapping on performance. Applications that depend on virtual memory suffer severe penalties because the speed of virtual memory is significantly less than physical memory. By controlling the size of data pieces streaming through the pipeline, we can avoid swapping and insure that data is processed only in physical memory.</p><p>Pipeline #1 was used to perform the experiment on a small system running Windows/NT with 128 MBytes of physical memory. While the input data is only 12.19 MBytes, the vtkImageMagnifyFilter expanded the data size by a factor of nine, followed by vtkImageGradient, which expanded the data by another factor of three, for a maximum data size of 329 MBytes. The experiment varied the cache size from 10 KBytes to 330 MBytes. (At 330 MBytes we depend entirely on system virtual memory.)</p><p>We also ran the same data on a two processor system to see the effect of multiprocessing. The results are shown below.</p><p>The results, plotted in Figure4, clearly demonstrates the effect of swapping. The best performance for a single processor system occurred when the cache size was set to 50 MBytes, which was 41 times faster than the results obtained when depending on virtual memory. Even when the cache size was set to a tiny 10 KBytes, we observed better performance than was obtained with virtual memory. There is a noticeable penalty as the cache becomes very small, since the overhead of breaking data into pieces   The effect of cache size on elapsed time for Pipeline #1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Onset of swap</head><p>affects performance. The performance for two processors showed similar results, although the effect due to small cache size was greater because each piece of data is divided in half and assigned to each of the two processors.</p><p>Another benefit of the streaming architecture is that we can process data whose size is greater than the physical address space of the computer. For example, using the same 32-bit NT, dual-processor system, we were able to process a peak data size of 25 GByte (vtkImageMagnify increased data size by a factor of 676) with a cache size of 50 MByte in approximately 3000 seconds. (This is because each piece is smaller than physical address space and we never need to allocate contiguous memory for the entire data set.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Multi-Threading and Cache Size</head><p>In the second numerical experiment, we compared the effect of varying cache size from 750 MByte down to 7.5 MByte for each of the three pipelines. In addition, the number of processors is varied between one and eight.</p><p>The computer system is a large 8-processor Infinite Reality SGI (R10000) with 3.5 GByte of physical memory. Because of the large physical memory and the cache size limit, the system did not swap. Therefore, the difference in elapsed time were due to the effects of more processors (multi-threading) or the overhead of processing data in pieces.   Elapsed time as number of processors and cache size is varied for Pipeline #3.</p><p>We noticed several interesting features in these results. First, with a single processor, the effect of cache size (breaking data into pieces) was small. In some cases the reduction in cache size actually reduced the elapsed execution time of execution, probably because the data better fit into machine cache. The major exception to this was Pipeline #3. This pipeline is different from the other two in that a branch exists in the pipeline. When generating results, the pipeline evaluates first one branch, and then the other. As the cache at the point of pipeline junction (i.e., vtkImageFFT) is reduced in size, less reusable data is cached. The net result is that for small cache sizes the two filters upstream of vtkImageFFT execute two times: first for the left branch and then for the right branch. (Performance could be improved by increasing the cache size at the point of branching.)</p><p>Another striking feature is the effect of reducing cache size combined with adding additional computational threads. Since with single processor systems we observed that the effect of streaming was relatively small, we surmise that the overhead of creating and joining threads becomes significant as the size of the cache becomes smaller. (Note: in the eight-processor case, each piece of data is processed by eight threads in each filter. Therefore, as the piece size becomes smaller, each thread works on less data, so the overhead of thread management becomes proportionally larger.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions &amp; Future Work</head><p>We have successfully designed and implemented an object-oriented architecture that can process structured data of arbitrary size on computers whose physical memory is much smaller than the data size. The architecture achieves this capability by breaking data into pieces as a function of a specified cache (or memory limit) size. In addition, the architecture supports multi-threading automatically without requiring reconfiguration of execution scripts. We found that the effect of streaming (breaking data into pieces) is small for uniprocessor systems, and that the cost of thread management becomes larger as the piece size is reduced. We also demonstrated the capability of systems to process data whose size is much greater than the size of physical memory.</p><p>Our ultimate goal is to incorporate the streaming architecture into VTK's unstructured visualization pipeline. This is a difficult task for several reasons. First, the data type changes as it passes through the pipeline; e.g., a structured grid when isosurfaced becomes a polygonal (triangle) mesh. Second, it is difficult to map the input to the output. For example, it is not known beforehand which cells, when isosurfaced, will generate surface primitives, and how many resulting primitives are generated. Third, it is difficult to break data into pieces since there are no natural boundaries in unstructured data. And finally, many algorithms are global in nature. Connectivity and streamlines require data in an unpredictable manner, or in its entirety, in order to execute.</p><p>Incorporating the streaming architecture into the unstructured pipeline may require changes to algorithms and accepting certain compromises. For example, global algorithms such as streamline generation may be recast (use algorithms with local kernels such as LIC <ref type="bibr" target="#b2">[Cabral93]</ref>), or decimation <ref type="bibr" target="#b18">[Schroeder92a]</ref> may occur in patches with boundary seams visible (not results invariant). It may also be that the architecture is extended to support multipass streaming where filters retain information between each pass.</p><p>The computing environment of the future will consist of a heterogeneous mixture of single-and multi-processor computing systems arranged on a high-speed network. While the architecture described here supports a (local) multi-processor, shared memory approach, it is readily extensible to the distributed environment. In a distributed environment, data can be broken into pieces (using the same approach described here) and assigned to systems across the network. Future plans call for distributed support to be built directly into VTK.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgment</head><p>This work was partially supported by the NSF Award #9872147. Thanks to Bill Lorensen for his insightful advice, to James Miller for assisting us in the numerical studies, and our colleagues at GE CRD and GE Medical Systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>pipeline (top) compared to a streaming pipeline (bottom). Cache, F c the reader configures itself to generate pieces of size S R which completes the first stage of the configuration process.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .Figure 3 .</head><label>23</label><figDesc>Pieces may be created that overlap one another. The overlap depends on algorithmic kenel size. Three pipelines used to test the streaming architecture. The vtkImageCastFilter in pipelines #1 and #2 is used to control the size of the input data. Note that while the images show just a single slice, the entire input volume is processed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 4. The effect of cache size on elapsed time for Pipeline #1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Elapsed time as number of processors and cache size is varied for Pipeline #1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Elapsed time as number of processors and cache size is varied for Pipeline #2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Elapsed time as number of processors and cache size is varied for Pipeline #3.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">. The system must be allow users to quickly identify important regions in the data, and then enable focused attention on those regions in ever greater detail (to the limit of the resolution of the data).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Murali, and others. I/O-Efficient Algorithms for Contour-Line Extraction and Planar Graph Blocking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symp. On Discrete Algorithms</title>
		<meeting>ACM-SIAM Symp. On Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Kamins and others. The Application Visualization System: A Computational Environment for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Imaging Vector Fields Using Line Integral Convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;93 Proceedings)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">External-Memory Graph Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symp. On Discrete Algorithms</title>
		<meeting>ACM-SIAM Symp. On Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="139" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">I/O Optimal Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Of Visualization &apos;97</title>
		<meeting>Of Visualization &apos;97</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Interactive Out-of-Core Isosurface Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-J</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Of Visualization &apos;98</title>
		<meeting>Of Visualization &apos;98</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Application-Controlled Demand Paging for Out-Of-Core Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Of Visualization &apos;97</title>
		<meeting>Of Visualization &apos;97</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Managing Big Data for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ellsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Siggraph &apos;97 Course #4 Exploring Gigabyte Datasets in Real-Time: Algorithms, Data Management, and Time-Critical Design</title>
		<imprint>
			<date type="published" when="1997-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Data Explorer Reference Manual. IBM Corp</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Database Management for Models Larger Than Main Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Sequin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Khorramabadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">teractive Walkthrough of Large Geometric Fatabases, Course Notes 32, Siggraph &apos;95</title>
		<imprint>
			<date type="published" when="1995-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic Isosurface Propagation Using an Extrema Graph and Sorted Boundary Cell Lists</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. On Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Vortex Identification -Applications in Aerodynamics: A Case Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kenwright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Of Visualization &apos;97</title>
		<meeting>Of Visualization &apos;97</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automatic Detection of Open and Closed Separation and Attachment Lines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kenwright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Of Visualization &apos;98</title>
		<meeting>Of Visualization &apos;98</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Presentation to Scientific Computation Research Center (SCOREC) at Rensselaer Polytechnic Institute</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kenwright</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Detection and Enhancement of Scale Coherent Structures Using Wavelet Transform Products</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Machiraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gaddipati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m">Proc. of the Tech. Conf. on Wavelets in Image and Signal Processing SPIE Annual Meeting</title>
		<meeting>of the Tech. Conf. on Wavelets in Image and Signal essing SPIE Annual Meeting<address><addrLine>San Diego CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Machiraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<title level="m">Efficient Feed-Forward Volume Rendering Techniques for Vector and Parallel Processors. SUPERCOM-PUTING&apos;93</title>
		<meeting><address><addrLine>Portland, Oregon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-11" />
			<biblScope unit="page" from="699" to="708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Path Cathcing: A Technique forOptimal External Searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramaswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. On Principles of Database Sys</title>
		<meeting>ACM Symp. On Principles of Database Sys</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="25" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Decimation of Triangle Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH `92)</title>
		<imprint>
			<publisher>August</publisher>
			<date type="published" when="1992" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit An Object-Oriented Approach To 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Upper Saddle River, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The P-Range Tree: A New Data Structure for Range Searching in Secondary memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramaswamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symp. On Discrete Algorithms</title>
		<meeting>ACM-SIAM Symp. On Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="378" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Partitioning and Ordering Large Radiosity Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Of SIG-GRAPH &apos;94</title>
		<meeting>Of SIG-GRAPH &apos;94</meeting>
		<imprint>
			<date type="published" when="1994-07" />
			<biblScope unit="page" from="443" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Out-of-Core Streamline Visualization on Large Unstructured Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Ueng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sikorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient 3-D Range Searching in External Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Vengroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Annu. ACM Sympos. Theory, Comp</title>
		<meeting>Annu. ACM Sympos. Theory, Comp</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="192" to="201" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
