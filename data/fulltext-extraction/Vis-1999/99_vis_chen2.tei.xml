<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">LOD-Sprite Technique for Accelerated Terrain Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baoquan</forename><surname>Chen</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science, State University of New York at Stony Brook, Stony Brook</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eddy</forename><surname>Kuo</surname></persName>
							<email>ekuo@homemail.com</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Naval Research Lab</orgName>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="laboratory">Virtual Reality Laboratory, Naval Research Laboratory Code 5580</orgName>
								<address>
									<addrLine>4555 Overlook Ave SW, Washington, DC</addrLine>
									<postCode>20375-5320</postCode>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science, State University of New York at Stony Brook, Stony Brook</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">SUNY at Stony Brook J. Edward Swan II</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Naval Research Lab</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">LOD-Sprite Technique for Accelerated Terrain Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Image-Based Modeling and Rendering</term>
					<term>Texture Mapping</term>
					<term>Acceleration Techniques</term>
					<term>Multi-Resolution</term>
					<term>Level of Detail</term>
					<term>Terrain Rendering</term>
					<term>Virtual Reality</term>
					<term>Virtual Environments</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present a new rendering technique, termed LOD-sprite rendering, which uses a combination of a level-of-detail (LOD) representation of the scene together with reusing image sprites (previously rendered images). Our primary application is accelerating terrain rendering. The LOD-sprite technique renders an initial frame using a high-resolution model of the scene geometry. It renders subsequent frames with a much lower-resolution model of the scene geometry and texture-maps each polygon with the image sprite from the initial high-resolution frame. As it renders these subsequent frames the technique measures the error associated with the divergence of the view position from the position where the initial frame was rendered. Once this error exceeds a user-defined threshold, the technique re-renders the scene from the high-resolution model. We have efficiently implemented the LOD-sprite technique with texture-mapping graphics hardware. Although to date we have only applied LOD-sprite to terrain rendering, it could easily be extended to other applications. We feel LOD-sprite holds particular promise for real-time rendering systems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>As scene geometry becomes complex (into the millions of polygons), even the most advanced rendering hardware cannot provide interactive rates. Current satellite imaging technology provides terrain datasets which are well beyond this level of complexity. This presents two problems for real-time systems: 1) the provided frame rate may be insufficient, and 2) the system latency may be too high. Much of real-time computer graphics has been dedicated to finding ways to trade off image quality for frame rate and/or system latency. Many recent efforts fall into two general categories:</p><p>Level-of-detail (LOD): These techniques model the objects in the scene at different levels of detail. They select a particular LOD for each object based on various considerations such as the rendering cost and perceptual contribution to the final image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Image-based modeling and rendering (IBMR):</head><p>These techniques model (some of the) objects in the scene as image sprites. These sprites only require 2D transformations for most rendering operations, which, depending on the object, can result in substantial time savings. However, the 2D transformations eventually result in distortions which require the underlying objects to be re-rendered from their full 3D geometry. IBMR techniques typically organize the scene into separate non-occluding layers, where each layer consists of an object or a small group of related objects. They render each layer separately, and then alpha-channel composite them.</p><p>Some hybrid techniques use both multiple LODs and IBMR methods <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b21">22]</ref>. A general pipeline of these techniques is shown in <ref type="figure">Figure 1</ref>. Each 3D object is first subjected to a culling operation. Then, depending upon user-supplied quality parameters, the system either renders the object at a particular LOD, or it reuses a cached sprite of the object.</p><p>This paper presents the LOD-sprite rendering technique. As shown in <ref type="figure">Figure 2</ref>, the technique is similar to previous hybrid techniques in that it utilizes view frustum culling and a user-supplied quality metric. Objects are also modeled as both LOD models and sprites. However, the LOD-sprite technique differs in that the 2D sprite is coupled with the LOD representation; the renderer utilizes both the LOD and the sprite as the inputs to create the output image. The LOD-sprite technique first renders a frame from highresolution 3D scene geometry, and then caches this frame as an image sprite. It renders subsequent frames by texture-mapping the cached image sprite onto a lower-resolution representation of the scene geometry. This continues until an image quality metric requires again rendering the scene from the high-resolution geometry.</p><p>We have developed the LOD-sprite technique as part of the rendering engine for a real-time, three-dimensional battlefield visualization system <ref type="bibr" target="#b8">[9]</ref>. For this application the terrain database consumes the vast majority of the rendering resources, and therefore in this paper our focus is on terrain rendering. However, LOD-sprite is a general-purpose rendering technique and could certainly be applied to many different types of scene geometry.</p><p>The primary advantage of LOD-sprite over previous techniques is that when the sprite is transformed, if the 2D transformation is within the context of an underlying 3D structure (even if only com-posed of a few polygons), a much larger transformation can occur before image distortions require re-rendering the sprite from the full 3D scene geometry. Thus, the LOD-sprite technique can reuse image sprites for a larger number of frames than previous techniques. In addition, because the sprite preserves object details, a lower LOD model can be used for the same image quality. These properties allow interactive frame rates for larger scene databases.</p><p>The next section of this paper places LOD-sprite in the context of previous work. Section 3 describes the LOD-sprite technique itself. Section 4 presents the results of our implementation of LOD-sprite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>The previous work which is most closely related to LOD-sprite can be classified into image-based modeling and rendering techniques and level-of-detail techniques. We first revisit and classify previous IBMR techniques while also considering LOD techniques, and then focus on some hybrid techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Image-Based Modeling and Rendering</head><p>Previous work in image-based modeling and rendering falls primarily into three categories:</p><p>(1) The scene is modeled by 2D image sprites; no 3D geometry is used. Many previous techniques model the 3D scene by registering a number of static images <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b25">26]</ref>. These techniques are particularly well-suited for applications where photographs are easy to take but modeling the scene would be difficult (outdoor settings, for example). Novel views of the scene are created by 2D transforming and interpolating between images <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">18]</ref>. By adding depth <ref type="bibr" target="#b16">[17]</ref> or even layered depth <ref type="bibr" target="#b22">[23]</ref> to the sprites, more realistic navigation, which includes limited parallax, is possible. Another category samples the full plenoptic function, resulting in 3D, 4D or even 5D image sprites <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b9">10]</ref>, which allow the most unrestricted navigation of this class of techniques. However, all of these techniques lack the full 3D structure of the scene, and so restrict navigation to at least some degree.</p><p>(2) The scene is modeled using either 3D geometry or 2D image sprites. Another set of previous techniques model each object with either 3D geometry or a 2D image sprite, based on object contribution to the final image and / or viewing direction <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b26">27]</ref>. The LOD-sprite technique differs from these techniques in that it integrates both 3D geometry and 2D image sprites to model and render objects.</p><p>(3) The scene is modeled using a combination of 3D geometry and 2D image sprites. There are a group of techniques which add very simple 3D geometry to a single 2D image <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b23">24]</ref>, which guides the subsequent image warping. Debevec et al. <ref type="bibr" target="#b6">[7]</ref> construct a 3D model from reference images, while Sillion et al. <ref type="bibr" target="#b23">[24]</ref> and Darsa et al. <ref type="bibr" target="#b5">[6]</ref> use a textured depth mesh which is constructed and simplified from depth information. In general, using a depth mesh with projective texture mapping gives better image quality than using depth image warping <ref type="bibr" target="#b16">[17]</ref>, because the mesh stretches to cover regions where no pixel information is available, and thus no holes appear. The main advantage of adding 3D scene geometry to the image is that it allows the warping to approximate parallax, and therefore increases the range of novel views which are possible before image distortion becomes too severe.</p><p>Our LOD-sprite is most closely related to the techniques of Cohen et al. <ref type="bibr" target="#b3">[4]</ref> and Soucy et al. <ref type="bibr" target="#b24">[25]</ref>. Both create a texture map from a 3D object represented at a high geometric resolution, and then subsequently represent the object at a much lower geometric resolution, but apply the previously created texture map to the geometry.</p><p>However, the LOD-sprite technique generates texture maps (image sprites) from images rendered at run-time, while these techniques generate the texture map from the object itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Level-of-Detail</head><p>There is a large body of previous work in level-of-detail (LOD) techniques, which is not reviewed here. The general LOD-sprite technique requires that geometric objects be represented at various levels of detail, but it does not require any particular LOD representation or technique (although a specific implementation of LODsprite will need to access the underlying LOD data structures).</p><p>This paper does not cover how to create LOD representations of a terrain -there exist numerous multiresolution representations for height fields. Lindstrom et al. <ref type="bibr" target="#b13">[14]</ref> and Hoppe <ref type="bibr" target="#b10">[11]</ref> represent the most recent view-dependent terrain LOD methods, and Luebke and Erikson <ref type="bibr" target="#b14">[15]</ref> can also be adapted for terrain datasets. In this paper we adopt the technique of Lindstrom et al. <ref type="bibr" target="#b13">[14]</ref>. This algorithm organizes the terrain mesh into a hierarchical quadtree structure. To decide which quadrant level to use, the algorithm computes a screen space error for each vertex, and compares it to a pre-defined error threshold. This error measures the pixel difference between the fullresolution and lower-resolution representations of the quadrant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Accelerated Virtual Environment Navigation</head><p>As stated above, many LOD and IBMR techniques have been applied to the problem of accelerating virtual environment navigation. Of these, LOD-sprite is most closely related to the techniques of Maciel and Shirley <ref type="bibr" target="#b15">[16]</ref>, Shade et al. <ref type="bibr" target="#b21">[22]</ref>, Schaufler and Stuerzlinger <ref type="bibr" target="#b20">[21]</ref>, and Aliaga <ref type="bibr" target="#b0">[1]</ref>. All of these papers present similar hybrid LOD/IBMR techniques. They create a hierarchy of image sprites based on a space partition of the scene geometry. In subsequent frames, for each node the techniques either texture map the node sprite onto a polygon, or re-render the node's 3D geometry if an error metric is above a threshold. Each reused image sprite means an entire subtree of 3D geometry need not be rendered, which yields substantial speedup for navigating large virtual environments. The main limitation of these techniques is that creating a balanced space partition is not a quick operation, and it must be updated if objects move. Also, to avoid gaps between neighboring partitions, they either maintain a fairly large amount of overlap between partitions <ref type="bibr" target="#b21">[22]</ref>, or they morph geometries to guarantee a smooth transition between geometry and sprite <ref type="bibr" target="#b0">[1]</ref>; both operations add storage and computational complexity. LOD-sprite differs from these techniques in that they interpolate the image sprite on a single 2D polygon, while LOD-sprite interpolates the image sprite on a coarse representation of the 3D scene geometry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE LOD-SPRITE TECHNIQUE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Algorithm</head><p>The general idea of the LOD-sprite technique is to cache the rendered view of a high-resolution representation of the dataset. We refer to this image as a sprite, and the frame where the sprite is created as a keyframe. LOD-sprite renders subsequent frames, referred to as novel views, at a lower resolution, but applies the sprite as a texture map. LOD-sprite measures the error caused by the divergence of the viewpoint from the keyframe as each novel view is rendered. When this error exceeds a threshold, LOD-sprite renders a new keyframe.</p><p>Pseudocode for the LOD-sprite algorithm is given in <ref type="figure" target="#fig_1">Figure 3</ref>. Lines 1 and 5 generate a sprite image from high-resolution scene geometry. This is necessary whenever the viewer jumps to a new viewpoint position (line 1), and when LOD-sprite generates a new  keyframe (line 5). At line 2 the algorithm processes each novel viewpoint. Lines 3 and 4 measure the error associated with how far the current viewpoint diverges from viewpoint at the time when the sprite was rendered; the procedure ErrorMetric is described in Section 3.2. At line 6 the algorithm prepares to render the frame at the current viewpoint by gathering a set of polygons from a low-resolution version of the scene geometry. Line 7 considers each polygon. Line 8 determines, for each low-resolution polygon, whether the polygon was visible when the sprite image was taken. This routine, WasVisible (described in Section 3.3), determines whether the polygon is texture mapped with the sprite texture (line 9) or the original texture map (line 11). The sprite data structure holds both the sprite texture map and the keyframe viewing parameters; LOD-sprite uses both to map polygons with the sprite texture in line 9. Creating a new sprite (lines 1 and 5) requires copying the frame buffer into texture memory, which is efficiently implemented with the OpenGL glCopyTexIm-age2D function.</p><p>Texture mapping a keyframe could be achieved using projective texture mapping: a light placed at the keyframe camera position projects the sprite image onto the scene geometry. However, our implementation of LOD-sprite does not use projective texture mapping, because the current OpenGL implementation does not test for polygon visibility. Occluded polygons in the keyframe are mapped with wrong textures when they become visible. Therefore, our implementation detects polygon visibility on its own (line 8), and applies a different texture map depending on each polygons' visibility (lines 9 and 11).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Error Metric</head><p>LOD-sprite decides when to render a new keyframe based on an error metric which is similar to that described by Shade et al. <ref type="bibr" target="#b21">[22]</ref>. <ref type="figure" target="#fig_2">Figure 4</ref> gives the technique, which is drawn in 2D for clarity. Consider rendering the full-resolution dataset from viewpoint position v1. In this case the line segments AC and CBare rendered (in 3D these are polygons). From this view, the ray passing through vertex C intersects the edge AB at point C 0 . After rendering the full-resolution dataset, the image from v1 is stored as a texture map. Now consider rendering the scene from the novel viewpoint v2, using the low-resolution representation of the dataset. In this case the line segment AB is rendered, and texture mapped with the sprite rendered from v1. Note that this projects the vertex C to the position C 0 on AB. From v1 this projection makes no visible differ-ence. However, from v2, vertex C 0 is shifted by the angle from its true location C. This angle can be converted to a pixel distance on the image plane of view v2, which is our measure of the error of rendering point C from view v2: ;</p><p>(1)</p><p>where is the view angle of a single pixel (e.g., the field-of-view over the screen resolution), and is a user-specified error threshold. As long as Equation 1 is true, we render using the sprite from the most recent keyframe (e.g., line 5 in <ref type="figure" target="#fig_1">Figure 3</ref> is skipped). Once Equation 1 becomes false, it is again necessary to render from the full-resolution dataset (e.g., line 5 in <ref type="figure" target="#fig_1">Figure 3</ref> is executed). Theoretically, we should evaluate Equation 1 for all points in the high-resolution dataset for each novel view. Clearly this is impractical. Instead, our implementation calculates for the central vertex of each low-resolution quadtree quadrant. The resolution of each quadrant is determined by the number of levels we traverse down into the quadtree that is created by our LOD algorithm <ref type="bibr" target="#b13">[14]</ref>. We calculate the central vertex by averaging the four corner vertices of the quadrant. To calculate , we have to know the point C 0 . We calculate C 0 by interesting the vector v1C with the plane spanned by the estimated central vertex and two original vertices of the quadrant. Once we know C 0 , we calculate from the dot product of the vectors v2C 0 and v2C.</p><formula xml:id="formula_0">θ v 1 v 2 C a A B b C ' α</formula><p>We next calculate the average sum of squares of the error for all evaluated quadrants and compare this with 2 :</p><formula xml:id="formula_1">P n i=1 2 i n 2 ;<label>(2)</label></formula><p>where n is the number of low-resolution quadrants. When this test fails, line 5 in <ref type="figure" target="#fig_1">Figure 3</ref> is executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Visibility Changes</head><p>As the viewpoint changes, polygons which were originally occluded or culled by the view frustum may become visible. <ref type="figure" target="#fig_4">Figure 5</ref> illustrates this problem. Let the two objects represent mountains. The light shaded region of the back mountain indicates occluded polygons in the keyframe, while the heavy shaded regions in both mountains show polygons culled by the view frustum. If these regions become visible in a novel view, there will be no sprite texture to map on them. Our solution is to map them with the same texture map we use to generate the keyframe. We classify the visibility of each polygon with a single pass over all vertices of the low-resolution geometry. This loop is part of the process of generating a new keyframe. For novel views, the visibility of each polygon to the sprite is already flagged. This visibility  flag controls which texture map is used for the polygon (and thus line 8 in <ref type="figure" target="#fig_1">Figure 3</ref> is a fast table look-up). OpenGL determines the visibility of each polygon from the novel viewpoint using the hardware z-buffer.</p><p>In our implementation, the terrain is represented by a triangle mesh. We determine the visibility of each low-resolution triangle using the keyframe viewing parameters and the keyframe zbuffer. Our visibility determination for each triangle is binary, which means we consider a partially occluded triangle to be fully occluded. We do not attempt to subdivide partially occluded triangles, because achieving this would require clipping the triangle into visible and invisible sub-triangles <ref type="bibr" target="#b7">[8]</ref>. This would not only be expensive, but would also generate too many small triangles.</p><p>To accurately detect visibility, we should scan-convert the whole triangle and detect the visibility of every pixel. This is obviously too expensive. Instead, we only perform this detection for the three triangle vertices. Only when all three vertices are visible do we flag the triangle as visible. Of course, this fails for triangles with unoccluded vertices but which are nevertheless partially occluded (e.g., a part of an edge and interior could be occluded). Such triangle will be erroneously flagged as visible. However, with terrain datasets this rarely occurs, since the projections of background triangles tend to be much smaller than foreground triangles.</p><p>We use the z-buffer to determine the visibility of each vertex. When we calculate a keyframe, we store both the z-buffer and the viewing matrix. Then, for each vertex, we calculate the x; y screen coordinate and the z-depth value with the keyframe viewing matrix. We compare this depth value to the z value at location x; y in the z-buffer. This tells us whether the vertex is occluded in the keyframe.</p><p>This raises several implementation issues. The first is that a vertex is usually not projected onto an integer grid point in the z-buffer.</p><p>Using the z-buffer value at the closest grid position does not always give the correct visibility, because that z value could represent a neighboring triangle. Interpolating between neighboring z values is also inappropriate, because they could represent disconnected objects. The second issue is that the LOD mesh is not static -we compare the low-resolution geometry to the z-buffer rendered from the high-resolution geometry.</p><p>Although it does not solve either of these problems, we have obtained good results in practice by using the following equation to determine visibility:</p><formula xml:id="formula_2">jZvertex , Z buffer j ; (3)</formula><p>where Zvertex is the calculated z value of the vertex, Z buffer is the zbuffer value at the closet grid point, and is the specified 'thickness' of the visible surface. When Equation 3 is true we flag the vertex as visible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Implementation Notes</head><p>To further enhance rendering time, we have tried to optimize our implementation for the graphics hardware. For each frame, we need two texture maps -the original texture map and the current keyframe -to map all of the visible polygons. It is much too costly to load the appropriate map into texture memory on a per-polygon basis. Instead, we load both maps into texture memory, and scale the calculated texture coordinates so that each polygon accesses the correct map. In addition, we use triangle strips as our rendering primitive. The drawback of this primitive is that we can only apply one texture map to the whole strip. For strips which contain both visible and invisible triangles, we can only use the original texture map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>Results are shown in <ref type="figure">Figures 6 and 7</ref>. The input is a 512 512 height field and 512 512 texture map. <ref type="figure">Figures 6a-e</ref> compare the LOD-sprite technique to a standard LOD technique <ref type="bibr" target="#b13">[14]</ref>. <ref type="figure">Figure 6a</ref> shows a terrain dataset rendered from a low-resolution LOD decomposition containing 1,503 triangles, while <ref type="figure">Figure 6b</ref> shows the same terrain rendered from a high-resolution decomposition with 387,973 triangles. Both figures use the same texture map. Comparing 6a to 6b, we see that, as expected, many surface features are smoothed out. <ref type="figure">Figure 6c</ref> shows the same view rendered with the LOD-sprite technique, using the same 1,503 triangles as  <ref type="figure">Figure 6d</ref> gives the absolute value of the difference between the high and low resolution images, while <ref type="figure">Figure 6e</ref> between the high and LOD-sprite images. <ref type="figure">Figures 6d and e</ref> clearly show the image-quality advantage of the LOD-sprite technique. Notice, however, the bright band along the silhouette, both against the horizon as well as the edge of the dataset in the lower left-hand corner of the images. These appear because our LOD decomposition <ref type="bibr" target="#b13">[14]</ref> is not sensitive to the edge of the dataset or to silhouette edges. <ref type="figure">Figure 7a</ref>-e show similar results but are rendered from a viewpoint over the mountains, looking down onto the plain beyond. In this figure note that the close mountains appear very similar at low resolution (a), high resolution (b), and with the LOD-sprite technique (c). This is because these mountains are so close that even at a high resolution the polygons are large, and the LOD decomposition keeps these polygons at full resolution. The difference images <ref type="figure">(Figures 7d and e</ref>) also demonstrate this. The comments regarding the silhouette edge given above also apply to this figure, although in this case the entire silhouette edge is also the edge of the data. <ref type="figure" target="#fig_2">Figures 9-14</ref> give the algorithm's timing behavior for the camera path shown in <ref type="figure" target="#fig_6">Figure 8</ref>. The camera starts away from the terrain, zooms in, flies over a plain, and then over a mountain range and onto the plain beyond. This path visits most of the interesting topological features of this dataset. The animation contains 600 frames for all the figures except for <ref type="figure" target="#fig_0">Figure 12</ref>, where the frame count is varied. Each frame was rendered at a resolution of 512 512 on an SGI Onyx 2 with 6 195MHz MIPS processors and Infinite Reality graphics. We rendered the same animation for three different runs: 1) using a high-resolution LOD decomposition, 2) using a low-resolution LOD decomposition, and 3) using the LOD-sprite technique. The LOD-sprite technique used the same settings as the high-resolution run for keyframes, and the same settings as the lowresolution run for the other frames. <ref type="figure">Figure 9</ref> shows how the number of triangles changes as each frame is rendered. The low-resolution and LOD-sprite runs have identical triangle counts, except at the keyframes. The high- resolution run requires about 2 orders of magnitude more triangles.</p><p>The semi-log plot shows that both triangle counts have a similar variation as the animation progresses. <ref type="figure">Figure 10</ref> shows how the LOD-sprite error (Section 3.2) changes as each frame is rendered. The error always starts from zero for a keyframe. As more novel views are interpolated from the keyframe, the error increases. When the error exceeds 1:0 pixels, we calculate another keyframe from the high-resolution scene geometry, which again drops the error to zero. <ref type="figure">Figure 11</ref> shows the amount of time required to render each frame. The high-resolution time runs along the top of the graph, at an average of 526 milliseconds per frame. The low-resolution time runs along the bottom, at an average of 22 milliseconds per frame. The rendering time for the LOD-sprite frames follows the low-resolution times, except when a new keyframe is rendered. For this animation the system generated 16 keyframes, at an average time of 680 milliseconds per keyframe. The great majority of the LOD-sprite frames are shown near the bottom of the graph; these took an average of 36 milliseconds to render. The overall average for LOD-sprite was 53 milliseconds per frame. <ref type="figure" target="#fig_0">Figure 12</ref> shows the fraction of the total number of rendered frames which are keyframes. This is plotted against the total number of frames rendered for the path shown in <ref type="figure" target="#fig_6">Figure 8</ref>. As expected, as more frames are rendered for a fixed path, the distance moved between each frame decreases, and so there is more coherence between successive frames. This figure shows how our system takes advantage of this increasing coherence by rendering a smaller fraction of keyframes. This figure also illustrates a useful property of the LOD-sprite technique for real-time systems: as the frame update rate increases, the LOD-sprite technique becomes even more efficient in terms of reusing keyframes. <ref type="figure" target="#fig_1">Figure 13</ref> also shows the fraction of the total number of rendered frames which are keyframes, but this time plots the fraction against the error threshold in pixels. As expected, a larger error threshold means fewer keyframes need to be rendered. However, the shape of this curve indicates a decreasing performance benefit as the error threshold exceeds about 1:0 pixel. For a given dataset and a path which is representative of the types of maneuvers the user is expected to make, this type of analysis can help determine the best error threshold versus performance tradeoff.</p><p>The LOD-sprite technique results in a substantial speedup over rendering a full-resolution dataset. Rendering 600 frames of the full-resolution dataset along the path in <ref type="figure" target="#fig_6">Figure 8</ref> takes 316 seconds. Rendering the same 600 frames with the LOD-sprite technique, using an error threshold of 1:0 pixel, takes 32 seconds -a speedup   <ref type="figure" target="#fig_2">Figure 14</ref> shows how the speedup varies as a function of the error threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSIONS AND FUTURE WORK</head><p>This paper has described the LOD-sprite rendering technique, and our application of the technique to accelerating terrain rendering. The technique is a combination of two rich directions in accelerated rendering for virtual environments: multiple level-of-detail (LOD) techniques, and image-based modeling and rendering (IBMR) techniques. It is a general-purpose rendering technique that could accelerate rendering for any application. It could be built upon any LOD decomposition technique. It improves the image quality of LOD techniques by preserving surface complexity, and it improves the efficiency of IBMR techniques by increasing the range of novel views that are possible. The LOD-sprite technique is particularly well-suited for real-time system architectures that decompose the Our primary applied thrust with this work is to augment the rendering engine of a real-time, three-dimensional battlefield visualization system <ref type="bibr" target="#b8">[9]</ref>. As this system operates in real-time, our most important item of future work is to address the variable latency caused by rendering the keyframes. One optimization is to use a dual-thread implementation, where one thread renders the keyframe while another renders each LOD-sprite frame. Another optimization is to render the keyframe in advance by predicting where the viewpoint will be when it is next time to render a keyframe. We can predict this by extrapolating from the past several viewpoint locations. Thus, we can begin rendering a new keyframe immediately after the previous keyframe has been rendered. If the system makes a bad prediction (perhaps the user makes a sudden, high-speed maneuver), two solutions are possible: 1) we could use the previous keyframe as the sprite for additional frames of LOD-sprite rendering, with the penalty that succeeding frames will have errors beyond the normal threshold. Or, 2) if the predicted viewpoint is closer to the current viewpoint than the current viewpoint is to the previous keyframe, we can use the predicted viewpoint as the keyframe in- stead. We are also considering implementing a cache of keyframes, which would accelerate the common virtual environment navigation behavior of moving back and forth within a particular viewing region. Issues include how many previous keyframes to cache, and choosing a cache replacement policy. The continuous LOD algorithm <ref type="bibr" target="#b13">[14]</ref> in our implementation is well-suited for our application of real-time terrain rendering. However, the low-resolution mesh generated by this technique does not preserve silhouette edges, which as demonstrated in <ref type="figure">Figures 6 and  7</ref>, forces us to use the original texture map along the silhouette. Another problem with many continuous-LOD techniques (including <ref type="bibr" target="#b13">[14]</ref>) is the artifact caused by sudden resolution changes, which results in a continuous popping effect during real-time flythroughs. The solution to this artifact is geomorphing, where the geometry is slowly changed over several frames. To address both of these issues we are currently integrating the LOD technique of Luebke and Erikson <ref type="bibr" target="#b14">[15]</ref>, which preserves silhouette edges and provides a nice framework for evaluating geomorphing techniques.</p><p>Finally, an important limiting factor for the performance of the LOD-sprite technique, as well as other image-based modeling and rendering techniques (e.g., <ref type="bibr" target="#b21">[22]</ref>), is that OpenGL requires texture maps to have dimensions which are powers of 2. Thus, many texels in our texture maps are actually unused. The LOD-sprite technique could be more efficiently implemented with graphics hardware that did not impose this constraint.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Traditional hybrid LOD and IBMR techniques render each object either as a sprite or at a certain level of detail. The LOD-sprite technique renders each object as both a sprite and as a geometric object at a certain level of detail.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Pseudocode for the LOD-Sprite algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Calculating the error metric.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>The originally occluded or view frustum culled objects may become visible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure 6a but texture mapped with Figure 6b. Unlike Figure 6a the surface features are quite well preserved, yet Figures 6a and 6c take the same amount of time (10 milliseconds) to render. Figures 6d and 6e give difference images;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>The camera path for </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>The number of triangles as a function of the frame number on a semi-log plot. (600 frames; path from Figure 8.) The error in pixels as a function of the frame number for the LOD-sprite run. (600 frames; path from Figure 8.) of 9.9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :Figure 12 :</head><label>1112</label><figDesc>The rendering time in milliseconds as a function of frame number. (600 frames; path from Figure 8.) The fraction of keyframes as a function of the total number of frames rendered. (Path from Figure 8.) scene into coherent layers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :Figure 14 :</head><label>1314</label><figDesc>The fraction of keyframes as a function of error threshold. (600 frames; path from Figure 8.) Speedup as a function of error threshold. 600 frames. (Path from Figure 8.)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We acknowledge the valuable contributions of Bala Krishna Nakshatrala for bug fixes and various improvements to the code, for re-generating the animations, and for help in preparing the graphs. This work was supported by Office of Naval Research grants N000149710402 and N0001499WR20011, and the National Science Foundation grant MIP-9527694. We acknowledge Larry Rosenblum for advice and direction during this project.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Visualization of complex models using dynamic texture-based simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Aliaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;96</title>
		<meeting>IEEE Visualization &apos;96</meeting>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="101" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Quicktime VR -an image-based approach to virtual environment navigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIG-GRAPH &apos;95)</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="29" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">View interpolation for image synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;93)</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="279" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Appearance-preserving simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Olano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;98)</title>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="115" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A real-time photo-realistic visual flythrough</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Rich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shenkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="255" to="264" />
			<date type="published" when="1996-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Navigating static environments using image-space simplification and morphing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Darsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1997-04" />
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modeling and rendering architecture from photographs: A hybrid geometryand image-based approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Debevec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIG-GRAPH &apos;96)</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient viewdependent image-based rendering with projective texturemapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Debevec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Borshukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rendering Techniques&apos;98</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="105" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Battlefield visualization on the responsive workbench</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Durbin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Swan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Colbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Crowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scannell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wartell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Welsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="463" to="466" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Gortler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Grzeszczuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Cohen</surname></persName>
		</author>
		<title level="m">The lumigraph. Computer Graphics (Proc. SIGGRAPH &apos;96)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="43" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Smooth view-dependent level-of-detail control and its application to terrain rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Tour into the picture: Using a spidery mesh interface to make animation from a single image</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Horry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Anjyo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Arai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;97)</title>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="225" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<title level="m">Light field rendering. Computer Graphics (Proc. SIGGRAPH &apos;96)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Real-Time, continuous level of detail rendering of height fields. Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">F</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;96)</title>
		<meeting>SIGGRAPH &apos;96)</meeting>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;97)</title>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Visual navigation of large environments using textured clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">W C</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1995-04" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Post-rendering 3D warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bishop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1997-04" />
			<biblScope unit="page" from="7" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Plenoptic modeling: An imagebased rendering system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bishop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIG-GRAPH &apos;95)</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="39" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multiple-center-of-projection images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rademacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bishop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;98)</title>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="199" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Priority rendering with a virtual reality address recalculation pipeline</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Regan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIGGRAPH &apos;94)</title>
		<imprint>
			<date type="published" when="1994-07" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A three dimensional image cache for virtual reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schaufler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuerzlinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum (Proc. of Eurographics &apos;96)</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="227" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Hierarchical image caching for accelerated walkthroughs of complex environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lischinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proc. SIG-GRAPH &apos;96)</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Gortler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
		<title level="m">Layered depth images. Computer Graphics (Proc. SIGGRAPH &apos;98)</title>
		<imprint>
			<date type="published" when="1998-07" />
			<biblScope unit="page" from="231" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient impostor manipulation for real-time visualization of urban scenery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sillion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Drettakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bodelet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum (Proc. of Eurographics &apos;97)</title>
		<imprint>
			<date type="published" when="1997-09" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="207" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A texture-mapping approach for the compression of colored 3D triangulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Soucy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Godin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rioux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="503" to="514" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Video mosaics for virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="22" to="30" />
			<date type="published" when="1996-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Torborg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kajiya</surname></persName>
		</author>
		<title level="m">Talisman: Commodity Real-time 3D graphics for the PC. Computer Graphics (Proc. SIGGRAPH &apos;96)</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="353" to="364" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
