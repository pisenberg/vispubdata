<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Skip Strips: Maintaining Triangle Strips for View-dependent Rendering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jihad</forename><surname>El-Sana</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Ben-Gurion University SUNY at Stony Brook Beer-Sheva</orgName>
								<address>
									<postCode>84105, 11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elvir</forename><surname>Azanli</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Ben-Gurion University SUNY at Stony Brook Beer-Sheva</orgName>
								<address>
									<postCode>84105, 11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Ben-Gurion University SUNY at Stony Brook Beer-Sheva</orgName>
								<address>
									<postCode>84105, 11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Skip Strips: Maintaining Triangle Strips for View-dependent Rendering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>View-dependent simplification has emerged as a powerful tool for graphics acceleration in visualization of complex environments. However, view-dependent simplification techniques have not been able to take full advantage of the underlying graphics hardware. Specifically, triangle strips are a widely used hardware-supported mechanism to compactly represent and efficiently render static triangle meshes. However, in a view-dependent framework, the triangle mesh connectivity changes at every frame making it difficult to use triangle strips. In this paper we present a novel data-structure, Skip Strip, that efficiently maintains triangle strips during such view-dependent changes. A Skip Strip stores the vertex hierarchy nodes in a skip-list-like manner with path compression. We anticipate that Skip Strips will provide a road-map to combine rendering acceleration techniques for static datasets, typical of retained-mode graphics applications, with those for dynamic datasets found in immediate-mode applications.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent advances in three-dimensional acquisition, simulation, and design technologies have led to generation of datasets that are beyond the interactive rendering capabilities of current graphics hardware. Several software and algorithmic solutions have been recently proposed to bridge the increasing gap between hardware capabilities and the complexity of the graphics datasets. These include level-of-detail rendering with multi-resolution hierarchies, occlusion culling, and imagebased rendering. Graphics rendering has also been accelerated through compact representations of polygonal meshes using data-structures such as triangle strips and triangle fans.</p><p>View-dependent simplifications have been recently introduced to enable fine-grained changes to multiresolution hierarchies that depend on parameters such as view location, illumination, and speed of motion. Such simplifications change the mesh structure at every frame to adapt to just the right level of detail necessary for visual realism. One drawback of such schemes is that they fail to take advantage of hardware-supported mechanisms for graphics acceleration, such as triangle strips. Luebke and Erikson <ref type="bibr" target="#b15">[15]</ref> point out that view-dependent simplification, being an immediatemode technique, has a relative disadvantage since most current graphics hardware takes advantage of retained-mode representations such as display lists that have static geometry and connectivity. To overcome this drawback Hoppe <ref type="bibr" target="#b12">[12]</ref> has proposed a solution to compute triangle strips per frame for the view-dependent simplification specific to that frame. In this paper we introduce Skip Strips as a solution to this dichotomy of immediate-mode simplifications and retainedmode hardware-supported acceleration.</p><p>A Skip Strip stores the vertex hierarchy nodes in a skip-listlike manner with path compression. Our approach combines the advantages of the two methods -selection of varied level of detail at different regions of the surface from view-dependent simplification and faster rendering from triangle strip representations. In addition, Skip Strips perform edge collapse and vertex split in constant time per operation, and the test to prevent foldovers at run time is done much faster as a result of using compact dependency lists. As other view-dependent simplification approaches, Skip Strips also take advantage of coherence between frames and incrementally update the displayed triangle strips. By using triangle strips, our algorithm is able to display the same number of triangles faster and uses less memory to store the active set of triangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Previous Work</head><p>In this section we give an overview of previous work done in the areas of view-dependent simplifications, triangle strip generation, and path compression data-structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">View-Dependent Simplifications</head><p>Most of the previous work on generating multiresolution hierarchies for level-of-detail-based rendering has concentrated on computing a fixed set of view-independent levels of detail. At runtime an appropriate level of detail is selected based on viewing parameters. Such methods are overly restrictive and do not take into account finer image-space feedback such as light position, visual acuity, silhouettes, and view direction. Recent advances to address some of these issues in a view-dependent manner take advantage of the temporal coherence to adaptively refine or simplify the polygonal environment from one frame to the next. In particular, adaptive levels of detail have been used in terrains by Gross et al <ref type="bibr" target="#b8">[8]</ref> and Lindstrom et al <ref type="bibr" target="#b13">[13]</ref>. A number of techniques for conducting view-dependent simplifications of generalized polygonal meshes rely on the primitive operations of vertex-split and edge collapse as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. The edge pc in the mesh on the left collapses to the vertex p and the resulting mesh is shown on the right. Conversely, the vertex p in the mesh on the right can split to the edge pc to generate the mesh on the left.</p><p>We refer to vertex p as the parent of vertex c (as c is created from p through a vertex split). The primitives of vertex split and edge collapse were proposed in the context of progressive meshes <ref type="bibr" target="#b11">[11]</ref>. View-dependent simplifications using the edgecollapse/vertex-split primitives include work by Xia et al <ref type="bibr" target="#b20">[20]</ref>, Hoppe <ref type="bibr" target="#b12">[12]</ref>, Guéziec et al <ref type="bibr" target="#b9">[9]</ref>, and El-Sana and Varshney <ref type="bibr" target="#b3">[4]</ref>. View-dependent simplifications by Luebke and Erikson <ref type="bibr" target="#b15">[15]</ref>, and De Floriani et al <ref type="bibr" target="#b2">[3]</ref> do not rely on the edge-collapse primitive. Our work is most directly applicable to view-dependent simplifications that are based upon the vertex-split/edge-collapse primitive; its extension to more general view-dependent simplifications is a part of our planned future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Triangle Strips</head><p>Triangle strips provide a compact representation of triangular meshes and are supported by several graphics APIs including OpenGL. Triangle strips enable fast rendering and transmission of triangular meshes. An example triangle strip in the model of a cow is shown in <ref type="figure" target="#fig_2">Figure 2</ref>. The set of triangles shown in <ref type="figure" target="#fig_3">Figure 3</ref>(a) can be compactly represented by a triangle strip 1;2;3;4; 5;6, where the i th triangle is described by the i th , i + 1 st , and i + 2 nd vertices in this sequence. Such triangle strips are referred to as sequential triangle strips. A sequential triangle strip allows rendering of n triangles using only n + 2 vertices instead of 3n vertices.</p><p>This results in substantial saving for memory bandwidth and computation of per-vertex operations such as transformations, lighting, and clipping. Sequential triangle strips cannot however represent general sequences of triangles, such as the one shown in <ref type="figure" target="#fig_3">Figure 3</ref>(b). To represent such triangle sequences, the notion of triangle strips has been extended to generalized triangle strips where the two vertices of the previous triangle can be swapped. This can be also simulated by repeating vertices. Thus, the triangle sequence in <ref type="figure" target="#fig_3">Figure 3</ref>   generalized triangle strips for a given triangle mesh model <ref type="bibr" target="#b0">[1]</ref>. The algorithm tries to generate strips which minimize the number of one-triangle strips. This algorithm chooses the triangle which is adjacent to the least number of neighbors as the next triangle in a strip. Evans et al <ref type="bibr" target="#b5">[6]</ref> use global adjacency information in conjunction with several heuristics such as maximizing the length of each strip, minimizing swaps, and minimizing the number of single-triangle strips. Speckmann and Snoeyink <ref type="bibr" target="#b17">[17]</ref> have computed the triangle strips for triangulated irregular networks by creating a spanning tree of the dual graph, and then traversing the tree in a modified depthfirst fashion. Chow <ref type="bibr" target="#b1">[2]</ref>, Taubin at al <ref type="bibr" target="#b19">[19]</ref>, and Gumhold and Straßer <ref type="bibr" target="#b10">[10]</ref> have used strips to efficiently compress polygonal meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Efficient Link Traversal</head><p>Let us study what happens when an edge collapses in a triangle strip. <ref type="figure" target="#fig_4">Figure 4</ref> shows such a situation. As can be seen, the results of an edge collapse can be represented by replacing all occurrences of the child vertex c with the parent vertex p. In this example, c = 4 and p = 2 . The above example illustrates that to maintain triangle strips under view-dependent changes to the triangle mesh connectivity, we should replace each vertex in a triangle strip by its nearest uncollapsed ancestor. In an arbitrarily long sequence of such edge collapses, it is easy to see why efficient traversal of links to a vertex's ancestors becomes important.</p><p>Skip list <ref type="bibr" target="#b16">[16]</ref> has been proposed as an efficient probabilistic data-structure to store and retrieve data. Skip lists can also be used for efficient compression of pointer paths. Consider a simple linked list as shown in <ref type="figure" target="#fig_7">Figure 5</ref>    In a skip list, a node that has k forward pointers is a level k node. The level of a node is determined in a probabilistic manner. The search for an element is done by traversing forward pointers that do not overshoot the required element. When no more progress is possible, the search moves down to the next level. This is shown by the gray path in <ref type="figure" target="#fig_7">Figure 5</ref>(c). To accomplish insertion or deletion of an element in a skip list, a search is carried out for that element using the above method. A vector of pointers is set up during this search to represent the set of pointers that are changed to implement the insert or delete operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Technical Background</head><p>In this paper we build upon two previous algorithms -construction of vertex hierarchy for view-dependent simplifications <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b12">12]</ref> and construction of efficient triangle strips <ref type="bibr" target="#b5">[6]</ref>. Let us overview these two algorithms next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Construction of Merge Trees</head><p>Merge trees have been introduced by Xia et al <ref type="bibr" target="#b20">[20]</ref> as a datastructure built upon progressive meshes <ref type="bibr" target="#b11">[11]</ref>  View-dependent simplification is achieved by performing edge-collapses and vertex-splits on the triangulation used for display, depending upon view-dependent parameters such as lighting (detail is directly proportional to intensity gradient); polygon orientation, (high detail for silhouettes and low detail for backfacing regions) and screen-space projection. This is shown in <ref type="figure" target="#fig_9">Figure 6</ref>. Since there is a high temporal coherence the selected levels in the merge tree change only gradually from frame to frame. Unconstrained edge-collapses and vertex-splits during runtime can be shown to result in mesh  <ref type="bibr" target="#b20">[20]</ref> propose the concept of dependencies or constraints that necessitate the presence of the entire neighborhood of an edge before it is collapsed (or its parent vertex is split). Thus, for the example shown in <ref type="figure" target="#fig_0">Figure 1</ref>, the neighborhood of edge pc should consist exactly of vertices n0 : : : n 6 for c to collapse to p. Similarly, for the vertex p to split to c, the vertices adjacent to p should be exactly the set n0 : : : n 6. Our current implementation of merge trees can construct the merge tree for 69K triangles bunny model in 10:3 seconds on an SGI Onyx 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generating Triangle Strips</head><p>We use the Stripe program by Evans et al <ref type="bibr" target="#b5">[6]</ref> to generate high quality triangle strips. This approach considers the problem of constructing good triangle strips from polygonal models. Often such models are not fully triangulated, and contain quadrilaterals and other non-triangular faces, which must be triangulated prior to rendering. The choice of triangulation can significantly impact the cost of the resulting strips. Evans et al have experimented with several variants of local and global algorithms; the details are available in <ref type="bibr" target="#b5">[6]</ref>. After comparing the results from 20 different local and global approaches on over 200 datasets, the best option has been empirically observed to use the global row or column strips with a patch cutoff size of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>In this approach the model is first partitioned into regions that have collections of m n quadrilaterals arranged in m rows and n columns, which is referred to as a patch. Each patch whose number of quadrilaterals, mn, is greater than a specified cutoff, in this case 5, is converted into one strip at a cost of three swaps per turn. Further, every such strip is extended backwards from the starting quadrilateral and forwards from the ending quadrilateral of the patch to the extent possible. On triangulated models like the ones we consider in this paper, Stripe has been found to work as well as other publicdomain triangle strip converters. Stripe Version 2.0 <ref type="bibr" target="#b4">[5]</ref> converts the 69K triangles bunny model into triangle strips with a total of 90K vertices in 6 seconds on an SGI Onyx2.</p><p>Stripe generates efficient triangle strips but requires more time than simplistic methods such as the greedy method <ref type="bibr" target="#b12">[12]</ref>. Since we wanted to do comparisons with an on-line algorithm to convert polygonal meshes into triangle strips we also decided to implement the greedy method. The greedy method proceeds as follows. From a given triangle we extend a triangle strip as far as possible. Once it is no longer possible to extend the triangle strip, we stop and begin a new triangle strip. In our current implementation of the greedy method we are working only with sequential triangle strips as discussed in Section 2.2. We found that for an on-line method, the greedy method is a better choice than Stripe since the former takes much less time, even though it generates about 15 , 20 more vertices. The greedy method takes 0:2 seconds on an SGI Onyx2 to convert a 69K triangle bunny model to triangle strips and generates 96K vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Our Approach</head><p>In our approach we generate a merge tree and the triangle strip representation of the original polygonal model off-line. The merge tree file, which contains the parent-child relationships for each node of the tree, is constructed as overviewed in Section 3.1 and described in <ref type="bibr" target="#b20">[20]</ref>. Even though our implementation uses merge trees, the concept of Skip Strips is quite general and can be used in conjunction with other vertex-collapsebased simplification schemes as well. The triangle strip representation is generated using the Stripe program as overviewed above in Section 3.2 and described in <ref type="bibr" target="#b5">[6]</ref>. At run-time we load the merge tree and triangle strip representations generated during preprocessing and build the Skip Strip data-structure on the fly. Then, depending on scene parameters such as eye position, local illumination, front/back-facing regions, we perform vertex split and edge collapse operations directly on the Skip Strips. The information from Skip Strips is then used to generate triangle strips for display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Skip Strip data-structure</head><p>A Skip Strip is an array of Skip Strip nodes. Each Skip Strip node contains vertex information, a list of child pointers and a parent pointer. This can be seen in <ref type="figure" target="#fig_6">Figure 7</ref> where the parent pointer is shown on the right and the list of child pointers is shown on the left of each Skip Strip node. We shall see in Section 4.3 how to generalize this data-structure to support a list of parent pointers to accelerate access in an edge-collapse hierarchy.</p><p>A Skip Strip is constructed at run time from the merge tree and triangle strip representations. A Skip Strip node is allocated for every merge tree leaf (terminal node) and parentchild pointers are set up to mimic the merge tree structure. In our current implementation we are assuming that a child vertex c collapses to a parent vertex p. For this case, a Skip Strip node corresponding to a vertex p will have child pointers to all its children, including c, that collapse to it at different stages of simplification. In general, if there are n vertices then the average height of the merge tree is Olog n. Thus, the average length of this child-pointer list for a Skip Strip node is Olog n. At a given time only one of these child pointers is flagged active and represents the node that will result from the most imminent split. Each Skip Strip node points to its immediate parent via the parent pointer. Parent pointer of the node is marked active if this node has collapsed to its parent at a given stage of simplification; otherwise it is marked inactive.</p><p>To illustrate the Skip Strip data-structure, let us see how it is built from a merge tree. <ref type="figure" target="#fig_11">Figure 8(a)</ref> shows a hypothetical merge tree over four vertices 1 to 4. As in all the merge tree diagrams in this paper, the right node is the child node and the left is the parent node (as defined by <ref type="figure" target="#fig_0">Figure 1</ref>). Let us assume that we are dealing with edge collapses in which one vertex collapses to another (i.e. no new vertices are created). The equivalent Skip Strip data-structure will have four nodes  The method that we have outlined above assumes that in an edge collapse from c to p, the new vertex is p. However, several other researchers have pointed out the advantage of creating new vertices during edge collapses. These new vertices could be created for accomplishing geomorphs <ref type="bibr" target="#b11">[11]</ref> or for better placement of approximating vertices using sophisticated error metrics <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b3">4]</ref>. For incorporating such simplification metrics into the framework of Skip Strips we suggest storing multiple coordinate sets, once per approximating vertex, in the child pointer of the Skip Strip node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Real-Time Adaptive Representation</head><p>Once the Skip Strip has been constructed it is easy to construct an adaptive level-of-detail mesh representation during run-time. Real-time adaptive mesh representation involves the determination of the vertices and triangle strips at the current level of detail. We shall refer to the vertices and triangle strips selected for display at a given frame as display vertices and display strips.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Determination of display vertices</head><p>Determination of display vertices proceeds along the same lines as proposed in earlier work on view-dependent simplification <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b12">12]</ref> where image-space feedback is used to guide the selection of the level of detail for the mesh. We determine which region of an object to simplify more and which to simplify less using several parameters such as viewer location and orientation, local illumination, and front/back-facing regions of an object. Similar to merge tree nodes, Skip Strips nodes also store a switch value to determine whether to refine, merge, or leave a Skip Strip node in its current level. If the computed value of the view-dependent error at a given node v is less than the switch value stored at node v, then node v splits. If the computed value is larger than the switch value stored at the parent of node v, then v merges.</p><p>In addition to the above criteria, each collapse and split also depends on the validity of the operation as determined during the preprocessing to avoid artifacts such as mesh foldovers as explained earlier in Section 3.1. One way to avoid such artifacts is to use dependencies <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b20">20]</ref>. In <ref type="bibr" target="#b3">[4]</ref>, we have introduced the concept of implicit dependencies that can test validity of edge collapse or vertex split in constant time. However, implicit dependencies rely on the existence of independent triangles that can be individually tagged. Since in the Skip Strip data-structure we do not store triangles explicitly it is difficult to use implicit dependencies. For Skip Strips we can use the traditional method of storing dependencies explicitly as a set of adjacent nodes <ref type="bibr" target="#b20">[20]</ref>. Instead, we have chosen to optimize the explicit dependencies by storing only that subset of adjacent nodes that do not participate in an ancestor-child relationship, i.e. we do not include an adjacent node in the dependency list if any of its ancestors is already in the list.</p><p>The execution of edge collapse and split operation is done in a small constant time (only integer increment and flag change or integer decrement and flag change) as follows. To perform a merge on the Skip Strip we activate the parent pointer and increment the child index of the merged node by one, followed by removing the merged node from the active nodes list. Split is done by deactivating the parent pointer and decrementing child index of the split node by one. Then we insert the node pointed to by the previous child index into the active nodes list. We have discovered that these simpler operations have reduced the time for checking and performing a vertex split or edge collapse from around 60seconds to 6seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Determination of display strips</head><p>The graphics dataset is represented as a set of triangle strips. Each triangle strip has two representations -the original highest resolution triangle strip that was generated using preprocessing, and the Skip-Strip-derived run-time representation of it that represents a triangle strip suitable for the current level of detail. We refer to the former as a original triangle strip and the latter as a display strip. At each frame we first perform view dependent edge collapses/vertex splits as outlined in Section 4.2.1. Each time an edge collapses or vertex splits, all display strips that contain that edge are flagged as modified. At the end of these simplifications, if a display strip remains unmodified, it is used for rendering. However, if a display strip is modified we discard it and begin generating its replacement by scanning each vertex in the corresponding original triangle strip. Each vertex of the original triangle strip has a pointer to a corresponding node in a Skip Strip. For each vertex's node in the Skip Strip we check whether its parent pointer is active or not. If the parent pointer is active we follow the sequence of active parent pointers until we reach a node that has an inactive parent pointer. The vertex information stored with the first node that has an inactive parent pointer is added to the new display strip. After the new display strip has been completely generated it is sent to the graphics system for display.</p><p>Let us next illustrate how the Skip Strips are used to split and collapse vertices of a triangle strip to generate the display strips. <ref type="figure" target="#fig_12">Figure 9</ref> shows the original mesh with vertices numbered 1::10. The two triangle strips representing this mesh are labeled a and b. Since no edges have collapsed, the display strips are the same as the original triangle strips. <ref type="figure" target="#fig_0">Figure 11</ref> shows the same after two edge collapses (6 ! 5, and 8 ! 7)</p><p>to the mesh of <ref type="figure" target="#fig_12">Figure 9</ref>. In <ref type="figure" target="#fig_0">Figure 10</ref> none of the parent pointers is active (since there have been no edge collapses). <ref type="figure" target="#fig_0">Figure 10</ref> shows the merge tree and the skip strip with one parent pointer per node, constructed for the mesh in <ref type="figure" target="#fig_12">Figure 9</ref> at the highest detail. In <ref type="figure" target="#fig_0">Figure 11</ref>, the parent pointers for nodes 6 and 8 pointing to 5 and 7 respectively, are active and appear dot shaded. The nodes 6 and 8 are inactive and appear with hatched shading. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Efficient Skipping for Parent pointers</head><p>As the object moves to a coarse representation, the time spent in following the active parent pointers increases. On the average, the maximum number of active parent pointers that one might need to traverse is Olog n -the height of the vertex  hierarchy. To reduce this time we trade off memory for speed. To accomplish this we use ideas from path compression <ref type="bibr" target="#b18">[18]</ref> and skip lists <ref type="bibr" target="#b16">[16]</ref> to build a list of parent pointers for each Skip Strip node. The parent pointers of each node point to its ancestors that are 1;2; 4;:::;log n hops away in the edge collapse hierarchy. By using an efficient, skip-list-like pointer hopping scheme we can reduce this to Olog log n. Although reducing Olog n to Olog log n factor might seem minor, in practice this results in an appreciable difference, especially when we note that the merge tree height is generally a logarithm to the base 5=4 <ref type="bibr" target="#b20">[20]</ref>. Thus, even if the edge-collapsebased vertex hierarchy tree is balanced (which it often is not), the height for a tree over one million vertices (and therefore the worst-case pointer hopping) will be 62 ( log 1:25 10 6 )</p><p>while a skip-list-like pointer hopping scheme will only need to traverse 6 ( log 2 62) pointers, an order of magnitude improvement for present-day datasets.</p><p>To efficiently implement traversal of parent pointers, each Skip Strip node has an active parent field to indicate which pointer in the parent list to follow to get closest to, without overshooting, the first active ancestor. We use a lazy update scheme to modify the active parent field for each Skip Strip node. For this we make use of the fact that the vertex hierarchy nodes are collapsed in an accordion-style fashion from high detail to low detail. In other words, if a vertex i collapses to vertex j, then it means that all vertices that lie in the sub- we need to decrement the active parent pointer until it points to a node that is below j (in other words has already collapsed).</p><p>Because of a high temporal coherence, these updates are few and each requires only one or two ancestor checks to find the "correct" ancestor that does not overshoot the first active ancestor. Likewise, when a vertex j splits we update all pointers from triangle strips that point to j as the first active ancestor to point to a lower level ancestor. We would like to note that in this application, traversal of triangle strips requires that we access each vertex of the triangle strip and, therefore, the overhead of such lazy updates of pointers to reflect split and collapse in Skip Strips is minimal. <ref type="figure" target="#fig_0">Figure 12</ref> shows the Skip Strip representation with multiple parent pointers for each node for the mesh in <ref type="figure" target="#fig_12">Figure 9</ref>. Note that the active parent and child pointers appear shaded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Further Optimizations</head><p>As the model moves to coarser levels the triangle strips begin to accumulate identical vertices. Sending such vertices multiple times is equivalent to sending degenerate triangles that do not contribute to the final scene but add an overhead to the graphics rendering. To address this we filter the triangle strips while sending them to the graphics engine. We have imple-mented a simple triangle strip scanner that detects and replaces patterns of vertices of the regular expression form aa + by aa and ab + by ab in the sequence of vertices sent for rendering. <ref type="figure" target="#fig_0">Figure 13</ref> shows the relationship between the triangle strip a (top half of the mesh from <ref type="figure" target="#fig_12">Figure 9</ref>) and how the display strip relates to it. As can be seen, a display strip is simply a linked list of pointers to the triangle strip. At the beginning of each frame the display strip is updated from the triangle strip. As the underlying mesh is simplified and vertex repetitions (as detected by triangle strip filtering) increase, it pays to do two further optimizations: (a) skip over the repetitions, and (b) change the display strip incrementally from frame to frame instead of constructing it from the original triangle strip per frame. The first optimization can be easily accomplished by using a skip-list-like structure instead of a linked list for the triangle strip (refer <ref type="figure" target="#fig_0">Figure 13(b)</ref>). The second optimization is accomplished by storing two pointers with each collapsible edge. These pointers point to the two triangle strips to which the two triangle sharing that edge belong. Since the triangle strips are computed statically, these pointers are generated only once during the pre-processing stage. For non-manifold meshes that can have more than two triangles sharing an edge, one can accordingly store one triangle strip pointer per additional triangle. Whenever an edge collapses at run-time, the (at most) two triangle strips that are affected have their headers flagged as modified. When a display strip is considered for rendering, we first check to see if its corresponding triangle strip has been modified since the last frame. If it has, we update the display strip, otherwise use it as is. We note again that the Skip Strips are computed only once, at the pre-processing stage. Therefore, as the simplification increases there comes a stage when triangle strips computed from a Skip Strip representation are highly fragmented (they each represent a small number of triangles). To address this issue, we have added a stage in our current implementation that performs merging of display strips. This proceeds as follows. We check the triangle strip pointers on the last edge of a display strip to see if a new display strip is beginning at that edge. If it is, we extend the current strip effectively merging the two strips.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>We have implemented Skip Strips and have obtained the results shown in <ref type="table">Table 1</ref> and <ref type="figure" target="#fig_0">Figure 14</ref>. All of these results have been obtained on an SGI Onyx 2 with four R10000 processors, 1 GB RAM. Timings reported here do not assume parallelization of the view-dependent simplifications. <ref type="table">Table 1</ref> shows the comparison between rendering datasets using three modes of view-dependent renderings. The three modes differ in how triangles are sent for rendering. Identical parameters of view-dependent simplifications are used across the three modes resulting in identical sets of triangles rendered. In the first mode triangles are sent independently without taking advantage of any adjacency information. In the second mode triangles determined for display in one frame are converted into triangle strips using the greedy method for generating sequential triangle strips. This is the current state-ofthe-art method for using triangle strips with view-dependent simplifications. The third mode involves using Skip Strips to generate display strips for rendering triangles. The comparisons for the three modes are shown in <ref type="table">Table 1</ref> for four datasets across representative flythroughs (as shown in the video). The Frame Count row indicates the number of frames in the flythrough path. The Adapt Count row indicates the total number of edge collapse/vertex split operations performed for the given flythrough path. The Tris Count and Verts rows represent the total number of triangles and vertices sent for rendering, respectively, over the entire flythrough path. Within each mode Adapt, Display, and Total indicate the cumulative times spent over the flythrough paths in changing the viewdependent detail, rendering, and the total time, respectively. In online stripping Strip is the time to generate triangle strips whereas for Skip-Strips, the time to maintain the strips is part of the Display time. As can be seen from these numbers, Skip Strips result in a 35 , 95 improvement over sending raw triangles and 50 , 63 improvement over computing triangle strips on-the-fly from scratch.</p><p>As the simplification levels increase and mesh sizes reduce, it becomes more attractive to perform on-the-fly greedy triangle strip computation than to maintain Skip Strips since the fragmentation amongst triangle strips increases as mentioned in Section 4.4. Merging of triangle strips on the fly addresses this problem to a certain extent, but it is inevitable that at some stage of simplification it becomes less attractive to maintain Skip Strips. <ref type="figure" target="#fig_0">Figure 14</ref> shows our results in determining the threshold above which we found it better to use Skip Strips for the bunny model. We found similar performance curves for other datasets. Rather than clutter the graph with several curves, we have simply reported the crossover points for the other datasets on the same graph.</p><p>The datasets used for the above results appear in <ref type="figure" target="#fig_0">Figures  15, 16</ref>, and 17. In these figures, parts (a) show an intermediate level of view-dependent simplification, while parts (b), (c), and (d) show how the triangle strips are maintained across different levels of detail using Skip Strips. Colors in parts (a) depict object colors, whereas colors in parts (b), (c), and (d) denote different triangle strips.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We have shown how Skip Strips can provide a convenient and simple representation to integrate retained-mode datastructures such as triangle strips with immediate-mode view-   <ref type="figure" target="#fig_0">Figure 14</ref>: Skip-Strips versus stripping online dependent simplifications. The Skip Strips offer two main advantages. First, they make pointer hopping along parent links in any hierarchical vertex collapse scheme efficient. Second, they simplify the execution of the vertex split and edge collapse operations to be as simple as two integer increment or decrement operations.</p><p>Skip Strips provide the advantage of hardware-assisted acceleration to view-dependent simplifications. However, they also suffer from some of the same limitations that afflict triangle strips. Thus, Skip Strip performance will not be very good for datasets that have several discontinuities in surfaces such as cracks, T-junctions , normals, colors, and textures. For such datasets, the triangle strips that are generated have to be split across such surface attribute discontinuities thereby limiting their efficacy in succinctly representing the polygonal mesh. Although this does affect overall performance, the results will likely still be better than rendering raw triangles.</p><p>Another issue to consider is the performance of Skip Strips over genus-reducing simplifications. Our preliminary results indicate that Skip Strips are also applicable to view-dependent genus-reducing simplifications; we need to test this further. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Edge collapse and vertex split</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(b) can be represented as 1;2;3; 4;5;4; 6;7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>A triangle strip in a cow model Akeley et al<ref type="bibr" target="#b0">[1]</ref> have developed a program that constructs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>A triangle strip example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Edge Collapse in a Triangle Strip</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(a). Reaching the n th node on this list requires O(n) pointer hops. Consider next a data-structure that has n=2 additional pointers that connect linked list nodes that are 2 away (refer Figure 5(b)). Using these additional pointers, any node on the list can be accessed in O(n=2) time. Skip lists generate O(n) such additional pointers in a probabilistic manner to provide O(log n) time access in the average case (refer Figure 5(c)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>7</head><label>7</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>A Skip list example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>to enable realtime view-dependent rendering of an object. As discussed earlier, let the vertex p in Figure 1 be considered the parent of the vertex c. The neighborhood of a vertex v is defined as the set of triangles that are adjacent to v. The neighborhood of an edge va;v b is defined as the union of neighborhoods of va and vb. The merge tree is constructed in a bottom-up fashion from a high-detail mesh to a low-detail mesh by storing these parent-child relationships (representing edge collapses) in a hierarchical manner over the surface of an object. At each level l of the tree a maximal set of edge-collapses is selected in the shortest-edge-first order and with the constraint that their neighborhoods do not overlap. The vertices remaining after these edge collapses are promoted to level l + 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 :</head><label>6</label><figDesc>Varying detail in a Merge Tree foldovers resulting in visual artifacts such as shading discontinuities. To avoid these artifacts Xia et al</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>A Skip Strip node representing the leaves of the merge tree (the highest detail vertices in the original model). Since according to the merge tree vertex 2 can merge to vertex 1, the parent pointer for the Skip Strip node 2 will point to Skip Strip node 1 and the child pointer for the node 1 will point to node 2. Similarly, the parent and child pointers of Skip Strip nodes 3 and 4 will be set.This stage is shown inFigure 8(b). The edge collapse 3 ! 1 can be represented in the Skip Strip as a parent pointer from node 3 to node 1 and a child pointer from node 1 to node 3. The completed Skip Strip structure is shown in Figure 8(c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Building a Simple Skip Strip</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Original triangle mesh</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>8 Figure 10 :</head><label>810</label><figDesc>Skip Strip for Triangle Mesh inFigure 9</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 11 :</head><label>11</label><figDesc>Skip Strip for Triangle Mesh in Figure 9 after two edge collapses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 12 :</head><label>12</label><figDesc>More efficient Skip Strip representations for Figures 10 and 11 tree rooted at vertex i have already collapsed to vertex i. If the triangle strips reference one of the vertices in this sub-tree rooted at i, and if their active parent pointer overshoots j, then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 13 :</head><label>13</label><figDesc>(a) Arrows mark edge collapses. (b) Efficient local skipping over triangle strip.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 15 :</head><label>15</label><figDesc>Skip strips across varying resolutions for the Stanford Bunny model (a) 255K triangles (b) 32K triangles (c) 255K triangles (d) 522K triangles Figure 16: Skip strips across varying resolutions for the Terrain dataset (a) 170K triangles (b) 65K triangles (c) 170K triangles (d) 340K triangles Figure 17: Skip strips across varying resolutions for the Auxilliary Machine Room dataset</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work has been supported in part by the NSF grants: CCR-9502239, DMI-9800690, ACR-9812572 and a DURIP instrumentation award N00014970362. Jihad El-Sana has been supported in part by the Fulbright/Israeli Arab Scholarship Program and the Catacosinos Fellowship for Excellence in Computer Science. <ref type="figure">Figure 17</ref> shows the Auxiliary Machine Room part from the dataset of a notional submarine provided to us by the Electric Boat Division of General Dynamics. We would like to thank the reviewers for their insightful comments which led to several improvements in the presentation of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Akeley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haeberli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Burns</surname></persName>
		</author>
		<title level="m">Program on SGI Developer&apos;s Toolbox CD</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Optimized geomerty compression for realtime rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;97 Proceedings</title>
		<imprint>
			<publisher>ACM/SIGGRAPH Press</publisher>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="403" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient implementation of multi-triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Puppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;98</title>
		<meeting>Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Generalized view-dependent simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics &apos;99</title>
		<meeting><address><addrLine>Milano, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Azanli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Skiena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<ptr target="http://www.cs.sunysb.edu/stripe" />
		<imprint/>
	</monogr>
	<note>Stripe Version 2.0</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Optimizing triangle strips for fast rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Skiena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Proceedings</title>
		<imprint>
			<biblScope unit="page" from="319" to="326" />
			<date type="published" when="1996-10" />
			<publisher>ACM/SIGGRAPH Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;97</title>
		<meeting>SIGGRAPH &apos;97</meeting>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast multiresolution surface meshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gatti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95 Proceedings</title>
		<editor>G. M. Nielson and D. Silver</editor>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A framework for streaming geometry in VRML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="68" to="78" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Real time compression of triangle mesh connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straßer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 98 Conference proceedings</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIG-GRAPH &apos;96</title>
		<meeting>SIG-GRAPH &apos;96</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH, ACM Press</publisher>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Los Angeles, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH, ACM Press</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="189" to="197" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;97</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Real-Time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fast and memory efficient polygonal simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;98</title>
		<editor>D. Ebert, H. Rushmeier, and H. Hagen</editor>
		<meeting>Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;97</title>
		<meeting>SIGGRAPH &apos;97</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="198" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Skip lists: A probabilitics alternative to balanced trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="668" to="678" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Easy triangle for TIN terrain models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Speckmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Canadian Conference on Computational Geomerty 97</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="239" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Data structures and network algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Regional Conference Series in Applied Mathematics</title>
		<imprint>
			<date type="published" when="1983" />
			<biblScope unit="volume">44</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Progressive forest split compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 98 Conference Proceedings, Annual Conference Series</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Adaptive realtime level-of-detail-based rendering for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="page" from="171" to="183" />
			<date type="published" when="1997-06" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
