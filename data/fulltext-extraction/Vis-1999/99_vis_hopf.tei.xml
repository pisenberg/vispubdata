<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Accelerating 3D Convolution using Graphics Hardware</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Hopf</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Thomas Ertl Visualization and Interactive Systems Group</orgName>
								<orgName type="institution" key="instit1">IfI</orgName>
								<orgName type="institution" key="instit2">University of Stuttgart</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Accelerating 3D Convolution using Graphics Hardware</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Convolution</term>
					<term>Hardware Acceleration</term>
					<term>Volume Visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Many volume filtering operations used for image enhancement, data processing or feature detection can be written in terms of threedimensional convolutions. It is not possible to yield interactive frame rates on todays hardware when applying such convolutions on volume data using software filter routines. As modern graphics workstations have the ability to render two-dimensional convoluted images to the frame buffer, this feature can be used to accelerate the process significantly. This way generic 3D convolution can be added as a powerful tool in interactive volume visualization toolkits.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Direct volume rendering is a very important technique for visualizing three dimensional data. Several fundamental different methods have been introduced <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b11">12]</ref>. Hardware-based volume texturing <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14]</ref> is one of the most prominent variants for interactive visualization due to the high frame rates that can be achieved with this technique.</p><p>The basic principle of texture based volume rendering is depicted in <ref type="figure" target="#fig_1">Figure 1</ref>. According to the sampling theorem a 3D view of the volume is generated by drawing an adequate number of equidistant, semi-transparent polygons parallel to the image plane with respect to the current viewing direction ("volume slicing").</p><p>Filtering on the other hand is a major part of the visualization pipeline. It is broadly used for improving images, reducing noise, and enhancing detail structure. Volume rendering can benefit from filter operations, as low pass filters reduce the noise e.g. of sampled medical volume images and high pass filters can be used for edge extraction, visualizing prominent data features. Multiscale approaches as <ref type="bibr" target="#b12">[13]</ref> regularly use disjunct filtering and downsampling steps and can benefit from any speedups of the filtering process.  Filters can be classified as linear or non-linear. Discrete linear filters can be written as convolutions with filter kernels that completely specify the filtering operation. Non-linear filters, as for instance morphological operators, were recently used for volume analysis and visualization <ref type="bibr" target="#b6">[7]</ref>. Segmentation and classification depend heavily on filtering operations as well. Bro-Nielson <ref type="bibr" target="#b0">[1]</ref> already thought about using convolution hardware for accelerating the registration process.</p><p>For texture based volume rendering the data set has to be loaded into special texture memory, which can be addressed by the graphics pipe very fast. The loading process itself is relatively slow, taking several seconds for big data sets even on the fastest available graphics workstations. As the data set has to be reloaded after a filter operation has been performed in software, interactive filtering will benefit a lot from convolution algorithms that directly work on the texture hardware. Additionally, we will show in the following that computing the convolution with graphics hardware is much faster than software solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">3D Convolution</head><p>The general three-dimensional discrete convolution can be written asf</p><formula xml:id="formula_0">(x, y, z) = i 1 ,i 2 ,i 3 k(i1, i2, i3) • f (x + i1, y + i2, z + i3)</formula><p>with f being the input data function and k being the filter kernel, resulting in the convoluted dataf .</p><p>In the following examination we will assume without loss of generality that k(i1, i2, i3) is given for 0 ≤ i1, i2, i3 &lt; n and vanishes outside this interval. Also, we will assume that the input data function vanishes for (x, y, z) outside the interval [0, m) <ref type="bibr" target="#b2">3</ref> .</p><p>In the special case of k(i1, i2, i3) =k1(i1) •k2(i2) •k3(i3) the   </p><formula xml:id="formula_1">f1(x, y, z) = i 1k 1(i1) • f (x + i1, y, z) (1) f2(x, y, z) = i 2k 2(i2) •f1(x, y + i2, z) (2) f (x, y, z) = i 3k 3(i3) •f2(x, y, z + i3)<label>(3)</label></formula><p>Of course special care has to be taken near the boundaries of the input data function, as convolution routines are generally written on a very low language level for speed purposes. <ref type="figure" target="#fig_3">Figure 2</ref> shows two well known convolution filters, the Gauß filter and its second derivative, both in their continuous and discrete forms. They can be used for noise reduction and edge detection, respectively. An example image that was filtered with these kernels can be seen in <ref type="figure" target="#fig_4">Figure 3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Hardware Acceleration</head><p>In order to accelerate the convolution process, special purpose hardware can be used. On systems that have built-in Digital Signal Processors (DSPs), for example for multimedia acceleration, a specialized convolution subroutine could be downloaded to the signal 00 00 11 11 00 00 11 11 00 00 11 11 00 00 11 11 00 00 11 11 <ref type="figure">Figure 5</ref>: Texture coordinates used for exact texel hits processor. On the other hand, most times these DSPs are not well documented or the run-time system can not be modified by the user. In general they are not faster than the main processor as well. Additionally, there exists a wide range of different DSP systems, all of which are incompatible to each other.</p><p>The approach we have implemented in our system is to combine a 2D and a 1D convolution kernel in order to calculate threedimensional separable convolutions. Several vendors of the graphics API OpenGL -as for example Silicon Graphics Inc. <ref type="bibr" target="#b9">[10]</ref> have included extensions for one-and two-dimensional filtering. In contrast to most implementations that emulate these extensions only in software, the SGI graphics pipes MXE and BasicReality calculate the convolutions on-board, boosting performance by an order of magnitude already for reasonably sized filters. The CRM graphics system of the O2 is capable of rendering convolutions in hardware as well, but it does not support volume textures, which are crucial for the algorithm as well.</p><p>Recall that the volume data is already stored in texture memory for visualization using texture hardware. Now (1) and (2) are combined to one 2D convolution that is to be applied to every plane of the volume data perpendicular to the z-axis. Therefore, plane by plane is drawn by rendering textured triangle strips (two triangles per strip) into the frame buffer as it is sketched in <ref type="figure" target="#fig_5">Figure 4</ref>. The texture coordinates assigned to the vertices of the triangle strips are specified in such way that no interpolation of the texture is necessary (see <ref type="figure">Figure 5</ref>). In order to increase the potential speedup and to avoid rounding problems, nearest neighbor interpolation is activated during the rendering process. Each plane is then read back with the OpenGL routine glCopyTexSubImage3DEXT, which replaces one plane of the active volume texture orthogonal to the z-axis by data that is read directly from the frame buffer. While transfering the data to the texture memory, the separable 2D convolution filter is activated using glSeparableFilter2DEXT. After this first pass, the volume texture contains data filtered along the x-and yaxes.</p><p>1D Convolution <ref type="figure">Figure 6</ref>: The second pass Applying the convolution to the third axis is more complicated and depicted in <ref type="figure">Figure 6</ref>. In this second pass planes are rendered perpendicular to one of the other axes. Assume that the y-axis has been chosen. As glCopyTexSubImage3DEXT can not write planes orthogonal to any other axis than the z-axis to the texture memory, they have to be transfered to a second volume texture. OpenGL's texture objects are used by calling glBindTexture for switching between them, which implies only a very small overhead. While copying the data from the frame buffer to the texture memory, a one-dimensional convolution filter is activated. As we are dealing with two-dimensional image data, we specify a 2D convolution filter with glConvolutionFilter2DEXT, using a filter kernel that is exactly one pixel wide.</p><p>After this second pass the convoluted volume data has been mirrored at the plane y − z = 0. For texture based volume renderers this does not impose any restrictions, as they only have to swap coordinates during texture coordinate calculations. When data order is crucial for the application, the algorithm of pass two can be used for both passes, thus restoring the data order in the second pass. However, the textured planes have to be drawn two times perpendicular to the y-axis. Cache misses are much more likely in this case in respect to planes rendered orthogonal to the z-axis. This can increase the convolution times on big volumes by up to 50% even on fast graphics hardware. <ref type="figure" target="#fig_6">Figure 7</ref> depicts the relevant part of the OpenGL pipeline. It reveals, that pixel fragments read from the frame buffer are clamped to [0, 1) before they can be written back to the frame buffer or into the texture memory. Filter kernels with negative coefficients can compute negative intermediary values during the two-dimensional convolution pass, which will not contribute to the final 1D convolution. Additionally, no negative results can be stored in the output volume. These values are especially needed when the filter kernel is not symmetrical.</p><p>The strategy for avoiding these effects depends on the particular application. For edge detection the absolute maxima of the filtered volume data are of interest. In this case, calculating the absolute value can be performed in hardware as well, further reducing necessary computations on the CPU. In most other cases post-convolution scaling and bias can be used to map the expected results to the interval [0, 1) just before the clamping takes place. OpenGL provides the GL POST CONVOLUTION c SCALE EXT and GL POST CONVOLUTION c BIAS EXT parameters, which are applied to pixel color values after convolution and before clamping as depicted in <ref type="figure" target="#fig_6">Figure 7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results</head><p>The used data sets are presented on the color plate. <ref type="figure" target="#fig_1">Figures 8 to 12</ref> show slices of a head data set of size 128 3 . <ref type="figure">Figure 8</ref> reveals the unfiltered data set, whereas <ref type="figure">Figure 9</ref> and 10 present slices of the software and hardware low pass filtered volume data, respectively. Here, a Gauß filter kernel of size 5 3 has been used. Almost no differences can be detected. <ref type="figure" target="#fig_1">Figure 11</ref> and 12 depict the results for high pass filtering using the second derivative of the Gauß filter, again computed in software and in hardware. The hardware convoluted volume displays noticeable artifacts that occur due to the already mentioned clamping step in the OpenGL pipeline. By using post-convolution scaling and bias the artifacts disappear completely.</p><p>The <ref type="figure" target="#fig_1">Figures 13 to 18</ref> picture another data set that has been used for testing the implementation. They have been visualized with the hardware based volume rendering toolkit TiVOR <ref type="bibr" target="#b10">[11]</ref>, again with the first picture being rendered with the original data set. While the noise reduction effect of the Gauß filter is rather bothering in <ref type="figure" target="#fig_1">Figure 14</ref> by smearing volume details, it has remarkable positive effects on ISO surface generation (compare <ref type="figure" target="#fig_1">Figures 17 and 18)</ref>. Please remark that the ISO surfaces are rendered in real-time using a hardware accelerated volume rendering approach described in <ref type="bibr" target="#b13">[14]</ref>.</p><p>Noise interferes with high pass filters, which can be seen in <ref type="figure">Figure</ref> 15. Using a high pass filter on the already low pass filtered data set reveals by far more and better separable details (see <ref type="figure" target="#fig_1">Figure 16</ref>) compared to the directly filtered volume.</p><p>We have tested the speed our implementation against a well tuned software convolution filter. Unsurprisingly, the software convolution is almost completely memory bound. Even extremely fast workstations as the Octane are limited by the main memory band- All times were measured on a Silicon Graphics Onyx2 equipped with a BasicReality graphics pipe. The system has two R10000/195 MHz processors and 640 MB main memory. <ref type="table">Table 1</ref>: Convolution times in seconds using hardware / software width, as today's caches are far too small for the values needed for convolution along the z-axis. High end machines as the Onyx2 perform huge 3D convolutions three times faster than the Octane, even when equipped with slower CPUs. Standard PCs cannot cope with the memory bandwidth of the Onyx2 system, and multiprocessor options will not accelerate the process because it is not CPU bound. <ref type="table">Table 1</ref> shows convolution times for different data sets and filter sizes, using software and hardware convolution. All times have been measured on an Onyx2 equipped with a BasicReality graphics pipe. The maximum filter size supported by the graphics system is 7 2 . Therefor, the maximum 3D convolution that can be performed in hardware on this system is 7 3 . Noteworthy is the fact that the BasicReality graphics system is optimized for filter kernels of size 5 2 . Convolutions with smaller kernels need exactly the same computation time. Filters of size 6 2 and 7 2 share their timing results as well. The x and y coordinates of the volume are swapped during the hardware based convolution process, which is a side effect of the presented 3D convolution algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>As several of today's graphics workstation vendors have added twodimensional convolution to their OpenGL pipeline, using this capability for accelerating 3D convolution is an almost straightforward approach. We have determined that by using the implemented algorithm three-dimensional convolution can be performed even on big data sets with nearly interactive rates. First promising approaches of accelerating wavelet decomposition and reconstruction have been investigated as well <ref type="bibr" target="#b2">[3]</ref>.</p><p>As all intermediary data is transfered to the frame buffer, clamping can swallow negative values that result from the two-dimensional convolution as well as final negative results. Thus this approach is currently most useful for symmetrical filter kernels. By using post-convolution scaling and bias extensions these problems can be easily overcome.</p><p>Non-separable convolutions are not possible right now with this algorithm. However, by applying several two-dimensional filter kernels and blending convoluted images in the frame buffer the use of non-separable 3D kernels will be a possibility for the future as well. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>{hopf,ertl}@informatik.uni-stuttgart.de Institut für Informatik Breitwiesenstr. 20 -22 70565 Stuttgart Germany</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Texture based volume rendering</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>The Gauß filter function and its second derivative</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Example image; original, filtered with Gauß, and filtered with second derivative kernel is called separable. In this case the number of operations necessary for the convolution can be reduced down to O(m 3 n), from O(m 3 n 3 ) in the non-separable case:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>The first pass of the hardware filtering algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>The OpenGL graphics pipeline</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :Figure 9 :Figure 10 :Figure 11 :Figure 12 :Figure 13 :Figure 14 :</head><label>891011121314</label><figDesc>The unfiltered head data set Head, low pass filtered in software Head, low pass filtered in hardware Head, high pass filtered in software Head, high pass filtered in hardware The original angiography data set The Gauß filtered data setFigure 15: Data, after direct filtering with Gauß' second derivativeFigure 16: First low pass, then high pass filtered dataFigure 17: ISO surfaces on the original angiography data setFigure 18: ISO surfaces on the Gauß filtered data set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Data set created by computer tomography, 128 3 ‡ Data set created by MR angiography, 256<ref type="bibr" target="#b2">3</ref> </figDesc><table><row><cell>Filter size</cell><cell>2 3</cell><cell>3 3</cell><cell>5 3</cell><cell>7 3</cell></row><row><cell>head  †</cell><cell cols="4">0.33/0.72 0.33/1.02 0.33/1.56 0.48/2.0</cell></row><row><cell>angio  ‡</cell><cell>2.5/6.0</cell><cell>2.5/8.7</cell><cell cols="2">2.5/14.7 3.7/21.3</cell></row><row><cell>†</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Medical Image Registration and Surgery Simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bro-Nielson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
		<respStmt>
			<orgName>IMM, Technical University of Denmark</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Texture Splats for 3D Scalar and Vector Field Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">L</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization 93</title>
		<editor>G. M. Nielson and Bergeron D.</editor>
		<meeting><address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="261" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hardware Based Wavelet Transformations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Erlangen Workshop &apos;99 on Vision, Modeling and Visualization, Erlangen</title>
		<imprint>
			<date type="published" when="1999-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<publisher>IEEE Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast Volume Rendering Using a Shear-Warp Factorization of the Viewing Transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lacroute</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley Publishing Company, Inc</publisher>
			<date type="published" when="1994-07" />
			<biblScope unit="page" from="451" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Compression Domain Volume Rendering for Distributed Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lippert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kurmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROGRAPHICS &apos;97</title>
		<editor>D. Fellner and L. Szirmay-Kalos</editor>
		<imprint>
			<publisher>Blackwell Publishers</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="95" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Hierarchical Volume Analysis and Visualization Based on Morphological Operators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lürig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="335" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data Parallel Volume Rendering as Line Drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stoll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1992-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Rendering using RE2 Technology</title>
		<meeting><address><addrLine>Mountain View, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">OpenGL on Silicon Graphics Systems</title>
	</analytic>
	<monogr>
		<title level="j">Silicon Graphics Inc</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Interactive Visualization and Navigation Tool for Medical Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Sommer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Sixth International Conference in Central Europe on Computer Graphics and Visualization &apos;98</title>
		<editor>N. M. Thalmann and V. Skala</editor>
		<meeting><address><addrLine>Plzen, Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>University of West Bohemia Press</publisher>
			<date type="published" when="1998-02" />
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="362" to="371" />
		</imprint>
	</monogr>
	<note>WSCG &apos;98</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Frequency Domain Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Totsuka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="271" to="78" />
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Multiscale Approach to Integrated Volume Segmentation and Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROGRAPHICS &apos;97)</title>
		<meeting>EUROGRAPHICS &apos;97)</meeting>
		<imprint>
			<publisher>Blackwell</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="117" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficiently Using Graphics Hardware in Volume Rendering Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="169" to="177" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
