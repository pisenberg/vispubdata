<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Scientific Visualization Synthesizer</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><forename type="middle">A</forename><surname>Crawfis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">National Laboratory Livermore</orgName>
								<address>
									<postCode>94551</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Allison</surname></persName>
							<email>allison4@llnl.gov</email>
							<affiliation key="aff0">
								<orgName type="institution">National Laboratory Livermore</orgName>
								<address>
									<postCode>94551</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Livermore</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">National Laboratory Livermore</orgName>
								<address>
									<postCode>94551</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Scientific Visualization Synthesizer</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We describe methods for displaying scientific data using textures and raster operations rather than geometric techniques. The flexibility and simplicity of raster operations allow a greater choice of visualization techniques with only a small set of basic operations. In addition, texture mapping techniques will be shown that allow the representation of several variables simultaneously. without a high degree of clutter. The combination of traditional geometric techniques, image composition techniques and image rendering techniques can be integrated into a single framework for the display of scientific data. This paper presents a system for generating and operating on textures and images for the purposes of scientific visualization. The advantages of using such a system are demonstrated through the use of examples. In particular, the development of bump maps for vector filters and contour lines is demonstrated.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>There has been significant press over the past several years on the benefits of working with several individual images and combining these to produce realistic images [Porter 841, <ref type="bibr">[Cook 841</ref>, <ref type="bibr">[Hanrahan 90a1,</ref><ref type="bibr">[Haeberli 903</ref>. These same arguments can be applied to the field of scientific visualization, where instead of compositing several images of rendered objects together, we wish to composite several graphs, images or plots. The principles are the same; we wish to overlay a mesh or several contour curves on top of an existing graph. This overlaying can be accomplished by plotting the various components in a specified order. However, by blending the raster representations of these graphs together, images can be improved to highlight the most pertinent information and provide more subtle cues for less important information.</p><p>Recent research in volume rendering has demonstrated the potential for direct rendering of information. This allows large data sets to be rendered without mapping the data to a large set of geometric objects. With the size of data sets rapidly growing, problem definitions are quickly being defined on grids of resolution approaching that of typical graphics workstations. Drawing lines, polygons or vectors at every mesh point may lead to a very cluttered image. Continuous coloring or data mapping, on the other hand, provide a smooth representation of the data. The use of textures can be extended to include vector fields and contom as well.</p><p>This has motivated the development of an experimental system and language for the interactive creation of textures and raster images. The language facilitates the manipulation of images and textures by allowing the user to deal with them as individual objects. An interactive interpreter for this language has also been developed to allow interactive experimentation of various texture mapping schemes.</p><p>We will first describe the Texl language and interpreter. Then we will discuss how one can map discrete scientific data to various textures or maps that can be combined in the rendering process. This will be done through the extensive use of examples. We will restrict the majority of our attention to two dimensional surfaces with full three-dimensional renderings, and briefly show how these techniques can be extended into three dmensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Texl Texture Synthesis System</head><p>In dealing with texture maps and the data with which to derive texture maps we determined that a flexible manipulation system was required. Some of the goals we desired include programmability and extensibility. While a standard programing language provides all of the flexibility one might need, the edit, compile, and link cycle was too long.</p><p>Other systems, used for similar work, provide the flexibility within a hybrid interpreted and compiled environment. The "Image Synthesizer" <ref type="bibr">[Perlin 851</ref> creates an environment that allows complete programmability over the color of individual pixels. The synthesizer also introduced the concept of solid or 3D textures. The concept of a generalized shading language to be used by rendering systems was introduced by <ref type="bibr">[Upstill 891 and [Hanrahan 90bl</ref>. By extracting features from the previous systems, we were able to construct a system to be used for synthesizing textures.</p><p>Our system, the Texl language, was designed to be similar to C for control structures. Data types are fixed and geared towards pixels, vectors, and texture maps. Since some applications may require arrays, the texture maps are allowed to be variable in size and depth to allow them to be used as numeric arrays. All numeric operations are the same as the C language. A summary of data types and operations used in the system follows. Higher level constructs, such as colors or vectors, are allowed in expressions. A user may add colors via the plus <ref type="bibr">('I+")</ref> operator, or combine them using other operators. In some cases scalar and vector quantities are allowed to be mixed. A user may scale a color, or vector, using the following expression:</p><p>For maximum flexibility, types of similar representations may be mixed. For instance, an expression may add a point to a vector yielding a vector. All data types in the system are considered to be first class objects. This allows the programmer to create variables of any named type and assign values of expressions to the variables. As in C, assignment is an operator which produces a side effect. The assignment operator may be used within expressions, such as control expressions in l ' f o r l l or "while" loops.</p><p>All colors are specified to contain 4 components: red, green, blue, and alpha. The alpha component specifies the opacity of the indicated pixel. Alpha channels were introduced by [Porter 841 for the purposes of compositing digital images. Compositing operators are provided for individual pixels or complete images. In addition to allowing textures to contain colors, they may also contain a set of vectors, v E 91n. We have used them to contain multiple scalar values of data, which are later transformed via some function to a texture. Scientific or engineering data are imported to the system and appear in a texture variable.</p><p>For better efficiency and quicker running speed, an external routine option is implemented. Often used or complex routines can be compiled into the system and are callable as if they are Texl routines. This allows such routines to perform at high rates of efficiency. External routines have been implemented to allow use of the scalar * [l, 0, 11 standard Unixm math library. We have also implemented other routines that can benefit from being compiled in C such as three dimensional noise and texturing routines, operations on entire surfaces, and filtering. Due to the similarity of Texl and C , conversion to an external module is usually very easy.</p><p>An example of a useful external routine is the 'I stamp" operation. By creating a small (10-30 pixels square) texture, it can be used to indicate aggregate behavior in a data raster. By stamping the small texture, a field of these icons are produced which will provide information on the whole data set. Various parameters of the icon may be controlled such as: size, rotation, or the amount of transparency. Since the icon is another texture, it may be created with Texl, or imported as with any other image or data set.</p><p>The system allows the user to load various Texl code files, and select and execute desired functions. Return variables from functions (usually texture rasters) can be stored in global variables. The user may then write the textures to disk or display them on the workstation screen. Rasters may be read in to be used as parameters to a Texl function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multivariate Representations</head><p>Color shaded contour plots have become commonplace for scientific environments. With color workstations now readily available and affordable, the use of color for scientific visualization needs to be expanded. Simple raster operations provide a fast and flexible way of combining traditional techniques into a single image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simple Plot</head><p>We will start by showing a sample of typical geometric based techniques: a color shaded or data mapped image, a mesh plot or grid, several ismontour lines and a vector plot. <ref type="figure" target="#fig_1">Figure 1</ref> illustrates an image generated using  simple raster operations to accomplish these tasks. Note that the grid is obstructed by the vector plot in this image and is somewhat difficult to see. This image was generated by the following simple Texl code: Note that the incoming data is sampled into a surface or image. In this particular case, both data and data2 are surfaces with only one channel of information (as opposed to image which has four channels for red, green, blue and opacity). The surface datu is also normalized to lie between zero and one. This allows us to keep our other surface operations simple, but is not required. The data is mapped to a color image using the routine data-map1 , which simply applies a color lookup on the data. Note that a color map is simply a 1 by N surface with four channels of information. A specialized routine regular-grid is called to generate a regular grid consisting of nx gridlines in the x domain and ny gridlines in the y domain. The width and color of the gridlines can be specified. The mesh generated for this image consisted of grey gridlines on a clear background. This image is then composited with the data mapped image using a maximum compositing operator. By choosing a grey level for the mesh lines, and a standard hot-to-cold color table, consisting of fully saturated colors, the result of applying this compositing operator is to decrease the saturation of the image at the mesh lines.</p><formula xml:id="formula_0">data =</formula><p>A contour plot of another data set can be added to the image by using the contour-surf routine. This routine will determine the contour curve for the given value and draw the curve in the specified color. A simple thresholding algorithm was used here.</p><p>A vector plot is then added to the image using the vectorplot routine. This routine takes as input a vector field (vec-dura), a description of where to place the vectors (points), and a description of the vector to plot (vector), and produces as output an image with the vectors composited into it. The Texl code for this routine is shown in <ref type="figure" target="#fig_2">Figure 2</ref>. The calling syntax for this routine is very simple, yet very powerful. By allowing an image to be passed to the vector plot routine that specifies for each pixel whether a vector should be drawn, an arbitrary placement of vectors can be made. Three point generating routines are provided for this purpose: a regular grid distribution, a uniform random distribution, and a weighted random distribution that takes another data image as input for the weighting. The vector argument passed into vectorglot is also very flexible, since it specifies an arbitrary image. This allows any image to be used as a vector. In particular, vectors with varying color distributions can be used. The stamp-surf routine shown in <ref type="figure" target="#fig_2">Figure 2</ref> is used to map the texture surface onto the vector plot surface. The vector used in <ref type="figure" target="#fig_1">Figure 1</ref> was constructed by taking the union of an ellipse with a cone into a 32 by 32 pixel image. The height of this surface controlled the intensity.</p><p>To show the generality of this vector plotting routine, we create the image shown in <ref type="figure" target="#fig_4">Figure 3</ref> by reading in an image of our LLL logo and using it as the vector in our  <ref type="figure" target="#fig_2">. c &amp; r p / a f v ,~4 2 7 . )</ref> vector-plot routine. The output of this routine was then used as a mask over the data mapped image. <ref type="figure" target="#fig_1">Figure 1</ref> portrays large quantity of data, but is too cluttered to adequately convey all of the information. The next example will convey the same information using techniques developed to reduce the ovemll clutter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Using Bump Maps to Reduce the Clutter</head><p>Since the output of all of our routines are images, we can use those images as height fields of a bump map. In particular, we wish to extract one color component of the images and use that as the height field of a bump map. In <ref type="figure" target="#fig_6">Figure 4</ref> we have placed the vector field and the contour curves into a bump map:  <ref type="figure" target="#fig_1">-surf( [0.2, 0.2, 0.2, 0.21 )</ref>; image = shade( contour, bump-map, spec-map, light-source );</p><formula xml:id="formula_1">data =</formula><p>The vector field used here is essentially the same as that of <ref type="figure" target="#fig_1">Figure 1</ref> only a random distribution of the vectors is used rather than a uniform grid of vectors. Since the vector we used in <ref type="figure" target="#fig_1">Figure 1</ref> was a smooth surface, it fit well into a bump map representation of the vector field. The Contour bumps can be generated using a simple color table mapping where the table is constructed using a sine wave, generating a cycle of ridges. This contour technique has the effect of producing thicker lines or ridges where the data changes less rapidly, hence the /  gradient of the surface can be seen in the thickness of the contour bumps.</p><p>Comparing <ref type="figure" target="#fig_6">Figure 4</ref> with <ref type="figure" target="#fig_1">Figure 1</ref>, the cluttering of the image is substantially reduced, and the color data mapping can be easily followed. The choice of which data parameters should be mapped to which representations depends on the degree to which the parameter should be highlighted.</p><p>Very subtle representations of less important features can be imbedded into the image, where the representation does not disrupt the portrayal of other data, but can be discernable none the less. The mesh plot is more discernable in <ref type="figure" target="#fig_6">Figure 4</ref>, while the vector field and contour lines are still noticeable, but not quite as apparent. At the same time, the data mapped image is plainly visible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Vector Filter</head><p>The vector techniques employed above work well for most problems, but can be expensive for large numbers of vectors. For large data sets, or for rapidly changing vector fields, the use of a one pass filter to deposit a vector representation can be both more efficient and more effective. Our first pass at producing a vector filter was to construct a kernel to find the average direction, and then set each pixel in that kernel to the value of a fourdimensional function, f <ref type="bibr">(x,y,vx,vy)</ref>, where x and y are the pixel locations and vx and vy specify the vector field at that point. <ref type="figure" target="#fig_7">Figure 5</ref> was generated by applying this kernel to the velocity field of a simulation of the interaction of a shock wave and turbulent flow field <ref type="bibr">[Rotman 911</ref>. The distribution function in this case calculated the height of a cylinder drawn in the direction of the average velocity. This height was then scaled by the magnitude of the vector. The Texl code for this filter is shown in <ref type="figure" target="#fig_10">Figure 6</ref>. Vector kernels that generate a more anisotropic reflection pattern are planned for future development.</p><p>The image in <ref type="figure" target="#fig_7">Figure 5</ref> also shows the density and vorticity. Since both of these quantities had very dynamic ranges with only a few values in the range, a histogram equalization procedure was applied to the data image before applying the data mapping. These two images were then merged by showing only the right half of the density and the left half of the vorticity. A border was placed around the image and the color texture map and the vector bump texture map were passed to the shader. An animated sequence of this data set has been generated using these techniques.  <ref type="figure">*,*,,,,,,,,,</ref>  By using a stochastic noise function as described by <ref type="bibr">[Perlin 851</ref>, one or more scalar functions can be represented based on different controls and uses of the noise. The most effective means for accomplishing this is to control the frequency of the noise function. <ref type="figure" target="#fig_8">Figure  7</ref> illustrates three scalar functions. The most obvious function is the sin(x)sin(y) function represented by the blue to violet shade map. The function:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alternate representations</head><p>is represented by an increasing distribution of random bumps as we approach the lower right-hand corner. A third function:</p><formula xml:id="formula_2">F(x,~) = a -x2 -y2 F(x,y) = sin(x)sin(y) y 114 sin(x+t)sin(y+t) y &gt; 114</formula><p>is barely noticeable as a snow storm of noise where F(x,y) exceeds some threshold. While this last technique is not very noticeable with the shading and bump mapping, in an animated sequence, a very noticeable flickering will occur. While this is undesired in high quality animation, the amount of noise or flickering can be used to convey information, while at the same time, the natural filters of the eye/mind can ignore it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusions</head><p>We have shown the simplicity and effectiveness of using raster operations and texture mappings for the display of scientific information. Using textures to portray information allows the representation of several variables within a single image. However, the simple representations shown here are only the first steps to a more general and powerful representation of data sets. The research on glyphs could easily be incorporated into textures used in the rendering pipeline. Time varying textures such as the flickering of metallic paint and the boiling of water can also be used. The end goal will be to utilize the pattern recognition capabilities of the human mind, and to merge the disciplines of scientific visualization, image synthesis and image processing.  <ref type="figure" target="#fig_2">Figure 4 applied  to a surface. (as colorplate, pago 427.)</ref> Finally, it must be remembered that the resulting representations of any of these techniques are images and hence can be used as texture maps (either color decals, bump maps, specularity maps or displacement maps). Mapping these textures onto surfaces such as surface plots are trivial (since there is a one to one correspondence between the surface domain and the texture domain).</p><p>For textures generated in longitudeflatitude space, these representation can again be easily mapped onto a sphere. This allows the flexible vector plots and isocontours to be applied to surfaces without having to rewrite new complex routines that specifically handle a vector plot on a surface, or produce a stack of plots in three-space, etc. <ref type="figure" target="#fig_11">Figure 8</ref> is one such example, showing the image in <ref type="figure" target="#fig_6">Figure 4</ref> mapped onto a surface plot instead of a flat plane.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Future Work</head><p>The research presented here is just the beginning of an extended program to examine the use of textures in both 2D and 3D. Our original intentions are to examine the use of textures in both 2D and 3D. Most of the techniques here can be quite easily extended for threedimensional data sets, since the textures are generated procedurally. The use of anisotropic lighting models offers another avenue of research. Many of the techniques listed above need to be explored and tested on real scientific problems. For problems in which several variables must be understood at once, glyph-like textures may be explored.</p><p>Future work on the Texl system includes the ability to compile a Texl function to C with incremental compilation and dynamic loading.     </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>A sample raster image. (See colorplere, page 427.) _____ ____ ___ ---__ ____________ _____________ -_______ -' Vector-Plot --Sump a vector into 1 d a c e at the spccificd ............................................................... and oriented accordin to the vector figmts umbcr vectorqlot( surface vectors nuface poinu surface stam;, surface out-&amp; ) number xs = map-x-a number ys = map_y-s3 number x. y; number angle number pi = 3.1415; mdth = 0.1; number vx.vT. // The vectors arc of 8 fixed m e 0 ) &gt; 0.0 ) // controls where to dace I/ thcvoctors. . .. -. -( ......................................................... I/ Determine the vector onenution. ......................................................... angle = -90.0. += ' a y = 180.0 / pi * atan( vy / vx ); if vx c 0.0 ) angle = angle + 180.0, 1 n vec++; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 'if s m p in rhc vac^. //******* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . stamp-surf( sump x/(xs 1 I s-I) width height, mgle.'l.O. idkytri, oit-sud j;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Texl code for the vector plotter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>normalize( data ); contour = data-mapl( data, color-map ); mesh = regular-grid( nx, ny, width, color ); image = max-surf( contour, mesh ); for( i=O; i &lt; n-contr; i++ ) contour-surf( data2, cont-val[i]. cont-color[i], image ); vector = vector-stamp( vector-color ); points = grid-pts( nx, ny ); vector-plot( vec-data, points. vector, image2 ); image = max( image, image2 );</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>LLL logo used as a vector. (~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>normalize( data ); data2 = normalize( data2 ); contour = data-mapl( data, color-map ); mesh = regular_grid( nx, ny. width, color ); contour = max-surf( contour, mesh ); vector = vector-stamp( vector-color ); points = random-pts( n ); vectorglot( vec-data, points, vector, bump-map ); cont-bumps = data-mapl( data2, ridge-map ); bump-map = max-surf( bump-map, cont-bumps ); spec-map = color</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Vector plots and contour plots using a bump map.(sm coiorpiate, -427.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 .</head><label>5</label><figDesc>Vorticity, density and velocity fields produced by a shock wave of 2.78 density jump passing through a turbulent field of 0.07%. (Data courtesy of Doug Rotman, LLNL). (See color plate, p a~e 427.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 .</head><label>7</label><figDesc>Representing scalar fields using random bumps and colored noise. (See colorplats, page427.) Pass a filter over the surface that deposiu a cylindrical brush in the direction of the vector field. imber vec-filt( surface vectors, I/ The data surface containing the vectors number sue, // The size of the vector kemel in pixels. number rad I/ The radius of the c linder ixels color a colbr // The overau color ofthe c y d e r . ' sufiaceout-sbrf // The resulung sudace. ) number xs = map-x-size vectors number ys = mapj-sizel vectors 1; number IX, iy; number x. y; number temp; number length; number vx, v number x l number m&amp;-$&amp; %.%; // Minimum vector length that is plotted xl = (size + (xs 46 size)) 12.0; x2 = xs,size/Z.0; y l = ( m e + ( s 46 size))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>iy = yl, ."I&amp;(, i &lt; 2. (iy = iy+size) ) ( (iy ?= 0 ix = x l ; ix &lt;$ $?x+size) ) .......................................................... I/ Determine the vector and calculate its len th . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . if ( length &gt; min-length ) ' vx = vx / leneth: I ' I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 6 .</head><label>6</label><figDesc>Texl code for the vector filter kernel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 .</head><label>8</label><figDesc>Textures generated in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Optimization of the intermediate code representation (used by the interpreter) are also desired.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 1 :</head><label>1</label><figDesc>A sample raster image.Figurp 3: ILL logo used as a vector.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 4 :</head><label>4</label><figDesc>Vector plots and cotour plots using 3 bump map.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 5 :</head><label>5</label><figDesc>Vorticity, density, and velocity fields Droduced by a shock wave of 2.78 density jump passing through a turbulent field of 0.07%. (Data courtesv of Doua Rotman, LLNL).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 7 :</head><label>7</label><figDesc>Representing scalar fields using random bumps and colored noise Ligu-e 8 Toxtures generated inFigure 4applied to a 'YJrfclCe</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under contract No. W-7405-Eng-48. We would like to thank Gene Cronshagen for generating <ref type="figure">Figure 5</ref> and developing the histogram equalization techniques, and Doug Rotman for graciously providing the data for <ref type="figure">Figure 5</ref>. We would also like to thank Becky Springmeyer, Mark Wagner and Nelson Max for proofreading and useful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">L</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shade Trees</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Direct WYSIWYG Painting and Texturing on 3 0 Shapes</title>
		<meeting><address><addrLine>Paul, Paint By Numbers</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="215" to="223" />
		</imprint>
		<respStmt>
			<orgName>Pat and Paul Haberli</orgName>
		</respStmt>
	</monogr>
	<note>Computer Graphics. SIGGRAPH 1990</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Language for Shading and Lighting Calculations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Lawson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="289" to="298" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
	<note>SIGGRAPH 1990</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Compositing Digital I m a g e s</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><forename type="middle">;</forename><surname>Perlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Duff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">253</biblScope>
			<date type="published" when="1984" />
		</imprint>
	</monogr>
	<note>Computer Graphics. SIGGRAPH 1984</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Douglas</forename><surname>Rotman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Shock Wave Effects on a Turbulent Flow</title>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1792" to="1806" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Upstill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">The</forename><surname>Renderman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Addison Wesley</publisher>
			<pubPlace>Reading, Ma</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
