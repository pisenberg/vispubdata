<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Fast Ray Casting Algorithm Using Adaptive Isotriangular Subdivision</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Renben</forename><surname>Shu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Systems Science</orgName>
								<orgName type="institution">National University of Singapore Kent Ridge</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Systems Science</orgName>
								<orgName type="institution">National University of Singapore Kent Ridge</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Fast Ray Casting Algorithm Using Adaptive Isotriangular Subdivision</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Ray casting is a popular method of rendering high quality images from volume data. Its main shortcoming has been the high computational eapense. This paper proposes a method of subdividing the image plane with isosceles triangles instead of &amp;ants as is usually done, resulting in f w e r rays being fired without sacrificing image quality. A brief theoretical analysis of the algorithm in comparison with other methoa3 is given.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Scientific Visualisation refen to the collection of techniques used to render volume data whose elements bear a spatial relationship with each other. It is commonly employed as a tool to aid research in various areas by providing the researcher a visual grasp of the problem under investigation.</p><p>Volume data are typically a set of values defined in 3-dimensional space. Each value (or density) may be taken to represent a small, finite volume called a wxel.</p><p>Points within a voxel have identical density values. This is known as the cuberille model (eg. <ref type="bibr">[TLTyM]</ref>, [GID851). The cuberille model thus views 3-space as a set of points whose density values change across voxel boundaries but remain constant within a voxel.</p><p>An alternative representation considers the volume as a sec of points whose density varies continuously according to a function of the spatial coordinates of that point As this-function is often not known, a finite set of points whose density can be determined by some form of direct observation is used to chaxacterise the volume. In most cases, this set of points occur at uniform coordinate locations. The density value of an arbitrary point within the volume is then determined with respect to all or some of the known points. The computational cell model expounded by Upson and Keeler lupSSS] falls under this category. Much of the work done in volume rendering are either implicitly or explicitly based on this model. (eg.</p><p>lLEVSSa1, DAR901, IPOH901 and IKAJ841).</p><p>The f d objective of any visualisarion effort is the generation of an image from volume data structured in the manner described above. Two appraaches have been widely used to render volume information; surface rendering and volume rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Surface rendering</head><p>Generally, surface rendering algorithms require elements of the dataset to be first classified into 2 sets, those above or equal to a given threshold (known as I-voxels) and those below the threshold ( d e d U-voxels). This partitions the datasets into 2 or more disjoint segments whose boundary "surfaces" can be used to produce meaningful images. Rendering algorithms all concentrate on fast and efficient methods of detecting and producing this boundary surface. For example, Artzy, Frieder and Herman [ARTS11 handles this problem by tracking-and extracting voxel faces that lie on this boundary. Another example is the Marching Cubes algorithm [LOR871 which extracts the boundary as a series of trianguIar polygons whose orientation approximates the surface. Wilhelms and Van Gelder IwIL901 improved on this by using an cctree data structure to quickly skip over parts of the volume having no surfaces, thereby speeding up the rendering process.  <ref type="bibr">([LEV901 and [SHU91]</ref>) also address this issue but approach the problem in a different way. In this paper, we extend the work done in [SHU91] with additional refinements which result in superior performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Volume rendering</head><p>The rest of the paper is organised as follows; we first describe briefly the principle of what Levoy has termed Adaptive Ray Casting Algorithms LEV901 as well as a similar approach which uses the Same idea but offering superior performance under simulation [SHU90]. We will then present an interesting variation to existing adaptive methods which outperform both earlier attempts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Adaptive ray casting algorithms</head><p>Adaptive ray casting algorithms exploit the coherency and band-limited nature of volume data so that on the average, less than 1 ray per pixel is needed to produce an image which is visually comparable to that obtained by conventional ray casting. Depending on the complexity of the image, speedups of as much as 4:l have been obtained with the variation presented in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Levoy's algorithm</head><p>Levoy's Algorithm works as follows. The image plane is divided into square sampIe regions (or 'tiles') each of side Wmax in length. <ref type="figure">Fig. 1</ref> illustrates the process. No further ray casting for a given region is required if the color from each comer pixel differs by less than some value, say Epsilon (A regions). Otherwise, the region is divided into 4 subregions and more rays are cast (B regions). The subdivision occurs recursively until either Epsilon is satisfied or the length of the side of the region falls below a specified minimum Wm,. Levoy's Algorithm has similarities with the principle behind quadtrees.</p><p>However, unlike quadtrees, Levoy's Algorithm does not assume that a terminal square has a single uniform color. Moreover, the procedure described above does not, by itself, color every pixel. Levoy uses a recursive interpolation technique for this purpose and is described in greater detail in his paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Triangular recursion</head><formula xml:id="formula_0">* -_ W W 2 Fig. 2. Tile subdivision in TR</formula><p>Levoy's Algorithm requires up to 5 additional rays to be fued for each tile subdivision. As each ray requires considerable effort to compute, it would be to our advantage to find a way to reduce the number of rays required to subdivide a tile. In a previous paper [SKU901 we have proposed using a different geometrical "tile" shape (a right angled triangle) which, under simulation, appears to reduce the number of rays required significantly. <ref type="figure">Fig. 2</ref> show graphically how TR "tiles" are subdivided. Each tile subdivision now only requires a maximum of 1 new ray to be fired. This algorithm, which we call Triangular Recursion, has since been implemented and used to generate images from medical, molecular and engineering volume data. The actual amount of improvement over Levoy's Algorithm varies for different datasets, but on the average, Triangular Recursion requires significantly less time than Levoy's Algorithm to produce an image of comparable quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Isosceles triangle recursion</head><formula xml:id="formula_1">W 4 e W A --W 2 Fig. 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. Tile subdivision in ITR</head><p>We propse a new method of partitioning the image plane so that the resulting adaptive algorithm requires significantly less rays compared to Levoy's Algorithm and TR. Owing to the shape of the geometric "tile" used to partition the image plane, we call our method the Isosceles Triangle Recursion, or ITR. <ref type="figure">Fig. 3</ref> shows a closeup of one such tile and how an ITR "tile" is subdivided. <ref type="figure">Fig. 4</ref> illustrates an image plane that has been partitioned using this tile shape. Note that tiles near the edge of the image plane lie partially outside (denoted by dotted lines) and hence pixel coordinates should be checked before ray casting is actually done. In the remainder of this paper, we will show, both theoretically and using an implementation, that such a geometrical shape significantly speeds up the adaptive ray casting process.</p><p>..</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..</head><p>. . <ref type="figure">Fig. 4</ref> . Subdividing the image plane using ITR</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Theoretical analysis</head><p>Exactly how ITR performs in comparison with the other algorithms is highly object dependent as well as the value of Epsilon, Wmax and W-.</p><p>However, if certain assumptions are made, we may prove that on the average, ITR performs significantly better than current adaptive image subdivision algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Definitions</head><p>Consider an image plane of resolution L x L pixels. Denote by Cjo the state of the image plane after initial subdivision. We define C ' to be the state of the image plane after every initial tile subdivides i times. Let lo denote the size of an initial tile (lo is a power of 2) Then if No is the number of tiles required to span the width of the image plane, we have No= (4 1. We note here that L must be chosen so thatis an integer. Define Npi to be the number of tiles at a given state C ' . Then we may also define NR,. to be the number of rays cast in order to change the image plane from state C ' to state C ' &amp; , .  For practical purposes, the image plane is sufficiently large so that we may simplify the above to N R~ = No2.</p><p>Considering the general case, it is clear, that Npi = 4Npi-,. Since Levoy's algorithm subdivides into 4 subtiles. we may generalise the argument to Npi = 4' " Determining N R~ is slightly more involved. Consider <ref type="figure" target="#fig_3">fig. 6</ref>. To get Cfr, f" CA, each tile subdivides by fhng off 5 rays. However, of these, 4 rays a~ shared by The previous section gives a way of determining Npi and Niti. However, under pratical situations not all tiles will subdivide. For this reason, it is instructive to compare the expected number of rays that will be fired for Levoy's algorithm or EL. We assume that the probability of a tile subdividing is proportional to it's area Our assumption is justifiable because we restrict our considerations to regular shaped tiles whose length is not significantly longer than their breadth. In addition, the size of each tile is small relative to the image plane (typically Wm, is not larger than 32 pixels while image planes are typically 768x768 pixels). Using this assumption, we may write pi = d? where pi is the probability that a tile of dimensions Ii x li will subdivide and a is a constant. Now let lo = 2h such that lo is relatively small w.r.t L.</p><p>Then for Levoy's algorithm, we have </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="45.">Comparison of expected rays fired</head><p>Using the results obtained from the previous sections, we have</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Results</head><p>Each approach (ITR, TR and Levoy's) is used to render images of successively higher quality (ie. decreasing Epsilon). Iteration stops when an image visually indistinguishable to that produced by direct ray casting is obtained. The amount of CPU time required to generate this image is then compared with the corresponding CPU times for the other techniques. <ref type="figure">Figs.</ref> 15 to 17 show images produced using ITR. As can be seen, there is no visible difference between ITFt and the brute-force algorithm. At the Same time, ITR is significantly faster, as shown in the series of graphs below (figs. 9 to 11). Owing to space constraints, we only publish screen snapshots of images rendered using the brute-force method and ITR, however for comparison purposes, we have also applied the same test approach to both TR and Levoy's Algorithm. As can be seen, ITR consistentIy outperforms the other 2 techniques.</p><formula xml:id="formula_2">EL : El -- No2 x 3 d 2 h : No2 x i d h 7. Conclusion -- 3h: 1.5h 2 : 1 --</formula><p>A similar reasoning can be applied to compare ITR with TR, which has not been presented owing to space limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Testdatasets</head><p>To determine how ITR performs with actual volume data, we have applied the algorithm to a number of datasets from different disciplines. These are;</p><p>Machine Part. This is a representative dataset used for research in materials engineering. The part used is a component of an engine cylinder block.</p><p>Human Head I (bone surface). This is a 256x256~113 CT scan of the head from a cadaver. The data was provided by courtesy of the University of North Carolina.</p><p>Molecule. This is an electron density map of a molecule.</p><p>Figs. 12 to 14 are sample images rendered from the above datasets using the brute-force algorithm of ray casting every pixel. All images generated for this paper were produced on an IBM RS/6000 Model 320 using the Silicon Graphics display adapter for image display. All images have a resolution of 768x768. This is sufficiently large for good photographs to be taken, but not too large that it would take brute force ray casting an inordinately long time.</p><p>This paper describes the use of ray casting in volume rendering, it's uses and advantages over surface rendering algorithms. One of the biggest shortcomings of ray casting is it's computational complexity. Our paper has described various adaptive algorithms which attempt to overcome this problem by taking advantage of image coherency and the band-limited nature of volume data.</p><p>Finally, we proposed a refinement to existing algorithms by choosing a different geometric shape to partition the image plane. A brief theoretical analysis is given which compares our approach with Levoy's algorithm. Using this approach, we have succeeded in obtaining improvements over existing adaptive ray casting algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">References</head><p>[ARTSl] Artzy E., Frieder G., Herman G.T. "The theory, design, implementation and evaulation of a 3-dimensional surface detection algorithm". CG&amp;A. 15, pp. 1-24.        </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Wmax - 2 Fig. 1 .</head><label>21</label><figDesc>Tile subdivision in Levoy's algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figs. 5 and 7 illustrate our definitions. For a given algorithm, N R~ and Npi can be determined as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>State Cfo for Levoy's algorithm From fig. 5, it is obvious that in state Cfm Np0 = No2 and NR~=( 1 + No )2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>neighbouring tiles. Hence, the actual number of total rays fired is less than 5NPp A little calculation will show that Ray sharing in Levoy's algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .1 2 -Fig. 8 .</head><label>728</label><figDesc>State Cfo for ITR Using the same reasoning, we have Npo = 2N02 and N R~ = 3 NO +NO'. Extending this to the general case, an ITR tile subdivides into 4 subtiles. However, in the case of ITR only 3 additional rays are required. Moreover, each ray is shared by exactly 2 tiles, hence, Note that an ITR tile is 5 the size of a Levoy tile, hence pi. the probability of an ITFt tile subdiyiiding is pi = 1 dl . Now let lo = 2h such that lo is relatively small 2 w.r.t. L. Then for ITR, we have \ Ray sharing in ITR</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>[ DAR90 ]</head><label>DAR90</label><figDesc>Darin L. B. Sudhanshu K. S. "A new front to back composition technique for volume rendering." W. CG International 1990. pp. 149-174. [CIDSS] Gideon F., Gordon D.. Reynolds R.A. "Back-to-Front Display of Voxel-Based Objects." E E E CG&amp;A January 85. pp. 52-60. (HOE901 Hoehne K. H., Bomans M.. Pommert A, Riemer M., Gunnar W. "Surface rendering". I E E CG&amp;A M m h 1990 pp 41-53. [HOH90] Hohne K.H., Bomans M, Pommert A. et. al. "3D visualisation of tomographic volume data using the generalised voxel model". 'Ihe Visual Computer (Kajiya J, Von Herzen, B. "Ray Tracing Volume Densities", Conputer Graphics 18(3) July 1984 pp.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 .Fig. 10 .</head><label>910</label><figDesc>Performance comparison for machine part Performance Comparison CT S c a n (human head) Performance comparison for CT scan (head) [LEVSSa] Levoy M. "Volume Rendering: Display of surfaces from Volume Data". IEEE Computer Graphics and Applications. May 1988. pp. 29-37. [LEV?38b] Levoy M. "Efficient Ray Tracing of Volume Data" Technical Report TR88-029, University of North Carolina at Chapel Hill. June 1988. [LEVW] Levoy M. refinement." The Visual Computer (1990) 62-7. "Volume rendering by adaptive [LOR871 hrenson WE. , Cline HE. "Marching cubes: a high resolution 3D surface ConstNction alprithm". Computer Graphics, Vol 21, No 4, July 1987. pp 163-169. [SHUW] Shu R.B., Liu A., Huang K.T. "An improved adaptive ray casting algorithm". Prodings IFlP TC 5/WG 5.10 Conference on Computer Graphics, Tokyo Japan. April 1991. [TUY84] TUY H.K., TUY L.T. "Direct 2-D display Of 3-D Objects." LEE CG&amp;A. October 1984. p~ 29-33. [WEL90] Wilhelms J. , van Gelder A. "OcaeeS for Faster Isosurface Generation: Extended Abstract". Computer Graphics Vol. 24 No. 5 Nov 1990. pp 57-62. Performance Comparison Molecule Fig. 11. Performance comparison for molecule</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 12 :</head><label>12</label><figDesc>Brute-force rendering of machine partFigure 13: Brute-force rendering of CT scan (head).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 14 .</head><label>14</label><figDesc>Brute-force rendering of molecule. Figure 15. I TR rendering of machine part.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 16 .</head><label>16</label><figDesc>I TR rendering of CT scan (head).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FigureA</head><label></label><figDesc>Fast Ray Casting Algorithm I ! sing Aduptitse lsotriangular Subdivision, R. Shu and A. Liu, pp. 232-238.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Brute-force rendering of machine part Figure 14. Brute-force rendering of molecule Figure 13: Figure 15 Brute-force rendering of CT scan (head), ITR rendering of machine part.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 16 ,</head><label>16</label><figDesc>ITR rendering of CT scan (head: Cigure 17 ITR rendering of molecule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>91/0000/0232601 .OO 0 1991 IEEE</head><label></label><figDesc>Volume rendering does away with the need for an intennediate polygonal representation and renders an image directly from the volume of interest. Image pixels are shaded as a function of the density values in</figDesc><table><row><cell>the density under consideration. Using this technique. it is possibk to produce images containing multiple semi-transparent surfaces, thereby revealing more detail than surface tracking methods. Ray casting is frequently used as a re-sampling technique in volume rendering. It has the advantage of algorithmic simplicity and the ability to produce reaIistic, high-quality images. As such, ray casting is widely used (eg. see [KAJM], LEV88a1, LEV88b1, [SHU91], [DAR90], [HOH90], and [LEV90]). It's primary disadvantage is the extreme computational expense arising from the large number of samples required per ray to generate images free from aliasing. Attempts have been made to minimise unnecessary sampling. For example, Levoy &amp;EV88b] uses a hierarchical enumeration scheme to rapidly bypass empty regions in CH3046-0/that values other than 0 and 1 are allowed, depending on the volume of interest. Adaptive subdivision algorithms</cell><cell>each voxel. Volume rendering relaxes the either-or requirement of binary classification by inaoducing the concept of opacity classification. The visibility (or opacity) of each point in the volume varies as a function of it's density between 0 (invisible) and 1 (fully opaque). In other words, opacity classification may be regardd as a generalisation of the binary classification principle in</cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl/>
			</div>
		</back>
	</text>
</TEI>
