<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Rotation of Volume Data on Data Parallel Architectures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Schrijder</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">B</forename><surname>Salem</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<addrLine>245 First St</addrLine>
									<postCode>02, 142-12 14</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<addrLine>48 94, 171 97 56 324 256&apos; 257</addrLine>
									<postCode>1282, 525</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fast Rotation of Volume Data on Data Parallel Architectures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Data parallel computer architectures hold great promises for high performance computing. Volume visualization (raytracing) is an application that can greatly benefit from these architectures. We describe an algorithm for rendering of orthographic views of volume data on such architectures. In particular the problem of rotating the volume in regard to the communication overhead associated with finely distributed memory is analyzed. We extend an earlier technique (shear decomposition) to 3D and show how this can be mapped onto a data parallel architecture using only grid communication during the resampling associated with the rotation. The rendering uses efficient parallel computation constructs that allow us to use sophisticated shading models and still maintain high speed throughout. This algorithm has been implemented on the Connection MachineR parallel supercomputer and is used in an interactive volume rendering application, with multiple frames per second performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Practitioners in such diverse fields as health care, geophysics, hydrodynamics, and molecular biology among others <ref type="bibr">[16; 23; 6</ref>; 141 increasingly accept and use volume rendering as an important analysis and educational tool. Interactive volume rendering is particularly desirable since often users cannot determine the proper rendering parameters a priori, and thus want to experiment to create meaningful images. Ideally, adjusting the parameters should provide an intuitive "physical" interpretation [ 1 11 and an interactive response <ref type="bibr">[24;</ref> 91, which requires large computing resources. The rapid advancements in parallel computer architectures have spurred interest in parallel volume rendering algorithms. This paper presents a parallel algorithm that rotates and renders three-dimensional volumes and is suitable for interactive systems.</p><p>In recent years, many algorithms have been developed that take advantage of the processing capabilities of data parallel computers. Data parallel algorithms and implementations exist for many traditional supercomputer applica-tions, such as hydrodynamics, finite element analysis, financial modeling, and large database searching <ref type="bibr">[l]</ref>. The huge computational requirements of many graphics problems have naturally led to the development of several data parallel algorithms [ 19; 5; 4; 18; 8; 21 in this arena as well.</p><p>Data parallel algorithms distribute data points finely across many processors. Without counting the communication cost, the floating point capabilities of computers such as the Connection MachineR system are more than sufficient for interactive volume rendering. For example, using the conservative estimate of 2 gigaflops performance for a 65536-processor CM-200 (5% of peak), we could afford 6 operations at each voxel, 20 times a second, on a volume of size 2563. This performance is only achieved in pure rendering. Communications overhead involved in transforming the volume considerably limits the performance of a parallel volume rendering system.</p><p>In this paper we present an efficient rotation algorithm that allows any orthographic rendering of a scalar data volume at interactive speeds (multiple frames per second). While our implementation of the ideas presented in this paper is a software implementation on a particular general purpose data parallel computer, the concepts are equally applicable to other data parallel computers, as well as to the design of custom hardware, or to software implementations on serial machines.</p><p>We address the problem of rendering a volume directly, as previously described in, for example, [6; 121, rather than extracting geometric primitives as is done in the marching cubes algorithm <ref type="bibr">[14]</ref>. The direct approaches integrate a linear transport equation [ 113 through the volume. In the algorithm described in <ref type="bibr">[6]</ref>, the volume is treated as a stack of 2D images which are suitably transformed and then composited to yield the final image. This corresponds to a transformation of the volume such that the view rays of an orthographic projection are axis-aligned with the transformed volume. In <ref type="bibr">[12]</ref> the rays are instead cast into the untransformed volume from the viewpoint in worldspace. Both of these algorithms map onto corresponding parallel implementations.</p><p>Before discussing how these two approaches can be mapped into a data parallel architecture we will give a short overview of the CM-200 architecture. This is followed by a detailed description of our algorithm, a discussion of the performance results, and directions for future research. The appendix gives a short description of the relevant parallel programming idioms, which we use in the following discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Data parallel programming primitives</head><p>The algorithm was implemented on a CM-200 computer, but is equally applicable to other data parallel architectures. The assumptions that went into the design are that the underlying hardware is SIMD (single instruction multiple data), and that grid communication is much cheaper than general communication. The former means that such customary optimizations as early termination of a view ray, due to the accumulated opacity [ 13 3, are meaningless as long as there are rays that still need further processing ' . The latter favors local computations and leaving the data in place over striding through memory (processors).</p><p>The CM-200 itself consists of 4k to 64k bitslice processors with one floating point chip for every 32 processors. The processors are organized in a hypercube with a toroidal topology <ref type="bibr">[lo]</ref>. Each processor has from 256kb to lOOOkb of local memory. The programming model supports virtual processors, allowing the programmer to abstract away from the actual number of physical processors available. This is achieved by having a physical processor simulate several virtual processors and is especially helpful for volume rendering, since most volumes of interest have many more than 64k voxels.</p><p>The algorithm itself was implemented in C* [22], a parallel extension of ANSI C. In the description of the algorithm below we will use the following C* constructs: shape,parallel variable, grid communication, and send and get (general communication). For a definition of these terms see Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Parallel volume raytracing</head><p>There are essentially two approaches to parallel volume raytracing. The first approach is a direct descendant of the volume rendering algorithm by Levoy [ 121; the second approach follows in the footsteps of the techniques proposed by <ref type="bibr">Drebin et al. [6]</ref>.</p><p>One data parallel implementation of <ref type="bibr">Levoy's [12]</ref> ray tracing approach would be to create a 3D shape in which two dimensions correspond to the pixels in the image plane and the third dimension maps into the samples along the rays emanating from every screen pixel. A second 3D shape has the extents of the volume and contains the actual data. Raytracing can then be performed by having every sample along a ray compute in parallel the address of the voxel in which it lies. These addresses can be used in a general communi- cation step to get the associated data values from the voxel shape, together with, for example, the gradient for use in a tri-linear interpolation of the data value at the actual sample point inside a given voxel. After collecting the correct sample values in the ray shape, efficient parallel programming constructs can be used to compute the intensity integral along the rays (for the details of this mapping see <ref type="bibr">[ 171)</ref>.</p><p>The advantage of this approach is that perspective transforms and scaling can be executed just as easily as orthographic projections. The major disadvantage lies in the fact that the general router hardware needs to be invoked to get the actual values and gradients from the voxel shape into the ray shape. This step is very costly, not just because of the inherent cost of a get operation, but also because the number of bits to be transferred is rather large. For example, for a 1283 volume of samples and gradients, eight million floating point values (32MB) must be transmitted. Since we are interested in interactive performance we chose not to go this route.</p><p>The other approach, put forth first by <ref type="bibr">Drebin et al. [6]</ref>, transforms the volume such that one of its coordinate axes is aligned with the rays, and then composites the data. This leaves the step of transforming the volume itself. Scaling by arbitrary factors as well as perspective transformations involves general communication, since the data values need to move various distances in processor space (only constantdistance moves are efficient grid communication). In the interest of speed we allow rotations in the transformation step only and assume that any scaling has been performed as a preprocessing step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Rotation</head><p>The most straightforward way of rotating the volume would be to rotate a 3D coordinate at each processor, giving us an address of the screen pixel into which a given sample falls. These samples cannot, however, be simply sent to the screen, as this would leave holes in the image (see <ref type="figure" target="#fig_0">Figure 1)</ref> 2 . Instead we are looking for a one-to-one mapping that transforms integer lattice points in the original volume 'For an approach that takes finite extent filter footprints explicitely into account to avoid these holes see <ref type="bibr" target="#b19">[24]</ref>.</p><p>into integer lattice points in the rotated volume, which then trivially map into screen coordinates. Such a mapping also insures that we have as many processors holding data after a rotation as before a rotation, which is a necessary condition for avoiding global data motion.</p><p>One approach which can give us such a one-to-one mapping is based on decomposing a transformation into a sequence of shears. Such multi-pass scale-shear techniques were used by <ref type="bibr">Drebin et al. [6]</ref>. A number of such algorithms have been published in the literature [3; 20; 21; 151, most recently by <ref type="bibr">Hanrahan [7]</ref>. All of these algorithms except the ones by <ref type="bibr">Paeth [15]</ref> and Tanaka et al.</p><p>[21] use a decomposition of rotation into shear matrices that have a non-unit scaling component (we will refer to these as scale-shearmatrices). The non-unit scaling, however, implies that these maps are not one-to-one on the whole numbers-we have more/fewer voxels after a scale then before. On a finely distributed memory architecture this leads to general communication, since the scaling moves data across a distance that is a function of the coordinate of a given voxel and not a constant for all processors. Our algorithm is instead based on a decomposition into pure shear matrices, which extends the techniques introduced by Paeth <ref type="bibr">[ 151 and Tanaka et al. [21]</ref>. <ref type="bibr">Paeth [15]</ref> and Tanaka [21] independently proposed a decomposition of 2D rotation into three shear matrices (here and throughout we assume column vectors and right-handed coordinate systems):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Shear decomposition of rotation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>cos0 -sin0 sine cose</head><p>An arbitrary angle rotation is expressed as a multiple of w/2, which is just an index manipulation, followed by.a rotation in [-7r/4, 7r/4], which is executed as a shear in the above fashion. This is to ensure the least amount of degradation in the individual shearing steps, due to resampling (for a detailed analysis of the filter characteristics of the entire sequence of shears refer to Paeth <ref type="bibr" target="#b4">[ 151)</ref>. This decomposition can be extended to 3D by observing that a single axis rotation of a 3D volume is just a 2D rotation of the slices perpendicular to the rotation axis. To disambiguate the notation, we will write a single axis shear of three space by specifying which axis gets sheared, along which orthogonal axis, and by how much. For example: This leads to a formulation that factors an orientation of three-space into a product of nine shear matrices: (Notice that a and ,b have opposite sign from those in equation 1). In this factoring, the third and fourth shear from the right can be multiplied into a single shear, since they shear the same axis (ZFalbeit as a function of Y and X respectively-leaving us with an eight-shear factoring.</p><formula xml:id="formula_0">Rz+&amp;+Rz@ = ( S ( Z , Y , C ) S(Y,Z,T) S(Z,Y,C) 1 ( S ( Z 7 277) S(Z,<label>r7</label></formula><p>Unfortunately, concatenating the sixth and seventh shear results in a shear matrix that shears two rows at the same time, giving us a 2D instead of a much simpler 1D resampling problem.</p><p>Another way to factor an orientation into seven shear matrices is based on the observation that any orientation can be expressed as a rotation of the form Rat R b R, , a, b E {z, y7 2). While there are six such possible products, they all have the property in common that one of the entries in the composite matrix is the cosine of the second rotation. For example</p><formula xml:id="formula_1">Rz,,Ry+R=, = ) Se S+ c 0 s, S,,S+ Coco, -C+.SeSet -CsiSe -CsC+Sel -CO! S, C~J C + S~ -I-CeSel CeCeiC+ -SeSe1 (3) ( c @</formula><p>(here C and S stand for the cos and sin of their subscripts respectively). Even though we can execute any column or row exchange and any sign change in a pre-or postprocessing step, we will not always be able to move an entry of sufficiently large modulus into the position ofthe cos entry in the matrix-the (1,l) entry in the above exampleto insure that the second rotation is within [-7r/4,7r/4].</p><p>In the worst case (the rotation with all matrix entries of modulus 1 /&amp;) this forces us to choose a rotation angle of cos-l( l/&amp;) FZ 0.955rad for the second rotation. In other words, the second rotation cannot always be guaranteed to be in the desired range. As Paeth points out in his analysis of the error behavior of the three pass algorithm, the filter degrades considerably outside of [-7~/4, ~/ 4 ] , rendering the factoring of equation 3 inferior to the altemative that we have implemented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Implementation</head><p>Instead of factoring an orientation into three rotations of three space we only consider two-axis rotations. A full orientation can then be achieved by a third rotation in the image plane itself. Since the number of elements to be rotated is so much smaller in the image plane than in the volume, this is a much faster approach to generating arbitrary orthographic views of the data set. This leaves us with a five-pass shear algorithm on the volume followed by a three-pass shear of the image plane. Using the notation of equation 2 for a rotation about X and then Y, for example, the volume shears are:</p><formula xml:id="formula_2">RY&amp;, = ( S(2, 2 , Y ) S(z, 276) S ( f , X&gt;Y) ) ( S(Z, Y, a ) S(Y, I, P) S ( f , Y1 a ) 1</formula><p>Remembering that each shear only manipulates one coordinate at once, and compositing the third and fourth shear (they shear the same axis), this can be expressed as the following sequence of transformations:</p><formula xml:id="formula_3">z t z + ( Y y Y + Y + P z 2 + 2 +ay +yz z + -z + b z t t z + y z (4)</formula><p>where the shear variables are chosen as in equation 2. Each shear can be decomposed into a fractional and an integral part. For example, the first shear in equation 4 has integral part r m n d <ref type="bibr">( a y )</ref> and fractional part ay -r m n d ( a y ) . In a typical serial implementation the above shears are executed by reading an element from a source array, 1D-resampling it to accommodate the fractional shift, and writing the result to a destination array with an index shift corresponding to the integral part of the shear (see <ref type="figure" target="#fig_3">Figure 2)</ref>. Hence, the integral part causes a data motion. This data motion is a constant distance for each row, however, this constant is different for each row. On a finely distributed SIMD architecture this again implies general communication: not all processors move data a constant distance, which would be grid communication. In order to avoid this general communication step we do the fractional interpolation of the data in place. To execute the integral shift we manipulate the coordinates of a datum rather then moving it. As a consequence, the coordinates associated with a datum are not the implicit coordinates of array referencing-or processor address-anymore, but rather explicit quantities. We hold these as an integer triplet at every processor and apply the integral part of the shear to them. For this strategy to work we have to ascertain that the "shift" of the coordinates does not result in two processors representing the same coordinates, as this would again lead to "doubling up" and holes. This doubling up does indeed not occur (for a proof see <ref type="bibr">Appendix C in [ 171)</ref>.</p><p>The data itself is linearly resampled in the direction of the given shear according to the difference between the rounded coordinate and the fractional coordinate. Thus the only communication necessary in the rotation part of the algorithm comes in the resampling step, in which we use grid communication for linear interpolation. Although this is not a high quality filter, we have found that it produces only minor aliasing artifacts and only for very small rotation angles. Higher order filters could be used by fetching values from a larger neighborhood. Since our main interest was in sufficient speed for interactivity, we have not pursued the use of higher order filters.</p><p>When rotating about other axes the above set of steps still applies with the modification that the indices are suitably permuted. Multiples of 7~/2 in the first and second rotation are simply expressed as the associated permutatiodsign change of the indices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Relative motion of neighbors</head><p>By leaving the data in place we exchange the physical move with an index manipulation. An unfortunate consequence of this is that it becomes more complicated to keep track of neighbors. For example, the forward neighbor in X might not be at the processor whose address is one higher in X anymore, due to a relative index shift of one in the column to the right (see <ref type="figure">Figure 4</ref> for an example of this). There does, however, exist a decision procedure to find the correct physical location of a logical neighbor based on purely local considerations. In essence, we examine whether adding (or subtracting) another cy will make the fractional part cross a "rounding boundary." This information is kept in two bits each for all previous shears. For a given shear, say along Y as a function of X, the corresponding bits indicate whether the processor above (meaning: with processor address one higher in X) or left (below) has a Y coordinate that is one larger (smaller) than the Y coordinate of this processor (see <ref type="figure">Figure 4)</ref>. These bits are computed as follows: /* parallel variables of 'cube' shape */ }else { 1 For all shears the code for the bit flags is identical except alpha and x, which are replaced by the shearing factor and the shearing coordinate respectively of the given pass. For For the decision procedure, which deduces the actual position of a desired neighbor, the following observation is important. Since we only consider angles in [-7r/4,7r/4], the first and third shear pass of a given rotation-which both shear the same axis-cannot create a shift above and below since l a1 5 tanw/8 x 0.41. This guarantees that forward-and by symmetry, backward-neighbors cannot wander off, due to rounding, from the one neighborhood(26 neighbors in 3D) of a given voxel in any of the five shears, independent of the actual rotation angles. For a detailed table of neighbor locations due to relative index changes as a function of the above and below bits in all the shears, see Appendix B in [ 171.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Parallel rendering of the volume</head><p>After the five shears have been executed, every processor contains a properly resampled value of the actual datafield as well as an associated triplet of coordinates. At this point there are two ways to generate an image on the screen. The first one applies to any rendering operator that is associative and commutative, such as, for example, a pure summing along the view ray-only a volume source term in the transport equation [ 1 11-to show the spatial decay of a datafield.</p><p>Another useful operator in this category is selection of the maximum value along the view ray, which detects structure. For such rendering operators the communications network can be invoked to do the operation en route to the screen. In this case we would take the X and Y coordinate of every voxel as the destination address in a send operation. The router network uses the specified combiner operator, for example, MAX, to combine messages whenever there is a collision in the routing network. For the send from the volume to the screen this will occur for all messages with the same X and Y address. Through the use of this combiner operator the general communication network can perform computation while successively reducing the number of messages moving through the network.</p><p>For non-commutative rendering operators, however, this technique can not be used, since the order of combination in the routing network is not known a priori (although it is deterministic). However, if the elements to be combined are in a known order, in particular, along a single axis of a shape, more efficient parallel programming constructs (scan and reduce, which achieve the compositing in logarithmic time in the length of the ray) can be used (see <ref type="bibr">[ 171)</ref>. In order to take advantage of these operators we need to reorder our resampled values, since their coordinate variables do not correspond to their processor addresses. While this requires a general send operation, the cost is more than made up by the efficient computation we gain after this reordering. This is especially true considering that the typical interaction loop with the program consists of a sequence of rotations to position the volume, followed by a sequence of renderings with varying parameters. Reordering the data also simplifies the approximation of the gradient of the data field. The actual rendering operator that we use is described in [I I].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Performance</head><p>The algorithm has been turned into a prototype application, allowing users to load a dataset from the Datavault (a parallel disk array attached to the CM-200) and to manipulate it through a graphical user interface. The program was used on machines ranging from a 4k to a 64k processor CM-200 and on data sets ranging in size from H3 to 1283. While these data set sizes are small for acquired data, such as seismic measurements, they are quite large for simulations, e.g., finite difference methods in computational fluid dynamics.   The typical interaction loop consists of a sequence of rotations to position the volume in an interesting view, followed by a number of adjustments to the rendering parameters. For this reason we have broken the algorithm into its rotation and rendering steps to give the best possible feedback speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1283</head><p>The measurements of <ref type="table" target="#tab_1">Table 1</ref> were made on a CM-200 with 1 Mb of memory per processor running at 1 OMHz. The times given do not vary with the data, however, single axis rotations, a common mode of rotation, execute in approximately one third the time of a two axis rotation. The number of terms in the rendering equation, such as the number of isosurfaces also influences the rendering time. High resolution renderings can be realized via subsampling after the rotation and their time is proportional to the screen area. For the times quoted in <ref type="table" target="#tab_1">Table 1</ref> the rendering included volume and isosurface sources, volume absorption, and attenuation by one extemal light source. All rotations were two-axis rotations.</p><p>Given a CM-200 computer with 64k processors we can rotate and display a 1283 volume at arate of 3Hz and rerender with new parameters at a rate of more than 17Hz. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Summary and discussion</head><p>We have derived a multipass shear algorithm to rotate a volume in place; this algorithm maps efficiently onto a data parallel architecture. The rotation part of the algorithm is independent of the final image resolution. Hence the algorithm supports a time/fidelity (images size and resolution) tradeoff. The CM-200 implementation brings interactive performance to volume rendering tools. The major problem in using an architecture with finely distributed memory is the communication overhead associated with the transformation of the volume. Rendering itself can take very good advantage of the floating point capabil-1283 ities of the underlying hardware. While we have achieved interactive performance overall, communication still takes up a great majority of the time from adjusting the rotation angle to seeing the result on the screen. The grid communication associated with the rotation itself is already optimal in the sense that it uses the smallest number of steps and distances to achieve the resampling. The reordering step, though, still uses the general router as if it were a random communication pattern, even though it clearly has highly regular structure 3. One way to address this problem is to use the forward pointers from the last shear to evaluate the transport integral in a recursive fashion. In this algorithm every processor with Z mod 2 == 0 fetches its forward neighbor and evaluates the integral on the corresponding sub interval. At the next level every processor with Z mod 4 == 0 fetches the just-computed values from its forward neighbor two pointer-jumps away and composites them. This process continues until the final intensity is accumulated. We have not implemented this approach.</p><p>A fruitful and important direction for further research is to analyze more closely the communication patterns that occur, while rotating a volume. Given an embedding of a 3D cube into the hypercube of the physcial machine, we speculate that new rotation algorithms can be found by examining how this embedding changes under rotation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C* parallel programming constructs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.l Variables</head><p>Shapes describe the layout (rank and dimensions) of a set of virtual processors and d e h e an embedding of a kdimensional array into the 12-dimensional hypercube of the physical machine. For example, a 3-dimensional shape with extents (128, 128,64) along axes (0, 1,2) is declared as:</p><formula xml:id="formula_4">shape 11281 11281 [64lcube;</formula><p>Several different shapes can exist at the same time. Once a shape exists parallel variables can be allocated of it.</p><p>Parallel variables are declared to be of any C type (e.g., float, char, int) of a particular shape. For example This declaration reserves the appropriate number of bits in every virtual processor of the declared shape. All operations on such variables, e.g., a += b, are executed concurrently in all processors. Here we are referring at each processor to that element of vol-data whose index is 1 higher (or lower) in the 0th dimension. The stepsize can be any constant.This form of communication is very efficient since all processors can execute it in lockstep.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Communication</head><p>General communication can move data to arbitrary locations within a shape, or fiom one shape to another. It uses parallel left indices to associate an address with every element of a parallel variable. These addresses are used to send to. or pet from: These instructions invoke the general routing network and can be very costly, depending on the communication pattern and how much congestion it generates. This form of communication comes in two flavors depending on whether the expression is on the lhs or rhs of an assigment: 1. Send, which implements a many-to-one communication strategy. Conflicts are resolved in the general router with a user-specified combiner, such as, add, m a , or overwrite. 2. Get, which allows for one-to-many communication patterns. Since this form of general communication is implemented via backward routing, the cost of a get operation is roughly twice as large as that of a send operation. <ref type="figure" target="#fig_13">Figure 6</ref> was made from MRI data of a human head (original 256x256~112, filtered to 128x128~128). Data courtesy Van Wedeen, MGH, Boston. Total rendering time with rotation: 324 mS. Two isosurfaces, volume source, and lambertian shading with one light source. <ref type="figure" target="#fig_11">Figure 7</ref> was made from 3D astrophysical jet computer simulation showing minimum density (64x64~ 128). Data courtesy M. Norman and D. Clarke, NCSA at UIGC. Total rendering time with rotation 94mS. This rendering uses the combiner MAX in a direct send to the screen. <ref type="figure" target="#fig_12">Figure 8</ref> was made from simulation data of potential field around water molecule (original 40x40~40, filtered to 64x64~64). Data courtesy of Paul Bash, MIT, Boston. Total rendering time with rotation: 55 mS. Three isosurfaces, volume source, and lambertian shading with one light source. <ref type="figure" target="#fig_14">Figure 9</ref> was made from electron density data of SOD enzyme (97x97~116). Data courtesy of Duncan McRee, Scnpps Clinic, La Jolla. Total rendering time with rotation: 324 mS. Two isosurfaces, volume source, and lambertian shading with one light source.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Image credits</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Example of holes and "doubling up" when mapping rotated integer coordinates to integer pixel locations for a 7rj4 rotation about the lower left hand sample point.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>6 ) S(Z, 277) ) ( S(r7 Y7 Q) S ( Y , z, P ) S(a, Y,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Executing a Yshear byphysically moving the data from a source array to a destination array (which might be coincident). In this example the shear is cy = 419. On the left are the sample points before shearing and on the right after shearing (solid dots), while the fiactionally resampled values are indicated by stars.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>* xround( alpha x ) ; if( alpha &gt;= 0 ) { above = ( f + alpha &gt;= . 5 ) ; below = ( falpha &lt; -. 5 ) ; above = ( f + alpha &lt; -.5 ) ;below = ( falpha &gt;= . 5 ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :Figure 4 :Figure 5 :</head><label>345</label><figDesc>Left: Coordinates before the shea,: Right: Pointers to forward neighbor in E \ Left: Coordinates after a shear in Y of a = 419.These reflect the integral part while the actual values are ji-actionally interpolated using nearest neighbors as indicated in Figure 3. Right: Pointers to forward neighbors inx Left: Coordinates after a shear in Xof p = -4 f 9.Due to the previous sh$, the forward pointers in Y (which are needed for the next shear) are now considerably more complicated as seen on the right. Notice in particular that some Y forward pointers now point in the X direction in "processor space 'I.a visual representation of the movement of neighbors in a shear sequence in 2D seeFigures 3,<ref type="bibr" target="#b3">4,</ref> and 5.   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>float : cube vol-data ; int:cube a, b;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Grid communication moves a value to or from a neighbor in the declared shape. Communication uses left indexing on a parallel variable. If the left indices involve only the self address '.' and a scalar offset, the communication will be of grid type: doub1e:cube vol-data, x-gradient; x-gradient = ( [ .+1] [ .] [ . Ivol-data -[.-l][.][.]vol-data ) * . 5 ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Smith, A. R. Planar 2-Pass Texture Mapping and Wwping. Computer Graphics 21,4 (July 1987), 263-272. [21] Tanaka, A., Kameyama, M., Kazama, S., and Watanabe, 0. A Rotation Method for Raster Image Using Skew Transformations. In Proceedings IEEE Conference on Computer Esion and Pattem Recognition (June 1986), pp. 272-277. vol-data = vol-data; /* send */</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Cosmicjetsimztlution (500,000 lightveurs across).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Electron densitjs around water molecule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 6 :</head><label>6</label><figDesc>MRI data of human head.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 9 :</head><label>9</label><figDesc>Electron densih. of SOD molecule(See color plates, page 409.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : All times are given in ms</head><label>1</label><figDesc></figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">'This is not strictly true, since even on SIMD architectures load balancing is possible, although it generally involves general communication.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Special thanks are due all members of the visualization group at Thinking Machines for their helpful comments and inspiring discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Implementing Fine-grained Scientifc Algorithms on the Connection Machine Supercomputer, tr89-1 ed. Thinking Machines Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bailey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Hypercube Ray Tracer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">A</forename><surname>Teague</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Distributed Memory Computing Conference</title>
		<meeting>the 5th Distributed Memory Computing Conference</meeting>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">3-D Transformations of Images in Scanline Order</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Catmull</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">C</forename><surname>Crow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Demos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hardy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mclaughlin</surname></persName>
		</author>
		<editor>J., Stout</editor>
		<imprint>
			<date type="published" when="1980-07" />
			<publisher>IEEE</publisher>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="279" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">3D Image Synthesis on the Connection Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Scientifc Applications of the Connection Machine</title>
		<editor>D. Simon</editor>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="260" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Ray Tracing on a Connection Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Delaney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1988 ACMDNRIA Intemational Conference on Supercomputing</title>
		<meeting>the 1988 ACMDNRIA Intemational Conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="1988-07" />
			<biblScope unit="page" from="659" to="667" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">Rendering</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hypercube Algorithm for Radiosity in a Ray Tracing Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Hermitage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Huntsberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Distnbuted Memoly Computing Conference</title>
		<editor>D. W. Walker and Q. F. Stout</editor>
		<meeting>the 5th Distnbuted Memoly Computing Conference</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990-11" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="206" to="227" />
		</imprint>
	</monogr>
	<note>Three-Pass Affine Transforms for</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interactivity is the Key</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Santek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CH Volume Esualization Workshop</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989-05" />
			<biblScope unit="page" from="39" to="43" />
		</imprint>
	</monogr>
	<note>ACM Siggraph</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Connection Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Hillis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Volume Rendering and Data Feature Enhancement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Krueger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="21" to="26" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="271" />
			<date type="published" when="1990-07" />
		</imprint>
	</monogr>
	<note>DataACM Transactions on Graphics</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Fast Algorithm for General Raster Rotation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Paeth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Graphics Interface</title>
		<meeting>Graphics Interface</meeting>
		<imprint>
			<date type="published" when="1986-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fast Rotation of Volume Data on Data Parallel Architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">; P</forename><surname>Sabella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Salem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<date type="published" when="1991-08" />
			<publisher>Thinking Machines Corporation</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. TMC-195</note>
	<note>A Rendering Algorithm for Visualizating 3D Scalar Fields</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Animation of interactive Fluid Flow Visualization Tools op a Data Parallel Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Salem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Intemational Joumal of Supercomputer Applications</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="10" to="39" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Particle Animation and Rendering Using Data Parallel Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="65" to="74" />
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Thinking Machines Corportation. C* Programming Guide</title>
		<imprint>
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
	<note>version 6.0 ed.</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keeler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>V-Buffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Visible</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Rendering. Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Interactive Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CH Volume Visualization Workshop</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1988" />
			<biblScope unit="page" from="59" to="64" />
		</imprint>
	</monogr>
	<note>ACM Siggraph</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
