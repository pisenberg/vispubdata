<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Image Handling in a Multi-vendor Environment</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">R</forename><surname>Nadeau</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Todd</forename><surname>Elvins</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Bailey</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Thomas</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">San Diego Supercomputer Center Advanced Scientific Visualization Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<postCode>1988</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department</orgName>
								<orgName type="institution">University of Utah</orgName>
								<address>
									<addrLine>November 1986. Upstill, S., The RenderMan Companion, Addison-Wesley Publishing Company</addrLine>
									<postCode>1990</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Image Handling in a Multi-vendor Environment</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Wavefront&apos;s</keywords>
			</textClass>
			<abstract>
				<p>In an ideal world every hardware and software vendor stores the same type of data in the same file format. Software packages transparently exchange their data and results. Diferent vendor&apos;s hardware plalforms read and write each other&apos;sfiles without a hitch. And the skies are not cloudy all day. This paper discusses software developed by the San Diego Supercomputer Center (SDSC) to deal with the real world of differing image file formats, mismatched byte orders and word sizes, and confusing hardcopy device interfaces.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>No software package or hardware platform is an island unto itself. A typical visualization task may require data filtering on one machine, rendering on another, image touch-up and compositing on another, and hardcopy and video device control from still another. Software to do these comes from many sources, including O/S-bundled packages, third-party packages, the Internet, and locally written code. It is a rare day when the output of one package is exactly correct as input into another.</p><p>In order to optimize load and store operations and best support custom features, most software packages invent their own custom file format for the storage of image data. As the market for imaging software grows, so grows the number of custom file formats. Software interconnectivity has become a serious issue in today's multivendor environments.</p><p>Few would disagree that a file format standard to support software interconnectivity is desirable. Efforts in that direction have included formats like HDF <ref type="bibr">[13,</ref><ref type="bibr">14]</ref> and NetCDF <ref type="bibr">[18]</ref>. Roadblocks slowing the widespread adoption of file format standards include issues of support for new vendor-specific features, portability to future hardware platforms, and migration paths for users with large data sets maintained in older vendor-specific file formats. So, while progress is being made on data format standards, the real world continues to require the use of many vendor-specific formats.</p><p>In a recent informal network survey about image file formats, 108 persons responded with a list of 99 file formats they commonly use. This characterizes the situation faced by today's visualization professionals. With a glut of image file formats, and a lack of portable, stable format rranslators, statements like you can't get there from here are all too frequent.</p><p>Dealing with images should be a simple task, rather than the time-consuming job it currently is. What is needed is a unified view of image storage and manipulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Breaking down the problem</head><p>The use for images in visualization is obvious. Various renderers, scanners, and graphics libraries make them, and various hardcopy devices print them. In between those two extremes, we manipulate and s t o~ them.</p><p>Because we make mistakes or need the seMces of multiple tools to make a single image, we often touch-up, paint over, scale, rotate, translate, recolor, cut, paste, and composite them.</p><p>A simple breakdown of necessary image handling functionality includes:</p><p>1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>Read an image from a file into memory Manipulate the image while in memory Write the image from memory to a file Write the image from memory to a device</p><p>In the spirit of UNIX which treats devices and files the same, it would be nice if items 3 and 4 were the same. The real world of controlling hardcopy devices is not so clean. Hardcopy device drivers must wony about running out of paper, selecting film recorder resolution, tweaking internal color tables, prerolling videotape, and running out of device memory. When handling images, files and devices must be treated seperately.</p><p>A key feature of all four of the above items is "memory." Item 1 reads the image file into memory.</p><p>Item 2 manipulates it while it's there. Items 3 and 4 write the image in memory out to a file or device. In fact, an image handling toolset may be defined in tenns of an image storage data structure, and the operations that may be performed upon it. This is the approach taken by the SDSC Image Tool suite. A VFB describes an image as a rectangular array of pixels with one or more values stored per pixel. To support a range of pixel data, each VFB pixel may contain several data items, including RGB triplets, color indices, monochrome bit values, Zbuffw floating-point depths, write-protect planes, alpha planes, and arbitrary integer and floating-point values. A single VFB may have as many, or as few, of these values per pixel as the occasion demands.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Virtual k a m e Buffer</head><p>A VFB also may have a Color Lookup <ref type="table">Table (CLT)</ref>.</p><p>As with traditional frame bufk hardware, a CLT is used to map VFB color indices to RGB triplets.</p><p>What dibntiates a VFB from graphics hardware frame b u h is that a VFB requires no graphics hardware. The VFB image structure is simple, portable, has an arbitrary width and height, and can store a variety of values pet pixel. The use of the VFB structure enhances modularity and permits functions to focus on the image handling task rarher than the peculiarities of a particular file format or piece of hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Elements of an image file</head><p>Beside the image. most file formats also store information such as the CLT, the image creator's name, the name of the software package that rendered it, the size and position of the window in which to display it, the background color, the frame number, the gamma correction factor, the date of creation, the version number of the file format, and so on. In file formats that support multiple images per file, this information may or may not be repeated for each image.</p><p>Many file formats deal with host byte order, word size, and floating-point format differences by including flags in the file's header that indicate the machine attributes used by the file's data. In other file formats, byte order, word size, and floating-point format selections are defined by the format as having specific machine attributes. In either case it is up to the reading and writing software to map between the file's attributes and those of the current host.</p><p>Most image file formats reduce the amount of disk space required to store an image by applying a compression scheme to the pixel data. Such compression schemes take advantage of pixel-to-pixel coherence. For example, a "run" of adjacent pixels all of the same color can be reduced to a run "length" and a single color "run" value. In this way large areas of the same color can be reduced to a few short "run codes," and the overall storage requirements for the image significantly reduced (usually around 309b). This type of "Run-Length Encoding" (RLE) image compression is used in most image file formats, though the actual implementation usually differs in minor ways from format to format. Because image files contain more than just the pixel values of the image, the task of reading, writing, and modifying image file data cannot constrain itself to pixels alone. Gamma correction factors, image titles, and so on must continue to be associated with the image after it has been read into memory. The VFB image storage data structure is only part of the solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Tagtable</head><p>Hardcoding a data structure for the storage of each of the many different data items found in image files would limit the extensibility of an image file handling tool set. What is needed is a general purpose extensible data structure capable of holding any type of data that might be found in an image file. To handle this situation, the SDSC Image Tool suite defines an abstract data type called a tag table.</p><p>A tag table is a threaded hash table of tag-value pairs. Data read in from an image file is entered into the tag table by hashing on a character string tag that labels the associated value. 'Qpical tags include "image name," "image gamma," "image clt," and "image vfb."</p><p>The hash table nature of a tag In both of these routines, the format of the image file to be read or written is indicated by a f o r m character string argument, with values such as "tir or "hdf". The addition of a new file format into the Image Tool suite makes another format name character string available, but does not add a new programmer-level call interface.</p><p>The use of file pointers rather than a filename allows the calling program to open the connection to the image storage stream in any way it sees fit. Files, stdin, stdout, and pipes are handled identically within a single call interface.</p><p>Thej?ugsTabfe argument to both routines is a tag Such optional directives instruct the write routines to output a particular variant of the selected file format. For instance, Sun Rasterfiles can store image pixels uncompresed ("standard") or RLECompred ("byteencoded"). If the type of stomge is not specified. the SDSC Image Tool suite selects the compressed vaxknt. Overriding this default is controlled by directives in the JagsTable.</p><p>By structuring the SDSC Image Tool suite call interface to channel all format read and write operations through a simple generic call interface, higher-level tool code can treat image files generically. An HDF file can be read and written by using the format name "hdf." Changing that name to "gif' or "ras" or "pix" is all that is necessary to switch to a different file format. If the format selection is provided by he user via a command-line argument, the tool need never care what exact image file format is being read or written.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Byte order and word sizes</head><p>Image Tool suite file format handlers are responsible for reading in or writing out file format-specific data. In order to be portable between different hardware platforms, such file I D routines must handle differences in machine byte order, word size, and floating-point format.</p><p>The SDSC Image Tool suite isolates such conversion code within a separate portable Binary ID Library.</p><p>The SDSC Portable Binary r/o library defines routines that mimic the functionality of UNIX read() and write() system calls, but with additional arguments. As an example, to portably read an integer from a binary file, the following pieces of information must be known: 1. Thestream toread from 2. 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>The variable into which to read the data The declared type of the variable being filled The no. of bytes the item occupies in the file 5. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.</head><p>The no. of bytes the item occupies on the host The byte order of the item in the file The byte order of the item on the host A UNIX r e d ( ) system call's arguments only specib items 1,2, and 4. The size and byte order of the integer in the file is assumed to be the same as that on the host This is not portable and makes it impossible, for instance, to read a DEC VAX binary file on a Sun SPARCstation without special byte-swapping post-processing.</p><p>If the file's integer is smaller than the host's integer (reading a 32-bit integer into a 64-bit Cray integer, for instance), then the upper bits of the host integer must be filled with something. If the host integer is declared as signed, the integer must be sign-extended (fill with 1's if the highest file integer bit is a 1). If the host integer is declared as unsigned, the integer must be padded with zeroes. Information on the type of the host integer and the size of the file and host integers is provided by items 3.4, and 5 above.</p><p>If the byte order of the integer in the file is different from that of the hosf then byte swapping must take place. This is indicated by items 6 and 7 above. Because the characteristics of the host do not change during execution, the host byte order indicated by item 7 can be determined once and is not required as an argument to every read operation. Similarly, the byte order of a binary file (item 6) is usually the same throughout the file and so does not need to be respecified on each read. The remaining five items, however, can change from read to read and must remain as call arguments.</p><p>When reading and writing floating-point values, differences in floating-point format must be handled.</p><p>Formats such as the IEEE standards, DEC's VAX formats, and Cray's formats differ in the number of bytes used, the order and meaning of those bytes, the number of bits used for the exponent and mantissa, the value used for the exponent bias, and the treatment of the implied </p><formula xml:id="formula_0">upper '1' bit</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Image conversion from a single tool</head><p>Some existing packages for image file format wnvefsion develop a custom tool for each format conversion.</p><p>To go from HDF to TIFF, use "hdftoti&amp;" To go from TIFF back to HDF, use "tifftohdf." To go from RLA to PIX, use "rlatopix," and so on. If n is the number of file formats supported. then this approach creates <ref type="figure">n * (n -1)</ref> separate command-line tools. If the net survey that listed 99 difkent file formats is to be believed, then a complete Writing a tool to read and write any image file format supported by the SDSC library is straightforward. The tool must parse a command-line to get input and output file names and fonnat names, open the two files. then make a call each to ImFileFReadO and ImFileFWriteO.</p><p>For ImFileFReadO, the caller passes a pointer to the input file and the name of that file's format. Data is read into the tag table and the call returns. returns, the output file has been written.</p><p>The following C program implements this simple file format conversion tool:  As new formats are added to the SDSC library, ImFileFReadf) and ImFileFWrite() recognize additional formal names. Updating the tool to a new SDSC library release and its additional format support is a matter of relinking.</p><p>With a single tool, image file format conversion between multiple formats becomes much simpler. Rather than remembering 9702 tool names and options, all a user need do is leam a single tool's features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Image type conversion</head><p>Within the SDSC Image Tool suite, an image's "type" indicates the type of data stored for each pixel. Common types include RGB mplets, color indices, grayscale values, or monochrome values. Additionally images may have an alpha plane, 2-buffer, write-protect plane, arbitrary integer, or floating-point values per pixel, and so on. Some image file formats support all of these image types, but most only support a subset. When an output file format does not support the to-be-written image's type, type conversion to one it does support is necessary.</p><p>Image type "promotion" is the advancement of an image depth from a small amount of information per pixel, to a larger amount of information per pixel. Monochrome images may be promoted to grayscale, grayscale images to color index images, and color index images to RGB images. Image type "demotion" is the reduction of per-pixel information and travels in the opposite direction.</p><p>The SDSC Image Tool suite provides automatic type conversion, when necessary. For example, a color index image with a CLT is passed to ImFileFWriteO to be written as an AVS X file. However, AVS X files only support RGB typed images. ImFileFWriteO automatically promotes the color index image to RGB, then writes the file.</p><p>ImFileFWriteO may also automatically demote an image. For example, an RGB image is passed to fmFileFWrite() for output to a GIF image file. However, GIF only supports color index images. ImFileFWrite() automatically demotes the image from RGB to color index, doing its best to build a good color table.</p><p>When an output format supports a variety of possible image types, automatic type promotion and demotion favors the least change to the original data, and the least infonnation loss. 8-bit color index images will be p moted to 12-. 16, U-, or 32-bit (or in between) color index images in prefemce to going to RGB and loosing the indexed nature of the image. Likewise, RGB images will demote only as far as necessary to make them match a type supported in the output file format. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Image manipulation</head><p>In a typical visualization, images rendered with one package often have to be combined with images generated by another. For example. a logo has to be composited into the lower left corner of every animation frame. A color scale bar or title has to be positioned and pasted in. Animated foregrounds have to be overlaid atop static backgrounds. Images have to be reduced and composited, storyboard-fashion, for multi-variable correlation shots. Colors have to be desaturated before being shot to video. Color tables have to be cycled. And so on. A visualization is not complete just because the raw images have been rendered.</p><p>Once an image has been read into VFB and tag table data structures, it can be manipulated by a suite of image routines. Such routines take as input a VFB and relevant arguments, and return to the caller a modified VFB.</p><p>Some existing packages for image manipulation embed manipulation algorithms within the body of each tool. If a tool doesn't meet one's exact needs as is, then the source is copied and edited to create a new tool. If the original tool had a bug, chances are good that the new tool has it as well. The result is that multiple copies of the same source propagate throughout the network, with the bugs tagging along. Updating all the spawned tools with a newer, bug-free algorithm becomes difficult.</p><p>Such code is better maintained as part of a standard library. Tools invoke library routines to do the image work. New tools can be written quickly to tailor functionality to the situation without cut-and-paste editing of the image manipulation algorithms.</p><p>While this is the purpose of libraries and the reason for such standard libraries as libc and libm, this is not yet the common approach used when dealing with image manipulation. The SDSC Image Tool suite encapsulates all image manipulation functionality into a single library rather than distributing it about in the individual tools. This makes programming new special-purpose tools quick and easy.</p><p>Because no library can anticipate every need, the VFB and Tag <ref type="table">Table data</ref> structures are available to the library user. Pixels and CLTs can be changed outside of library routines. Such extemal manipulation of VFB and CLT data structures is an essential feature needed for the development of renderers and custom image manipulation tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Hardcopy problem</head><p>Hardcopy has traditionally been a term associated only with paper printouts. In the evolving world of visualization it has come to encompass any form of walkaway-with-it media, such as 35" slides, polaroids, 16" movies, holograms, videodiscs and videotapes.</p><p>Hardcopy device control usually requires custom code to deal with the features of a device's communications protocol. SCSI device drivers, RS232 protocol parsers, and so on are required. With these custom drivers comes custom tools to send data to them. Like the n * (n -I )</p><p>image translator tool situation, hardcopy device control can involve a plethora of tools and interfaces for the user to leam. The hardcopy control problem can also spill over into the image file format confusion by creating hardcopy device-specific file formats that embed control protocol in the file. In a world with 99 (and likely more) different image file formats in common use, the last thing the world needs is another image file format for every hardcopy device.</p><p>What is needed is a uniform and user friendly way of sending images to hardcopy devices. This is the approach taken by the SDSC Visualization Printing suite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.">Visualization printing</head><p>From the point of view of the user, image hardcopy output must be easy to use, and network transparent.</p><p>If the system is not easy to use, people won't use it.</p><p>Instead they will kludge, avoid, or underutilize the sys-tem. The user must be allowed to concentrate on their science and view the production of hardcopy as simply an add-on that requires little thollght to accomplkh. The first command above sends the file ima8e.W to the print queue named slides. The second command sends 2 copies of the file do1phin.pix to the print queue named polaroid. The third command shoots an animation described by the visualization metafile (a kind of script) aroimatwn.vm to the print queue named video-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>tw-</head><p>The arguments to vpr should look familiar. They are identical to the standard UNIX line printer queuing utility lpr. vpr is, in fact, built atop lpr in order to leverage off of the robust and network transparent features already standard in UNIX. This makes vpr easy to port around the network. A workstation can be made to send image files to the visualization printer queues by simply installing a few additional queues in the standard system file letclprintcap.</p><p>Like lpr, the user submits to vpr one or more image files to be printed, and the name of the queue to which to print them. The image file format is intuited from file magic numbers and/or file name extensions. The user is not required to 6rst convert their image to a devicespecific custom image file format. vpr supports any of the image file formats recognized by the underlying SDSC Image Tool suite.</p><p>Within vpr, the user's images are recognized and sent to a holding area (a shared network spool directory for images). A smaller, text-only, visualization metafile (script) is queued to the remote printer host via lpr.</p><p>On the remote printer host, the visualization metafile is "printed" by the UNIX fpr daemon, lprd, by invoking a print filter for the device. The filter reads in the metafile, and retrieves the user's images, one at a time, from the holding area. The image files are read-in using ImFileFReadO and processed to expand or shrink the image to match the resolution of the output device. Additional image manipulation operations, such as cropping, rotation, and lightness adjustments, may take place as requested by user flags in the metafile. With the processed image complete and waiting in a VFB, the printer filter sets up the output device, then transmits the image using whatever device driver and device protocol is necessary.</p><p>When the image has been printed, the filter moves on to the next image listed in the metafile. When the metafile is complete, the holding area images are removed and the user is notified.</p><p>Like </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="13.">Network resources</head><p>It is common to view hardcopy devices as network resources. What is less common is to view compute engines in the same light. When a compute-intensive task needs to be handled, it makes sense to use the fastest computer available. When a user-interface task needs to be handled, it makes sense to use a graphics workstation. This distributed view of task handling means that a site's compute resources include all those available to it over the network.</p><p>NetV is an experimental network-based volume vkualization system under development at SDSC [91. Volume visualization tasks are submitted for processing on one or more network compute engines, such as SDSC's Alliant FX/2800, Cray Y-MP, nCUBE, and Intel IPSC860 systems. By distributing such computeintensive tasks to machines better able to handle them, the user gets faster rendering throughput and is able to interact to a greater degree with volume data.</p><p>Rather than contribute to the glut of custom image file formats, the NetV project uses the SDSC Image Tool suite to output rendered volume images in any supported image file format. The embedded volume rendem renders the image into a VFB, then writes it out using ImFileFWrire(). The user that submitted the job can select the format to use.</p><p>This tactic of supporting a range of 6le formats rather than a single custom format allows tools to address a wider user base. Tools become more general and better integrated into the work environment of the user. The simplicity of ImFileFWntd) makes the addition of multiple file format storage a relatively easy enhancement to existing tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="14.">Summary and Conclusions</head><p>The SDSC Image Tool suite adbesses a software interconnectivity problem plaguing the visualization industry. By providing a simple, extensible, and portable mechanism for the support of a variety of common image file formats, tool-writers are able to concentrate on the task at hand, rather than the quirks of aparticular image file format. Users of such tools are able to work with images generated from a variety of sources, without being restricted to an arbitrary standatd format.</p><p>The SDSC Visualization Printing suite creates a unified view of hardcopy devices. Through internal use of the SDSC Image Tool suite, users of the VisualizatiOa Printing suite are able to submit images in any of a variety of image file formats. By building atop the standard UNIX lpr mechanism, the suite leverages off of existing robust and network transparent mechanisms. By isolating hardcopy device-specific code within underlying print filters, users can avoid dealing with the quirks of a particular hardcopy device.</p><p>The SDSC Image Tool and Visualization Printing suites are a portable, extensible, well-integrated approach to handling images in a multi-vendor environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="15.">Future directions</head><p>SDSC Image Tool functionality can be enhanced in several directions. Additional file format handlers can, and should, be written. Further image manipulation routines are needed. The modular approach of the system allows these additions to be made without impacting </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>solution to the current situation would require 99 * (99 -I ) = 9702 separate image conversion tools! The SDSC Image Tool suite instead encapsulates format-specific code into format handlers invoked through the generic ImFileFRead() and ImFileFWnte() call interfaces discussed earlier. The number of format handlers written i s just (2 * n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>*</head><label></label><figDesc># i n c l u d e &lt; s t d i o . h&gt; # i n c l u d e "im. h" /* Arg 1: i n p u t f i l e format name * Arg 2: i n p u t f i l e name * Arg 3: o u t p u t f i l e format name * Arg 4 : o u t p u t f i l e name */ main( a r g c , a r g v ) a T a b l e = TagTableAlloc ( ) ; inFp = f o p e n ( a r g v [ 2 ] , "r" );</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>VFB) is the image storage data structure found at the core of the SDSC Image Tool suite. The VFB design mimics, in software. the hardware frame bufk designs common in today's graphics hardware.</figDesc><table /><note>A Virtual Erame B &amp;(</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>table allows access to the table's contents by tag name, such as get me all the "image vfbs" in the tag table. l'his lets tools query a tag table for tags relevant to the tool, and ignore all the rest. For instance, a tool can process all the CLTs in a tag table and ignore tags for image VFBs, image names, frame numbers, author names, and so on. The threading of hash table entries allows the entries to be accessed in the order in which file data was entered into the table. This facilitates queries such as get me the next "image vj3" in the tag table. Threaded access is necessary when file data must be processed in a particular order.13,14] and TIFF [21. 6. Image file VO</head><label></label><figDesc>For instance, in multi-image animation files, the order of images in the file is the same as the order of frames in the animation. Shooting such a file of images to movie film, videodisc, or videotape requires processing the tag table's file information in first-to-last o r b .Within the SDSC Image Tool suite, the tag table data structure is the central in-memory storage structure for image file data. As such it mimics in memory the approach taken by several existing file formats, including HDF [image file formats have different header arrangements and sizes, and store their images with slightly diffkrent compression schemes. This tends to require custom handlers for each. image file format encountered. To date, the SDSC Image Tool suite supports the following image file formats: GIF 181, HDF</figDesc><table><row><cell>Different )</cell><cell></cell></row><row><cell>FILE</cell><cell>*fp;</cell></row><row><cell>char</cell><cell>*format;</cell></row><row><cell>TagTable</cell><cell>*flagsTable;</cell></row><row><cell>TagTable</cell><cell>*dataTable;</cell></row><row><cell cols="2">int ImFileE'Write( fp, format, flagsTable,</cell></row><row><cell>dataTable )</cell><cell></cell></row><row><cell>FILE</cell><cell>*fp;</cell></row><row><cell>char</cell><cell>*format;</cell></row><row><cell>TagTable</cell><cell>*f lagsTable;</cell></row><row><cell>TagTable</cell><cell>*dataTable;</cell></row></table><note>[13,14], IFF [23], MacPaint [7], PBM (PBM, PGM, PPM) [171, PIC [15.16], PICT 171, PIX [3], PostScript 111, RAS 1241, RGB 1201, RLA/RLB 128.291, RLE [251, SYNU[19], TIFF [2], AVS X [22], XBM [lo], and XWD[ 1 1,121. If each additional file format supported also added a new programmer-level call interface to be learned, the task of dealing with a large number of common file for- mats would become unwieldy. In order to unify things and obscure the quirky details of individual file formats, the SDSC Image Tool suite defines generic "file read and "file write" programmer call interfaces. These top level VO routines provide a single interface to the programmer, and intemally handle some of the common denominators in reading and writing differing image file formats. These routines act as portals into the lower-level format-specific handler code of the tool suite. These generic file VO C programming language rou- tines are declared as follows:int ImFileFRead ( fp, format, flagsTable, dataTableImFileFRead() reads file data from a supplied file pointer fp, storing incoming data into the dataTbble tag table. ImFileFWrite() writes file data from the datalbble out to the file pointer fp. An alternate call interface that uses file descriptors instead of file pointers is also avail- able.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>table .</head><label>.</label><figDesc>While data flows into and out of he dataTable, the &amp;$Table is instead used to store format VO directives.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>By encapsulating byte order. word size, and floatingpoint handling within a general-purpose portable binary VO library, upper-level image handling code is made considerably simpler and more portable. To date the SDSC Image Tool suite and its Binary I/o Library have been ported to the following architectures: Alliant FX/80, DECstation, nCUBE, NeXT, Silicon Graphics 4D, Stardent GS1000, Sun 3, and Sun 4. With all machine dependencies isolated within the Binary VO Library, porting the SDSC Image Tool suite to a new architecture has been simply a matter of compilation.</figDesc><table /><note>in a normalized mantissa. As with integers, the SDSC Binary U 0 Library automatically handles map- ping to and from the host and file's floating-point formats within the same simple read and write calls.Alliant nV2800, Cray Y-MP, DEC VAX,</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>this tool might be: convert tiff myfile.tiff hdf newfile.hdf</head><label></label><figDesc>The SDSC Image Tool suite implements its image conversion tool imconv in a similar fashion. While imconv incorporates error checking and a variety of additional features, the base code is essentially what is shown.</figDesc><table><row><cell>ImE'ileFRead ( inFp, a r g v [ 1 1 , NULL,</cell></row><row><cell>d a t a T a b l e ) ;</cell></row></table><note>outFp -fopen ( argv[ 4 1 , "U" ) : ImF'ileE'Write ( outfp, argv [3] , NULL, dataTable) :1 A sample execution of</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>'</head><label></label><figDesc>Ihe uset can override automatic type conversion operations to obtain specific output file variants. For example, an RGB image may be specifically converted to an 8-bit color index image and stored within a Sun Rasterfile, even though Sun Rasterfiles support the storage of RGB typed images. This is handy when RGB images are to be previewed on non-RGB framebufferS.</figDesc><table /><note>These type conversion control directives are passed to the type converter through the j?agsTable argument to IntFileF Write(). If no flags are given, IrnFileF Write() makes its own best guess at how to convert the image if needed.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Network transparency allows hardcopy to be submitted from any host on a site's network. As with UNIX line printers, hardcopy devices look like they exist on the user's machine. Users m not forced to transfer their files to a special machine in order to get hardcopy. In fact, the user need not have any knowledge of where the devices really are, or even exactly w h they really are. Users view the hardcopy facility as being identical and equal on all systems.</figDesc><table><row><cell>The SDSC Visualization Printing suite is accessed</cell></row><row><cell>through the single command vpr (for Visualization</cell></row><row><cell>PRint). For example:</cell></row><row><cell>vpr +slides image.hdf</cell></row><row><cell>vpr +polaroid -#2 dolphin .pix</cell></row></table><note>vpr -Pvideotape animation.vm</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>other SDSC Image Tool suite tools, vpr and the underlying device print filters utilize generic image manipulation functions provided by the SDSC Image Tool suite. This reduces the size of print filter code and speeds the development of new filters. To date SDSC</figDesc><table><row><cell>has print filters for its Management Graphics Solitaire8</cell></row><row><cell>digital film recorder (slides, 4 x 5~~ polaroids, 16-mm</cell></row><row><cell>movies), and its Canon U -5 0 0 color paper pMter.</cell></row><row><cell>Print filters to drive SDSC's Sony LVR-5ooO videodisc</cell></row><row><cell>player/recorder and Lyon-Lamb MiniVas videotape deck</cell></row><row><cell>player/recorder controller are under development.</cell></row><row><cell>Implementing vpr atop the standard UNIX lpr</cell></row><row><cell>mechanism avoids reinventing the wheel, allows the</cell></row><row><cell>SDSC Visualization Printing suite to leverage off of</cell></row><row><cell>existing proven tools, and maintains a user interface</cell></row></table><note>consistent with existing standards. Using the lpr mechanism also provides systems managers with stan- dard tools to start and stop queues, and change the order of jobs waiting to be printed.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>existing features, The multi-format chaos typical of image handling also occurs when dealing with scene description (geometry) files. 2D geometry files like ANSI CGM [4], Postscript [l], and Apple's PICT [7], and 3D scene files like Wavefront's OBJ [27], Alias' WIRE and SDL [31, RenderMan's RIB [16]. Stardent's DORE [211. ANSI PHIGS [6] and IGES [5]. and many others, require a translation solution as well. The problem is made more complex by the variety of approaches to storing scene descriptions. Issues include how shading models are defined, how textures are mapped, how algorithmic textures are supported, how spotlights are described. how reflection and refraction attributes are defined. and so on. A general approach for scene description similar to the SDSC Image Tool suite is needed.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The SDSC Image Tool suite and Visualization Print- This work has been s u p p o d through major funding from the National Science Foundation and the State of Califomia. The opinions, conclusions, or recommendations expressed herein ate those of the authors and do not necessarily reflect the views of SDSC, General Atomics, or their sponsors.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Adobe Systems, PostScript Language Reference Manual</title>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Tag Image File Format</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aldus</forename><surname>Corp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Microsoft</forename><surname>Corp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988-08-08" />
		</imprint>
	</monogr>
	<note>revision 5.0</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Alias Programming Manual</title>
		<idno>ver- sion 3.0</idno>
	</analytic>
	<monogr>
		<title level="j">Alias Research</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Computer Graphics Metafile (CGM) for the Storage and Transfer of Picture Description Information</title>
		<imprint/>
		<respStmt>
			<orgName>American National Standards Institute</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Programmer&apos;s Hierarchical Interactive Graphics System (PHIGS)</title>
	</analytic>
	<monogr>
		<title level="m">ANSI X3</title>
		<imprint>
			<biblScope unit="page" from="144" to="1988" />
		</imprint>
		<respStmt>
			<orgName>American National Standards Institute</orgName>
		</respStmt>
	</monogr>
	<note>Initial Graphics Exchange Specification (ICES)</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Apple Computer, Inside Macintosh, volumes I through V</title>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">GIF Graphics Interchange Formar A standard defining a mechanism for the storage and transmission of raster-based graphics information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Compuserve</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-06-15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">NetV: An Experimental Network-based Volume Visualization System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T</forename><surname>Elvins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Nadeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second IEEE CoMer-ANSI X3</title>
		<meeting>the Second IEEE CoMer-ANSI X3</meeting>
		<imprint>
			<biblScope unit="page" from="122" to="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-~</forename><surname>~_ _ ~ Ence On Visualization</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">bitmap&quot; manual pages, X Window System distribution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mit X Window</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>System</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>release 4</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">X Window System distribution, version ll</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mit X Window</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>System</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
	<note>Xlib -C Language X Interface</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">xwd&quot; and &quot;xwud&quot; manual pages, X Window System distribution, version 11, release 4. National Center for Supercomputing Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mit X Window</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>System</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NCSA HDF Specifications</title>
		<imprint>
			<date type="published" when="1988-12" />
			<publisher>PIXAR</publisher>
		</imprint>
	</monogr>
	<note>NCSA HDF. version 3.0. Image Computer Programmer&apos;s Manual, release 2.2</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">RenderMan Interface</title>
		<imprint>
			<date type="published" when="1989-09" />
		</imprint>
	</monogr>
	<note>version 3.1</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Poskanzer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-02" />
		</imprint>
	</monogr>
	<note>pgm,&quot; and &quot;ppm&quot; manual pages, PBMPLUS distribution</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">s Guide: An Interface for Data Access, version 1.06</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Rew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>User</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Silicon Graphics, undocumented image file format described by comments and code in &quot;4Dgifts&quot; source distributed by Silicon Graphics. Stardent Computer, DORE Programmer&apos;s Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">San Diego Supercomputer</forename><surname>Center</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synu Reference Manual, SDSC Technical Report</title>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Image File Format -.x</title>
		<imprint/>
	</monogr>
	<note>Stardent Computer</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">AVS File Formats</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Appendix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stardent Application Visualization SystemlUser&apos;s Guide</title>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
