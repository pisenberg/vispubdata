<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Combing the Communication Hairball: Visualizing Parallel Execution Traces using Logical Time</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Peer-Timo</roleName><forename type="first">Katherine</forename><forename type="middle">E</forename><surname>Isaacs</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilir</forename><surname>Bremer</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd</forename><surname>Jusufi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhinav</forename><surname>Gamblin</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Bhatele</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Schulz</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hamann</surname></persName>
						</author>
						<title level="a" type="main">Combing the Communication Hairball: Visualizing Parallel Execution Traces using Logical Time</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/TVCG.2014.2346456</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:12+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Information visualization</term>
					<term>software visualization</term>
					<term>timelines</term>
					<term>traces</term>
					<term>performance analysis</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1: Logical timeline and clustered logical timeline views from Ravel, a tool for visualizing parallel execution traces. Events are represented by boxes, colored by their wall-clock delay. The use of logical time reveals communication patterns and leverages developers&apos; understanding of their program&apos;s structure. We use the logical time structure to cluster on any metric, which allow us to represent large-scale traces using explorable clusters while still depicting messages with full timelines for a subset of processes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Large-scale simulations increasingly form the backbone of a wide variety of science and technology fields <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b1">2]</ref>. These parallel applications can utilize hundreds of thousands of processors across tens of thousands of nodes. Understanding, let alone optimizing, the behavior of a massively parallel simulation code is a significant and largely unsolved challenge <ref type="bibr" target="#b11">[12]</ref>. At the same time, high-end simulations monopolize supercomputers for days or weeks, so even minor runtime improvements translate into significant energy and cost savings, in-</p><p>• Katherine E. <ref type="bibr">Isaacs</ref> creased throughput, and more science per time. One common approach to gain more insight into the behavior of a code is tracing, which logs events of interest during program execution, providing a detailed history for later analysis. The data can include function invocations for each process, interactions between processes, hardware counter states, or file operations. Even when recording only a subset of events or selected parts of the code, a trace of a moderately sized run may contain gigabytes or terabytes of data. In addition to the sheer scale, traces can be highly complex, making automatic analysis challenging. While there exist solutions to some problems, like identifying the critical execution path <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b6">7]</ref>, in many cases the root causes of performance problems are more subtle than, for example, a single late process. Moreover, fully automatic techniques have been of limited use. Instead, application developers and performance experts have turned to visualization in hopes of identifying patterns and forming new hypotheses to be tested.</p><p>Currently, the visual analysis of trace data tends to one of two extremes: on one end, visualizations used in practice attempt to show all of the data with little or no preprocessing <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b33">33]</ref>, which makes the visualization difficult to comprehend even at modest pro- cess counts. At the other end of the spectrum are summary statistical graphs and analysis techniques, which heavily compress or process the data. While some analysis techniques focus exclusively on highlevel structure <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b15">16]</ref>, others identify problematic behavior locally <ref type="bibr" target="#b43">[43]</ref>, but discard the context necessary to discover initial causes or longer term effects. What is missing are visualization techniques that provide productive analysis that is abstract enough to handle large process counts but detailed enough to provide new insight.</p><p>Given the goals of performance experts -understand and optimize the behavior of codes -and the state of the existing trace analysis tools, we have identified three design goals for an improved trace visualization. A visualization must:</p><p>G1 Preserve and highlight event patterns and dependencies. Most applications will exhibit regular patterns in their traces caused by their iterative nature. Detecting these patterns is key to any performance analysis. A visualization must clearly show such patterns. For communication specifically, we must avoid the indecipherable tangle of lines common in current tools.</p><p>G2 Be effective for large numbers of processes. Many performance problems only manifest at large process counts, so the visualization must scale to be useful.</p><p>G3 Provide multiple levels of detail and abstraction. Analysts need overviews when little is known about a problem, and the ability to explore in more detail when necessary.</p><p>To meet these goals, we decided to visualize a trace in logical time inferred from the happened-before dependencies between events. This differs from physical time, which existing tools use, and has two main advantages: First, logical time, by construction, corresponds more closely to the code structure, with which a user is intimately familiar, resulting in a more intuitive visual encoding. Second, the discrete nature of logical time allows us to cluster and thus summarize chains of events across processes leading to a scalable, multi-resolution representation. We combine these two properties in Ravel, a new visualization tool for parallel execution traces. Ravel provides multiple linked and coordinated views of large-scale traces at different levels of abstraction. Unlike existing tools, our primary axis is logical time with other metrics that reflect physical time based properties, such as lateness, encoded using color maps. This allows developers to easily detect differences in structure between processes or different versions of the code as well as to understand differences in, for example, timing when comparing similar structures. In summary our contributions are: 1. A logical, rather than physical, parallel interactive timeline visualization that still captures physical timing data. 2. A distance metric for clustering logical timelines based on physical time behavior. 3. Ravel, a visualization tool for parallel execution traces using multiple coordinated views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND AND RELATED WORK</head><p>Modern supercomputers are composed of a network of nodes, where each node has compute cores and local memory. Large-scale parallel applications divide computational work among individual processes by assigning a piece of the overall work to each core. This is called domain decomposition. For the computation to proceed, processes typically must exchange data. A common model is to send messages between processes. The Message Passing Interface (MPI) <ref type="bibr" target="#b35">[35]</ref> is the most widely used standard for this kind of programming model in high performance computing. Under MPI, developers explicitly call routines for sending and receiving messages between processes. Each process is assigned a unique ID for addressing messages and to determine what part of the larger problem to compute. While we focus on applications using MPI here, our approach is general enough that it could be applied to other message passing implementations and dependency-based programming models.</p><p>Tracing is a technique that chronologically records actions taken by an application during its execution. We call the resulting record an execution trace. The recorded actions include entering and exiting functions, as well as sending and receiving messages. Events are timestamped. In parallel programs, the process in which each event occurs is also recorded. We combine matching function entry and exit actions and deem the time spent in a function an event. We also associate messages with the functions that send and receive them. We call these send events and receive events.</p><p>Most parallel trace visualizations plot stacked per-process event timelines with process or thread numbers mapped to the non-time axis. Functions are represented as rectangular bars that span their lifetime along the time axis, a technique used in Gantt charts. Single process trace visualizations often show the active call stack for each process by arranging function bars similar to an icicle plot. Trumper et al. <ref type="bibr" target="#b41">[41]</ref> aligned multiple of these views to show threads, but targeted situations where only a few threads need to be viewed at a time. When several processes are shown, there is not enough space for the call stack, so only the active function is represented. Zinsight's <ref type="bibr" target="#b12">[13]</ref> event flow view follows this depiction with functionality to expand process timelines into those of the composite processing elements. However, these traces do not include communication between processes.</p><p>Visualizations of this type that depict messages use lines between the two communicating process timelines positioned based on their send and receive times. Actively maintained visualization tools of this type include Vampir <ref type="bibr" target="#b31">[31]</ref>, Paraver <ref type="bibr" target="#b33">[33]</ref>, and Projections <ref type="bibr" target="#b22">[22]</ref>, the latter focusing on Charm++ as an alternative to the MPI model. For a more complete survey of visualizations of various types of traces, including the ones we discuss here, we refer the reader to <ref type="bibr" target="#b21">[21]</ref>.</p><p>As more processes are added to the parallel physical timeline view, the message lines can become an inscrutable hairball, which makes it impossible for users to see, let alone understand, any pattern present in the trace. While Ravel uses the same familiar paradigm of parallel timelines, events as rectangles and messages as lines between processes, our approach uses logical timelines rather than physical ones. This untangles the hairball and can reveal messaging patterns. Physical time information, which is still critical for performance analysis, is added back to the plot by color coding the logical time view. We include a traditional physical timeline view, but it is mainly for comparison for users familiar with existing tools as well as for detailed exploration of local areas of interest discovered using our other views.</p><p>Ariadne <ref type="bibr" target="#b10">[11]</ref>, PVaniM <ref type="bibr" target="#b40">[40]</ref>, and Growing Squares <ref type="bibr" target="#b13">[14]</ref> animated message events between processes in logical time for debugging and program comprehension purposes, but did not include physical time information needed for performance analysis. Furthermore, these visualizations portrayed at most tens of processes.</p><p>Muelder et al. <ref type="bibr" target="#b29">[29]</ref> tackled the issue of scale by changing the vertical axis from processes to event duration and using opacity scaling to plot the events from all processes on top of each other, visually clustering similarly timed events but anonymizing all processes, thereby omitting message dependencies between them. Sigovan et al. <ref type="bibr" target="#b38">[38]</ref> plotted event duration versus process ID, incorporating time through animation. This shows individual processes, but not messages between them. Our visualization allows users to explore communication patterns at a level of detail that preserves these relationships.</p><p>Vampir includes an option for applying k-means clustering to processes, choosing k by how many clusters can fit on screen <ref type="bibr" target="#b8">[9]</ref>. The clustering is done on events in physical time and messages are omitted. We also use clustering, but we use temporal metrics to cluster in logical time. Projections shows outlier timelines when it is not possible to draw all processes. Our clustering view is similar, showing a process of interest and its messaging neighborhood.</p><p>Timeline visualizations in other domains share some similarities with this work. An overview of time-series visualization techniques can be in found in <ref type="bibr" target="#b0">[1]</ref>. LifeFlow <ref type="bibr" target="#b44">[44]</ref> aggregates and aligns numerous event sequence records, placing groups at their mean event sequence time. EventFlow <ref type="bibr" target="#b28">[28]</ref> extends this visualization to durational events. The timelines in this data do not have relationships between them.</p><p>Several techniques depict interactions between multiple timelines, such as participation in the same event <ref type="bibr" target="#b30">[30]</ref>, marriages between persons <ref type="bibr" target="#b24">[24]</ref>, or edits to the same file <ref type="bibr" target="#b32">[32]</ref>, by changing the proximity between the timelines. In history flow <ref type="bibr" target="#b42">[42]</ref>, Wikipedia author contributions to a single article were positioned vertically by the change along the article's text. This visualization could use either physical or per-revision time. These techniques however do not depict multiple separate interactions occurring concurrently, which is the case with many messaging patterns in our traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LOGICAL TIMELINES</head><p>As time is a central element of traces, many trace visualizations represent the time data of events using position on a common scale, the most effective visual channel <ref type="bibr" target="#b9">[10]</ref>. While this choice gives the viewer the most fidelity with respect to event start and end time differences, the larger communication structure composed of those events and messages is easily lost. This structure is an important context for understanding the underlying application code. We prioritize this structure by switching from a physical time scale to a logical time scale where events are positioned based on a logical happened-before ordering defined by the semantics of the communication events (e.g., a message has to be sent before it can be received). At the same time, we retain physical time, which is important to understand the overall performance, by color encoding with metrics derived from physical time. In particular, we have had success using a metric we call lateness, the delay each event experiences relative to its logical assignment. We explain logical time in Section 3.1 and lateness in Section 3.2. Logical time and lateness further provide a basis for handling issues of scale, which we discuss in Section 3.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Logical Time</head><p>Logical time is a concept based on the order in which the events took place with respect to each other rather than compared to physical or wall clock time. Lamport <ref type="bibr" target="#b25">[25]</ref> defines the happened-before relation and the Lamport clock, which serve as an initial basis for the logical time we use. Happened-before is a transitive relation (→) such that: (1) for events a, b of the same process, a → b if a occurs before b and (2) for matching send and receive events s, r, respectively, s → r. The Lamport clock is a function C that assigns a number to each event such that for events a, b, C(a) &lt; C(b) if a → b.</p><p>We use a clock scheme with additional constraints designed to extract communication structures from the trace <ref type="bibr" target="#b19">[20]</ref>. This scheme has a happened-before relation between phases, blocks of execution composing some larger sub-task of the program. Division of the trace events into communication phases can be given by the user or determined computationally based on connected components in the event happened-before graph. Then it enforces the condition that for any two phases P, Q, if P → Q, then C(p) &lt; C(q)∀ events p ∈ P and q ∈ Q.</p><p>Another feature of this scheme is that, instead of assigning the least possible value required by the conditions thus far, it prioritizes assigning the same values to send events, arguing that these are more important to the structure of the communication. As communication is the focus, non-messaging events between each pair of communication events in a process are aggregated into a single logical event. Following the terminology of this scheme, we refer to logical time values as logical steps. We also use the phases determined by the algorithm for clustering (see Section 3.3.1).    <ref type="figure" target="#fig_2">2a</ref> shows a portion of a four-process trace visualized using physical time. <ref type="figure" target="#fig_2">Fig. 2b</ref> shows the the same events in logical time. In both views, green and yellow rectangles are used to represent messaging events and lines between them represent messages. Nonmessaging time is shown in gray. In the physical time view, the width of the rectangle represents duration. In the logical time view, the widths are kept constant to avoid obscuring the communication structure. The communication structure is more apparent using logical time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Lateness</head><p>As we replace the physical time scale with a logical timeline, we must retain the information captured by physical time data by encoding it in a different way. We do this by coloring the events with a novel metric that shows delays of processes compared to others.</p><p>The most straightforward metric for timing data is event exit time, the actual time at which the event completed. Generally, event exit time provides the most useful information since it shows when computation following a communication event is delayed, though we optionally enable other choices, such as enter time or duration, to allow performance analysts to study delay times. A greater exit time value with respect to other events around the same step indicates that the event is behind schedule relative to the others. The greater the discontinuity in color between an event and its predecessor, the greater the duration of the event.</p><p>Discontinuities can be difficult to discern when coloring by absolute exit time, especially when viewing a large number of steps. To further highlight the discontinuities, we focus on a metric that represents them using the delay of an event relative to its peers. We call this the lateness of the event and calculate it as the difference in exit time between the event and the earliest event sharing its timestep. <ref type="figure">Fig. 3</ref> shows a portion of a 16 process MG <ref type="bibr" target="#b2">[3]</ref> trace with events colored by lateness. We observe lateness beginning in the tenth process and propagating to the other processes along message lines. Note that because lateness is calculated relative to the other events in a timestep, once the delay has propagated to all processes, each process's lateness drops as soon as all processes are synchronized. We call this phenomenon "resetting." This behavior is advantageous in the visualization because it prevents late events that occur at the beginning of the trace from masking those that occur further towards the end. <ref type="figure">Fig. 3</ref>: Logical timeline with events colored by lateness, the difference in the wall-clock exit time between the event and the earliest event sharing the timestep. Lateness spreads starting from the tenth process to others waiting via message dependencies until it reaches all processes, at which point it "resets".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Scale</head><p>The amount of screen space that can be devoted to each timeline diminishes as the process count increases. Logical time and lateness provide a convenient platform with which to cluster, allowing us to represent large numbers of processes. We discuss clustering in Section 3.3.1. Our default cluster representations show aggregate sends and receives at each logical time step. We include a mechanism for detecting user-defined motifs and changing their cluster representation to better portray them. We explain this mechanism in Section 3.3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Clustering</head><p>We cluster to group processes according to the metric of interest (by default, lateness). Many processes exhibit different behavior between logical time phases, so we apply clustering on a per-phase basis.   <ref type="figure">Fig. 4</ref>: Distance between two logical timelines with metrics p i , q i . When both processes exhibit an event, we use the squared difference. When only one process exhibits an event, we use the difference between the event and a prior event if it exists.</p><p>The distance metric for our clustering takes advantage of the discrete logical timesteps, considering the phase's span of steps as a vector of values. However, we do not calculate a pure Euclidean distance on this vector, as not every process will have an event at every timestep in a phase. We expect physical time-based metrics like lateness to be fairly stable until perturbed by another event, so we use previous values to fill in gaps where applicable. At any step where one process has an event and another does not, if the process without the event has a previous event in the phase, we use the metric value of that event, otherwise we skip the step. We also skip any steps where both processes are inactive. As we cluster on metric and not structure, we do not want to penalize processes for not having as many matching events. Therefore, we take an average of the squared distances between each step counted. A sample distance calculation is shown in <ref type="figure">Fig. 4</ref>.</p><p>In Ravel, we employ two-stage clustering. We first rapidly generate a moderate number of clusters using CLARA (Clustering for Large Applications) <ref type="bibr" target="#b23">[23]</ref>, a sampled k-medoids method, as implemented in Muster <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, though other clustering algorithms could be used. In the second stage, we create a navigable cluster hierarchy of the CLARA clusters using single linkage hierarchical clustering <ref type="bibr" target="#b37">[37]</ref>, allowing users to explore different clusterings.</p><p>CLARA is O(p) where p is the number of processes. The hierarchical clustering algorithm is O(c 2 ) where c is the (small) number of CLARA clusters. Calculating per phase rather than over the length of the trace further decreases clustering costs. Not all phases may contain all processes and phase breaks mean not every event-less step will have a suitable previous event to use for a value. We cluster the entire trace using lateness during preprocessing. If the user changes the metric later, we recalculate the clustering for phases only as they come into view, spreading out and only incurring computation cost as needed. The user may also elect not to perform clustering. In this case the cluster view will not be shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Customization</head><p>We can improve the visualization by detecting patterns of interest and customizing their cluster representation. We have developed a modular interface to support patterns in Ravel. Each module defines a pattern, and we run pattern detection in all phases during preprocessing. On successful detection, we call the module's draw functions to visualize the cluster of the phase containing the detected pattern.</p><p>As an example, we have implemented a module to detect exchanges. Exchanges are a prevalent pattern, commonly referred to as stencils in scientific simulations and iterative solvers. An exchange occurs in phases where every process sends and receives from the same set of other processes, e.g., its neighbors within the application's domain decomposition. Each process may have a different neighborhood size, as long as the sends and receives match.</p><p>There are several common ways of performing an exchange. One is to alternate sends and receives. Another is to have all processes initiate all of their sends and then handle all of their receives. A third is to have all processes initiate their receives, perform their sends, and finally collect the incoming messages in an MPI WaitAll. We detect all three of these flavors and develop a custom cluster visualization for each. These are described in Section 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RAVEL</head><p>Our trace visualization tool, Ravel, shown in Once an area of interest has been found in the other views, the physical time view provides detail in wall-clock time. Finally, the metric overview, discussed in Section 4.4, allows users to see the distribution of a metric like lateness over the entire length of the trace and navigate to time spans of interest. Ravel chooses which timeline windows will be opened at the start based on the number of processes in the trace and the clustering options.</p><p>The three timeline views, logical, clustered logical, and physical, have linked panning and zooming through time. The selected portion of the metric overview will also update to reflect these actions. The logical and physical timelines also have linked panning and zooming through processes, which are stacked on the vertical axis in both views. Individual MPI events may be selected in one timeline view and will be highlighted in all views in which they are visible. Hovering on events will bring up a tooltip with more information. Users have the option to omit the display of aggregated non-communication events in the logical and clustered logical views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Logical Time View</head><p>In the logical timeline view, individual process timelines are stacked in rows, ordered by their ID in MPI. We preserve this order in all timeline views as it likely has meaning to the developers, e.g., it is often easily mapped to the application domain decomposition.</p><p>The horizontal axis represents logical time. Events are drawn as equally sized boxes as the time scale is logical and not physical. This drawing choice also emphasizes communication patterns. Messages are drawn as lines of equal width between their send and receive event.</p><p>When small numbers of processes or timesteps are shown, events are drawn with spacing and borders. As the number of processes or timesteps increases, the spacing and borders are omitted to conserve space. With large numbers of processes, message lines are omitted as well. They may also be turned off by the user. When the number of processes exceeds the pixel height of the view, overplotting techniques are used so that even sparse logical timestep patterns will be visible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Clustered Logical Time View</head><p>The clustered logical time view is split into two sections. The clusters are shown in the bottom section, while timelines for a focus subset of processes are shown in the top section. The latter is useful to give viewers a hint as to the detailed pattern of communication, which the clusters are unable to show. <ref type="figure" target="#fig_7">Fig. 6</ref> demonstrates this feature.</p><p>Each cluster is displayed as a timeline of events matching the logical time scale of the other views. The communication events are represented by a rectangular glyph <ref type="figure" target="#fig_8">(Fig. 7)</ref> subdivided vertically into sections. The top section shows sends while the bottom shows receives. Inactive processes are an uncolored section in the middle. The height of each section corresponds to the portion of the cluster performing that action at that timestep. For sparse data, the inactive section can be removed. To further emphasize the communication, a send line is drawn from the top and a receive line from the bottom. The thickness of this line is determined by the portion of the cluster that is sending or receiving. Each event is colored by the average metric of the events it  A dendrogram of the clustering of the phase in focus is displayed in the left panel. Users can expand or contract the clustering dendrogram to explore clusters. The vertical space assigned to each cluster is proportional to the number of processes in that cluster. Alternating background colors demarcate cluster boundaries. Single-process clusters are drawn as they would be in the logical timeline view, with message lines drawn between the leaf timeline and the cluster containing the other end of the message.</p><p>The user can select a cluster of interest. Doing so will highlight all members of that cluster in the focus processes and in the other timeline views. Highlighting of processes is done by decreasing the opacity of all non-selected processes and events.</p><p>The focus process timelines are drawn similarly to the logical timeline view, except messages between a focus process and an undrawn process are drawn completely in the focus process's event, starting at the center and ending in the corner closest to where it would be drawn in the full view, to indicate whether it is a send or a receive and communicating between a process with a higher or lower ID.</p><p>Initially, the process containing the event with the greatest metric value and that process's messaging neighborhood are chosen as focus processes. The user can set radius of the messaging neighborhood can be set by the user or change the focus processes to the neighborhood of the maximum metric process or centroid process in a selected cluster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Customized Cluster Drawing for Exchanges</head><p>In Section 3.3.2, we introduced a module that detects exchange communications and changes the cluster drawing if the exchange falls into one of three types. The general cluster drawing is suitable for the type where each process posts all its sends and then handles receives individually. For the case where all receives are collected into a single MPI Waitall, we replace the drawing of the receive line with a quarter pie indicating how many receives are handled at that step on average compared to the maximum handled in that phase. We also quantify that average with a label. This is shown in <ref type="figure" target="#fig_15">Fig. 8</ref>.</p><p>In the case of a large volley of send-receive pairs, we verify that the majority of the messages have their receive event two steps after their send. Then we represent the cluster as a pair of timelines, exchanging <ref type="figure" target="#fig_15">Fig. 8</ref>: Cluster view of an exchange in SMG2000 <ref type="bibr" target="#b34">[34]</ref>, a semicoarsening multigrid solver, with a customized cluster representation. The small pie charts below the communicating tasks show that the earlier MPI Waitall calls collect fewer receives than the later ones. messages back and forth. In some clusters, certain events in this portrayal may not be present in the data, e.g., a cluster of all first-senders will not have any representative first-receivers. In that case, we depict the unrepresented events as an empty box with a dashed border. The send-receive pattern is maintained in this drawing, but no non-present events are shown. This cluster representation is used in Section 5.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Physical Time View</head><p>The physical time view is the common visualization of traces, with process timelines stacked in rows and physical time on the horizontal axis. Events are represented as bars, their widths proportional to duration. Messages are shown as lines between two process timelines.</p><p>If recorded as part of the trace, this view shows details of noncommunication, and possibly non-MPI, events. This can include function invocations made at any level, so some events contain others. A gray scale is applied to non-messaging events with calls made deeper in the tree colored lighter and drawn on top of their parent calls. If present, the main procedure will be darkest and overlaid with other events. Messaging events will always be at the leaves of their call tree. These are colored as in the other timeline views.</p><p>As the horizontal scale in this view is physical time rather than logical time, a mapping between steps to physical time must be made to keep it synchronized with the other views. During preprocessing, this view creates such a map, storing for each step the start and stop time. The start time is the least enter time of any event occurring at that step. The stop time is the greatest exit time of any events occurring at that step. When mapping between steps and physical time, we assume the largest span calculated. This causes irregular overlaps resulting in logical timelines scrolling non-smoothly when the physical timeline is being panned or zoomed and vice versa. However, this is necessary to assure that the other views contain the entirety of messaging information in the one being manipulated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Metric Overview</head><p>The metric overview displays the sum of the active metric across all processes for all timesteps in the trace. The horizontal axis is logical time. The height of the bars are scaled by the step exhibiting the greatest sum. Users can select time spans on the metric overview to quickly navigate to any portion of the trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CASE STUDIES</head><p>We examine two large scale parallel codes to show the utility of Ravel. In the first case study, we show how Ravel was used to discover a nonoptimal message ordering in an in situ analysis application and then verify the improved implementation. We also demonstrate the cluster view's ability to show messaging patterns at multiple scales. In the second case study, we use Ravel to explore messaging delay patterns under two different run configurations of a parallel physics simulation code at three process counts and reveal a scaling bottleneck.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Massively Parallel Merge Trees</head><p>As the gap between available memory and the effective file I/O rates increases, many tasks that have traditionally been performed in post processing will have to be executed in situ. This is particularly problematic for many of the common data analysis and visualization algorithms, which are typically global in nature, file I/O or memory band-width bound, and often unstructured. Parallelizing such approaches, especially to tens or hundreds of thousands of cores utilized by today's simulations, is a significant challenge.</p><p>Here, we analyze a development version of a massively parallel algorithm <ref type="bibr" target="#b27">[27]</ref> to compute merge trees, a topological structure that has recently been used to analyze some of the largest combustion simulations <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b3">4]</ref>. The algorithm relies on a global gather-scatter approach similar to a V-cycle in a traditional multi-grid solver with the corresponding problem of low parallel efficiency as most processes are kept idle some of the time. Further, as with many analysis problems, the computation is highly data dependent causing severe load imbalance in some cases.</p><p>The general data flow for a merge tree using a binary gather is shown in <ref type="figure" target="#fig_9">Fig. 9</ref>. Each process is assigned an equal portion of the data with the decomposition typically dictated by the corresponding simulation code. All processes then perform a local computation step and send the results to their designated gather processes. These integrate the information and send the results both upwards to the next level merge and back downwards towards the leaves which must integrate it. This process is repeated until all information has been globally integrated by the root of the gather. To avoid any one node sending an excessive number of messages, e.g., the root to all leaves, the scattering is routed backwards along the gather tree using multiple hops.</p><p>Since virtually all simulation codes distribute data among all available processes, the gather tree will contain as many leaves as there are processes in the simulation. The gather processes are therefore overloaded onto the processes in a straightforward modulo-k type fashion; e.g., in a binary gather the first level of gather will be assigned to processes 0, 2, 4,..., the level 2 gather to processes 0, 4, 8,..., and so on. <ref type="figure" target="#fig_10">Fig. 10</ref> shows the Vampir and Ravel visualizations of a complete 16 process, 4-ary merge tree. The logical step view is colored by lateness. In this case, the initial step is late, meaning the lateness is due to a   severe load imbalance caused by the input data characteristics. As process 0 is imbalanced, lateness is propagated to the corresponding gather as well as the resulting re-broadcast. Once the root of the tree is reached in the second gather stage lateness resets -there are no other events in the logical step with which to compare. The logical steps clearly highlight the gather tree structure of the algorithm and provide immediate insight into the overall behavior of the code. None of this information is easily accessible from the traditional trace visualization as the time-bound layout obscures the underlying structure. <ref type="figure" target="#fig_11">Figs. 11a and 11b</ref> show two more realistic cases -a 1,024 and 16,384 process run using an 8-ary gather with the same data. There is more lateness in the 1,024 run than the 16,384 process run. As in the small 16 process example, the lateness is due to load imbalance caused by the data. The 1,024 process run divides the data into larger portions per process than the 16,384 process run. The larger data portions are able to exhibit more variance in computational requirements, which is why the 1,024 process run experiences more lateness.</p><p>Since 1,024 and 16,384 are not powers of eight, the level closest to the root only contains two gather processes at 1,024 nodes (and thus 16 processes at the next) and 4 gather processes at 16,384 nodes. In <ref type="figure" target="#fig_11">Fig. 11a</ref>, we can see a division in connection between the top and the bottom half of the image, with each half containing eight parallelograms, 16 groups in total. Similarly, the right side of <ref type="figure" target="#fig_11">Fig. 11b</ref> contains four large groupings. However, the repeating motif of a parallelogram with a panhandle results in many timesteps where few processes are active. A closer analysis reveals a potential flaw in the algorithm. The panhandle occurs when a process sends to its leaves, those closest in rank space, before sending to its higher level children. Furthermore, this means the gather processes first send the information back to the leaves before sending it onward towards the root of the tree. This motif manifests at each level of the tree, the largest example being the events in the middle of the logical steps on the higher half of the MPI ranks (lower half of the visualization). The observed ordering misses an opportunity for a more aggressive pipelining of the computation. No process can finish until the root of the gather has been reached and thus the gather should be prioritized over the scatter.</p><p>Upon discovering the non-optimal message ordering in Ravel, the merge tree developers changed their implementation. <ref type="figure" target="#fig_11">Figs. 11c and  11d</ref> are traces of the improved application using the same input param-eters, but showing significantly more overlap in the communication.</p><p>For the large examples, the logical view can no longer meaningfully represent the messages, which are not drawn. The focus processes in the cluster view can be used to get a sense of the communication pattern. <ref type="figure" target="#fig_2">Fig. 12</ref> features the Ravel cluster view for one phase of the improved merge tree algorithm run at both 1,024 and 16,384 processes. Though the two traces differ in scale, the messaging pattern conveyed (a) 1,024 process merge tree, improved implementation (b) 16,384 process merge tree, improved implementation <ref type="figure" target="#fig_2">Fig. 12</ref>: One phase of the improved merge tree algorithm. Despite the difference in process count, the cluster view reveals the same message pattern. The focus processes exhibit the motif of one process sending to three different groups of eight processes, labeled in (a). As soon as the message is received by a child, it in turn begins sending, except in the final group. This indicates those are the gather tree leaves and thus the messages are ordered optimally.  We hypothesize the gradients may be due to round trip behavior required by the sends which can be completed faster by processes that only receive in a send-receive timestep pair.</p><p>is equally visible in both views. The focus processes show the optimized messaging pattern. The second process sends to three different groups of eight children, a group for each level of the gather tree for which that process is active. After the child receives the message, it in turns starts sending, except for the last group. This indicates the final group of eight which do not send represent the leaves, verifying the updated merge tree implementation handles the leaves last.</p><p>The coloring of the cluster visualization shows that the processes have been grouped by lateness in the aggregate non-communication steps late in the phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Laser-Plasma Interaction Simulations</head><p>pF3D <ref type="bibr" target="#b39">[39]</ref> is a highly scalable parallel application used to study laserplasma interactions in experiments at the National Ignition Facility at LLNL. This code is routinely run on high-end supercomputers, such as the IBM Blue Gene/Q and Cray XE6 at very high processor counts. The communication-heavy nature of this application often leads to performance problems at such scales.</p><p>One of the dominant communications in pF3D is a nearest-neighbor exchange where each process communicates with six nearest neighbors in a three-dimensional (3D) process grid. The default mapping of pF3D processes to cores on some architectures can make this exchange inefficient due to the relatively bad placement of communicating neighbors on the interconnect topology. For example, Blue Gene/Q (BG/Q) uses a five-dimensional (5D) torus interconnect as the network between processing nodes. Different mappings of the 3D logical process grid of pF3D onto the 5D torus of BG/Q can make a significant difference in how messages are routed on the network and in turn, performance <ref type="bibr" target="#b5">[6]</ref>. The effect was previously studied on a 3D torus interconnect with the aid of a visualization specific to that interconnect topology <ref type="bibr" target="#b26">[26]</ref>. As such visualizations are not available for all interconnects, including the BG/Q's 5D torus, we explore performance under different process mappings using tracing and trace visualization.</p><p>The default process mapping assigns process IDs to all 16 cores on a node before moving onto the next node. We can also apply a different mapping that assigns process IDs to one core on each node in a roundrobin fashion. Runs of the pF3D communication benchmark using the round-robin mapping finished 1.25 to 2.5 times faster than those run with the default mapping. <ref type="figure" target="#fig_11">Fig. 13</ref> shows trace visualizations of both mappings applied to 1,024, 8,192, and 32,768 process executions.</p><p>At each scale, the round-robin mapping exhibits much less lateness at all steps, which is expected given its better overall performance. The first two send-receive pairs, corresponding to timesteps 0 through 3, are an exchange in the z direction of the domain decomposition. Under the default mapping, this means all processes send off-node to the exact same neighbor node, contending for the same network link. As such, we expected to see lateness vary among groups of 16 processes in the default mapping and then this lateness to propagate along the processes. We also expected the round-robin mapping would not have as much lateness variance in groups of 16 during the z exchange, but what small variance it did have would help alleviate contention further along the exchange where conflicts could occur, leading to lower lateness overall. In the 1,024 process scenario, Ravel shows behavior that supports this theory during the z exchange: the first four steps of <ref type="figure" target="#fig_11">Fig. 13a</ref> show a lot of variance in lateness between neighboring processes, visible in both the logical and clustered view, and lateness propagating along message lines, visible in the focus processes of the clustered view. The first four steps of <ref type="figure" target="#fig_11">Fig. 13d</ref> show no lateness as expected. However, after the first four steps, we see unexpected gradient patterns along the processes under both mappings. These gradients are also present in the larger runs.</p><p>The unexpected gradients are most visible in <ref type="figure" target="#fig_11">Figs. 13b, 13c and 13f</ref>. Also, rather than lateness propagating along a process, it inverts between the first two and the second two timesteps in these same examples. When we adjust the color map of the 8,192 process round-robin trace <ref type="figure" target="#fig_11">(Fig. 14)</ref>, we also find similar problems. We verified that these observations were not drawing artifacts by examining focus processes in the cluster view and zooming in on the logical view. These effects could not be seen in a standard physical time visualization <ref type="figure" target="#fig_5">(Fig. 15)</ref>.</p><p>In the first two send-receive pairs (timesteps 0 -3), lateness starts at the send, but is not entirely caused by contention from the mapping, because that does not explain the gradient. We hypothesize another contributor to this lateness. The MPI send call used can require the receiver to acknowledge the request. In the first two steps, only the last processes, those corresponding to the final xy plane in the domain decomposition, do not send. This is visible as the white space at the bottom of step 0 and the top of step 2. By not sending, those processes are able to more promptly respond to the request. Thus, their senders receive acknowledgement first and can complete their send. This ef-fect cascades along the process IDs, resulting in the observed gradient. <ref type="figure" target="#fig_7">Fig. 16</ref> illustrates this effect. The second send-receive timestep pair has the same problem inverted. In the 1,024 process runs, no process both sends and receives in the first two timesteps, so no cascade effect occurs which explains why no gradient appears.</p><p>The send-receive timestep pairs in the y and x direction have similar boundary conditions, but are tiled in the process ID space. This leads to the striping patterns seen in some of the later steps. However, if the effect of the earlier delays is great enough, the effects of the later steps may not be significant enough to show up in this view.</p><p>The developers were previously unaware of this cascading dependency problem. They were able to fix the problem leading to a significant performance benefit. <ref type="figure" target="#fig_8">Fig. 17</ref> shows the difference in time spent in communication for the full (non-benchmark) application before and after the change with all other parameters fixed.    <ref type="figure" target="#fig_11">Fig. 13</ref>. Even with relatively few processes, it is difficult to understand the communication structure and behavior. <ref type="figure" target="#fig_7">Fig. 16</ref>: Sends cannot complete until the matching receive is called. Therefore they must wait until the receiver finishes its own send. This causes a cascading effect which shows up as gradients in Ravel. <ref type="figure" target="#fig_8">Fig. 17</ref>: Time pF3D spent in communication using the original and fixed implementation. Removing the dependency issue found using Ravel resulted in a significant reduction in time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We have presented a scalable, informative visualization for parallel execution traces that utilizes the concept of logical time. By shifting the data from physical to logical time, we are able to maintain and clarify communication (messaging) and dependency relationships between processes and illuminate messaging patterns among processes, meeting our first design goal (G1). By applying metrics derived from physical time, we depict sources, patterns, and evolution of delays in an execution.</p><p>Another benefit of logical timelines is the way they lend themselves to clustering, allowing us to summarize behavior at even larger scales. We created a representation for clusters that includes messaging information along with structural cues from focus process neighborhoods to meet our second design goal (G2), efficacy at scale, without abandoning the first.</p><p>We combined our logical timelines and clusters with a traditional physical time visualization and an overview, coordinated across a single logical time scale, giving users a range of detail from the coarse full timeline overview to the highly detailed physical timeline, with the logical timelines and clusters existing in the middle. By coordinating these views, we achieve our final design goal (G3) of providing exploration at several levels of abstraction. We demonstrated the effectiveness of this visualization through two case studies, discovering and explaining performance issues in a parallel analysis application and a large-scale scientific simulation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>For</head><label></label><figDesc>information on obtaining reprints of this article, please send e-mail to: tvcg@computer.org. Manuscript received 31 Mar. 2014; accepted 1 Aug. 2014 ate of publication 2014; date of current version 2014. 11 Aug. 9 Nov. D . Digital Object Identifier 10.1109/TVCG.2014.2346456</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(a) Physical timelines. (b) Logical timelines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 :</head><label>2</label><figDesc>Portion of a four-process trace. Sends events are green. Receive events are yellow. Non-messaging events are gray. Messages are drawn as black lines between processes. The communication pattern is easily discernible in the logical time view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.</head><label></label><figDesc>Fig. 2a shows a portion of a four-process trace visualized using physical time. Fig. 2b shows the the same events in logical time. In both views, green and yellow rectangles are used to represent messaging events and lines between them represent messages. Nonmessaging time is shown in gray. In the physical time view, the width of the rectangle represents duration. In the logical time view, the widths are kept constant to avoid obscuring the communication structure. The communication structure is more apparent using logical time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Logical Timeline View shows logical steps as equally sized bars and messages as lines between them. Color encodes lateness. Physical Timeline View shows all events as bars with width proportional to wall-clock duration. Messaging events are colored by lateness. Other events are gray, darker the further up the call tree. Clustered Logical Timeline View has a compressed representation of the events in each cluster and a representative set of process logical timelines. Metric Overview plots the sum of a metric (e.g. lateness) over all timesteps in the trace.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 :</head><label>5</label><figDesc>Overview of Ravel, a tool for visualizing parallel execution traces.Logical Time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 ,</head><label>5</label><figDesc>is composed of four coordinated views. The logical time view, discussed in Sections 3.3.2 and 4.1, displays the logical timelines of all processes. This view is useful for moderate numbers of processes and overviews. The clustered logical time view, discussed in Sections 3.3 and 4.2, shows timeline clusters and representative timeline neighborhoods. This view is useful for large numbers of processes. The physical time view, discussed in Section 4.3, is similar to the main view in prevailing trace visualization tools. It should be familiar to experienced users.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 :</head><label>6</label><figDesc>Logical (top)  and Cluster (middle/bottom) view of a merge tree gather, further discussed in Section 5.1. The bottom row shows the unopened root of the cluster hierarchy, summarizing the events in the cluster: many processes active in the first two steps, few in the rest. Above the cluster are individual timelines showing the communication neighborhood of one process of interest. The focus processes show structure which can no longer be seen in the logical view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 :</head><label>7</label><figDesc>Cluster event glyphs. The top bar and line are proportional to the number of sends and colored based on the average metric for sends. The bottom bar and line is the same for receives. The blank area is proportional to inactive processes. The left glyph represents the noncommunication event preceding the right. In this example, receiving processes experience an increase in the metric value on average. represents. Customized depictions for special communication patterns are discussed in Section 4.2.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 :</head><label>9</label><figDesc>Communication pattern of the parallel merge tree algorithm for eight processes using a binary gather. The data is distributed among the eight processes (identity indicated by the coloring) and the gather processes are overloaded onto a subset of processes. The solid shapes highlight the processes responsible for the communication in each round. At each round of communication data is sent upwards to the root and downward to the children in a point-to-point fashion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 :</head><label>10</label><figDesc>Complete trace of a 16 process, 4-ary merge tree rooted at process 0. The Vampir view is dominated by the first round of receives waiting for the local compute; little other structure is readily discernible. In contrast, the Ravel logical time view directly reveals the communication structure expected fromFig. 9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>(a) 1 ,</head><label>1</label><figDesc>024 process merge tree, original implementation. (b) 16,384 process merge tree, original implementation. (c) 1,024 process merge tree, improved implementation. (d) 16,384 process merge tree, improved implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 :</head><label>11</label><figDesc>Ravel visualizations of an 8-ary merge tree calculation using both the original and improved implementations on 1,024 and 16,384 processes, respectively. The skewed parallelograms correspond to cascading sends towards the leaves. Branching in the gather three, numbered in (a) and (b), is clear. In the original implementation, (a) and (b), the parallelograms have a panhandle and there is a lot of white space, indicating most processes are often waiting. After this was discovered in Ravel, the developers improved the implementation to more optimally order messages. Traces of the new implementation, (c) and (d), show greater parallelism of the communication operations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>(a) 1 ,</head><label>1</label><figDesc>024 processes, default mapping (b) 8,192 processes, default mapping. (c) 32,768 processes, default mapping. (d) 1,024 processes, round-robin mapping (e) 8,192 processes, round-robin mapping. (f) 32,768 processes, round-robin mapping.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 13 :</head><label>13</label><figDesc>Ravel visualizations of the pF3D near-neighbor exchange using both the default mapping and the round-robin mappings at 1,024, 8,192 and 32,768 processes. Timestep labels have been added at the top for clarity. The traces from the round-robin mapping runs exhibit lower lateness throughout. These visualizations also show a curious pattern in lateness, causing a gradient in the logical view. An examining of details in the cluster view shows this is not a drawing artifact.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>(a) 8 ,</head><label>8</label><figDesc>192 processes, round-robin mapping. (b) Zoom to show gradient in later steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 14 :</head><label>14</label><figDesc>Trace for an 8,192 process, round-robin mapping pF3D benchmark run with the lateness range relative to maximum lateness in the step. The same striping patterns seen in the default mapping trace inFig. 13bare visible here as well.(a) Vampir visualization of all 1,024 processes. (b) Vampir visualization of subset of 1,024 processes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 15 :</head><label>15</label><figDesc>Vampir visualizations of the pF3D exchange as shown in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, Ilir Jusufi and Bernd Hamann are with University of California, Davis. E-mails: {keisaacs,jusufi,bhamann}@ucdavis.edu.</figDesc><table /><note>• Peer-Timo Bremer, Todd Gamblin, Abhinav Bhatele, and Martin Schulz are with Lawrence Livermore National Laboratory. E-mails: {ptbremer,tgamblin,bhatele,schulzm}@llnl.gov.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors would like to thank Aaditya Landge for his help with the parallel merge tree application, Nikhil Jain and Steven H. Langer for their help with pF3D, and Steven Mueller for his multimedia technical expertise.</p><p>This work was performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under Contract DE-AC52-07NA27344. LLNL-JRNL-657418. This research is supported in part by the Department of Energy Office of Science Graduate Fellowship Program, administered by ORISE-ORAU under contract no. DE-AC05-06OR23100.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Visualization of Time-Oriented Data. Human-Computer Interaction Series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Aigner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Miksch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tominski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">ASCAC subcommittee report: The opportunities and challenges of exascale computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ashby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Colella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dongarra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kothe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lusk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Messina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mezzacappa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Moin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Siegal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Streitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wright</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
		<respStmt>
			<orgName>United States Department of Energy</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The NAS parallel benchmarks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Barszcz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Barton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Browning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Fatoohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. J. of Supercomputer Applications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="63" to="73" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Combining in-situ and in-transit processing to enable extreme-scale scientific analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Abbasi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Grout</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Klasky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kolla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Parashar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pebay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thompson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Conf. on Supercomputing (SC12)</title>
		<meeting>ACM/IEEE Conf. on Supercomputing (SC12)</meeting>
		<imprint>
			<date type="published" when="2012-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Feature-based statistical analysis of combustion simulation data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Grout</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Vis. and Comp. Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1822" to="1831" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mapping applications with collectives over sub-communicators on torus networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhatele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename><surname>Langer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Draeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Landge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Still</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Conf. on Supercomputing (SC12), SC &apos;12</title>
		<meeting>ACM/IEEE Conf. on Supercomputing (SC12), SC &apos;12</meeting>
		<imprint>
			<date type="published" when="2012-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Scalable critical-path based performance analysis. Parallel and Distributed Processing Symp</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boehme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">R</forename><surname>De Supinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Geimer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1330" to="1340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive exploration and analysis of large scale simulations using topology-based data segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Day</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Bell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Vis. and Comp. Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1307" to="1324" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Comprehensive performance tracking with Vampir 7</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Brunst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hackenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Juckeland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Rohling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools for High Performance Computing 2009</title>
		<editor>M. S. Mller, M. M. Resch, A. Schulz, and W. E. Nagel</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="17" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Graphical perception: Theory, experimentation, and application to the development of graphical methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cleveland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mcgill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="531" to="554" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Ariadne debugger: Scalable application of event-based abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cuny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Forman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Snyder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stemple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1993 ACM/ONR Workshop on Parallel and Distributed Debugging, PADD &apos;93</title>
		<meeting>1993 ACM/ONR Workshop on Parallel and Distributed Debugging, PADD &apos;93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="85" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Tools for exascale computing: Challenges and strategies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hovland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Janssen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Marques</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Skinner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vetter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-10" />
		</imprint>
		<respStmt>
			<orgName>United States Department of Energy</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Zinsight: A visual and analytic environment for exploring large event traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>De Pauw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heisig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Intl. Symp. on Software Vis., SOFTVIS &apos;10</title>
		<meeting>5th Intl. Symp. on Software Vis., SOFTVIS &apos;10</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="143" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Growing Squares: Animated visualization of causal relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tsigas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2003 ACM Symp. on Software Vis., SOFTVIS &apos;03</title>
		<meeting>2003 ACM Symp. on Software Vis., SOFTVIS &apos;03</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<title level="m">Muster: Massively scalable clustering</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Clustering performance data efficiently at massive scales</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">R</forename><surname>De Supinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Intl. Conf. on Supercomputing (SC10)</title>
		<meeting>ACM Intl. Conf. on Supercomputing (SC10)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scalable methods for monitoring and detecting behavioral equivalence classes in scientific codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd IEEE Intl. Parallel and Distributed Processing Symp</title>
		<meeting>22nd IEEE Intl. Parallel and Distributed essing Symp</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automatic detection of parallel applications computation phases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gimenez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Labarta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd IEEE Intl. Parallel and Distributed Processing Symp</title>
		<meeting>23rd IEEE Intl. Parallel and Distributed essing Symp</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Vetter. ASCR modeling and simulation of exascale systems and applications workshop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hoisie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kerbyson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2012-08" />
		</imprint>
		<respStmt>
			<orgName>United States Department of Energy</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhatele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Ordering traces logically to identify lateness in parallel programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bremer</surname></persName>
		</author>
		<idno>LLNL-TR-656141</idno>
		<imprint>
			<date type="published" when="2014-06" />
		</imprint>
		<respStmt>
			<orgName>Lawrence Livermore National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">State of the art of performance visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Giménez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Jusufi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhatele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE Conf. on Vis. State-of-the-Art Reports, EuroVis &apos;14</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scaling molecular dynamics to 3000 processors with projections: A performance analysis case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">V</forename><surname>Kalé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Terascale Performance Analysis Workshop, Intl. Conf. on Computational Science (ICCS)</title>
		<imprint>
			<date type="published" when="2003-06" />
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Clustering Large Applications (Program CLARA)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Rousseeuw</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<biblScope unit="page" from="126" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tracing genealogical data with TimeNets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">W</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Card</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Intl. Conf. on Advanced Visual Interfaces, AVI &apos;10</title>
		<meeting>Intl. Conf. on Advanced Visual Interfaces, AVI &apos;10</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="241" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Visualizing network traffic to understand the performance of massively parallel simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Landge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhatele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename><surname>Langer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Vis. and Comp. Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2467" to="2476" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">In-situ feature extraction of large scale combustion simulations using segmented merge trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Landge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kolla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Conf. on Supercomputing (SC14), SC&apos;14</title>
		<meeting>ACM/IEEE Conf. on Supercomputing (SC14), SC&apos;14</meeting>
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Temporal event sequence simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Monroe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Vis. and Comp. Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2227" to="2236" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Visual analysis of inter-process communication for large-scale parallel computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Muelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Gygi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Vis. and Comp. Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1129" to="1136" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Munroe</surname></persName>
		</author>
		<ptr target="http://xkcd.com/657" />
		<title level="m">XKCD #657</title>
		<imprint>
			<date type="published" when="2009-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">VAMPIR: Visualization and analysis of MPI resources</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Nagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Solchenbach</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Supercomputer</publisher>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="69" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Software evolution storylines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ogawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Intl. Symp. on Software Vis., SOFTVIS &apos;10</title>
		<meeting>5th Intl. Symp. on Software Vis., SOFTVIS &apos;10</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Paraver: A tool to visualize and analyze parallel code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pillet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Labarta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cortes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Girona</surname></persName>
		</author>
		<idno>UPC-CEPBA 95-3</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Polytechnic University of Catalonia</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Accelerated Strategic Computing Initiative. The SMG2000 benchmark</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Message Passing Interface Forum. MPI: A message-passing interface standard</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Extracting critical path graphs from MPI applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cluster Computing</title>
		<imprint>
			<date type="published" when="2005-09" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">SLINK: An optimally efficient algorithm for the single-link cluster method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sibson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="34" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Visualizing large-scale parallel communication traces using a particle animation technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sigovan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">W</forename><surname>Muelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3pt2</biblScope>
			<biblScope unit="page" from="141" to="150" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Filamentation and forward brillouin scatter of entire smoothed and aberrated laser beams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Still</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Hinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Suter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physics of Plasmas</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="2023" to="2032" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">PVaniM: a tool for visualization in network computing environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Topol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sunderam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1197" to="1222" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Understanding complex multithreaded software systems by using trace visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Trümper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bohnet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Döllner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Intl. Symp. on Software Vis., SOFTVIS &apos;10</title>
		<meeting>5th Intl. Symp. on Software Vis., SOFTVIS &apos;10</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="133" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Studying cooperation and conflict between authors with history flow visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Viégas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dave</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCHI Conf. on Human Factors in Computing Systems, CHI &apos;04</title>
		<meeting>SIGCHI Conf. on Human Factors in Computing Systems, CHI &apos;04</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="575" to="582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Usage of the SCALASCA toolset for scalable performance analysis of large-scale parallel applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J N</forename><surname>Wylie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ábrahám</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Frings</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fürlinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Geimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-A</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mohr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pfeifer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Szebenyi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools for High Performance Computing</title>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="157" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">LifeFlow: Visualizing an overview of event sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Guerra Gómez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Plaisant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">D</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Taieb-Maimon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCHI Conf. on Human Factors in Computing Systems, CHI &apos;11</title>
		<meeting>SIGCHI Conf. on Human Factors in Computing Systems, CHI &apos;11</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1747" to="1756" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
