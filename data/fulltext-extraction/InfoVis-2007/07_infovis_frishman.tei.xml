<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multi-Level Graph Layout on the GPU</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-10-27">27 October 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Student Member, IEEE</roleName><forename type="first">Frishman</forename><surname>Yaniv</surname></persName>
							<email>frishman@tx.technion.ac.il</email>
							<affiliation key="aff0">
								<orgName type="institution">Israel Institute of Technology</orgName>
								<address>
									<settlement>Technion</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ayellet</forename><surname>Tal</surname></persName>
							<email>ayellet@ee.technion.ac.il</email>
							<affiliation key="aff0">
								<orgName type="institution">Israel Institute of Technology</orgName>
								<address>
									<settlement>Technion</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Multi-Level Graph Layout on the GPU</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-10-27">27 October 2007</date>
						</imprint>
					</monogr>
					<note type="submission">received 31 March 2007; accepted 1 August 2007; posted online</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph layout</term>
					<term>GPU</term>
					<term>graph partitioning</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents a new algorithm for force directed graph layout on the GPU. The algorithm, whose goal is to compute layouts accurately and quickly, has two contributions. The first contribution is proposing a general multi-level scheme, which is based on spectral partitioning. The second contribution is computing the layout on the GPU. Since the GPU requires a data parallel programming model, the challenge is devising a mapping of a naturally unstructured graph into a well-partitioned structured one. This is done by computing a balanced partitioning of a general graph. This algorithm provides a general multi-level scheme, which has the potential to be used not only for computation on the GPU, but also on emerging multi-core architectures. The algorithm manages to compute high quality layouts of large graphs in a fraction of the time required by existing algorithms of similar quality. An application for visualization of the topologies of ISP (Internet Service Provider) networks is presented.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graph drawing addresses the problem of constructing geometric representations of graphs <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b37">38]</ref>. It has applications in a variety of areas, including software engineering, software visualization, databases, information systems, decision support systems, biology, and chemistry.</p><p>Producing pleasing graph layouts fast is still a challenging problem. For instance, one of the most popular graph layout algorithms, the force directed algorithm, is computationally expensive. The complexity of each iteration of the algorithm is O(V 2 + E). On large graphs, the layout procedure can take anywhere from a few seconds to several minutes to complete, hindering the capability to use this algorithm to explore large data sets.</p><p>In recent years, a popular way to accelerate computations is to perform them on the GPU (graphics processing unit) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32]</ref>. This is due to the high computational power, low cost, and ubiquity of GPUs in every modern PC. GPUs are geared towards repetitively performing the same computation on large streams of data. Therefore, the GPU suits uniformly structured data, such as images or matrices. Graphs do not posses a uniform structure, hence, they do not admit any intuitive and natural representation that suits computation on the GPU. This paper proposes two ways in which force directed algorithms can be accelerated. The first is a general multi-level scheme, which is based on spectral partitioning. The second is computation of a graph layout on the GPU.</p><p>Multi-level graph layout algorithms have been proposed in the past <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b39">40]</ref>. In these algorithms, the given graph is recursively coarsened, to compute its multi-level representation. In contrast, in our scheme, the algorithm works on a high-detailed graph at all levels of the partitioning. Thus, a good hierarchical representation of the graph is obtained. The scheme proposed in this paper is a general multi-level scheme, which is based on spectral partitioning. Using a bottom up approach, layouts of increasing detail are computed. It is shown how coarse layouts of a graph can be efficiently extended to the final high quality layout.</p><p>In addition, this paper describes a method of representing graphs so as to make efficient use of GPU resources. Partitioning is used to break the large problem into smaller and similarly-sized problems that suit computation on the GPU or on other data-parallel programming models. This algorithm exposes the underlying structure of the graph, and thus can be used in a multi-level scheme.</p><p>Another algorithmic contribution of the paper is devising a layout algorithm that combines the strengths of two different well-known layout algorithms <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23]</ref>. The produced layouts are as good as existing state of the art layouts <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, yet computed at a fraction of the running time. For example, a layout of the graph bcsstk31 is computed using our approach in 5.8 seconds compared to 83 seconds in <ref type="bibr" target="#b14">[15]</ref>.</p><p>Implementation-wise, the paper elaborates on how force directed layout is accelerated, by performing the time-consuming stages on the GPU. The data storage and the stream processing are described.</p><p>Last but not least, the algorithm is applied to the visualization of the topologies of Internet Service Providers (ISP) networks. In this application, illustrated in <ref type="figure" target="#fig_1">Figure 1</ref>, nodes represent routers and edges represent the connections between them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Many algorithms have been proposed to perform graph layouts <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b37">38]</ref>. This paper focuses on force directed layout <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23]</ref>, which is based on simulating the graph as a network of charged particles that repel each other, where edges are simulated by springs. The algorithm is popular due to its ability to draw general undirected graphs, its ability to be tailored according to specific requirements, and the aesthetically pleasing layouts it produces. However, a major drawback of the algorithm is its high computational cost.</p><p>Some algorithms have been proposed to perform force directed layouts of large graphs <ref type="bibr" target="#b15">[16]</ref>. In <ref type="bibr" target="#b39">[40]</ref> coarser representations of the graph are recursively built using the edge collapse operation. Instead of computing all-pairs repulsion forces, only close-by nodes are addressed. The algorithm in <ref type="bibr" target="#b17">[18]</ref> creates coarse graphs using an approximation of the k-center problem. A modified version of <ref type="bibr" target="#b22">[23]</ref> is used to perform single level layout. This algorithm requires O(V 2 ) memory and O(V E) time. The algorithm in <ref type="bibr" target="#b1">[2]</ref> computes repulsion forces in O(N log N). In <ref type="bibr" target="#b33">[34]</ref> a quadtree is used to accelerate layout and to visualize the graph in multiple levels of detail. In <ref type="bibr" target="#b8">[9]</ref> a maximum independent set filtration is used to coarsen the graph. At each level new nodes are placed in accordance with their neighbors. A local force computation is performed using both <ref type="bibr" target="#b22">[23]</ref> and <ref type="bibr" target="#b7">[8]</ref>. FM 3 <ref type="bibr" target="#b14">[15]</ref> is a state of the art multi-level algorithm <ref type="bibr" target="#b15">[16]</ref>. There, solar systems are created, which consist of nodes at a distance of two edges or less from the center of the solar system. A clever O(N log N) approximation of the all-pairs repulsive forces is used to accelerate layout.</p><p>In <ref type="bibr" target="#b25">[26]</ref> a simplified energy function is used, which allows more robust mathematical treatment. The layout problem is reduced to an Eigen value computation problem, which is solved using an algebraic multi-grid approach. Although the resulting algorithm is very rapid, the quality of the layout is limited <ref type="bibr" target="#b15">[16]</ref>. This may be attributed to the algorithm defining forces only along edges of the graph. In <ref type="bibr" target="#b19">[20]</ref> a high dimensional embedding of the graph is computed and then projected into the drawing plane, allowing a linear time O(E +V ) algorithm.  In the current paper, instead of working on increasingly coarsened graphs, the input graph is partitioned to smaller and smaller parts. This helps construct an accurate multi-level representation of the graph.</p><p>In recent years, GPUs have been successfully applied to numerous problems outside of classical computer graphics <ref type="bibr" target="#b30">[31]</ref>. Some GPU usage examples include solving differential equations <ref type="bibr" target="#b12">[13]</ref>, linear algebra <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b26">27]</ref>, signal processing <ref type="bibr" target="#b28">[29]</ref>, visualization <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b21">22]</ref> and simulation <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b27">28]</ref>, to name a few.</p><p>Several other GPU applications are somewhat related to ours. In <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b36">37]</ref> simulation of deformable bodies using mass-spring systems is performed. However, while the mass-spring algorithms take only nodes connected by edges into account, the force directed algorithm considers all the nodes when calculating the force exerted on a node. GPUs have also been used to simulate gravitational forces <ref type="bibr" target="#b29">[30]</ref>, where an approximate force field is used to calculate forces. Accelerating dynamic graph drawing on the GPU has been addressed in <ref type="bibr" target="#b6">[7]</ref>. The focus of that work was on creating stable layouts of changing graphs, whereas the current paper addresses static layouts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SPECTRAL GRAPH PARTITIONING</head><p>Computing directly the layout of a large graph is both time-consuming and difficult. This is due to the sensitivity of force directed layout to the initial conditions given to the algorithm. To address these problems, multi-level schemes have been used <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b39">40]</ref>. The key idea is that a good representation of the overall structure of the graph will yield a layout of the "skeleton", which can be quickly computed, and which can assist in drawing the large input graph.</p><p>We propose an algorithm for creating a series of resolution decreasing representations of the graph by recursively partitioning it. We require the parts to have similar size and have a minimal cut between them. The former requirement helps preserve the balance between the nodes during layout, while the latter guarantees that different parts are weakly coupled and hence can be treated relatively independently.</p><p>While existing multi-level graph layout algorithms recursively coarsen the graph in order to compute the multi-level representation, our algorithm works on a high-detailed graph at all levels of the partitioning. This allows us to obtain a high-quality representation of the graph, which does not suffer from the growing inaccuracy involved in repetitively creating coarser and coarser representations of a reduced version of the graph.</p><p>To do it, we use spectral graph theory <ref type="bibr" target="#b3">[4]</ref>. This theory has been used in the field of parallel computation to partition computation dependency graphs, where the amount of work between processors needs to be balanced <ref type="bibr" target="#b32">[33]</ref>. It was also used in image segmentation, where normalized cuts were introduced <ref type="bibr" target="#b34">[35]</ref>. The idea of using eigenvectors of the Laplacian for finding partitions of graphs has a rich history <ref type="bibr" target="#b5">[6]</ref>.</p><p>Suppose that w i j is the weight of the edge (i,j), D is a diagonal matrix, D(i, i) ≡ ∑ j w i j , and W (i, j) ≡ w i j is the graph edge weights matrix. The matrix L = D −W is the Laplacian of graph G. The goal is to partition G into two equal-sized partitions A, B. For node i, we define q i = 1 if i ∈ A and q i = −1 if i ∈ B. It can be shown <ref type="bibr" target="#b32">[33]</ref> that the cut size J is:</p><formula xml:id="formula_0">J = CutSize = 1 4 ∑ i, j w i j (q i − q j ) 2 = 1 2 q T (D −W )q.</formula><p>In order to minimize J, we can relax the indicators q i to continuous values and take the second smallest eigenvector of</p><formula xml:id="formula_1">(D −W )q = λ q.</formula><p>This vector is known as the Fiedler vector <ref type="bibr" target="#b5">[6]</ref>. (The smallest eigenvector, corresponding to an eigenvalue λ 1 = 0 is</p><formula xml:id="formula_2">q 1 = (1, ..., 1) T .)</formula><p>To compute the Fiedler vector, we use the power iteration algorithm <ref type="bibr" target="#b40">[41]</ref>, shown in <ref type="figure" target="#fig_2">Figure 2</ref>. The input of the algorithm is a guess for the Fiedler vector, stored in v2. The computed Fiedler vector is returned in v2. The algorithm is iterative. In each iteration v2 is orthogonalized against the first eigenvector and multiplied by the matrix B which is used to reverse the order of the eigenvectors, using the Gershgorin bound, which bounds the magnitude of the largest eigenvalue of the Laplacian. This algorithm fits sparse matrices (i.e., graphs), since it requires only matrix-vector multiplications. A similar algorithm is used in <ref type="bibr" target="#b25">[26]</ref> to directly compute the graph layout, whereas it is used here only to partition the graph. A drawback of the power iteration algorithm is its slow convergence rate. To accelerate the convergence, a multi-grid algorithm is used. Instead of directly operating on the largest Laplacian matrix, a series of coarsening operations is performed, until reaching a minimal problem size. The coarsening algorithm is detailed in Section 4, Step 1. After coarsening, the coarser problems are recursively solved and interpolated back, setting a good initial guess for the next (finer) problem.</p><formula xml:id="formula_3">L = Laplacian(G) g = Gershgorin bound(L) = max i L ii + ∑ j =i |L i j | B = gI -L v1 = 1 √ N • 1 N //first (known) eigenvector do v2 old = v2 v2 = v2 − (v2 T • v1)v1 v2 = B • v2 v2 = v2 v2 until |v2 old • v2 T − 1| &lt; ε or max iteration count reached</formula><p>After computing the Fiedler vector v2, it is used to partition the graph. Each node in the graph has a corresponding value in v2. This value is used to determine which partition the node will be assigned to. The vector v2 is sorted. A set of k − 1 splitting values is determined by sampling the sorted vector at k −1 uniformly spaced points. This splits the vector into k regions. The partition to which a node is assigned is computed by determining to which of the k regions the value of v2 corresponding to the node belongs to.</p><p>Since the graph is partitioned into more than two parts, some clusters may be disconnected. A post-processing stage that merges clusters is performed. Each cluster whose size is below a threshold, is merged with its largest neighboring cluster.</p><p>The partitioning algorithm continues repetitively, building finer and finer representations of the graph. The finer representations are then used in a multi-level scheme, described in Section 4, to compute a globally pleasing layout of the original graph.</p><p>In our implementation, any eigen problem of a size smaller than 128 nodes is directly solved, since coarsening it further is not timeeffective. For each problem, a maximum of 10000 power iterations are allowed and an accuracy ε = 10 −8 is used. The graph is partitioned by default into three parts (k = 3). Disconnected clusters smaller than 1 9 of the graph are merged. Our attempts to perform a more adaptive partitioning, resulted in lower quality results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MULTI-LEVEL LAYOUT ALGORITHM</head><p>Given an undirected weighted graph G = G 0 = (V, E), the goal of the algorithm is to compute a straight-line drawing of G, assigning 2D coordinates to each node. Our algorithm is based on the force-directed approach <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b37">38]</ref>, which simulates a system of forces defined on the input graph and converges towards a local minimum energy position, starting from an initial placement of the vertices.</p><p>Our algorithm has several key ideas. First, a multi-level scheme is used to compute the layout. Instead of directly computing a layout for the input graph, several coarsened versions of it are created. Starting from the coarsest version, a series of increasingly detailed layouts are computed. Care is taken to interpolate positions from each coarse layout and use them as the starting point for the next finer layout.</p><p>Second, spectral partitioning methods are used to compute lower resolution representations of the graph, as discussed in Section 3. Using this approach the difficult graph partitioning problem is transformed to a 1D partitioning problem. Breaking the graph into increasingly finer parts allows us to produce a series of increasingly detailed graphs, which are used in the multi-level scheme.</p><p>Third, a layout algorithm which combines the strengths of <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23]</ref> is used. While <ref type="bibr" target="#b22">[23]</ref> is able to compute a good layout, given any starting point, it is time consuming. The algorithm of <ref type="bibr" target="#b7">[8]</ref> is faster and computes "smoother" layouts, but is more sensitive to the initial conditions given to it. We propose an algorithm which combines the strengths of both algorithms in order to produce the final layout.</p><p>The algorithm is composed of the following stages, shown in Figure 3: We elaborate on each stage below.</p><p>1. Initial coarsening: compute G 1 , G 2 ,...,G coarsest where G k+1 = edge collapse(G k ).</p><p>2. Partitioning initialization: set P level=0 part num=0 to G coarsest . Set l = 0.</p><p>3. Partitioning: try to partition each graph P l n . This creates a new set of graphs P l+1 0 , P l+1 1 ,.... If no graph P l n could be partitioned, goto step 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Multi-level construction: construct</head><formula xml:id="formula_4">L l out of G coarsest , where</formula><p>each node in L l corresponds to a graph P l n .</p><p>5. Layout initialization: compute an initial layout for L l , using interpolated initial positions from the coarser L l−1 .</p><p>6. Layout: compute the layout for L l . This is the core step of the algorithm, which uses our variant of the force-directed approach. Set l = l + 1, goto step 3.</p><p>7. Compute a layout for G coarsest using interpolated initial positions from L f inest , the finest graph layout computed in stage 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Final un-coarsening:</head><p>Compute layouts for G coarsest−1 , G coarsest−2 ,...,G 0 by repetitively interpolating from G i to G i−1 and laying out G i−1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 3. Algorithm overview</head><p>Initial coarsening (Step 1): In step 1, the graph is coarsened several times, as a pre-processing stage that helps reduce computation time. At each level k, given a fine graph G k , a coarser representation G k+1 is constructed using a series of edge collapse operations <ref type="bibr" target="#b39">[40]</ref>. A collapse operation replaces two connected nodes and the edge between them by a single node, whose weight is the sum of the weights of the nodes being replaced. The weights of the edges are updated accordingly. (The initial weight of a node/edge is 1.) The order of the edge collapse operations is different than in <ref type="bibr" target="#b39">[40]</ref>: First, candidate nodes for elimination are sorted by their degree, so as to eliminate low-degree nodes first. An adjacent edge of a low-degree node is chosen for collapse by maximizing the following measure:</p><formula xml:id="formula_5">w(u,v) w(v) + w(u,v) w(u)</formula><p>, where w(x) is the weight of node x and w(x, y) is the weight of edge (x, y). This function helps to preserve the topology of the graph by "uniformly" collapsing highly connected nodes.</p><p>In our implementation, three initial coarsening steps are performed. This significantly reduces the computation time of spectral partitioning (Step 3), while maintaining a good relation between the input graph G 0 and G coarsest .</p><p>Partitioning initialization (Step 2): This step initializes the variables used in the recursive partitioning of graph G coarsest in the next step. The graph P 0 0 , which is set to G coarsest , is created. Partitioning (Step 3): The goal of this step is to create high quality coarser representations of the graph G coarsest , which are used in the multi-level layout scheme.</p><p>Starting from the single graph P 0 0 at level 0, for each level l the set of graphs P l n in this level are partitioned as described in Section 3. Each graph P l n is partitioned into graphs P l+1 m , by adding the corresponding edges from P l n . As the level number l increases, G coarsest is partitioned into a growing number of graphs decreasing in size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multi-level construction (Step 4)</head><formula xml:id="formula_6">: A series of graphs L 0 , L 1 ,.</formula><p>..,L f inest of increasing detail is created. At level l, the graph L l is created as follows. Each node n k in L l corresponds to a single graph P l k in level l. The weight of a node n k in L l is the sum of the weights of the nodes in graph P l k it corresponds to. Edges (n k , n j ) in L l are created by summing corresponding edges in G coarsest which connect the nodes in G coarsest corresponding to P l k and P l j . Layout initialization (Step 5): The goal of this stage is to compute a good initial layout of L l . This is done based on the layout of L l−1 , and proceeds as follows. Initially, each node p i ∈ L l is placed at the position of its parent node in L l−1 , whose layout was already computed. Next, the position of each node is scaled, as follows:</p><formula xml:id="formula_7">p i (x, y) = |V (L l )| |V (L l−1 )| • p i (x, y),<label>(1)</label></formula><p>where V (L k ) is the set of nodes in L k . The intuition behind Eq. 1 is that the scale should be proportional to the ratio between the number of nodes in the graphs L l and L l−1 . Finally, an iterative algorithm is used to improve the placement. At each iteration, each node i is placed at the average between its current position, p i , and the average position of its neighbors, N(i), as follows:</p><formula xml:id="formula_8">p i = 1 2 p i + 1 degree(i) ∑ j∈N(i) p j .</formula><p>This procedure creates a good initial placement, which is used in the next step. In our implementation 50 iterations are used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Layout (Step 6):</head><p>In this stage, a layout for L l is computed, using our variant of the force directed approach. This is done utilizing the multi-level scheme, until the final layout of the finest graph, L f inest , is computed. Using this scheme, it is possible to retain important information about the overall structure of the graph from previous layouts, which is extracted from the spectral partitioning of the graph.</p><p>There are a couple of common approaches to performing force directed layout. The first common approach, exemplified by the Fruchterman-Reingold (FR) algorithm <ref type="bibr" target="#b7">[8]</ref>, computes the forces directly. Each node is moved according to the forces acting on it. It computes "smooth" layouts, but is sensitive to the initial conditions given to it. A second common approach, used in the Kamada-Kawai (KK) algorithm <ref type="bibr" target="#b22">[23]</ref>, derives an energy function from the forces and attempts to minimize the energy in order to create the layout. The node that reduces the energy the most is moved in each step. This algorithm is less sensitive to the initial conditions. However, it requires an expensive all-pairs shortest path calculation and the computed layouts are less "smooth".</p><p>In this paper, an approach that combines the strengths of both algorithms is used. The key idea is to use the KK approach, to give the overall structure of the graph and reduce the sensitivity to initial conditions. Then, the computed layout is used as an input to the FR-based algorithm. On finer graphs, only the faster FR layout is used. By doing so, we get a good initial placement from the KK algorithm and a "smooth", aesthetically more pleasing layout from the FR algorithm. Note that a combined approach is used in <ref type="bibr" target="#b18">[19]</ref> in order to meet nodesize constraints. In the current paper, however, FR is used to refine the layout of finer graphs in the multi-level hierarchy.</p><p>The most expensive step of the FR algorithm is the computation of all-pairs repulsive forces between nodes, which is crucial for obtaining a good layout. This step is accelerated in two ways. First, the graph is geometrically partitioned. Instead of calculating all-pairs repulsive forces, as customary, approximate forces are calculated. An exact calculation is performed only for nodes contained in the same partition, while an approximate calculation is performed for nodes belonging to different partitions. Second, the calculation of the forces is parallelized and performed on the GPU.</p><p>Graph L l is now partitioned geometrically, according to the current layout, so as to balance the number of nodes per partition. This is important in order to achieve good load balance between the parallel processors of the GPU (Section 5). Moreover, since the nodes in each partition are geometrically localized, it is possible to approximate the partitions with a single "heavy" node, as discussed below.</p><p>Specifically, a KD-tree-type partitioning is created. The nodes are partitioned according to their median, alternating between the X and Y coordinates. This recursive subdivision terminates when the size of the subset is below the required partition size.</p><p>The algorithm is iterative. In each iteration, the KD-tree is updated according to the current layout (while required). Then, the center of gravity is found for each partition and is used to replace the nodes it contains. Next, The forces applied to each node are computed. Finally, the nodes are displaced according to the forces acting on them, while bounding the allowed displacement according to the exponential converge schedule, which resembles simulated annealing.</p><p>The key to achieving high performance is to perform these computations (i.e., finding the center of gravity of the partitions, calculating the various forces acting on the nodes, and calculating the displacements), in parallel on the GPU for each node/partition.</p><p>In particular, the repulsive and attractive forces that are computed in parallel for each node are as follows. The difference from <ref type="bibr" target="#b7">[8]</ref> is that the forces from distant partitions are approximated using their center of gravity CG. For each node v that belongs to partition P i ,</p><formula xml:id="formula_9">F repl (v) = K 2 ∑ u =v,u∈P i pos(v)−pos(u) pos(v)−pos(u) 2 + ∑ P j =P i |P j | pos(v)−CG(P j ) pos(v)−CG(P j ) 2 F attr (v) = ∑ u:(u,v)∈E pos(u)−pos(v) (pos(u)−pos(v)) K</formula><p>The attractive and repulsive forces are then summed up in parallel for every node, resulting in an approximation of the total force applied to each node, F total (v). Then, each node is displaced, in parallel, using a simulated annealing technique, which exponentially decreases the allowed displacement:</p><formula xml:id="formula_10">pos new (v) = pos(v) + F total (v) F total (v) min(t, F total (v) ).</formula><p>Here, t is the bound for the maximum displacement, which is initial-ized to K * |V | and decreases at each iteration by a factor λ . In our implementation, K = 0.1 and λ = 0.9</p><p>The simulated annealing technique makes the graph slowly freeze into position. Thus, later iterations perform increasingly local corrections to the layout. Because of this behavior, it is possible to perform geometrical KD partitioning of the graph with decreasing frequency.</p><p>In our implementation, re-partitioning is done on iterations 1-4 and then every 10 iterations. A total of 50 FR iterations are performed <ref type="bibr" target="#b39">[40]</ref>. KK layout is performed on graphs smaller than 1000 nodes. This constant was selected so the layout time will not be dominated by KK layout which requires performing an expensive all-pairs shortest path calculation. We use 2000 iterations in each KK layout.</p><p>Layout of G coarsest (Step 7): In this step, the layout of L f inest is extended to a layout for G coarsest . Here, the same method applied in Steps 4-6, is used. Instead of interpolating positions from L i−1 to L i , an initial placement for G coarsest is computed using the existing layout of L f inest . The mapping of nodes between G coarsest and L f inest is performed similarly to Step 4: each graph P f inest n corresponds to several nodes in G coarsest . After computing an initial placement for G coarsest , layout proceeds as discussed in Step 5-6.</p><p>Final un-coarsening (Step 8): This step extends the layout of G coarsest to a layout of the original graph G = G 0 . In each iteration, the layout of G i is used to compute an initial placement for the nodes of the finer graph G i−1 , using the algorithm described in Step 5. Then, the force directed algorithm of Step 6 is applied to the initial placement of nodes in G i−1 .</p><p>In our implementation, we do not perform force directed layout of the final graph G 0 , for which the layout is the most expensive. Instead, using the layout of G 1 and the interpolation algorithm for computing initial positions, we are able to get a good layout for G 0 . When |E| ≈ |V |, the dominating term is |V | 1.5 . However, due to the calculation's simplicity and its parallel implementation, the actual running times are low, as discussed in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">GPU IMPLEMENTATION</head><p>This section describes how the GPU is utilized to accelerate the forcedirected layout. It elaborates on key details, which are briefly introduced in <ref type="bibr" target="#b6">[7]</ref>. Figures that illustrate the overall process are included.</p><p>The key to high performance on the GPU is using multiple processors, which operate in parallel. The GPU schedules the execution of multiple threads, thus hiding memory access latency. Each thread runs a small program called a kernel program, which computes a single element of the output stream.</p><p>In the following, we first describe how the data is stored on the GPU and then how the stream processing is performed <ref type="bibr" target="#b2">[3]</ref>.</p><p>Data Storage: On the GPU, input and output are represented as two-dimensional arrays of data, called textures. The challenge is to map the graph and its elements onto textures, even though graphs do not admit any intuitive and natural representation as balanced arrays. Below, we describe the textures used to represent the graph,</p><p>To represent the graph layout, three textures are used: one texture for the nodes and two textures for the edges.</p><p>The location texture holds the (x,y) positions of all the nodes in the graph. Each graph node has a corresponding (u,v) index in the texture. As shown in <ref type="figure" target="#fig_4">Figure 4</ref>, the nodes in each partition are stored at a rectangular region in the location texture. Recall that Section 4 described how to partition a graph, so that the nodes in each partition are geometrically close and the number of nodes in each partition is similar. This partitioning is critical for the acceleration of the layout on the GPU for two reasons. First, storing neighboring nodes (those that belong to the same partition) together maximizes memory access locality. Thus, it makes efficient use of the GPU's memory bandwidth, since information regarding neighboring nodes will most likely reside in the cache. Second, since the number of nodes in each partition is similar, the amount of computation performed on each node is balanced. Thus, it makes efficient use of the GPU's data parallel architecture, which requires lock-step execution. The location texture also holds the partition number of each node. Given a partition of maximum size c sz , the height and width of each rectangular region representing a partition are set to h partition = max(8, √ C sz ) and C sz h partiton , respectively. Graph edges are represented by a neighbors texture and by an adjacency texture, as shown in <ref type="figure" target="#fig_5">Figure 5</ref>. The adjacency texture, whose size is O(|E|), contains lists of (u, v) pointers into the location texture. These lists represent the neighbors of each node. The neighbors texture holds for each node a pointer into the adjacency texture, to the coordinates of the first neighbor of the node. Pointers to additional neighboring nodes are stored in consecutive locations in the adjacency texture. Doing so improves access locality. The degree of each node is also stored in the neighbors texture. Its size is equal to that of the location texture. The geometric (KD) partitions (described in Section 4, Step 6) are represented using two textures: the partition information texture and the partition center of gravity texture. The partition information texture holds the following information: (u0, v0) -the coordinates in the location texture of the upper left corner of the partition, the width and height of the partition rectangle in the location texture, the number of nodes in the last row of the partition (which may be partially filled), and the number of nodes in the partition. The partition center of gravity (C.G.) texture holds the current (x,y) coordinates of the center of gravity of each partition. Two textures are used to represent partitions not only because each texture is limited in the number of fields (to 4), but also to separate between the constant information and the information modified during the layout computation (i.e., center of gravity).</p><p>The forces computed during layout iteration are stored in two textures in a straightforward manner: the attractive force texture and the repulsive force texture. The attractive force texture contains for each node the sum of the attractive forces F attr exerted on it by its neighbors. The repulsive force texture holds the sum of repulsive forces, F repl : both by nodes in the same partition and by the other partitions in the graph. Both textures have the same dimensions as the location texture and contain the 2D components of the forces, (F x , F y ).</p><p>Stream processing: On the GPU computation is performed by selecting the rendering target, which is the stream, or the texture, to which the output should be written. Next, an appropriate kernel program is loaded. Finally, graphics primitives such as quadrilaterals, are rendered in order to invoke the computation. For each pixel in the primitive (i.e., that the quadrilateral covers), the loaded kernel program is executed. Below we describe the order of invocations of the kernel programs, and their input and output textures. <ref type="figure" target="#fig_6">Figure 6</ref> displays the execution graph of the algorithm. The algorithm is composed of three main stages, each implemented in a separate parallel foreach loop which is executed in parallel for all elements on the GPU. The first loop calculates the center of gravity of each partition. The second loop calculates the forces acting on each node. The third loop displaces nodes using simulated annealing.</p><p>The partition CG (center of gravity) kernel calculates the center of gravity of each partition. The kernel reads information about each partition from the partition information texture and from the location texture and writes its result into the partition center of gravity texture. The GPU operates on all partitions in parallel.</p><p>The repulse kernel, which is the most time consuming kernel, calculates the repulsive forces exerted on each node. The kernel reads information from the partition information, the partition center of gravity, and the location textures. The output of the kernel is written to the repulsive force texture. For each fragment, the kernel first calculates the internal forces (exerted by nodes contained in the partition that the node belongs to). Then, it approximates the forces by all other partitions. Both of these calculations are performed using branching and looping instructions, in order to iterate over all other nodes in a partition and over all other partitions. Since the partitions are similarly sized, good branching consistency is maintained.</p><p>The attract kernel calculates the attractive forces caused by graph edges. It reads the neighbors, adjacency, and location textures and writes its output to the attractive forces texture. For each node, the kernel accesses the neighbors texture in order to get a pointer into the adjacency texture, which contains the (u,v) texture coordinates in the location texture, of the node's neighbors. For each neighboring node, the attractive force is calculated and accumulated.</p><p>Finally, the anneal kernel calculates the total force on each node. It reads the attractive force, repulsive force, and location textures and updates a second copy of the location texture. This double-buffering technique is used due to the inability of the GPU to read and write to the same stream. In the next iteration, the updated location texture is bound as input to the different kernels, thus facilitating feedback in our computation. The anneal kernel also bounds the total displacement of each node according to the current temperature of the layout. This temperature exponentially decreases at every iteration, hence allowing the graph to "freeze" into its final layout.</p><p>In total, the partition CG kernel performs O(|V |) operations; the repulse kernel performs O(|V | 1.5 ) operations; the attract kernel performs O(|E|) operations; and the anneal kernel O(|V |) operations. On the GPU, the computations executed in each kernel, are run in parallel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head><p>Our algorithm was tested on several well-known graphs, commonly used in the graph drawing literature <ref type="bibr" target="#b38">[39]</ref>. The bcsstk* graphs represent stiffness matrices. The Sierpinski graph is a self-similar fractal composed of triangles. The finan512 graph is taken from a linear programming matrix. The flower B graph is constructed by joining 6 circles of length 50 at a single node before replacing each of the nodes by a complete subgraph with 30 nodes (K 30 ) <ref type="bibr" target="#b15">[16]</ref>. The 4elt and crack graphs are 2D Finite-element meshes. The fe * graphs are unstructured meshes related to fluid dynamics, structural mechanics, or combinatorial optimization problems. <ref type="figure" target="#fig_1">Figures 7 -11</ref> show some of the layouts computed by our algorithm, whereas <ref type="table" target="#tab_0">Table 1</ref> gives information about the graphs. Each image is accompanied with a layout  computed by other algorithms <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16]</ref>. It can be seen that the layouts computed by our algorithm compare well with FM 3 <ref type="bibr" target="#b14">[15]</ref>. The bcsstk31 graph ( <ref type="figure">Figure 7)</ref> has a high edge density: |E|/|V | = 16. Moreover, it has a regular mesh-like structure. This regularity is extracted in our layout, as a result of the good partitioning and interpolation of the graph. <ref type="figure">Figure 8</ref> shows the Sierpinski graph, which demonstrates that the symmetry of the graph is maintained, even though the holes in the graph are challenging, compared to more uniform mesh graphs. <ref type="figure" target="#fig_8">Figure 9</ref> demonstrated the layout of the topologically challenging finan512. It is of similar quality to FM 3 and better than the other algorithms compared in <ref type="bibr" target="#b15">[16]</ref>. <ref type="figure" target="#fig_1">Figure 10</ref> shows the flower B graph, which has a relatively high edge density: |E|/|V | ≥ 14. Here, k = 6 is used for partitioning the graph and KK layout is performed on graphs up to 128 nodes. The 4elt graph, shown in <ref type="figure" target="#fig_1">Figure 11</ref>, exhibits large variations in node density and is thus challenging for an algorithm that seeks to maintain equal edge lengths <ref type="bibr" target="#b39">[40]</ref>. The layout manages to show the interesting features of the graph -planarity and holes. Our layout is more uniform and contains less overlaps than the Kamada-Kawai layout from <ref type="bibr" target="#b10">[11]</ref>.</p><p>For the performance tests, a PC equipped with a 2.4 GHz Intel Core 2 Duo CPU and an NVIDIA 8800GTS GPU is used. Our algorithm was implemented in C++, Cg, and OpenGL. <ref type="table" target="#tab_0">Table 1</ref> shows the running time of our algorithm when using only the CPU and using the GPU to accelerate the computation. It also shows the running times for the FM 3 algorithm, produced on a 2.8 GHz Intel Pentium 4 CPU . In addition, it shows our algorithm on a slower machine (3.0 GHz Pentium 4), which is comparable to the machine used for the reported experiments of FM 3 <ref type="bibr" target="#b15">[16]</ref>.</p><p>Compared to FM 3 , using a new GPU-equipped machine, a speedup by a factor of up to 22 times is achieved. The GPU accelerates the total computation time by a factor of up to 5.5. Without the GPU, on comparable hardware, our algorithm runs 2-4 times faster than FM 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">VISUALIZATION OF ISP ROUTER NETWORKS</head><p>We have applied our algorithm to the visualization of Internet Service Provider (ISP) router networks. The router networks of ISPs are comprised of several points of presence (POPs). In each POP, several routers are located. They are connected to the backbone of the ISP and to routers connected to subscribers of the ISP. The data is taken from <ref type="bibr" target="#b0">[1]</ref>. It was collected by using the traceroute tool to determine the route taken by packets traversing the ISP's network <ref type="bibr" target="#b35">[36]</ref>. <ref type="figure" target="#fig_1">Figures 1, 12</ref> show layouts of the networks of several ISPs. Each node in the graph corresponds to a router. Edges represent links between routers. Red nodes are not associated with any ISP in the datathey are used to connect the ISP to the rest of the Internet. The other nodes are color coded according to the ISP they belong to.</p><p>The layouts make evident some facts about these networks. First, most routers of each ISP are clustered together. This can be seen from the large clusters of nodes having the same color (excluding the red nodes). Second, two clusters are evident in <ref type="figure" target="#fig_1">Figure 12</ref> -the brown cluster on the left, which represents an Australian ISP, and the rest of the graph. The yellow and pink nodes represent European ISPs. The black and blue nodes represent North American ISPs. The strongest connections exist between the two North American ISPs. There are good connections between European and North American ISPs. Connections between the Australian ISP and the other ISPs are sparser. Third, the per-ISP clusters are further divided into small clusters of routers, perhaps in the same city or nearby area. For instance, it can be seen that the brown routers belong to a couple of clusters. Fourth, the red external routers, which do not belong to any ISP, are used to link to the external world (outside the ISPs visualized). Fifth, the number of external routers is about the same as the number of internal routers, hence each router has one link on average to the world outside the ISP it belongs to. Sixth, the routers have varying degrees. Some have high degree and are central points (such as the router connecting the brown ISP and the yellow ISP), while others have low degree. <ref type="figure" target="#fig_1">Figure 12</ref> also compares our layout to one computed by GRIP <ref type="bibr" target="#b8">[9]</ref>. It can be seen that GRIP's layout does not display the overall, clustered structure of the graph. Moreover, important edges, such as the ones connecting the brown cluster to the other part of the graph, are not visible. However, the GRIP layout contains less overlap between nodes. To compare the performance, both layouts were computed using only the CPU on a 3GHz Pentium PC. Linux, required for GRIP, is not available on the PC with the GPU. The running time of GRIP was 3 seconds and the running time of our algorithm was 12 seconds. Trying to modify the parameters of GRIP resulted in a higher runtime, but without an improvement in layout quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head><p>This paper has presented a new algorithm for multi-level force directed layout of graphs on the GPU. The algorithm has several key ideas. First, the graph is multi-level and is based on spectral partitioning. Second, the algorithm combines the strengths of both the Kamada-Kawai and Fruchterman-Reingold approaches, in order to compute a good layout fast. Third, a geometric partitioning and interpolation method in proposed, which facilitates the generation of good initial layouts of the finer versions of the graph.</p><p>Moreover, the paper has demonstrated how the GPU can be used to accelerate the algorithm by a factor of up to 5.5 times compared to our CPU implementation.</p><p>Last but not least, it has been demonstrated that the algorithm computes meaningful high quality layouts, while requiring significantly lower running times than existing algorithms of similar quality. Moreover, the algorithm was applied to visualize ISP networks.</p><p>In future research, we plan to implement more parts of the algorithm on the GPU. Acceleration candidates include the Fiedler vector computation and the initial position interpolation. Transitioning to the newly released NVIDIA CUDA development environment may help in getting finer control over the GPU.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Published 14</head><label>14</label><figDesc>September 2007.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>ISP router map. Each node represents a router. Edges link routers. Red nodes are external to the ISPs visualized. Other nodes are colored according to the ISP they belong to: green -Abovenet (US, 664 routers); blue -Exodus (US, 551 routers); black -Tiscali (Europe, 513 routers). A total of 5044 routers and 8043 connections are shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>The power iteration algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Complexity:</head><label></label><figDesc>The most time consuming steps of the algorithm are spectral partitioning and the FR force directed layout. Assuming that each KD partition of the graph contains C s nodes, the asymptotic FR complexity is O(|E| + |V | * (C s + |V | C s )), which is minimized to O(|E| + |V | 1.5 ) when C s = |V |. The spectral partitioning takes O(|V | 1.5 ) [35]. Therefore, the total complexity is O(|E| + |V | 1.5 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Representing a graph on the GPU. Left: A graph spatially partitioned into partitions; right: a corresponding location texture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Representing graph edges on the GPU. Node X has three neighbors: Y,Z and W.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Execution graph of GPU layout (rectangles = streams, ovals=kernels)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>bcsstk31. Red: our layout, black: FM 3 layout Sierpinski 08. Red: our layout, black: FM 3 layout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>finan512. Red: our layout, black: FM 3 layout Fig. 10. flower B. Red: our layout, black: FM 3 layout Fig. 11. 4elt. Red: our layout, black: Kamada-Kawai layout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 .</head><label>12</label><figDesc>ISP router map. Each node represents a router. Edges link routers. Red nodes are external to the ISPs visualized. Other nodes are colored according to the ISP they belong to: blue -Abovenet (US, 665 routers); black -Exodus (US, 554 routers); yellow -Ebone (Europe, 314 routers); pink -Tiscali (Europe, 514 routers); brown -Telstra (Australia, 3756 routers). A total of 10895 routers and 15667 connections are shown. Top left -GRIP layout. Bottom right -our layout.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Graph information and running time [sec.]. Runtime columns show total running times for computing a layout.</figDesc><table><row><cell>graph</cell><cell>|V |</cell><cell>|E|</cell><cell>FM 3 algorithm</cell><cell>our algorithm</cell><cell>our algorithm</cell><cell>our algorithm</cell></row><row><cell></cell><cell></cell><cell></cell><cell>2.8GHz Pentium</cell><cell cols="3">3GHz Pentium 2.4GHz Core2 Duo 2.4GHz Core2 Duo + 8800GTS GPU</cell></row><row><cell>flower B</cell><cell>9030</cell><cell>131241</cell><cell>11.9</cell><cell>3.25</cell><cell>2.21</cell><cell>1.59</cell></row><row><cell>4elt</cell><cell>14588</cell><cell>40176</cell><cell>N\A</cell><cell>8.094</cell><cell>4.973</cell><cell>3.237</cell></row><row><cell>crack</cell><cell>10240</cell><cell>30380</cell><cell>23.0</cell><cell>4.844</cell><cell>3.018</cell><cell>2.44</cell></row><row><cell>bcsstk31</cell><cell>35586</cell><cell>572913</cell><cell>83.6</cell><cell>25.329</cell><cell>14.199</cell><cell>5.754</cell></row><row><cell>bcsstk32</cell><cell>44609</cell><cell>985046</cell><cell>110.9</cell><cell>39.266</cell><cell>22.549</cell><cell>9.617</cell></row><row><cell>bcsstk33</cell><cell>8738</cell><cell>291583</cell><cell>23.8</cell><cell>5.141</cell><cell>2.986</cell><cell>2.486</cell></row><row><cell>fe pwt</cell><cell>36463</cell><cell>144794</cell><cell>69.0</cell><cell>22.985</cell><cell>13.48</cell><cell>5.44</cell></row><row><cell>finan512</cell><cell>74752</cell><cell>261120</cell><cell>158.2</cell><cell>79.268</cell><cell>43.645</cell><cell>12.267</cell></row><row><cell>fe ocean</cell><cell cols="2">143437 409593</cell><cell>355.9</cell><cell>158.849</cell><cell>86.32</cell><cell>15.536</cell></row><row><cell>Sierpinski 08</cell><cell>9843</cell><cell>19683</cell><cell>16.8</cell><cell>5.25</cell><cell>3.127</cell><cell>2.705</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This work was partially supported by European FP6 NoE grant 506766 (AIM@SHAPE) and by the Israeli Ministry of Science, Culture &amp; Sports, grant 3-3421. Some images are courtesy of AT&amp;T Research and the University of Köln. We thank them for allowing us to use them. We thank the reviewers for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Rocketfuel maps and data</title>
		<ptr target="http://www.cs.washington.edu/-research/networking/rocketfuel/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A hierarchical O(N logN) force-calculation algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">324</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="446" to="449" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Brook for GPUs: stream computing on graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sugerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fatahalian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="777" to="786" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">R K</forename><surname>Chung</surname></persName>
		</author>
		<title level="m">Spectral graph theory. Regional Conference Series in Mathematics</title>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="1" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">GPU Gems: Programming Techniques, Tips, and Tricks for Real-Time Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fernando</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A property of eigenvectors of nonnegative symmetric matrices and its application to graph theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fiedler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Czechoslovak Mathematical Journal</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">100</biblScope>
			<biblScope unit="page" from="619" to="633" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Online dynamic graph drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Frishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroVis</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Graph drawing by forcedirected placement. Software-Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M J</forename><surname>Fruchterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Reingold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1129" to="1164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A multi-dimensional approach to force-directed layouts of large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gajer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Kobourov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Geom</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="18" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient algorithms for solving dense linear systems on graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Galoppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">K</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Henson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lu-Gpu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM / IEEE Supercomputing</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Topological fisheye views for visualizing large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="468" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Interactive simulation of deformable bodies on GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Georgii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Echtler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SimVis</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="247" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A multigrid solver for boundary value problems using programmable graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Goodnight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Woolley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lewin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Humphreys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH/Eurographics Workshop on Graphics Hardware</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="102" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<ptr target="http://www.gpgpu.org" />
		<title level="m">GPGPU</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Drawing large graphs with a potential-fieldbased multilevel algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hachul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="285" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An experimental comparison of fast algorithms for drawing general large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hachul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">3843</biblScope>
			<biblScope unit="page" from="235" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A streaming narrow-band algorithm: Interactive computation and visualization of level sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">T</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="422" to="433" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Fast Multi-Scale Algorithm for Drawing Large Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="179" to="202" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Drawing graphs with non-uniform vertices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Working Conference on Advanced Visual Interfaces (AVI&apos;02)</title>
		<meeting>Working Conference on Advanced Visual Interfaces (AVI&apos;02)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Graph drawing by high-dimensional embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="195" to="214" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Simulation of cloud dynamics on graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lastra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH/Eurographics Workshop on Graphics Hardware</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="92" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fourier volume rendering on the GPU using a split-stream-FFT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Von Rymon-Lipinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Hanssen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Keeve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Vision, modeling and visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="395" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An algorithm for drawing general undirected graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kawai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="15" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<title level="m">Drawing Graphs: Methods and Models</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Uberflow: A GPU-based particle engine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kipfer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Segal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/SIGGRAPH Workshop on Graphics Hardware</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="115" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Drawing huge graphs by algebraic multigrid optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiscale Modeling &amp; Simulation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="645" to="673" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Linear algebra operators for GPU implementation of numerical algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="908" to="916" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Real-time 3D fluid simulation on GPU with complex obstacles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific Conference on Computer Graphics and Applications</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="247" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The FFT on a GPU</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moreland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Angel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-GRAPH/Eurographics Workshop on Graphics Hardware</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="112" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The rapid evaluation of potential fields using programmable graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Nyland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Prins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Workshop on General Purpose Computing on Graphics Hardware</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A survey of general-purpose computation on graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Purcell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="21" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">GPU Gems 2 : Programming Techniques for High-Performance Graphics and General-Purpose Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pharr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fernando</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Partitioning sparse matrices with eigenvectors of graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pothen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Liou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Matrix Anal. and Appl</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="430" to="452" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">FADE: Graph drawing, clustering, and visual abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Quigley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing, number 1984 in LNCS</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="197" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Normalized cuts and image segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on PAMI</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="888" to="905" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Measuring ISP topologies with rocketfuel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">T</forename><surname>Spring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="133" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Large Steps in GPU-based Deformable Bodies Simulation. Simulation Modelling Practice and Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tejada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="703" to="715" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Graph Drawing: Algorithms for the Visualization of Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Battista</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Walshaw</surname></persName>
		</author>
		<ptr target="http://staffweb.cms.gre.ac.-uk/˜c.walshaw/partition/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A Multilevel Algorithm for Force-Directed Graph Drawing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Walshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="253" to="285" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Fundamentals of Matrix Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Watkins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>John Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
