<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Declarative Grammar of Flexible Volume Visualization Pipelines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Min</forename><surname>Shih</surname></persName>
							<email>minshih@ucdavis.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Rozhon</surname></persName>
							<email>carozhon@ucdavis.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Fellow, IEEE</roleName><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
							<email>ma@cs.ucdavis.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Kwan-Liu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Davis</orgName>
								<orgName type="institution">University of California</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Davis</orgName>
								<orgName type="institution">University of California</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Davis</orgName>
								<orgName type="institution">University of California</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Declarative Grammar of Flexible Volume Visualization Pipelines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Volume visualization</term>
					<term>direct volume rendering</term>
					<term>declarative specification</term>
					<term>multivariate/multimodal volume data</term>
					<term>animation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents a declarative grammar for conveniently and effectively specifying advanced volume visualizations. Existing methods for creating volume visualizations either lack the flexibility to specify sophisticated visualizations or are difficult to use for those unfamiliar with volume rendering implementation and parameterization. Our design provides the ability to quickly create expressive visualizations without knowledge of the volume rendering implementation. It attempts to capture aspects of those difficult but powerful methods while remaining flexible and easy to use. As a proof of concept, our current implementation of the grammar allows users to combine multiple data variables in various ways and define transfer functions for diverse input data. The grammar also has the ability to describe advanced shading effects and create animations. We demonstrate the power and flexibility of our approach using multiple practical volume visualizations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Direct volume rendering (DVR) is a well-accepted technique for visualizing 3D volumetric data in many scientific and engineering domains. Driven by the growing need and increasing standard of visualizing volume data, a wide variety of enhancements have been developed to improve different aspects of DVR. GPU acceleration especially has made it a powerful visualization tool. However, in many problem domains, the commonly found DVR tools may not be sufficient. Since the feature of the data the visualization should reveal can vary largely according to the domain-specific tasks to perform, specialization of rendering is often required in order to achieve effective visualization. As most existing DVR tools provide only limited flexibility to customize the rendering, the need of specialized visualization is usually hard to meet.</p><p>DVR involves the process of sampling the data volume, mapping the sampled values to color and opacity values, projecting the mapped values onto a 2D image, and compositing the values for each pixel of the image. Among these steps, mapping is the most critical step in achieving expressive visualization. <ref type="figure" target="#fig_0">Fig. 1</ref> illustrates the visualization process, with special emphasis on the sample-level rendering pipeline that determines the color and opacity for given sampling points. In practice, each step of the pipeline can be altered to create specialized rendering effects for various visualization purposes. For example, the normal 1D transfer function can be replaced by a 2D transfer function in order to achieve advanced classification. Advanced shading or nonphotorealistic rendering (NPR) techniques can be applied after the classification step to help illustrate features of interest within the data.</p><p>In the case where multiple data fields are visualized simultaneously, the pipeline can become even more complicated. Scientific simulations such as computational fluid dynamics (CFD) often require visualizing multivariate data. In medicine, combining the use of different imaging modalities (PET + CT, for example) can provide more comprehensive information about the patient. In order to better convey insight within these data, the visualization often needs to combine information from multiple data fields.</p><p>Creating a volume visualization often involves an iterative process. Within this process, the user keeps adjusting the rendering configuration according to the interactive visual feedback. Minor adjustments that do not involve changes in the pipeline, such as editing transfer function, can be easily done with traditional GUI applications that domain scientists are usually familiar with. However, it is more complicated when the user wants to alter the pipeline. For example, changing the number of fields intermixed in multi-volume DVR involves changing the sample-level pipeline. According to our experiences collaborating with domain scientists, such pipeline changes often happen in the early exploration stage of the iterative process. For such tasks, existing systems are mostly either not flexible enough (capable for only some certain scenarios) or too difficult to use (requiring DVR implementation knowledge). This motivates us to develop a novel volume visualization tool that enables domain scientists to flexibly and interactively change the visualization pipeline without going deeply into the DVR implementation. Our tool should also be easily adopted by system designers and visualization researchers to develop specialized visualization systems.</p><p>We consider declarative visualization as a good solution. Declarative visualization design has long been used by the information visualization community <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b39">40]</ref>. It allows decoupling the specification of the visualization from the actual execution model. Designers specify what is shown instead of how it is achieved. This hides a great portion of complexity in designing and implementing a complicated pipeline from the visualization designers.</p><p>In this paper, we present a declarative grammar for flexible volume visualization pipeline design. To the best of our knowledge, this is the first work using declarative grammar to specify different volume visualization pipelines. The goal of our design is to ease the difficulty of customizing the rendering process while maximizing flexibility. The language design focuses on the ability to specify the process of getting color and opacity for each given sample point. The target users are both visualization system designers (programmers) and general end users (non-programmers). For system designers, our technique allows fast prototyping. Our language can be implemented as an application program interface (API), which can be used as the basis of a rendering engine for a system. End users, with some training, can directly operate our tool to create specialized visualizations for their visualization or presentation purposes.</p><p>The major contribution of our work is a declarative language and system design for the customization of multivariate volume visualization pipelines. Specifically, our grammar enables users to specify the following aspects of a pipeline:</p><p>• Data variables and their use. Data variables can be used directly as the input of color and opacity mapping, be used to derive a new scalar field, or be used as a volumetric filter.</p><p>• Color and opacity mapping. Color and opacity can be mapped from either a single data field or mutliple data fields. 2D transfer functions are also possible to use. . Volume visualization pipeline. In the rendering process of the datalevel pipeline, the data volume is sampled. Each sample is processed through a sample-level pipeline, in which the sampled value is mapped to color and opacity value, shaded, and then composited into the pixel.</p><p>• Advanced shading effects. Lighting with shadows is supported. Non-photorealistic rendering effects such as tone shading, silhouettes, and style transfer functions <ref type="bibr" target="#b7">[8]</ref> are supported.</p><p>• Multi-volume rendering. Multiple volumes can be specified. Different sample compositing operators can be used.</p><p>• Animation. As a natural extension of the grammar, parameter values can be animated by setting keyframes in the specification.</p><p>The prototype system we implemented demonstrates an execution framework for the proposed language as well as a reference design of the graphical user interface (GUI) components that complements the text-only interface. The GUI components allow fine tuning of the resulting visualization, simplifying aspects of the visualization that are difficult or unnecessary to describe textually. Several examples are presented, which demonstrate the flexibility of our design as well as its ease of use. Complex visualizations can be expressed in relatively small scripts, which are reproducible and can be shared among users, greatly enhancing the usability and expressiveness of DVR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>To perform volume data analysis and visualization tasks, domain scientists often use off-the-shelf visualization systems such as Paraview <ref type="bibr" target="#b3">[4]</ref>, VisIt <ref type="bibr" target="#b11">[12]</ref>, Amira <ref type="bibr" target="#b1">[2]</ref>, Osirix <ref type="bibr" target="#b25">[26]</ref>, and various other applications dedicated to the task. Although these systems allow users to easily create and configure visualizations, most of them provide very limited flexibility to further customize the visualization. On the other hand, with their own source code and low-level libraries, users can create visualizations that use arbitrary algorithms, but the steep learning curve prevents many from profiting from this approach. In recent years this gap has been widened by the prolific use of parallel architectures such as GPUs (graphics processing units). GPUs are extremely useful for achieving interactive frame rates, but GPU programming is not a simple task for novice programmers. Even those with a great deal of experience may not be able to fully leverage the computing power of GPUs due to differences in architecture and programming paradigms. To close this gap between graphics programmers and typical users, researchers have investigated a variety of approaches, each providing different levels of abstraction to the underlying algorithms and data structures.</p><p>At one of the lowest levels of abstraction, software libraries provide an encapsulation of low-level algorithms and data structures. There are several volume rendering libraries <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b40">41]</ref> as well as visualization libraries incorporating volume rendering functionality <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b37">38]</ref>. Using these libraries to create visualizations requires a lot of experience in programming with general purpose languages, usually C or C++. Writing this kind of software also involves a great deal of low-level system programming for the creation of a graphics environment and the parallelization of the code for different target architectures. To make dealing with such low-level interfaces easier, domain-specific languages (DSLs) have been designed to enable users to express algorithms in the domain-specific semantics they are familiar with and hide more complicated implementation details, allowing the user to focus on development of the core algorithm.</p><p>Some of these DSLs incorporate volume processing and visualization, addressing different aspects of the data analysis and visualization pipeline. Scout, presented by McCormick et al. <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> and Jablin et al. <ref type="bibr" target="#b17">[18]</ref>, is a visualization DSL that provides the ability to express mappings as mathematical expressions and queries. This work shares many common features with our approach, such as the support of multi-dimensional transfer functions, multivariate visualization, and computing derived fields. Hašan et al. <ref type="bibr" target="#b16">[17]</ref> present Shadie, a DSL that enables customized volume rendering. The framework provides an environment where users can pass python-like code snippets describing the desired visualization to the renderer as arguments. Presented by Chiw et al. <ref type="bibr" target="#b12">[13]</ref> and Kindlmann et al. <ref type="bibr" target="#b18">[19]</ref>, Diderot provides a high-level computation model, allowing programmers to use high-level mathematical notation to express mathematical concepts, with special emphasis on support for higher-order tensor operations. Vivaldi was introduced by Choi et al. <ref type="bibr" target="#b13">[14]</ref> as a DSL that focuses on volume processing and visualization on a distributed heterogeneous computing system. Vivaldi's Python-like grammar allows domain experts to easily implement their specific algorithms without worrying about the complex memory management and data communication issues that arise in distributed computing. Rautek et al. <ref type="bibr" target="#b28">[29]</ref> present ViSlang, a DSL-based system for scientific visualization that focuses on the integration of multiple DSLs into one system. Whereas our language is declarative, previous visualization DSLs mostly specify volume rendering imperatively. Some DSLs (Shadie <ref type="bibr" target="#b16">[17]</ref>, for example) require writing all of the code to evaluate the volume rendering integral, which is not easy for novice users even with the abstractions provided by the DSL. Some other DSLs (Scout <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref>, for example) hide this complexity and only require an implementation of the mapping code. However, this still requires users to have at least some experience in programming.</p><p>Many visualization frameworks adopt a dataflow methodology in order to encapsulate reusable software components, providing an abstraction level that is higher than procedures but lower than complete applications. In these frameworks a visualization pipeline is represented as a dataflow graph, in which each node represents a component. The components (also called modules, processors) implement specific visualization functions such as filtering, mapping, and rendering. The functions are applied to the data as the data flows through these components, and the entire graph forms a complete visualization algorithm. Scientific visualization systems or libraries that adopt the dataflow concept include AVS <ref type="bibr" target="#b35">[36]</ref>, OpenDX <ref type="bibr" target="#b21">[22]</ref>, SCIRun <ref type="bibr" target="#b38">[39]</ref>, VTK <ref type="bibr" target="#b33">[34]</ref>, and VisTrails <ref type="bibr" target="#b4">[5]</ref>. More recently Voreen <ref type="bibr" target="#b24">[25]</ref> and Inviwo <ref type="bibr" target="#b34">[35]</ref> are introduced, which focus more on GPU-based volume visualization. Many dataflow systems provide a drag-and-drop interface for users to operate the dataflow graph. Through the interface, users can place new components, configure them, and create connections between them. However, most of the frameworks mentioned above handle volume rendering only in the data level, which means the volume rendering functionality is provided as a single indivisible module and the only changeable parts are pre-processing and post-processing steps. The sample-level rendering pipeline, which determines the color and opacity of each sample point, however, has very limited customization.</p><p>In the context of GPU-based volume rendering, enabling flexible sample-level pipelines usually requires dynamic generation of GPU programs. Plate et al. <ref type="bibr" target="#b27">[28]</ref> use graph-based dataflow interface for shader program editing in their dynamic shader generation framework for multi-volume rendering. The dataflow graph represents the process applied to each ray sample within the volume and determines the color and opacity of the sample. Arens <ref type="bibr" target="#b2">[3]</ref>   <ref type="bibr" target="#b29">[30]</ref> shader framework is a list, in which the components of a volume rendering pipeline are arranged linearly. Although these three approaches support creation of sample-level rendering pipelines with reusable building blocks, they are still not easy for non-expert users to use because only low-level building blocks are provided. Assembling these operations into a meaningful volume rendering pipeline requires the user to have some knowledge about the volume rendering algorithm. The multi-volume rendering system presented by Rößler et al. <ref type="bibr" target="#b30">[31]</ref> provides a higher-level abstraction of rendering pipeline build-ing blocks, which represent the specification of the pipeline as a tree structure. However, compared to the above approaches the specification capability of this framework is more limited.</p><p>Many information visualization toolkits have already adopted declarative grammar for specifying visual encodings. Low-level grammars such as Protovis <ref type="bibr" target="#b5">[6]</ref>, D3 <ref type="bibr" target="#b6">[7]</ref>, and Vega <ref type="bibr" target="#b32">[33]</ref> are often used as a basis for customized visualization tools. On the other hand, higher-level grammars such as ggplot2 <ref type="bibr" target="#b39">[40]</ref> and Vega-Lite <ref type="bibr" target="#b31">[32]</ref> allow concise specification of visualizations, facilitating fast search within the space of visualization. However, these grammars are not suitable for volume visualization. The infrastructures of these grammars are designed to support general information visualization and do not provide much benefits to DVR specification. Furthermore, the extra generalities of these grammars may increase the users' burden or even confuse them. For example, both ggplot2 and Vega-Lite allow to use a variety of visual encoding channels. However, in DVR-based volume visualization, the only visual encoding channels available are color and opacity. The spatial channels (x, y, and z) are already tied to the intrinsic spatial property of the data and should not be changed by the user. Other channels, such as size and shape, do not make much sense in DVR. In addition, some concepts critical to DVR, such as shading, are lacking in these grammars. Our declarative grammar for volume visualization is partially inspired by these grammars, providing a high-level abstraction for volume visualization specification, while keeping sufficient flexibility to support sophisticated visualization needs. The main difference between our grammar and these grammars is that our grammar focuses more on the needs of specification of DVR-based volume visualization and avoids unnecessary generality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">GRAMMAR DESIGN</head><p>The goal of our grammar's design is to allow users to declaratively specify the visual appearance of volume rendering without considering the implementation details. The specification describes what we call the sample-level pipeline, which computes the color and opacity of each sample point of the volume. To hide unnecessary details, the camera model and the compositing scheme are kept standard, i.e., a typical perspective/orthogonal camera model as well as a front-to-back/backto-front alpha blending scheme is adopted. We model a sample-level pipeline as a set of fields and mappings. A field defines a function of sample point positions. The output value of the function can be a scalar, a vector, or even a tensor. In the context of volume rendering, scalar fields, fields whose output is a scalar value, and color-opacity fields, fields whose output is a vector with three color channels plus an alpha channel, are used. A mapping describes a function transferring an input field (or multiple input fields) into an output field. For volume rendering color and opacity mappings are used to acquire the color and opacity values of sample points. Sophisticated pipelines can be specified by connecting various fields together with carefully designed mappings. The final result of color and opacity mapping can then be used for shading computation and composited into the final image.</p><p>In this section we present a grammar that uses the described rendering pipeline model. The grammar provides several ways to specify a scalar field, using a volume data source, a field function expressed by a formula, or even the result of filtering or mapping another scalar field. A color-opacity field is specified by the source scalar field(s), the transfer function to map the field value(s) to color and opacity, the shading method, and other operations that alter the color and opacity. Multivolume rendering is supported by combining multiple color-opacity fields with field composition operators. A complete pipeline specification consists of a single color-opacity field specifying the output of the pipeline. The language is based on JSON (JavaScript Object Notation), an open-standard text-based format. We chose JSON because it is a widely used standard, is easy to parse, and it has sufficient expressiveness for hierarchical structures. Since JSON is supported in many programming languages, it is easy to integrate our grammar into a scripting system for a visualization toolkit. However, it would also be possible to implement the grammar as an application program interface (API) in a general purpose programming language. Please see Appendix A in the supplementary materials for a detailed documentation of the language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Scalar Field Specification</head><p>A scalar field, denoted by the field keyword, represents a function from sample points in the volume to scalar values. There are various ways to define a field, listed below. They can be composed just as functions. Scalar fields can be used as inputs of color and opacity mapping in color-opacity field specifications or as input variables for specifying other scalar fields. They can even be used to define the values of scalar parameters. The variety of ways to combine the fields enriches the expressiveness of the grammar.</p><p>Fields can be specified using a given data source name:</p><formula xml:id="formula_0">"field": " density "</formula><p>where the volume data source specified would be used to obtain the field's values. Interpolation is performed automatically. It is also possible to give a formula to describe the field function, for instance, the following "field": "abs( density1 -density2 )"</p><p>declares a field that takes the absolute value of the difference between two data sources. Besides directly giving the formulas, scalar fields can also be analytically defined through the use of preset shapes:</p><p>"field": { " sphere ": { " center ": [50, 50, 50], " radius ": 30, " fillValue ": 0.5 // the value filled in the sphere } } Preprocessing can be applied to scalar fields to form new fields, for example, the code "field": { " boxFilter ": { "field": " vorticity ", "size": 5 // the filtering kernel size } } applies a low-pass filter to the source data to form a scalar field. Volume clipping and transformation can be specified as sub-blocks of a field: Finally, scalar fields can be defined in advance and reused: "defs": { " my_var ": " density " } ... "field": " my_var " // use defined field</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Color-opacity Field Specification</head><p>The specification of a color-opacity field involves color mapping, opacity mapping, and an optional shading and filtering process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Color and Opacity Mapping</head><p>Here is an example color-opacity field specification:</p><p>{ "color": { "field": " density ", "range": [0, 100], // data value range "map": ["blue", "green", "red"] // colormap }, " opacity ": { "field": " density ", "range": [0, 100], // data value range "map": [0.0, 0.1, 0.1, 0.3, 0.3] // opacity map } }</p><p>The color block contains the specification of the source scalar field, the mapped value range, and the colormap used for the color mapping. The colormap is given by the map property, which, for convenience, can be specified in several ways, as shown in the following: "map": "red" // monocolor "map": ["blue", "green", "red"] // a colormap with three colors "map": " rainbow " // colormap preset Similarly, the opacity block also contains field, range, and map properties. But since the opacity mapping has only a single output variable (the opacity value), the map property of opacity is specified by a list of opacity values instead of colors, and the resulting mapping function is a piecewise linear function defined by these values. Using a formula to define the opacity mapping function is also possible. For isosurfacing, an isosurface property can be added into the opacity block, specifying the isovalue.</p><p>Multi-dimensional transfer functions have proven helpful for classification when one-dimensional ones do not work well. To extract interesting features, supplementary variables such as gradient magnitude and occlusion spectrum <ref type="bibr" target="#b14">[15]</ref> are used as the second dimension of 2D transfer functions. Visualizing multivariate data is another natural application of multi-dimensional transfer functions <ref type="bibr" target="#b19">[20]</ref>. Our grammar provides an intuitive way to specify the use of multi-dimensional transfer functions. Multiple variables are used as the input of the transfer function when a list is given as the input field of color and opacity mapping, for example:</p><p>" opacity ": { field": ["var1", "var2"] // 2D transfer function }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Shading</head><p>In a typical volume rendering pipeline, an optional shading step, usually gradient-based Phong (or Blinn-Phong) shading, can be applied after the classification (mapping) step in order to reveal surface shapes within the rendering. Non-photorealistic rendering techniques like tone shading <ref type="bibr" target="#b15">[16]</ref> can also be used for enhancing surface shape perception. Another NPR technique, silhouettes, can be used to clarify the spatial relationships among objects within the data. Artistic style shading <ref type="bibr" target="#b7">[8]</ref> is another NPR technique, useful for creating illustrations.</p><p>We generalize the shading process to any kind of post-classification process that alters the sample color and opacity before blending the sample color into the accumulated ray color or the framebuffer (depending on which volume rendering scheme is applied). Conceptually, this process can be seen as a mapping from one color-opacity field to another. By default, these operations are disabled in our grammar. The user can turn on them by using the corresponding sub-blocks in the color-opacity field specification as seen in the examples below.</p><p>" lighting ": { // Blinn -Phong lighting " ambient ": 0.2, " diffuse ": 0.8, " specular ": 0.4, " shadow ": true } " toneShading ": {...} // tone shading " edgeLine ": {...} // silhouettes " style": " stippling " // artistic style Scalar parameters within these blocks can also be specified by giving scalar fields, making spatially-varying materials in lighting possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Filtering</head><p>In order to show interesting features, users often want to hide unimportant regions within the data to avoid undesired occlusion. This is sometimes done with transfer function settings or clipping. However, there are still cases where these tools do not work well. Our grammar provides a way for users to conveniently specify the filtering condition by assigning a filter field. The filtering syntax is useful for the adoption of segmentation volumes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{</head><p>" color": {...}, " opacity ": {...}, " filter ": { "field": " vessel_seg " // use a segmentation volume as a mask } }</p><p>The above example specifies a color-opacity field applying a segmentation volume as a mask, showing only the interesting portions of the data. Range selection or mapping is also supported. The following code shows an example using a user-provided distance field to show only the regions close enough to the features:</p><p>{ "color": {...}, " opacity ": {...}, " filter ": { // specify filtering "field": " distance " // the field used for defining the filter "range": <ref type="bibr">[0,</ref><ref type="bibr" target="#b9">10]</ref> // the visible data range } } By using shape fields as filter fields, cutaway or ghosting effects can be achieved. The specified filter field is used to modulate each sample's opacity value to control the visibility. Note that although the filtering function can also be done by specifying a complicated opacity mapping, the filtering syntax provides users a convenient and straightforward tool to do this common visualization task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Field Composition</head><p>Multi-volume rendering is one of the key features supported by our grammar design. There are several ways to intermix the contributions of multiple intersecting volumetric objects <ref type="bibr" target="#b10">[11]</ref>. Image-level intermixing renders volumes separately and composites the renderings afterwards. Although it is easy and cheap, the incorrect depth relationship may result in confusing visualizations. In contrast, accumulation-level intermixing, the most common approach for multi-volume rendering, composites the volumes in a per-sample manner, resulting in depthcorrect renderings. With our grammar, accumulation-level intermixing can be specified by using field composition operators. Below is an example using the blend operator, which does a front-to-back alpha blending to combine two color-opacity fields. Composition operators take a list of fields as input, and produce a single field as output. Other operators include max, min, add, subtract, and multiply. These composition operators can also be applied to scalar fields, and they can be nested to express a complicated combination of fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Animation Specification</head><p>Our design also includes the ability to specify animation for all vector and scalar parameters individually. By replacing a vector or scalar property value with an animation block denoted by the keyword animate, the relevant parameter can be animated. This allows animation to be specified at the granularity of each parameter, rather than a global animation on the entire rendering.</p><p>An animate block is specified by only two required arrays, times and values, which specify the time and value of each keyframe of the animation. An arbitrary amount of keyframes can be specified in this manner. The system will then interpolate values between the keyframes using the interpolation method specified. Below is a small example that illustrates this specification. In this example, the rotate parameter of the transformation is animated. The keyframes at 0 seconds, 5 seconds, and 10 seconds with the rotation vectors specified would be generated. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Simplifications</head><p>One key aspect of our grammar is that it allows the omission of property settings. The ambiguities due to the missing property values are resolved by the system by assigning default settings. This is especially helpful because in the early stage of pipeline designing, users may not care about the precise configuration of each component of the pipeline and may want to defer the exact parameterization, simplifying the process. This feature also reflects the idea that our grammar specifies pipelines instead of the final visualization. To help users get close to the desired final visualization, the system provides the ability to fine tune the parameters. Our reference design of such a system is described in Sect. 4. By omitting unnecessary properties, the specification of a color-opacity field can be simplified as below:</p><p>{ "color": { // use default range and map settings "field": " density " }, " opacity ": { "field": " density " } }</p><p>This specification would adopt the default color and opacity mapping defined by the system, along with the scalar value range fitting the source data field. Shading can also be added without any parameter given. Below is an example in which Blinn-Phong lighting is applied using the default material parameters. To further ease the users' coding work, we also apply the following simplification rule to the grammar: child specification blocks can inherit some properties from parent or ancestor blocks. More specifically, if a property of a child block is omitted while it is defined in the parent or any ancestor block, the parent or the ancestor block's setting would be used. This syntactic sugar is inspired by the fact that in most use cases, the color mapping's source field is exactly the same as the opacity mapping's. With this simplification rule, the field of color and opacity can be moved a level up to be a property of the color-opacity block, and therefore no redundant field specification is needed. Combining this rule with the property omission rule, a pipeline specification can be as simple as the code shown below: { "field": " density " // both color and opacity mapping use this } Moving the essential field property out of color and opacity blocks allows us to introduce a simpler form for specification of these two blocks, providing a straightforward way to specify the source field and the transfer function: { "field": " density ", "color": ["blue", " yellow ", "red"], " opacity ": [0.0, 1.0] } Another example of the use of the inheritance rule is clipping/transformation. For multivariate volume visualizations, every variable field usually applies the same clipping and transformation setting in order the maintain spatial consistency. Thus, we move clipping and transform blocks from individual color-opacity fields to the parent composition operation block: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SYSTEM DESIGN AND IMPLEMENTATION</head><p>As a proof of concept, we implemented an interactive visualization system incorporating a scripting interface that accepts specifications written in the presented grammar. <ref type="figure">Fig. 2(a)</ref> shows the graphical interface of our system. Besides the rendering window <ref type="figure">(Fig. 2(a2)</ref>), the system provides a scripting panel <ref type="figure" target="#fig_0">(Fig. 2(a1)</ref>) for the user to declare the pipeline specification and a properties panel <ref type="figure">(Fig. 2(a3)</ref>) providing controls for the rendering parameters. The underlying architecture involving the scripting function is illustrated in <ref type="figure">Fig. 3</ref>. The implementation is based on C++ and OpenGL, leveraging the GPU's computing power for real-time volume rendering. In this section, we describe the significant elements within our implementation and discuss the challenges as well as our design decisions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Translator and the Dynamic Volume Renderer</head><p>The main challenge in implementing our specification language comes from the flexibility of the sample-level rendering pipeline. OpenGLbased volume renderer implementations typically use shader programs to apply per-sample operations for sample processing. These programs are critical to apply the full computational power of the GPU, so to interactively edit sample-level pipelines, there must be a way to change shader programs during runtime. We solve this dynamic shader generation problem through the use of shader graphs, i.e., we organize building blocks of a shader program using a graph structure where each node manages a program snippet and each link between two nodes represents the execution dependency between the nodes. Shader graphs are also adopted by <ref type="bibr" target="#b27">[28]</ref> and <ref type="bibr" target="#b2">[3]</ref>, but in contrast with these works, we use the shader graphs internally rather than exposing the graphs directly to users. The core part of our implementation consists of two modules: a translator that converts the JSON specification into an intermediate representation (IR), and a dynamic GPU volume ray caster based on the IR. Correspondingly, the execution of a pipeline specification can be divided into two phases: the translation phase and the rendering phase.</p><p>In the first step of the translation phase, the translator parses the JSON document and stores the specification in an internal tree-based structure that holds the property settings. For missing properties, The translator resolves the ambiguities by using default values or the values naturally derived from other given properties.</p><p>Next, the translator constructs the shader graph according to the specification structure and connects the specification structure nodes with corresponding shader graph nodes. After the shader graph is constructed, the GLSL shader code is generated by traversing the graph (which will always be a directed acyclic graph) in a topological order. The generated GLSL code, which computes the color and opacity of each ray sample, is then inserted into the ray traversal loop of a volume ray caster shader to form a complete fragment shader program. The shader graph and the specification structure comprise the IR of the rendering pipeline.</p><p>For any animation blocks in the specification, the translator creates keyframes corresponding to the times and values specified by the script and sends them to a keyframe manager. When the user chooses to play the animation, the animator interpolates the keyframe values and update the values stored in the IR.</p><p>In the rendering phase, the renderer first walks the IR (which contains the shader graph) to apply necessary data updates. The updates involve requesting data from the data manager when new data sources are specified and calculating derived data such as filtered volumes or shadow volumes. The renderer also resolves the domain of rendering by unifying the bounding boxes of each visible field in the specification. Next, the shader program is configured by updating uniform variables and binding textures and is then executed on the GPU to perform volume rendering. Although our renderer implementation is based on the volume ray casting algorithm, the translator and the IR are not limited to a ray casting scheme. The primary output of the shader graph is just a function determining the sample color and opacity, so in theory it is possible to integrate it into a volume renderer with any other kind of rendering scheme such as texture slicing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Dynamic Parameter Configuration Interface</head><p>Since volume rendering is a complicated process, there are many parameters that users can configure. Although our grammar design allows users to assign parameter values through code, specifying every detail of the visualization using a text-based interface can be tedious and error-prone work. Hence, a graphical user interface (GUI) that facilitates fine-tuning the visualization parameters is desired. As our system incorporates flexible visualization pipelines, the number and types of controllable parameters can vary dramatically according to the pipeline specification applied. Therefore, our system provides a control panel with dynamic layout that contains essential controls for the applied pipeline specification. When the user updates the specification, the content of the control panel will change accordingly to meet the need of parameter configuration of the current pipeline. On the other hand, when the user interacts with the control panel, the specification shown in the scripting panel will also reflect the changes made by the user. In terms of implementation, the dynamic parameter controls are constructed at the same time the translator generates the intermediate representation of the pipeline. The controls are linked to the corresponding specification structure nodes, so the changes in the GUI result updating of the specification. <ref type="figure">Fig. 2(b)</ref> and (c) demonstrate how the dynamic control panel works. In <ref type="figure">Fig. 2(b)</ref>, a simplest pipeline is specified. Therefore, the panel only provides the most essential controls for a color-opacity field, the { "blend": [ { "id": "domain_boundary", "field": "mixture_fraction", "color": "white", "isosurface": 0.045, "lighting": {} }, { "id": "cool_flame", "field": "ketohydroperoxide_mf", "lighting": {} }, { "id": "hot_flame", "field": "temperature_distance" } ] } drop-down list for selecting the source field and the editor for the coloropacity mapping. In <ref type="figure">Fig. 2(c)</ref>, lighting is added to the specification. Since the grammar allows omission of properties, the user can leave the lighting block blank. Once the user applies the new specification, the controls for lighting parameters including the light source position and the material parameters are added to the control panel, and the user can tweak the lighting settings. The changes made with the GUI controls immediately update the parameters in the specification shown in the scripting panel. This design elegantly hides unnecessary details from the user, helping the user focus on the tasks they are most interested in each work stage.</p><p>Our system also provides a dataflow view for advanced users to directly manipulate the generated shader graph. The users can verify the pipeline specification through this interface. { "blend": [ { "id": "ct", "field": "mouse_ct", "color": ["white", "black"], "opacity": [0, 0.003, 0.5, 1], "clipping": { }, "lighting": { "shadow": true }, "filter": { "sphere": { } } }, { "id": "pet", "field": "mouse_pet", "color": "rainbow", "transform": </p><formula xml:id="formula_1">{ } } ] } (b) (c) (e) (d) (a) (a) (a') (b) (c) (d) (e) (d')</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXAMPLE VISUALIZATIONS</head><p>In this section, we use a range of visualizations to demonstrate how our grammar facilitates the creation of expressive volume visualizations with sophisticated rendering pipelines. Both scientific simulation data and medical imaging data are used in these visualizations. <ref type="figure" target="#fig_7">Fig. 4</ref> shows a visualization of a combustion simulation dataset. The simulation assists in the study of turbulent mixing effects on autoignition, which is relevant to diesel engine design. The selected timesteps of the dataset show a two-stage ignition process of n-dodecane. The simulation begins with a first-stage low-temperature ignition process, which is represented by the cool flame appearing in <ref type="figure" target="#fig_7">Fig. 4(a)</ref> and growing in <ref type="figure" target="#fig_7">Fig. 4(b)</ref>. As the cool flame dies out, the process enters the second stage. The orange-red high-temperature flame ignites <ref type="figure" target="#fig_7">(Fig. 4(c)</ref>) and grows quickly towards the edge of the jet <ref type="figure" target="#fig_7">(Fig. 4(d)</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Combustion</head><p>The code in <ref type="figure" target="#fig_7">Fig. 4</ref> shows the specification used for generating all the renderings displayed in this figure. The specification defines three color-opacity fields, the mixture fraction, the keto-hydroperoxide, and the distance to high-temperature features. The three fields are blended together in a per-sample manner. The white isosurface in the mixture fraction field represents a constant mixing ratio between the fuel and the air, showing the overall structure of the combustion jet. The keto-hydroperoxide (a precursor species for low-temperature ignition) highlighted in blue (the cool flame) indicates the low-temperature ignition, while the high-temperature features in orange-red (the hot flame) show the high-temperature ignition. The resulting multi-volume rendering is informative and is feasible for analysis and storytelling purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Mouse PET/CT Scan</head><p>Multimodal medical image datasets consist of scans of the same subject using multiple acquisition methods. Among the medical imaging techniques, the hybrid of positron emission tomography (PET) and computed tomography (CT) is a widely used method. By combining PET and CT, the abnormal metabolic activity detected with the PET scan can be localized using the CT scan. Thus visualizing such a dataset demands that the PET image is clearly shown while the CT image provides spatial information. <ref type="figure" target="#fig_8">Fig. 5</ref> demonstrates a complete workflow to interactively create a visualization of a mouse PET/CT scan using our system. Each subfigure and the corresponding code block are denoted with identical letters. First, the CT volume is rendered using a temporarily specified transfer function <ref type="figure" target="#fig_8">(Fig. 5(a)</ref>). We use the graphical transfer function editor to tweak the color-opacity mapping, resulting in the rendering shown in <ref type="figure" target="#fig_8">Fig. 5(a')</ref>. To remove the bed under the mouse, we add an empty clipping block and adjust the parameters through the control panel, resulting in the picture shown in <ref type="figure" target="#fig_8">Fig. 5(b)</ref>. Next, the lighting block is added, with shadow turned on to clarify the skeleton's shape. { "defs": { "qcr15": { "boxFilter": { "field": "qcriterion", "size": 15 } }, "qcr49": { "boxFilter": { "field": "qcriterion", "size": 49 } } }, "blend": [ { "id": "small", "field": "qcriterion", "lighting": {}, "filter": "(qcr49&gt;20.0?1.0:0.0)" }, { "id": "medium", "field": "qcr15", "lighting": {}, "filter": "(qcr49&gt;20.0?1.0:0.0)" }, { "id": "coarse", "field": "qcr49", "lighting { "field": "kidney", "blend": [ { "id": "outline", "isosurface": -750 }, { "id": "bone", "style": "ToonGray", "filter": { "field": "seg_bone" } }, { "id": "vessel", "style": "ToonPink", "filter": { "field": "seg_vessel" } },</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{</head><p>"id": "kidney", "filter": { "field": "seg_kidney" }, "lighting": {} }, { "id": "tumor", "filter": { "field": "seg_tumor" }, "lighting": After this step, we render the CT volume ( <ref type="figure" target="#fig_8">Fig. 5(c)</ref>). As our goal is to render both the CT volume and the PET volume in the same image, we then add a new color-opacity field showing the PET volume and blend it with the CT field. A transform block is used for registration since the images from the two modalities are not aligned originally. We do not apply Blinn-Phong lighting for the PET field because we want to show the intensity distribution of the PET volume instead of certain surfaces. The resulting image ( <ref type="figure" target="#fig_8">Fig. 5(d)</ref>) shows a hybrid PET/CT rendering. However, this visualization still has an issue: the interesting region of the PET image is occluded by the ribs from the CT image ( <ref type="figure" target="#fig_8">Fig. 5(d')</ref>). To alleviate the occlusion while keeping the spatial relationship clear, we use a spherical filter to reduce the opacity of the occluding ribs ( <ref type="figure" target="#fig_8">Fig. 5(e)</ref>). The final rendering is shown in the top-right of <ref type="figure" target="#fig_8">Fig. 5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Turbulence</head><p>In this example, a dataset from the Johns Hopkins Turbulence Database <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b26">27]</ref> is visualized. The simulation depicts the hierarchical nature of vortex tubes in turbulence <ref type="bibr" target="#b9">[10]</ref>. However, revealing this hierarchical structure with a standard volume rendering pipeline is challenging because simply plotting the vorticity gives an uninformative picture in which many thin vortex tubes are intertwining in a crowded manner. To solve this problem, we need to identify the coarsescale vortices first and then display the small-scale vortex tubes only within the coarse-scale vortex tubes. The task of identifying coarsescale vortices is done by low-pass filtering the Q-criterion field (the indicator of vortices) with the boxFilter specification. Here we use two different sizes of the box filter to produce a medium-scale field and a coarse-scale field, respectively (see the qcr15/qcr49 field definition in the code shown in <ref type="figure" target="#fig_9">Fig. 6</ref>). To show the vortices within vortices, the coarse-scale field is used in a threshold test to determine the visibility of the small-scale (unfiltered) field and the medium-scale field (see the small-scale/medium-scale vortices field specification in the code shown in <ref type="figure" target="#fig_9">Fig. 6</ref>). Therefore, the vortices outside the coarse-scale vortex tubes would be hidden, resulting in an image clearly showing the hierarchical structure of turbulence (right picture in <ref type="figure" target="#fig_9">Fig. 6</ref>). The coarsescale vortex tubes are represented by gray surfaces, the medium-scale vortex tubes are in blue, and the small-scale vortices are colored by a green-yellow-red colormap showing the magnitude of Q-criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Kidney Tumor</head><p>To demonstrate how our technique facilitates illustrative volume visualization, we specify a pipeline using multiple shading styles for visualizing a human body CT scan, where the key point of the visualization design is to depict the tumor attached on one of the kidneys. In the visualization, we also want to show the bones and the vessels to provide context, but we do not want the contextual objects to be too distracting. To achieve this goal, we first separate the objects within the data. Because some objects share the same band of data values, it is difficult to use a transfer function to separate the objects. Instead, we use pre-generated segmentation volumes as filters to mask the CT volume and obtain separate color-opacity fields for the bones, the blood vessels, the organs, and the tumor. We then apply different shading styles for each field, respectively. For the tumor and the organs, Blinn-Phong lighting is applied. The tumor is specially highlighted in an attracting purple color. On the other hand, the bones and the vessels are assigned to cartoon styles, making them flat-looking and less attractive to the eye. Finally, a very light blue surface is added to give the outline of the body. <ref type="figure" target="#fig_10">Fig. 7</ref> shows the resulting illustration. The specification blocks for different objects are highlighted in the corresponding colors, respectively, in the code shown in <ref type="figure" target="#fig_10">Fig. 7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Animated Human Body</head><p>Our grammar allows specification of animations for parameter values of the pipeline. An example application of this feature is demonstrated in <ref type="figure" target="#fig_11">Fig. 8</ref>, displaying the interior structures of a human body image through animation. In the code shown in the figure, three animation blocks are specified, animating the translation/rotation of the right-half (from the viewer's perspective) of the human body and the clipping plane of the left-half of the body. The times of the keyframes are arranged so that the transformation animation takes place first, and the clipping animation starts right after the transformation is done. The sub-figures in <ref type="figure" target="#fig_11">Fig. 8</ref> show four selected frames of the animation. <ref type="figure" target="#fig_11">Fig. 8(a)</ref> displays the initial state. Then the transformation animation starts, goes through <ref type="figure" target="#fig_11">Fig. 8(b)</ref>, and ends in <ref type="figure" target="#fig_11">Fig. 8(c)</ref>. The clipping animation then starts and ends in <ref type="figure" target="#fig_11">Fig. 8(d)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DISCUSSION AND FUTURE WORK</head><p>The examples in the previous section show that our declarative grammar can concisely specify various practical visualization pipelines. Compared to programming with lower-level DSLs/libraries, our technique alleviates the coding burden significantly. The expressiveness of the language is sufficient enough to cover a range of sophisticated use cases. Moreover, our prototype system provides some insight into designing a system that uses our grammar, demonstrating a hybrid interface design that utilizes both text-based and graphical interfaces. The two UI schemes are complementary to each other; the text-based interface provides flexibility, while the graphical interface helps the tasks that are tedious to do with a text-only interface.</p><p>Although our grammar in its current state cannot cover every volume visualization need, the grammar is easy to extend. New functions can be integrated into the framework by defining new keywords and blocks in the language. For instance, a new data pre-processing operation can be added as a new type of block that lies in a scalar field specification. Similarly, new types of sub-blocks in the specification of a color-opacity field can be used for indicating new shading methods. Since the newly added block types do not change the way existing block types are interpreted, backward compatibility can be maintained without any difficulty. By ignoring the blocks denoted by unknown keywords, there is also some room for forward compatibility.</p><p>The impact to the rendering performance due to the flexibility of the pipeline is negligible because the workload of the rendering is mainly on the GPU side. The shader program is only compiled once before execution, so there is no interpretation overhead during rendering. Furthermore, we have not observed significant differences in performance between the generated shader code and hand-written code. This is primarily due to that GPU-based DVR programs are more intensive in memory accesses instead of arithmetic/logic operations. Therefore, the performance impact due to the less optimized generated code is not significant. We plan to conduct a more comprehensive evaluation in the future in order to further investigate the performance of our system.</p><p>Nevertheless, for average users, our grammar might have a steeper learning curve than traditional GUI applications. To create specifications, the users may need to memorize the syntax and the keywords or to have a manual in hand. The grammar itself does not prevent the users from doing something unreasonable. Also, it might not be easy to debug. However, these issues can potentially be solved by improving the system functionality. Like modern integrated development environments (IDEs) for software development, the script editor can provide various assistant functions such as auto-completion and showing warnings for bad inputs. The system can also provide GUI to help the users create the blocks in the specification. Templates for common scenarios can be provided so the users can start with an environment similar to the traditional GUI applications. After all, we believe the flexibility provided by our grammar justifies the steeper learning curve.</p><p>We have identified some limitations within the current grammar design. First, since our pipeline model assumes that each sample is processed independently of other samples, the applicable operations within this process are limited to local operations. For instance, maximum intensity projection (MIP), which requires recording the maximum intensity value along each viewing ray, is not supported by our pipeline model unless it is treated specially. This characteristic of the pipeline model also prevents rendering algorithms relying on specific volume integration schemes. For example, the volumetric halo technique described in <ref type="bibr" target="#b8">[9]</ref> operates on view-aligned slices through the volume in front-to-back order. This technique relies on a slice-based rendering scheme and thus is not applicable to our pipeline model. Second, our grammar does not provide a way to specify image-space operations. Image-space post-processing can sometimes improve the resulting visualization's effectiveness. Examples include tone mapping, which can enhance the contrast of the image, and edge detection, which can clarify object boundaries. Since our pipeline model deals with object-space primitives-scalar and color-opacity fields-image-space operations cannot be specified without expanding the scope of the grammar.</p><p>In the future, we want to extend the grammar in several aspects to address a wider range of visualization and analysis tasks. In addition to volumes, we want to support more types of primitives such as tubes for line-based data and glyphs for point-based data, enabling hybrid rendering of volumes and geometric primitives. Next, we want to extend the language to support not only visualization but also processing of data. In the current design, data pre-processing can be specified within the field specification using preset functions such as the boxFilter used in <ref type="figure" target="#fig_9">Fig. 6</ref>. We want to make this portion of the grammar even more flexible and provide a way for the user to save the processed data. Finally, we want to extend the language to facilitate multi-view visualization. The effectiveness of specifying interaction between multiple views with a declaritive grammar has been demonstrated in <ref type="bibr" target="#b31">[32]</ref>. Also, as shown in <ref type="bibr" target="#b0">[1]</ref>, the capability of connecting volume rendering views with information views, such as histogram views, can enable even more effective visualizations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1. Volume visualization pipeline. In the rendering process of the datalevel pipeline, the data volume is sampled. Each sample is processed through a sample-level pipeline, in which the sampled value is mapped to color and opacity value, shaded, and then composited into the pixel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>"field": { "field": " vorticity ", " clipping ": [ [20, 0, 0], // lower -left [80, 100, 100] // upper -right ], " transform ": { " translate ": [0, 20, 0], " rotate ": [0, 0, 45], // in degrees "scale": [1.2, 1, 1] } }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>: {...}, "color": {...} }, { // volume 2 " opacity ": {...}, "color": {...} } ] }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>{"</head><label></label><figDesc>"field": " vorticity ", " transform ": { " rotate ": { " animate ": { "times": [0, 5, 10], // keyframe times</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>{</head><label></label><figDesc>"color": {...}, " opacity ": {...}, " lighting ": {} // empty lighting block; use default settings }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>: {...}, // clipping and transformation are applied " transform ": {...} // to both volume 1 and 2 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 2 .Fig. 3 .</head><label>23</label><figDesc>(a) The system interface, consisting of (1) a scripting panel, (2) a rendering window, and (3) a parameter control panel. The mapping editor (4) is shown as needed. (b)(c) The dynamic control panel. The layout of the panel changes according to the currently applied specification. The architecture of our prototype system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 4 .</head><label>4</label><figDesc>Selected time-steps of a numerical simulation of self-igniting jet of n-dodecane. Blue cool flame represents a low-temperature ignition process, while orange-red hot flame represents a high-temperature ignition process.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 .</head><label>5</label><figDesc>A workflow to create a visualization of a mouse PET/CT scan. (a) The CT image rendering is initially created with the code-specified transfer function. (a') The transfer function setting is refined through the graphical mapping editor. (b) To remove the bed, clipping is applied. (c) Lighting is applied to better show spatial information. (d) The PET image is blended with the CT image. (d') Zoom-in view shows the occlusion by the ribs. (e) The occlusion is remedied by reducing the opacity of the ribs. Top-right: the resulting visualization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 .</head><label>6</label><figDesc>Turbulence simulation data showing vortices within vortices. The gray surfaces show the coarse-scale vortex tubes. The blue surfaces show the medium-scale vortex tubes. The small-scale vortices are shown with a green-yellow-red colormap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 7 .</head><label>7</label><figDesc>Illustration showing kidney tumor. The interesting objects (the tumor and the kidneys) are rendered with standard shading, while the context objects (the bones and the blood vessels) are rendered with cartoon styles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 .</head><label>8</label><figDesc>Selected frames of a script-generated animation of a human body image. First, the body is opened into two halves to show the interior structures (from (a) to (c)), and then it is clipped gradually to show the interior from a different aspect (from (c) to (d)).</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors wish to thank Chris Ye, Kelvin Li, and Franz Sauer for invaluable discussions. Thanks also go to Dr. Jacqueline H. Chen, Sandia National Laboratories, and Dr. Angelique Y. Louie, University of California, Davis, for providing us with their datasets. This research is supported in part by the U.S. Department of Energy through grant DE-SC00012610 and U.S. National Science Foundation through grant IIS-1528203.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{</head><p>"blend": [ { "id": "left_half", "field": "visible_male", "lighting": {} "clipping": [ { "animate": { "times": <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12]</ref>, "values "id": "right_half", "field": "visible_male", "lighting": {}, "clipping": {}, "transform": { "rotate": { "animate": </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A tri-space visualization interface for analyzing time-varying multivariate volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Akiba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Joint Eurographics / IEEE VGTC Conference on Visualization, EURO-VIS&apos;07</title>
		<meeting>the 9th Joint Eurographics / IEEE VGTC Conference on Visualization, EURO-VIS&apos;07<address><addrLine>Aire-la-Ville, Switzerland, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>Eurographics Association</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="115" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amira</forename></persName>
		</author>
		<ptr target="http://www.amira.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A dataflow-based shader framework for visualizing dissections of the heart using individual patient data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Arens</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
		<respStmt>
			<orgName>University of Paderborn</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The paraview guide: a parallel visualization application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Ayachit</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Vistrails: enabling interactive multiple-view visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Crossno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 2005</title>
		<imprint>
			<date type="published" when="2005-10" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Protovis: A graphical toolkit for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1121" to="1128" />
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">D3 data-driven documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bostock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ogievetsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2301" to="2309" />
			<date type="published" when="2011-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Style transfer functions for illustrative volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bruckner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="715" to="724" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Enhancing depth-perception with flexible volumetric halos</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bruckner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1344" to="1351" />
			<date type="published" when="2007-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Vortices within vortices: hierarchical nature of vortex tubes in turbulence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bürger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Treib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Werner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Lalescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szalay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meneveau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Eyink</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1210.3325</idno>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Data Intermixing and Multi-volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sakas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Visit: An end-user tool for visualizing and analyzing very large data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Childs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Brugger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Whitlock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ahern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pugmire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Biagas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krishnan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>US</publisher>
			<pubPlace>Berkeley, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Ernest Orlando Lawrence Berkeley National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Diderot: A parallel dsl for image analysis and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chiw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reppy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Samuels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;12</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="111" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Vivaldi: A domain-specific language for volume processing and visualization on distributed heterogeneous systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G C</forename><surname>Hildebrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2407" to="2416" />
			<date type="published" when="2014-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The occlusion spectrum for volume classification and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Correa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1465" to="1472" />
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A non-photorealistic lighting model for automatic technical illustration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gooch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gooch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Annual Conference on Computer Graphics and Interactive Techniques, SIGGRAPH &apos;98</title>
		<meeting>the 25th Annual Conference on Computer Graphics and Interactive Techniques, SIGGRAPH &apos;98<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="447" to="452" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Shadie: A domainspecific language for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hašan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wolfgang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<ptr target="http://miloshasan.net/Shadie/shadie.pdf" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>Draft paper; available at</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Scout: High-performance heterogeneous computing made simple</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Jablin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 IEEE International Symposium on Parallel and Distributed Processing Workshops and Phd Forum</title>
		<imprint>
			<date type="published" when="2011-05" />
			<biblScope unit="page" from="2093" to="2096" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Diderot: a domain-specific language for portable parallel scientific visualization and image analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chiw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Seltzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Samuels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reppy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="867" to="876" />
			<date type="published" when="2016-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Multidimensional transfer functions for interactive volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="270" to="285" />
			<date type="published" when="2002-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A public turbulence database cluster and applications to study lagrangian evolution of velocity increments in turbulence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Perlman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meneveau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szalay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Eyink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Turbulence</title>
		<imprint>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page">31</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An architecture for a scientific visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">S</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Gresh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Mcauliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scout: a data-parallel programming language for graphics processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Inman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mohd-Yusof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cummins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="648" to="662" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
	<note>High-Performance Computing Using Accelerators</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Scout: a hardware-accelerated system for quantitatively driven visualization and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Inman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Ahrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004-10" />
			<biblScope unit="page" from="171" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Voreen: A rapid-prototyping environment for ray-casting-based volume visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meyer-Spradow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ropinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mensmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hinrichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="6" to="13" />
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="http://www.osirix-viewer.com/" />
		<title level="m">Osirix</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Data exploration of turbulence simulations using a database cluster</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Perlman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meneveau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing, 2007. SC &apos;07. Proceedings of the 2007 ACM/IEEE Conference on</title>
		<imprint>
			<date type="published" when="2007-11" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A flexible multi-volume shader framework for arbitrarily intersecting multi-resolution datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Plate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Holtkaemper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Froehlich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1584" to="1591" />
			<date type="published" when="2007-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Vislang: A system for interpreted domain-specific languages for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rautek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bruckner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Grller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2388" to="2396" />
			<date type="published" when="2014-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A shader framework for rapid prototyping of GPU-based volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rieder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Link</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">K</forename><surname>Hahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1031" to="1040" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dynamic shader generation for GPU-based multi-volume ray casting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Rößler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Botchen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="66" to="77" />
			<date type="published" when="2008-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Vega-lite: A grammar of interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Satyanarayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wongsuphasawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="341" to="350" />
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Reactive vega: A streaming dataflow architecture for declarative interactive visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Satyanarayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hoffswell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="659" to="668" />
			<date type="published" when="2016-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The visualization toolkit: an object-oriented approach to 3D graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>Kitware</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Inviwo -an extensible, multi-purpose visualization framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sunden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Steneteg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kottravel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jonsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Englund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Falk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ropinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Scientific Visualization Conference (SciVis)</title>
		<imprint>
			<date type="published" when="2015-10" />
			<biblScope unit="page" from="163" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The application visualization system: a computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Faulhaber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">The volpack volume rendering library</title>
		<ptr target="https://graphics.stanford.edu/software/volpack/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Ospray -a cpu ray tracing framework for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Amstutz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Brownlee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jeffers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gnther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Navratil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="931" to="940" />
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Visualization in the SCIRun problem-solving environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weinstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Simpson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zimmerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Jones</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Elsevier Inc</publisher>
			<biblScope unit="page" from="615" to="632" />
			<pubPlace>United States</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">ggplot2: Elegant Graphics for Data Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wickham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">vlib: A volume graphics API</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<editor>K. Mueller and A. E. Kaufman</editor>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="133" to="147" />
			<pubPlace>Vienna; Vienna</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
