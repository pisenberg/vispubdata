<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rapid Graph Layout Using Space Filling Curves</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Muelder</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
						</author>
						<title level="a" type="main">Rapid Graph Layout Using Space Filling Curves</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T18:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Information visualization</term>
					<term>Graph layout</term>
					<term>Space filling curves</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Network data frequently arises in a wide variety of fields, and node-link diagrams are a very natural and intuitive representation of such data. In order for a node-link diagram to be effective, the nodes must be arranged well on the screen. While many graph layout algorithms exist for this purpose, they often have limitations such as high computational complexity or node colocation. This paper proposes a new approach to graph layout through the use of space filling curves which is very fast and guarantees that there will be no nodes that are colocated. The resulting layout is also aesthetic and satisfies several criteria for graph layout effectiveness.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Applications in many fields employ graph visualization to present data to the user. For example, document visualizations <ref type="bibr" target="#b21">[22]</ref> can represent documents and their citation network with a graph. Similarly, social network visualizations <ref type="bibr" target="#b15">[16]</ref> can represent people as nodes in a graph. These visualizations are frequently used to show inherent patterns in the data. In order to emphasize these patterns, many algorithms have been developed that determine how to lay out the nodes in space. Many algorithms exist to generate graph layouts, and they all generally share similar goals. Namely, they all strive to produce a layout that meets one or more criteria, such as minimizing edge crossings or having a short average edge length.</p><p>While most existing algorithms work well on sparse, mesh-like networks, real world networks such as scale-free networks are often large and dense. As these graphs grow larger and denser, speed and screen space also become issues. As the number of nodes on the screen increases, less screen space can be used for each node, so the more frugal a visualization needs to be in using that space. One way of doing this is by reducing the number of nodes shown in detail at any one time, such as through focus plus context interaction. But in order to allow interactivity, it is imperative that the graph layout is fast, as each interaction requires the graph to be adjusted. Many existing algorithms are not fast enough to interactively adjust, so they rely on distortion techniques such as fisheye lenses <ref type="bibr" target="#b11">[12]</ref>. Also, most existing algorithms do not handle dense clusters in the graph very well, as the nodes inside the cluster get placed too close together to discern details.</p><p>The graph layout approach we present here avoids these limitations of previous layout algorithms, particularly when working with dense, scale-free networks. It proceeds by using a clustering algorithm to order the nodes of a graph, then using this ordering to arrange these nodes along a space filling curve of arbitrary complexity. This allows the graph to not only be initially laid out quickly, but also to adjust to user interaction even more quickly. Our approach is also very frugal with screen space, as it creates a layout which is space filling and guarantees that nodes inside a cluster are not placed too close together. It also guarantees good aspect ratios of clusters. In this paper, we describe our new approach, and also compare it quantitatively and qualitatively against seven other algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>This work draws upon several existing techniques in both the fields of graph visualization and space filling curves. Many graph layout algorithms have been developed, and there are several variations of space filling curves. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Existing Graph Layout Techniques</head><p>Sometimes a graph has an intuitive layout where the vertices contain positional information that can be used, such as geographical locations. However, most graphs do not have such information, thereby requiring that the positions of vertices be derived. Special cases, such as trees or directional graphs, have certain properties which can be utilized to generate a layout. But, general graphs require more flexible algorithms. Also, some work has been done in graph layout using parallel hardware <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b31">32]</ref>, but many other layout algorithms could be ported to parallel hardware as well. Hachul and Jünger have produced an in-depth survey of many recent, general graph layouts <ref type="bibr" target="#b13">[14]</ref>. The most intuitive, and probably the most often used graph layout algorithms for small graphs, are force-directed layouts such as Fruchterman-Reingold <ref type="bibr" target="#b9">[10]</ref>, LinLog <ref type="bibr" target="#b29">[30]</ref>, and Kamada-Kawai <ref type="bibr" target="#b20">[21]</ref>. These algorithms position graphs by iteratively refining the positions of vertices in order to incrementally reduce an energy function. This energy function varies between algorithms, but generally has the property that it is a function of the distances between nodes and the weights of the edges between them. While these layouts are intuitive and generally considered aesthetic, they do not scale well to large or dense graphs. Some variants try to alleviate this issue, such as the Grid Variant Algorithm (GVA) of Fruchterman and Reingold <ref type="bibr" target="#b9">[10]</ref> accelerates layout by limiting repulsive forces between nodes to those contained in the same area of a grid. However, they are still quite computationally expensive.</p><p>There are more efficient algorithms which use a multi-scale approach. Examples of these algorithms include the work of Cohen <ref type="bibr" target="#b2">[3]</ref>, the Fast Multipole Multilevel Method (FM 3 ) <ref type="bibr" target="#b12">[13]</ref>, and the Graph dRawing with Intelligent Placement (GRIP) algorithm <ref type="bibr" target="#b10">[11]</ref>. These algorithms start by laying out a small approximation of a graph, then progressively laying out finer approximations of the graph, until the entire original graph is laid out. As this does not take multiple iterations, these algorithms generally perform far better than traditional force-directed approaches, while still producing similar results.</p><p>Even faster graph layout algorithms are available in the form of algebraic layouts, such as Algebraic Multigrid Computation of Eigenvectors (ACE) <ref type="bibr" target="#b23">[24]</ref> or High Dimensional Embedding (HDE) <ref type="bibr" target="#b14">[15]</ref>. These algorithms calculate layouts immediately using linear algebra techniques rather than iteratively or recursively laying out graphs according to force calculations. While not very intuitive, these algorithms can quickly produce layouts that are similar to the forcedirected layouts. However, as shown in the survey by Hachul and Jünger <ref type="bibr" target="#b13">[14]</ref>, these algorithms can fail to produce a good layout in some cases, particularly when the graph is dense.</p><p>The graph layout approach most closely related to the one presented here is the treemap based graph layout <ref type="bibr" target="#b24">[25]</ref>, which does not fall into either category. This approach works by hierarchically clustering a graph, then applying a treemap to this hierarchy to derive placements for the nodes. It can attain the speed of algebraic approaches while avoiding issues such as nodes mapping to the same location. It also uses the entire screen, so that no screen space is wasted. However, <ref type="figure">Fig. 1</ref>. Graph layout approach: First, we hierarchically cluster the nodes of the graph. Then, we traverse this hierarchy to generate an ordering. Finally, we use this ordering to place the nodes on a space filling curve.</p><p>when the hierarchy generated by the clustering algorithm is not well balanced, the results often end up with regions with poor aspect ratios. While work has been done on improving treemap aspect ratios, they do not generally apply to binary trees, as are used in the treemap graph layout algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Matrix Ordering</head><p>The approach of this paper essentially reduces the problem of graph layout to one of matrix ordering, so it is important to consider what work has been done on ordering of adjacency matrices. Mueller et al. provide a survey of several different matrix ordering algorithms, including breadth-first search, depth first search, RCM, King, Sloan, and spectral decomposition <ref type="bibr" target="#b26">[27]</ref>. Fekete et al. also explore matrix orderings in their work on ZAME <ref type="bibr" target="#b7">[8]</ref>, in which they describe the use of a modified version of HDE and an approximated traveling salesmen algorithm for matrix ordering. Also, any graph clustering can be used to derive a matrix ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Graph Clustering</head><p>Graph clustering is a challenging problem in its own right. There are as many kinds of clustering algorithms as there are kinds of graphs that need to be clustered. However, graph data is frequently clustered in order to create an overview or allow interactions such as semantic zooming <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b11">12]</ref>. Several clustering algorithms are hierarchical, such as agglomerative or divisive clustering <ref type="bibr" target="#b19">[20]</ref>. Others, such as k-means, are not hierarchical. We choose to focus on clustering of small world networks, such as the modularity algorithm of Clauset, Newmann, and Moore <ref type="bibr" target="#b1">[2]</ref>, and the variant by Huang and Nguyen <ref type="bibr" target="#b17">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Space Filling Curves</head><p>The use of space filling curves in visualization is not that common, but has recently become more popular. PhylloTrees <ref type="bibr" target="#b28">[29]</ref> use spirals similar to space filling curves to aid in the layout of hierarchical data. Several recent computer network visualizations have used a space filling curve to map the IP4 address space of the internet <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b27">28]</ref>. The work of Martin Wattenberg demonstrates the use of a space filling curve as an alternative to a treemap, and proves some nice properties of the resulting visualization, which are due to this curve <ref type="bibr" target="#b32">[33]</ref>. The relationship between Wattenberg's 'jigsaw map' and a regular treemap is particularly relevant to this work, as it analogous to the relationship between the space filling graph layout approach of this paper and the treemap based graph layout <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A SPACE FILLING GRAPH LAYOUT</head><p>This paper proposes an approach to generating a graph layout through the use of space filling curves. As diagrammed in <ref type="figure">Figure 1</ref>, this approach consists of three steps. First, the clustering algorithm groups nodes together into a binary cluster hierarchy. This hierarchy is then traversed to generate a node ordering. Finally, the nodes are spaced out along a space filling curve according to the ordering. An example of a graph layout generated with this approach is shown in <ref type="figure" target="#fig_0">Figure 2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Node Ordering</head><p>In order to lay out the graph nodes along the space filling curve, we must first order them coherently. Several common matrix orderings were tried (including BFS, DFS, RCM, and King), but none of these reliably produced good enough results. We found that using a clustering algorithm reliably produces a good ordering results in many real world datasets. Since we are focusing on small world graphs (also called scale-free or power law graphs), we use the "Fast Modularity" community structure inference algorithm <ref type="bibr" target="#b1">[2]</ref>, which has been shown to be very effective for graphs of this type. This algorithm works by starting with each node as its own cluster, then iteratively agglomerating them together by merging the two clusters that maximize the increase in the modularity Q, which is defined as:</p><formula xml:id="formula_0">Q = 1 2|V | ∑ i, j a i, j − d i d j 2|V | δ (i, j)</formula><p>where |V | is the number of nodes, a i, j is 1 if there is an edge between nodes i and j and 0 otherwise, d i is the degree of node i, and δ (i, j) is 1 if nodes i and j are in the same cluster and 0 otherwise. As described in <ref type="bibr" target="#b1">[2]</ref>, this clustering algorithm runs in O(|E| × d × log|V |), where d is the depth of the hierarchy (usually O(log|V |)).</p><p>Once this clustering hierarchy has been generated, the approach derives an ordering of nodes by traversing the tree depth-first. At each level of traversal, it is possible to choose which branch of the hierarchy to traverse next. Currently, our approach chooses the branch to traverse in the order determined by the clustering algorithm, which turns out to be prioritized by the size of cluster. This traversal is very fast, as it takes only Θ(|V |) operations. However, this does not take into consideration inter-cluster edges, so it is possible for such edges to be stretched out across the graph. A better ordering could probably be achieved by using the inter cluster edges to decide which branch of the hierarchy to descend down at each level, but that is beyond the scope of this paper. Regardless of the order in which the branches are traversed, the clustering information will be preserved. That is, nodes that are in the same branch of the clustering hierarchy will be placed close to each other in the ordering, and hence be in a contiguous area of the resulting layout. Since we are focusing on fairly well clustered graphs, this is the most important property for the datasets shown here. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Space Filling Curves</head><p>Once the graph nodes have been ordered, they are mapped onto the screen according to a space filling curve. The primary property of space filling curves which we wish to utilize is that they exhibit what is referred to as "c-locality" <ref type="bibr" target="#b32">[33]</ref>. That is, space filling curves satisfy the equation:</p><formula xml:id="formula_1">Distance(M(p i ), M(p j )) &lt; c |p i − p j |</formula><p>where p i is the 1D position of a point i along the line, M(p i ) is the mapping of that point into 2D space, and c is some small constant. Due to this property, graph nodes that are clustered together are guaranteed to be placed nearby on the screen. In particular, for a cluster of n nodes, they are guaranteed to be contained in a circular region of diameter c √ n. Therefore, a space-filling curve based layout can guarantee a minimum aspect ratio for clusters. Space filling curves also have the property that they do not self-intersect, which means that graph nodes spaced out on a curve will never be placed in the exact same location, as is possible with algebraic layouts. In addition, space filling curves completely fill the area inside their boundary as their order d → ∞. Thus, given a high enough order curve, graph nodes can be placed at any point on the screen, so that screen space is not wasted. However, since displays use discreet pixels, these curves only need to be of an order sufficient to cover every pixel, which is actually quite reasonable.</p><p>In this work we use three space filling curves: a Hilbert curve, a Peano curve, and a Gosper curve. All three curves are defined recursively, where the first level is defined by a fairly simple curve, and each segment of the curve of order d is replaced by a copy of the original pattern to create the curve of order d + 1.  When this length is smaller than the size of a pixel, the Hilbert curve completely covers the screen. In other words, for a screen space with dimensions S × S, the Hilbert curve needs to be of order d = Ω(log 2 S), which for most standard screen dimensions (up to 2, 048 × 2, 048) is</p><formula xml:id="formula_2">d = 11.</formula><p>The Peano curve (shown in <ref type="figure">Figures 3(d)</ref>, 3(e), and 3(f)) is slightly more complex than the Hilbert curve, but is otherwise quite similar. The primary difference between it and the Hilbert curve is that it replaces each corner with 9 new corners instead of 4. Thus, an order d Peano curve has 9 d points and 9 d − 1 segments of length <ref type="bibr" target="#b0">1</ref> 3 d . Because of this added complexity, there are several variations of Peano curves, as there are various possible orientations for the recursive steps. Also, this complexity allows the curve to cover all pixels in even fewer iterations -for a screen space with dimensions S × S, the Peano curve needs to be of order d = Ω(log 3 S), which for most standard screen dimensions (up to 2, 187 × 2, 187) is d = 7.</p><p>The Gosper curve (shown in <ref type="figure">Figures 3(g)</ref>, 3(h), and 3(i)), sometimes called the 'Flow-snake,' is the most complex of the three. It is advantageous in that it does not impose hard borders in each recursion, thus it imposes the least amount of artificial structure onto the graph. However, it is not completely space filling, because it is not square and it leaves white space around the outside of its boundary. At each recursion, the Gosper curve replaces each segment of the curve with a copy of the order 1 Gosper curve. Thus, an order d Gosper curve has 7 d segments of length 1 ( √</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7)</head><p>d . To cover a screen space with dimensions S × S, the Gosper curve needs to be of order d = Ω(log √ 7 S), which for most standard screen dimensions (up to 2, 401 × 2, 401) is d = 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Node Mapping</head><p>The last step is to map the nodes onto one of the space filling curves. This is done by first arranging the nodes one dimensionally according to their ordering, and normalizing the node's positions to the range [0, 1]. The simplest way to do this is to space them out evenly, with 1 |V | between each node. Once they are spaced out in one dimension, their positions on the space filling curve are calculated with a mapping function M : Q → Q 2 . Just as the space filling curves are defined recursively, this mapping function is also calculated recursively. At each intermediate level of the recursion, the mapping function calculates which segment of the curve it will be mapped to, then recurses on that segment. In the final level of the recursion, the function calculates which segment the node lands on and places the node along that segment appropriately. However, given a sufficiently high order curve, this final level will be at sub-pixel resolution, so the node could be placed anywhere in the region. <ref type="figure">Figure 4</ref> shows the result of mapping a graph of similarity between network scans to Hilbert curves of various orders. As the order of the space filling curve increases, the nodes quickly converge to their final positions. As mentioned before, at order 11, the Hilbert curve covers every pixel, so in this example, recursing farther than 11 would not improve the results. By calculating the positions in this manner, we can map the nodes from the ordering to the screen in O(d × |V |), where d is the order of the fractal, which is logarithmic according to screen resolution, so for our purposes it is essentially constant. Pseudo-code for the basic space filling curve mapping function is given in Pseudo-Code 1. While there are details which are specific to each curve, all three curves we use share the same basic algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Cluster Spacing</head><p>While placing the nodes out evenly on the space filling is simple and guarantees that all nodes are spaced out away from each other, overall the nodes end up with an even distribution across the screen. This is often considered to be not very aesthetic, as it looks as if the nodes were spread out at random. Also, it blurs the distinction between clusters, as there is no separation between them. It is possible to resolve these issues by adjusting the spacing between nodes. In particular, we want to increase the spacing between nodes in different clusters, while decreasing the spacing between nodes in the same cluster. Since we already have clustering information from the layout process, it is straightforward to use this clustering information to space out the nodes.</p><p>Nodes that are clustered together are closer in the clustering hierarchy, and therefore have similar depths in the hierarchy. So, the depths of two consecutive nodes in the tree traversal will be nearly the same when the two nodes are in the same cluster. Therefore, it is possible to space the nodes out according to the difference in their depths in the hierarchy. That is, when the difference between the clustering depths of two consecutive nodes is small, they should be placed closer together, and when the difference is large, they should be spaced out farther. We do this by calculating the spacing s i,i+1 as:</p><formula xml:id="formula_3">s i,i+1 = |depth i+1 − depth i | k</formula><p>where k is user defined. Examples of clusters spaced out this way are shown in <ref type="figure" target="#fig_4">Figure 5</ref>. As can be seen in the figure, clusters get compacted together and spaced out apart from each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Geometric Zoom</head><p>One advantage to using a very fast graph layout is that it can be used in an interactive system. A common interactive technique for graphs is the capability to zoom into a small section of the graph to show it in more detail. Existing approaches often use techniques such as fisheye lenses to distort an initial layout <ref type="bibr" target="#b11">[12]</ref>. But such approaches require that the graph be laid out at full resolution to begin with. By using our space filling curve based approach, the graph can be relaid out rapidly enough to allow interactivity, such as a geometric zoom. One simple way to do this is to increase the spacing factors of nodes that the user selects to focus on. Similar to how clusters can be separated by spreading them out on the curve, focal areas can be expanded to take up more space by increasing their portion of the curve. That is, the layout can perform a geometric zoom by increasing the spaces between nodes that the user selects. In our system, the user to selects nodes to zoom with the mouse, and adjusts the level of zoom with a slider widget. An example is shown in <ref type="figure" target="#fig_5">Figure 6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>In order to test the effectiveness of our graph layout approach, we ran it on several graph datasets of various sizes. These datasets are summarized in <ref type="table" target="#tab_2">Table 1</ref>. The "netscans" dataset (shown in <ref type="figure">Figure 4</ref>) is a complete weighted graph representing the similarity between network scans. However, to more clearly depict patterns in this graph, edges with a weight below a threshold value are not shown <ref type="bibr" target="#b25">[26]</ref>. The "california" dataset (shown in <ref type="figure" target="#fig_4">Figures 5 and 8)</ref> consists of the links between the webpages found from a search for the word 'California' <ref type="bibr" target="#b3">[4]</ref>. The "pgraph" dataset (shown in <ref type="figure" target="#fig_0">Figures 2 and 6</ref>) is a protein homology graph, which is relatively dense <ref type="bibr" target="#b6">[7]</ref>. Finally, the "usafla" dataset (shown in <ref type="figure" target="#fig_6">Figure 7</ref>) is of the intersections and the streets between them in the state of Florida <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Scalability</head><p>One primary application for rapid graph layout is for very large graphs, which would take a very long time to lay out with traditional forcedirected layouts. In order to be useful for this task, the approach has to be scalable to large datasets. As mentioned before, the actual layout  , which is still quite fast. The extra space used by this approach is only Θ(|V |) to store the hierarchy, which makes it quite efficient in terms of memory usage. As shown in <ref type="figure" target="#fig_6">Figure 7</ref>, we have tested our approach on graphs up to |V | = 1, 070, 376, |E| = 2, 712, 798 and still been able to quickly and reliably produce results with commodity hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison</head><p>The primary advantage to the approach presented here is that it is very fast. However, even if a graph layout is fast, it is useless unless the resulting layout is good. For instance, a randomized layout can be generated very fast, but the resulting layout will rarely be useful. Force-directed layouts, such as LinLog, generally produce quite good results, but take a long time to do so. Algebraic layouts are much faster, but can fail to produce good results. The treemap based layout is fast and often effective, but imposes structural artifacts such as poor aspect ratios, since everything is rectangular. The space filling curve based approach presented here attains speed comparable to the treemap layout, and provides the same guarantees of filling the screen and no node colocation, but it does not impose such a rigid structure or have the issues with 'skinny regions' that the treemap layout does. In order to demonstrate the quality of a space filling curve based layout, a comparison between it and several other layouts is given in <ref type="figure">Figure 8</ref>, where they are applied to the "California" graph <ref type="bibr" target="#b3">[4]</ref>. We used the Boost Graph Library's implementation of GVA [1] Yehuda Koren's own implementations of ACE and HDE <ref type="bibr" target="#b22">[23]</ref>, Yusufov's implementation of GRIP src-grip, and the Open Graph Drawing Framework's implementation of FM 3 <ref type="bibr" target="#b30">[31]</ref>. While several algorithms have parameters that can be adjusted, this would involve a trial and error process which would need to be included in the timing tests, so we use default parameters. Timing results were generated by running the programs on one core of a 2.66GHz Intel Xeon Mac Pro with 8GB of RAM and are presented in <ref type="table" target="#tab_3">Table 2</ref>. The LinLog layout, shown in <ref type="figure">Figure 8(a)</ref>, was easily the slowest, taking 10,737 seconds to compute 200 iterations. In this layout, it is clear that there is a very tightly connected group of nodes, and many weakly connected or disconnected subgraphs. While it can be seen that there are actually three clusters in the center of the graph, the internals of these clusters can not be seen, since the nodes are so close together. Also, much of the space around the outside of the region is not utilized.</p><p>The Grid-Variant Algorithm (GVA) <ref type="bibr" target="#b13">[14]</ref>, shown in <ref type="figure">Figure 8(b)</ref>, is a heuristically accelerated layout based on the Fruchterman-Reingold layout algorithm <ref type="bibr" target="#b9">[10]</ref>. As can clearly be seen, this algorithm is much faster than LinLog, taking only 45 seconds to do 400 iterations. However, the results are not as good as LinLog, since the three clusters in the middle are not distinguishable from each other. It also induces a grid-like arrangement of many of the nodes due to the heuristic, which is not related to the graph. Also, GVA leaves even more of the surrounding area as whitespace. While the force-directed graph layouts may be intuitive and aesthetically pleasing, neither of them show the internal structures of the clusters.</p><p>The Fast Multipole Multilevel Method (FM 3 ) <ref type="bibr" target="#b12">[13]</ref>, shown in <ref type="figure">Figure 8(c)</ref>, uses a multi-scale approach to generate a layout more quickly than traditional force directed layouts. It produced results similar to GVA, but in a fraction of the time. Also, the resulting layout does not have the grid-like artifact that GVA does. However, the results are even less useful than either of the previous two. The cluster in the center is packed even tighter than in GVA, and any internal properties of this cluster are indiscernible. In particular, there is no way to tell that there are three clusters inside. Also, even more space is left white around the borders, so that the disconnected components can be placed around the large one.</p><p>GRIP <ref type="bibr" target="#b10">[11]</ref>, shown in <ref type="figure">Figure 8(d)</ref>, is another multi-scale algorithm, similar to FM <ref type="bibr" target="#b2">3</ref> . As can be seen in the figure, it performed even better than FM 3 in terms of speed, taking just over a second, yet produced very similar results. That is, the majority of the nodes are compacted into one small cluster, inside of which very few details can be seen, while the majority of screen space is allocated to the disconnected components.</p><p>The algebraic method ACE <ref type="bibr" target="#b23">[24]</ref>, shown in <ref type="figure">Figure 8</ref>(e), while very fast, produced the least useful results. Not only are the vast majority of nodes concentrated in a very small area, but it does not even separate disconnected components. It also leaves most of the screen blank. However, the worst issue was that it often failed to complete running. When it did finish running, it finished very quickly, but it often locked up and never reached completion. Similar results were presented in Hachul and Jünger's survey paper <ref type="bibr" target="#b13">[14]</ref>, though it could be an implementation bug.</p><p>Similarly to ACE, HDE <ref type="bibr" target="#b14">[15]</ref>, shown in <ref type="figure">Figure 8</ref>(f), also produced results very quickly, but which were not as useful as the force-directed algorithms. As in ACE, the majority of the nodes are grouped in one large cluster, with a few outliers on the other side of the screen. The three clusters are not distinct at all, and the disconnected components are not separated. Also, just like all the previously mentioned examples, HDE leaves a large portion of the screen empty.</p><p>The treemap based layout <ref type="figure">(Figure 8(g)</ref>) was made by applying the "Fast Modularity" algorithm <ref type="bibr" target="#b1">[2]</ref>. splitting the regions such that edges are shortened, and randomizing node placement within their regions. The whole layout took less than a second to compute. The resulting layout very clearly shows three large clusters of nodes, with many internal nodes, and a large number of other nodes distributed around the screen. Within these clusters, interesting features, such as nodes of high degree, are easily visible. Similar features are also visible in the rest of the graph. However, there are artifacts, particularly near the edges of clusters, where nodes are spread out over skinny regions of the treemap. The treemap also imposes a fairly artificial rectangular shape to the graph, which can distract from other patterns that are actually present in the graph.</p><p>The space filling curve layouts (8(h), and 8(i)) were generated as described in this paper. The graph was clustered with the "Fast Modularity" algorithm <ref type="bibr" target="#b1">[2]</ref>, traversed to generate an ordering, then mapped to the screen with a space filling curve of sufficient order. That is, the Hilbert curve was order 11, and the Gosper curve was order 7. In all cases, the layout time is greatly dominated by the initial clustering calculation, just as in the treemap layout. However, this is done offline and only once, so that when the user interacts with the graph it can be updated very quickly. As with the treemap based layout, all three clusters can be seen clearly in each space filling curve based layout, and the internals of all three clusters can also be easily seen. Unlike the treemap based layout, these layouts do not encounter a problem with skinny clusters, due to the c-locality property of the space filling curves. While the Hilbert curve does still impose square boundaries on the clusters, the effect is much less pronounced than in the treemap layout. The Gosper curve, on the other hand, imposes no square boundaries, but it sacrifices filling the entire screen, as it leaves some space empty around its border. A Peano curve based layout was also generated, but was very similar in time and quality to the Hilbert curve based layout, and is omitted due to space constaints. Overall, only the treemap based layout and the space filling curve based layouts clearly showed the three separate clusters in the graph. Further exploration reveals that the three clusters are in fact of different groups of websites -one for university sites, one for government sites, and one for all other sites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Limitations</head><p>While we have shown this approach to be fast and effective at visualizing dense networks, it does still have some limitations. The approach as presented here is dependent on a good clustering to generate the ordering. So, if a dataset has no clear clustering, or if a poor clustering algorithm is chosen, there is a good chance that this approach will not work well. In particular, our approach will not perform well on artificial 'grid-like' graphs, which are prevalent in many graph drawing works. However, many real world networks do actually exhibit clustering. Finally, the space filling graph layout approach would run into a problem if the number of nodes matches exactly with the complexity of the space filling curve, as it would suddenly create many collinear points. For instance, if the number of nodes is exactly 4 n for some n, then the Hilbert curve based layout would place every node on the corner of the Hilbert curve of order n, resulting in a poor layout. However, this could be solved by adjusting the spacing factors or randomly jittering the nodes along the curve. While our current cluster separation approach has been effective on the data sets we have tried, it would theoretically fail in the pathological case of a graph with two identically sized clusters that are adjacent in the clustering hierarchy, as they would have zero spacing between them. However, this situation is very rare in real world data. While our approach guarantees that nodes are not placed in exactly the same location, it is still possible for them to get arbitrarily close, which can be a problem when nodes are of large or non-uniform size, or if they are being labeled. Finally, a space filling curve layout might not be as aesthetically pleasing as traditional force directed layouts, due to the artificial structure imposed by the curve. However, just like the treemap based layout <ref type="bibr" target="#b24">[25]</ref>, the space filling curve based layout could be used as an initial layout for a force directed approach, which would refine the layout in very few iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">FUTURE WORK</head><p>While our space filling curve based approach to graph layout is effective, there are still improvements that can be made. Accounting for inter-cluster edges is yet to be solved by taking these edges into account when traversing the hierarchy. Alternately, other matrix ordering algorithms could be applied here, in which case the clustering hierarchy would not be necessary. There are many other space filling curves which could be explored, such as H-curves and Sierpenski curves, as some of them have better c-locality than others. Other interactive techniques such as semantic zooming could also be added to this framework, and they would work well due to the very low amount of time it takes to recalculate a layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We have described how graph layouts generated through the use of a space filling curve guarantee several nice properties. Using a clustering algorithm to generate the ordering guarantees that each cluster is located in a contiguous region of space. Because the curves never self-intersect, the layout guarantees that graph nodes are never placed on top of each other. Furthermore, due to the c-locality property of the space filling curves, this layout guarantees that clusters of nodes are arranged with a good aspect ratio. The scalability and efficiency of space filling curves has been demonstrated using several real world datasets, and the performance has been compared to seven existing algorithms. We have shown that this new approach to graph layout is quite effective at dealing with dense graphs and capable of clearly presenting features that many other algorithms could not show.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>A protein homology graph laid out with our space filling curve based approach. Color corresponds to depth in the clustering hierarchy. |V | = 28,854,|E| = 1,180,816</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>4 Fig. 3 .</head><label>43</label><figDesc>Examples of space filling curves.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 3shows various orders of all three curves.The Hilbert curve (shown in Figures 3(a), 3(b), and 3(c)) is the simplest of the three space filling curves used here. At each recursion, every corner of the curve is replaced by 4 new corners. Thus, an order d Hilbert curve has 4 d points and 4 d − 1 segments of length 1 2 d .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>11 Fig. 4 .</head><label>114</label><figDesc>Mapping nodes to space filling curves of increasing order. A graph of network scans shown with Hilbert curves of increasing order. Each increase in order places the nodes closer to their final positions. Order 11 is at the pixel level, so further recursions will have no effect.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>(a) Peano curve -no seperation (b) Peano curve -with seperation Separating clusters. By adjusting the spacing between nodes according to the clustering information, clusters can be separated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Geometric Zoom. The graph can be distorted by increasing the spacing between selected nodes along the space filling curve. The left image shows the original graph and the other ones show the result of expanding the selected region by different zoom factors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Scalability. Our approach can scale to large graphs. This graph is of the streets in the state of Florida, |V | = 1,070,376,|E| = 2,712,798 One small region is expanded to show detail.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Results: Time to generate a usable layout for several graphs</figDesc><table><row><cell>Graph netscans</cell><cell>|V | 848</cell><cell>|E| 22,462</cell><cell>Clustering .0739s</cell><cell>Hilbert 0.0007s 0.0007s 0.0007s Peano Gosper</cell><cell>Total time 0.074s</cell></row><row><cell>california</cell><cell>6,107</cell><cell>15,160</cell><cell>0.655s</cell><cell>0.0043s 0.0039s 0.0043s</cell><cell>0.659s</cell></row><row><cell>pgraph</cell><cell cols="2">28,854 1,180,816</cell><cell>9.169s</cell><cell>0.0212s 0.0206s 0.0220s</cell><cell>9.190s</cell></row><row><cell>usafla</cell><cell cols="2">1,070,376 2,712,798</cell><cell>20.531s</cell><cell>0.8185s 0.7689s 0.8318s</cell><cell>21.337s</cell></row></table><note>process only takes Θ(|V |) operations, so this approach is limited by the clustering algorithm's complexity of O(|E| × d × log|V |)</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>Speed comparison of various algorithms on the "California" graph<ref type="bibr" target="#b3">[4]</ref>, |V | = 6,107,|E| = 15,160</figDesc><table><row><cell></cell><cell>Iters or Depth</cell><cell cols="2">Time/itr Clustering</cell><cell>Time</cell></row><row><cell>LinLog</cell><cell>200</cell><cell>53.7s/itr</cell><cell>N/A</cell><cell>10,737s</cell></row><row><cell>GVA</cell><cell cols="2">400 0.113s/itr</cell><cell>N/A</cell><cell>45.5s</cell></row><row><cell>FM 3</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>12.9s</cell></row><row><cell>GRIP ACE</cell><cell>N/A N/A</cell><cell>N/A N/A</cell><cell>N/A N/A</cell><cell>1.51s 0.19s or ∞</cell></row><row><cell>HDE</cell><cell>N/A</cell><cell>N/A</cell><cell>N/A</cell><cell>0.19s</cell></row><row><cell>Treemap</cell><cell>N/A</cell><cell>0.076s</cell><cell>0.655s</cell><cell>0.731s</cell></row><row><cell>Hilbert</cell><cell>11</cell><cell>0.0043s</cell><cell>0.655s</cell><cell>0.659s</cell></row><row><cell>Peano</cell><cell>6</cell><cell>0.0039s</cell><cell>0.655s</cell><cell>0.659s</cell></row><row><cell>Gosper</cell><cell>7</cell><cell>0.0043s</cell><cell>0.655s</cell><cell>0.659s</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This research was supported in part by the Intel Corporation, the National Science Foundation through grants CCF-0634913, CNS-0551727, OCI-0325934, CNS-0716691, CCF-0808896, OCI-0749227, and OCI-0749217, and the Department of Energy through the SciDAC program with Agreement No. DE-FC02-06ER25777. We would also like to thank those who provided the data sets <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b25">26]</ref> as well as Yehuda Koren, Andreas Noack, Roman Yusufov, and the authors of the Boost graph library and the Open Graph Drawing Framework for making the source of their graph layout implementations available online <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b33">34]</ref>.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://boost.org/libs/graph/doc/fruchtermanreingold.html" />
		<title level="m">Boost graph library&apos;s GVA</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Finding community structure in very large networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Clauset</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review E</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page">66111</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Drawing graphs to convey proximity: An incremental arrangement method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions On Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="197" to="229" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Data</surname></persName>
		</author>
		<idno>12/10/07</idno>
		<ptr target="http://www.cs.cornell.edu/Courses/cs685/2002fa" />
		<title level="m">California&apos; search results graph</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Data</surname></persName>
		</author>
		<idno>12/10/07</idno>
		<ptr target="http://www.dis.uniroma1.it/∼challenge9/download.shtml" />
		<title level="m">Graph of Florida streets from the 9th dimacs implementation challenge</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Graph of San Francisco Bay Area streets from the 9th dimacs implementation challenge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Data</surname></persName>
		</author>
		<idno>12/10/07</idno>
		<ptr target="http://www.dis.uniroma1.it/∼challenge9/download.shtml" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Protein homology graph from Large Graph Layout project site</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Data</surname></persName>
		</author>
		<ptr target="http://bioinformatics.icmb.utexas.edu/lgl/,ac-cessed12/10/07" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Zame: Interactive large-scale graph visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-N</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Goodell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE VGTC Pacific Visualization Symposium (PacificVis)</title>
		<meeting>IEEE VGTC Pacific Visualization Symposium (PacificVis)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multi-level graph layout on the gpu</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Frishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1310" to="1319" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Graph drawing by forcedirected placement. Software -Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M J</forename><surname>Fruchterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Reingold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1129" to="1164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Grip: Graph drawing with intelligent placement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gajer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Kobourov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Graph Drawing</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="222" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Topological fisheye views for visualizing large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="468" />
			<date type="published" when="2005-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">A Potential-Field-Based Multilevel Algorithm for Drawing Large Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hachul</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Universitaet zu Koeln</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An experimental comparison of fast algorithms for drawing general large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hachul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Graph Drawing</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="235" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graph drawing by high-dimensional embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Graph Drawing</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="207" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Vizster: Visualizing online social networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Boyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 IEEE Symposium on Information Visualization (InfoVis)</title>
		<meeting>the 2005 IEEE Symposium on Information Visualization (InfoVis)</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Census and survey of the visible internet (extended)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Pradkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bannister</surname></persName>
		</author>
		<idno>isi-tr-2008-649</idno>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
	<note type="report_type">technical report</note>
	<note>usc/information sciences institute, february</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A fast algorithm for balanced graph clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">V</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 IEEE Symposium on Information Visualization (InfoVis)</title>
		<meeting>the 2007 IEEE Symposium on Information Visualization (InfoVis)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="46" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">High level internet level traffic visualization using hilbert curve mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Irwin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Pilkington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM VizSEC 2005 Workshop</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="29" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Hierarchical clustering schemes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Psychometrika</title>
		<imprint>
			<date type="published" when="1967" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="241" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An algorithm for drawing general undirected graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kawai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="15" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Major information visualization authors, papers and topics in the acm library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Borner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Viswanath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">InfoVis04 Contest</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Korens algorithm implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
			<affiliation>
				<orgName type="collaboration">ACE and HDE</orgName>
			</affiliation>
		</author>
		<ptr target="http://research.att.com/∼yehuda/indexprograms.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Ace: A fast multiscale eigenvectors computation for drawing huge graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Koren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE Symposium on Information Visualization (InfoVis)</title>
		<meeting>the 2002 IEEE Symposium on Information Visualization (InfoVis)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">00</biblScope>
			<biblScope unit="page">137</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A treemap based method for rapid layout of large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Muelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE VGTC Pacific Visualization Symposium (PacificVis)</title>
		<meeting>IEEE VGTC Pacific Visualization Symposium (PacificVis)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A visualization methodology for characterization of network scans</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Muelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bartoletti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM VizSEC 2005 Workshop</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="29" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A comparison of vertex ordering algorithms for large graph visualization. Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lumsdaine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th International Asia-Pacific Symposium on</title>
		<imprint>
			<date type="published" when="2007-02-07" />
			<biblScope unit="page" from="141" to="148" />
		</imprint>
	</monogr>
	<note>APVIS &apos;07</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Munroe</surname></persName>
		</author>
		<ptr target="http://www.xkcd.com/195/" />
		<title level="m">Map of the internet</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Phyllotrees: Phyllotactic patterns for tree layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S T</forename><surname>Carpendale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Agarawala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroVis</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="59" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An energy model for visual graph clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Noack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2912</biblScope>
			<biblScope unit="page" from="425" to="436" />
			<date type="published" when="2004-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<ptr target="http://www.ogdf.net/" />
		<title level="m">The open graph drawing framework</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A scalable parallel force-directed graph layout algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tikhonova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Parallel Graphics and Visualization Symposium</title>
		<meeting>Parallel Graphics and Visualization Symposium</meeting>
		<imprint>
			<date type="published" when="2008-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A note on space-filling visualizations and space-filling curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 IEEE Symposium on Information Visualization (InfoVis)</title>
		<meeting>the 2005 IEEE Symposium on Information Visualization (InfoVis)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page">24</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yusufovs</surname></persName>
		</author>
		<ptr target="http://www.cs.arizona.edu/∼kobourov/GRIP" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
