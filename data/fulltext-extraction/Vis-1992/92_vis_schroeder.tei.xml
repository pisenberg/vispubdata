<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Montanaro</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Volpe</surname></persName>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>An Object-Oriented Scientific Visualization System</keywords>
			</textClass>
			<abstract>
				<p>VISAGE is a scientifi visualization system implemented in an object-oriented, message passing environment. The system ics to Xlib and Motif user interface. Objects are created using compiled C and interact through an interpreted scripting language. The result is apexible yet e&amp;ient system that has folvld wide application in ow user community. This paper &amp;scribes the object architecture and the major issues we faced when designing the visualization classes. Somple applicationr iuz also described. i n C k k S 0%&quot; 500 C h S S e S rangblgfrom V k d i Z a t h Md graph</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.0">Introduction</head><p>Visualization systems have become powerful tools for the scientist and engineer since they were first proposed in 1987 by the SIGGRAPH Panel on <ref type="bibr">Graphics</ref> Because scientific visualization is not mature, any successful system must allow the intrduction of new algorithms, and these algorithms must be able to operate on a variety of data types. To meet this extensibility requirement. clpcent systems employ a variety of architectures including network data flow, UNIX-like pipelines, and procedural interfaces.</p><p>Object-oriented languages and methodologies have &amp;veloped concurrently with the demand for sophisticated visualiiation systems. Our early experience with an objectaiented animation system <ref type="bibr">[lo]</ref> provided an implementation framework and rich animation class library that form the basis of VISAGE, the VISualization, Animation, and Graphics Environment.</p><p>Visualization systems can be broadly classified as either programmable or turnkey. Programmable systems provide a means for the scientist to experiment with provided techniques or to introduce new ones.  <ref type="bibr">[5]</ref>.</p><p>[8], [9] deliver a system for the comfort of the end user. These systems are better suited for people without programming knowledge, but require users to import data in supported formats. A turnkey system also presents a stable u s a interface.</p><p>VISAGE takes a different approach. In OUT environment we need a system that can package turnkey applications as well as serve as a research platform to discover new visualization techniques. Our object-oriented solution meets both objectives by providing: -An object-oriented architecture that uses subclassing to enforce complicated protocob and promote reusability. User interface classes that permit custom interfaces for a variety of applications. The same object-oriented structure is present in the user interface and X l l class libraries. These interface classes are isolated &amp;om the visualization classes. An underlymg scripting language that permits extension of packaged functionality. A uniform object paradigm that q u i r e s every component of the system to be an object with instance variables to maintain state and methods to operate on that state. All instance variables and methods can be accessed through the scripting language.</p><p>'This paper describes the architecture of the VISAGE visualization classes and application. Although we successfully implemented the system in an object-oriented environment called LYMB, the class design is applicable to other implementations. We start by describmg the goals that Continue to drive the design of the visualization classes. Next we describe the architectwe of the system and the visualization clarses. A brief description of implementation issues is followed by examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.0">Design goals</head><p>The VISAGE system was developed based on a number of design goals. The major goals are described as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.1</head><p>Object-oriented A primary design goal was to implement VISAGE using the object-oriented paradigm [ 111. The benefits of this approach are widely documented, but to us it means flexible, compact. and modular code that is easy to maintain. extend. and reuse. We also find that object-oriented system are easy to leam and use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data forms</head><p>In VISAGE, visualization data consists of a geometric representation plus additional scalar and vector data. Initially four 0-81862897-9/92 $03.00 @ 1992 EEE</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Shuctured grid</head><p>Unstructured grid The structured grid set is a topologically regular set of points whose coordinates may be non-uniform. The topological form is of a regularly subdivided cube. The relationship of one point to another is implicit in the data. The unstructured grid set is a set of points, or nodes. and topological organizations of nodes. or elements. For example, a set of eight nodes can be used to form a hexahedral (or brick) element. The points are generally randomly positioned with respect to one another, and the topological relationship of one point to another is maintained in the element specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">3 Data representation</head><p>Implementing efficient algorithms requires that data is stored and accessed in native form. By native form we mean that the various data types are not converted into some canonical form. Rather data structures and methods are constructed based on the particular characteristics of the data. For example, it is possible to represent the four geometric types described previously using a general unstructured grid data structure [ 121. Howevg penalties in storage and access requirements often result. Consider representing a structured point set with a unstructured grid representation. Instead of using a simple combination of dimension and aspect ratio, the structured point set would require at a minimum nodal coordinates and element connectivities. In addition, performing a simple search to determine the closest point to a specified point is straightfoward in a structured point set. In an unstructured grid set the process is much more compute intensive. In VISAGE, all data is stored and accessed in a form native to the type of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Animation</head><p>VISAGE was designed from the ground up to support general purpose animation. In VISAGE, animations are not sequences of static images, or isolated objects that periodically inrroduce new data into the system. Rather animations are defined pogrammatically and every object in the system including the user interface, algorithm, and data objects can all participate. In addition, all data objects in the system have the notion of time, and the ability to interact with other objects to read, write, and cache their data as necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Script</head><p>Figure 2 LYMB architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">5 Distributed visualization</head><p>Another important design goal was the ability to create distributed applications. This is important in order to take advantage of distributed compte and data servers. In addition, coarse grained parallel processing can be achieved in many applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.6</head><p>Portability VISAGE is portable, running on most UNIX graphics workstations including HP Series 300 and 700 computers, DECStation 5000, Silicon Graphics VGX, GTX, Personal Iris and Indigo, the IBM 6OOO series, and Sun 3 and 4. We designed the system to use native graphics software and hardware on each system (e.g., Starbare on the HP systems, GL on the Silicon Graphics), rather than relying on any single standard. We find this to be beneficial because some implementations of standard graphics libraries are not optimal on all systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.7</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Other goals</head><p>Of course there are a numbex of other design goals important to the success of any system. These include simple data abstraction for ease of use, efficient algorithms and data structures for rapid response, and well designed data interactors to improve system interactivity. In addition, we stress flexibility most of all. In VISAGE, the entire application, including the user interface, animation sequences, and data access is codgurable at run-time. The system is not built by writing compiled code to interface with object liiaries. Instead we use an inteqxetive environment to rapidly configure the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.0">Architecture</head><p>The VISAGE architecture consists of two major parts: the LYMB implementation environment and the visualization architecture. LYMB provides the fundamental mechanisms for object implementation and interaction. The visualization architecture includes specification of data and algorithm objects. This paper emphasizes the architecture of the visualization classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">LYMB LYMB [lo], [13]</head><p>is an object-oriented environment written in the C programming language. The usual object-oriented characteristics of object instantiation, data encapsulation, and inheritance are obtained by adopting a standard development methodology. LYMB implements object interaction by using run-time message passing, either directly within C-code or through an interpreter. LYMB currently contains over 500 classes including visualization. graphics, numerical computation, programming tools, the X and Xt libraries, and the Motif widget set.</p><p>The message passing mechanism is illustrated in <ref type="figure">Figure 2</ref>. LYMB messages are of the single form</p><formula xml:id="formula_0">object ml d..., mn;</formula><p>where object is the name of an instance or class, and ml, d, mn are messages to object. The trailing semicolon indicates the end of messages sent to object. Each message consists of a string plus additional parameters. if necessary. The following is a typical LYMB statement:</p><formula xml:id="formula_1">sctrlornew:x = # sin?;</formula><p>Here the object scalar is sent the new:x message to create an instance of the scalar class. The value of x is set to 45 and then the sine of the value is computed using the sin! message.</p><p>Messages may either originate from objects embedded in C code, or at run-time from the keyboard or files containing sequences of LYMB messages (i.e.. scripts). The result is that applications written in LYMB use a hybrid compiled/interpreted environment. This environment is both flexible and powerful, since compute mtensive tasks are written in C as object classes, but object interaction (which implements the application) is specified at run-time. In fact it is possible to write complete applications without writing any C code, provided all necessary classes are available. This interpreted environment is particularly important when creating graphical user interfaces with X11 toolkits using Motif, since the fine-tuning of resou~ces and callback behavior can be changed without the lengthy compile-load pro-LYMB is a complete programming language. Conditional execution, looping. procedures, and recursion can all be implemented using LYMB scripts. It is also possible to use object indirection and recursive parsing to exchange data between objects.</p><p>In LYMB, message passing is not confined to a single process or on a single computer. Interprocess and intercompter message passing is supported and provides a powerful tool to build dis- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Visualization architecture</head><p>The underlying visualization architecture in VISAGE is based on data flow. As a result there are two general object types: data objects and FOCXSS objects. Data objects represent and pro-vi&amp; access to data of various forms, while process objects produce, transform, or consume data objects. Taken together, data objects and process objects form a data flow network architec-</p><formula xml:id="formula_2">ture similar to AVS [2] or apE [3].</formula><p>The VISAGE data flow architecture is shown in <ref type="figure" target="#fig_2">Figure 3</ref>. Data is generally introduced into the system using reader objects. These objects create data set objects that are processed by data setjilter and computed featm objects. The computed features generate data objects called display data, which is a simple visualization form. Finally. diqday modellers map the display data through a lookup table and create another type of data object, rendering primitives for the particular comptex rendering library. The architecture is thus a three stage network of data objects: data sets, display data. and rendering pimitives, separated by process objects that generate. transform, and consume data.</p><p>The data set, which consists of a geometry, scalar, and vector data, represents data in efficient, native structures. It also supports a variety of data types for interfacing to different data forms. The computed feature transforms the large, complex data forms of the data set into the simpler, more efficient, and more general display data form. Display data serves as a common denominator between the more complex data set and the hardware specific rendering pimitives. The generality of display data also allows many different process objects to operate on it.</p><p>cess. whenever practical. algorithms are implemented at the display data level since the added capability is available to process a greater variety of data sources. Finally, display modellers interface with the rendering library to generate graphical images. These objects implement mechanisms for run-time instantiation of rendaimg primitive objects, resultmg in the portability and rendering efficiency that the system enjoys.</p><p>Simplicity is another important Characteristic of this architecture. There are only three classes of data objects, providing a data abstraction that is easy to understand and use. It is also flexible, supporting and interfacing to a wide variety of data.</p><p>A more detailed description of these objects follows. For each object class, we give a description plus an object model diagram Ill]. These diagrams represent object inheritance (shown as triangle connection) and object association (shown as straight line connection). Important instance variables are also shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="33.1">DataSet</head><p>The data set <ref type="figure">(Figure 4)</ref> is a composite object, consisting of three primitive data classes: scalar, vector, and geometry. Geometry is an abstract superclass of the four geometric repesentations structured and unstructured points, and structured and unstructured grids. Although only a single geometry. scalar, and vector may be processed at one time, the data set retains lists of the many possible scalars and vectors that may be associated with the geometry. The primitive data classes geometry, scalar, and vector inherit from visage data. Visage data is an abstract class that implements methods to manipulate and access time dependent data, and to interface with the reader objects. Hence all subclasses of visage data are transient.</p><p>The generic data object can represent arbitrary multi-dimensional mays. Methods are available for extracting and m h p ulating the data in various ways. A typical access method extracts portions of the data as scalars or vectors to be associated with the data set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.22">DLsplay Data</head><p>The display data object <ref type="figure">(Figure 4)</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="33.4">Reader</head><p>Reader objects <ref type="figure" target="#fig_6">(Figure 6)</ref> are process objects that read data from a file, converting them into data sets or display data. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.25">Wrtter</head><p>Writer objects ( <ref type="figure" target="#fig_6">Figure 6</ref>) are process objects that write data based on the form of their input data object. Only the netCDF writer object is available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">. 2 . 6 Data Set Filter</head><p>Data set filters <ref type="figure" target="#fig_6">(Figure 6</ref>) take as input a data set, generating a data set as output. Wical examples include the gradient and tri-angulation filters. The gradient object pocesses a data set consisting of a geometry and scalar to produce a data set consisting of the same geometry with the gradient vector field. The triangulation object takes in a data set and creates a data set consisting of an unstructured grid geometry. The triangulation is implemented using the Delaunay triangulation [17].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="33.7">Computed Feature</head><p>Computed features ( <ref type="figure" target="#fig_6">Figure 6)</ref>   and associated scalar data Some display filters take as input more than one display data (this is hue for other process objects as well, e.g., streamer). For example, data primitive takes two display data objects as input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="33.8">Display</head><p>For each point in the first input display data, the second display data is copied to it, aligned lLccoTding to the input vector or normal, and scaled and colored accodhg to the input scalar data or vector magnitude. An application of the data primitive is to ingest streamlines created from the streamer object, and then copy along it spheres defined from the sphere modeller. The spheres nqxesent fuel droplet size within an annular combustor as the droplets travel from the nozzle into the combustor <ref type="figure">(Figure   8</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.29">Display Modeller</head><p>Display modellers ( <ref type="figure" target="#fig_6">Figure 6</ref>) create rendering primitives from display data. There are two parts to this process. First, the display data must be transformed into a structure compatible </p><formula xml:id="formula_3">. I display linea ! ! diapplsy point8 ! ! dmplay p o t y w ! ! dinplay dl I ---U</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="32.10">Modeller</head><p>Modeller objects ( <ref type="figure" target="#fig_4">Figure 5 )</ref> are filters that are sources of display data. The cone modeller, for example, creates polygonal cone representations based on its resolution instance variable. In VISAGE, modellers also provide convenience methods to interact with the rendering process. These convenience methods allow modellers to be specified as the display modeller to the actor class. Then i n t d l y a display modeller is instantiated and interfsced to the display data created by the modeller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.0">Implementation</head><p>Implementing an object-oriented visualization system poses many problems. An overview of some of the more interesting ones, and the approach we used to solve them is given in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Network construction and execution</head><p>In VISAGE visualization networks are constructed by connecting filter and data objects together. Normally data objects are never explicitly created by the developer, instead they are created as a by product of the execution of a filter <ref type="figure" target="#fig_7">(Figure 7)</ref>. These data objects then become objects private to the filter, and store the result of the processing activity. The advantage of this is that if a change to a filter object in the middle of a network occurs, only those objects downstream of the change need re-execute.</p><p>The disadvantage of this is that large amounts of memory are consumed for storing the intermediate data representation. VISAGE networks can be constructed so that filter objects use the same output data object as input data object. Hence the output data overwrites the input data This reduces memory requirement at the expense of processing time.</p><p>Networks, once constructed. use an implicit scheme to control execution. Every object in the system, including the visualization objects, keeps track of modification time. Hence whenever the instance variables of an object are changed, its modified time is updated. When a request for data is made to an object in the network, the object queries its upstream neighbor for modified time, who then queries its upstream neighbors' modified time, and so on. If the modified time of the upstream object is greatex than the object itself, then the object must regenerate its output data. In VISAGE, the process oceurs as a backward propagating query for modified time, followed by a forward propagation of network execution, as required. This implicit scheme is different from many other systems that use an   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Data management</head><p>Data management is another concem in visualization. In typical object-oriented systems. data passed between objects is usually of a simple form: floats, integers, strings, etc. Pointers are typically not passed between objects, since knowledge of the structure of the data must be distributed outside the objects, violating the data encapsulation commandment of the object-oriented paradigm. In the design of the VISAGE classes, we limit pointer passing. However, to minimize data copying and improve performance, pointers must sometimes be passed so that data can be shared.</p><p>Passing pointer data between objects raises an important issue: which object owns the data? When an object allocates and then passes memory to another object, neither object knows when it is safe to release the memory. Failure to resolve this issue properly results in systems that exhibit excessive memory usage, or are brittle.</p><p>One possible solution is to use a LISP-like garbage collection approach. LISP systems depend upon the ability to tag unreferenced memory. Since memory is not tagged on most UNM systems, implementing garbage collection in a UNIX and C environment is &amp;cult. Garbage collectors can also be rather slow and unpredictable, reclaiming memory at inopportune times.</p><p>To address this memory management issue we implemented a reference count object, called " m g r , to keep track of the dynamic memory allocated in LYh4B. Memmgr routines are called instead of the usual C memory allocation routines, malloc, realloc, calloc, and free. All memmgr routines take the same arguments as their regular counte~~arts. but they also take an extra strmg argument that associates a particular object or function in the system with the pointer being tracked.</p><p>Memmgr keeps track of each reference to allocated memory.</p><p>When memory is initially allocated, its reference count is set to 1. Then every other object that accesses this memory registers its use with the memmgr register hction. Registering use of memory increments its reference count by 1. However, when an object no longer needs to access reference memory, it calls the memmgr fiee method. Freeing memory in this way reduces the reference count by 1. The memory can be safely freed when the reference count to an area of memory is reduced to zero. This approach minimizes system memory utilization. often data that passes through the visualization network is shared by a number of objects. For example, a list of points passed from an unstructured point set to a display data to a rendering primitive is allocated only once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">3 Distributed visualization</head><p>Given the size of data that are created today. and the complexity of some of the visualization techniques, it is important to utilize computational resources as efficiently as possible. One teclmique to achieve this goal is to implement distributed visualization.</p><p>In VISAGE, distributed visualization is implemented using LYMB message passing <ref type="figure">(Figure 2)</ref>. The key to this process is the object msg. Msg receives messages from objects, or through the parser (i.e.. user key-in or scripts). M i c a l message passing involves placing arguments on an internal stack, and then executing the method corresponding to the message sent to the object. These arguments are usually simple types such as integer, float, or scalar, but sometimes they are more complex types such as pointers to display data or float arrays. Passing complex arguments poses no problem when the objects exist within the same process. However, when these objects exist m separate pmcesses or on different computers. passing pointers will not work. Hence the msg object uses a dfierent mechanism when sending messages to remote objects.</p><p>The proxy object is used in conjunction with msg to perfonn distributed message passing. When a message is sent to a remote object 0. msg first tries to find it within its local object table. If it cannot find U, msg then tzies to find it m a remote LYMB pocess. The possible remote processes are specified at run-time as a list to msg. For each process in the list, msg connects to that pocess and determines whether object U exists. If it does exist, then msg creates a local proxy object to represent the remote object 0, and enters the proxy object into its local symbol  this point on, the proxy object handles message trafEc between itself and the remote object 0. The proxy object is also responsible for marshalliig data with XDR mutines to 0. Hence complex data types are transparently transmitted from one object to the next across pocesses or computers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.0">Applications</head><p>We refer to VISAGE as both a visualization class library as well as an application <ref type="figure">(Figure 9</ref>) that we distrihte to our end users. Besides using the visualization classes. the VISAGE application uses many other objects implemented in the LYMB development environment. Some of these classes include Motif widgets, Xlib wd Xt classes, programming tools such as collection, logic, and loop, and the OSCAR [lo] animation class library. A portion of the VISAGE application showing the use of many of these classes to implement 1-D probes is shown in <ref type="figure">Figure</ref> 10.</p><p>Because the VISAGE application is written using LYMB. it is run-time extensible. Users frequently extend VISAGE into new areas such as fusing image data f h n MRl and PET ( <ref type="figure" target="#fig_0">Figure   11</ref>) or visualizing blood flow in the human brain ( <ref type="figure" target="#fig_0">Figure 12</ref>). The example shown in <ref type="figure" target="#fig_0">Figure 12</ref> is especially interesting because animation cues, scenes, a random particle generator, and a numerical integration process to move the particles were added without the need to recompile or modify VISAGE.</p><p>Other users prefer to write custom applications using the VISAGE visualization classes. <ref type="figure" target="#fig_0">Figure 13</ref> is sn example of an environmental data set. Here the data consisted of water table heights plus monitoring and punping well locations. This was combined with local topographical information to show the placement of an industrial facility in relationship to a nearby river and the water table. Other applications that have been developed include golf visualization [21 J, VIVA, an application for exploring sliceariented volume data, and THAADS, a 3D command and control simulation system. Dozens of other small applications have been written by piecing together and extending existing LYMB scripts. Our users find that is possible to rapidly develop custom visualization applications in this way.     </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>V i s u a l i z a t i o n data structures. geometric data types were selected: structured and unstructured point sets, and structured and unstructured grids (Figure 1). A structured point set. also known as volume or uniform data, consists of a set of regularly spaced, orthogonal points [121. The geometric representation consists of an x-y-z resolution, possibly supplemented with tax-ay-az aspect ratios. The point coordinates and relationships are implicit in the data. The point coodnates in unstructured point sets are randomly located in space. The relationship of points one to another is totally unspecified.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>tributed systems. Distributed message passing is implemented using the XDR protocol [14]. so machines of different architectures can exchange data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Visualization architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Filter Display filters (Figure 6) take display data as input and generate display data as output. Because of the generality of display data. a large number of algorithms are implemented as display filter objects. ' b o examples of display filter objects are the decimation filter [20], and the contour filter. The decimation filter reduces the number of polygons in a mesh while preseming the original topology and approximating the original geometry. Contour filter generates contour lines from an input polygonal mesh</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Renderer object diagrams with the rendering library. Second, the scalar information in the display data object is mapped through a lookup table to generate color shading. If no scalar information is present, or if scalar mapping is turned off, the actor's property is used to color the object. Some rendering libraries are also capable of texture mapping. Texture coordinates are available from display data, and the texture file from the actor's property. These two pieces of information are then used to generate texture on the final image.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>explicit network executive to control b execution of network process objects [2]. An example LYMB script illustrates the visualization classes. The example constructs one of the s t r e d i e / fuel droplet representations of Figure 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Process object diagram.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>VISAGE visualization network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Fuel droplet size and path in annular combustor. VISAGE application showing main control panel and rendering window.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>VISAGE 1 D probe; plotting scalar values along arbitrary line.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 1 1 :</head><label>1</label><figDesc>Fusion of MRI (256 x 256 x 45,ldbit) and PET (128 x 128 x 15, &amp;bit) data from thc human brain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Visualization blood flow in the basilar artery. Data measured using phase contrast MRI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 :</head><label>13</label><figDesc>Water table visualization showing monitoring wells (yellow) and pumping wells (orange). (Seewlor plates, p. CP-25.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>71. PI. PI.</head><label></label><figDesc>, Image Processing and Workstations [l]. Since then several commerciq and academic systems have been developed [2]. [31. [41. [SI. 161. [</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Many systems [2], [3]. [6]. [7] use a network dataflow architecture to implement sophisticated visualization applications. Using this a p a c h . users can customize networks and readily introduce new algorithms. Turnkey systems [4].</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Fig- ure 5. Note that renderer is an abstract class that implements the rendering protocol. Speciiic renderer classes inherit from ren- derer</head><label></label><figDesc>and implement the pmticular methods necessary to properly initialize and control the rendering library.</figDesc><table /><note>represents points, lines, polygons, and mangle strips in any combination. Additional attribute information can be associated with the points including Figure 4 Data object diagrams.- This infor- scalars. vectors. normals. and texture coordinates. mation is used by the display filters to transform display data,and by the display modellers to process display data into render- ing primitives. Display data inherits transient behavior from vis- age data.333 Rendering Primitive VISAGE has many rendering class libraries. Each library consists of four basic parts. The renderer performs high-level ini-tialization and synchronizes the rendering process. The light and camera objects implement the particular light and camera func- tionality of the rendering library. The fourth part. the rendering primitives, implement the interface of geometry (points, lines, polygons. and triangle meshes) and attributes (normals, colors, texture coordinw) to the rendering library. The renderer main- tains lists of its lights, cameras, and actors. Actor is an object that maintains transformation and properties, and interfaces to the rendering primitives through its display modeller. The rendering process is initiated by sending a render! mes- sage to the renderer. This message can be sent dmtly by the user, or indirectly, as a result of interacting with the user inter- face objects. The renderer then causes the lights, camera, and actors update themselves, as necessary. To implement device independence, the renderer sends its class name to its lights. cameras, and actors. The class name can then be used to dynami- cally instantiate internal light, camera, and rendering primitive objects corresponding to the class of the renderer (and hence the type of rendexiig library). As a result VISAGE applications are independent of any particular renderiig library. The object diagram for the rendering classes is shown in</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Many shrt cuts have been taken advantage of in this example. Every object when created has initial values for its instance variables. Most of these are left unaltered. For example, the display modeller mtemally references a lookup table object. The default lookup table object is used. Also the renderer automatically creates lights and cameras since neither is specified.</figDesc><table><row><cell>P Create a renderer */</cell></row><row><cell>cdf-reader new: areader</cell></row><row><cell>filename 'casel.cdf;</cell></row><row><cell>P Create a streamline */</cell></row><row><cell>streamer new: astreamline</cell></row><row><cell>data-in= areader</cell></row><row><cell>startpsition= (1.23);</cell></row><row><cell>P Create drops along streamline */</cell></row><row><cell>d a t a e t i v e new: pearls</cell></row><row><cell>datajn= astreamline</cell></row><row><cell>source= asphere</cell></row><row><cell>range= [areader range?];</cell></row><row><cell>sphere-modeller new: asphere</cell></row><row><cell>resolution=3;</cell></row><row><cell>P Map display data to graphics library */</cell></row><row><cell>display-modeller new: draw-spheres</cell></row><row><cell>data_in= pearls</cell></row><row><cell>range= [ areader range?];</cell></row><row><cell>P Actor interfaces to renderer and modellers */</cell></row><row><cell>actor new: anactor</cell></row><row><cell>r Device indepadent renderer created */ modeller= draw-spheres;</cell></row><row><cell>renderer new: aren</cell></row><row><cell>actors= [actor instances?]</cell></row><row><cell>render! ;</cell></row></table><note>P The sphere is used by data primitive to represent dmps *I</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>table. From Intermediate data is stored;</head><label></label><figDesc></figDesc><table><row><cell cols="2">reduced compu-</cell></row><row><cell cols="2">tation</cell></row><row><cell cols="2">Intermediate data</cell></row><row><cell>is</cell><cell>wemitten;</cell></row><row><cell cols="2">reduced memory</cell></row><row><cell cols="2">requirement</cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Bmwn Mmahtion in scimtific Cunputing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">H</forename><surname>Mccamidr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Defmti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Conlputer Graphics</title>
		<imprint>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">21</biblScope>
			<date type="published" when="1987-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upum</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">brains md ottsm. The A*ation v i System: A Complutiaul Bnvirmment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fdhabcr</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
