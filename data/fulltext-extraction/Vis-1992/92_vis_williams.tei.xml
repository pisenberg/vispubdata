<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The State of the Art of Visual Languages for Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Williams</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of New Mexico Albuquerque</orgName>
								<address>
									<postCode>87 13</postCode>
									<region>NM</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
							<email>rasure@chama.eece.unm.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of New Mexico Albuquerque</orgName>
								<address>
									<postCode>87 13</postCode>
									<region>NM</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The State of the Art of Visual Languages for Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Data $ow visual language systems are now being used to provide sophisticated environments for the visualization of scient@ data. These systems are evolving rapidly and are beginning to encompass related technologies such as distributed computing and user inte flace development systems. This paper presents a hierarchical classijication of the components and issues involved, giving the reader an understanding of the design decisions and trade-08s that the developers of these systems are making. The component categories can be used as a framework for discussing where interoperability of competing visual programming environments might occur and what the future holds for these systems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The newest generation of sophisticated environments for the visualization of scientific data typically include a data flow based visual language which provides a graphical interface to predefined operators to import, manipulate and display data [ 11. Applications are constructed by using a mouse to link together icons representing the operators to create an executable block diagram. This facilitates the rapid prototyping of solutions to complex data analysis/ visualization problems.</p><p>The purpose of this paper is to describe the components that characterize a data flow based visualization environment and to identify the issues that must be addressed. This provides a framework within which to understand and discuss the design decisions and trade-offs made during the development of these systems. It also helps to identify the level at which interoperability between current visual programming languages might occur and directions for future work. The purpose of the paper is not to make side-by-side comparisons of competing systems. However, the following discussion is based upon the imple-  <ref type="table" target="#tab_0">Table 1</ref> summarizes the categories of components used for the classification. The choice of data flow as the Visual Language Programming Paradigm is the underlying concept upon which these systems are based. This representation is relatively consistent across current visual language environments, but the implementation of the actual mechanisms that support the execution of the Visual Language Program Process vary dramatically. A Development Environment is not a requirement of a visual language system, but is typically included because: 1) the original developers of the visual language needed one to efficiently build the system and 2) visual languages can function as application builders if a development environment is available to extend the system. Visualization Requirements detail the issues unique to the application of visual language envi-ronments to the analysis and display of scientific data. Finally, several areas are identified as Considerations for Future Work. These components are discussed in detail in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Visual Language Programming Paradigm</head><p>The visual language specification component defines the graphical elements that comprise the programming language and the meaning of those elements within the context of the visual programming paradigm includes syntax and semantics. The programmer's inrerJace to a visual language provides for access to the graphical elements of the language paradigm and may also provide for textual entry of additional program information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Language Specification</head><p>The syntax of a visual language may be thought of as the graphical elements that define its outward appearance. For a data flow language these are the operators (nodes) and connections that make up the flow graph network. Sample visual programming workspaces are shown in the color plates: Figure 6 (AVS), <ref type="figure" target="#fig_8">Figure 7</ref> (SGI Explorer), and <ref type="figure" target="#fig_9">Figure 8</ref> (Khoros).</p><p>Semantics refers to the meaning ascribed to valid constructs in the language. Operators can be distinguished based on their function. These include input, output, transfer, control, and extractor nodes. To solve complex problems using visual languages, control nodes are needed to provide run-time decisions to determine the execution order for operators. Control operators may include forloops, while-loops, if-then-else, merge, and trigger. Data dependent control operators extract information and then set values which chancre omrator parameters to direct the else operator. The first (identified by the double border) is closed, while the second is open to show the subprocedure's internal network. Other systems implement a "graphical hierarchy" that merely creates a pictorial hierarchy (like a group command in a draw package) but without any true programming abstraction. For a visual language to support recursion each instance of an operator must have its own local data per instance of execution. None of the current visual language systems support operators that allow recursion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Programmer's Interface</head><p>The programmer's interface to the visual language provides, as a minimum, a graphical editor for constructing the program flow graph. However, a language based exclusively on data flow cannot provide the best interface for every interaction with the programmer. Consequently, most data flow visual languages are augmented with additional modes of user input. These are typically used to facilitate the setting of operator parameters via knobs, sliders, buttons, and keyboard entry. <ref type="figure">Figure 2</ref> shows such a widget for controlling the isosurface value.  The expression of a visual hierarchy varies a great deal among different systems. Some systems implement hierarchical operators as a border around a grouping of operators, while others replace the grouping with a single (higher level) operator. For example, the Khoros workspace of <ref type="figure" target="#fig_9">Figure 8</ref> contains two instances of a user-defined subprocedure node in the branches following the if-then-The keyboard can also be used to enter textual expressions for operator parameters such as the control variables for the count-loop in  Systems that combine several user interface modes are referred to as multiparadigm systems. Graphical editors may also be syntax sensitive to prevent the programmer from creating an illegal program network. <ref type="figure" target="#fig_4">Figure 4</ref> demonstrates how colors can be used to denote data types. An efficient means of accessing operators and selecting one from those available is essential to the productivity of the visual programmer. Some systems advocate a palette of icons representing the nodes, others display menus listing the textual names of operators. <ref type="figure" target="#fig_5">Figure 5</ref> shows both a display menu (at the top) and a palette (at the bottom) for accessing operators. Either of these methods becomes cumbersome when there are a significant number of operators (say, greater than 50) available. A hierarchical arrangement of operators grouped into appropriate categories is necessary, the number of levels determined by the size of the system. While this does provide for an orderly search, it can increase the time required to access operators.</p><p>And finally, aside from showing the general flow of data through the network, a visual program is not self documenting. The programming interface should support the addition of documentation that can be associated with the various graphical components (operators and connections) of the visual program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Visual Language Program Process</head><p>A visual program process is analogous to an operating system process--it is a running program together with its associated state and data. Issues that must be addressed include the functionality embodied within an operator definirion, the execurion model employed, and the characteristics of the data model that an operator works on. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Operator Definition</head><p>Operators for traditional textual languages, such as Fortran and C, are relatively simple. For example, an "add" operator uses two scalar values as its input to produce a single scalar output. The actual machine instruction executed is a function of the data type of the scalar values, which is determined at compile time. An analogous, but more complex, description can be given for an operator in a visual language, beginning with an understanding of the abstraction level of the operator. An "add" operation typically available in a visualization environment may be many levels of abstraction above the analogous machine instruction. For example, adding pixel values of two images together. Similarly, an operation to perform some type of data rendering is an abstract operator because its actual functionality is dependent on the data model (type) to be acted on by the operator. In other words, the level of abstraction is derived from the data model used and the function being performed. Visual languages derive much of their power by having abstract operators which hide the complexity of the data model and data manipulation from the user.</p><p>Current visual language systems utilize a variety of techniques to specify the interface to operator modules (which may be differentiated by their binding method, as described in the following paragraphs):</p><p>programan operator is a program executable by the operating system (bound as a UNIX process), function callan operator is a textual language function call interface (dynamically linked or compiled), parseran operator is a string passed to an expression parser (visual language is translated as input to the parser, which then interprets the string), or codean operator is a set of textual language instructions (compiled or interpreted at run-time). Each interface specification technique has its own inherent advantages and disadvantages and also impacts the implementation of the data and execution models as discussed below.</p><p>There are a number of different approaches to binding an operator to a specific instance for execution within a visual program. These are also influenced by the method selected for the operator interface. In general, the later the binding time the better, but at the cost of increased overhead in the execution model. For example, an operator with a program interface may be initiated as a process at the time it is accessed from a menu and placed in the visual program (early binding), or it may be started as a process when it is dispatched after being scheduled (late binding). While an operator with a function call interface, may be executed when it is dynamically linked by the dispatcher (late binding), or it may be executed as part of a compiled visual program (early binding). Operators are polymorphic if the output of any operator can serve as the input to any other operator. This can be achieved if the operators do not have any side affects with respect to the rest of the visual program and if they can fully interpret the data model with respect to the operation being performed. Using this definition, it is not likely that a very comprehensive system will ever be fully polymorphic--it would not be practical. For example, the "add" operation may be able to operate on any specific instance of the data model, but it is not reasonable to expect a "volume renderer" to function correctly for all possible applications of the data model (for example a 2 D field).</p><p>The implementation of the operator functionality may be coded in a traditional textual language such as C or Fortran or a parallel programming language like C* or Fortran 90. If the programming paradigm supports hierarchy, a higher level operator may be built up as a visual program consisting of a flow graph of lower level operators.</p><p>By definition, data flow operators consume and produce blocks of data. "Data granularity" refers to the size of the block of data processed by an operator. Consider the data moving through a visual process to be a stream of blocks. If the block size is the same as an instance of the data model (the norm for current visualization environments), then the data granularity is large. Hence the name "large-grain data flow." If the block size is the same as an atomic element of the stream transport, then the data is fine-grain. "Fine-grain data flow" operators are needed for real-time process control or real-time signal processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Execution Model</head><p>To become a visual process a visual program must be executed. The program, described as a flowgraph of operators, is first translated, then the operators are scheduled (which may be inherent in the translation) and dispatched.</p><p>Most visual languages are translated via interpretation to provide the user with a higher level of interactivity with the visual process and to allow for partial program execution. But, interpretation does add to the overhead of executing the visual process. It is very difficult to design a compiler for a visual language because of the attributes of the data flow paradigm and the attributes of the operators. Systems that have been implemented with a compiler embed a "quasi-static" scheduler to manage the visual process execution.</p><p>The scheduler of a visual program determines which operator should be active depending on data availability and demand for data. Most systems have a global coordinating scheduler that keeps track of such information, but it is also desirable to have the operator itself determine when it should be active. In the case of operators that have a program interface, the scheduler may also have knowledge of a network of other machines on which it may distribute processes at the operating system level.</p><p>The dispatcher is responsible for binding the operator to the visual process. For an operator with a function call interface, the dispatcher can dynamically link in the object code. A dispatcher for program operators may execute an operating system process or it may send new execution information to an operator that is already running. When visual processes are being distributed across a network of machines, each machine may have its own local dispatcher which communicates with the scheduler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Data Model</head><p>Large-grain data flow systems may not save intermediate data (no permanence) because storing of all the data generated within the visual process is prohibitive. Instead, intermediate data results must be recomputed in order to produce new output. These systems do not save state and therefore program execution cannot be interrupted nor can partially executed programs be recovered.</p><p>The transport of data between operators can vary from using allocated memory of a single process (when operators with function call interfaces are all linked to a single process) to using a combination of UNIX shared memory and sockets. In the first case, the data can easily be global to the entire visual program which greatly simplifies data transport and storage. In the second case, there ate typically many processes communicating with each other. If these are on different machines, efficient use of data transport (permanent and non permanent) dramatically effects the performance of the system.</p><p>A visual language for a specific application domain will typically have its own internal data structure for representing the data model accepted by its operators. As polymorphism of operators is attempted across several application domains this representation necessarily becomes very complex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Program Monitoring</head><p>The monitoring of a visual process is useful for determining its proper performance and in aiding the programmer in debugging the program. Interpreted systems typically highlight the operator(s) as they are running to give the programmer an execution view of the visual process state. This is shown in <ref type="figure" target="#fig_4">Figure 4</ref> where the colorizer operator is active (highlighted). Most systems also allow the user to probe a connection so that intermediate data can be viewed or rendered. The notion of visual process monitoring is sometimes referred to as "program visualization" <ref type="bibr">[7]</ref>. For example, Khoros operators can be individually executed as a network is incrementally built up and single stepped for debugging purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Software Development Environment</head><p>The software system has yet to be created which can meet everyone's needs "off-the-shelf." Since the field of scientific visualization is in its infancy, with new techniques and applications appearing almost daily, visualization environments must be designed so that they can be modified and extended. The components of a visual programming environment that provide the support needed to add new operators to the system include a user interjluce develop" sysrem (UIDS) [8] for specification of program interface(s) and a method of describing data structures so that a common set of data transport utilities can be used. If a high-level specification is used for the operuror programming interjiuce and if the data structure can be described abstractly, much of the code needed to implement a new operator can be generated automatically. Once a new operator is created, it must be installed, documented, and maintained via system cunjgurarion manugemenf tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">User Interface Development System</head><p>Building a visual programming system is a complex software task that integrates user interface-software, data processing software, data rendering software, and the host operating system and windowing system. All of the current visual language systems are layered on either a custom user interface (U) software toolkit or an existing standard <ref type="bibr">(MOTIF, Windows, Athena, OLIT, etc.)</ref>. For the display of data, developers of visual programming systems choose to use either a custom toolkit and/or a combination of standards (PI-IIGS, PEX, GL, Xlib, etc.).</p><p>To make the development of the visual language programming system more efficient, developers may either rely on using a commercial user interface builder, or build all of the user interface by hand, or develop their own user interface builder that works well with the chosen U1 toolkit and visualization toolkit. The user interface builder often has a code generator as a back end. The generated code acts as an application framework for a new operator. Providing the programmer (who wishes to create a new operator) with a development environment allows the basic system to be extended to better solve specific applications. In addition, the visual language interface might only be used in the early stages of prototyping a solution, with the end product not involving a visual program at all. Instead, a simplified, custom interactive interface may be created for easier access by end users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Operator Programming Interface</head><p>Most current visual programming systems do not include a complete UIDS to aid the end user with creating a custom interactive application, but most do provide for a great deal of flexibility in adding new operators to the visual language. For example, the operator programmer may be given a library of programs for accessing a specific data structure or an abstract data type that can encompass many possible data structures. This library would include functions that would be used to make the operator compatible with other operators within the visual language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Configuration Management</head><p>Finally, an operator needs to be installed, maintained, and made accessible to the visual programmers. If this is to be done in a productive manner, i.e. not in a haphazard way, configuration management tools need to be provided within the development environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Visualization Requirements</head><p>The requirements of a software environment with respect to the visualization of scientific data are somewhat de-coupled from the components of the visual language itself. While it is true that the visual language is the mechanism used for generating an image, the same can be done with textual based programming language. However, the visual programming paradigm provides the scientist or visualization specialist with a flexible tool for graphically representing the sequence of operations that are required: First the data must be imported into the system; then manipulations are performed to achieve some desired result, which is then displayed using some visualization technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data ImportlJ3xport</head><p>Existing visualization systems each use their own internal data structure to represent the data model accepted by their operators. Therefore, users' data must be translated. usually through a file-read or library call, into the appropriate data format. The data structures used for scientific visualization can be classified into four groups: data on a structured uniform Cartesian grid with implicit coordinate information, data on a structured non-uniform Cartesian grid with explicit coordinate information (i.e. curvilinear grids), data on a non-structured grid and geometry data. The requirements are application specific but if the data structure for a particular visualization system is not robust enough to handle a certain class of data, the user must seek a solution elsewhere. Some systems utilize multiple data formats to represent different types of data. This implies that there are different operators for different data classes.</p><p>Thus a user might not be able to accomplish a desired visualization if an operator is not available for a particular technique within a data class. Other systems use a unified data model where all data is of a general class with specializations which aid in better memory management as well as assisting in the visual programming interface by indicating and allowing only legal connections. Polymorphic operators can then manipulate the data appropriately for each specialization.</p><p>Ease of use is another differentiating factor between visualization systems. Data importation either involves making library calls, editing an ASCII file and using that for data translation possibly through a GUI, or creating an operator to translate user data into the system's internal data structure. Most current systems do not force the user to make library calls for the data translation step. A stand-alone translation application may be functionally powerful but difficult to use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Data Manipulation</head><p>The data manipulation is performed by operators within the system which have the capability to compute, enrich, enhance, extract or otherwise transform data. Manipulations can be grouped into three distinct classes of transformations: data to image, data to data, and data to geometry.</p><p>Data to image is used in direct image-based visualization.</p><p>In this class, data values are mapped directly into a color space and the result is a displayable image. An example is shown in <ref type="figure" target="#fig_7">Figure 6</ref> which maps the pressure field for a global ocean model to a color continuum. Data to data transforms permit manipulation of the data to be visualized. <ref type="figure" target="#fig_9">Figure 8</ref> demonstrates this manipulation by performing a Marr filter on the image data (based on the data variance).</p><p>Extracting scalar values from a vector field is another example which is shown in <ref type="figure" target="#fig_7">Figure 6</ref>. Data to geometry transforms are required since these systems render geometry, typically utilizing Z-Buffer hardware, during the visualization process. This is shown in <ref type="figure" target="#fig_8">Figure 7</ref> where an isosurface representing DNA nuclear material is extracted from a confocal microscopy data set of a dying cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Data Display</head><p>The techniques used for data display include graphics and rendering: transparent surfaces, volumetric rendering techniques, etc. Additionally, there is a presentation requirement for 24imensional visualization or 3-dimensional visualization. Most systems excel on one or the other, both not in both. Coupled with this requirement is the need for annotation of data and images. Since so much of scientific data is based on dynamical models, animation is an important requirement. There are two basic types of animation: image based and geometry based. Image based animation refers to the process of generating a sequence of images and playing them back to form an animation loop. Geometry based animation refers to the process of saving disjoint (over time) geometries and rendering those back as a sequence. This, of course, requires rendering hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and Directions for Future Work</head><p>The hierarchical classification of visual language system components presented in this paper has been developed and refined over the past two years based on the authors' experiences with creating a visual programming environment, analyzing and using other visualization sys-tems, and attempting to specify the "ideal" system for the future. This classification will continue to change as visual languages continue to evolve, but the categories of components defined in <ref type="table" target="#tab_0">Table 1</ref> should remained relatively constant, while most of the changes will occur in the specific details as we gain a better understanding of the issues involved.</p><p>The visual programming environment of the future will be an elegant blend of all the features discussed above. It will be used as a software development environment for scientific research which supports many levels of interaction within the system. Additional areas which should be considered when looking toward the future include colluborative programming and interoperability between systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Collaborative Programming</head><p>Visual programming provide a great potential for collaborative programming. If the user interface of the visual programming language is distributed to a set of users across a network of machines, they could simultaneously write a single program. While the concept of group-ware programming is not new, its application to visual programming will allow for a more natural implementation. In addition, a heterogeneous distributed computing environment must be supported by the scheduler so that the location of data and compute resources is transparent across the network of participants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Interoperability</head><p>Current visualization environments, while similar in many respects, exhibit a wide disparity in the types of operators which are included with each system. These differences may be attributed to the original application interests of their respective developers. For example, some systems are strong in data display operators using various rendering techniques. Others emphasize data manipulation with many operators for data analysis.</p><p>In an ideal world, the visual programmer could combine the results from several systems, capitalizing on the strengths of each. This interoperability could take place a several different levels, from the sharing of data, to the sharing of operators across different environments. To achieve operator compatibility, software development tools will be required within visual programming environments that allow a user to easily wrap a non-standard function call interface with the data token conversion, data transport, etc. as needed. This conversion process will lead to a better understanding of how various systems are implemented and may motivate developers to provide a common set of language support mechanisms and interface definitions that will facilitate interoperability.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>execution. Figure 1 identifies several of these different types of operators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure</head><label></label><figDesc>Figure 2: SGI Explorer control panel for isosurface operator containing dial widget and toggle buttons.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Khoros count-loop and variables pane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>AVS network with different colored connections representing different data types. Active operator is highlighted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>SGI Explorer operator selection windows using both display menu (top) and palette (bottom).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9</head><label>9</label><figDesc>shows the Khoros interactive User Interface Specification (UIS) file Editor which describes the graphical interface of a new operator to the code generators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>AVS workspace demonstrating imagebased vlsuailzation. Data is from ocean circulation model computed at LANL's ACL on the CM-2. Pressure field at 80 meters is mapped by a linear colormap showing regions of high and low pressure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>SGI Explorer workspace demonstrating geometry-based visualization. Dataset was sampled with a confocal microscope in the Ufe Sciences Division at IANL. isosurfaces represent DNA nuclear regions of a dying cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Khoros workspace with two Instances of a user-defined Marr filter subprocedure that contains a loop to pass through the data twice. The variance of the image is extracted and used to determine which version of the Man filter should be executed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Khoros interactive Graphical User Interface Editor as used to define the UIS flle for a new operator. Code generators then create all the interface code to integrate the operator into the visual language. (See mlorplates, p. CP-23.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Hierarchical classification categories</head><label>1</label><figDesc></figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was partially sponsored by Los Alamos National Laboratory (contract number 9-XF99-E6828-1). It was also performed under the auspices of the Department of Energy and was partially funded by Department of Energy High Performance Computing Grant KC0701 and NSF STC-CPRC CCR-9 12008.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">W</forename><surname>Brodlie</surname></persName>
		</author>
		<title level="m">ScientiJc Visualization: Techniques and Applications</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An Open Environment for Image Processing Software Development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">I992 SPIW IS&amp;T Symposium on Electronic Imaging Proceedings</title>
		<imprint>
			<date type="published" when="1992-02" />
			<biblScope unit="volume">1659</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Application Visualization System: A Computational Environment for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">XEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Dataflow Toolkit for Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ZEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="60" to="69" />
			<date type="published" when="1990-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Architecture for a Scientific Visualization System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Usualization &apos;92</title>
		<meeting>Usualization &apos;92</meeting>
		<imprint>
			<date type="published" when="1992-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Taxonomies of Visual Programming and Program Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Usual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="97" to="123" />
			<date type="published" when="1990-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">User-Interface Tools: Introduction and Survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="15" to="23" />
			<date type="published" when="1989-01" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
