<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visual Query Specification in a Multimedia Database System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Keim'</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institut fiir Informatik</orgName>
								<orgName type="institution">Universitiit Munchen Leopoldstr</orgName>
								<address>
									<addrLine>1 lB</addrLine>
									<postCode>8000</postCode>
									<settlement>Munchen</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Computer Science Department</orgName>
								<orgName type="department" key="dep2">Naval Postgraduate School</orgName>
								<address>
									<settlement>Monterey</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Visual Query Specification in a Multimedia Database System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Wsual Query Specijication</term>
					<term>Graphical User Interface</term>
					<term>Multimedia Database System</term>
					<term>Natural-Language Interface</term>
					<term>Information Retrieval</term>
					<term>Image Data Management</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper we describe a visual interface for a Multimedia Database Management System (MDBMS). In spite of the technological advances in display devices, DBMS query languages are still linear in syntax as it was two decades ago. Although natural language interfaces have been found to be useful, natural language is ambiguous and dvficult to process. For queries on standard (relational) data these difficulties may be easily avoided with the use of a visual, graphical interface to guide the user in specifying the query. For image and other media data which are ambiguous in nature, we use natural language processing combined with direct graphical access to the domain knowledge to interpret and evaluate the natural language query. The system fully supports graphical and image inpuvoutput in different formats. The combination of visual effect and natural language specijication, the support of media data, and the allowance of incremental query specijication are very effective to simplib the process of query speciJcation not only for image or multimedia databases but also for all databases.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The Visual Query Specification Interface is designed as an integral part of the Multimedia Database Management System (MDBMS) to support a natural query specification process for conventional and image or other media data. Over the last two decades several research projects have been conducted in the area of user interfaces for (multimedia) database systems. The first approach for a graphical database interface is the well-known QBE interface <ref type="bibr">[Z0077]</ref>. Most recent research in the area of user interfaces focuses on the entity-relationship WONG82, FOGG84, ROGE881 or the more complex semantic and object-oriented data model [KING84, GOLD85, BRYC86, AGRA901, allowing queries to be directly specified within the schema. In contrast, we use an extension of the relational model to handle and manipulate media data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vincent Lum* Systems Engineering, Chinese University</head><p>Shatin, Hongkong vlum@cusel 1.se.cuhk.hk Another approach to achieve an easy and user friendly query specification was chosen by researchers in the artilicial intelligence area. Much effort went in building natural language processing systems capable of understanding queries expressed in natural language. An overview over the research in this area can be found in [&amp;LE871 and a good example for the current state of the art is the TEAM system <ref type="bibr" target="#b5">[GROS87]</ref>. Because of the problems related to natural language understanding hardly any of the systems is actually used for retrieval in databases. In our system, we are not trying to completely understand natural language. We argue that in order to express a query on formatted data in most cases natural language understanding is not necessary. The user can easily choose the necessary tables and attributes from lists, type the desired values and combine simple conditions into more complex ones. To our knowledge, none of thenatural language interfaces to database systems can handle complex combinations of conditions because of the semantic problems related to multiple sentences.</p><p>The manipulation of image data is not straightforward as in conventional databases. One main problem is the retrieval of image data based on contents. The difficulty arises because we must match the contents of the media data in the database with the content specification in the query. This difficulty is intrinsically tied to the very rich semantics of multimedia data. To answer queries posed on images a person must draw from a very rich experience encountered in life to derive a good answer. One must have a sophisticated technique at analyzing the contents of the images to get the different semantics associated with the images. Automatic image analysis is not only difficult but almost impossible because little variation in details or application context may change the interpretation of an image. Technology today is not advanced enough to expect systems which have this kind of capability to answer multimedia queries.</p><p>However, humans can abstract the contents of multimedia data into text and use the text description equivalent to the original multimedia data to match the user request or query. <ref type="figure">Figure 1</ref> shows the format of multimedia data which consists of the registration, raw and description data. Raw data IMAGE <ref type="figure">Figure 1</ref> : Image Data Format is the bit string representation of the image, video, sound, etc. obtained from scanning or digitizing the original multimedia data. Registration data enhances the information about raw data and is not redundant. Description data is for specifying the contents of multimedia data. In our system, we assume that users will supply the description data in natural language form.</p><p>To accomplish the goal of content retrieval of multimedia data, only a restricted interpretation of natural language is necessary which is done by the parser component using the application dependent dictionary as a semantic basis. The current implementation of the parser uses augmented-transition network parsing and interpretation routines. The details of the parser are beyond the scope of this paper but are given in IROWE911.</p><p>A problem of the natural language approach is that it is generally the case that the description of a multimedia data does not exactly match the description of a user query. The reason is that it is difficult for different users, or even the same user at different times, to describe the same thing identically because the user may use synonyms or generalize/ specialize categories belonging to the domain of interest and so on. Hence, in an earlier paper we proposed an intelligent approach to approximate matching by integrating object-oriented and natural language understanding techniques. The details of the natural language processing done by the parser and matcher component of our system are beyond the scope of this paper. They are given in [GUGL92, LUM921. A prototype of MDBMS has been implemented at the Naval Postgraduate School PUM89, ROWE911.</p><p>A visual user interface like ours is generally applicable in all situations, and the evaluation of queries is less complicated and less time-consuming than pure natural language processing. In the remaining part of this paper, Section 2 outlines the important features of the Visual Query Interface and gives examples for query specifications. Section 3 describes the other database operations (schema definition, insert, update and delete) and Section 4 gives concluding remarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Visual query specification</head><p>The goal of a visual user interface is to support the query specification process allowing the user to use the database system efficiently. It should allow inexperienced users tore-trieve data from the database without having to know a specific query language. In today's database management systems the user is forced to think in terms of data model and query language, differing a lot from his way of thinking. Often a user can express a query easily in natural language, but has difficulties to express it in a given query language.</p><p>Most queries involve both media and formatted data. For conditions on the media part of a query we use our intelligent matching algorithm which is directly processing natural language. To help the user in describing the desired media data we provide direct graphical access to the domain lmowledge used to interpret and evaluate the natural language expression. For conditions on formatted data, natural language is too imprecise and may lead to undesired results. We argue that for formatted data the use of natural language is not necessary. The system already knows the table and attribute names andif this information is presented to the user in an adequate waythe user can easily specify his query without using natural language. We think, that a visual, graphical user interface is best suited to support the user in the process of specifying a query.</p><p>The data model adopted in our system is an extended relational model. Despite some drawbacks the relational model has great advantages: It is well known, widely used and has a firm theoretical basis. For our purpose, we extend the relational model to capture media datatypes and, as shown below, we also extend the query language to allow the manipulation of media data and to facilitate the query specification process.</p><p>Before describing the Visual Query Interface in more detail, we first outline ways to achieve a natural query specification process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Towards a natural query specification</head><p>Usually every user can describe a query (or at least the desired result) easily in natural language. Unfortunately, natural language expressions representing a query are imprecise and difficult to automatically translate into a formal query language to be understood by a database management system. We argue that the gap between the user's way of expressing a query in natural language and database manipulation languages like SQL can be improved considerably.</p><p>When comparing the user's natural language (NL) expression for aquery with corresponding SQL statements the first difficulty is that the table and attribute names do not exactly match. In a visual user interface this problem is easy to overcome. Lists with all table names can be presented to the user who simply selects the desired ones using a pointing device. In the next step lists with the attribute names of the selected tables will be presented to the user. Again, he only chooses the desiredones using apointing device. In contrast to natural language processing no difficult and time-consuming matching between the users' NL expressions and the table or attribute names is necessary.</p><p>Another difficulty is related to joins between tables. In examining a large number of queries expressed in natural language as well as SQL we found that in most cases the join condition directly corresponds to some specific NL expressions. However, the tables connected by a join condition had to be deducted from the context because in most cases they were implicit. Additionally, thenumber of joins used in most of the queries was small compared to the number of possible joins. This can be explained by two facts. First, the number of semantically meaningful joins is restricted and second, some of the most frequently used joins are already intended at the design time of the database. In order to provide a natural way of expressing joins, in our system we allow the database designer and user to define and name joins prior to their actual use. A predefined join can involve more than two tables (e.g. two tables joined by means of a third table) thereby providing a simple way of expressing m:n relationships. Once defined and named, all predefined joins can be used to specify a query. Predefined joins differ from views: First, the result of a predefined join is not a table as in the case of a view, but a specific connection between tables. Second, predefined joins allow connections between different levels in nested queries. Examples are given in the next section.</p><p>Another thing we learned in examining the process of human query specification is the handling of complex queries composed of an arbitrary combination of conditions. Given acomplex data retrieval task the userpartitions it into smaller subtasks which are easier to handle. Starting with the easy parts of the query the user deals with all parts and combines the results into the final solution. In our system we support this way of handling complex queries by an incremental query specification which is described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Description of the query specification</head><p>In this section, we will describe the Visual Query Interface in more detail by presenting several examples. We will show the main features of the Visual Query Interface, especially those which are different from other graphical database interfaces. We start with a general description of the steps used in the retrieval process. When starting the MDBMS system the user will be automatically connected to the Visual Query Interface and the first step is to select the desired database. Then the user gets the system menu providing the main database manipulation functions: insert, delete, update and retrieval. When selecting retrieval, the user gets the query specification window. The next step is to select the tables to be used in the query. For each selected table a list with all attributes will be displayed in a separate window and all predefined connections involving at least one of the selected tables will appear in the Connections window. To specify the result list (projec-tion) the user has to move the desired attributes to the Result List. Now, only the conditions need to be specified. Using connections, attributes from the selected tables and operators provided by the Tool Box, the query can be built easily using the mouse. In the Query Representation window the query is displayed graphically. Each part of the query is represented by a small box, simple conditions by a single box, subqueries by a double box, and the connection lines are labeled with thekind of connection used. An advantage is that every part of the query can be addressed €or edit or delete at any time during the query specification process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Predefined joins</head><p>A special feature of the Visual Query Interface are predefined joins. Predefined joins can be defined at design time of the database by the database designer. Having the necessary connections between tables in mind, the database designer tunes the database so that joins can be executed efficiently. All semantically meaningful joins can already be defined at design time. However, if other joins are needed later, the user can define them at any time using the NEW option.</p><p>For this paper, let us consider a sample database with the following tables: <ref type="figure">(s-nc s-name, class, yr-built, cap-id, mission-id, base-</ref> Predefined joins allow an easier specification of complex queries. The user does not need to think about the attributes and conditions necessary to join tables, he simply chooses the desired one out of the predefined joins in the Connections window. Predefined joins can involve more than two tables, e.g. the following SQL statement expresses a three way join between ship and weapon: To express the join conditions of the same query using the Visual Query Interface, only one step is necessary. After selecting tables and attributes the predefined join ship carries weapon has to be selected. The result is displayed in the Query Representation window as shown in  Predefined joins can even be used to express joins of relations with themselves, e.g. the query 'Select the name of each officer together with the name of his immediate commander!' can be easily specified using a predefined join. The user could specify the query as follows: First he has to select the officer table. Since he deals with two instances of this table he has to select it twice resulting in an officer1 and officer2 window. The last step is to select the predefined join oflcer is-commander-of oficer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>mission (m-id, m-name, direction, goal, task) navy_base (base-id, location, size) officer (0-id, 0-name, address, salary, commander-id, ship-ns ship</head><p>Two more things about predefined joins need to be mentioned: First, any kind of join (not only equijoins) may be predefined and second, it is allowed to predefine identical joins with different names. This is useful to allow an easy identification of the required predefined join because the same query can be expressed differently. A simple example is ship carries weapon and weapon is-carried-by ship.</p><p>The internal handling of predefined joins and related query optimization issues are beyond the scope of this paper. They are described in D I M 9 11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Incremental query specification</head><p>To support incremental query specification we allow the user to start with any part of the query; e.g. to specify the query "Select the name of ships which carry all weapons of the category 'surface-to-air'! " the user can start with the subquery weapons of category 'surface-to-air' and then continue with the main part of the query without specifying the connection between these two parts. At a later stage, the user may combine the separate parts.</p><p>As an additional feature, we provide an option to save and reload any part of a query for later use. If the user needs part of the query later for other queries he may save the desired part by selecting the corresponding items in the Query Representation window and assigning a name to them. Later he can reload the desired part when working on a different query and integrate it in the new query. Furthermore, to enhance the clarity of display, parts of a query can be grouped together and displayed as one box (zoom in). If the user wants to see the query in full detail at a later stage he may use the zoom out option.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tool Box</head><p>The Tool Box allows fast access to all functions supported by the system. The functions are divided into five groups: logical operators and basic elements (AND, OR, Condition, Subquery), comparison operators (=, &gt;, c, 2 , I), nesting operators (Exists, not Exists, IN, not IN, ALL), set operators (U, n, -, G, 2) and aggregate operators (AVG, SUM, MAX, MIN, COUNT). The semantics of most operators are the same as in SQL. An additional operator, the 'aZZ'-operator, has been added because it allows an easier and clearer specification of a special category of queries. A detailed description of the 'all'-operator with a formal definition of its semantics is beyond the scope of this paper and is given in [KEIM911. Condition and Subquery options are necessary for the incremental query specification process. Using these options, the user is able to continue the query specification with a different part of the query. When selecting Condition the user gets anew condition box and in case of selecting the Subquery option he gets a double box for a new subquery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Media Description Erlitor</head><p>Another important part of our system is the way of specifying the natural language description part of a query necessary when media data are involved. If the user selects a media attribute in the specification of the condition, automatically a special Media Description Editor will be displayed in a separate window where the media description can be specified. An example for the Media Description Editor is shown in <ref type="figure" target="#fig_5">figure 3</ref>. The description editor has special features to support the intelligent matching process mentioned above. The 'Hierarchy' button supports the user in finding the right description. For a selected (highlighted) word or phrase it presents the corresponding part of the object-oriented domain knowledge providing hints for a better description (see figure 4 for an example). With the 'Weight' button the user is able to assign weighting factors to subject, verb and object component groups of anatural language expression. The weighting factors are used in the intelligent matching algorithm to combine the weights of the different groups. If the user does not provide weighting factors, an equal factor is assigned to all component groups. When selecting the 'Check' or 'Done' button the entered description is instantly sent to the parser.   As the next part the user might want to specify the image description condition 'image shows "An aircraft carrier is operating in the Mediterranean Planes are in operation over the ship." '. The specification process for this part is similar to the specification of the first part. The user selects the ship table and after getting a new condition box he selects the attribute s-image from the ship window. Because s-image is a media attribute, the system automatically provides the special Media Description Editor window. In this window the user can type the natural language description for the image, in our example "An aircraft carrier is operating in the Mediterranean. Planes are in operation over the ship.". When selecting the 'Done' button the description will directly be interpreted by the parser.</p><p>The last step is to specify the main part of the query and to compose the parts into the final result. Starting with the beginning of the query <ref type="figure">( 'Select name, base-id and image')</ref> the user moves the attributes s-name, base-id and s-image to the Result List window. By selecting Cond from the Tool Box and ship carries weapon from the connections window the user specifies the join condition. Now, as the last part of the query, the user has to specify the 'all'-condition. This can be accomplished by getting anew condition box, clicking to w-nr in the weapons window, '= ' and 'alZ' in the Tool Box and the double box representing the subquery 'weapons ofthe category surjiace-to-air ' in the Query Representation window. The last step is to combine the conditions into the final result. This is done by selecting the conditions and the logical operator AND from the Tool Box. In figure 5 the final result of the query specification process is shown. Two other possibilities to express the same query without using the special 'all'-operator are shown in figures 6 and 7. The figures give an impression how complex queries are represented in our Visual Query Interface. The reader might easily imagine the specification process of these queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Presentation of results</head><p>An important aspect of a visual user interface for multimedia database systems is the presentation of the results. The question is how to present a huge amount of multimedia objects. The problem is that, unlike conventional attributes, multimedia objects may have a time and space dimension.</p><p>To solve these problems we choose a combined form and list oriented approach. Generally, the results are presented as a list. In place of the media values only buttons are displayed which the user may select in order to see and/or hear the corresponding media object. Another way to see an object in more detail is to point to the line containing the desired tuple to get the tuple displayed in its form representation. Forms allow users to see more attributes (including media attributes) than available in a list; however, in contrast to lists, only one tuple at a time is displayed. By using the list representation the user can easily scan a huge amount of data but at any step he has also the possibility to get the more detailed form version of a media object. When specifying a query automatically a new form is created including spaces for the values of all attributes involved. With the help of a graphical design tool the user can rearrange the form according to his needs and store it under a different name. In future queries the user can choose an already defined form when dealing with a similar query. In figure 8 the results of our sample query are shown using the customized form WithDescription.</p><p>The combined list and form oriented approach only solves the space problem. It is highly desirable to have an influence on the time dimension of multimedia objects, too.</p><p>Nobody wants to see a whole video in order to identify it as the desired one. Each time, a media object with time dimension (e.g. video or sound) is played, the user should have the possibility to stop, skip a part, go back, etc. In a special window all possible options should be presented as buttons so that the user can choose one of them using the mouse. A precondition for this kind of handling time dependant media objects is random access to their storage representation. In our MDBMS prototype system random access to media objects with time dimension is not supported yet and therefore we do not provide these features for time dependant objects. Other desirable options for time dependant media objects are the possibility to see a text version of a sound object (e.g. possible for speech or songs), the possibility to define index points which are directly accessible without linearly scanning the media object and the possibility to define synchronization points (for composed media objects).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Other database operations: schema definition, insert, update and delete</head><p>In this section we will give an overview of the other database operations that are supported by our visual user interface. The operations to be described are Schema Definition, Insert, Update and Delete.</p><p>For the schema definition we have chosen a rather simple table-oriented approach. The system designer defines anew relation by identifying name, type, width and key of all the attributes. The possible datatypes including media datatypes are presented in a menu. More important at this stage, however, is the possibility to predefine joins allowing an easier query specification by the end user.</p><p>Insert, Delete and Update are performed using a formbased approach. When creating a new table, automatically anew form is created. The spaces for the attribute values reflect the possible length of values to be inserted or updated. As mentioned before, the user is able to rearrange the form according to his needs.</p><p>The insert operation is performed by filling a form with data. After specifying the attribute values for a tuple the user selects the 'Insert' button to trigger the actual insert. During the insertion process also an 'Erase All' button to erase all fields is available. After inserting a tuple the user remains in the form to insert other tuples. To quit the insertion mode the user has to use the 'Quit' button. The first step of the update operation is similar to the retrieval operation because it is necessary to identify the tuples desired for update by specifying a selection condition. The condition, a simple or complex one, is specified using the query specification window as described in section 2.2. However, only attributes from one table may be in the Re-suZt List. The result for the specified query is presented as a list and by clicking to one row of the list a tuple is caused to be displayed in a form. To change the tuple the user simply edits the values in the form and uses the 'Update' button. Other buttons available in the form are the 'Next Tuple', 'Previous Tuple', 'Update All' and, of course, the 'Quit' button. By using the 'Next Tuple' or 'Previous Tuple'button the user gets the next or previous tuple found by the user given selection condition, letting the displayed tuple unchanged. When using the 'Update All' button an empty form is provided which the user fills to change all tuples found using the user given selection condition. <ref type="figure">Figure 9</ref> shows an example for the update process.</p><p>Like update, delete is a two step operation. First, tuples must be retrieved according to a specified selection condition. In contrast to update, no Result List is necessary because tuples cannot be deleted partially. The second step, the actual deletion, is performed using the resulting list or a form. Both, list and form provide buttons for deleting the tuples one-by-one or all selected tuples at once.</p><p>Another important issue is how the media datatypes are integrated into forms because e.g. a sound cannot be displayed in a form and other difficulties arise for images. For the sound type two fields are necessary, one for the path of the sound file and one for the description. Furthermore a 'Play Sound' button is available for each attribute of type sound to play the sound after inserting the path. For attributes of type image a came, two text fields for the path and the description and a 'Display Image' button to display the image after inserting or updating the path are provided (see <ref type="figure">figure 9)</ref>. The frame for the image can be of an arbitrary size making it necessary to zoom the image in or out when it is displayed. By distinguishing between raw and registration data we efficiently support many different input/output formats including pixrect format with RMT-none (black and white) or RMT-EQUAL-RGB (color), Brown Univ.'s ALV format or Utah runlength format (URLE).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Concluding remarks</head><p>A major problem faced in today's database systems is the lack of anatural way to specify complex queries. It is caused by the gap between the user's way of thinking and the query languages used in most systems. Basically these systems are still linear in syntax. Such languages have neither made use of the visual aspect of human senses nor the natural process of the human minds to process information. Although a lot of work has been done in the area of user interfaces for database systems, no query languagecomes close to thenatural query specification process used by humans.</p><p>Our contribution exploited in this paper is a visual, graphical database interface supporting a natural query specification process. We combine an extended relational DBMS with an easy-to-use visual interface allowing direct access to standard as well as multimedia data. It narrows the gap between the user's way of thinking and formal query lan-guages by using visual user interaction. In our system, we support an incremental query specification and predefined joins to make the query specification process user friendly. The user is guided as much as possible allowing a quick, convenient and useful query specification. Furtber research is necessary to come even closer to the user's way of query specification e.g. by allowing the user to directly communicate with the system in natural language when appropriate.</p><p>We believe that our system provides a simple and elegant approach to the rerrieval of multimedia data. The simplicity of our user interface lies in the natural way of query specification being directly obtained from queries expressed in natural language. We also believe that our approach is a general one that can be readily applied to most database query interfaces (e.g. relational systems and extensions hereof).</p><p>Future work include the integration of other media datatypes like video and mixed media data with the need to support the presentation of time dependent data.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>id, ship-weapon {s-nr; w-nT quantity) weapon {w-nl; w-name, category, type, range, w-image) Only few of the possible joins between these tables are semantically meaningful; e.g. the only meaningful equijoin between ship and officer is ship.cup-id = ofJicer.o-id. Most other equijoins like ship.s-nume = oficemddress or ship.s-nr = oficem-id are senseless and will never be used.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>name, w-name from ship, ship-weapon, weapon where ship.s-nr = ship-weapon.s-nr</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>weapon.w-nr = weapon.w-nr</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Example for a Predefined Join</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The parser tries to check and interpret it and, in case of an error, gives back the error message. In case of the 'Done' button the Media Description Mediterranean. m a r e in operation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Media Description Editor</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Example for a Noun HierarchyEditor disappears if the parser does not return an error. If the user wants to edit the description at a later stage he has to select the corresponding box in the Query Representation window and push the 'Edit' button. A larger example walk through a more complex example:To further explain the query specification process let us'Select the name, base-id and image of ships which can carry all weapons of the category surjiace-to-air and where the image shows "An aircraji carrier is operating in the Mediterranean Planes are in operation over the ship. ". 'If a user wants to specify the query he might want to start with an easy part, e.g. 'weapons of the category surjiace-toair '. To specify this part the user first selects Subquery in the Tool Box providing him a second double box for the subquery. Then he selects weapon in the Tables window. As a result he gets all attributes of the weapon's table in a separate window and by clicking to w-nr he selects the desired attribute. The next step is to specify the condition. By clicking to Cond in the Tool Box he gets an empty condition box in the Query Representation window and by clicking to the attribute category in the weapon's window, '=' in the Tool Box and typing in surface-to-air he fills the box with the actual condition.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Odeview: The Graphical Interface to Ode</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1990 Int. Conf. on Management of Data</title>
		<meeting>ACM-SIGMOD 1990 Int. Conf. on Management of Data<address><addrLine>Atlantic City</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Natural Language Understanding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Allen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<publisher>BenjamidCummings Publishing Company, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">SNAP: A Graphics Based Schema Manager</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bryce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 2nd Int. Conf. on Data Engineering</title>
		<meeting>IEEE 2nd Int. Conf. on Data Engineering<address><addrLine>Los Angeles</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Leesons from a &apos;Living in a Database&apos; Graphical User Interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fogg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD Int. Conf. on Management of Data</title>
		<meeting>ACM-SIGMOD Int. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ISIS: Interface for a Semantic Information System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>[gold851 Goldman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD Int. Conf. on Management of Data</title>
		<meeting>ACM-SIGMOD Int. Conf. on Management of Data<address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">TEAM: An experiment in the Design of Transportable Natural Language Interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J</forename><surname>Grosz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="issue">32</biblScope>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Multimedia Database Management System Supporting Content Search in Media Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Guglielmo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V ; King841</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">;</forename><surname>Melville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Meyer-Wegener</surname></persName>
		</author>
		<idno>NPSCS-89-020</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of Cod. on Applied Natural Language Processing</title>
		<meeting>of Cod. on Applied Natural Language essing<address><addrLine>Trento, Italy; Monterey, CA; Singapore; Monterey, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984" />
		</imprint>
		<respStmt>
			<orgName>CS Depart., Naval Postgraduate School</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
	<note>Natural Language Processing of Captions for Retrieving Multimedia Data</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Intelligent Natural Language Processing for Media Data Query</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim K.-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Golden West Conf. on Intelligent Systems</title>
		<meeting>Int. Golden West Conf. on Intelligent Systems<address><addrLine>Reno, NEV</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Entity-Relationship Database User Interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">R</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">G</forename><surname>Cattell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Readings in Database Systems</title>
		<editor>M. Stonebraker</editor>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Exploiting Captions for Access to Multimedia Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Guglielmo</surname></persName>
		</author>
		<idno>NPSCS-91- 012</idno>
	</analytic>
	<monogr>
		<title level="j">Naval Postgraduate School</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">GUIDE: Graphic User Interface for Database Exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">K T</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Kuo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int. Conf. on Very Large Data Bases</title>
		<meeting>of the Int. Conf. on Very Large Data Bases<address><addrLine>Mexico City</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Query-By-Example: A Data Base Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
