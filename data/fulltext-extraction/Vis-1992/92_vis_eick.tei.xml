<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Visualizing Code Profiling Line Oriented Statistics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">L</forename><surname>Steffen</surname></persName>
						</author>
						<title level="a" type="main">Visualizing Code Profiling Line Oriented Statistics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Code tuning is a well-known technique for improving the run-time perJormance of software. There are several widely used profilers available that show the heavily used functions. Other profiers provi&amp; fine gran profiling detail such as basic block counts. The djficulty in using fine grain profilers is coping with the large volumes of data that they generate. We describe a visualization technique that enables us to display and analyze line count profile data. Our technique is to make a reduced picture of code with the line execution counts identified with the color. We show &quot;hot spots&quot; in red, &quot;warm spots&quot; in orange, and so on. We are also able to identjbr nonexecuted code and nonexecutable code such as declarations and static tables.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>One goal in writing a software program is that it run fast. There are three components to run-time efficiency:</p><p>algorithms, data structures, and efficient coding. To find the inefficiencies in their code, programmers use profiles to determine where the most CPU time is spent and then make changes to reduce this time. This process is called code tuning. There have been many welldocumented success stories <ref type="bibr">[']</ref> where code tuning has resulted in dramatic performance improvements. The current profilers provide either manageable quantities of coarse function oriented data or huge volumes of fine line oriented data Line oriented data involves statistics for each source code line. With current tools it is impossible to cope with the volume of data generated by line oriented profiling. In this paper we describe a remarkable Visualization technique that enables us to analyze line oriented profile data.</p><p>The first step in code tuning is to figure out where the "hot spots" in the code are. To help with this task for Cr21 there are several profilers commonly available in the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U N X~ environment, including g p r~f , [~l I C O~~, [~] ~v c c , [~ and pixie.m</head><p>The profiling tools use one of two basic strategies to identify frequently executed code: pcsampling or basic-block counting. With pc-sampling the program interrupts periodically and records the program counter. This results in a statistical profile of the program execution. A basic block is a region of the code that can be entered only at the beginning and exited only at the end. Basic-block counting instruments the executable program with code that counts the number times each basic block is entered. Some profilers enhance these techniques with knowledge of the function call graph to obtain function usage times or CPU usage per line. Prof and gprof are perhaps the most well known profilers and use pc-sampling. Pixie, nvcc, and lcomp use basic block counting.</p><p>In typical applications, programmers look at the function usage tables to determine which functions are taking the most CPU time. Within these functions they attempt to identify the loops, remove extra code, or apply other tricks to improve efficiency. The function oriented profilers provide data pointing the programmer to the functions taking the most CPU time, but provide no insight into which lines to optimize. Line oriented profilers overwhelm the programmer with too much data. Something better is needed.  To answer these questions we apply software visualization[g1 monitor, although they may be difficult to see when application to profile data. Section2 describes the reduced to fit in this paper. The color is identified with a Seesoft tool and its user interface. Section 3 discusses statistic associated with each line, such as line execution <ref type="figure" target="#fig_1">Figure 2</ref> in more detail and analyzes the pattern using count. When Seesoft is displaying profile data, the the display manipulation capabilities of Seesoft. visual impression is a miniature picture of the source Section 4 concludes and summarizes. code with the "hot spots" colored in shades of red.</p><p>In <ref type="figure" target="#fig_1">Figure 2</ref> we turned off code indentation so that all</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Seesoft display tool</head><p>Seesoft is a general purpose tool for displaying large lines have the same visual prominence. The visual effect is striking-there is a big "hot spot" toward the end of volumes of source At the bottom of the screen are buttons and toggles that control the display mode. To the left of the buttons there are two mws (not shown) for displaying text. On these two lines we print the line execution counts and code for the line associated with the current mouse tracks the mouse and the code inside the box is displayed slider and uses the left mouse button for activation and in the window. The size of the magnifying box is the middle mouse buuon for deactivation. The lines proportional to the size of the Reader window. This whose counts are in the activated regions are displayed. enables the programmer to understand what fraction of The concept is similar to paint programs, that is, the the total is visible and where the code is in the file. The  <ref type="figure">Figure 3</ref> shows an example where the its corresponding magnifying box (see <ref type="figure">Figure 3)</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Using Seesoft for code profiling</head><p>This section applies Seesoft to understanding the cscope profile data described in the introduction. The sizes of the files are apparent from the length of the rectangles. The biggest file is scanw.c (which has over 4,600 lines) and other big files are cgrepx, main.c, and fvld.c. The "hot spots" in the code are visible from the red color. By brushing on the color bar we can deactivate the less executed lines. What have we learned from this analysis that other profilers do not show? We have:</p><p>0 Shown the sizes of the files: The longest by far is generated by lex.</p><p>0 Found the locations of the "hot" and "warm spots:"</p><p>In <ref type="figure">files scanner.c,jnd.c, and crossreJc.</ref> 0 Learned that the most executed lines are inj3d.c and the next most executed lines are the machine generated code in scannerx.</p><p>Discovered with Reader windows that one "hot spot" is lex's input loop, but others are directly generated from lex rule actions in cscope.</p><p>state machine.</p><p>0 Noticed a huge table in scanner.c that is lex's finite</p><p>Were surprised that much of the cscope code has not been executed in our test. This is obvious from our visual displays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Summary and conclusions</head><p>This paper describes a method for visualizing line oriented profile data and a software tool, Seesoft. embodying the method. Seesoft displays files as rectangles and code as colored lines within each rectangle. Each colored line is optionally indented and drawn to look like the real code does. The line color is determined by the profile counts, "hot spots" in the code are shown in red. Our techniques generalize to other line statistics, including CPU usage by line as generated by pixie, code coverage, and identifying initialization code.</p><p>Software visualization for analyzing profile data complements function summary techniques because it allows the programmer to study line oriented statistics. Our method allows programmers to discover usage pattems in the code that would be infeasible to find using traditional methods.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>[lo] and use our SeesofrfM visualization system for visualizing line oriented profile data As shown in Figure 1, Seesoft displays source code by representing files as rectangles whose height corresponds to the size of the file. Seesoft shows the file name above the rectangles and uses multiple rectangles for large files. Each line in the files is shown as a row within the rectangle. The length and indentation of the rows corresponds to the real code. The indentation allows the user to identify the C control structures ( i f , for, while, and switch) clearly on a high resolution J Seesoft Profile Display A Seesoft display showing line MUnt statistics for cscopc. ?he color of each Line is determined by the number of times it executed. On the right there is a cdor scale that is 'pproximatcly logarithmic. The most frquently executed code is red, the "hot spofs." with decreasing count^ moving through the RGB color specmm to deep blue for d e executed only once.Nonexecutable code such as declarations and C preprocusor statements is black and unexecuted code is gray.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>of code that has been scmnet.c and little "hot spots" in several of the other typeset.["] This compact representation can comfortably files. Also, much of the light code is gray indicating that is was not executed. The Of the display 35 files at 1, OOO lines each on a standard high describes our Seesoft tool in more detail and its Seesoft Profile Display wlthout Indentation 'Ihis is h e same data as Figure I ucep the indentation has been mmed off, making it easier to see the "hot spots." resolution (1280x1024) workstation color monitor. ' Files with more than about 1, OOO lines are shown as multiple adjacent rectangles. The file names are shown above each rectangle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 .Figure 3a .Figure 4 .</head><label>13a4</label><figDesc>Library files and a few other shor~ filer from the cscop iource are o m i d fran the figures to make than more readable. position. By default, Seesoft's line representation reflects the indentation in the code. The programmer may turn off indentation using the Indent button. This is useful when all lines should have the same visual prominence. The Added and Blink buttons are for displaying additional statistics, but are not used for code profiling. The Reader button allows the programmer to open additional windows viewing the code.Programmers, on discovering "hot spots," need to see the corresponding code. Upon depressing the Reader button two actions occur. The user positions and sizes a new window for displaying code using a 10 point font and a small colored "magnifying" box appears on the graphical display at the current mouse position. As the mouse is moved, the magnifying box (See color plates, p. CP-24.) Seesoft Profile Display with Hot Spots Brushed Flgure 3b and c. 1 -1 Seesoft Reader Windows llrir display show only Be "bot spou" in the code. dl ahcr lina h v c brm duaivated by tmuhing on B e color AS Two Ruder windows, below. havccbrm opened to display oodc h U diftiarhto I&amp; bsuure ofthemdl fmt dza, h t four lines above the highlighted linein the lef~ Ruder L a -ad idcaring Bat lhir U the ha" Seesoft Profile Display wlth Warm Spots BrushedThis display shows only the "hot spas" in the code, dl other lines have been deactivated by brushing on h e color scale.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>lines whose counts are in the painted regions of the programmer may create, position, and size multiple slider bar are displayed. In Figures 1 and 2 the threshold Reader windows independently. The color border on is completely active and correspondingly all lines of each Reader window has a different color that matches code are visible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>"</head><label></label><figDesc>hot" line counts have been activated and there are two</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure3 shows the locations of the most executed lines from Table2 and shows the actual code in the Reader windows. This code is lex's input loop. We investigated the "hot spots" in cr0ssrejc.find.c. and scannerx and found that the input matching in function yylook at the end of scannerx is called from the yylex function at the beginning of scunner.c, which itself is called from crossrejc, which is the C interface to the lex code. The second Reader window in Figure3 shows the most executed code inj5nd.c. Note that from the comment in the source code (which is clearly visible on our workstation monitor but difficult to read in our reproduction for this paper) the programmer (the second author) has correctly guessed what to tune here. By comparing Figures 1 and 3 the hot spot in cr0ssref.c corresponds to a s w i t c h statement Figure 3 shows us the most frequently executed cases. Figure4 shows the "wann spots." Some of the lex rule actions appear as cases in the large s w i t c h in the left column of scanner.c (also see the entire s w i t c h statement in Figure 1). Figure2 shows the nonexecutable and nonexecuted code. The blank code segments are nonexecutable: declarations, #include's, Xdef ines's and block comments. They appear most often at the tops of files. The huge blank region in the middle of scunner.c is lex's finite state machine. The gray segments are nonexecuted code.Our test suite, although not exhaustive, exercised the major features in cscope. It is surprising that so much of the code is gray. This code is for error checking, recovery, and other unexercised options.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 showsTABLE 1 . PC-Sampling Program Profiling Results cwnsecs #call m s / d function file 2.65 184131 0.01 yylook scanner-c 3.60 7653 0.12 doscan 1ibclabscan.c 4.40 2251 0.36 read 1ibclreod.c 5.05 mcount 5.59 18292 0.03 doprnt 1ibclabprint.c 6.07 285 1.68 accessdata waa &amp;rived from the first few liaes of prof output for one run of the cscope C code browser program using itself as input 'he results from gprqfare similar. Both profile=</head><label>11</label><figDesc>This particular run consists of building the cscope database and exercising each item in the cscope main menu. It looks hopeless to improve the performance of cscope from Table 1. The function yylook uses the largest portion of the CPU</figDesc><table><row><cell>time, about 26%. Yylook is a l d l function in the</cell></row><row><cell>file scanner.c. Yylook is called from yylex,</cell></row><row><cell>another lex function also in scanner.c and itself a high</cell></row><row><cell>CPU user. The huge file scanner.c is machine generated</cell></row><row><cell>from hand coded specifications in scanner.1. It is</cell></row><row><cell>impossible to tell which lines in scanner.c execute most</cell></row><row><cell>often, and, more importantly, which lex rule actions</cell></row><row><cell>created those lines. The next most frequently executed</cell></row></table><note>the most frequently executed functions from one run of the cscope181 C code browser using itself as input on a Sun Sparcstation 2.poduce large quantities of output, most of w h i d~ is not wefuL</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 2 . Bask Block Program Profiling ResultsCertainly scanner.c and yylook contain</head><label>2</label><figDesc>These come from seven basic blocks. The highest counts are a tight loop in scanpast that searches for the ends of strings. The next highest are all in yylook, the lex code that we could not understand before. It is infeasible for humans to understand the remaining 15.707 lines of count statistics without further help. important "hot spots," but where are the other "hot spots"? What lex rule actions generated these lines? Which other files contain "hot spots"? Where is the initialization code, static tables, error checking code? What files have code that is not</figDesc><table><row><cell>I function</cell><cell>file</cell><cell>line</cell><cell>counts I</cell></row><row><cell>scanpast scanpast</cell><cell>firrd.c fmd.c</cell><cell>1129 1130</cell><cell>1350287 1350287</cell></row><row><cell>scanpast</cell><cell>find.C</cell><cell>1131</cell><cell>1350287</cell></row><row><cell>scanpast</cell><cell>jind.C</cell><cell>1132</cell><cell>1350287</cell></row><row><cell>scanpast</cell><cell>fmd.c</cell><cell>1133</cell><cell>1350287</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>4658</cell><cell>6303 10</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>4659</cell><cell>6303 10</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>4642</cell><cell>595217</cell></row><row><cell>yylook</cell><cell>scannerx</cell><cell>4643</cell><cell>595217</cell></row><row><cell>yylook</cell><cell>scannerx</cell><cell>4669</cell><cell>527566</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>4674</cell><cell>501257</cell></row><row><cell>yylook</cell><cell>scannerx</cell><cell>4675</cell><cell>501257</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>4670</cell><cell>501257</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>467 1</cell><cell>501257</cell></row><row><cell>yylook</cell><cell>scanner.c</cell><cell>465 1</cell><cell>468286</cell></row></table><note>This table show the six most frequently e x e c d basic blocks. The rrmaining 15,707 lines (over 300 pages) of basic block output are not shown.functions in Table 1, doscan. read, doprnt, and access (mcount is part of the profiler itself), are all system or library functions and probably cannot be changed. The insights from gprof are about the same, it is impossible to tell what parts of cscope are causing these other routines to execute. The results fiom basic block counting profilers are not much betrer. Table2 shows the 15 most executed lines.executed or tested?</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>See color plates, p. CP-24.)</head><label></label><figDesc>The mouse sensitive color scale on the right-hand side Reader windows. The user interaction techniques of the display also functions as a thresholdmg slider. described here are most effective when the Thresholds traditionally have slider bars that enable manipulations are performed in real-time. It is difficult range restrictions. Our threshold, however, allows the to illustrate this technique in a static medium such as this user to select multiple, arbitrary ranges, that may even be paper. We are preparing a companion video tape that disconnected. The user brushes[121 the mouse over the illustrates their use.[131 (</figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Programming Pearls</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Bentley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<pubPlace>Addison-Wesley, Reading, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The C Programming Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">W</forename><surname>Kemighan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dennis</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978" />
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Research System Programmer&apos;s Manual, Tenth Edition Holt Dryden Saunders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Hume</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Mcilroy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Unix</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">gprof: A Call Graph Execution Profiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Mckusick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SICPLAN &apos;82 Symposium on Compiler Construction</title>
		<meeting>the SICPLAN &apos;82 Symposium on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="1982-06" />
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="120" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cheap Dynamic Instruction Counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Weinberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AT&amp;T Bell Laboratories Technical Journul</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1815" to="1841" />
			<date type="published" when="1984-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Experimental Evaluation of a Test Coverage Analyzer for C and C++</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Frakes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lubinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Neal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journul of Systems and Sofware</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="135" to="139" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">User&apos;s Reference Manual, Volume II</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>I R K</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Silicon Graphics, Inc</publisher>
			<biblScope unit="volume">2</biblScope>
			<pubPlace>Mountain View, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Interactive Examination of a C hgram with Cscope</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">L</forename><surname>Steffen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<pubPlace>Dallas</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m">Winter Conference Proceedings. USENIX Association</title>
		<meeting><address><addrLine>El Cemto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="page" from="170" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dynamic Graphics for Software Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interface &apos;92 Proceedings</title>
		<meeting><address><addrLine>College Station, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">L</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">E</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sumner</surname></persName>
		</author>
		<title level="m">Seesoft-A Tool For Visualizing Software.,&apos;&apos; submitted to IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Human Factors and Typography for More Readable Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ronald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Baecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Marcus</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="page">235</biblScope>
			<pubPlace>Reading, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The Use of Brushing and Rotation for Data Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">A</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">S</forename><surname>Cleveland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">in D y m &apos; c Graphics for Statistics</title>
		<editor>William S. Cleveland and McGill</editor>
		<imprint>
			<publisher>Wadsworth</publisher>
			<date type="published" when="1988" />
			<biblScope unit="page" from="247" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Visualizing Code Projiling Line Count Statistics, video tape</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">L</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Steffen</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>AT&amp;T Bell Laboratories</orgName>
		</respStmt>
	</monogr>
	<note>under preparation</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
