<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Logical Time in Visualizations Produced by Parallel Programs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Janice</forename><forename type="middle">E</forename><surname>Cunyy</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Massachusetts</orgName>
								<address>
									<postCode>01003</postCode>
									<settlement>Amherst</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">A</forename><surname>Hough</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Massachusetts</orgName>
								<address>
									<postCode>01003</postCode>
									<settlement>Amherst</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joydip</forename><surname>Kundu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Massachusetts</orgName>
								<address>
									<postCode>01003</postCode>
									<settlement>Amherst</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Logical Time in Visualizations Produced by Parallel Programs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Visualization tools that display data as it is manipulated by a parallel, MIMD computation must contend with the effects of asynchronous execution. We have developed techniques that manipulate logical time in order to produce coherent animations of parallel program behavior despite the presence of asynchrony. Our techniques &quot;interpret&quot; program behavior in light of user-defined abstractions and generate animations based on a logical rather than a physical view of time. If this interpretation succeeds, the resulting animation is easily understood; if it fails, the programmer can be assured that the failure was not an artifact of the visualization. Here we demonstrate that these techniques can be generally applied to enhance visualizations of a variety of types of data as it is produced by parallel, MIMD computations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>not a linear order. Animation systems, however, are constrained to sequential, frame-by-frame depictions and therefore they must impose a linear ordering on events. But what if this ordering does not match the programmers expectations? Is the resulting anomaly an artifact of the visualization tool or is it a misunderstanding of the real world phenomena or is it the symptom of a program bug?</p><p>To date, our work has focused on program animation tools designed specifically for use in debugging for correctness.' We have developed techniques that manipulate logical time in order to produce coherent animations of parallel program behavior despite the presence of asynchrony. Our techniques "interpret" program behavior in light of user-defined abstractions and generate animations based on a logical rather than a physical view of time. If this interpretation SUCceeds, the resulting animation is easily understood; if it fails, the programmer can be assured that the failure was not an artifact of the visualization. Here we demonstrate that these techniques can be more generally applied to enhance the visualization of data as Visualization tools aid in the understanding of massively parallel, MIMD computations. They are useful both at the application level where data world phenomena and at the programming level where program animation enables the to better under-it is manipulated by pardel, MIMD computations. We begin, in Sections 2 and 3, by defining our techniques in their original context, that is, within systems their utility in the more general context of data visualization. In Section 5, we present our conclusions.</p><p>allows the user to better understand simulated, real for Program animation-In Section 41 we demonstrate stand the behavior of his/her code. At either level, however, visualization tools running on MIMD architectures must contend with the effects of asynchronous execution. Processes in an asynchronous computer system execute without the benefit of a global clock; instead they have their own local clocks which are not mutually synchronized. As a result, it is not always possible to determine the order of events executed by different processes. The temporal ordering of events in a parallel, MIMD computer system is a partial order, 'The Parallel Programming Environments Project at the University of Massachusetts is supported by the National Science Foundation under grant CCR-9023256.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Our Approach: An Overview in the</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Context of Parallel Program Animation</head><p>Massively parallel computer systemsin which hundreds or even thousands of interacting processes execute concurrentlyare enormously complex. In order to understand their behavior, programmers rely 'This is in contrast to a number of program visualization tools designed for use i n debugging for performance [2, 5, 151. In dcbuggingfor correctness, it is logical time that is important; in debugging for performance, it is physical time. 0-8186-2897-9/92 $03.00 0 1992 BEE on informal modeling techniques: information traced during execution is filtered and abstracted to develop a model of the system's actual behavior that is compared with the programmer's conceptual model of the system's intended behavior. Visualization tools aid in this process by providing comprehensible views of program behavior. Consider, for example, a program iteratively approximating the solution to a PDE using a Successive Overrelaxation (SOR) method [6]. Processes, arranged in a square mesh repeatedly update their values as a function of the values of their neighbors. To speed convergence, their execution alternates in a checkered pattern as in <ref type="figure" target="#fig_0">Figure 1</ref>: first striped processes execute and then solid processes. <ref type="figure" target="#fig_1">Figure 2</ref> shows snapshots from a straightforward animation of an SOR program but it does not show the expected behavior. What has gone wrong? which all processes were "doing the same thing at the same time." Here we assume that the visualization tool supports some type of abstraction, allowing the user to group program actions into abstract events. In this example, we group read and update actions into striped and solid events which we animate with m and Abstraction alone, however, is not enough.</p><p>The abstract striped and solid events are not atomic but occur over a period of time (starting with the first read and ending with the update). Because of asynchrony, the time periods for successive events can overlap; thus, the logically sequential striped and solid events may appear as concurrent. Worse, since they are executed on the same set of processes, their animations may be superimposed making them incomprehensible. (This phenomenon occurs in the Dictionary Search example below; it is seen in <ref type="figure" target="#fig_3">Figure 4b</ref>.)</p><p>Our visualization techniques produce comprehensible pictures by ordering events in logical rather than physical time. Events are ordered in logical time by process dependencies: processes are sequential and their actions are totally ordered by local timestamps, and interprocess dependencies: messages must be sent before they can be received.2</p><p>For the SOR program, striped and solid steps are ordered by process dependencies and thus we animate them in successive frames as shown in <ref type="figure" target="#fig_2">Figure 3</ref>. In the figure, the abstract events of interest have been temporally separated, providing visual discrimination and allowing the user to understand his/her program's behavior in terms of his/her own conceptualizations. The behavior in this new animation is logically equivalent to the behavior in the original picture; that is, all processors execute the same sequences of operations with the same interprocess dependencies. For many parallel computations, however, such simple orderings are not possible because of intertwined dependencies. Consider, for example, a program that implements a dictionary search in which queries are pipelined from the host to a database of key-ordered records stored in a hypercube <ref type="bibr" target="#b13">[14]</ref>. Queries are routed within the cube  to the proper node using binary search. In the animation of primitive events shown in <ref type="figure" target="#fig_3">Figure 4a</ref>, multiple queries are active simultaneously and it is difficult to understand whether or not each query is proceeding as intended.</p><p>To view this behavior in a more understandable format, we define an abstract event t o be all of the communications generated on behalf of a single query. These new query events cannot be separated on the basis of logical time because they follow datadependent paths through the cube, arriving in different orders a t different processes. There is no single, logically consistent ordering that can be imposed by the animator.</p><p>For such cases,. we introduced perspective views which enable the user to selectively ignore logical dependencies in establishing partially consistent event orderings. In this case, we can choose to ignore all dependencies other than those caused by send events on the host process. This creates the perspective views shown in <ref type="figure" target="#fig_3">Figure 4c</ref> d in which queries are shown in the order that they were issued from the host and each query completes before the next begins. This animation is clear and understandable. In spite of the fact that it is not logically equivalent to the actual execution trace (queries appear to arrive a t some processes out of order), it enables the programmer to easily comprehend relevant aspects of program behavior. In this case, it enabled us to discover a bug that was not apparent in the original animation: in <ref type="figure" target="#fig_3">Figure 4</ref> 4 a query crosses a dimension of the cube twice indicating an error in the routing of messages. Thus, ignoring some temporal orderings in the original execution sequence made it possible for the programme? to understand aspects of the program's behavior relevant to its correctness. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Our Approach: The Technical Details</head><p>We base our animations on Lamport's happened before relation <ref type="bibr" target="#b11">[12]</ref> which is defined on primitive actions, each assumed to have a processor-local timestamp, denoted timestamp(a) for a n event a. Positioning events on their process time-line according to their local timestamps (increasing from left to right), event a happened be fore event b, denoted a -+ b, iff one of the following conditions holds:  Precedes captures the notion that one abstract event logically occurs before another. Parallels captures the notion that no logical ordering exists between the events and overlaps captures the notion that the events are logically intertwined (that is, some part of each event must occur before some part of the other).</p><p>Our techniques associate with each relation a transformation that assigns animation times. In the case of precedes, we separate the events by assigning animation times so that all elements of the first event complete before any element of the second event begins. In the case of parallels, we assign the the same animation time to the earliest events in each set. The transformation for precedes, for example, separates the 'This notation is slightly different than Lamport's.</p><p>striped and solid steps of the SOR program in <ref type="figure" target="#fig_2">Figure 3,</ref> while the transformation for parallels synchronizes the subevents of each step.</p><p>For events related by precedes or parallels, the transformations produce consistent orderings; that is, all processes execute the same sequence of events and the happened before relation remains unchanged. For events related by overlaps, however, we cannot construct consistent reorderings and, thus, we introduce partially consistent orderings in which each process executes a subsequence of its original event sequence and the happened before relation is a subset of the original happened before relation.</p><p>We base our partially consistent orderings on a user-selected subset of the events called a perspective. Only events named in the perspective are used in computing ordering relations. Events not named in the perspective and not needed for the display of named events are deleted and the remaining events are reordered in a manner consistent with the computed relations. We might, for example, consider the following behavior where all constituent events of an abstract event are labeled with the same uppercase letter where circles indicate the events used to compute the ordering. The ordering on Process 1 has been applied to all events, including those on Process 2; abstract event C has been deleted since it does not contain elements in the perspective. Alternatively, the same system can be decomposed from the perspective of Process 2, in which case Each reordering is meaningful; each exposes the order of events on an individual process and provides some insight to the code and environment of that process. The two reorderings together characterize the complete behavior of the system. We have successfully used the logical time manipulations described here in the Belvedere animation system [7, 8, 101 which was specifically designed to aid in the debugging of parallel programs for correctness. Here, we demonstrate their more general application to visualizations of domain-specific data. example, we use the animation of a program that performs an underwater simulation taken from a paper on the Voyeur animation system <ref type="bibr" target="#b16">[16]</ref>. The simulation consists of a 2D world where sharks eat fish that come too close. Initially, the simulation might be configured as in <ref type="figure" target="#fig_10">Figure 5a</ref>. After a single logical timestep, it might be configured as in <ref type="figure" target="#fig_10">Figure 5b</ref> where both sharks in the first row have moved into the top middle square and the shark on the right has eaten a fish. <ref type="figure" target="#fig_10">Figure 5</ref> displays the logical timesteps for each process; it shows synchronized processes moving together from Step 1 to Step 2. If, however, the processes are not synchronized, the confusing display shown in <ref type="figure" target="#fig_11">Figure 6</ref> might be seen. In that figure, some processes are at Step 1 while others have advanced to Step 2. The image is difficult to interpret; sharks in the top row, for example, are not displayed at all because during Step 2 they have moved to processes still displayed at Step 1. The problem is not in the code but in its visualization.</p><p>Existing animation tools solve this problem by requiring the programmer to explicitly simulate a global or real world time. Each process must output clock "ticks" and all of the data produced between successive ticks is displayed at the same time. This simulated time has been called "phase" time <ref type="bibr" target="#b0">[13]</ref> or "generation" time <ref type="bibr" target="#b16">[16]</ref> and it works well for SPMD (Single Program Multiple Data) programs in which all processes proceed in unison. It does not work well for less regular programs in which processes independently update data at different points in their execution. In these programs, processes that are not involved in an u p date do not have any way of knowing that time should be advanced. Examples of programs that do not proceed in unison include the dictionary search discussed above and the FIFO queue discussed below.</p><p>With our techniques, the user defines abstract events composed of single updates to shark and fish positions on all processes. These abstract events are ordered by precedes and, thus, they are automatically separated to produce the desired animation (as shown in <ref type="figure" target="#fig_10">Figure 5 )</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2. Recursive Matrix Transposition.</head><p>In this example, we consider the animation of a program that performs a recursive matrix transposition taken from a paper on the ParaGraph visualization system [5]. Starting with the matrix as displayed in <ref type="figure" target="#fig_12">Figure 7</ref>, we successively transpose submatrices of sizes 2 x 2, 4 x 4 and 8 x 8. A visualization in which processes asynchronously update the display as they compute produces the incomprehensible snapshots of <ref type="figure" target="#fig_13">Figure 8</ref>. Using our techniques, abstract events corresponding to the recursion levels are shown in a logically coherent manner as in <ref type="figure" target="#fig_14">Figure 9</ref>. This enhanced visualization is considerably easier to understand than the original.</p><p>It should be noted that for this algorithm, where all processes recurse to the same depth, the use of   phase time or generation time would also suffice as shown in [5]. If, however, the depth of recursion was not uniform as, for example, in a binary search, then only our techniques would produce coherent pictures.</p><p>In the next example, we demonstrate a program that cannot be successfully animated with phase or generation time alone.</p><p>Example 3. Parallel FIFO Queue [4]. Here, we discuss an animation of a parallel queue4 but the scenario is typical of many simulations that model concurrent, nonatomic updates of data. <ref type="figure" target="#fig_0">Figure 10a</ref> shows an empty circular queue. Each trapezoid represents a location in the queue; the head pointer is labeled I and the tail pointer is labeled D.</p><p>In <ref type="figure" target="#fig_0">Figures 10b and c,</ref> we use a solid trapezoid below the queue to indicate that an Insert is in progress and a blank trapezoid above the queue to indicate that a Delete is in progress. Note that <ref type="figure" target="#fig_0">Figure 10</ref> shows both an Insert and a Delete in progress at the same location but this does not indicate an error. Neither Inserts nor Deletes are atomic. A Delete takes three steps: first it gets the position of the next queue element, then it waits until any Inserts on that location have completed, and then it removes the element. Its start can legitimately overlap with the previous Insert. <ref type="figure" target="#fig_0">Figure 10d</ref> shows several Inserts and Deletes in progress; shaded queue locations are full. All of these pictures show the queue behaving as expected. But what if there is an error?</p><p>Suppose that the wait is omitted during Deletes so that it is possible for them to access the queue before data has been inserted. <ref type="figure" target="#fig_0">Figure 11</ref> shows snapshots from the animation of an execution sequence in which this actually occurred. It looks as if the first Insert has completed and the first Delete is still in progress. Why doesn't the error show up?</p><p>The problem is in the timing of the screen updates. In, this trace, the Delete accessed the queue first but the sequence of operations that made up the Insert finished before the sequence of operations that made up the Delete. The screen was updated as the sequences completed and, thus, it showed the Insert first, masking the error. Using logical time, however, this anomaly does not occur. <ref type="figure" target="#fig_0">Figure 12</ref>, for example, shows the same execution trace animated with our techniques. Inserts and Deletes were ordered logically by the dependencies caused by queue accesses (dependencies resulting from the process waits were ignored). The error is clearly visible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D I I</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>This scenario is typical of simulations in which different parts of a data structure are concurrently updated by nonatomic operations. Simulated global time <ref type="figure" target="#fig_0">Figure 12</ref>: Snapshots from the logically ordered animation of the erroneous version of the parallel queue.</p><p>is not useful because not all processes participate in each update and, thus, not all processes are aware of the need to advance their clocks. Our techniques <ref type="figure" target="#fig_0">Figure 10</ref>: Snapshots from the animation of the parallel queue.</p><p>allow the user to focus on just those temporal orderings that are relevant to the logical behavior under investigation. They also allow the user to change that focus as different aspects of the behavior come under scrutiny. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>All visualization tools that display data as it is manipulated by a parallel, MIMD computation must contend with the effects of asynchronous execution. In some cases, this is done with the explicit simulation of a global clock but that is not always feasible. Here we propose a less restrictive mechanism in which logical time is manipulated in order to produce coherent animations of parallel program behavior. Our techniques "interpret" program behavior in light of user-defined abstractions and generate animations based on a logical rather than a view of time. In this paper, we have demonstrated the application of these techniques more generally to a variety of types of data visualie ations . </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Checkered pattern of striped and solid processes for the SOR program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Snapshots from the SOR program. animation of the 'Here, we consider only nonshared memory paradigms but the definitions can be extended to shared memory as discussed The most obvious problem is that the programmer but instead thought of a global pattern of activity in did not think Of the individual behavior of processes in Section 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Intended, logical sequence of striped and solid steps in the SOR computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Snapshots of an animation of the Dictionary Search. Low-level communication events (a); abstract events with several concurrent search requests ( b ) ; a perspective view of abstract events showing the path taken by an individual request (c); erroneous communication between p3 and p7 (d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>i) events a and b happen on the same process and timestamp(a) &lt; timestamp(b) is the act of sending a message and b is the act of receiving it (denoted by a n arrow from a to b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>111)-</head><label></label><figDesc>there is some event c such that a -+ c and c Two events are unordered if they are not related by happened b e f~r e :~ a 1) b iff not ( a 4 b) and not ( b -+ a) defined on primitive events. For our purposes, we extend the definition to nonatomic events, defining three relationsprecedes, parallels, and overlapsbetween abstract events. Other extensions have been proposed [12, 1, 11, 31 but ours has been tailored to the needs of visualization systems. We begin with a relation partially precedes, denoted H. Let A and B be sets of events. Informally, A H B if some part of A happens before some part of B or they share a primitive event; formally i) A H B if 3a E A , b E B : a -, b or a = b and ii) H is closed under transitivity Using partially precedes we define the three possible relations between two abstract events: Precedes: A j B iff A H B and NOT ( B H A ) Parallels: A 1) B iff NOT ( A ci B ) and NOT ( B ++ A ) , (alternatively, iff Va E A , b E B : a I ( b) Overlaps: A e B iff A M B and B H A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 5 :</head><label>5</label><figDesc>Logically consecutive time steps in the lives of sharks and fishes. Each process is labeled with its current time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 6 :</head><label>6</label><figDesc>Actual execution of the sharks and fishes program. Processes are executing at different time steps concurrently.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 7 :</head><label>7</label><figDesc>Snapshot of the matrix before transposition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 8 :</head><label>8</label><figDesc>Snapshots from the original animation of the recursive transposition program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 9 :</head><label>9</label><figDesc>Snapshots from the enhanced animation of the recursive transposition program showing the original matrix and the matrix after the transposition of 2 x 2, 4 x 4 and 8 x 8 submatrices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>'</head><label></label><figDesc>Note: We have assumed a nonshared memory paradigm but for this example we simulate a shared memory location as a process: if p is a process and m a memory location, a write from p to m is treated as a message from p to m and a read by p from m is treated as a message from m to p.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 11 :</head><label>11</label><figDesc>Snapshots from the original animation of an erroneous version of the parallel queue.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Debugging Heterogeneous Distributed Systems Using Event-Based Models of Behauior</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">M</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bates</surname></persName>
		</author>
		<idno>86- 05</idno>
	</analytic>
	<monogr>
		<title level="m">Also available as COINS Department</title>
		<meeting><address><addrLine>Amherst MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Massachusetts</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Graphical Representations of Program Performance on Hypercube Message-Passing Multiprocessors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alva</forename><surname>Couch</surname></persName>
		</author>
		<idno>88-4</idno>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
		<respStmt>
			<orgName>Tufts University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Partial Orders for Parallel Debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Fidge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging</title>
		<meeting>the ACM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="183" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The NYU Ultracomputer -Designing and MIMD Shared Memory Parallel Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Gottlieb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralph</forename><surname>Grishman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clyde</forename><forename type="middle">P</forename><surname>Kruskal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">P</forename><surname>Mcauliffe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Snir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers C</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="175" to="189" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Visualizing Performance of Parallel Programs. Oak Ridge National Laboratory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Etheridge</surname></persName>
		</author>
		<idno>ORNL/TM-11813</idno>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Parallel Computers: Architecture, Programming and Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Hockney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Jesshope</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
			<pubPlace>Adam Hilger, Bristol, England</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Belvedere: Prototype of a Pattern-Oriented Debugger for Highly Parallel Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">A</forename><surname>Hough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Janice</forename><forename type="middle">E</forename><surname>Cuny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1987 International Conference on Parallel Processing</title>
		<meeting>1987 International Conference on Parallel Processing</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="735" to="738" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Initial Experiences with a Pattern-Oriented Parallel Debugger</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">A</forename><surname>Hough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Janice</forename><forename type="middle">E</forename><surname>Cuny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging</title>
		<imprint>
			<biblScope unit="page" from="195" to="205" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Perspective Views: A Technique for Enchancing Visualizations of Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">A</forename><surname>Hough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Janice</forename><forename type="middle">E</forename><surname>Cuny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1990 International Conference on Parallel Procersing</title>
		<meeting>1990 International Conference on Parallel Procersing</meeting>
		<imprint>
			<biblScope unit="page" from="11" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Debugging Parallel Programs Using Abstract Visualizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">A</forename><surname>Hough</surname></persName>
		</author>
		<idno>91-53.</idno>
		<imprint>
			<date type="published" when="1990" />
			<pubPlace>Amherst MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, University of Massachusetts</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Also available as COINS Department</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Data Path Debugging: Data-Oriented Debugging for a Concurrent Programming Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hsuesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Kaiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the A C M SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging</title>
		<meeting>the A C M SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="236" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Time, Clocks, and the Ordering of Events in a Distributed System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Analyzing Parallel Program Executions Using Multiple Views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">3</forename><surname>Fowler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="203" to="217" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Implementing a Dictionary on Hypercube Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Omondi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Brock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1987 International Conference on Parallel Processing</title>
		<meeting>the 1987 International Conference on Parallel Processing</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="707" to="709" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">D</forename><surname>Olson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruth</forename><forename type="middle">A</forename><surname>Aydt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tara</forename><forename type="middle">M</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Birkett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>David</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scalable Performance Environments for Parallel Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><forename type="middle">A A</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">K</forename><surname>Nasief</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Totty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Sizth Distributed Memory Computing Conference</title>
		<meeting>Sizth Distributed Memory Computing Conference</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="562" to="569" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Voyeur: Graphical Views of Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Socha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><forename type="middle">L</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the A CM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging</title>
		<meeting>the A CM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="206" to="217" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
