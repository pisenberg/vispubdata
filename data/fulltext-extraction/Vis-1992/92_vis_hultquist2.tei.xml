<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SuperGlue: A Programming Environment for Scientific Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P M</forename><surname>Hultquist</surname></persName>
							<email>hultquist@nas.nasa.gov</email>
							<affiliation key="aff0">
								<orgName type="institution">Numerical Aerodynamic Simulation Systems Division NASA Ames Research Center</orgName>
								<address>
									<addrLine>Mail Stop T045-1 Moffett Field</addrLine>
									<postCode>94035-1000</postCode>
									<region>California</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Raible</surname></persName>
							<email>raible@nas.nasa.gov</email>
							<affiliation key="aff0">
								<orgName type="institution">Numerical Aerodynamic Simulation Systems Division NASA Ames Research Center</orgName>
								<address>
									<addrLine>Mail Stop T045-1 Moffett Field</addrLine>
									<postCode>94035-1000</postCode>
									<region>California</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SuperGlue: A Programming Environment for Scientific Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Visualization environments have two audiences: scientists and programmers. W e suggest that many existing platforms overemphasize ease-of-use and do not adequately address issues of extensibility. We have built a visualization testbed, called SuperGlue, which is particularly suited for the rapid development of new visualization methods. A n interpreter supports rapid development of new code and an extensive class hierarchy encourages code reuse. B y explicitly designing for ease of programming, we have produced a visualization system which is powerful, easy t o use, and rapidly improving. This report describes the motivation of the work, the architecture of the system, and our plans for further development.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Our application is the visualization of computational fluid dynamics (CFD) simulation results. This is a particularly demanding field due to the complex nature of the datasets. A steady-state 3D solution is produced by solving the Navier-Stokes equations (a system of non-linear partial differential equations) in a curvilinear coordinate system. This calculation typically takes many hours of Cray-class supercomputer time. The resulting dataset consists of a collection of vector and scalar fields sampled at millions of points. To meet the challenge of visualizing such data, we have produced an environment explicitly tailored for the rapid development of new visualization techniques for C F D .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Requirements</head><p>Scientific visualization packages share a common set of requirements. Although most packages attempt to meet them, most fall short in several ways. These requirements are not unique to visualization, but they apply more strongly to it than to many other specialties.</p><p>extensibility Cooperation between scientists and programmers can be very fruitful, but the value of this relationship depends upon the ability of the programmers to rapidly implement new features in response to changing needs.</p><p>flexibility Scientific visualization software must implement a wide variety of requirements including: reacting to user inputs, displaying computed models, and performing complex application-specific calculations over very large datasets.</p><p>robustness Visualization in many disciplines requires the management of a large amount of data, examined using many techniques. The development of new visualization methods is best achieved in the context of a running environment, and errors in the new code should not be allowed to bring down a running environment and its built-up internal state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Existing platforms</head><p>In this section, we consider three popular systems for the visualization of C F D results: Plot3D <ref type="bibr" target="#b3">[4]</ref>,</p><p>FAST <ref type="bibr">[l]</ref>, and Explorer <ref type="bibr" target="#b8">[9]</ref> from Silicon Graphics.</p><p>Plot3D is a mature, straightforward, and highly portable system. It is organized as a single-process program with a command-line interface. It has enjoyed wide acceptance because its pragmatic approach solves many problems that C F D researchers face on a daily basis.</p><p>In the FAST model, separate processes communicate through shared memory to produce a collection of geometric models of the data. These models are displayed by a central rendering module. New application-specific tools can attach to the shared memory, and may place newly-computed data and models into this common pool.</p><p>Explorer (and its conceptual predecessor AVS <ref type="bibr" target="#b10">[13]</ref>) are examples of the "data flow paradigm" of scientific visualization. New modules or filters can be strung together in a network through which data is processed from input file to screen image. A graphical network editor provides a simple means to construct a wide variety of different visualizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Limitations</head><p>All of these systems are extensible to some degree, but none of them strongly addresses the issue of rapid prototyping, full extensibility, or code reuse. Although FAST and Explorer allow the recompilation of just the single module under development, even this requirement can be disruptive to the programmer. Plot3D requires full recompilation in order to test new extensions.</p><p>Both FAST and Explorer offer some library-based utility routines for the implementation of new modules, but otherwise provide no provisions for reusing code. Plot3D provides no explicit support for code reuse, but has been extensively customized in dozens of derivative versions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">SuperGlue</head><p>It should be clear that the previously discussed requirements of a visualization system (extensibility, flexibility, and robustness) are best designed into a system from the start; it is extremely difficult to add them after the fact.</p><p>Of these three requirements we assert that systemwade extensibility is the most difficult to achieve. One common approach is to include a specialized configuration language. It has been our experience that these ad hoc languages grow over time and rarely develop into a coherent whole.</p><p>Rather than modify a visualization system to meet our requirements, we started with a system which already met these requirements and then added the specific features needed for visualization. More specifically, we centered the system around a complete, interpreted languagea dialect of Lisp called Scheme <ref type="bibr">[ll]</ref> which we then extended to support the demands of visualizing large CFD datasets.</p><p>SuperGlue has been implemented on SGI hardware; it should be portable, however, to any machine which supports a rich graphics environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Previous extension languages</head><p>The extension language approach has been used in many applications.</p><p>AutoCAD is a widely-used commercial system which uses a Lisp-like language for customization and extension. GNU Emacs also incorporates an interpreter for a dialect of Lisp, combined with a large number of compiled primitive functions for processing text. <ref type="bibr">Beckman [2]</ref> used Scheme to implement a system for interpreted programming with the Silicon Graphics GL.</p><p>P3D <ref type="bibr">(Welling et al [14]</ref>) is a restricted dialect of Common Lisp used to describe graphical models of the scientific data. SuperGlue extends this notion by allowing the language to describe user interaction as well as the format and the graphical presentation of the data.</p><p>PDBq Palmer <ref type="bibr">[lo]</ref>) is a scientific visualization guage which resembles C. Explicit support for vector arithmetic simplifies the programming of new visualization methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Overview</head><p>Section 2 describes the overall architecture of Su-perGlue. Sections 3 and 4 discuss the major extensions which were added to the command language. The application and the programming interfaces of Super-Glue are described in section 5 , and an example implementation of a new feature is examined in section 6.</p><p>package w x ich is built upon an special-purpose lan-The paper concludes with a review of the benefits and the difficulties of this approach, and a brief discussion of our future plans.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A dual-language architecture</head><p>The SuperGlue environment has been implemented using two languages: Scheme and C. This split adds some conceptual burden, but offers many advantages which make this approach worthwhile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.1</head><p>Interactive visualization requires a flexible and intuitive user interface, which is difficult to develop out of thin air. It must be evolved with the benefit of experience and experimentation. Scheme has several characteristics that make it the ideal choice for implementing the flow of control of complex interfaces: 0 It is interpreted. Programs can be written and tested interactively.</p><p>0 It is complete. Scheme is able to express a wide variety of programming paradigms.</p><p>0 It is standardized. This allows us to share code with other researchers.</p><p>SuperGlue is based on the "Xscheme" program written by David Betz, who allows its use for noncommercial purposes. Xscheme compiles Scheme expressions into machine-independent byte-codes, which are then executed on a virtual machine implemented in C. The result is a reasonable compromise between portability, compilation time, and execution speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">C as a computation language</head><p>Although Scheme is a fine language for high level control and user interface programming, most of our numerical and graphical primitives are coded in C. Execution speed is the primary reason for this, though many programmers also prefer C's compact syntax for mathematical programming. C is also more convenient when interfacing to Unix libraries. (Nothing in principle prevents new primitives from begin written in C++, FORTRAN, or other compiled languages, but at present it is less convenient.</p><p>Another reason to use C is mu tiprocessing. Our SGI workstations support the creation of autonomous lightweight threads that run on multiple CPUs. Once instantiated, a thread will run asynchronously until it needs to return a result. It must then gain temporary exclusive access to the interpreter in order to avoid corrupting shared data structures. A set of C macros simplifies this synchronization.</p><p>In order to maintain the benefits of an interpreted language when programming in C, we have extended Xscheme to support "dynamic loading." This feature allows new versions of a C function to be compiled and loaded into the running system; thereby shortcircuiting the traditional edit, compile, link, run, configure, and test cycle. Dynamically loading a page or two of source code takes only five to ten seconds.</p><p>Scheme as a control language 1 2.3 The inter-language interface A convenient interface between the two languages is a crucial component of any dual-language architecture. Two issues must be addressed: different storage models and different calling conventions. The difference in storage models is inherent in the specifications of the two languages. In C, variables are typed and values are untyped; in Scheme, values are typed and can be assigned to any variable. (This is equivalent to saying the C does compile-time type checking, while Scheme does run-time type checking.) We were able to preserve Scheme's "exceptionally clear and simple semantics" <ref type="bibr">[ll]</ref> by making it the responsibility of every C primitive to type-check and convert each of its Scheme arguments into the corresponding C format. When the function completes, its result must be converted to a Scheme data item.</p><p>The issue of different calling conventions is a consequence of the Xscheme virtual machine architecture. This virtual machine manages its own stack, which is independent of the C hardware stack. As a result, C primitives must explicitly pop their arguments from the Xscheme stack when they are called, and must explicitly push any arguments onto this stack when they call back to Scheme.</p><p>We decided to insulate all Scheme code from these implementation considerations. A set of C macros and functions allows these incompatibilities to be resolved in a straightforward and portable manner. The result is transparent access from Scheme to C and convenient access from C to Scheme. The cost of these conversions in terms of coding, maintenance, and execution time is insignificant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">T h e object system</head><p>The advantages of object-oriented systems are numerous and well-documented. The Xscheme kernel has extended the Scheme language to support single inheritance with dynamic method lookup. We added a convenient syntax for defining new methods and have built a class hierarchy of over 150 classes and almost 1500 methods. This class hierarchy collectively defines the generic features of all interactive visualization applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The hierarchy</head><p>The class object defines the behavior of all instances in the system, including that of the class c l a s s . The class c l a s s defines the behavior of all classes in the system, including itself. The remaining classes are grouped into the following major subtrees:</p><p>data contains the essential "computer science" data structures such as collections, stacks, queues, and dictionaries.</p><p>graphics implements an object-oriented interface to the Silicon Graphics GL. Automatic deallocation of GL resources is supported. Higher-level graphical objects, such as curves and meshes, are also included. Finally, direct-manipulation is supported by a virtual trackball and a 3D cursor.</p><p>interface provides 2D user-interface objects (such as sliders, buttons, and popup menus) implemented using GL. A scene widget forms a rectangular picture of a 3D scene.</p><p>math provides access to application-specific compiled code, such as numerical integration and interpolation routines. Class definitions are provided for matrices, quaternions, and the composite structures which represent CFD data sets.</p><p>system includes interfaces to Unix resources such as files, directories, and threads. Additional classes implement the Scheme runtime environment; these include clocks, alarms, and a sourcelevel Scheme debugger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Defining a new class</head><p>Each class inherits some of its behavior and contents from its superclass. It adds to this initial configuration by adding additional internal state, and by defining new methods which can be used to modify that state. The defmethod statement declares the name of the relevant class, the name of the method itself, an argument list, and the body of the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Message sending</head><p>The first item of any Scheme expression must be a function or an object. If it is an object, then second item must be a symbol, which is then used as the message to be sent to that instance. Messages which cannot be handled by the immediate class of the receiving instance are passed up the superclass chain. If a message fails to match any method in the chain, the erroneous send is trapped in the source code debugger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Storage management</head><p>A typical C F D dataset consists of a grid of a million points with a 3D position and three sampled flow quantities recorded for each point. As scientists examine a solution, they typically calculate many more fields over that same grid. Several features were explicitly added to SuperGlue to support the management of these large datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Chunks</head><p>Chunks are Scheme data items which contain a header and a contiguous block of untyped memory. The information in the header allows the garbage collector to reclaim storage when appropriate. Compiled primitives are used to process the compact data within the chunk.</p><p>Some scientific datasets are extremely large; so large that if we were to read them with normal methods we would rapidly exhaust the available swap space of the average workstation. This fatal situation can be avoided by memory mapping the contents of these large files directly into the program's address space. Memory mapped chunks are similar to normal chunks, except that they rely on the operating system to read the data from disk only when it is referenced. Besides preserving swap space, memory mapped chunks eliminate the initial file-reading delay of most other systems. This is significantly more efficient if only a subset of the data is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Storage of field data</head><p>It is often convenient to encapsulate a chunk within an instance of a class. This arrangement gives us the best of both worlds: a Scheme object with a set of supported methods, and an efficient means of storing the data. Taken together, these provide ease of bookkeeping with the speed required for complicated application-specific data manipulation.</p><p>C F D simulation results are represented by an instance of the class bundle cf. <ref type="bibr">Butler [5]</ref>), which concurvilinear grid. Each field contains its sampled volume as a chunk. This chunk is passed to applicationspecific primitives which operate on fields.</p><p>A bundle may be a subvolume of another bundle. When a bundle is asked for a field it does not have, the child may compute that field from the fields it does contain or may extract the data from the corresponding field in its parent. The expressive power of the interpreted language could be used to implement additional bookkeeping to support remote or lazy evaluation of field data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Destructors</head><p>Certain objects used in SuperGlue have an existence external to the system. For example, the SGI Graphics Library maintains lights, textures, and materials within its own address space. A mechanism for explicit destructors has been implemented so that when the associated instance for such an item is reclaimed by SuperGlue, the corresponding external resource can be explicitly deallocated.</p><p>The interpreter was extended to maintain a list of items for which explicit "destructor functions" have been defined. When the garbage collector completes tains a collection of named B elds defined on a common its mark pass of memory, unmarked objects on this special list are transferred t o a separate list of "reclaimed" objects. Items on this "reclaimed" list share the property that they are no longer in use, and thus can be deallocated when the system becomes idle. This approach consumes only three words of overhead for those few objects which require explicit destruction. It requires only a single scan of the special list between the mark and the sweep phases of the garbage collection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Interacting with SuperGlue</head><p>SuperGlue offers two interfaces. One is a mousedirected interface of widgets and and 3D scenes used in the target application. The other is a textual interface which is of use primarily to programmers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The application interface</head><p>The point-and-click side of SuperGlue presents a number of scenes and panels. A scene depicts a set of objects, or visuals, in a 3D environment. A scene can be resized to any size or shape, and can even cover the entire workstation screen. The constructed models can be displayed in any number of scenes; each with its own viewing direction and magnification. A panel contains a number of 2D widgets, is usually fairly small, and cannot be resized. <ref type="figure" target="#fig_5">Figure A</ref> shows a typical screen display, including two views of some 3D data <ref type="figure" target="#fig_9">(Rogers [12]</ref>), an instance inspector, and a hierarchy browser.</p><p>The application interface of SuperGlue provides direct-manipulation of cursors in the 3D volume of a flow field. Chording of the mouse buttons is used to control a modal mapping between the 2D motions of the mouse and the 3D motions of the cursor. Users often manipulate these 3D probes at high magnification while viewing the resultant models from another angle in a second window. This approach allows the precise and direct placement of control points, a vast improvement over what is possible by indirectly controlling these positions using multiple 2D widgets.</p><p>The system attempts to maintain a high frame rate by downgrading the quality of the image while it is moving in response to user input. When the user pauses between commands, the system does not pause, but uses the otherwise idle machine cycles to improve the accuracy of the presented results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">T h e textual interface</head><p>SuperGlue programming is qualitatively different than programming in compiled languages. The primary reason for this is the rapid feedback provided by an interpreted language. Rather than typing at the SuperGlue interpreter directly, we rely on the builtin capability of GNU Emacs to control external processes. Thus all text input to and output from Super-Glue goes through Emacs. The Emacs window can be split into sections, which can independently display files of source code, the interpreter transcript, and interactions with the Scheme and the compiled code debuggers.</p><p>A typical SuperGlue session lasts somewhere between several hours and several days. During this time many Scheme and C functions are defined and redefined. Emacs supports this activity by allowing either individual functions or entire files of either C or Scheme code to be downloaded to the interpreter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Debugging</head><p>SuperGlue provides the usual tools of a Lisp-based environment, including code tracing, pretty-printers, break loops, and a simple programmatic interface for handling errors. Unhandled errors and user-generated interrupts cause the system to trap into the interactive debugger. Unlike most C or FORTRAN environments, it is unnecessary to run "under the debugger," since it is built into the system.</p><p>The Scheme debugger allows the user to print the current source code expression, to display the call stack, to examine and modify local variables, to evaluate arbitrary expressions in the context of a particular frame, to set breakpoints, to automatically display the relevant source code in Emacs, and finally to fix and proceed from most errors. The debugger includes online help and offers different modes for beginning and advanced SuperGlue programmers.</p><p>The GNU debugger db is used to debug all C code, including any dynamicaly-loaded C. No additional effort is required to debug dynamically-loaded code; the required additional bookkeeping is handled automatically if the programmer loads the C code with the standard SuperGlue Emacs keystroke.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">A programming example</head><p>Programming in SuperGlue often consists of writing new methods to improve the user interface or creating a new class to access some new applicationspecific routine. We describe an example of the latter in this section, then demonstrate the advantages of incorporating new features as first-class entities of an evolving system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Stream line calculation</head><p>A common technique in flow visualization uses tangent curves through a vector field. When the field is the velocity of the steady fluid, then each curve defines the path traveled by a massless particle drifting through the flow; such paths are called streamlines. In this section, we describe an implementation of streamlines for CFD datasets.</p><p>A streamline is the solution of the initial value problem posed by a vector field U and an initial point XO. We need to compute a sequence of points This integration requires numerical methods iterated over a piecewise interpolation of the vector field samples. SuperGlue provides several primitives for this calculation, using a variety of adaptive, multistep, and predictor-corrector methods. Since this computation can be time-consuming, all of these routines are implemented in C and can be run as threads spawned from the user interface. These functions place the computed point coordinates into a chunk which is available to the rendering thread for the display of interim results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">The streamline object</head><p>A new class definition is needed to manage calls to the calculation primitives. This new streamline class can inherit much of its behavior from the alreadyexisting path class. Every instance of path stores a bundle of one-dimensional fields. It supplies methods for computing the bounding boxes of its fields and for rendering that curve using GL or PostScript.</p><p>The declaration of the new class declares it to be a subclass of path, to which it adds three new instance variables: domain, vec-name, and my-thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(def c l a s s streamline (super path) (instance domain vec-name my-thread)</head><p>When any instance is created, it immediately receives the isnew initialization message. The corresponding method for our new class includes a call to the initializer of the superclass, and then stores the argument values into the internal state of this new instance. These three arguments are the bundle of the enclosing (usually 3D) domain, the name of the vector field (e.g. velocity, temperature-gradient) in which the streamline is to be computed, and the initial seed point from which the streamline to begin. The method does not call the primitive directly, but instead passes it and the arguments to the thread class, which spawns a task and returns an instance which serves as a handle for this computational task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Using streamlines</head><p>Since the streamline class has been incorporated into the class hierarchy of SuperGlue, it is now available for use in any future application. This offers many benefits over the frequent alternative in which a new feature is accessible only as an option on a menu. Three examples presented here use instances of streamline, but specify the initial seed points of the curves in a different way.</p><p>The data used in these examples was computed by Ekaterinaris and Schiff computed placement Finally, a composition of functions can be used to automate the placement of streamlines. A 2D slice was extracted from the flow data. All grid points on this slice with a fluid density below some threshold were then used as seed points for a third set of streamlines, shown in a side view in figure D.</p><p>The three sets of streamlines can be combined in a single image to produce a depiction of the vortex. This is shown in a side view in figure E, and from upstream and above the wing in figure F. The distinct placement methods complement each other and together provide a more useful tool for examining this data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>Our experience with developing and using Super-Glue has convinced us that our approach is sound. Development of new tools is rapid, fun, and endowed with high probability of a successful result. Problems with the system have appeared, but these are more irksome than serious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Applications</head><p>SuperGlue has been used to create an animation of a proposed space station design <ref type="figure" target="#fig_6">(Globus [7]</ref>).</p><p>It has been used as an exploratory environment for the development of new (presently unpublished) visualization techniques.</p><p>It was used by one of the authors as the development platform for an improved method for the construction of stream surfaces <ref type="bibr">[B]</ref>.</p><p>It currently lacks some of the features required for unassisted use by scientists, but we are adding this "user-friendliness" as quickly as we can. We believe that having invested a great deal of time in laying the foundation, we shall be able to construct the rest of the house much more quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Problems</head><p>We did not fully appreciate the sheer magnitude of code required in an interactive visualization environment. SuperGlue is now about 35000 lines of code, split about equally between Scheme and C. After applying three man-years of effort to extending a previously existing interpreter, we have only made a dent in our list of desired features.</p><p>The difference in the speeds of interpreted Scheme and compiled C can be as much as one hundred-fold.</p><p>For many portions of the system, this difference in speed is not important; in others, it is unacceptable. An optimizing native code compiler for Scheme and a faster garbage collector would allow Scheme code to be used for a greater proportion of the system. Commercial LISP implementations provide this speed, but we needed a system which could be fully modified for our particular goals. We did not fully anticipate the great resistance we have encountered regarding the use of Scheme. Dialects of LISP are still regarded with suspicion or disdain, perhaps in supercomputer centers more than anywhere else.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Future plans</head><p>The SuperGlue project is open-ended by design; progress is made by growing the class hierarchy. Certain features hold particular interest for us and we expect to spend the coming year implementing these items: publication tools Interactive color raster displays are a. valuable exploratory tool, but publishable images are a necessity. The realities of modern publishing still require line art for the majority of archival publications.</p><p>virtual reality Levit and Bryson <ref type="bibr" target="#b2">[3]</ref> have shown that the visualization of complex flow fields can be greatly aided by the technology of virtual reality. In a virtual reality environment the display must be repainted in real-time, so all of the drawing code must be migrated into C where it will be immune from intermittent pauses caused by garbage collection.</p><p>unsteady data The state of the art in computational fluid dynamics has reached the stage of simulating 3D unsteady flows. The massive data storage requirements almost certainly demand a distributed implementation using workstations connected to supercomputers over high-speed networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Summary</head><p>No tool is right for every job; no language is right for every algorithm. The bilingual structure of Su-perGlue provides a flexible platform from which to attack the varied requirements of interactive visualization, from the tuning of a user interface to the processing of a large dataset.</p><p>Chunks and memory-mapped files are compact and efficient mechanisms that allow data to be managed and examined from the Scheme command layer, yet rapidly processed by compiled numerical and graphical routines. Bundles simplify manipulation of CFD datasets. Destructors are an efficient mechanism that allow external resources to be returned when they are no longer needed.</p><p>Programming with an interpreter allows convenient exploration of alternative implementations. The class hierarchy provides a clean mechanism for the reuse of code. Together, these features help reduce the time required for the implementation of new features. The programming members of a visualization team are able to respond in a timely manner to the needs of their scientist-clients.      </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>dei c l a s s dass-name (super superclass-name) ( c l a s s class-variable . . .) ( class-variable indzalzzer) (instance instance-variable . . . I &gt; The dei c l a s s statement begins with the name of the new class, followed by three statements which define the superclass and the additional internal state of the new class. The c l a s s statement defines the variables which are shared among all instances of the new class. The instance statement defines the new variables which are held as separate copies in each new instance. (defmethod class-name ( method-name argl ... &gt; body ... 1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>(</head><label></label><figDesc>x0,x1, . . .xn) such that t i + 1 X i + l = xi + li u(x(s))ds for a closely-spaced sequence of values (ti V i E [0, T I ] ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>The sequence of points along the curve is computed by calling the compiled primitive function streamline: calc. The compute method provides a convenient wrapper for this routine. The primitive receives the 1D position field result buffer, the position and vector fields of the enclosing 3D bundle, and the initial seed point xo for the integrated curve. (defmethod streamline (COMPUTE seed) ; ; Reinitialize this streamline, ; ; and allocate the destination buffer. (when my-thread (my-thread ' k i l l ) ) (path ' r e s e t ) (path ' a l l o c ' p o s i t i o n 1000) ; ; Do computation as a separate iask.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>[ 6 ]</head><label>6</label><figDesc>. It represents a "vortex breakdown" over a delta wing, moving at Mach 0.3 at 40 degrees angle of attack and a Reynolds number of lo6. The grid contains slightly over 200,000 data points. manual placement Using the standard 3D cursor instance (shown in figure B), we can place a number of seed points in the breakdown region of the vortex. Exploration of this region of the data is greatly aided by direct manipulation and interactive response. scripted placement Interactive placement is convenient for the exploration of some flow features, but placement at exactly specified points in the flow is often desired. A trivial Scheme expression was used in figure C to place a sequence of seed points along the leading edge of the wing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure A</head><label>A</label><figDesc>Application interface of SuperGlue, showing two scenesan inspector, and a hierarchy browser.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure B :</head><label>B</label><figDesc>Close up view of the mouse-directed placement of seed points in the breakdown region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure C :</head><label>C</label><figDesc>Scripted placement of seed points along the leading edge of a delta wing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure D :</head><label>D</label><figDesc>Side view of the computed placement of seed points in the low-density vortex core.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure E :</head><label>E</label><figDesc>Side view of the completed visualization of the vortex breakdown over a delta wing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure F :</head><label>F</label><figDesc>Three-quarter vlew of the vortex breakdown over a delta wing.(See wlorplates, p. CP-27.)</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="0">It is convenient. Scheme provides dynamic typing, automatic memory deallocation, simple syntax, and a wide variety of data types.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We wish to thank Tom Lasinski, who has steadfastly supported our efforts. We thank A1 Globus, Kris Miceli, and Michael Gerald-Yamasaki, who have tested early versions of the code. JH wishes to thank Mary Hultquist for her encouragement and tolerance. We also thank David Betz for his fine implementation of Xscheme, and John Ekaterinaris and Stuart Rogers for allowing the use of their flow data.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">FAST: A multiprocessed environment for visualization of computational fluid dynamics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gordon</forename><forename type="middle">V</forename><surname>Bancroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;90</title>
		<meeting>Visualization &apos;90<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-10" />
			<biblScope unit="page" from="14" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">A scheme for little languages in interactive raphics. Soflware-Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Beckman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-02" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="187" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The virtual windtunnel: An environment for the exploration of three-dimensional unsteady fluid flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Bryson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Creon</forename><surname>Levit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;91</title>
		<meeting>IEEE Visualization &apos;91<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-07" />
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Graphics and flow visualization in CFD</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Buning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Steger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A I A A Aerospace Sciences Conference</title>
		<meeting><address><addrLine>Reno, NV</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
	<note>AIAA Paper 851507</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A visualization model based on the mathematics of fiber bundles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Pendley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers in Physics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="45" to="51" />
			<date type="published" when="1989-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Vortical flows over delta wings and numerical prediction of vortex breakdown</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Ekaterinaris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">B</forename><surname>Schiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A I A A Aerospace Sciences Conference</title>
		<meeting><address><addrLine>Reno, NV; Pa</addrLine></address></meeting>
		<imprint>
			<publisher>AIAA</publisher>
			<date type="published" when="1990-01" />
			<biblScope unit="page" from="90" to="0102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The design and visualization of a space biosphere</title>
	</analytic>
	<monogr>
		<title level="m">lUth Biennial Space Studies Institute / Princeton University Conference on Space Manufacturing</title>
		<meeting><address><addrLine>Princeton, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Constructing stream surfaces in steady 3d vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P M</forename><surname>Hultquist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Vzsualiration &apos;98</title>
		<meeting>Vzsualiration &apos;98<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Document Number 007-1371-010. A language for molecular visualization</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="23" to="32" />
			<date type="published" when="1992-01" />
		</imprint>
	</monogr>
	<note>Silicon Graphics Inc. IRIS Explorer user&apos;s guide</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A numerical study of three-dimensional incompressible flow around multiple posts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">A</forename><surname>Rees</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Clinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Revised3 report on the algorithmic language scheme. A C M Sigplan Notices</title>
		<meeting><address><addrLine>Reno, NV</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-01" />
			<biblScope unit="volume">21</biblScope>
		</imprint>
	</monogr>
	<note>A I A A Aerospace Sciences Conference. AIAA Paper 86-0353</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The application visualization system [AVS): A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Craig U Son</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">P3D: A lispbased format for representing general 3d models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Welling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Nuuja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phil</forename><surname>Andrews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Supercomputing &apos;90</title>
		<meeting>Supercomputing &apos;90</meeting>
		<imprint>
			<date type="published" when="1990-01" />
			<biblScope unit="page" from="766" to="774" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">C</forename><surname>Palmer</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Kaul</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
