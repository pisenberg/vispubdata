<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Efficient Range Search Algorithm for Visualizing Extrema of Volume Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaolin</forename><surname>Wu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Western Ontario London</orgName>
								<address>
									<postCode>N6A 5B7</postCode>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Efficient Range Search Algorithm for Visualizing Extrema of Volume Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>qisualization of volume data</term>
					<term>multidimensional range search</term>
					<term>computational geometry</term>
					<term>algorithms</term>
					<term>data structures</term>
					<term>expected time complexity</term>
					<term>nearest common ancestor</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This article presents a new, fast range search algorithm for visualizing extrema of d-dimensional volume data in real time as the user interactively moves the query range. The new algorithm is based on an eficient data structure, called index heap, which needs only O(N/log N) space and O(d2dN) preprocessing time to be set up, where N is the site of d-dimensional data volume. The algorithm can answer an extremum query in 0 (4 d) expected time and its worst case time complexity is 0(2d log N) per query. For dimensions two and three, we can consider that the range search for extrema is effected in average 0(1) time per query independent of the sire of query range. Unlike the present range query algorithms in the computational geometry literature, the proposed algorithm is very simple and can be easily implemented by practitioners.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In visualizing volume data the user can carry out range queries in a d-dimensional space, say, where are the minimum and/or maximum of the data points within a given d-dimensional query range? Then the positions of the data extrema in spatial relation to the query range can be projected into some three or two-dimensional subspaces graphically and get visualized. For instance, for a three-dimensional data set, the query range, a box, a sphere, or a general polyhedron, can be displayed as a wire-frame or transparent enclosure, and the answer to the query can be visually encoded, say by color coding. Thus one can visualize where the maximum and/or the minimum of the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Yonggang Fang t</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Department of Electronic Engineering</head><p>Tsinghua University Beijing, P.R.China 100084 volume data in the query range are located through 3D graphics. This visualization of extrema in a threedimensional volume is useful in medical imaging. The minimum and maximum voxel values in a local threedimensional region have diagnostic significance. Visually locating these statistic attributes of 3-dimensional C T or MRI image data in a clear geometrical reference to the major body organs allows doctors to put things into context thus interpret medical image data more intuitively than simply reading the locations of these statistic attributes. Furthermore, it is helpful for the doctors to see the locations of maximum and/or minimum voxel values in range query as functions of the query region. Namely, the user interactively changes the position, the shape or/and the size of query region, and visualizes how the answers to the range queries change accordingly in real time. The same type of graphical tool can also be useful for scientists and statisticians in multivariate analysis. This research was motivated by the above visualization applications.</p><p>This research focuses on the algorithmic aspect of the introduced visualization problem. Specifically for the above application in medical imaging, we are concerned with how fast the locations of minimum and maximum voxel values inside any given threedimensional query range Q can be identified. Since the three-dimensional medical images consist of huge amount of volume data, the naive linear search for extrema in a query region is bound to be too slow for real-time applications. To shorten the query time we preprocess the volume data and construct some search data structures. This approach is known as multidimensional range search in the field of computational geometry <ref type="bibr" target="#b2">[2]</ref>. Multidimensional range search has been a very active research topic in the last decade with many algorithms published (see the reference lists of [l, 41). Unfortunately, these published algorithms, although with attractive asymptotical behaviour in theory, are generally too complicated requiring the support of intricate data structures to be practical. In ad-dition to the implementation difficulties, these range search algorithms can outperform the straightforward algorithms in terms of query time only when the involved data set is very large. What necessitates the complex data structures of the current range search algorithms is a general problem formulation which is unnecessary for visualizing extrema of volume data of medical images. Computational geometry researchers formulate range search on a finite set of arbitrarily distributed points in Euclidean space. However, in medical imaging, volume data are usually given as a set of points on a finite N, x Ny x N, rectangular lattice, i.e., as a three-dimensional array of voxels. This lattice arrangement of the data points enables us to design far more simpler and faster range query algorithms than the current algorithms.</p><p>First we introduce in the next section a search data structure called index heap which is central to our effiLient range query algorithm for visualizing extrema in volume data. Then based on this data structure we develop in section 3 the new range query algorithm in detail in two dimensions. This development is generalized to any dimensions in section 4. Section 5 contains a technique to reduce the space requirement of the index heap data structure which contributes to the practicability of the proposed algorithm. We conclude the paper with our experimental results and remarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Index Heap and Extrema-Finding</head><p>Without loss of generality we will only discuss range query for maximum in the sequel. The case of range query for minimum follows trivially by symmetry. To give the reader some intuition we first study the one- To facilitate the range query for maximum we organize, in a preprocessing, the indices i by the values f ( i ) of the sequence F in a complete binary tree structure. For convenience and without loss of generality we assume that N is a power of 2. We pair up f(i) from left to right, and store the index of the larger value of f ( 2 t -1) and f(21), 1 5 t 5 N/2. Then the indices of the larger values are organized in the same way and so on, resulting in a tree structure as depicted by <ref type="figure">Figure l(a)</ref>.</p><p>If the indices i associated with the internal nodes of the tree in <ref type="figure">Figure l</ref> We call these intervals of length of a power of 2 the standard f index ranges.</p><p>For reasons to be self-evident shortly we number the nodes of index heap with consecutive positive integers starting from 1 in the in-order traversal of the heap as illustrated in <ref type="figure">Figure l</ref> Please distinguish between i and j , the former is an f index in the sequence F while the latter is an index of array A which stores f indices in the index heap according to in-order traversal. Then it is easy to see that at the position j = 2h(2t -1) in A is a heap node of height h that is the root of the subheap covering the standard f index range ( z h</p><formula xml:id="formula_0">( t -1),2ht]. Thus f(A[ah(2t -l)]) = max{f(i)lah(t -1) &lt; i 5 2 h t } , t = 1 , 2 , . . . N 2 -h .</formula><p>(1) One reason for numbering the nodes of the index heap by in-order traversal is that the nearest common ancestor of any pair of nodes can be computed by a   <ref type="figure" target="#fig_5">Figure   2</ref> when the algorithm searches down the index heap, the actual query range always covers at least half of the standard f ranges corresponding to the subheaps. This means that the root of a subheap has a better than 0.5 chance of falling into the query range. Consequently, we have </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head><p>In this section we will generalize the onedimensional range search algorithm for extrema to two Range Search for 2 D Extrema dimensions. As stated in the introduction this algorithmic study was motivated by the need of visualizing the extrema of three-dimensional volume data. In two dimensions the problem seems less interesting in terms of visualization. One can alway plot a two-dimensional f( t, y) as a three-dimensional surface z = f(z, y) and directly observe the peaks and valleys on the surface for local maxima and minima. However, if the function f ( t , y) oscillates excessively then it becomes difficult to identify the exact maximum or minimum in a given range just by viewing a perspective projection of the surface z = f ( t , y ) . The user may want the positions of the maximum and minimum in an interactively specified area clearly marked. This necessitates range search for extrema in two dimensions. Another application of two-dimensional range query for extrema often occurs in image analysis. Visually identifying the maximumor minimum of a given query range in a gray scale image can be hard due to the noise or subtle intensity change. In our experience of developing an interactive image processing tool kit the users were much happier when they could easily follow the positions of maximum and minimum in an image window of interest as the window moves by reading moving markers such as arrow, cross or color coded pixel that identify maximum and minimum rather than base their judgement on gray values. Besides their own immediate applications we study two-dimensional range query also because the following development in two dimensions can be straightforwardly generalized to three dimensions and further to any number of dimensions.</p><p>Let f(z, y) be a two-dimensional function defined on an N, . . , f(z, Y N~) , 1 5 c 5 N,, of the N, x Ny lattice. Then we interconnect all these one-dimensional heaps as depicted by <ref type="figure" target="#fig_9">Figure 3</ref> to form a two-dimensional heap. This seemingly messy data structure has an elegant two-dimensional array representation. Let A be a <ref type="figure" target="#fig_2">( 2 N , -1)</ref> x (2Ny -1) array of two-dimensional coordinates A[r, c] = <ref type="figure">(xma,, y,,,)</ref> of the maximum in some rectangle. Specifically we define f <ref type="figure" target="#fig_5">(A[2'(2t,l</ref>   <ref type="figure" target="#fig_2">(2zo -1,221 -1,2y0 -1,2yl -1)</ref> will return the xy coordinates of the maximum of f(z,y) in Q. It is clear that in the worst case the two-dimensional query algorithm runs in time preportional to the height of the two-dimensional index heap, namely, O(log(N,Ny)). Like in the onedimensional case the expected time complexity of the algorithm is determined by the average number of recursion levels that the function MAX invokes before it finds the maximum position. In a similar analysis to that of previous section, we find that as the algorithm searches down the two-dimensional index heap, each test on the root of a subheap which is the maximum of a standard range, i.e., the predict  <ref type="figure" target="#fig_2">(2N,, -1) x (2N,, -1)</ref> x . . <ref type="figure" target="#fig_2">x (2N,, -1</ref> Based on the above theorem, we may still consider that the expected time complexity of range search for extrema in three dimensions to be O(1). Due to the importance of three-dimensional range query algorithm in volume data visualization we give below the pseudocode of the algorithm in three dimensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Compaction of Index Heap</head><p>Although the space required by the index heap data structure is O(d2dN), being linear in the size of data volume, this memory requirement may be too high in practice if the data volume is very large (true for medical images) and particularly considering that the index heap needs to reside in RAM for speeding up the query time. In this section we will show that it is unnecessary to explicitly record the coordinates of the maxima of all standard ranges in the index heap. A compact bit representation of d-dimensional index heap will be introduced to reduce the memory requirement from O ( C~~~N ) words to O ( C~~~N ) bits, while the time complexities of the range query algorithm remain the same as before.</p><p>For simplicity and intuition, we again begin with one dimensional case. Recall that in <ref type="figure" target="#fig_2">Figure 1</ref>  And the test if j , , , E L 0 , j l ) can tell whether to terminate the query successfully or to search further down the index heap. By now we have developed a compact bit representation of the one-dimensional index heap and showed that the working space for the proposed range query algorithm for extrema can be reduced from O ( N ) words to O ( N ) bits in one dimension with only a constant penalty on the expected query time. This space reduction represents a saving by a factor of O(1og N), since the word length W must be no shorter than log N to code the maximum position in the straightforward array representation of the index heap developed in section 2. In other words, if W 2 log N is satisfied on a RAM machine then the extra space requirement by the heap data structure is sublinear, <ref type="figure">namely, O ( N / log N)</ref> in machine words.</p><p>Generalizing the compact bit representation from one-dimensional index heap to multi-dimensional index heap is trivial, since the construction of the ddimensional index heap is separable in dimensions. Recall that a d-dimensional index heap can be represented by a d-dimensional <ref type="figure" target="#fig_2">(2NZ, -1) x (2NZ, -1)</ref> x --x (2N2, -1) <ref type="figure" target="#fig_5">array A [ q , 2 2</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Empirical Results and Remarks</head><p>In contrast to the range query algorithms published in the computational geometry literature which demand the support of intricate data structures and often have good asymptotical performance only in theory, the proposed range query algorithm for extrema of volume data is very simple hence easy to implement. The pseudocodes given in the paper are almost in a form of actual computer program. We implemented the new algorithm in two and three dimensions, and timed the algorithm with actual medical image data. The empirical results indicated that the expected time complexity by our algorithm analysis matched the average query time in practice. For instances, an average of 15 tests were carried out to find an extrema in a tw-dimensional query range; an average of 63 tests sufficed in a three-dimensional query range. These average operation counts were independent of the sizes of query ranges. Our experiments agreed with our algorithm analysis that the coefficient before the expected time complexity 0(4d) is 1. Therefore, if the query range has a size larger than 4d then the new algorithm will outperform the naive exhaustive search. In scientific visualization applications the size of query range is usually much larger than 4d, thus the new algorithm presents an efficient and practical solution to the problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>*t</head><label></label><figDesc>Supported by grants from the Natural Science and Engi-Currently visiting the first author's department. neering Council of Canada.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>dimensional case. Let F = f(l)f(2) . . . f ( N ) be a sequence of N real numbers. Then a query range [/,.I, 1 5 r, corresponds to a subsequence F [ I , r ] = f(/). . . f(r) of F . Given a query range [ I , r] we want to report the index am,,, I 5 i,,, 5 r , such that f(imaz) 2 f(t) for all 1 5 t 5 r .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>(a) are replaced by f(i), then the tree in Figure 1 becomes a heap on f ( i ) . Thus we call this data structure index heap. The root of the index heap stores the f index of the maximum value of the entire interval [l, NI, where root.leftson (respectively rootightson) stores the f index of the maxi-The paper is organized as follows. (a) an index heap; (b) the numbering of heap nodes by in-order traversal for an array representation of the heap and for simple nca computation. mum value in interval [l, N/2] (respectively (N/2, NI).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(b). This numbering allows the representation of the index heap to be a simple one-dimensional array A , i.e., A b ] is the content (an f index) of the j t h node of the index heap in the in-order traversal. The relation between the f index i and the position j such that A [ j ] = i is simply j = 2i -1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>2 )THEOREM 1</head><label>21</label><figDesc>simple expression in O( 1) time on a RAM machine [3]. Denote by nca(j0, j l ) the nearest common ancestor of j o and jl, where j o , j1 and nca(j0,jl) are all the indices of array A. Then we have nca(jo , j l ) = 2h+1 Ijo/2h+' J + 2h h = llog(jo@ji)J, ( with h being the height of n c a ( j 0 , j l ) in the index heap, and @ is the bitwise XOR operator. Note that the nca operation plays an important role in the following range query algorithm because the smallest standard f index range covering a query range [I,r] corresponds to the nearest common ancestor of the two end points I and r in the index heap. Now we are ready to introduce our algorithm for range search for maximum. Given a query range [I, r] we first find the smallest standard f index range I that covers [I,r]. Since the index i,,, of the maximum value in the standard range I is available in the index heap, we can fetch it and test if i,,, E [I,.]. If the answer is yes we are done, otherwise we divide the search problem into two subproblems: maximum query in [I,mid(I)] and maximum query in [mid(I) + 1 , r ] , where mid(I) is the midpoint of the standard interval I, and solve the subproblems recursively. The final result can be obtained by combining the answers to the subproblems. The algorithm is described below as a simple recursive function. MAX(j0, j1): f index; begin X = nca(jo,jl); { compute nca using Eq(2) } then return(A[X]); else begin if API E [ ( j o + 1 ) / 2 , ( j l + 11/21 ti = MAX(j0, X -1 ) ; t z = MAX(X + 1 , j l ) ; if f ( t 1 ) &gt; f(t2) then return(t1) else return(t2); end; end. Given an f query range [I,.] we call the function M A X by letting jo = 21 -1 and j1 = 2r -1. The function MAX(21-1,2r -1 ) returns the f index of the maximum valuef(MAX(2I -1,2r -1 )) in the subsequence F[I, r]. The worst case time complexity of the proposed algorithm is O(1og N) since a query range [I, r] will.be partitioned by the algorithm into at most O(1ogN) standard ranges. But even better we can prove the following. The proposed algorithm can report the mazimum in a query range [I, r] in 0(1) ezpected time. 0 : points m the quay range</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :</head><label>2</label><figDesc>The query range always covers at least half of the standard f ranges as the proposed range query algorithm searches down the index heap.Proof. Suppose that the predict A[X] E [2j0 -1 , 2 j l -11 in the preceding pseudocode MAX(j0, jl) has probability p to be satisfied. Then the algorithm has the probability ( 1 -p)"-'p to search down the index heap n levels before it succeeds in locating the maximum, thus on the average it needs to searchlog N 4 1 -P)"-lP (3) n = l levels down from the root of the index heap. Under the assumption that any point in a query range [I, r] has equal likelihood to be the maximum we have p 2 0.5. To verify p 2 0.5 we only need to see in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>n=l and thus the theorem. 0 The preprocessing of constructing the f index heap takes O ( N ) time and clearly the index heap uses O ( N ) space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>x</head><label></label><figDesc>Ny lattice. Given a rectangular query range [ z l , t r ] x [yl,yr] we want to report the position (tm,,,yma,) such that f(zma,, Ymaz) = max{f(x:, Y)I(Z, Y) E [ ; c I~ e r ] x [YI, ~r l } . TO speed UP the above two-dimensional range search we introduce a data structure called two-dimensional index heap which is a generalization of its one-dimensional counterpart. First one-dimensional index heaps are built on all rows f(.l,Y),f(zz,Y)...,f(z lv,,Y), 1 I Y 5Ny, and all columns f(z, YI), f(z, ~2 ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>( 2 ,</head><label>2</label><figDesc>), 2j(2ty -l)]) E max{ f (2, y)I 1 I; t, I; N,2-', 1 5 t , 5 Ny2-j, Y)E(2't,, 2'(t,+l)] x ( 2 J t y , 2j(ty+1)]} 0 : actual data point. 0 : internal heap node. ---. : ldimensional index heap in x direction. ....... : ldimensional index heap in y direction. -: link between x and y index heaps to form 2dimensional index heap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 3 :</head><label>3</label><figDesc>Two-dimensional index heap. 0 5 i I l o g N , , 0 5 j I l o g N y . (5) Note that A[., .] is itself a 2-vector, but we simply treat A[.,.] as an entity and refer it, in the sequel, to an f index as we did in one-dimensional case and for any d-dimensional function f. We call a rectangle of form (2'tz,2'(t, + I)] x ( 2 j t y , 2 j ( t y + I)] a standard index range. Such a standard index range corresponds to a heap node which contains the coordinates (zma,,yma,) of the maximum value in the standard range, and this heap node is A[2'(2t, -1),2J(2tyl)] = (2,,,,ymaz). Based on the above array representation of two-dimensional index heap, it is straightforward to generalize the one-dimensional range search algorithm for maximum in the previous section to two dimensions. end. Given a query range Q = [zo,z1] x [yo,yl] the function call MAX</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>THEOREM 2</head><label>2</label><figDesc>A[A,, Ay] E each recursive invocation of the function MAX, has a probability p 2 0.25 to be successful. Thus the expected depth of recursion of function MAX is b o + 1)/21 b l + 11/31 x &amp;yo + I)/% ( j , l + 1)/21 in n = l n = l In two dimensions we can still consider that each recursion level of function MAX terminates in O( 1) time. Therefore, we have the following conclusion. The proposed two-dimensional range query algorithm can report the maximum in any rectangular query range Q = [zo,z1] x [yo,yl] in O(1) expected time. As indicated by Figure 3 and Eq(5), the array representation of the two-dimensional index heap A[., -] has (2N, -1)(2Ny -1) elements, one for each standard index range. Thus the space complexity of the two-dimensional range query algorithm is O ( N , N y ) , linear to the number of pixels. The preprocessing of setting up A[., .] clearly runs in ( N , N y ) time.4 Generalization to High-dimensionalUp to now it should have become obvious how the proposed range search algorithm for extrema can be generalized to volume data in any d-dimensional N,, x NS2 x . . x N,, lattice. The data structure required is a so-called d-dimensional index heap which is constructed by interconnecting d one-dimensional index heaps, one for each dimension. The d-dimensional index heap can be represented by a d-dimensional</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>where p 2 2 -THEOREM 3</head><label>23</label><figDesc>) array Let N = n l y &lt; d N z j be the total size of the Then O d2dN) space are required to set up the ddimensional index heap data structure. In d dimensions, the expected depth of recursion of the function MAX before the maximum in an arbitrary query range is found is d is the probability for each level of the recursion to successfully find the maximum in the query range. In the worst case the d-dimensional range query algorithm for extrema can trace the index heap from its root to one of its leaves, invoking up to O(1ogN) levels of recursion. Each recursion level of the function MAX costs 0(2d) time since it divides the problem into 2d subproblems and then selects the maximum. In summary we state the general result below. The expected and worst case time complexities of the proposed range query algorithm are 0(2dT(d)) = 0(4d) and 0(2d log N ) respectively, with O ( C~~~N ) preprocessing time and O(d2dN) space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>each internal node of the index heap inherits the f index from either its left son or right son. Now we annotate an internal heap node v by bit 0 if the maximum comes from v.leftson or by bit 1 if the maximum comes from v.rightson. Thus one bit per node suffices to record the maximum position of a standard range if we traverse the bit-annotated heap from the node corresponding to the standard range down to the leaf node. This encoding of index heap requires only N-1 bits. However, with the above bit representation of the index heap we can no longer directly obtain the index of the maximum of a standard range since the maximum positions in bit heap representation are all relative. One needs to traverse the heap following a bit path to get the maximum position. Consequently, the expected query time is increased from previously In order to improve the expected query time even with a compact bit representation of the index heap, we record the maximum position of each standard index range relative to the left end of the standard index range. Since a standard index range corresponding to a heap node at height h covers only 2h points, h bits suffice to code the relative maximum position. Thus variable length code is used to encode the index heap with the maximum position in an internal heap node at height h being represented as an integer of h bits. Then we traverse the heap in preorder to concatenate the variable length codes of all heap nodes visited to a single bit string S . The total length of the bit string S isO(1) to O(l0g N ) . log N IS[ = h210gN-h = 2N -logN -2,(8)being only twice as long as the previous one bit per node representation. Next we will show that the new heap encoding scheme still enables constant query time in the expected case.h = l On a RAM machine the string S is pacted into ISl/W machine words, where W is the computer word length. Thus variable-length code of the maximum position at an internal node of the heap may straddle in between adjacent machine words. In order to fetch the variable-length code for an arbitrary internal heap node in constant time we develop the following technique. Let Q = [I,.] be an f query range. Recall from section 2 that this query range corresponds to the index range [ j o , j l ] in the index heap, where j , = 21l,j, = 2r -1. In the index heap, the node nca(j0,jl) is at height h = [log(jo@jl)], and the node nca(j0,jl) is s away from the leftmost node v,(la) at the height h , where (9) Because the compact variable-length encoding of the index heap is through the preorder heap traversal, the code of the heap node v,(h) begins at the bit position log Nh-1 ao(h) = 2'(logNi) i = O = ( h + 2 ) 2 -h N -l o g N -2 (10) in the string S . Therefore, the code of the node nca(j0,jl) which is s away from vl(h) at height h begins at the bit position (Y(s, h) = ao(h) + sh, (11) and ends at the bit position a ( s , h) + h -1. If the machine word length W 5 logN (usually true in practice), then we can get the code C ( n c a ( j 0 , j l ) ) of the node nca(j0,jl) in O(1) time by first computing Q(S, h ) and then extracting h bits, both of which take 0(1) time on a RAM machine. Note that in the variable-length encoding of the index heap the code value C(v) of the node U is the maximum position of the standard index range corresponding to v and this position is relative to the leftmost node of the subheap whose root is v. Thus the code value C(ncu(jO,j,)) can be converted to the maximum index j,,, in the in-order traversal of the index heap by jma, = ~( n c a ( j o , j l ) ) + nca(jo,jl) -2h + 1. (12)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>THEOREM 4</head><label>4</label><figDesc>, . . -, Z d ] . In dimension C j , we have &amp;&lt;k&lt;d,$.fi(2Nz,, -1) one-dimensional index heaps on ch-elements A [ z~, . * . , Zi-l,1, . . . , z d ] , 1, . . . , z d ] . All these one-dimensional index heaps can be encoded separately by strings of 0 ( 2 N 2 , ) bits, and their decoding take O( 1) time as we analyzed before. Now we reach the final conclusion. A [ z~, . * . , ~i -1 , 2 , . . ., z d ] , . . *, A[tl, * , ~i -1 , 2N2, -Range query for extrema in a ddimensional data volume of site N can be effected in 0(4d) time in the expected case, and in 0 ( 2 d log N ) time in the worst case, with an additional O(d2dN/ log N ) space on a RAM machine whose word length is no shorter than log N . The preprocessing time is O ( d 2 d N ) .</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A functional approach to data structures and its use in multidimensional searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chazelle</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">SIAM J. on Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shamos</surname></persName>
		</author>
		<title level="m">Computational Ge-427-463. ometry</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fast algorithms for finding nearest common ancestors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">N</forename><surname>Gabow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. on Computing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="338" to="355" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Partitioning space for range query</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">F</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. on Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="371" to="384" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
