<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Display of Scientific Data Structures for Algorithm Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W I L L I</forename><surname>Hibbardlk2</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Space Science and Engineering Center 2Department of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">R</forename><surname>Dyer2</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Space Science and Engineering Center 2Department of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Paul1</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Space Science and Engineering Center 2Department of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Display of Scientific Data Structures for Algorithm Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present a technique for dejining graphical depictions for all the data types dejined in an algorithm. lhe ability to display arbitrary combinations of an algorithm&apos;s data objects in a comnwn frame of refrence, coupled with interactive control of algorithm execution, provides a p o w 6 1 way to understand algorithm behavior. Type dejinitions are constrained so that all primitive values occurring in data objects are assigned scalar types. A graphical display, including user interaction with the display, is modeled by a special data type. Mappings from the scalar types into the display model type provide a simple user inteface for controlling how all data types are depicted, without the need for type-specijk graphics logic.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1: Introduction</head><p>Designing scientific algorithms is something of an art. For example, algorithms for extracting useful information from remotely sensed data are based on well understood mathematical and statistical techniques, but often combine these techniques in problem specific ways that can only be determined experimentally. Scientists can usually recognize incorrect results in graphical depictions of the output of their algorithms. To find the source of errors they need a way to apply this same visual understanding to the internal logic of their algorithms.</p><p>Interactive debugging systems allow scientists to step through program logic and to print the values of program variables and arrays, in order to track down low-level bugs. They need the same sort of interactive capability applied to diagnosing problems with high-level algorithm behavior. However, where low-level logic can be understood from a few printed values, high-level behavior involves masses of data that can only be understood through visualization. Thus there is a need for techniques for generating graphical depictions of the internal data objects of scientific algorithms. In order to be useful to scientists, the user interface for controlling these depictions should be simple and not require graphics expertise.</p><p>The data flow architecture <ref type="bibr" target="#b4">[3]</ref> is widely used for scientific visualization, with implementations including <ref type="bibr">AVS [9]</ref>, SGI Explorer, Khoros <ref type="bibr" target="#b8">[7]</ref> and apE <ref type="bibr" target="#b2">[2]</ref>. It provides a graphical user interface for specifying algorithms as networks of modules. The data flow architecture is popular because of the flexibility of mixing calculation modules with display modules, and because of its easy graphical user interface. However, data flow networks are not generally used for developing detailed algorithms. Current data flow implementations support finite sets of data structures; in order to support algorithm details they would need to support userdefinable, application-speci fic data structures.</p><p>The Balsa and Zeus systems [l] provide a set of tools for designing visualization environments for algorithms. Demonstration environments produced using Zeus provide very detailed and effective views of the internal workings of complex algorithm.</p><p>However, the environment must be custom designed for every algorithm.</p><p>The Powervision system <ref type="bibr" target="#b7">[6]</ref> uses an object-oriented language to support interactive development of image processing algorithms. The system includes a fixed set of display methods, defined in terms of a set of virtual functions for accessing data objects. As algorithm designers define new object classes, they must ensure that the virtual access functions extend to those classes, and may need to design new display methods for particularly novel classes. The Powervision system exploits object-oriented techniques to reduce the amount of program logic needed to display new object classes, but the system does not eliminate it.</p><p>In this paper we describe a technique, that we call the "scalar mapping technique", for generating graphical depictions of the internal data objects of scientific algorithms, without the need for type-specific display logic. We also describe an implementation of this technique in the VIS-AD (VISualization for Algorithm Development) system, an experimental laboratory for developing algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2: The scalar mapping technique</head><p>The scalar mapping technique defines an infinite set of data types that can serve as the types of data objects in a programming language. The data types are defined in such a manner that every primitive value occurring in a data object has one of a finite set of scalar types. The technique also models a graphical display, including user interaction with the display, as a special data type whose primitive values have one of a finite set of display scalar types. Mappings from the scalar types to the display scalar types provide a simple user interface for controlling how all data types are displayed, since the graphical depiction of a data object of any data type can be derived from the scalar mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.1: Data types</head><p>Define T as the set of types for the data objects in an algorithm. It is common for a programming language to define a set of primitive types (e.g. int, real), and to define a set of type constructors for building the types in T from the primitive types. We modify this by interposing a finite set S of scalar types between T and the primitive types. We define the primitive types as: </p><formula xml:id="formula_0">PRIM=</formula><formula xml:id="formula_1">S c T (fori = 1, ..., n.ti E T)* (t1 ,..</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>., tn)E T ( S E S h t E T)* (s+ t ) c T</head><p>where (c1 ,. . . ,tn) is a tuple type constructor with element types ti, and ( s + t) is an array type constructor with value type t and index type s.</p><p>Every primitive value, including an array index value, Occutring in a data object of type t E T , has a scalar type in S. This is the key to providing a simple user interface for controlling the display of all algorithm data objects. By defining mappings from the scalar types into a type model of a graphical display, the user can control the way that all data types are displayed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.2: Model of a graphical display as a data type</head><p>We model a graphical display by defining a special display data type. The contents of the display, including the way its contents change in response to user controls, form the value of a data object of type display. dimensional array of voxels is projected onto the twodimensional display screen, and the projection can be interactively rotated, panned and zoomed under user control. The scalar color has primitive type real3d and is the color value of a voxel. The scalars contour-i have primitive type real and are values attached voxels that are depicted by iso-value surfaces or iso-value lines drawn through voxels.</p><p>The scalar animation has primitive type int and is the index of an array of voxel volumes that can be rendered in sequence for animation, under user control. The scalars selector-i have any of the primitive types (real, reala, real3d, inf or siring) and are indices of display contents. The display contents change in response to user control of selector-i values, providing a way for the display type to model abstract user interactions with a graphical display.</p><p>The displuy type is defined by:  </p><formula xml:id="formula_2">voxel = (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.3: Display frame of reference</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DISPLAY(F,FD,t):D(t) + D(disp2ay)</head><p>is derived from F and FD, and produces data objects of the display type from data objects of any type t E T .</p><p>The functions F and I D provide a simple way for the user to control the DISPLAY function, and therefore to control the display of data objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3: The VIS-AD system</head><p>The scalar mapping technique is implemented in the MS-AD system <ref type="bibr" target="#b6">[5]</ref>, which has been used to demonstrate the effectiveness of the technique for supporting experiments with a variety of algorithms, including an algorithm for discriminating clouds in multi-spectral satellite images. The VIS-AD system also provides a simple syntax for defining types in T using the tuple and array type constructors. The keyword structure is used for the tuple constructor.</p><p>The . hist-location = earth-location;</p><p>.hist-histogram = histogram;</p><p>Data objects of type visir-image are two-dimensional images of temperature and brightness values, indexed by earth-location values. The cloud discrimination algorithm partitions images into regions, and a data object of type visir-set is an image with partitions indexed by image-region values. A data object of type visir-set-sequence is a time sequence of partitioned images. The wi-image and wi-set types are similar to the visir-image and visir-set types, with temperature, variance and brightness values at each image pixel. The var-image and var-set types are also similar to the visir-image and visir-set types, with only a variance value at each image pixel. A histogram data object attaches a frequency count to a set of temperature values, and a histogram-set object contains a histogram and an earth-location vaIue for each image-region value.</p><p>The VIS-AD system provides a simple syntax for specifying a display frame of reference.  Using this frame of reference, the lower-right window of <ref type="figure" target="#fig_4">Figure 1</ref> shows a top-south view of a data object of type visir-set-sequence. This data object is the input to the cloud discrimination algorithm. The text editor window on the left shows a section of the cloud discrimination algorithm coded in a language similar to (See mlor plates, p. CP-1 7.) C. A data object is selected for display by placing the cursor over any occurrence of its name in this window and clicking a mouse button. Any combination of data objects may be selected for display, and all occurrences of their names are highlighted in reverse video.</p><p>Execution breakpoints are set and cleared using the mouse in this window, and the next program statement to be executed is highlighted. The small text editor window at the top of the screen contains the display frame of reference. The widgets in the upper-right comer of the screen are used to control animation, to select ranges for scalars mapped to selector, to adjust color look-up tables for real scalars mapped to color, and to select iso-levels for scalars mapped to contour.</p><p>Since  percentiles of the histogram. The purple sphere indicates the value of a scalar object of type variance, calculated from the temperature percentiles. The blue-green object near the bottom has type var-set, and is calculated from another wzr-set object by setting those pixels whose variance is greater than the value depicted by the purple sphere to a special missing value; these missing pixels are invisible in the display. Only a single value of image-region is selected in <ref type="figure" target="#fig_6">Figure 2,</ref>     A second frame of reference example is: map temperature to x-axis; map brightness to z-axis; map variance to y-axis; map count to y-axis; map image-region to selector; map time to animation;</p><p>Since earth_location does not occur in these map statements, F(earth-location) = ni E and earth-location values are ignored in the display. Using this frame of reference, <ref type="figure" target="#fig_10">Figure 4</ref> shows an object of type wi-set as a three-dimensional scatter diagram. The view in <ref type="figure" target="#fig_10">Figure 4</ref> shows temperature along the horizontal axis and variance along the vertical axis, and is restricted to a single wi-image sub-object.</p><p>The mappings of temperature and time in the first frame of reference example can be edited to get: map earth-location to xzqlane; map temperature to selector; map brightness to color; map variance to y-axis; map time to y-axis; map count to x-axis; map image-region to selector;  The frame of reference can be edited again to get: map earth-location to xzqlane; map temperature to color; map brightness to color; map variance to y-axis; map time to animation; map count to x-axis; map image-region to selector; <ref type="figure" target="#fig_13">Figure 6</ref> shows the visir-set-sequence object from <ref type="figure" target="#fig_4">Figure 1</ref> in this frame of reference.</p><p>Since F(temperature) = color and F(brightness) = color, the color at each pixel is the average of the colors defined by the look-up tables for temperature and brightness. The color map widgets show red intensity proportional to temperature and blue-green intensity proportional to brightness. This way of looking at multi-spectral data is familiar to earth scientists. The essential feature of the VIS-AD system is its ability to generate displays of any combination of algorithm data objects, in a variety of frames of reference. Editing the algorithm, editing the frame of reference definitions, setting execution breakpoints, starting, stopping and single stepping algorithm execution, and displaying various combinations of data objects, can all be done highly interactively in an integrated environment. Data objects may be displayed in multiple frames of reference simultaneously. If a data object is enabled for display while the algorithm is executing, every time the object is modified it will be flagged for re-display. Thus VIS-AD can be used to produce animations of running algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4: Data semantics and data display</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.1: Data semantics</head><p>The DISPLAY function was defined in Section 2.3 as a function From the domain D(t) of data objects of a type t E T to the domain D(display), so we will describe these domains.</p><p>The domains of scalar types are determined from the domains of their primitive types, by Navigation (earth alignment) and calibration (radiance normalization) for satellite images can be implemented by appropriately defined subdomains of D(real2d) and D(reaZ), so that raw satellite images can be accessed directly in terms of latitude, longitude and temperature.</p><p>An expression like image[location] is evaluated by resampling the value of location to the nearest index value of the image array; the expression evaluates to missing if location is outside the range of index values of image. Furthermore, arithmetic expressions evaluate to missing if any operand is missing. Thus algorithms can combine data from multiple sources without the need for detailed logic for resampling, for checking data boundaries, and for checking for missing data.</p><p>Although VIS-AD implements simple resampling for access to arrays with real, real2d and real3d indices, it would be possible to implement one or more interpolation schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2: The DZSPLAY function</head><p>There are two equivalent formulations of the DISPLAY function. One formulation composes the DISPLAY function from a sequence of basic type transformations <ref type="bibr" target="#b5">[4]</ref>. The other is in terms of a tree structure defined for data objects, and is described here. where vi E D ( s i ) and where any spatial coordinate display scalar values among the FD(si)(vi) are factored into x-axis, y-axis and z-axis values in We).</p><p>The DISPLAY function is computed as: <ref type="figure">COMPOSI7E({DISP( W ( p ) ) ( p E PATH(0)</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DZSPLAY(F, FD, t)(o) =</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.3: Discussion of data display</head><p>Although the spatial Coordinate display scalar xyz-volume is factored into the one-and two-dimensional Cartesian factors x-axis, y-axis, z-axis, nyqlane, xzglane and yzglane, the generated displays need not conform to Cartesian coordinate systems. Twoand three-dimensional scalars may be mapped to spatial display scalars, and the FD functions for those scalars may include mathematical coordinate transformations into non-Cartesian coordinate systems. Similarly, threedimensional scalars may be mapped to the color display scalar, and the FD functions for those scalars may include mathematical color transformations into color systems other than RGB (Red, Green and Blue).</p><p>The scalar mappings provide a flexible tool for projection pursuit for data sets in many dimensions. Given a higher dimensional data set, the user can map different dimensions of the data set to three spatial coordinates, three color dimensions, animation, and a variable number of selector dimensions.</p><p>It is certainly possible for the user to define a display frame of reference that produces depictions that poorly communicate the information content of data objects. However, the interactivity of the system allows the user to experiment with the scalar mappings, in order to understand how the mappings work and to find effective object depictions.</p><p>Since interactive response times are important, the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIS-AD implementation of the DISPLAY function uses</head><p>shared-memory parallelism and is optimized for vectorization. It traverses paths in an object's tree structure in parallel. It divides the ranges of values of array indices into sections, and the paths through each section are traversed by a different processor. Also, the internal storage format for data objects has been designed to allow efficient vector processing of arrays of scalars and arrays of tuples of scalars. Running on an SGI 340 VGX, the DISPLAY function generated each of the figures in this paper in less than one second. This performance permits interactive visualization of data objects large enough for real scientific algorithms, and smooth animations of the behavior of some algorithms. Because of the nested arrays in the display type, a display data object may be very large. The VIS-AD implementation of the DISPLAY function minimizes this size by:</p><p>1. computing values for only those sub-objects of a display object that affect visible screen contents, and re-applying the DISPLAY function to data objects as animation and selector indices change. When data objects are transformed into dense sets of non-missing voxels it is impossible to see all the voxels, so VIS-AD provides a user-controlled clipping plane for creating a cut-away view of the display.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5: Plans for further development</head><p>We are generating a library of standard image analysis and remote sensing functions callable by VIS-AD programs. We are also adapting VIS-AD for distributed execution, enabling programs to call functions on remote computers.</p><p>We plan to extend the definition of the display type by including real display scalars for transparency and rejlectivity, and a real3d display scalar for vector, in the voxel tuple. Scalars mapped to these new display scalars would be depicted by complex volume rendering and flow rendering techniques.</p><p>We plan to extend the set T of data types by adding type constructors for lists, trees and other complex linked structures. We will extend the DISPLAY function to generate diagrams of linked structures, and to provide interaction mechanisms that allow the user to traverse linked structures. In order to do this, linked structures will probably be included in an extended definition of the display type.</p><p>We plan to extend the parallel algorithm for the DISPLAY function to a scalable algorithm running on large numbers of processors, in order to increase interactivity for large data objects.</p><p>We plan to adapt VIS-AD to generate graphical execution traces of algorithm data objects, and graphical depictions of the way that algorithm behavior varies with respect to varying algorithm parameters and varying input data sets. These functions are possible because of the flexibility to define arrays of any data type. The system can trace a data object during execution by deriving a new array type of values of the data object, indexed by a scalar for algorithm step number. The system will execute the algorithm and store the value of the selected object in the derived array at user-declared trace points. Similarly, algorithm behavior over an ensemble of invocations can be studied by deriving a new array type of values of a selected algorithm data object, indexed by a scalar for a parameter that varies between algorithm invocations (this may,be a string scalar for the name of an input data set that varies between invocations). The system would invoke the algorithm for each value of the parameter and save the final value of the selected object in the derived array. By mapping the index scalar of the derived array to a display scalar, the user will be able to generate flexible displays of an execution trace or of the way algorithm behavior varies over an ensemble of invocations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(int, string, real, real2d, real34 where real2d and real3d are pairs and triples of real numbers. An algorithm designer defines a finite set S of scalar types, and binds them to the primitive types by a function P : S + PRIM. An infinite set T of types can be defined from S by:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>The</head><label></label><figDesc>display type is defined in terms of a set DS of display scalars: DS= (x-axis, y-axis, z-axis, xyglune, xzglune, yzglane, qi-volume, color, contour-1 , . . . , contour-n, animation, selector-1 , . . . , selector-m) The scalar qi-wlume has primitive type red3d and is a three-dimensional voxel coordinate. The scalars x-&amp;, y-axis, z-axis, xyjlane, laqlune and yzqlune are real and real2d Cartesian factors of xyz-volume. The three-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Types in Tare defined in terms of the scalar types S, and the display type used to model a graphical display is defined in terms of the display scalar types DS. Mappings from S to DS create a frame of reference for generating graphical depictions of data objects with types in T. A displuy frame of reference is defined by functions: F:S+ DSU {nir) FD(s):D(s) + D(F(s)) for s E S where D(t) is the set of data objects a type t. If F(s)=niZ then FD(s) is undefined and the values of s are ignored in the display. The function FD determines how display scalar values are computed from scalar values. The function:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>The</head><label></label><figDesc>VIS-AD system provides a simple syntax for defining the set S of scalar types and the function P: S --f PRIM. The following are examples of scalar types defined for the cloud discrimination algorithm: type brightness = real; type temperature = real; type variance = real; type earth-location = real2d; type image-region = int; type time = real; type count = int; Here brightness and temperature are the visible and infrared radiance values of pixels in satellite images, variance is derived from temperature, earth-location is a pair of values for the latitude and longitude of pixel locations, image-region is an index into rectangular subimages, time is an index for image sequences, and count is used for histograms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Cloud discrimination algorithm input.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>F(time)=animation in the frame of reference example, only a single visir-set sub-object is displayed in Figure 1. Toggling the ANIMATE widget causes the display to sequence through the object's visir-set subobjects. Since F(image-region)=selector, two slider widgets in the upper-right comer are used to select a range of values for image-region; all visit-image subobjects are selected in Figure 1. Since F(brightness)= coZor, the pixel colors are functions of their brightness values, according to the color widget in the upper-right comer of the screen. Since F(earth-location) = z y l a n e , the pixels are laid out horizontally. Since F(temperature)=y-axis, the. zemperahrre values of pixels determine their height in the display. The object depiction may be interactively rotated, zoomed and translated in 3-D with simple mouse controls.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 2 :</head><label>2</label><figDesc>A step in discriminating clouds.Objects are depicted in monochrome when no object component is mapped to color.When several monochrome objects are displayed simultaneously, each object has a different color.Figure 2shows a southwest view of five monochrome data objects. The tall white graph is an object of type histogram-set. The small blue and yellow spheres indicate the values of scalar objects of type temperature, calculated by the cloud discrimination algorithm as the 10th and 90th</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>so the depictions of the histogram-set and var-set objects are restricted to single histogram and wzr-image sub-objects.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 :</head><label>3</label><figDesc>The discriminated clouds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 3</head><label>3</label><figDesc>shows an object of type visir-set-sequence that is the output of the cloud discrimination algorithm. It is identical to the object inFigure 1, except that the values of pixels judged by the algorithm not to be in clouds have been set to the missing value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 4 :</head><label>4</label><figDesc>A 3-D scatter diagram of an image.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 5</head><label>5</label><figDesc>shows the visir-set-sequence object from Figure 1 in this frame of reference. Since F(temperature) =selector, two slider widgets in the upper-right comer of the screen are used to select a range of values for temperature, and the display is restricted to those pixels whose temperature values are within the selected range. Since F(time)=y-axis, the object's four visir-set sub-objects are stacked along the y-axis, showing the motion of cloud features.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 5 :</head><label>5</label><figDesc>A time sequence image object.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 6 :</head><label>6</label><figDesc>Looking at multiple spectra with color.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>(</head><label></label><figDesc>See wlorplates, p. CP-17.)D(s)=D(P(s)).The domain of the primitive type int is the union of a set of finite sub-domains, each an interval of integers, as follows:D(intij ) = {k (i 5 k 5 j } D(int) = {missing} U ui D(int. . ) 1.Jwhere i, j and k are integers and the missing value indicates the lack of information (the use of special "missing data" codes is common in remote sensing algorithms). The domain of the primitive type real is the union of a set of finite sub-domains, each a set of half-open intervals, as follows:D(rea1 ) = { [ f ( k / 2 " ) , f ( ( k + 1) / 2"))Ii s k s j } f,i,j, n where i,j, k and n are integers and Fld is a set of increasing continuous bijections from R (the set of real numbers) to R; the functions in Fld provide nonuniform sampling of real values. The domains D(reulW, D(real3d) and D(string) are similarly defined as the unions of finite sub-domains. D ( ( s + t ) ) is defined as the union of a set of function spaces, rather than as the single space of functions from D(s) to D(t), as follows: where subs ranges over the finite subdomains of the scalar domain D(s), and (D(ssubs) + D(t)) denotes the set of all functions from the set D(ssubs) to the set D(t). Every array object in D((s --f t)) contains a finite set of values from D(t), indexed by values from one of the finite subdomains of D(s). The domains of tuple types are defined by: D((t, ,..., f , ) ) = {missing}~ D(t,)x ... xD(tn) Each domain D(t) has a lattice structure [8], with the missing value as its least element. The half-open intervals in D(real) are approximations to values in R and are ordered by the inverse of set inclusion; that is, in the lattice structure, an interval is "less" than its subintervals. Values in D(real2d) and D(reuZ34 form similar lattices and are approximations to values in R2 and R3. The lattice structure can be extended to array and tuple types. The lattice structure of domains, and the definition of array domains as unions of function spaces, provide a formal basis for interpreting array data objects whose indices have primitive types real, red2d or real3d as finite samplings of functions over R, R2 or R3. For example, a satellite image is a finite sampling of a continuous radiance field. The VIS-AD programming language allows arrays to be indexed by real, real2d and reul3d values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>2 .</head><label>2</label><figDesc>The tree structure m(o) for objects o is defined recursively as follows: 1. If o is an array containing value objects oi, i= 1,. . . ,n, with corresponding scalar index values vi, then TR(o) is a branch node with sub-nodes TR(oi), and the value vi is attached to TR(oi). If o has the missing value, then TR(o) is a leaf node and the missing value is attached to nZ(o). If o is a tuple containing scalar element objects vi, i= 1 ,..., m, and non-scalar element objects oi, i = l , ..., n, then TR(o) is a branch node with subnodes m(oi), and all the values vi are attached to each 7??(oi). If n=O (0 has only scalar elements) then TR(o) is a leaf node, and the values vi are attached to that node. If o has the missing value, then m(o) is a leaf node and the missing value is attached to m(o).3. If o is a scalar not occurring as a tuple element, then nZ(o) is a leaf node and the value of o is attached to TR(o). Define PATH(o) as the set of paths in m(o) from the root node to any leaf node. For any p E P A W ( 0 ) define V(p)=vlv2 ... vn as the string of scalar values attached to nodes along the path p. Then a string of display scalar values is calculated from V(p) as: VD@)=FD(sl)(vl)* *FD(sJ(Vn)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>)) where DZSP(W@)) is a display object computed from the string of display scalar values W@), and the COMPOSZ7E function computes a single object in D(disp1ay) from a set of such objects. If the leaf node of the path p is generated from an object with the missing value, then DZSP(W@)) =missing. Otherwise the DZSP function is computed as follows. Given a string W@), for each s E DS define N, as the number of values of type s that occur in W@). Compute a voxel object vox= (wcolor, Wconrour-I 9 * * * 7 wconrour-n) as follows: if Ncolor=O and for i = l , ..., n. Nconrour i=O then vox= (SPECL4L.colo, , missing, . . . ,-missing) else for s= color, contour-I, . . . , contour-n if N,=O then w,=missing else ws=(uI +... +uN)/NS where SPECIALcolo, is the monochrome color value described in Section 3, and the ui are the values of type s occumng in W@). For s=x-axis, y-axis and z-axis, compute w, as follows: if N,=O then w,=SPECZAL, else w,=ul+ ...+ uN where SPECIAL., is the spatial coordinate of a distinguished plane perpendicular to the s axis, and the U; are the values of type s occurring in W@). s=animation and selector-i, compute w, as follows: For If N,=O then w,=D(s) else wS=uN where w,=D(s) indicates that all values in D(s) are used for w,, and uN is the value of type s occurring farthest from the root in I D @ ) . Now the display object d=DZSP(W(p)) is computed as follows: d[wselecror-ll. . . [wse~cror_ml[~animntion] [wx -,uchl[wy-,uc,l[wza r j . s l =vox If w,=D(s) was selected for s=animation or selector-i, then the equation above applies for all values of w, in D(s). All other voxel sub-objects of d are set to missing. Thus, if the string W@) contains exactly one value for each display scalar, then the color and contour-i values of W@) are set in a single non-missing voxel sub-object of DISP(W@)), indexed by the spatial, animation and selector-i values of W@). However, undefined and multiply-defined display scalar values are more complex, and the DZSP function handles them in a way that varies between display scalars. If the value of a spatial coordinate is undefined in We), the depiction of p is embedded in a distinguished plane. However, if the value of s=animation or selector-i is undefined in W@), sets of voxel sub-objects in DZSP(W@)) are set to vox so that the depiction of p is invariant to user control of s. Multiply-defined color and contour-i values are composited by taking their mean, but multiply-defined spatial coordinates are combined by taking their sum, so that, for example, the histogram in Figure 2 is positioned over the appropriate image region. The COMPOSITE function computes an object in D(dispZay) from a set of such objects. This computation is done independently for each voxel sub-object (i.e. for each combination of selector-i, animation and spatial values indexing a voxel sub-object). The color value of a voxel is computed as the mean of the non-missing color values of the corresponding voxel sub-objects of the set of objects, and similarly for contour-i values. The COMPOSZlE function is also used to combine depictions of multiple objects into a single display.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>2 .</head><label>2</label><figDesc>Splitting the display type into two arrays, one for contour values and the other for color values. 3. Limiting the sampling resolution of xyz-volume for the array of contour values. 4. Using sparse representations for the array of color values; texture maps are used for voxels lying on the distinguished 2-D planes determined by the values SPECLQL, SPECMY-,, and S P E C M Z and lists i f non-missing voxels are used outside of the distinguished planes.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>Wilson for their support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">and Gregory This work was funded by NASNMSFC (NAG8-828) and NSF (IRI-9022608)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A system for algorithm animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sedgewick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="177" to="186" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A dataflow toolkit for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="60" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ConMan: A visual programming language for interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haeberli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Automated display of geometric data types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dyer</surname></persName>
		</author>
		<idno>#1015</idno>
		<imprint>
			<date type="published" when="1991" />
			<publisher>UW Computer Sciences</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A development environment for data analysis algorithms. Preprints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Paul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. Interactive Information and Processing Systems for Meteorology, Oceanography, and Hydrology</title>
		<imprint>
			<publisher>American Meteorology Society</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="101" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcconnell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lawton</surname></persName>
		</author>
		<title level="m">IU software environments; Proc. IUW</title>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="666" to="677" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A visual language and software development environment for image processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Argiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International J. of Imaging Systems and Technology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="183" to="199" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Schmidt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<publisher>Denotational Semantics. Wm. C. Brown Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The application visualization system: a computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="103" to="104" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
