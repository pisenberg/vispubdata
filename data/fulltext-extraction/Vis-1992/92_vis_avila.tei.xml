<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards a Comprehensive Volume Visualization System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ricardo</forename><forename type="middle">S</forename><surname>Ada</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lisa</forename><forename type="middle">M</forename><surname>Sobierajski'</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><forename type="middle">E</forename><surname>Kaufman'</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Towards a Comprehensive Volume Visualization System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The VolVis system has been developed to satisfv the diverse requirements of the volume visualization community by co@ortably housing numerous visualization algorithms and methods within a consistent and well organized framavork. The VoNis system is supported by a generalized abstract model which provides for both geometric and volumetric constructs. VolVis contains several rendering algorithms that span the speed versus accuracy continuum. A fmt volume rendering algorithm has been dcveloped, which is capable of exploiting existing graphics hardware without placing any viewing restrictwns or compromising accuracy. In addition, VoNis includes a volumetn&apos;c navigm&apos;on facility, key-pame animation generator, quantitative analysis tools, and a generalized protocol for commm&apos;cating with 30 input devices.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Volume visualization is quickly becoming an integral part of many scientific fields [4]. Visualization techniques am used in areas as diverse as aiding physicians in surgical and radiation rreament planning [23, helping meteorologists understand weather patterns 133, and assisting geologists in identifying potential oil reservoirs <ref type="bibr">[13]</ref>. The software used by the geologist would not help a meteorologist predict the weather, and would be useless for surgical planning. In the past, new visualization systems have been developed for each visualization application. In each system, assumptions are made about the type of data, the rendering algorithm, or the input device employed, creating a software package with limited applications.</p><p>A few visualization systems have been developed which achieve some degree of independence. For example, a procedural interface was <ref type="bibr">developed [7]</ref> which provides a library of C routines for data visualization. This is useful as a basis on which a computer scientist can build a new visualization application, but is not useful to a scientist or an engineer without C programming experience. A more complete system, ANALYZE [a], was developed which provides the scientist with a rich set of tools for the abstract model for the system environment, which defines world, volume, and light some properties. Algorithms are then developed for data manipulation, navigation, quantitative analysis, and rendering in this environment These algorithms rely only on the abstract model, and are independent of machine types, windowing systems, and input devices. Finally, the user interface, and any devicedependent routines (e.g., for rendering geometric primitives) arelincorporated into the system. The abstract model and functionality of the VolVis system are further described in Sections 2 and 3. Another goal of the VolVis system is to provide the user with several rendering algorithms spanning the speed versus accuracy continuum. At one extreme is the low-accuracy rendering algorithm employed by the navigator. At the other end is a volumetric ray tracer (e.g., <ref type="bibr">[14,</ref><ref type="bibr">161)</ref>. which provides realistic images at a relatively high cost, By placing restrictions on the viewing parameters, a templatebased ray caster [151 can be employed which produces more accurate images than the navigator at lower rendering times than the volumetric ray tracer.</p><p>Many algorithms for d a c e projections of volumetric data currently exist. One method is to approximate the surface with a polygon mesh 161, then utilize standard graphics hardware. for projection. To produce accurate images of complex surfaces with this method typically requires more polygons than can be projected interactively on even a highend graphics workstation. Another method for surface projection from volume data is described by Levoy 151. This method produces accurate images, but has a high rendering time. Other visualization methods exist for rendering complex surfaces 11, 10, 121, but none of these methods allow arbitrary viewing parameters while maintaining interactive rates.</p><p>The VolVis system contains a new volume rendering algorithm far complex objects, called Polygon Assisted Ray Casting, or PARC, which can accurately project complex surfaces at interactive rates. This algorithm provides for accurate rendering at interactive rates by exploiting the hardware of existing graphics workstations. The PARC algorithm is described in detail in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Abstract model</head><p>The VolVis system is designed to meet several key objectives. One important objective is to be independent of the window system, input device, algorithm, and data. Another important objective is flexibility, thereby insuring that a new concept or algorithm can be incorporated without constraining existing or future algorithms. To achieve these goals, an expandable abstract model for volume visualization was developed.</p><p>The first step in creating the abstract model is to define some basic building blocks. A Position defines a point p e R 3 , while a Vector defines 3D orientation or direction. A Matrix is a 4x4 array of floating point values which represents a transformation in a three dimensional homogeneous coordinate system. A Plane is a plane equation defining an infinite plane in R3, and a Color is a (red,greenblue) triple corresponding to a 24-bit color. Built upon these basic building blocks are some higher level constructs such as a Coordsys, which is a Position indicating the origin, and three Vectors representing the x, y , and z axes of a cartesian coordinate system in R~.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Some of the basic building blocks in the VolVis</head><p>abstract model can assume one of multiple representations. For example, a Segmentation can be a simple threshold, a binary segmentation function, or a transfer function defining opacity based on scalar value and gradient. Likewise, a LocalShade defines a shading model for a volume which can contain constant coefficients, or complex transfer functions defining shading coefficients based on scalar value, gradient, data color, or texture color. A DataColor can define a single color for the volume, or a transfer function mapping scalar value and gradient to color. A Texture may contain a 2D texture, a 3D solid texture, or a function which is used to generate the texture values. A DataCut contains a cut geometry which is to be applied to a volume. For example, a DataCut may be a plane, a hexahedron, or a sphere. The VolumeData can be either geometric, scalar data, or vector data, and a LightSource can be a point light source, a directional light source, a geometric light source or a volumetric light source. These basic abstract model building blocks are illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>.  One of the major advantages of this abstract model is the ease with which VoZumes can be manipulated.  Figures 3-5 illustrate the differences between the template-based algorithm, PARC, and the volumetric ray tracer. <ref type="figure" target="#fig_2">Figure 3</ref> shows an MRI head rendered using the templatebased projection algorithm. As required by the algorithm, a parallel projection was performed from a View located outside of the volume. In contrast, <ref type="figure" target="#fig_3">Figure  4</ref> shows several images of the same head rendered with PARC. The images illustrate the PARC algorithm's ability to handle an arbitrary View and cut geometries. Finally, <ref type="figure" target="#fig_4">Figure 5</ref> shows the same MRI head, however this time rendered with the VolVis ray tracer. This figure illustrates the ray tracer's ability to handle both volumetric and geometric objects within a global illumination model. The Navigation component is an interactive volumetric navigation aid which allows the user to specify complex flight paths through volumemc data sets as well as directly manipulate all objects defined within the World. The user navigates through data sets much like a flight simulator in which movement can take place with respect to the View coordinate system. The navigator is controlled thfough either the navigation window or the 3D input device specified in the Input Devices component. Interactive projection rates are achieved by utilizing a quick projection algorithm which operates on a reduced representation of the Volumes. The user may change the level of detail displayed by the navigator to suit the operation being performed.  The Image Control component facilitates the manipulation of images generated within the VolVis <ref type="figure" target="#fig_1">(See wlor plates, p. CP-2.)</ref> I system. One can create complex animations within the VoNis system through the use of the Animation component The Animator is a key-frame animation system in which animations are specified by a series of key-frames or states of the system and the number of steps to u'eate between each state. The navigator is generally used to position Volumes, Lights, and the View, and the animator is used to store each key-frame. Once all key-frames have been specified, the animator then interpolates between the key-frames to produce an</p><p>The Quantitative Analysis component of VoNis extracts quantitative measurements from volumetric data. Measurement capabilities include 2D and 3D distance, histogram, surface area, and volume measurements. These measurements are performed either on an entire volume or on a subregion selected within the Navigator component.</p><p>The Input Devices component allows the user to choose the type of input device currently in use within the VoNis system. The user may choose between a standard mouse, a flying mouse, buttons and dials, an Isotrak, a SpxdmU, or even a DataGlove. This component is also responsible for initializing the device and any other prrrameters associated with its operation. animation sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PARCpolygon &amp;sisted ray casting</head><p>In an effort to attain interactive projection rates, the VoZVis system utilizes the PARC algorithm. PARC is a ray casting algorithm capable of computing a fast and accurate surface projection without placing restrictions on the Projection type, and the position, orientation or size of the viewing window.</p><p>The original volumetric data <ref type="figure">V(x,,y,s,)</ref> is The algorithm casts rays through the scalar field S from each pixel of the viewing window. <ref type="figure">Figure Ha)</ref> shows the rays as they traveme S and i n t e w t with an object So. Each ray begins from a position on the viewing window and a sample p is performed at regular intervals along the ray until Q <ref type="figure">( I ( V , p )</ref> ) = 1, indicating that the ray has entered the object So. The color of the pixel is then computed by applying a shading function at point p. Although the basic approach does not place any restrictions on the viewing window, rendering times are high due to the large number of samples perfunned within S. The cost of performing these samples can be quite high given the expense of the interpolation function I. Secondly, an increase in accuracy is accomplished by reducing the distance between sample points, thereby causing a proportional increase in rendering times.</p><p>This algorithm can be improved dramatically by reducing the number of samples required during projection. Let's assume that prior to ray casting we h o w whether a ray originating at some pixel in the View intersects SO, and if so, the distance along the ray at which the closest intersection occurs. Given this information we need not cast rays which do not intersect So. Additionally, for those rays which do intersect SO, we can effectively skip over all the samples along the ray to the intersection. If we combine casting rays only at viable pixels with sampling S only on the projected surface of the object, the number of samples required during projection is equal to the number of viable pixels in the View.</p><p>Although obtaining the viable pixel and intemxtion distance information prior to projection appears too costly for consideration, this information can be approximated quickly through the use of polygon projection into two z-buffers. The object So must first be approximated with a set of polygons that completely contain i t We have chosen to represent the polygons as the faces of a set of subvolumes P within S which contain a surface of SO. P is determined by first ' subdividing each axis of S into 2' equal distance regions where 1 is the subdivision level. A scalar field S subdivided with level 1 then contains Z3' subvolumes. Every subvolume that contains a boundary between So and S , according to Q is then placed in the set P.</p><p>Once the set of subvolumes P has been calculated, the six faces of each subvolume in P are then projected into two z-buffers. The three front facing polygons of each subvolume are projected into the near z-buffer Z,, while the three back facing polygons are projected into the far z-buffer 2 , . The near z-buffer Z,, now contains a distance value for every viable pixel in the View and a flag for a pixel that cannot send a ray which intersects So. Due to the polygonal approximation, rays sent from viable pixels do not necessarily intersect So. However, the higher the subdivision level I, the p a t e r the likelihood that a viable pixel spawns a ray that actually intersects SO. The far z-buffer Zf contains the farthest distance from a pixel to an intersection with SO.</p><p>Therefore, a ray from a viable pixel need only step a distance of Z,-Z,, starting at a distance of Z,, along the ray. Provided that graphics hardware is available, projection of the set P can be performed quickly since shading of the subvolumes is not necessary. <ref type="figure" target="#fig_6">Figure 6@)</ref> shows the approximation of the object and the substantial reduction in the number of samples performed along the rays.</p><p>The algorithm thus far does not take into account multiple Volumes and the possibility that the View may intersect with subvolumes in P. To handle multiple Volumes, we compute a Z,, and a 2, for each Volume then step along each ray from the closest distance in all Z,, buffers to the farthest distance in all Z, buffers. At each step along the ray we use the information within the z-buffers to determine which Volumes to sample.</p><p>To handle a View intersecting subvolumes in P, we project first the back facing polygons of each subvolume into Z,, with a color CDmk then the front facing polygons into Z,, with a color CF,~,,~. Should the zbuffer Z,, contain the color c S &amp; , the ray must begin sampling at the pixel position on the View.</p><p>The performance of this algorithm now rests on the subdivision level 1 chosen. When 1 is large, the high number of polygons causes a large polygon projection time but a small ray casting time since the polygons closely approximate the surface of So. When 1 is small, the low number of polygons causes a low polygon projection time but a large ray casting time since the surface of So is only coursely approximated. The challenge then is to choose the appropriate subdivision level 1 which minimizes the total projection time. Unfortunately, the optimal subdivision level 1 is dependent on the floating point speed of the machine, the polygon projection time of the machine, and even the characteristics of the object So within S. In general, the PARC algorithm total time TpMc is: TPMC = Tpob + T R~ + Tfier where Tp0b is the polygon projection m e , T R~ is the ray stepping time, and Toycr is the projection overhead time.</p><p>The rendering of an object So requires the selection of the appropriate subdivision level 1. This entails the analysis of the functions Tpob. T R~, and T,,, for the object So as a function of 1. In general, as 1 increases, Tpob grows exponentially depending on the surface characteristics of So and the polygon projection rate of the machine. In contrast, as 1 increases, TRq decreases exponentially depending on the surface characteristics of So and the floating point speed of the machine. The TOYLr function, which includes looping through the View pixels and shading at ray-object intersections, remains relatively constant.</p><p>The strength of this approach is that PARC can adapt to different machine abilities to provide the best possible PARC rendering time. For instance, a machine with exceptional floating point performance but satisfactory polygon projection performance is likely to cause PARC to use a relatively low subdivision level 1 in an effort to obtain the lowest possible PARC rendering time. The computation of Tpob, T R~, TO,,*, and T p~c can be performed as a preprocessing step and stored for later rendering sessions on a specific machine. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PARC results</head><p>We have performed the analysis of Tpob, TR?, ToVC, and TpMc on two structurally different volumetric data sets using a single processor and the geometry engine of a Silicon Graphics 240GTX. An MRI scan of a human head and a confocal microscope scan of a rat hippocampal pyramidal neuron were reconstructed to a voxel resolution of 256x256~166 and 256x256~163, respectively. The MRI head is representative of a fairly solid, well connected, almost spherical structure while <ref type="figure" target="#fig_1">(See colorplates, p. CP-2.)</ref> the hippocampal pyramidal neuron is a representative of a sparse, disconnected branch-like structure. The data sets were projected onto a View with a resolution of 256x256 pixels. The View was rotated 12 times about the y axis with 30 degree angular displacements yielding the functions Tpob, TRq, TOW, and TPMC for an average image. <ref type="figure" target="#fig_7">Figure 7</ref> shows a view of the MRI head and the corresponding view of the hiDDocamDal pyramidal ne&amp; whiih were computed d&amp;ng analysis. The functions for both the h4RI head and the hippocampal pyramidal neuron are shown in <ref type="figure" target="#fig_8">Figures 8  and 9,</ref> respectively. Both the MRI head and the hippocampal pyramidal neuron exhibit a substantial decrease in ray stepping time as the subdivision level 1 increases. However, the polygon projection time of the MRI head begins to grow quickly when I &gt; 6, while the polygon projection time of the hippocampal pyramidal cell shows a gradual increase when I &gt; 7. The total projection time TPm indicates that the MRI head should be subdivided at I = 6 resulting in an average PARC projection time of 6.139 seconds. However, the hippocampal pyramidal neuron obtains an optimal projection time TpMc of 3.004 seconds at 1 = 7. The brute-force rendering time is roughly equivalent to PARC level 0 projection. Comparing PARC level 0 and the optimal levels for the h4RI head and the hippocampal pyramidal neuron shows that PARC, at the optimal level, achieves a 13.9 and a 42.7 speedup, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Implementation and future directions</head><p>VoNis is currently running under X/Motif on HP and Silicon Graphics platforms, and under WOpenwindows on the Sun platfom, taking advantage of the graphics hardware as is available on the HP 400S, SGI 24OGTX, and the Sun SPARCstation 2 GS.</p><p>Interactive control of VoNis is accomplished through either a standard mouse, buttons and dials, a Spaceball, or a VPL DataGlove.  <ref type="figure" target="#fig_0">Figure 10</ref> shows four images created with the PARC algorithm which are part of an animation of a flight through a hippocampal pyramidal neuron. The VoIVis ray tracer was used to render the C T lobster data shown in figure 11. Two blue mirrors were placed in the <ref type="figure" target="#fig_1">(See wlor plates, p. CP-2.)</ref> scene to reflect hidden parts of the lobster.</p><p>The VolVis system is currently being expanded to work in higher dimensions. This includes rendering and analyzing higher dimensional data, as well as navigation in higher dimensions. Additionally, the abstract model is being extended to incorporate irregular grids. The VoNis system is also being ported to other platforms.</p><p>Improvements on the PARC algorithm are also planned. Methods for reducing the number of projected polygons and an adaptive subdivision level are being investigated. The PARC algorithm is also being extended to handle rendering with transparency and more complex segmentation techniques. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Acknowledgments</head><p>This project has been supported in part by a grant from the Center for Biotechnology. SUNY at Stony</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>The basic building blocks of the abstract model.The three top-level components of the VolVis abstract model are the Image, the View, and the World. An Image is simply an object which contains a width and height (in pixels), a depth (in bytes), and raw pixel values. A View is an object which defines the current specification of the view plane. This is done by storing an original CoordSys, a current Coordsys, and a Matrix defining a transformation between the two. The x and y axes of the current Coordsys lie on the view plane, while the z axis defines the general viewing direction.Also stored in the View are the field of view, and the width and height of the View in both pixels and units, where a unit is considered to be a distance of 1.0 in theWorld coordinate system. When a projection is performed, an Image is associated with the View. The World contains all Volumes and Lights, as well as the Worldshude shading model which includes global information such as ambient light and background color. The CoordSys for the World is a standard left-handed Cartesian coordinate system. All other coordinate systems defined in the abstract model are relative to this standard coordinate system. The World may contain multiple DataCuts defining cut geometries which are to be applied to all Volumes. Multiple Lights are defined within the World, where each Light contains a LightSource. Multiple Volumes are also supported, with each Volume containing an original CoordSys, a current CoordSys, and a transformation Matrix, similar to the View. Also contained in the Volume are the Plane equations defining the faces of the bounding hexahedron of the Volume, as well as the x. y , and z resolution of this I hexahedron in both voxels and units. The resolution in voxels indicates the number of sample points in the volume data, while the resolution in units specifies the size of the object in World space. Each Volume contains a unit type, which indicates what one unit in this volume represents. For example, one unit in a volume may represent a micron, an inch, or a kilometer. This information is used during measurement, and is also used to convert multiple volumes into a common unit type, thereby showing the relative sizes of these volumes. In order to facilitate transformations between the World coordinate system and the Volume coordinate system, four conversion Matrices are stored within each Volume. These Matrices are used to transform a Position or a Vector from the World ~OoTdi~te system to the Volwne coordinate system (and vice-versa) in both units and voxels. A Volume may contain multiple DataCuts which are applied to the data in addition to the ones specified in the World. Each Volume also contains a LocalShade, a DataColor, a Texrwe, and the actual VolumeData. If the VolumeData is scalar data, it contains a Segmentation, and the actual sampled data. If the VolumeData is geometric data, it contains a geometric object description. A representation of a Volume built from the icons of Figure 1 is shown in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Iconic representation of a Volume inVolVis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>A VolVi template-based projection of an MRI scanned head.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Various VolVis PARC projections of an MRI scanned head.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>A VolVis ray traced projection of an MRI scanned head and a sphere.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>a rectilinear array of scalar values. The scalar value s of a point p lo~ated at ( X~~, , Z~) E R~ can be approximated with an interpolation function Z(V, p). 'Ihe interpolation function I should be piecewise polynomial such as trilinear or tricubic interpolation. The volumetric data V combined with the interpolation function I define the scalar field S c R3. An object So in the scalar field S is defined by a segmentation function Q. The segmentation function Q partitions S into two sets, either object So or background S , , such that Q ( s ) evaluates tolifs E So,andQ(s)evaluatestoOifs E SB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>(a) A 2D illustration of brute-force ray casting. (b) A 2D illustration of the PARC algorithm, with 2, shown as a dashed polyline, and Zf shown as a solid polyline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>The MRI head and confocal cell images computed while determining the subdivision level 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>A plot of TpMc, Tpob, TRq, and To, as a function of subdivision level I when rendering the neuron. Inset: A magnified view of the plot.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Four frames from a PARC animation depicting a flight through the confocal neuron data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>A VolVi ray traced projection of a CT scanned lobster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Howard Hughes Medical Institute State University of New York at Stony Brook Stony Brook, NY 11794-5230 manipulation. analysis, and display of 3D and 4D biomedical data. Interaction in ANALYZE is achieved through keyboard and mouse input, which does not always provide an intuitive method for performing three-dimensional data manipulation and analysis. Another commercial system is VoxelView of Vital Images [9, 113; however, VoxelView is running only on the Silicon Graphics graphics engine and cannot be used on other platforms.In this papex we present the VolVis system, a</figDesc><table /><note>*comprehensive volume visualization system. One goal of the VolVis system is t o create a powerful volume visualization environment, while avoiding any windowing, input device, algorithm or data dependencies. This is achieved by first creating an</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Translations and rotations are performed by simply concatenating the new transformation matrix to the one stored in the Volume, thereby defining a new current CoordSys, new Plane equations, and new conversion Matrices. Unlike many other systems that require data interpolation to be performed during the data input/hxonstruction phase, the VolVis abstract model allows for arbitrary scaling of the data with no additional memory expense. This is accomplished by modifying the x, y, and z size in units of the data, which results in modified Plane equations and conversion Matrices. advantage of the VolVis abstract model is its expandability. The model is designed so that, for example, the addition of a new Texture type, Segmentation type, or geometric object requires a minimal amount of work, and does not compromise the flexibility of the model. Incorporating a new projection algorithm or measurement tool is also made simple by this model. The number and types of properties vary &amp;pending on the object in question. For example, some of the more relevant properties of a Volume are position and orientation, segmentation, color, texture, local shading model, cut geometries, and flags indicating whether However, some properties may be modified utilizing more interactive methods within the Navigation component.TheRendering component of VoNis is perhaps the most powerful component within the system. The user may select from a variety of rendering algorithms, each having its own unique set of advantages and disadvantages. Generally speaking, these algorithms span the continuum between fast and inaccurate to slow and accurate. The Rendering component includes a template-based ray casting algorithm for quick discrete parallel projections [151. Despite the speed of the algorithm, it unfortunately can not perform perspective projections and is also unable to handle a generalized viewing window. The PARC algorithm can perform parallel and perspxtive projections as well as handle a</figDesc><table><row><cell></cell><cell>Another 3. System functionality</cell></row><row><cell>fully generalized viewing window. This algorithm provides highly accurate pmjeztions with relatively fast projection times. The PARC algorithm is discussed in more detail in Section 4. Finally, a powerful volumemc ray tracer is included within the Rendering component to provide high quality projections using a global illumination model, similar to 114, 161. This is</cell><cell>The VolVis system contains several primary components which are intended to meet the variouS needs of volume visualization users. These include file input and output, filters, object control, image control, rendering, navigation, animation, quantitative analysis, and input devices. Each of these components is described below.</cell></row></table><note>The File U 0 component handles all input and output within the VolVis system. This includes the ability to save and retrieve several volumetric data filetypes, geometric data aes, multi-dimensional texture files, %-bit image and animation files, world environment files, and interaction log files. It is often desireble to apply a filter to a volumetric data set during or after input in order to enhance features, smooth data, or reduce noise. For this purpose several standard filters are provided within the Filters component of the VolVis system. Every object within the VolVis system contains properties which can be modified within the Object Control component. The VolVis system contains several basic object types including World, View, Volume, and Light.this object is currently visible andlor modifiable. Modifiability allows the user to apply transformations to several Volumes and Lights simultaneously in order to perform complex object manipulations easily. Visibility simply determines whether a Volume is visible or a Light is active. The global properties stored within the World such as ambient lighting, light attenuation factor, background color, and global cut geometries may also be modified in this component. 'Ihe Object Control component provides a window based method for modifying these properties.particularly useful when global effects such as shadows and reflections can provide more clues about the structure of the data.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0" />
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Display of 3D Digital Images: Computational Foundations and Medical Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">T</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Udupa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and AppIications</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="39" to="46" />
			<date type="published" when="1983-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visualizing Large Data Sets in the Earth Sciences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Santek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">Visualization</biblScope>
			<date type="published" when="1990" />
			<publisher>IEEE Computer Society Press Tutorial</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Montine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;90</title>
		<meeting>Visualization &apos;90<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page">364</biblScope>
		</imprint>
	</monogr>
	<note>A Procedural Interface for Volume Rendering</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Software System for Interactive and Quantitative Analysis of Biomedical Images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Robb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30 Imaging in Medicine</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Volume Microscopy of Biological Specimens Based on Non-Confocal Imaging Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">L</forename><surname>Senft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Argiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">L</forename><surname>Van Zandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;90</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-10" />
			<biblScope unit="page" from="424" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">V-BUFFER: Visible Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="59" to="64" />
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Van Zandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Argiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A New &apos;Inlook&apos; on Life</title>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="52" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interactive Visualization of 3D Seismic Data: A Volumetric Method&apos; *</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="middle">R H</forename><surname>Wolfe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">N</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="24" to="30" />
			<date type="published" when="1988-07" />
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Realistic Volume Imaging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;90</title>
		<meeting>Visualization &apos;90<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="226" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Template-Based Volume Viewing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Eurographics &apos;92</title>
		<meeting>Eurographics &apos;92<address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Discrete Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="53" to="57" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
