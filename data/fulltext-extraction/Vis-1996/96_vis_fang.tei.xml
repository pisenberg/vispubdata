<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deformable Volume Rendering by 3D Texture Mapping and Octree Encoding</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiaofen</forename><surname>Fang</surname></persName>
							<email>sfang@iss.nus.sg</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">Indiana University Purdue University at Indianapolis</orgName>
								<address>
									<postCode>46202-5132</postCode>
									<settlement>Indianapolis</settlement>
									<region>IN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajagopalan</forename><surname>Srinivasan</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institute of Systems Science</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>Heng Mui Keng Terrace, Kent Ridge</addrLine>
									<postCode>119597</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Su</forename><surname>Huang</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institute of Systems Science</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>Heng Mui Keng Terrace, Kent Ridge</addrLine>
									<postCode>119597</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raghu</forename><surname>Raghavan</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institute of Systems Science</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>Heng Mui Keng Terrace, Kent Ridge</addrLine>
									<postCode>119597</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute of Systems Science</orgName>
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Deformable Volume Rendering by 3D Texture Mapping and Octree Encoding</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Volume Rendering</term>
					<term>3D Texture Mapping</term>
					<term>Morphing</term>
					<term>Volume Deformation</term>
					<term>Octree</term>
					<term>Scientific Visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Rendering deformable volume data currently needs separate processes for deformation and rendering, and is expensive in terms of both computational and memory costs. Recognizing the importance of unifying these processes, we present a new approach to the direct rendering of deformable volumes without explicitly constructing the intermediate deformed volumes. The volume deformation is done by a radial basis function that is piecewise linearly approximated by an adaptive subdivision of the octree encoded target volume. The octree blocks in the target volume are then projected, reverse morphed and texture mapped, using the SGI 3D texture mapping hardware, in a back-to-front order. A template based Z-plane/block intersection method is used to expedite the block projection computation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Deformable Volume Rendering</head><p>Volume rendering is an emerging technique widely used in visualizing the internal structures of large volumetric datasets. In many scientific applications, however, the volumetric objects are often time dependent and deformable. Using normal volume rendering methods to visualize the deformation process requires the construction of all the intermediate deformed volumes. Such volume construction is unfortunately very expensive in terms of both computational and memory costs, and is far from being real-time or interactive animation rate. For fast animated rendering of deformable volumes, new techniques are needed to handle dynamic volume data. In this paper, we present a deformable volume rendering algorithm that embeds the deformation into the visualization process for fast rendering of arbitrary 3D morphing-based deformation of various volume datasets. Hardware assisted 3D texture mapping and the octree encoding of the volumetric objects are also used in the algorithm to improve the rendering speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>There are a large number of publications on the topic of volume rendering. They can be roughly classified into two categories: image space approaches such as raycasting based algorithms <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b24">25</ref>],</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Overview</head><p>The algorithm to be presented in this paper is an object space algorithm based on octree projection. Although texture mapping is used here to take advantage of hardware features, the algorithm can be easily modified for software implementation of any object space rendering algorithm.</p><p>In this algorithm, the original volume is subdivided into texture blocks of fixed size. For each given pair of landmark point sets in the original and deformed (target) volumes, a backward morphing function from the deformed volume to the original volume is computed. An adaptive subdivision process using octree encoding is then invoked to select target octree blocks in the deformed volume so that the morphing can be approximated by trilinear interpolation within each target block. Once this setup for morphing function and target blocks is done, the result can be used for the rendering of all intermediate animation frames in all viewing angles. For each viewing direction, the target blocks are first sorted in a back-to-front order, and then projected and texture mapped to the projection plane in that order. The block projection involves computing the polygons from Z-plane/block intersections, and interpolating the morphed vertices of the polygons in the original volume and their tex-ture coordinates. Because of the uniform sizes and orientation of the target blocks, such Z-plane/block intersection needs to be done only once for sample blocks of each size and the results are "pasted" to all other blocks.</p><p>In Section 2, we first present our method of computing the landmarkbased morphing function for volume deformation. The generation of texture blocks and the adaptive subdivision of the target blocks are described in Section 3. Section 4 discusses the template-based block projection algorithm and the texture mapping process in detail. In Section 5, some implementation details and results are given, followed by a discussion on a few pratical problems in using the 3D texture mapping hardware in OpenGL. We conclude our presentation with a few further comments and future work in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">VOLUME DEFORMATION BY MORPHING</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Hardy's Interpolation</head><p>A landmark based 3D morphing can be defined as a globally smooth interpolation between scattered data points in 3D space. This problem has been widely studied in computer aided geometric design. Several methods have been proposed in using scattered data interpolation for volume morphing and image warping <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17]</ref>. One particular radial basis function method, Hardy's interpolation, has been especially useful for morphing purposes because of its global smoothness and robustness <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>. In our approach, Hardy's interpolation is used as the deformation function, but in the reversed direction, i: e: it is a backward morphing that transforms the points in the deformed volume back to the original volume for texture association.</p><p>For given source landmarks fL 0 i = ( x 0 i ; y 0 i ; z 0 i ) g ( i = 1 n ) in the original volume and target landmarks fLi = ( x i ; y i ; z i ) g ( i= 1 n ) in the deformed volume, the morphing function is defined as:</p><formula xml:id="formula_0">H(P) = n X i =1 hi (d 2 i (P) + r 2 i ) + L ( P )<label>(1)</label></formula><p>where L(P) is a linear function to absorb any global linear transformation to the whole landmark set, di is the distance function from</p><p>Li, and is the exponent parameter that should be either 0:5, 1 or 1 for good results. ri is a set of parameters that can control the stiffness of the deformation. We set it to</p><formula xml:id="formula_1">min j6 =i di(Pj)</formula><p>to ensure that the deformation is soft in the region where landmarks are sparse and stiff in the region where landmarks are dense.</p><p>The coefficients fhig (hi 2 R 3 ) and L are computed by solving the following linear system from the interpolation equations to ensure that landmarks are mapped to their corresponding landmarks up to a linear transformation.</p><formula xml:id="formula_2">H(Li) = L 0 i (2) n X i=1 hi xi = n X i=1 hi yi = n X i=1 hi zi = n X i=1 hi = 0 (3)</formula><p>It has been shown <ref type="bibr" target="#b13">[14]</ref> that such a linear system is very stable and the interpolant exists and is unique under normal datasets. More details about Hardy's interpolation and other scattered data interpolation methods can be found in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Influence Radii and Locally Bounded Hardy's Interpolation</head><p>Computing H(P) is quite expensive becausethe distances from each point P to all landmarks need to be individually calculated, and there are usually a large number of points to be morphed in a volume. It was pointed out in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref> and elsewhere that, when = 1, an influence radius Ri can be defined for each landmark point Li, so that its contribution (the ith term in the summation in (1)) to points outside its influence area (the sphere centered at Li with radius Ri) is smaller than a pre-defined tolerance , and therefore can be neglected. This leads to the following locally bounded Hardy's interpolation:</p><formula xml:id="formula_3">M(P) = n X i =1 Hi [(d 2 i (P)+r 2 i ) 1 (R 2 i +r 2 i ) 1 ]++L(P) (4)</formula><p>where Ri is computed from the equation:</p><formula xml:id="formula_4">jhij ( R 2 i + r 2 i ) 1 =<label>(5)</label></formula><p>In function M, the ith term in the summation vanishes if the distance to Li is larger than Ri. The tolerance determines the accuracy of the approximation of (4) to <ref type="bibr" target="#b0">(1)</ref>. In our experiments, when = 0 : 5 , the result from using <ref type="bibr" target="#b3">(4)</ref> and <ref type="formula" target="#formula_0">1</ref> </p><formula xml:id="formula_5">M(Li) = L 0 i<label>(6)</label></formula><p>Without noticeable loss of quality, M(P) can be computed much faster than H(P) because points outside the influence areas of the landmarks need not be considered. For the examples we have tested, an average speed up of ten can be achieved. The concept of the influence radius also plays an important role in the adaptive subdivision of the target volume to be discussed in next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TEXTURES AND TARGET BLOCKS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Texture Volume, Texture Memory and Texture Blocks</head><p>We define a texture volume as a volume with voxels containing RGB color and opacity values. If an input volume dataset is based on intensities, it needs to be first converted into a texture volume by a transfer function. This texture volume will then be loaded into the hardware texture memory for texture mapping. Because the texture volume is often much larger than the texture memory, it has to be subdivided into smaller subvolumes called texture blocks that can be comfortably put into the texture memory. Each texture block is considered a separate texture map that can be accessed through the texture coordinates of points in the object space. When a texture block is first accessed, a texture binding operation is needed to define the texture block as the current texture map, and subsequent accesses to the same texture block will use the same texture map until a new texture block is encountered. The binding is not expensive if the texture block is already in the texture memory. Otherwise, the content of the texture block will be loaded into the texture memory. Furthermore, if the texture memory is full, swapping of the entire texture memory is then necessary. Such texture block loading and texture memory swapping is very expensive (e: g:</p><p>on an SGI VTX machines with 4MB texture memory, each swapping takes approximately 0:1 second) and is often the dominant cost in texture mapping based algorithms, as we will show later in Section 5. From our experience, using smaller texture blocks sometimes helps to reduce the texture binding time (including the time for loading and swapping) as shown in Section 5. But this is very much dataset and hardware implementation dependent, and will not be discussed further in detail in this paper.</p><p>For the subdivision of the texture volume into texture blocks, an octree data structure is used. In our implementation, the subdivision is uniform, i: e: the texture blocks are the same sized octants of the texture volume. The octree data structure here serves two purposes:</p><p>to efficiently query the texture blocks. Such queries are used very frequently in our rendering algorithm.</p><p>to have a consistent data structure with the deformed volume so that the algorithm can be uniformly applied to the texture volume directly for the rendering of un-deformed volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Target Blocks and Their Subdivisions</head><p>To approximate the morphing function M, the deformed volume space is adaptively subdivided into target blocks so that only the block vertices need to be morphed, and all other points in the block can be trilinearly interpolated (approximations using higher degree polynomials, such as quadratic interpolations, is also possible, but may be more expensive). The subdivision process operates within a target octree. This target octree is initially set to a complete octree representing a preliminary uniform subdivision with a pre-determined depth level. The vertices of the leaf nodes of the uniform target octree are first morphed back to the original volume space (texture space), using the morphing function M. If the bounding box of the eight morphed vertices of a leaf node falls into an empty space, i: e: it does not intersect any texture block, this leaf node is considered empty. A target block is defined as a non-empty leaf node in the current target octree.</p><p>In some blocks, the trilinear approximation of the morphing function may not be sufficiently accurate for the desired deformation. When this happens, these target blocks should be subdivided further into eight sub-blocks for better approximation. To identify blocks for subdivision, we adopt an approach used in <ref type="bibr" target="#b11">[12]</ref>. In this approach, several sample points in each target block are selected (often the center of the block and the centers of its six faces, since these points will be used anyway if subdivision is needed) and deformed separately by the morphing function M and the trilinear interpolation.</p><p>If the distances between the morphed results and the interpolated results are all under the given tolerance, the target block is considered acceptable, otherwise subdivision is needed. This process continues recursively until all target blocks meet the tolerance requirement.</p><p>For the purpose of approximating the deformation function, the tolerance used above is a measure of how close the trilinear interpolation is to the original morphing function. On the other hand, because of the existence of neighboring blocks with different levels of subdivision, sampling discontinuity in the texture volume can occur along the common boundary of such neighboring blocks after trilinear interpolation, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Such discontinuity can cause a small portion (within the given tolerance) in the texture volume be either mis-sampled or double-sampled. To avoid artifacts in the rendered deformed images caused by this problem, the tolerance has to be small. In our experiments, a tolerance of the size of three voxels seems to be sufficient for the examples shown in this papers.</p><p>Directly using the above subdivision approach with a uniform small tolerance can generate a large number of target blocks, and consequently slow down the rendering. To reduce the number of blocks without substantially affecting the final rendering quality, we introduce a varying tolerance approach. The tolerance controlling the precision of the subdivision can be different in different regions erances. We take a small influence area (i: e: a small influence radius) to mean that the landmark is used for small but more delicate shape changes in a small region. In other words, in the influence areas of the landmarks with small influence radii, the tolerances for the approximation of the morphing function should be smaller than in larger influence areas. For example, each target block can be assigned with a tolerance that is proportional to the radius of the smallest influence area it falls in. Based on these tolerances, the subdivision can be coarse in regions where the deformation is more uniform, and is finer in regions where more delicate shape changes are expected.</p><p>During the subdivision, the vertices of all target blocks have already been morphed, as in the uniform case. Thus, the bounding box of the morphed vertices of each target block can then be checked to see whether it falls into empty space. If so, the target block is marked empty, and removed from the target block list. In other words, the final set of target blocks is the set of all non-empty leaf nodes in the final target octree. The above target block construction and vertex morphing process needs to be done only when landmarks are changed. The result can be used for all subsequent rendering of all the animation frames and viewing angles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BLOCK PROJECTION AND TEXTURE MAP-PING</head><p>The 3D texture mapping hardware can take polygons in a back-tofront (or front-to-back) order and texture map them based on their texture coordinates of the polygon vertices. The polygons can be generated by intersecting consecutive Z-planes with all the target blocks. In the following algorithm, instead of taking one Z-plane and computing its intersections with all the blocks, we take the blocks one by one and compute all the polygons for each block at once to make use of the block coherence. To ensure that the polygons are computed in the right order, the blocks have to be sorted first.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Sorting of Octree Blocks</head><p>Because the target blocks are already organized in the target octree, sorting for a given viewing direction is fairly simple. Assuming the viewing direction vector is (x; y; z), relative to the orthogonal coordinate system of the octree, the signs of the coordinates determine the order in which the eight child octants of each node are visited, as shown in <ref type="figure">Figure 2</ref>. Based on this view-dependent child access order, a view-dependent depth first traversal of the target octree will automatically pick the target blocks in back-to-front order. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Z-plane/Block Intersection by Template Pasting</head><p>Since there can be thousands of target blocks, computing the intersection for every one would be too expensive. Here we give a template based approach that computes such intersections with only a few sample blocks and saves the results into templates which are later pasted to all other blocks with very little overhead. For a given viewing direction, all target blocks have the same orientation and only a few different sizes. Intuitively, the result of the Z-plane/block intersection for one sample block should be able to be used by all other blocks of the same size with a simple translation. As shown in <ref type="figure">Figure 3</ref>, the template is defined as a list of polygons as the result of the intersections of consecutive Z-planes and the sample block. Let us assume, without loss of generality, that the bottom vertex of the rotated sample block is at (0; 0; 0), and all Z-planes are at the integer Z coordinates with a Z step = 1 . For a given target block with its bottom vertex at (x; y; z) after rotation, if z is an integer number, we only need to translate all polygon vertices in the template by (x; y; z) to get the polygons for this target block. Otherwise, suppose z has an integer part k and a decimal part q (q 2 (0; 1)). Merely translating the template by (x; y; k) is not sufficient because there is a small offset q that needs to be taken into account. With the q offset, as illustrated in a 2D analog in <ref type="figure">Figure</ref> 4, each translated polygon vertex needs to be shifted by q pe,</p><p>where pe is the unit offset for each edge and is pre-computed and stored in the template as well.</p><p>The above approach for the offset works only when each Z-plane intersects the same set of block edges for both the translated sample block and the target block. When the offset is too big, this will not be true anymore as shown in <ref type="figure" target="#fig_2">Figure 4</ref> where the middle Z-plane intersects different edges for the dashed target block. To overcome this problem, more than one template is needed. <ref type="figure">Figure 5</ref> shows a 2D analog of this solution. For each vertex, Vi = ( x i ; y i ; z i ) , of the sample block, its offset qi = dzie z i is first computed. The Z interval [0,1] will then be partitioned by all the qi into subintervals.</p><p>One template will be built for each subinterval, using a sample block with bottom vertex at the low end of the subinterval as shown in V2' <ref type="figure">Figure 6</ref>: The 2D analog of the multiple texture blocks and polygon clipping <ref type="figure">Figure 5</ref>. When pasting a target block, we first check which subinterval the offset of the block q falls into, and use the template for that subinterval to compute the polygons for the target block as described before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Texture Mapping of Polygons</head><p>Before sending the polygons of a target block for texture mapping, the following two things have to be ready:</p><p>1. Each texture block that the target block morphed into needs to be found, defined and bound.</p><p>2. The texture coordinates of the morphed vertices of the polygons in the current texture block need to be given for getting the proper texture from the texture volume to generate the visual deformation effect.</p><p>As explained in Section 3.2, the morphed polygon vertices are computed by linear interpolation of the morphed block vertices. Because these morphed vertices are in the world coordinate system of the original volume, simple translation and scaling will turn their coordinates into texture coordinate, within the [0; 1] range, of the current texture block.</p><p>To find the texture blocks that a target block morphed into, we take the bounding box of the morphed vertices of each target block, and define texture blocks that intersect this bounding box as the associated texture blocks of this target block. In most cases, only one associated texture block exists for a target block. Thus, this texture block can be defined as the current texture block for the texture mapping of all the polygons of the current target block. But when the morphed target block falls across texture blocks, as shown in <ref type="figure">Figure 6</ref>, there can be multiple associated texture blocks.</p><p>When multiple associated texture blocks occur, the polygons of the target block need to be texture mapped multiple times -once for every texture block, i: e: each associated texture block needs to be bound once for this target block. The order of binding the associated texture blocks within each target block is the same octree order we used in Section 4.1 for sorting the target blocks. Because the target block is fairly small, we assume that such order is uniquely defined within each target block. For instance in <ref type="figure">Figure 6</ref>, the order of binding the four texture blocks for the target block is: (T1; T 3 ; T 2 ; T 4 ) because the vertices that are morphed into these four texture blocks are viewed in that order in the target volume. For each texture block, since only part of the polygon is inside, the rest will have negative or greater than 1 texture coordinates. The behavior of texture mapping with such invalid texture coordinates often depends on the hardware implementation. In OpenGL, for instance, the texture can be either clamped using the boundary texture or repeated from the other side of the texture boundary. Clamping texture with a zero valued texture boundary would have solved the problem. But unfortunately in OpenGL, the texture boundary is not yet supported. Our alternative solution to this problem is to use the hardware clipping feature in OpenGL to clip the polygon against the six faces of the texture block to ensure that only the part of the polygon that is within the texture block gets texture mapped. This hardware clipping is quite easy and convenient to use and very fast. Because the polygons are defined in the viewing coordinate system, the clipping planes have to be defined there as well. Due to the nonlinear transformation between the viewing coordinate system and the texture coordinate system, the faces of the texture block will be turned into curved surfaces in the viewing coordinate system. However, since within each target block, the morphing function is considered linear, we can always use an approximate linear transformation (4x4 matrix), e: g: by interpolating four vertices of the target block and their morphed counterparts, for each target block to transform the texture faces into clipping planes in the viewing coordinate system.</p><p>In addition, if we want to animate the intermediate steps of the morphing, the rendering process is exactly the same except that the deformed vertices of the target blocks are calculated by linear interpolation of the original vertices and the morphed vertices.</p><p>Finally, if the deformation function is the identity, i: e: no deformation is intended, the target blocks would be the same as the texture blocks. Using the above template based approach we can directly project the texture blocks without worrying about the texture association problem and the repeated texture binding problem, because the algorithm will bind each texture block exactly once. Naturally, the rendering of unmorphed volumes is much faster than the morphed volumes since texture binding time is in fact the dominant portion of the overall rendering time as shown in <ref type="figure" target="#fig_4">Figure 7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION</head><p>The algorithm presented in this paper has been implemented in a software package called Mutability as part of a research project in the Center for Information Enhanced Medicine (CI E MED) at the Institute of Systems Science. The software was written in C++ and OpenGL on an SGI VTX (R4400) workstation of 150MHz with 128 Mbytes main memory. The texture memory on this machine is 4MB.</p><p>To test the algorithm, the CT-scanned datasets of a human head and some monkey heads were used. 56 homologous biological landmark points were picked on these datasets at the Johns Hopkins University by Joan Richtsmeier. The texture-mapped rendering results are shown in <ref type="figure" target="#fig_4">Figure 7</ref>. (e) are the morphing results from human to macaque in 128 3 and 256 3 sizes respectively. <ref type="figure" target="#fig_4">Figure 7(c)</ref> is the direct rendering of an 128 3 volume of an erectus skull. In <ref type="figure" target="#fig_4">Figure 7</ref>(f) and <ref type="figure" target="#fig_4">Figure 7(i)</ref>, the erectus is morphed to human and macaque respectively. <ref type="figure" target="#fig_4">Figure 7(g)</ref> shows the morphed results from human to a chimpanzee. In <ref type="figure" target="#fig_4">Figure 7(h)</ref>, the human is morphed to a macaque first and then back to the human again. The result is different from the original human because switching the source and destination landmark sets in Hardy's interpolation doesn't make the inverse function. All these morphing results are based on biological landmarks only -no extra points have been used to artificially correct the shape changes.</p><p>The algorithm's performance data are given in <ref type="table">Table 1</ref>  of building target blocks are also given in <ref type="table">Table 1</ref>, though the texture blocks need to be built only once for each source volume, and the target blocks need to be constructed only when landmarks are changed. In this table, we also give the total memory used in the algorithm. This includes the memory for the texture blocks, the target octree and blocks, and the templates. It also shows that smaller texture block size does help to reduce texture binding time. In table 2, the rendering time is partitioned into four parts: template building, computing associated textures and texture coordinates, projecting blocks, including polygon filling time by the hardware, and texture binding. It is clear from <ref type="table">Table 2</ref> that the dominant cost is the texture binding, which depends very much on the hardware performance and the size of the texture memory. With a larger texture memory, we expect the performance to improve dramatically.</p><p>Finally, we would like to bring up a few problems we encountered in using the SGI OpenGL 3D texture mapping hardware, and their possible causes and solutions.</p><p>When using multiple texture blocks for large datasets, artifacts (often lines) may occur along the boundary of two texture blocks, as seen in some of the images in <ref type="figure" target="#fig_4">Figure 7</ref>. This is because the image interpolation in texture mapping along the boundary cannot use the neighboring image values that are stored in the other texture block. This problem can be solved if texture boundary is later supported by OpenGL as the way it is described in OpenGL specification, because the neighboring image values can then be simply defined as the boundary of the texture blocks.</p><p>Due to, again, the missing OpenGL support to texture boundary in SGI workstations, as described in Section 4.3, the six planes of each texture block need to be transformed to the object space as clipping planes to cut the polygons from each target block that fall partially out of the texture block. Since such linear transformations (as the approximation to the morphing function) are usually different for different target blocks, the same boundary plane can be transformed to different places in the object space by the transformations for different target blocks. Clipping results from these inconsistent clipping planes may cause mis-or double-sampling in part of the polygons, resulting in artifacts in the final image. With texture boundary, this problem can be easily solved by using clamping texture boundary of zero values, and the clipping process is not at all needed.</p><p>As mentioned earlier in this section, texture binding (including loading and swapping) is very expensive and can be the dominant cost in texture mapping based algorithms. This is particularly frustrating for the rendering of animation sequences of large datasets. The number of bindings can be reduced if the accessesto the same texture block by different target blocks are contiguous (i: e: without accessing other texture blocks in between), which is often not possible because the deformation changes the sorting order of the target blocks. However, for the purpose of pre-viewing animation sequences, we can ignore the order change in the target blocks. Instead, we only sort the texture blocks, and process the target blocks in the order of their associated texture blocks. This way, all target blocks associated with the same texture block will be processed together, which essentially eliminates the need for rebinding of the same texture block. The result using this sorting order is of course wrong because of the incorrect viewing order. But it does provide a very fast way (a speed up of about five to ten in our experiment) to a rough rendering that still gives you a good idea about the overall shape change, and often very useful and informative for applications that need quick responses. The correct but slower rendering can be brought up a little later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>We have presented a new rendering algorithm for deformable volumes, using hardware assisted texture mapping and octree encoding. By taking advantage of the uniform shape and orientation of octree blocks, a fast template-based Z-plane/block intersection approach is developed. A smooth locally bounded Hardy's morphing function based on landmark interpolation is used to model the volume deformation. An adaptive subdivision scheme based on the influence radii and varying tolerances is introduced to generate a set of target blocks within which the deformation can be linearly interpolated. The algorithm is efficient in terms of both the rendering speed and memory use. It however can only achieve interactive rate for 128 3 volumes with 4MB texture memory. The algorithm will be significantly slower for larger volumes. We expect this situation to improve with a larger texture memory and perhaps a more optimized texture binding strategy.</p><p>In the future, besides improving the texture binding scheme to reduce the texture swapping rate, we would like to also develop a software version of the algorithm based on target block projection. Our goal is to be able to interactively deform and manipulate 3D volume rendered images by interactive landmark editing. Such a tool would be useful for people who want to visualize and analysis deformable volumetric objects interactively. Finally, we intend to pursue this new paradigm of transformation integrated with visualization by allowing more general deformations of the volume data. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Discontinuity in texture space for neighboring blocks with different levels of subdivisions of the volume, since not every place in the volume needs the same level of approximation. The influence radii of the landmarks provide a natural and quantitative way to determine such varying tol-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>The order of the octants for a given viewing direction The template for Z-plane/block intersection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>The 2D analog of the offset to the template</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 7(a) and (b) are the original human head (translucent) and macaque head (skull) volumes (256 3 ) rendered directly by projecting the texture blocks only. Figure 7(d) and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>(a) Human (256 3 ); (b) Macaque (256 3 ); (c) Erectus (128 3 ); (d) Human-Macaque (128 3 ); (e) Human-Macaque (256 3 ); (f) Erectus-Human (128 3 ); (g) Human-Chimpanzee (256 3 ); (h) Human-Macaque-Human (256 3 ); (i) Erectus-Macaque (128 3 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 . The Algorithm's Overall Performance DataTable 2 . Partitioned Rendering Time</head><label>12</label><figDesc></figDesc><table><row><cell>and Ta-</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGMENTS</head><p>We would like to thank Professor Joan Richtsmeier and her colleagues from the Johns Hopkins University for providing all the wonderful CT datasets and placing landmarks on them.</p><p>The inspiration of this work comes from the original CI E MED project, Mutability. We would like to take this opportunity to thank all the other members of the Mutability project, in particular, Dr. Tim Poston and Kartik Venkataraman for their earlier effort on the same problem, Dr. Wayne Lawton for many useful discussions, H. T. Nguyen for setting up a wonderful software development environment, and Meiyappan Solaiyappan for his help in using the SGI texture mapping hardware.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nancy</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1994 Symposium on Volume Visualization</title>
		<meeting>1994 Symposium on Volume Visualization<address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast algorithms for volume ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Danskin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1992 Workshop on Volume Visualization, October</title>
		<meeting>1992 Workshop on Volume Visualization, October</meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Volume morphing methods for landmark-based 3D image deformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiaofen</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raghu</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joan</forename><forename type="middle">T</forename><surname>Richtsmeier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1996 SPIE Medical Imaging, SPIE 2710</title>
		<meeting>1996 SPIE Medical Imaging, SPIE 2710<address><addrLine>Newport Beach, CA, Febuary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Scattered data interpolation: Tests of some methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Franke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Computation</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="181" to="200" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Smooth interpolation of large sets of scattered data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Franke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Journal for Numerical Methods in Engineering</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1691" to="1704" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Innovative volume rendering using 3D texture mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Sheng-Yih Guan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lipes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 1994 SPIE Medical Imaging, SPIE 2164</title>
		<meeting>of 1994 SPIE Medical Imaging, SPIE 2164</meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multiquadric equations of topography and other irregular surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Hardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Geophys. Res</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="1905" to="1915" />
			<date type="published" when="1971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Wavelet-based volume morphing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization 94</title>
		<meeting>of Visualization 94</meeting>
		<imprint>
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scheduled Fourier volume morphing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Hughes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics, SIGGRAPH&apos;</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="43" to="46" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Space deformation using ray deflectors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yair</forename><surname>Kurzion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th Eurographics Workshop on Rendering</title>
		<imprint>
			<date type="published" when="1995-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hierarchical splatting: A progressive refinement algorithm for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics, SIGGRAPH&apos;</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="285" to="288" />
			<date type="published" when="1991-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Feature-based volume metamorphosis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apostolos</forename><surname>Lerios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chase</forename><forename type="middle">D</forename><surname>Garfinkle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH&apos;95</title>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="449" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient ray tracing of volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="261" />
			<date type="published" when="1990-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interpolation of scattered data: Distance matrices and conditionally positive definite functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Micchelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Constr. Approx</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="11" to="22" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scattered data modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Application</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="60" to="70" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Comparing methods of interpolation for scattered volumetric data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Tvedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">State of the Art in Computer Graphics</title>
		<editor>David F. Gogers and Rae A. Earnshaw</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Image warping with scattered data interpolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Detlef</forename><surname>Ruprecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heinrich</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Application</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="37" to="43" />
			<date type="published" when="1995-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Free-form deformations of solid geometric models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">W</forename><surname>Sedeberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Parry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics, SIGGRAPH</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="151" to="160" />
			<date type="published" when="1986-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sorting and hardware assisted rendering for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clifford</forename><forename type="middle">M</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barry</forename><forename type="middle">G</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><forename type="middle">L</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1994 Symposium on Volume Visualizatio</title>
		<meeting>1994 Symposium on Volume Visualizatio</meeting>
		<imprint>
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
	<note>Washington, D.C.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Terzopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Platt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fleischer</surname></persName>
		</author>
		<title level="m">Elastically deformable models. SIGGRAPH&apos;87</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="205" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A volume visualization algorithm using a coherent extended weight matrix</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Puig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Navazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="45" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A coherent projection approach for direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics, SIGGRAPH&apos;</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="275" to="284" />
			<date type="published" when="1991-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Direct volume rendering via 3D textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orion</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-06" />
			<pubPlace>Santa Cruz</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Univ. of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. UCSC-CRL-94-19</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Digital Image Warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wolberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>IEEE Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Template-based volume viewing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics&apos;92</title>
		<meeting>Eurographics&apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
