<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mesh Reduction with Error Control</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reinhard</forename><surname>Klein</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Wilhelm-Schickard-Institut, GRIS</orgName>
								<orgName type="institution">Universität Tübingen</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunther</forename><surname>Liebich</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Wilhelm-Schickard-Institut, GRIS</orgName>
								<orgName type="institution">Universität Tübingen</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straßer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Wilhelm-Schickard-Institut, GRIS</orgName>
								<orgName type="institution">Universität Tübingen</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Mesh Reduction with Error Control</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3[Computer Graphics]: Picture/Image Generation, Display algorithms</term>
					<term>I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling Curve, surface, and object representations, Object hierarchies</term>
					<term>Additional hierarchical approximation, model simplification, levels-of-detail generation, shape approximation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In many cases the surfaces of geometric models consist of a large number of triangles. Several algorithms were developed to reduce the number of triangles required to approximate such objects. Algorithms that measure the deviation between the approximated object and the original object are only available for special cases. In this paper we use the Hausdorff distance between the original and the simplified mesh as a geometrically meaningful error value which can be applied to arbitrary triangle meshes. We present a new algorithm to reduce the number of triangles of a mesh without exceeding a user-defined Hausdorff distance between the original and simplified mesh. As this distance is parameterization-independent, its use as error measure is superior to the use of the L 1-Norm between parameterized surfaces. Furthermore the Hausdorff distance is always less than the distance induced by the L 1-Norm. This results in higher reduction rates. Excellent results were achieved by the new decimation algorithm for triangle meshes that has been used in different application areas such as volume rendering, terrain modeling and the approximations of parameterized surfaces. The key advantages of the new algorithm are: It guarantees a user defined position dependent approximation error. It allows to generate a hierarchical geometric representation in a canonical way. It automatically preserves sharp edges.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction and previous work</head><p>Triangle meshes are one of the most popular representations of surfaces for computer graphics applications. On the one hand, rendering of triangles is widely supported by hardware and, therefore, 1 Universität Tübingen, Auf der Morgenstelle 10 / C9, 72076 Tübingen,</p><p>Germany. E-mail: reinhard@gris.uni-tuebingen.de http:nnwww.gris.uni-tuebingen.de fast. On the other hand, there is an increasing set of data acquisition techniques which generate triangle meshes as output. Examples are Marching Cubes algorithms, acquisition of digital elevation data, 3D reconstruction from images, or the use of 3D-scanners. However, most of these techniques generate much more triangles than neccessary to represent the given object with a small approximation error. For example typical medical computer tomography or magnetic resonance scanners produce over 100 slices at a resolution of 256 by 256 or up to 1024 by 1024 pixels each. For a sampled data set of the human head at a resolution of 512 by 512 pixels, isosurface extraction of the bones using the Marching Cubes algorithm produces a mesh with about 1M triangles. A digital map of Germany with a resolution of 40 meters in North-to-South and Westto-East direction results in about 500M points. Such huge amounts of data lead to problems with data storage and postprocessing programs. Animation and realtime rendering of such datasets is almost impossible even on high performance graphics hardware.</p><p>Many techniques were published that aimed at reducing surface complexity. These techniques simplify triangular meshes either by merging elements or by resampling vertices using different error criteria to measure the fitness of the approximated surfaces.</p><p>Following, we briefly mention some general and valuable solutions. For some surveys see also <ref type="bibr" target="#b0">[CRS96]</ref> and <ref type="bibr" target="#b3">[HG95]</ref>.</p><p>Coplanar facets merging: coplanar or nearly coplanar data are searched, merged in larger polygons and then retriangulated into fewer simple facets, <ref type="bibr" target="#b4">[HH92,</ref><ref type="bibr" target="#b7">MSS94]</ref>.</p><p>Mesh decimation: the algorithm uses multiple passes removing on each pass, all vertices that satisfy a distance and a feature angle criterion. The resulting holes are retriangulated <ref type="bibr" target="#b10">[SZL92]</ref>. Point coalescence: this technique subdivides the ambient space into smaller subspaces. Multiple vertices in a subregion are merged into a single vertex using a weighted approximation such as their centeroid. The merged vertices are then reconnected with their neighbours to form a collection of faces <ref type="bibr" target="#b8">[RB93]</ref>.</p><p>Re-tiling: a new set of vertices is inserted at random on the original surface mesh, and then moved on the surface to be displaced on maximum curvature locations; the original vertices are then iteratively removed. A retiled mesh, built on the new vertices only, is returned <ref type="bibr" target="#b11">[Tur92]</ref>.</p><p>Multiresolution retiling: the approach uses remeshing, resampling and wavelet parametrization to build a multiresolution representation of the surface from which any approximated representation can be extracted [EDD + 95].</p><p>The general drawback of all these algorithms is the lack of a common way of measuring the error between the original and the simplified mesh. This has also been pointed out by Cignoni and Rocchini <ref type="bibr" target="#b0">[CRS96]</ref>. Therefore, a general comparison between the above approaches is not easy.</p><p>In many cases the relation between the parameters (like the ones used in the algorithms above) and the result of the mesh simplification process is a-priori not obvious for a user. For example, some approaches <ref type="bibr" target="#b10">[SZL92,</ref><ref type="bibr" target="#b11">Tur92]</ref> allow the user to define the maximum error that can be introduced in a single simplification step. In this way errors can accumulate and there is no measure for the actual global error.</p><p>How further parameters like "feature angles" <ref type="bibr" target="#b10">[SZL92]</ref>, roughness criteria <ref type="bibr" target="#b9">[Sb94]</ref>, or decimation rates <ref type="bibr" target="#b10">[SZL92,</ref><ref type="bibr" target="#b11">Tur92]</ref> effect the simplification process and the simplified mesh is also not obvious. As the specification of the parameters is difficult, the user in many cases has to run the reduction algorithm several times with different parameters to get a good result.</p><p>The mesh simplification process is much easier to control by measuring the distance between the original and simplified mesh. Such distance measures have already been used for mesh simplification in the area of terrain modeling <ref type="bibr" target="#b1">[DFP85,</ref><ref type="bibr" target="#b3">HG95]</ref> and the approximation of parameterized surfaces <ref type="bibr" target="#b6">[Kle94,</ref><ref type="bibr" target="#b5">Ke95]</ref>. For height fields the distance between the original and the simplified mesh can be measured either as vertical distance from a plane or as distance from the closest point to the polygon. For parameterized surfaces the L 1 -norm is a possible measure.</p><p>In addition, the measurement of the distance between original and simplified mesh is neccessary for mesh simplification algorithms that must ensure a certain geometric accuracy between the original and the simplified mesh. An example from medicine is the reconstruction of organs from CT data that need to be replaced by a prosthesis.</p><p>The basis of our mesh simplification algorithm is the use of the Hausdorff distance as an appropriate error measure between original and simplified mesh. In contrast to other algorithms like <ref type="bibr" target="#b10">[SZL92]</ref> this distance is measured between the reduced and the orignal mesh and not between the reduced mesh and some average surface. We shortly define and discuss this distance in the next section. (1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The error metric</head><p>We call this distance one-sided Hausdorff distance between the set X and the set Y . It doesn't define a distance function on the set of all sets of R n , because it is not symmetric. That means that in general dE(X;Y) 6 = dE(Y;X):</p><p>If, for example, the one-sided Hausdorff distance dE(T;S)from the simplified mesh S to the original mesh T is less than a predefined error tolerance , then 8x 2 T there is a y 2 S with d(x;y) &lt; :</p><p>For mesh simplification this condition would be sufficient in many cases. But in some cases the unsymmetry of this distance leads to problems. This can either happen near to the borders of the original mesh or at parts of the mesh that resemble to the border, in the sense that the angle between adjacent triangles along a common edge is very small. An example is the concave blade of a sickle, see <ref type="figure" target="#fig_1">Figure  1</ref>. To handle such cases we use the Hausdorff distance. It is defined by dH(X;Y) = max(dE(X;Y); d E ( Y;X)):</p><p>(2)</p><p>In contrast to the one-sided Hausdorff distance it is symmetric and we have dH(X;Y) = 0 ( ) X = Y:</p><p>If the Hausdorff distance between the original triangulation T and the simplified triangulation S is less than a predefined error tolerance , then 8x 2 T there is a y 2 S with d(x; y) &lt; and 8y 2 S there is a x 2 T with d(x; y) &lt; :</p><p>Therefore, the Hausdorff distance between the original and simplified triangulation is the one a user would intuitively think of.</p><p>It is worthwhile to mention that for any parameterized surface S : R 2 : ! R 3 that is approximated by a piecewise linear surface T :: R 2 : ! R 3 we always have dH(S; T) j j S T jj1 = sup u2 jjS(u) T(u)jj:</p><p>For this reason, using the Hausdorff distance for error measurement results in higher reduction rates using the same error tolerance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The algorithm</head><p>The algorithm is a typical mesh simplification algorithm, that is it starts with the original triangulation T and successively simplifies it: It removes vertices and retriangulates the resulting holes until no further vertices can be removed from the simplified triangulation S without exceeding a predefined Hausdorff distance between the original triangulation and the simplified one. The main problem of the algorithm is how to compute the Hausdorff distance dH(S; T) = max(dE(S; T); d E ( T;S))</p><p>(3) between the original and simplified mesh. While, in general, this is a very complicated task, it can be easily solved in the case of an  <ref type="figure">Figure 2</ref>: Although the distance d2 is less than distance d1, d1 is measured due to the topological correspondance.</p><p>iterative simplification procedure. The idea is to keep track of the actual Hausdorff distance between the original and simplified mesh and of the correspondence between these two meshes from step to step. This correspondance is the clue to compute the Hausdorff distance between the two meshes. It allows for every x 2 S in the new triangulation to find the triangles of the original triangulation that contain the y 2 T nearest to x; that is d(x; y) d(x; z);8z 2 U T and vice versa. U T needs to be carefully chosen in order to avoid measuring the distance to topologically not neighbouring parts of T;see <ref type="figure">Figure 2</ref>. Note that keeping track of the correspondance and the Hausdorff distance dH(S; T) is a local operation because only a small part of the simplified triangulation changes in each step. Points of the simplified triangulation that may change the Hausdorff distance dH must belong to the modified area of the simplified triangulation. The calculation of the new distance is restricted to that area. After each step we know the Hausdorff distance between the original and simplified mesh. Based on this information a multiresolution representation of the model can be built.</p><p>A further idea of the new algorithm is to compute and update an error value for every single vertex of the simplified mesh. This value describes the potential error, that is the Hausdorff distance that would occur if a certain vertex was removed. In each step we actually eliminate one of the vertices whose removal causes the smallest potential error. At the beginning of the algorithm the original and simplified triangulation coincide. For every single vertex the potential error is computed and all vertices are stored into a list L in ascending order according to their potential errors. If a vertex is actually removed from the current simplified triangulation this list is updated. Because of the ordering of the list, the vertex that should be removed next is placed at its beginning. There are two cases where the removal of a vertex would not make sense: First so-called complex vertices, see <ref type="bibr" target="#b10">[SZL92]</ref>, and second vertices for which the retriangulation of the resulting hole may lead to topological problems. These situations are detected by topological consistency checks, see <ref type="bibr" target="#b11">[Tur92]</ref>. In both cases the potential error is set to infinity.</p><p>This strategy of implicit sorting preserves sharp edges in the original triangulation, see <ref type="figure" target="#fig_1">Figure 10</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Description of the algorithm</head><p>In the algorithm we first concentrate on the one-sided Hausdorff distance dE(T;S)from the original to the simplified mesh. After the realization of this one-sided distance, it is relatively easy to calculate the full Hausdorff distance, if neccessary. smaller than the predefined maximum Hausdorff distance . Otherwise it is not possible to remove an additional vertex while keeping the distance between simplified and original triangulation smaller than and we are finished. If we remove a vertex v from the triangulation its adjacent triangles are removed and the remaining hole is retriangulated. For this purpose the adjacent vertices are projected into a plane similar to the algorithm of Turk <ref type="bibr" target="#b11">[Tur92]</ref>. If the corresponding polygon in the plane does not self-intersect, the polygon is triangulated using a constrained Delaunay triangulation. The use of the Delaunay triangulation is not essential but we found that it produces better reduction results than an arbitrary triangulation of the polygon. In addition, for all neighbouring vertices v1; ; v n ; n 2 N of v the potential errors need to be updated, see <ref type="figure" target="#fig_2">Figure 3</ref>. The vertices have to be removed from the list L and reinserted into L according to their new potential error. Note that this can be done in O(log r) time, where r is the number of remaining vertices in the reduced mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">The main loop</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Calculation of the potential error</head><p>One of the crucial parts in the algorithm is the computation of the potential error of a vertex, because in this step not only the distances between vertices have to be computed but the distance dE between all points of the two triangulations. To simplify things we use Yet after some simplification steps there are triangles tk; k2K</p><p>in the original mesh with vertices that do no longer belong to the simplified mesh, see <ref type="figure" target="#fig_5">Figure 5</ref>. The straightforward way to calculate the maximum distance dE(tk; S ) = sup  Note that this is a local procedure and that this data structure not only enormously accelerates the distance computation but also ensures that the distance measure is always calculated to the correct part of the simplified mesh, i.e. the distance measurement respects the topology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Distance from a triangle t to the simplified triangulation S</head><p>The maximum of the distances from all three vertices of a triangle t in the original mesh to the simplified mesh is not always an upper bound for the distance from a triangle t to the simplified triangulation S: If the smallest distances from the vertices of the triangle t exist to different triangles of the simplified mesh S; the distance from t to S may occur between a point on the border or even inside of the triangle t and a point somewhere on the simplified triangulation S:</p><p>We distinguish two cases:</p><p>The triangle t of the original triangulation has no vertex in common with the simplified triangulation S:</p><formula xml:id="formula_0">v 1 v 6 v 5 v 3 v 2 v 4 v 7</formula><p>Figure 6: For every already removed vertex in the original triangulation we keep the triangle in the simplified triangulation that is nearest to the vertex itself. For example the vertices v4; v 5 ; v 6and v7 store (v1; v 2 ; v 3 ) :Vice versa the triangle (v1; v 2 ; v 3 )stores the vertices v4; v 5 ; v 6 ; v 7 : Here all subdivided triangles belong to the same case like the one in <ref type="figure">Figure 2</ref>).</p><formula xml:id="formula_1">1) 2)<label>3</label></formula><p>The triangle t of the original triangulation has one or two vertices in common with the simplified triangulation S:</p><p>This distinction allows us to reduce all occurring cases to easier-tohandle ones using a simple regular subdivision of the original triangles. If the second case is not treated differently, the subdivision may not converge to one of the simpler cases. Case 1: We consider the following three subcases, see <ref type="figure" target="#fig_6">Figure 7</ref>:</p><p>All three vertices are nearest to the same triangle s 2 S:</p><p>The three vertices are nearest to two triangles s1; s 22 Sthat share an edge.</p><p>All other cases.</p><p>In the first subcase we have</p><formula xml:id="formula_2">dE(t; S) = max(d(v1; S ) ; d ( v 2 ; S ) ; d ( v 3 ; S )):</formula><p>The second subcase is a little bit more complicated. We intersect the half-angle plane between the two triangles s1 and s2 sharing a common edge with those edges of the triangle t having endpoints that belong to different triangles. We then use the maximum of distances of the vertices of t and the distances of these intersection points to ha lf an gl e pl an e</p><formula xml:id="formula_3">v 1 v 2 v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8 v 9</formula><p>Figure 8: In the left Figure the situation is shown in 3D. Looking in direction of the edge v7v4 we get the 2D situation on the right side. To calculate the distance from (v1; v 2 ; v 3 )to the triangles 1 = ( v 4 ; v 6 ; v 7 )and 2 = ( v 4 ; v 7 ; v 8 )the half-angle plane between the two triangles 1 and 2 is intersected with the edge v1v2 and the edge v1v3: The distance from (v1; v 2 ; v 3 ) to the simplified triangulation S can then be calculated as the maximum of the distances from the intersection points and vertices v1; v 2 ; v 3to the triangles 1 and 2:</p><formula xml:id="formula_4">v 1 v 2 v 2 v 1 v 3 v 4 v 5 v 6 v 7 v 8</formula><p>Figure 9: On the left side the 3D situation is shown, on the right side a 2D view. To obtain the distance from (v1; v 2 ; v 3 ) to the simplified triangulation S the distances to the triangles adjacent to v3 are calculated using the half-angle planes between adjacent triangles.</p><p>the triangles s1 and s2 as an upper bound for the error, see <ref type="figure">Figure   8</ref>. In all other cases the original triangle is adaptively subdivided until the subtriangles fulfill either subcase 1 or subcase 2. Or until until the longest edge of a subtriangle is smaller than the predefined error tolerance in subcase3, see <ref type="figure" target="#fig_6">Figure 7</ref>-3b). In that subdivision terminating case the maximum distance</p><formula xml:id="formula_5">d(t;S) = max(d(v sup 1 ; S ) ; d ( v sub 2 ; S ) ; d ( v sub 3 ; S ))</formula><p>is used. (To also get a correct upper bound for the approximation error in this case, one should run the algorithm with = ( 1 + 1 p 3 ) 1 to ensure error :)</p><p>Case 2: In the case that the three vertices of the original triangle belong to triangles in the simplified triangulation S that share a common vertex, an upper bound of the maximum distance is again computed using the half-angle planes between adjacent triangles, see <ref type="figure">Figure 9</ref>. Using adaptive subdivison we reduce the general case 2 either to this case or to case 1 where none of the vertices of the subtriangle belong to the simplified triangulation. During the simplification process it may happen that subtriangles generated in the above cases are no longer needed because the adjacency relationships of the triangle in the simplified mesh change. If the triangles in the simplified mesh grow, more and more vertices of the subdivided triangles are nearest to the same or adjacent triangles in S. In such cases we remove the subdivided triangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Achieving the Hausdorff distance</head><p>The simplest way to achieve a sharp upper bound of the Hausdorff distance between the original and the simplified mesh is to measure the distances of the new edges of the retriangulated holes to all triangles containing a vertex that is nearest to one of the potentially removed triangles in each calculation of the potential distance .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Examples</head><p>Two different applications illustrate the superior results of our triangle decimation algorithm. The first application is the approximation of NURBS surfaces by triangle meshes. The NURBS surface is regularly sampled in parameterspace to achieve an error bound to an intermediate triangulation of 10000 vertices. This triangulation is simplified by the new algorithm using the Hausdorff distance and compared to a triangulation simplified using a L 1 norm on the NURBS-parametrization, <ref type="bibr" target="#b6">[Kle94,</ref><ref type="bibr" target="#b5">Ke95]</ref>. This application shows the superiority of the Hausdorff distance to the L 1 -Norm for a geometric approximation. The second application applies the decimation algorithm to the isosurface of medical data created using the Marching Cubes algorithm run on a data set of 113 slices with a resolution 512 by 512 pixel. More than 811000 triangles were required to model the bone surface. The results are compared to a result gained by the algorithm of Schroeder, Zarge, Lorensen <ref type="bibr" target="#b10">[SZL92]</ref>. Despite of the very small error tolerances of one or one-and-a-half pixel, the reduction rates are even higher than the ones published by Schroeder et al. Further it should be noted that reduction as achieved by this algorithm cannot be achieved in general using a L 1 -Norm.</p><p>In the third application we use an object containing different features like sharp edges. Due to the ordering of the removed points at the beginning of the algorithm planar regions are reduced first. Removing vertices on sharp edges would lead to illegal approximation errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have described an algorithm for solving the mesh simplification problem, that is the problem of approximating an arbitrary mesh by a simplified mesh. The algorithm ensures that for each point in the original mesh there is a point in the simplified mesh with an Euclidean distance smaller than a user-defined error tolerance : For parameterized surfaces this distance also allows for much better reduction rates and is, in addition, independent of the parameterization.</p><p>We have applied our mesh simplification algorithm to different complicated meshes consisting of up to 811.000 vertices. The very impressive reduction rates for Marching Cubes outputs on medical data demonstrate the power of the algorithm even for error tolerances in the range of a voxel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgement</head><p>We would like to thank A. Schilling for many fruitful discussions.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Mesh optimization: an energy function is evaluated over the mesh and is minimized either by removing/moving vertices or collapsing/swapping edges [HDD + 93].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Left: The original nonconvextriangle mesh T is contained within a plane. The simplified mesh S consists of a triangulation of the convex hull of the original mesh and therefore the original mesh is contained in the simplified mesh. Right: The same situation in 3D. 8x 2 T there is a y 2 S with d(x; y) &lt; but we do not have 8y 2 S there is a x 2 T with d(x; y) &lt; :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>After building the list L; the triangulation is simplified through an iterative removement of vertices, one at a time: At each iteration, the vertex on top of the list L is removed from the list and from the actual triangulation, provided that its corresponding potential error is If the vertex v is removed only the potential errors of neighbour vertices have to be updated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>dE(T;S) = max t2T d(t; S) instead of dE. If none of the neighbour vertices of a single vertex has already been removed from the original triangulation, it is clear how to calculate the potential error of that vertex: Let ti; i= 1 ::n be the set of removed triangles and sj; j= 1 ::m the set of new triangles produced during the retriangulation and v the vertex. Note that m = n 2 in the general case and m = n 1 if the removed vertex was a border vertex. To calculate dE(ftigi=1::n; fsjgj=1::m) it is sufficient to compute max j=1::m (d(v;fsjg); see Figure 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>for these triangles is not realizable to the whole simplified triangulation S: To solve this problem we store for each already removed vertex v of the original triangulation T the triangle s 2 S that has the v None of the neighbour vertices of a vertex are removed. In this case it is clear which triangles of the old and new triangulation have to be considered to calculate the potential error that would arise if the vertex was removed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>For the white triangles of the original triangulation (solid lines) it is a priori not clear to which triangles of the simplified triangulation (dashed) distances have to be computed. smallest distance to v. Vice versa we store for each triangle s 2 S all vertices that reference s as the triangle with smallest distance, seeFigure 6. This information is updated in each iteration step and suffices to calculate dE(T;S). Let sil 2 Sl; i= 1 ::n be the set of removed triangles and sjl+1 2 Sl+1; j= 1 ::m the set of new triangles produced during the step from triangulation Sl to Sl+1 and fvk 2 V g the set of vertices of the original triangulation that are already removed. Furthermore each vk must be nearest to one of the removed triangles sil 2 Sl: For all triangles of the original triangulation T incident to one of the vertices vk the distance to Sl+1 is calculated. It is sufficient to calculate the distances between triangles of the original triangulation and a subsetS Sl+1; wherẽ S contains the newly created triangles of Sl+1 and the triangles of Sl+1 sharing at least one point with the newly created ones. This is justified by dE(t; S) dE(t;S):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>In the Figures 1), 2), and 3) the vertices of the triangle t have smallest distances to one, two, or three different triangles of the simplified triangulation S: In Figure 3 b) the original triangle is subdivided.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Simplification of an object consisting of 1341 vertices and 2449 triangles. The size of its bounding box is 20 20 20 units. The approximation error is 0:25 units. The simplified mesh contains 124 vertices and 208 triangles. This is a reduction rate of 91%. Note the preservation of the sharp edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Approximation of a parameterized NURBS surface using the new decimation algorithm with Hausdorff distance on the left side and using a L 1 -Norm on the right side. For each case the same maximum distance is used. Due to the L 1 -Norm the reduction rate in the upper Figure is less than in the lowerFigure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Approximation of the original mesh produced by a Marching Cubes algorithm up to the size of one pixel. The original dataset is reduced from 811k vertices (1622k triangles) to 30.5k vertices (62.7k triangles). This is a reduction rate of 96.2 %.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Approximation up to the size of one and a half pixel. The original dataset is reduced from 811k vertices (=1622k triangles) to 22.7k vertices (47.1k triangles). This is a reduction rate of 97.2 %.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Metro: measuring error on simplified surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rochini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
		<idno>B4-01-01-96</idno>
		<editor>Istituto I.E.I. -C.N.R.</editor>
		<imprint>
			<date type="published" when="1996" />
			<pubPlace>Pisa, Italy, January</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Figure 14: The same dataset reduced by the algorithm of Schroeder et al. down to 74.2k vertices. This is a reduction rate of 91%</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Defloriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Falcidieno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pienovi ; Matthias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 95 Conference Proceedings, Annual Conference Series</title>
		<editor>Robert Cook</editor>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1985-08" />
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="6" to="11" />
		</imprint>
	</monogr>
	<note>Graphics and Image Processing</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Mesh optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;93 Proceedings)</title>
		<editor>James T. Kajiya</editor>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
	<note>HDD + 93</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Fast polygonal approximation of terrains and height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<pubPlace>Pittsburgh, PA 15213</pubPlace>
		</imprint>
		<respStmt>
			<orgName>School of Computer Science, Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report CMU-CS-95-181</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Isosurface extraction SIMD architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Hinker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization&apos;92</title>
		<imprint>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="1" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mesh generation from boundary models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Straßer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third Symposium on Solid Modeling and Applications</title>
		<editor>C. Hoffmann and J. Rossignac</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995-05" />
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linear approximation of trimmed surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reinhard</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Mathematics Of Surfaces VI</title>
		<editor>R.R. Martin</editor>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Discretized marching cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scateni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;94 Proceedings</title>
		<editor>R. D. Bergeron and A. E. Kaufman</editor>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="281" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multi-resolution 3d approximation for rendering complex scences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics: Methods and Applications</title>
		<editor>B. Falcidieno and T. L. Kunii</editor>
		<imprint>
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Managing the complexity of digital terrain models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Roßbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. &amp; Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="775" to="783" />
			<date type="published" when="1994-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;92 Proceedings)</title>
		<editor>Edwin E. Catmull</editor>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Re-tiling polygonal surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;92 Proceedings)</title>
		<editor>Edwin E. Catmull</editor>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
