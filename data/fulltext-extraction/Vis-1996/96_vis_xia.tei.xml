<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic View-Dependent Simplification for Polygonal Models</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julie</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
						</author>
						<title level="a" type="main">Dynamic View-Dependent Simplification for Polygonal Models</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present an algorithm for performing view-dependent simplifications of a triangulated polygonal model in real-time. The simplifications are dependent on viewing direction, lighting, and visibility and are performed by taking advantage of image-space, objectspace, and frame-to-frame coherences. A continuous level-of-detail representation for an object is first constructed off-line. This representation is then used at run-time to guide the selection of appropriate triangles for display. The list of displayed triangles is updated incrementally from one frame to the next. Our approach is more effective than the current level-of-detail-based rendering approaches for most scientific visualization applications where there are a limited number of highly complex objects that stay relatively close to the viewer.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The scientific visualization and virtual reality communities have always faced the problem that their "desirable" visualization dataset sizes are one or more orders of magnitude larger than what the hardware can display at interactive rates. Recent research on simplification of polygonal objects to generate multiresolution hierarchies has been motivated by attempts to bridge the gap between the desired and the actual hardware performance, through algorithmic and software techniques.</p><p>Research on simplification of general three-dimensional polygonal objects (non-convex, non-terrain, possibly high genus) has spanned the entire gamut of highly local to global algorithms, with several approaches in between that have both local and global steps. Local algorithms work by applying a set of local rules, which primarily work under some definition of a local neighborhood, for simplifying an object. The local rules are iteratively applied under a set of constraints and the algorithm terminates when it is no longer possible to apply the local rule without violating some constraint. The global algorithms optimize the simplification process over the whole object, and are not necessarily limited to the small neighborhood regions on the object. Some of the local approaches have been -vertex deletion by Schroeder et al <ref type="bibr" target="#b24">[21]</ref>, vertex collapsing by Rossignac and Borrel <ref type="bibr" target="#b23">[20]</ref>, edge collapsing by Hoppe et al <ref type="bibr" target="#b20">[17]</ref> and Guéziec <ref type="bibr" target="#b10">[11]</ref>, triangle collapsing by Hamann <ref type="bibr" target="#b15">[12]</ref>, and polygon merging by Hinker and Hansen <ref type="bibr" target="#b18">[15]</ref>. Some of the global approaches have been -redistributing vertices over the surface by Turk <ref type="bibr" target="#b25">[22]</ref>, minimizing global energy functions by Hoppe et al <ref type="bibr" target="#b20">[17]</ref>, using simplification envelopes by Varshney <ref type="bibr" target="#b26">[23]</ref> and Cohen et al <ref type="bibr" target="#b3">[4]</ref>, and wavelets by DeRose et al <ref type="bibr" target="#b6">[7]</ref>. The issue of preservation or simplification of the genus of the object is independent of whether an algorithm uses local rules, or global rules, or both, to simplify. Recent work by He et al <ref type="bibr" target="#b16">[13]</ref> provides a method to perform a controlled simplification of the genus of an object.</p><p>Simplification algorithms such as those mentioned above are iteratively applied to obtain a hierarchy of successively coarser Contact address: Department of Computer Science, State University of New York at Stony Brook, Stony Brook, NY 11794-4400, Email: varshney@cs.sunysb.edu approximations to the input object. Such multiresolution hierarchies have been used in level-of-detail-based rendering schemes to achieve higher frame update rates while maintaining good visual realism. These hierarchies usually have a number of distinct levels of detail, usually 5 to 10, for a given object. At run time, the perceptual importance of a given object in the scene is used to select its appropriate level of representation from the hierarchy <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b22">19,</ref><ref type="bibr" target="#b21">18]</ref>. Thus, higher detail representations are used when the object is perceptually more important and lower detail representations are used when the object is perceptually less significant. Transitions from one level of detail to the next are typically based on simple imagespace metrics such as the ratio of the image-space area of the object (usually implemented by using the projected area of the bounding box of the object) to the distance of the object from the viewer.</p><p>Previous work, as outlined above, is well-suited for virtual reality walkthroughs and flythroughs of large and complex structures with several thousands of objects. Examples of such environments include architectural buildings, airplane and submarine interiors, and factory layouts. However, for scientific visualization applications where the goal often is to visualize one or two highly detailed objects at close range, most of the previous work is not directly applicable. For instance, consider a biochemist visualizing the surface of a molecule or a physician inspecting the iso-surface of a human head extracted from a volume dataset. It is very likely during such a visualization session, that the object being visualized will not move adequately far away from the viewer to allow the rendering algorithm to switch to a lower level of detail. What is desirable in such a scenario is an algorithm that can allow several different levels of details to co-exist across different regions of the same object. Such a scheme needs to satisfy the following two important criteria: It should be possible to select the appropriate levels of detail across different regions of the same object in real time.</p><p>Different levels of detail in different regions across an object should merge seamlessly with one another without introducing any cracks and other discontinuities.</p><p>In this paper we present a general scheme that can construct such seamless and adaptive level-of-detail representations on-the-fly for polygonal objects. Since these representations are view-dependent, they take advantage of view-dependent illumination, visibility, and frame-to-frame coherence to maximize visual realism and minimize the time taken to construct and draw such objects. An example of using our approach is shown in <ref type="figure" target="#fig_0">Figure 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Previous Work</head><p>Adaptive levels of detail have been used in terrains by Gross et al <ref type="bibr" target="#b9">[10]</ref> by using a wavelet decomposition of the input data samples. Wavelet space filters are defined that allow changes to the quality of the surface approximations in locally-defined regions. Thus, the level of detail around any region can adaptively refine in real-time. This work provides a very elegant solution for terrains and other datasets that are defined on a regular grid. Some of the previous work in the area of general surface simplification has addressed the issue of adaptive approximation of general polygonal objects. Turk <ref type="bibr" target="#b25">[22]</ref> and Hamann <ref type="bibr" target="#b15">[12]</ref> have proposed curvature-guided adaptive simplification with lesser simplification in the areas of higher surface curvature. In <ref type="bibr" target="#b26">[23,</ref><ref type="bibr" target="#b3">4]</ref>, adaptive surface approximation is proposed with different amounts of approximation over different regions of the object. Guéziec <ref type="bibr" target="#b10">[11]</ref> proposes adaptive approximation by changing the tolerance volume in different regions of the object. However in all of these cases, once the level of approximation has been fixed for a given region of the object, a discrete level of detail corresponding to such an approximation is statically generated. No methods have been proposed there that allow free intermixing of different levels of detail across an object in real time in response to changing viewing directions.</p><p>Work on surface simplification using wavelets <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> and progressive meshes <ref type="bibr" target="#b19">[16]</ref> goes a step further. These methods produce a continuous level-of-detail representation for an object in contrast to a set of discrete number of levels of detail. In particular, Hoppe <ref type="bibr" target="#b19">[16]</ref> outlines a method for selective refinement -i.e. refinement of a particular region of the object based upon view frustum, silhouette edges, and projected screen-space area of the faces. Since the work on progressive meshes by Hoppe <ref type="bibr" target="#b19">[16]</ref> is somewhat similar to our work we overview his method next and discuss how our method extends it.</p><p>Progressive meshes offer an elegant solution for a continuous resolution representation of polygonal meshes. A polygonal mesĥ M = M k is simplified into successively coarser meshes M i by applying a sequence of edge collapses. An edge collapse transformation and its dual, the vertex split transformation, is shown in <ref type="figure" target="#fig_1">Figure 2</ref>. </p><formula xml:id="formula_0">M k collapse k 1 ! M k 1 collapse k 2 ! : : : M 1 collapse 0 ! M 0 (1)</formula><p>We can retrieve the successively higher detail meshes from the simplest mesh M 0 by using a sequence of vertex-split transformations that are dual to the corresponding edge collapse transformations: <ref type="bibr" target="#b19">[16]</ref> refers to M 0 ; fsplit0; split1; : : : ; s p l i t k 1 g as a progressive mesh representation. Progressive meshes present a novel approach to storing, rendering, and transmitting meshes by using a continuous-resolution representation. However we feel that there is some room for improvement in adapting them for performing selective refinement in an efficient manner. In particular, following issues have not yet been addressed by progressive meshes:</p><formula xml:id="formula_1">M 0 split 0 ! M 1 split 1 ! : : : M k 1 split k 1 ! M = M k (2) Hoppe</formula><p>The sequence of edge collapses is aimed at providing good approximations M i to M = M k . However, if a sequence of meshes M i are good approximations toM under some distance metric, it does not necessarily mean that they also provide a "good" sequence of edge collapse transformations for selective refinement. Let us consider a two-dimensional analogy of a simple polygon as shown in <ref type="figure" target="#fig_2">Figure 3</ref>. Assume that vertices v0; v 6 ; v 7 ;and v8 are "important" vertices (under say some perceptual criteria) and can not be deleted. An approach that generates approximations based on minimizing distances to the original polygon will collapse vertices in the</p><formula xml:id="formula_2">order v1 ! v2; v 2!v 3 ; v 3!v 4 ; v 4!v 5 ; v 5!v 6 to get a coarse polygon v0; v 6 ; v 7 ; v 8 . Then if selective refine- ment is desired around vertex v1, vertices v6; v 5 ; v 4 ; v 3 ; v 2</formula><p>will need to be split in that order before one can get to vertex v1. An approach that was more oriented towards selective refinement might have collapsed v1 ! v2; <ref type="bibr" target="#b5">6</ref> for better adaptive results, even though the successive approximations are not as good as the previous ones under the distance metric.</p><formula xml:id="formula_3">v 3!v 4 ; v 5! v 6 ; v 2 ! v 4 ; v 4 ! v</formula><p>Since the edge collapses are defined in a linear sequence, the total number of child links to be traversed before reaching the desired node is On.</p><p>No efficient method for incrementally updating the selective refinements from one frame to the next is given. The reverse problem of selective refinement -selective simplification too is not dealt with. In this paper we provide a solution to the above issues with the aim of performing real-time adaptive simplifications and refinements. We define a criterion for performing edge collapses that permits adaptive refinement around any vertex. Instead of constructing a series of sequential edge collapses we construct a merge tree over the vertices of meshM so that one can reach any child vertex in Olog n links. We then describe how one can perform incremental updates within this tree to exploit frame-to-frame coherence, viewdependent illumination, and visibility computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Image-Space-Guided Simplification</head><p>Level-of-detail-based rendering has thus far emphasized objectspace simplifications with minimal feedback from the image space. The feedback from the image space has been in the form of very crude heuristics such as the ratio of the screen-space area of the bounding box of the object to the distance of the object from the viewer. As a result, one witnesses coarse image-space artifacts such as the distracting "popping" effect when the object representation changes from one level of detail to the next <ref type="bibr" target="#b17">[14]</ref>. Attempts such as alpha-blending between the old and the new levels of detail during such transitions serve to minimize the distraction at the cost of rendering two representations. However alpha blending is not the solution to this problem since it does not address the real causelack of sufficient image-space feedback to select the appropriate local level of detail in the object space; it merely tries to cover-up the distracting artifacts.</p><p>Increasing the feedback from the image space allows one to make better choices regarding the level of detail selection in the object-space. We next outline some of the ways in which imagespace feedback can influence the level of detail selection in the object-space:</p><p>Local Illumination: Increasing detail in a direction perpendicular to, and proportional to, the illumination gradient across the surface is a good heuristic <ref type="bibr" target="#b0">[1]</ref>. This allows one to have more detail in the regions where the illumination changes sharply and therefore one can represent the highlights and the shadows well. Since surface normals play an important role in local illumination, one can take advantage of the coherence in the surface normals to build a hierarchy over a continuous resolution model that allows one to capture the local illumination effects well.</p><p>Screen-Space Projections: Decision to keep or collapse an edge should depend upon the length of its screen-space projection instead of its object-space length. At a first glance this might seem very hard to accomplish in real-time since this could mean checking for the projected lengths of all edges at every frame. However, usually there is a significant coherence in the ratio of the image-space length to the object-space length of edges across the surface of an object and from one frame to the next. This makes it possible to take advantage of a hierarchy built upon the the object-space edge lengths for an object.</p><p>Visibility Culling: During interactive display of any model there is usually a significant coherence between the visible regions from one frame to the next. This is especially true of the back-facing polygons that account for almost half the total number of polygons and do not contribute anything to the visual realism. A hierarchy over a continuous resolution representation of an object allows one to significantly simplify the invisible regions of an object, especially the back-facing ones.</p><p>Silhouette boundaries: Silhouettes play a very important role in perception of detail. Screen-space projected lengths of silhouette edges (i.e., edges of whose adjacent triangles is visible and the other is invisible), can be used to very precisely quantify the amount of smoothness of the silhouette boundaries. Again, a hierarchy built upon a continuous-resolution representation of a object allows one to do this efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Construction of Merge Tree</head><p>We would like to create a hierarchy that provides us a continuousresolution representation of an object and allows us to perform realtime adaptive simplifications over the surface of an object based upon the image-space feedback mechanisms mentioned in Section 3. Towards this end we implement a merge tree over the vertices of the original model. In our current implementation, the merge tree stores the edge collapses in a hierarchical manner. However, as we discuss in Section 7 the concept of a merge tree is a very general one and it can be used with other local simplification approaches as well. Note that the merge tree construction is done as an off-line preprocessing step before the interactive visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Basic Approach</head><p>In <ref type="figure" target="#fig_1">Figure 2</ref>, the vertex c is merged with the vertex p as a result of collapsing the edge pc. Conversely, during a vertex split the vertex c is created from the vertex p. We shall henceforth refer to c as the child vertex of the parent vertex p. The merge tree is constructed upwards from the high-detail meshM to a low-detail mesh M 0 by storing these parent-child relationships in a hierarchical manner over the surface of an object.</p><p>At each level l of the tree we determine parent-child relationships amongst as many vertices at level l as possible. In other words, we try to determine all vertices that can be safely merged based on criterion defined in Section 4.3. The vertices that are determined to be the children remain at level l and all the other vertices at level l are promoted to level l + 1 . Note that the vertices promoted to level l + 1 are a proper superset of the parents of the children left behind at level l. This is because there are vertices at level l that are neither parents nor children. We discuss this in greater detail in the context of regions of influence later in this section. We apply the above procedure recursively at every level until either (a) we are left with a user-specified minimum number of vertices, or (b) we cannot establish any parent-child relationships amongst the vertices at a given level. Case (b) can arise because in determining a parentchild relationship we are essentially collapsing an edge and not all edge collapses are considered legal. For a detailed discussion on legality of edge collapses the interested reader can refer to <ref type="bibr" target="#b20">[17]</ref>.</p><p>Since in an edge collapse only one vertex merges with another, our merge tree is currently implemented as a binary tree. In <ref type="figure" target="#fig_3">Figure 4</ref>, the three highest detail levels for a sphere are shown colored by the corresponding vertices in red, green, and yellow. The remaining levels are shown colored in blue. To create a reasonably balanced merge tree we try to collapse as many edges as possible at each level such that there are no common triangles in their respective regions of influence. Since this step involves only local checks, we can accomplish this step in time linear in the number of triangles at this level. If we assume that the average degree (i.e. the number of neighboring triangles) of a vertex is 6, we can expect the number of triangles in an edge's region of influence to be 10. After the collapse this number of triangles reduces to 8. Thus the number of triangles can be expected to reduce roughly by a factor of 4=5 from a higher-detail level to a lower-detail level. Thus the total time to build the tree is given by n + 4n</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">+ 16n</head><p>25 + : : :=O n .</p><p>To decide in what order to collapse the edges, we sort the edges by their edge lengths and collapse the shortest edges first. Collapsing an edge causes the neighboring edges to change their lengths. However as mentioned above, since changes are local we can maintain the sorted edge lengths in a heap for efficient updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Storing Subtree Attribute Ranges</head><p>To allow real-time refinement and simplification we can store at every parent node (i.e. a node that splits off a child vertex) of the merge tree, a range of scalar and vector attributes of the children in the subtree below it. Then image-space feedback can be used to determine if this range of scalar and vector attributes merits a refinement of this node or not. We explain this process of incremental refinement and simplification in greater details in Section 5.1.</p><p>In our current implementation every merge tree node v stores only the Euclidean distances to its child and parent that determine when v's child will merge into v and when v will merge into its parent. These distances are built up during the merge tree creation stage. However, we plan to extend this to store the surface normal and color ranges also, so that the incremental simplification and refinement stages can take advantage of the coherences across these vector attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Merge Tree Dependencies</head><p>By using techniques outlined in Section 5.1, one can determine which subset of vertices is sufficient to reconstruct an adaptive level-of-detail for a given object. However, it is not simple to define a triangulation over these vertices and guarantee that the triangulation will not "fold back" on itself or otherwise represent a non-manifold surface (even when the original was not so). <ref type="figure" target="#fig_4">Figure 5</ref> shows an example of how an undesirable folding in the adaptive mesh can arise even though all the edge collapses that were determined statically were correct. A shows the initial state of the mesh. While constructing the merge tree, we first collapsed vertex v2 to v1 to get mesh B and then collapsed vertex v3 to v4 to get mesh C. Now suppose at run-time we determined that we needed to display vertices v1; v 2 , and v4 and could possibly collapse vertex v3 to v4. However, if we collapse v3 to v4 directly, as in mesh D, we get a mesh fold where there should have been none. Checks for such conditions are too expensive to be performed at run-time. To solve the above problem we introduce the notion of dependencies amongst the nodes of a merge tree. Thus, the collapse of an edge e is permitted only when all the vertices defining the boundary of the region of influence of the edge e exist and are adjacent to the edge e. As an example, consider <ref type="figure" target="#fig_1">Figure 2</ref>. Vertex c can merge with vertex p only when the vertices n0; n 1 ; : : : ; n kexist and are adjacent to p and c. From this we determine the following edge collapse dependencies, restricting the level difference between adjacent vertices:</p><p>1. c can collapse to p, only when n0, n1, . . . , nk are present as neighbors of p and c for display. 2. n0; n 1 ; : : : ; n kcan not merge with other vertices, unless c first merges with p.</p><p>Similarly, to make a safe split from p to p and c, we determine the following vertex split dependency:</p><p>1. p can split to c and p, only when n0; n 1 ; : : : ; n kare present as neighbors of p for display.</p><p>2. n0; n 1 ; : : : ; n k can not split, unless p first splits to p and c.</p><p>The above dependencies are followed during each vertex-split or edge collapse during real-time simplification. These dependencies are easily identified and stored in the merge tree during its creation. Considering <ref type="figure" target="#fig_4">Figure 5</ref> again, we can now see that collapse of vertex v3 to v4 depends upon the adjacency of vertex v1 to v3. If vertex v2 is present then v1 will not be adjacent to v3 and therefore v3 will not collapse to v4. Although having dependencies might sometimes give lesser simplification than otherwise, it does have the advantage of eliminating the expensive floating-point run-time checks entirely. The basic idea behind merge tree dependencies has a strong resemblance to creating balanced subdivisions of quad-trees as presented by Baum et al in <ref type="bibr" target="#b1">[2]</ref> where only a gradual change is permitted from regions of high simplifications to low simplifications. Details of how these merge tree dependencies are used during run-time are given in Section 5.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Real-Time Triangulation</head><p>Once the merge tree with dependencies has been constructed offline it is easy to construct an adaptive level-of-detail mesh representation during run-time. Real-time adaptive mesh reconstruction involves two phases -determination of vertices that will be needed for reconstruction and determination of the triangulation amongst them. We shall refer to the vertices selected for display at a given frame as display vertices and triangles for display as display triangles. The phases for determination of display vertices and triangles are discussed next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Determination of display vertices</head><p>We next describe how we take into account the screen-space projections in determining which regions of an object to simplify more and which ones less. The heuristics for determining lighting, visibility culling, and silhouette boundaries are similar. As mentioned earlier, every merge tree node v stores a Euclidean distance for splitting a vertex to its child as well as the distance at which it will merge to its parent. The former is called the downswitch distance and the latter is called the upswitch distance. If the maximum possible screen-space projection of the downswitch distance at the vertex v in the object space is greater than some pre-set threshold T, we permit refinement at v and recursively check the children of v.</p><p>However, if the maximum possible screen-space projection of the upswitch distance at v in the object space is less than the threshold T, it means that this region occupies very little screen space and can be simplified, so we mark v as inactive for display. We follow this procedure and select all those vertices for display that either (a) are leaf nodes and none of their parents have been marked as inactive, or (b) have their immediate child marked as inactive. This determines the initial list of vertices selected for display.</p><p>We then follow the merge dependencies from the initial list of display vertices to select the final set of display vertices in the following manner. If a vertex v is in the initial list of display vertices and for it to be created (via a vertex split), the vertices vd 0 ; v d 1 ; : : : ; v d k had to be present, we add the vertices vd 0 ; v d 1 ; : : : ; v d k to the list of display vertices and recursively consider their dependencies. We continue this process until no new vertices are added.</p><p>When determining the vertices for display in frame i + 1 we start from the vertex list for display used in frame i. We have found a substantial frame-to-frame coherence and the vertex display list does not change substantially from one frame to the next. There are minor local changes in the display list on account of vertices either refining or merging with other vertices. These are easily captured by either traversing the merge tree up or down from the current vertex position. The scalar and vector attribute ranges stored in merge tree nodes can be used to guide refinements if the difference in the display vertex lists from one frame to the next becomes nonlocal for any reason. We compute the list of display vertices for first frame by initializing the list of display vertices for frame 0 to be all the vertices in the model and then proceeding as above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Determination of display triangles</head><p>If the display triangles for frame i are known, determination of the display triangles for frame i + 1 proceeds in an interleaved fashion with the determination of display vertices for frame i+1 from frame i. Every time a display vertex of frame i merges in frame i + 1 we simply delete and add appropriate triangles to the list of display triangles as shown in <ref type="figure" target="#fig_5">Figure 6</ref>. The case where a display vertex in frame i splits for frame i + 1 is handled analogously. Incremental determination of display triangles in this manner is possible because of the dependency conditions mentioned in Section 4.3. The list of display triangles for the first frame is obtained by initializing the list for frame 0 to be all the triangles in the model and then following the above procedure. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results and Discussion</head><p>We have tried our implementation on several large triangulated models and have achieved encouraging results. These are summarized in <ref type="table" target="#tab_0">Table 1</ref> The images of sphere, crambin, and bunny models that were produced for the above times are shown in <ref type="figure" target="#fig_0">Figures 1, 7</ref> and 8 respectively. All of the above timings are in milliseconds on a Silicon Graphics Indigo2 Impact with a 250 MHz R4400 processor and 128MB RAM. It is easy to see that the time to traverse the merge tree and construct the list of triangles to be displayed from frame to frame is fairly small. This is because of our incremental computations that exploit image-space, object-space, and frameto-frame coherences. The above times hold as the user moves the model, or the lights around. The triangulation of the model changes dynamically to track the highlights as well as the screen-space projections of the faces. As can be seen from the merge tree depths, the trees are not perfectly balanced. However, they are still within a small factor of the optimal depths. This factor is the price that has to be paid to incorporate dependencies and avoid the expensive run-time floatingpoint checks for ensuring good triangulations. For each dataset, we continued the merge tree construction till 8 or fewer vertices were left. As expected, the factor by which the number of vertices decreases from one level to the next tapers off as we reach lowerdetail levels since there are now fewer alternatives left to counter the remaining dependency constraints. As an example, for sphere, only 64 vertices were present at level 30 and it took another 12 levels to bring down the number to 8. If the tree depth becomes a concern one can stop sooner, trading-off the tree traversal time for the display time. An interesting aspect of allowing dependencies in the merge tree is that one can now influence the characteristics of the run-time triangulation based upon static edge-collapse decisions during preprocessing. As an example, we have implemented avoidance of slivery (long and thin) triangles in the run-time triangulation. As Guéziec <ref type="bibr" target="#b10">[11]</ref>, we quantify the quality of a triangle with area a and lengths of the three sides l0; l 1 ;and l2 based on the following formula:</p><formula xml:id="formula_4">Quality = 4 p 3 a l 2 0 + l 2 1 + l 2 2<label>(3)</label></formula><p>Using Equation 3 the quality of a degenerate triangle evaluates to 0 and that of an equilateral triangle to 1. We classify all edge collapses that result in slivery triangles to be invalid, trading-off quantity (amount of simplification) for quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Work</head><p>We have outlined a simple approach to maintain dynamically adaptive level of detail triangulations. Crucial to this approach is the notion of merge trees that are computed statically and are used during run-time to take advantage of the incremental changes in the triangulation. In our current implementation we are using the method of edge collapses. However the idea behind merge trees is pretty general and can be used in conjunction with other local heuristics for simplification such as vertex deletion and vertex collapsing. We plan to study some of these other heuristics in the future and compare them with our current implementation that uses edge collapses. At present we do not store surface normal or color ranges at the nodes of the merge tree. Storing and using these should improve the quality of the visualizations produced using merge trees even more. Also of some interest will be techniques that create better balanced merge trees while still incorporating dependencies. We plan to investigate these issues further.</p><p>Of course, our approach also makes dynamically-specified manual simplifications possible, where the user can interactively specify the amounts of approximation desired at various regions of the object. Using this, certain parts of the object can be rendered at lower or higher details than otherwise. However, in this paper we have only considered automatic object simplifications during interactive display.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>(a) Sphere with 8192 triangles (uniform LOD) (b) Sphere with 512 triangles (uniform LOD) (c) Sphere with 537 triangles (adaptive LOD) Uniform and Adaptive Levels of Detail</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Edge Collapse and Vertex SplitThus, a sequence of k successive edge collapse transformations yields a sequence of successively simpler meshes:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Good versus Efficient Selective Simplification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Three Levels in a Merge Tree for a Sphere To construct a balanced merge tree we note that the effects of an edge collapse are local. Let us define the region of influence of an edge v0; v 1 to be the union of triangles that are adjacent to either v0 or v1 or both. The region of influence of an edge is the set of triangles that can change as an edge is gradually collapsed to a vertex, for example, in a morphing. Thus, in Figure 2 as vertex c merges to vertex p, (or p splits to c), the changes to the mesh are all limited to within the region of influence of edge pc enclosed by n0; n 1 ; : : : n 6 . Note that all the triangles in region of influence will change if vertices p and c are merged to form an intermediate vertex, say p + c=2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Mesh Folding Problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Display Triangle Determination</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Adaptive Level of Detail Generation Times</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to acknowledge several useful discussions with Arie Kaufman and Greg Turk. We would like to thank Greg Turk and Marc Levoy for generously sharing their models of the phone and the bunny. We deeply appreciate the thorough review and detailed and insightful comments by the anonymous referees. This work has been supported in part by the National Science Foundation CA-REER award CCR-9502239.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="table">36  537  42  6  3  9  Bunny  69451  420  3615  65  90  20  110  Crambin 109955  530  7433  61  56  49  105  Phone  165963  1020  4351  63  29  36</ref> </div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards image realism with interactive update rates in complex virtual building environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Airey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Brooks</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (1990 Symposium on Interactive 3D Graphics)</title>
		<editor>Rich Riesenfeld and Carlo Sequin</editor>
		<imprint>
			<date type="published" when="1990-03" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Making radiosity usable: Automatic preprocessing and meshing techniques for the generation of accurate radiosity solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Winget</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH&apos;91</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="51" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hierarchical geometric models for visible surface algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="547" to="554" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Simplification envelopes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">V</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Series, ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">System strategies to optimize CIG image content</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cosman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Schumacker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Image II Conference</title>
		<meeting>the Image II Conference<address><addrLine>Scottsdale, Arizona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A more flexible image generation environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">C</forename><surname>Crow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH&apos;82</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1982" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="9" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Multiresolution analysis for surface of arbitrary topological type</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">D</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
		<idno>93- 10-05</idno>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Seattle, WA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1995-08-11" />
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH 95</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Séquin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1993-08-06" />
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH 93</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast multiresolution surface meshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gatti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;95 Proceedings</title>
		<editor>G. M. Nielson and D. Silver</editor>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Surface simplification with variable tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Symposium on Medical Robotics and Computer Assisted Surgery, MRCAS &apos;95</title>
		<meeting>the Second International Symposium on Medical Robotics and Computer Assisted Surgery, MRCAS &apos;95</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
	<note>Original molecular surface (109955 triangles</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Dynamic adaptive simplification (7433 triangles)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic Adaptive Simplification for Crambin Surface Original bunny model</title>
	</analytic>
	<monogr>
		<title level="j">Figure</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
	<note>69451 triangles</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Dynamic adaptive simplification</title>
		<imprint/>
	</monogr>
	<note>3615 triangles</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Dynamic Adaptive Simplification for Bunny Model</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A data reduction scheme for triangulated surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="197" to="214" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Controlled topology simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Graphics techniques for walkthrough applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Helman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive Walkthrough of Large Geometric Databases, Course Notes 32, SIGGRAPH &apos;95</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Geometric optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hinker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;93</title>
		<editor>Gregory M. Nielson and Dan Bergeron</editor>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="189" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series, ACM SIGGRAPH</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mesh optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<meeting><address><addrLine>Anaheim, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1993-08-06" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
	<note>Proceedings of SIG-GRAPH 93</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Visual navigation of large environments using textured clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">W C</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 Symposium on Interactive 3D Computer Graphics</title>
		<meeting>the 1995 Symposium on Interactive 3D Computer Graphics</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">IRIS performer: A high performance multiprocessing toolkit for real-Time 3D graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Helman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings, Annual Conference Series</title>
		<editor>Andrew Glassner</editor>
		<meeting><address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1994-07-29" />
			<biblScope unit="page" from="381" to="395" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;94</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Multi-resolution 3D approximations for rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993-07" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings SIGGRAPH &apos;92</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Re-tiling polygonal surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings SIGGRAPH &apos;92</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1992" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Hierarchical geometric approximations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<idno>TR-050-1994</idno>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="27599" to="3175" />
			<pubPlace>Chapel Hill, NC</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of North Carolina</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
