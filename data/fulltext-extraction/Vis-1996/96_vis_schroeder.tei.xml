<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Design and Implementation Of An Object-Oriented Toolkit For 3D Graphics And Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
						</author>
						<title level="a" type="main">The Design and Implementation Of An Object-Oriented Toolkit For 3D Graphics And Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The Visualization Toolkit (vtk) is a freely available C++ class library for 3D graphics and visualization. In this paper we describe core characteristics of the toolkit. This includes a description of object-oriented models for graphics and visualization; methods for synchronizing system execution; a summary of data representation schemes; the role of C++; issues in portability across PC and Unix systems; and how we automatically wrap the C++ class library with interpreted languages such as Java and Tcl. We also demonstrate the capabilities of the system for scalar, vector, tensor, and other visualization techniques. 1. Render Master-coordinates device-independent methods and creates rendering windows. 2. Render Window-manages a window on the display device. One or more renderers draw into a render window to generate a scene (i.e., final image). 3. Renderer-coordinates the rendering of lights, cameras, and actors. 4. Light-illuminates the actors in a scene. 5. Camera-defines the view position, focal point, and other camera characteristics. 6. Actor-an object drawn by a renderer in the scene. Actors are defined in terms of mapper, property, and a transform objects. 7. Property-represents the rendered attributes of an actor including object color, lighting (e.g., specular, ambient, diffuse), texture map, drawing style (e.g., wireframe or shaded); and shading style.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.0">Introduction</head><p>Two important trends are emerging in the computer industry. These are the development of object-oriented systems and the use of more complex user interface methods, especially the use of 3D computer graphics and visualization. Object-oriented systems offer the possibility to create better, more maintainable systems with reusable software components. Computer graphics offers a window into the computer and the virtual worlds created there; and when coupled with visualization, enables users to rapidly explore and understand complex systems. Taken together, these two trends will be major forces as the computer industry moves into the 21st century.</p><p>It is clear that 3D graphics and visualization are entering mainstream use. As evidence of this we cite the widespread use of 3D graphics in the entertainment and gaming industries, and its support on the PC. For example, there are now several 3D graphics software API's on the PC, including OpenGL <ref type="bibr" target="#b0">[1]</ref>, and hardware boards ranging in cost from hundreds to thousands of US dollars.</p><p>Object-oriented (OO) methods are now widely recognized as effective software design and implementation tools. Design methodologies from such researchers as Rumbaugh <ref type="bibr" target="#b1">[2]</ref> and Booch <ref type="bibr" target="#b2">[3]</ref> are receiving widespread attention, while C++ <ref type="bibr" target="#b3">[4]</ref>, SmallTalk <ref type="bibr" target="#b4">[5]</ref>, and other objectoriented languages have become widely successful software tools. Also, a variety of class libraries are available, ranging from standard data structures to mathematics and numerical equation solvers.</p><p>These trends have only recently converged (in the last half-decade) into object-oriented tools for 3D graphics and visualization. They have influenced commercial sys-tems such as AVS <ref type="bibr" target="#b5">[6]</ref>, IBM Data Explorer <ref type="bibr" target="#b6">[7]</ref>, and Iris Explorer <ref type="bibr" target="#b7">[8]</ref>, which exhibit object-oriented features such as modular and extensible components. However, despite such features, not all systems are implemented using OO techniques and languages, and are often difficult to use independent of their graphical user environment.</p><p>In this paper we describe our efforts towards building a object-oriented toolkit, referred to as vtk, for 3D graphics and visualization <ref type="bibr" target="#b8">[9]</ref>. We begin by listing our design goals and follow with an overview of our object design. In the implementation section we discuss many important issues such as graphics portability; design for an interpreted language; and our method for updating the visualization network. We conclude with examples to demonstrate central features of our design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.0">Design Goals</head><p>From the inception of the toolkit, we had a series of highlevel design goals. These goals were based on our previous work with a proprietary system we referred to as LYMB/VISAGE <ref type="bibr" target="#b9">[10]</ref> <ref type="bibr" target="#b10">[11]</ref>, as well as our experience dealing with user's of visualization systems. These goals are described in the subsections that follow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Toolkit Philosophy</head><p>One important lesson we learned is that building large, monolithic systems is detrimental to software flexibility. As a result, we wanted to create a sharply focused object library that we could easily embed and distribute into our applications. <ref type="figure" target="#fig_0">Figure 1</ref>(a) illustrates the basic idea. Toolkits enable complex applications to be built from small pieces. The key here is that the pieces must be well defined with simple interfaces. In this way they can be readily assembled into larger systems. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Interpreted Language Interface</head><p>Computer languages are usually one of two types: compiled or interpreted. Compiled languages are usually higher performing than interpreted languages, but interpreted languages offer greater flexibility. Our experience has shown that interpreted applications can be built significantly faster than compiled applications, mainly through the elimination of the compile/link cycle. (Shared libraries and incremental compilation techniques are improving the interactivity of compiled systems, but the gap remains.) Also, interpreted applications are often written at a higher level than compiled languages. This results in simpler, more compact code that is faster to write and debug. Compiled systems, however, are absolutely necessary when creating high-performing visualization applications. Compiled systems also offer low-level access to computer system resources.</p><p>We wanted our system to have the best of both the compiled and interpreted approaches <ref type="figure" target="#fig_0">(Figure 1(b)</ref>). As a result, we decided to build the core computational objects using a compiled language, and the higher level applications using an interpreted language. We also wanted to make sure that there was a crisp boundary between the compiled core and the interpreted language. This requirement ensured that the compiled core could be easily separated from the interpreted language and easily imbedded into applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Standards Based</head><p>In our prior work with the LYMB/VISAGE system, we used our own special methodology and the C programming language to build an object-oriented system. This system also featured our own interpreted scripting language. While this system served us well for over a dozen years, we soon found that it was an uphill battle to encourage others to adopt our methodology. We also found that the software support and maintenance burden increased dramatically as the system grew in complexity. As a result, we decided that the new system must use standard components and languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Portable</head><p>Years of experience with computer graphics has made us skeptical that any single graphics library will become a standard. Even OpenGL, which is a widely accepted 3D standard, may be supplemented or even superceded by the recent flurry of interest in 3D games, multi-media, and internet access. Consequently, we wanted a high-level abstraction for 3D graphics that would be independent of new incarnations of graphics libraries. In this way applications written in the system could be easily ported as new standards become available.</p><p>Compatibility issues also arise due to differing windowing systems on Unix, PC, and other platforms. Another important design goal was to keep the core system independent of windowing systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Freely Available</head><p>A pragmatic lesson of the computer industry is that for software to succeed, it must be widely used and sup-ported. As researchers we decided that the best way to accomplish this was to make the source code freely available. Anticipated benefits of this approach include the ability to better disseminate our algorithms, collaborate with other researchers, develop credibility in the graphics and visualization fields, and offer tools for educational and research purposes. We also knew that outside users would offer bug fixes and valuable suggestions to improve the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Simple</head><p>We often find that concepts that we take for granted in computer science and graphics are not always easily transferable to users of our visualization tools.These users are typically overwhelmed with their own work load (e.g., design, analysis, etc.), and cannot afford the time to learn and maintain a working knowledge base of computer graphics and visualization. Hence we have adopted the following quote from Albert Einstein as our credo: "Everything should be as simple as possible, but not simpler." By keeping the system simple, we expect to encourage wider use of visualization and 3D graphics. Other benefits of this philosophy include reduced effort to maintain, extend and interface to the toolkit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.0">Object Models</head><p>There are two distinct parts to our object design. The first is the graphics model, which is an abstract model for 3D graphics. The second is the visualization model, which is a data-flow model of the visualization process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Graphics Model</head><p>The graphics model captures the essential features of a 3D graphics system in a form that is easy to understand and use. The abstraction is based on the movie-making industry, with some influence from current graphical user interface (GUI) windowing systems.There are nine basic objects in the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Mapper -represents the geometric definition of an</head><p>actor and maps the object through a lookup table.</p><p>More than one actor may refer to the same mapper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9.</head><p>Transform -an object that consists of a 4x4 transformation matrix and methods to modify the matrix. It specifies the position and orientation of actors, cameras, and lights. <ref type="figure">Figure 2</ref> illustrates these concepts in concrete form. Note that derived objects of these base classes are available to extend the functionality of the toolkit. For example, the assembly object is a type of actor that enables hierarchical grouping of objects for purposes of property specification or collective transformation. Other objects, such as color lookup tables, also play an important role in the visualization system, but are not described here for brevity. To achieve portability of this design we developed the concept of device objects. These objects are derived classes of abstract superclasses, or extend the functionality of graphics classes in a device dependent way. An example of a derived device class is the OpenGL renderer. The OpenGL renderer is a subclass of the abstract superclass renderer. When the user constructs a generic renderer and rendering window in the system using the render master class, the render master instantiates the appropriate device-specific renderer. For example, on a Sun Unix system, the following code vtkRenderMaster rm; renderWindow = rm.MakeRenderWindow(); aRen = renderWindow-&gt;MakeRenderer(); creates a device-dependent render window appropriate to the system's windowing system (i.e., X Windows), and a device-dependent renderer appropriate to the graphic library (i.e., Sun's XGL). The same code run on a PC, however, would create a Windows rendering window, and an OpenGL renderer.</p><p>Lights, cameras, properties, and actors are examples of generic objects that have device-dependent counterparts (e.g., OpenGL actor, OpenGL light, etc.). When these generic objects are created, device dependent objects are created automatically that interface to the appropriate graphics library. This is generally transparent to the user, and ensures that all applications are completely indepen-dent of the particular graphics library. In fact, to port an application to a new graphics library, only the device dependent objects need be coded. The application itself remains unchanged.</p><p>Our graphics design compares favorably to Open Inventor <ref type="bibr" target="#b11">[12]</ref>, which is a commercial toolkit available from SGI. In the Inventor model, the abstract model is based on a scene graph. A scene graph is an acyclic, directed graph of nodes, where nodes correspond to such objects as actors, lights, cameras, properties, and transforms. The major difference is that the Inventor model closely follows the state-machine based, graphics engine that is implemented in OpenGL. The rendering process is a traversal of the graph, where each node affects the current state of the rendering process. Thus, the order of the nodes in the graph has significant impact on the final image. Although the state-based traversal is powerful and efficient, it does violate a fundamental tenet of object-oriented design. That is, the behavior of every object is completely determined from its inputs and local instance variables. In a scene graph, changes to a node in the graph can affect objects downstream of the graph traversal. Also, the scene graph model is not intuitive to many graphics programmers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Visualization Model</head><p>The vtk model is based on the data-flow paradigm adopted by many commercial systems. In this paradigm, modules are connected together into a network. The modules perform algorithmic operations on data as it flows through the network. The execution of this visualization network is controlled in response to demands for data (demand-driven) or in response to user input (eventdriven). The appeal of this model is that it is flexible, and can be quickly adapted to different data types or new algorithmic implementations.</p><p>Our visualization model consists of two basic types of objects: process objects and data objects (see <ref type="figure">Figure 3</ref>). Process objects are the modules, or algorithmic portions of the visualization network. Data objects, also referred to as datasets, represent and enable operations on the data that flows through the network.</p><p>Process objects may be further classified into one of three types: sources, filters, and mappers. Source objects initiate the network and generate one or more output datasets. Filters require one or more inputs and generate one or more outputs. Mappers, which require one or more inputs, terminate the network.</p><p>In our toolkit we initially selected five types of data as shown in <ref type="figure" target="#fig_1">Figure 4</ref>. As indicated by this figure, an abstract interface to data is specified by the dataset object. Subclasses of dataset include polygonal data (corresponding to the graphics data vertices, lines, polygons, and triangle strips), structured points (representing both 2D images and 3D volumes), and structured and unstructured grids (e.g., finite difference grids and finite element meshes). In addition, it was convenient to define another abstract object, point set, which is a superclass of objects with explicit point coordinate representation. The fifth data type, unstructured points, was not implemented because it could be represented by one or more of the other types. (Unstructured points are point locations without an topological relationship to one another.) An important feature of our data model is the concept of cells. A dataset consists of one or more cells. Each cell is considered to be atomic visualization primitive. Cells represent topological relationships between the points that compose the dataset. The primary function of cells is to locally interpolate data or compute derivatives of data. In vtk, twelve cell types ranging from the 0D vertex to the 3D hexahedron are recognized. Each is a subclass of the abstract cell class, and additional cell types may be easily derived. Note that cells are not necessarily explicitly represented by datasets. For example, the voxel cells in a volume (i.e., structured points dataset) are not explicitly represented since this would incur a severe storage penalty. Instead, when the system requests a particular voxel, the voxel is built on the fly from the dimensions, origin, and aspect ratio of the volume, and the cell id of the voxel.</p><p>One nice feature of our object-oriented design is that we can take advantage of the dataset inheritance hierarchy to construct generic or specific process objects. Generic process objects operate on datasets -the particular type of dataset is immaterial to the operation of the filter. On the other hand, process objects can be specially constructed for a particular dataset type. For example, the contour filter operates on any dataset type, generating point, line, and surface primitives depending upon the input type. The decimation filter, however, has been specifically constructed to operate on polygonal data, allowing the implementor to make performance enhancing assumptions about the nature of the data. This allows the implementor of process objects to make a trade-off between generality and efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Object-Oriented Design Issues</head><p>To the OO purist, the design of our visualization system poses some problems. In usual OO design, data structures and methods are encapsulated into objects. In our design, algorithms (i.e., methods) and datasets (i.e., data structures) are encapsulated separately.</p><p>Our departure from what might be considered a purer OO design is based on three factors. First, combining complex algorithms and datasets into a single object would result in excessively large objects. The simplicity and modularity of the resulting design would be compromised. Second, combining algorithms and datasets into objects would result in repeating code, since the implementation of an algorithm for different data types often differs only in regions of data access. Third, users naturally view algorithms as objects that operate on data objects. Thus the design is comfortable to users, which is a key element of good system design.</p><p>Other researchers disagree with our view. In particular Favre <ref type="bibr" target="#b12">[13]</ref> has presented a design that encapsulates data objects and algorithms into single objects. We expect that this will remain an open research issue as visualization systems becomes more widely used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.0">Implementation Issues</head><p>While a high-level object design goes a long way towards creating useful systems, the implementation details often make or break the user acceptance of a system. In this section we describe some key issues we addressed to make our system easier to use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Programming Languages</head><p>Our choice of compiled language was predicated on the need for an efficient, object-oriented core. C++ fulfills these requirements <ref type="bibr" target="#b3">[4]</ref>. In addition, C++ offers other important features. It is widely used with a large selection of development tools and compilers. C++ is also a strongly typed language. This feature is used in our toolkit to enforce (at compile time) correct connectivity between process and data objects in the visualization network.</p><p>We constrained our use of C++ to conservative features. Multiple inheritance was abandoned early due to the resulting complexity and problems with compilers. Advanced features like templates and exception handling were also ignored, mainly due to the fact that the compilers we used at the time we started implementation were unreliable. (Since the initial implementation we have used templates effectively.) We found the language easy to work with when used this way. Since we architected our toolkit to include an interpreted language completely independent of the core compiled language, we had a number of possible interpreted languages to choose from. Our initial choices were Tcl, Python, and Perl, languages used by many software developers. For our initial interpreted language we decided to use Tcl <ref type="bibr" target="#b13">[14]</ref>. Our choice was based on the relative popularity of Tcl, and because of the Tcl-based Tk widget set. Tcl/Tk is a powerful development environment offering portable GUI development on Unix and Windows systems. Since we choose Tcl/Tk, we are able to build complex user interfaces on top of our toolkit, as well as interface to the many Tcl/Tk packages.</p><p>The size of our compiled toolkit (100,000+ LOC) made it infeasible to manually "wrap" it with Tcl. Instead, we built a simplified C++ parser to automatically generate Tcl wrapper code <ref type="bibr" target="#b14">[15]</ref>. Because the parser recognized certain coding conventions we had adopted, it was easier to create than a formal C++ parser. Well over 90% of the public methods are automatically wrapped in this way. (A small hints file was created to help the parser correctly interpret ambiguous or more complex statements.) Approximately 70,000 lines of wrapper code were generated using this approach.</p><p>Since the implementation of our Tcl/Tk interpreted layer, Java <ref type="bibr" target="#b15">[16]</ref> has emerged as arguably the best known interpreted language. Using our simple parser, we were able to wrap our library with Java over the course of two months (most of the time was spent learning the internals of Java.) Our ability to wrap the core with Java validated our toolkit architecture, and indicates that using other interpreted languages is an open possibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Conventions</head><p>We adopted a number of conventions that accelerated our implementation efforts, including documentation efforts. Some simple conventions include using a standard, long, and descriptive naming scheme for objects, methods, and variables; adopting standard templates and styles for coding; and applying a vtk prefix to object names to avoid namespace collision with other C++ class libraries. However, the two most important conventions we used were embedding of documentation directly into the source code and the use of standard Set/Get methodology to read and write object instance variables.</p><p>Embedding the documentation directly in the code served two important functions. First, it allows developers to directly pursue on-line source and header files for information about particular objects. Second, it allows us to automatically generate manual pages and HTML web documents. The benefit is that the chore of documentation is distributed into the implementation of the object. Thus documentation is just part of coding an object. When updated documents are required, a simple procedure is initiated that can generate the documents automatically.</p><p>For reading and setting the value of object instance variables, we used a standard array of Set/Get macros. These macros provide a uniform interface to objects, as well as enforce uniform object behavior. For example, one important feature of our system is that every object maintains an internal modification time. (This fact will become important when we discuss network execution shortly.) The Set macros insure that the modification time is correctly maintained. When setting an instance variable, these macros compare old values with new ones, only updating the modification time of the object if the value of the instance variable has changed. In addition, the macros can be enabled to print out debugging information, if desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Network Topology and Execution</head><p>Building visualization networks is a process of connecting process and data objects ( <ref type="figure" target="#fig_2">Figure 5(a)</ref>). The major issue here is to make sure that the input(s) to a process object are of the correct type, and that non-terminating loops in the network are correctly managed. Once a proper network is constructed, a mechanism is required to update the network as input data or object parameters change.</p><p>The strong type checking of C++ plays an important role here. The SetInput() method of a filter only accepts the specified dataset class or its subclasses. To connect the output of filter A to the input of filter B, a construct of the following form is used (expressed in C++):</p><formula xml:id="formula_0">B-&gt;SetInput( A-&gt;GetOutput() );</formula><p>Thus A's output type must be the same as B's input type, or a subclass of B's input type.</p><p>Looping in a network occurs when the input to an object B is the output of an object D, where D depends on the output of B <ref type="figure" target="#fig_2">(Figure 5(b)</ref>). Although such situations are not common, in some cases they can be used to advantage. For example, numerical integration of a set of points through a vector field can be simulated by the network of  <ref type="figure" target="#fig_2">Figure 5(b)</ref>. Here, the motion of the point set P is controlled by the vector values at P, and as P moves, vector values are resampled at P's new positions. The process repeats, moving P through the dataset. In vtk, infinite looping is prevented by setting an internal flag. Process objects set this flag when they begin to execute. This flag prevents infinite recursion from occurring if the execution of the network happens to return to the object. Thus, loops are allowed but only executed once per network execution.</p><p>The execution of the network is based on an implicit scheme. In this scheme each process object maintains an internal modification time and execution time. Then, when output from a process object A is requested, A compares its internal modified time and the modified time of its inputs against its last execution time. If A has been modified, or its inputs modified more recently than its last recorded compute time, then A will re-execute. There are two parts to updating the network using this implicit scheme: an update pass that compares modified and execution times, and an execution pass in which process objects may be re-executed to bring them up to date.</p><p>Most commercial systems use a graphical interface to select, connect, and execute visualization networks. While extremely powerful, the graphical interface is often an obstacle to creating networks with branching or conditional execution, or it complicates embedding visualization networks into an application. Although solutions have been proposed for this problem <ref type="bibr" target="#b16">[17]</ref>, the implementation of our toolkit using procedural languages makes selective network execution easy to program and control. It also simplifies embedding our toolkit into applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Memory Management</head><p>A major concern when implementing visualization in data-flow form is the amount of memory consumed. The toolkit addresses this issue by implementing a referencecounting scheme, and allowing the user to tailor the network to favor computation or memory.</p><p>Reference counting allows process objects to share data objects, or portions of data objects. As the top half of <ref type="figure">Figure 6</ref> illustrates, if portions of data are passed through the network unchanged, the data can be referenced by other objects without duplication. The key to this approach is to keep track of the number of objects referring to a reference counted object. When the reference count goes to zero, the referenced object automatically deletes itself.</p><p>In some applications memory resources are scarce, while in others the cost to compute the output of a filter or network is high. The toolkit provides facilities to accommodate these needs. Networks can be tailored to favor memory preservation at the expense of additional computation, or computation can be favored at the expense of additional memory requirements, or a combination of both. These capabilities are implemented by providing flags to control the automatic deletion of output data as the network executes. For example, as the bottom half of <ref type="figure">Figure 6</ref> illustrates, if the flag is enabled and memory resources are favored, after the process object B finishes execution, it signals its input process object A to delete its output data. Favoring memory means that A will always re-execute if any part of the network that depends on A needs to re-execute. On the other hand, if computation is favored, A will not re-execute unless it or its input data is modified. Instead, A maintains its output in memory, and can provide it without computation to B when necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Issues in Object-Oriented Implementation</head><p>A major criticism of object-oriented systems is that often they are slower performing than equivalent systems implemented in conventional procedural languages. This is due to the requirement to copy data between objects to preserve object encapsulation, the access of object instance variables through formal methods, and the overhead of constructing and deleting objects.</p><p>While we have found this performance penalty to be real, its effect can be minimized in three ways. First, the system must not create and destroy large numbers of objects. For example, in vtk there is a points object that represents an array of x-y-z coordinates. An inefficient implementation would represent each point with a separate object, requiring excessive constructor/destructor overhead and data access. Second, the amount of data copying must be minimized. Instead, large pieces of data (i.e., datasets), are encapsulated as an object, and then a references to this object are exchanged as the data moves through the system. Finally, C++ offers an inline capability. This can greatly improve system performance by eliminating function call overhead. However, the inline capability has no effect if the methods are dynamically bound, or if the compiler chooses to ignore the inline directive, so this capability is often limited.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.0">Examples</head><p>The following examples illustrate the use of the toolkit in practical application. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Hello Cone -C++ version</head><p>In this example we create and render a cone represented with a polygonal mesh. (The original idea for this example is adapted from Wernecke's Inventor Mentor <ref type="bibr" target="#b11">[12]</ref>.) The example is implemented in C++ and shows a simple pipeline with no intermediate filters. There are some important features of this example. First, the vtkRenderWindowInteractor is a 3D widget. It captures mouse and keystroke events in the rendering window. Typical functions include wireframe/surface display, picking, and a toggle into 3D stereo viewing. Second, because lights and a camera are not created, the system automatically creates them. Finally, this source code will compile and run on any Unix (using OpenGL, GL, Sun's XGLR, or HP's Starbase renderer), or Windows 95 or NT system (using OpenGL). The system automatically selects the correct renderer based on what's available on the system. Also notice the use of the SetInput()/GetOutput() methods to construct the visualization pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Hello Cone -Tcl/Tk version</head><p>In this example, the previous example is repeated except that it is implemented using the Tcl interpreter. Note that a special Tk interface is included (i.e., vtkInt.tcl). This is an interpreter widget and allows interactive modification to the application.  Color Plate 1 shows the output of this example including the Tcl/Tk interpreter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Generate An Isosurface</head><p>In the next example we show a portion of a network used to read 16-bit medical data and generate isosurfaces <ref type="bibr" target="#b17">[18]</ref> for skin and bone. The example is implemented in C++ and the results are shown in Color Plate 2.</p><p>// read the volume vtkVolume16Reader *v16=new vtkVolume16Reader;</p><p>v16-&gt;SetDataDimensions(64,64); v16-&gt;SwapBytesOn(); v16-&gt;SetFilePrefix ("../../../data/headsq/quarter"); v16-&gt;SetImageRange(1, 93); v16-&gt;SetDataAspectRatio (3.2, 3.2, 1.5); // extract the skin vtkMarchingCubes *skin=new vtkMarchingCubes; skin-&gt;SetInput(v16-&gt;GetOutput()); skin-&gt;SetValue(0, 500);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Decimate and Smooth Polygonal Mesh</head><p>In this example we read a Cyberware laser digitizer file, decimate (i.e., reduce polygon count) <ref type="bibr" target="#b18">[19]</ref>, and Laplacian smooth <ref type="bibr" target="#b19">[20]</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Other Examples</head><p>The Visualization Toolkit is comprised of over 300 classes.</p><p>Visualization techniques for scalar, vector, and tensor visualization are available. Modelling algorithms such as decimation, implicit modelling, extrusion, texture cutting, Delaunay triangulation, splatting, and glyphing can also be used to create complex visual displays. Color Plates 4 through 10 demonstrate capabilities of vtk. Plate 4 shows a cut plane through a structured grid. Plate 5 shows streamtubes in a vector flowfield. Plate 6 is the visualization of a quadric function showing 2D and 3D contours and cut planes. Plate 7 shows four hyperstreamlines <ref type="bibr" target="#b20">[21]</ref> in a tensor field. The tensor field is generated from a point load in a semi-infinite domain. In Plate 8 is an example of multidimensional, unstructured data visualization for financial loan data. The axes are monthly payment, interest rate, and loan amount. The grayish wireframe surface shows the total data population, and the red surface show accounts that are delinquent on loan payment. Plate 9 shows the application of transparent textures <ref type="bibr" target="#b21">[22]</ref> to cut-away and reveal the inner structure of a mechanical assembly.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1</head><label>1</label><figDesc>System</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4</head><label>4</label><figDesc>Dataset types. a) polygonal data, b) structured points, c) structured grid, d) unstructured grid, e) unstructured points, f) object diagram using OMT [2] notation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5</head><label>5</label><figDesc>: C to B to (A and D) Execute (If A modified): A then B then C Network</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>an actor and give it cone geometry vtkConeSource *cone = new vtkConeSource; cone-&gt;SetResolution(8); vtkPolyMapper *mapper = new vtkPolyMapper; mapper-&gt;SetInput(cone-&gt;GetOutput()); vtkActor coneActor = new vtkActor; coneActor-&gt;SetMapper(mapper); // assign our actor to the renderer ren-&gt;AddActors(coneActor); // draw the resulting scene win-&gt;Render(); //start event loop iren-&gt;Start(); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>source</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Visualization model. Process objects A, B, C input and/or output one or more data objects. Data objects represent and provide access to data; process objects operate on the data. Objects A, B, and C are source, filter, and mapper objects, respectively.</figDesc><table><row><cell>Render master creates rendering windows</cell><cell cols="2">Instances of render window Renderer instances Camera defines view Lights illuminate</cell><cell>dataset A output Figure 3 A</cell><cell>input</cell><cell>B</cell><cell>dataset B</cell><cell>C</cell></row><row><cell cols="2">Actor instances</cell><cell>scene</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Property</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Transform</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Mapper (geometry)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Figure 2 Graphics model</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>the polygonal mesh. (Surface normals are also calculated.) A portion of the network implemented in Tcl is shown. The resulting image is shown in Color Plate 3.</figDesc><table><row><cell>vtkPolyNormals normals;</cell></row><row><cell>normals SetInput [smooth GetOutput];</cell></row><row><cell>vtkPolyMapper cyberMapper;</cell></row><row><cell>cyberMapper SetInput [normals GetOutput];</cell></row><row><cell>vtkActor cyberActor;</cell></row><row><cell>cyberActor SetMapper cyberMapper;</cell></row><row><cell>eval [cyberActor GetProperty]</cell></row><row><cell>SetColor 1.0 0.49 0.25;</cell></row><row><cell>vtkCyberReader cyber;</cell></row><row><cell>cyber SetFilename "../../data/fran_cut"</cell></row><row><cell>vtkDecimate deci;</cell></row><row><cell>deci SetInput [cyber GetOutput];</cell></row><row><cell>deci SetTargetReduction 0.9;</cell></row><row><cell>deci SetAspectRatio 20;</cell></row><row><cell>deci SetInitialError 0.0002;</cell></row><row><cell>deci SetErrorIncrement 0.0005;</cell></row><row><cell>deci SetMaximumIterations 6;</cell></row><row><cell>vtkSmoothPolyFilter smooth;</cell></row><row><cell>smooth SetInput [deci GetOutput];</cell></row><row><cell>smooth SetNumberOfIterations 20;</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.0">Conclusion</head><p>We have developed a toolkit for 3D graphics and visualization. The toolkit core is implemented as a compiled C++ class library, and an interpreted application layer has been implemented in Tcl/Tk. We have successfully built applications in both C++ and Tcl, and have been able to embed the C++ toolkit into other systems. As anticipated, we have found the toolkit easy to use, extend, and maintain, and found that applications are portable across Unix and PC's.</p><p>The software is freely available and can be found at http://www.cs.rpi.edu/~martink . We welcome all comments, suggestions, bug reports, and contributions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">OpenGL Programming Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Neider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mason</forename><surname>Woo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Object-Oriented Modeling and Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Premerlani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Eddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Object-Oriented Design with Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<publisher>Benjamin/ Cummings Publishing Co</publisher>
			<pubPlace>Redwood City, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The C++ Programming Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Stroustrup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Smalltalk-80: The Interactive Programming Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Application Visualization System: A Computational Environment for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
	<note>Kamins and others</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Data Explorer Reference Manual, IBM Corp</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IRIS Explorer User&apos;s Guide</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
	<note>Silicon Graphics Inc.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit An Object-Oriented Approach to 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Prentice Hall</publisher>
			<pubPlace>Upper Saddle River, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Run-Time Interpreted Environment for Rapid Application Development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Montanaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Yamrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GE Corporate R&amp;D Report No. 91CRD266</title>
		<imprint>
			<date type="published" when="1991-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">VISAGE: An Object-Oriented Visualization System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Montanaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Volpe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;92</title>
		<meeting>of Visualization &apos;92<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="219" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wernecke</surname></persName>
		</author>
		<title level="m">The Inventor Mentor</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Object Oriented Design for the Visualization of Multi-Variate Data Objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Favre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;94</title>
		<meeting>of Visualization &apos;94<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="319" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Tcl and the Tk Toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<publisher>Addison-Wesley Publishing Company</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An Approach to the Automatic Wrapping of a C++ Class Library into Tcl</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Submitted to Tcl/Tk Workshop &apos;96</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ritchey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Java! New Riders Publishing</publisher>
			<pubPlace>Indianapolis, IN.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An Extended Data-Flow Architecture for Data Analysis and Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Treinish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;95</title>
		<meeting>Visualization &apos;95<address><addrLine>CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="363" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Decimation of Triangle Meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH `92)</title>
		<meeting>SIGGRAPH `92)</meeting>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">25</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Signal Processing Approach to Fair Surface Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;95</title>
		<meeting>SIGGRAPH &apos;95</meeting>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="351" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Visualizing Second-Order Tensor Fields with Hyperstreamlines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Delmarcelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="25" to="33" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Geometric Clipping with Boolean Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;93</title>
		<meeting>of Visualization &apos;93<address><addrLine>Los Alamitos, CA, Press</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="268" to="274" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
