<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Complex-Valued Contour Meshing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Weigle</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Mississippi State University</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">C</forename><surname>Banks</surname></persName>
							<email>banks@cs.msstate.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Mississippi State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Complex-Valued Contour Meshing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.1.5 [Numerical Analysis] Roots of Nonlinear Equations</term>
					<term>G.1.6 [Numerical Analysis] Optimization</term>
					<term>G.2.1 [Discrete Mathematics] Combinatorics</term>
					<term>I.3.5 [Computer Graphics] Computational Geometry and Object Modeling</term>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques</term>
					<term>J.2 [Physical Sciences and Engineering] Mathematics and Statistics</term>
				</keywords>
			</textClass>
			<abstract>
				<p>An isovalue contour of a function of two complex variables defines a surface in four-space. We present a robust technique for creating polygonal contours of complex-valued functions. The technique, Contour Meshing, generalizes well to larger dimensions.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This paper describes a recursive technique to construct a triangle mesh on an implicit surface (also called a variety or contour) in 4-space. The technique readily extends to large dimensions. We explore the resulting family of surfaces with an interactive 4D viewer in order to inspect the behavior of a complex curve as it sweeps through a singularity.</p><p>The k-dimensional analog of a surface is called a k-manifold. It is known that a k-manifold cannot necessarily be triangulated unless it is differentiable <ref type="bibr">[Cairns]</ref>. An implicitlydefined contour might not be differentiable, so one might imagine that some exotic contour could arise that prevents any algorithm from triangulating it. Fortunately, a contour is guaranteed to be triangulable if the underlying function is algebraic <ref type="bibr">[Waerden]</ref> or analytic <ref type="bibr">[Koopman]</ref>; our aim of triangulating a contour in large dimensions is therefore not undertaken in vain.</p><p>Various triangulation techniques have been developed for computer graphics <ref type="bibr">[Koide]</ref>  <ref type="bibr">[Lorensen]</ref>  <ref type="bibr" target="#b3">[Bloom88]</ref> and numerical analysis <ref type="bibr" target="#b0">[Allgower90]</ref>  <ref type="bibr" target="#b1">[Allgower91]</ref>. Many of these techniques are designed specifically to construct triangulations only of curves, surfaces, or varieties of codimension one (several having been implemented as part of the Pisces project at the Geometry Center <ref type="bibr">[Pisces]</ref>). The Contour Meshing algorithm, by contrast, is quite general. It consults m functions in (k+m)-dimensional space to yield an implicit k-dimensional contour.</p><p>Section 2 describes the Contour Meshing scheme used to locate isosurfaces in 4-space. Section 3 describes the methods used for viewing the implicit surfaces in 4-space and varying a contour parameter t. Finally, section 4 presents statistics resulting from triangulating the implicit surfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Contour Meshing Algorithm</head><p>This section presents simple recursive routines that can be combined to triangulate k-dimensional contours. The contours arise from the set of scalar-valued functions f : R R with f = c for constants c , where 1 I n-k. The</p><formula xml:id="formula_0">i i i i n</formula><p>first routine triangulates the domain; the second locates the contour.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Splitting a Cell into Simplexes</head><p>Recall that a square is a 2-cell, a cube is a 3-cell, a "hypercube" is a 4-cell, and so on (figure 1). Also recall that a triangle is a 2-simplex, a tetrahedron is a 3-simplex, a "hypertetrahedron" is a 4-simplex, and so on (figure 2). Euclidean space R is conveniently tiled by n-cells, but we n wish to split the cells into simplexes prior to contouring. Triangulating the cells avoids ambiguities <ref type="bibr">[Nielson]</ref> that arise when a contour crosses a cell. There are various ways to perform the split <ref type="bibr" target="#b1">[Allgower91]</ref>. We chose a method that  . The cell's midpoint connects to each face to produce six pyramids (middle). The midpoint of a pyramid's base produces four 3-simplexes (right). <ref type="bibr">square)</ref> foreach edge in square do</p><formula xml:id="formula_1">splitC2 (square, simplex) simplex.p[2] midpoint (</formula><formula xml:id="formula_2">simplex.p[0..1] edge.p[0..1] splitC3 (cube, simplex) simplex.p[3] midpoint (cube)</formula><p>foreach square in cube do splitC2 (square, simplex) splitC4 (hypercube, simplex) simplex.p[4] midpoint <ref type="bibr">(hypercube)</ref> foreach cube in hypercube do splitC3 (cube, simplex)</p><formula xml:id="formula_3">split (cell, simplex, n) if (n &gt; 1) then simplex.p[n] midpoint (cell) foreach subcell in cell do split (subcell, vertex, n-1) else simplex.p[0..1] cell.p[0..1] /* simplex.p[0.</formula><p>.n] now contains a simplex */ can be formulated to work in arbitrary dimension and that can also be applied to other polytopes in addition to the ncell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Splitting a 2-cell</head><p>First consider the 2D case, splitting a 2-cell into four 2-simplexes (squares into triangles). Each edge in the cell can combine with the cell's midpoint to form a 2-simplex (figure 3). The process is analogous to barycentric subdivision of a simplex. The splitC2 routine gives pseudocode for this operation in a 2-cell. The datatype for simplex and edge contains an array p[0..dim] of vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Splitting a 3-cell</head><p>Next consider the 3D case. We want to split a 3-cell into 3-simplexes (cubes into tetrahedra). Each face in the cell can combine with the 3-cell's midpoint to form a pyramid. If each face is further split into four triangles the result is four tetrahedra rather than one square pyramid, a step performed by the previous routine. The process is sketched in <ref type="figure" target="#fig_1">figure 4</ref>, and pseudocode is given as splitC3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Splitting a 4-cell</head><p>Now consider the 4D case. We want to divide a 4-cell into 4-simplexes (hypercubes into hypertetrahedra). Again, we start by finding the midpoint of the cell. Then for each 3-cell "face" in the 4-cell (cube in the hypercube) we apply the previous routine, chopping the cube into its constituent tetrahedra. The tetrahedron, together with a midpoint, yields a 4-simplex. Pseudocode is given as splitC4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Splitting an n-cell</head><p>This process generalizes to solve the problem of splitting n-cells into n-simplexes. The routines can be written recursively, passing each sub-cell to the next recursive level and terminating the subdivisions upon reaching the 1-cell (edge). Pseudocode for splitting the n-cell is given in split. Selecting the (n-1)-cells from an n-cell is simply a matter of combinatorics.</p><p>This midpoint-splitting scheme generates 2 n! simplexes n-1 from an n-cell; there are other techniques <ref type="bibr" target="#b1">[Allgower91]</ref> that generate only n! simplexes. The midpoint scheme is therefore easy to encode but inefficient in simplex production, a familiar trade-off. As section 4 shows, however, the actual number of contour-triangles produced is, in practice, much lower than this worst-case analysis would suggest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Contouring the Simplexes</head><p>A contour of a 1-simplex (segment) is a single point p such that f(p) = c for some constant c. Assume, without loss of generality, that c = 0. We will not treat the degenerate case where f = 0 identically across the entire simplex; the problem of simplexes not transverse to f is addressed elsewhere <ref type="bibr" target="#b1">[Allgower91]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contouring a 1-simplex</head><p>To determine whether the function f crosses zero on an edge, we check for a sign change at the endpoints. Thus, that there is a zero-crossing in the interval between vertices v and v . Note that the reverse implication does not hold; the 1 2 mesh must be sufficiently fine to resolve a zero-crossing that lies within a simplex. In the pseudocode contourS1 below, triangulate (polytope, simplex, n) if (n &gt; 1) then</p><formula xml:id="formula_4">f(v ) f(v</formula><formula xml:id="formula_5">simplex[n] midpoint (polytope)</formula><p>foreach subpoly in polytope do triangulate (subpoly, simplex, n-1) else</p><formula xml:id="formula_6">simplex[0..1] polytope[0..1]</formula><p>the test for a zero-crossing is encoded by the if-statement.</p><p>pseudocode contourS4 demonstrates the method for finding The contour point on an edge can be located with a linear contours in 4-simplexes. approximation or with an iterative root-finding scheme. We leave the details to a "black-box" calculation performed by the routine contourPoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contouring a 2-simplex</head><p>A contour within a 2-simplex (triangle) is approximated by contourS3, then to tetrahedra and hypertetrahedra in a segment. Each endpoint of the segment is a point that lies contourS4. These individual routines can be subsumed by a on an edge of the triangle. We loop over the edges (each single a recursive solution to find the contour in an edge being a sub-simplex of the triangle), locate zeron-simplex. The pseudocode is shown below as contour. crossings, and then connect them to form a contour-segment in the triangle. The endpoints defining the contour-segment are found via a call to contourS1. Pseudocode for the 2D case is given below as contourS2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contouring a 3-simplex</head><p>Bloomenthal describes how to find contours in 3-simplexes it can itself be approximated by simplexes. The routine split (tetrahedra) by enumerating combinations of zero-crossings can be adapted to split a polytope into simplexes, and is into a table <ref type="bibr" target="#b4">[Bloom94]</ref>. <ref type="table">The table provides an explicit</ref> given below as triangulate. Its only essential difference construction of a contour. By contrast, we seek a procedural from split is that it loops over sub-polytopes (rather than approach that mimics the sequence of steps applied to a sub-cells) along the boundary of the polytope. triangle. To construct the contour-polygon in a tetrahedron, we loop over its four triangular faces, then connect contoursegments found within them in order to form a contourpolygon in the tetrahedron. Note that the polygon may have either three or four edges. (The four-edge case may actually be non-planar, so calling it a polygon is technically an abuse of terminology.) The pseudocode is given below as contourS3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contouring a 4-simplex</head><p>To find a contour in a 4-simplex, we loop through its 3simplex "faces" and collect the contour-polygons they contain. <ref type="figure" target="#fig_3">Figure 5</ref> illustrates the 3-simplexes that comprise a 4-simplex; the decomposition is a matter of combinatorics, and generalizes readily to n-simplexes. The contourpolygons form the boundary elements of the contourpolyhedron within the 4-simplex. Note that the "polyhedron" may actually be non-flat, even if it has flat polygonal faces. A contour-polyhedron in a 4-simplex that can assume a variety of shapes. These are shown in the appendix. The</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contouring an n-simplex</head><p>As this sequence of examples shows, the edges and triangles of contourS2 are promoted to triangles and tetrahedra in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Triangulating a contour-polytope</head><p>Once a contour-polytope has been extracted from a simplex,   Why would one want to triangulate the polytope? One reason Consider the reciprocal function xy = t (so named because of is to provide simple graphics primitives for rendering an its explicit form y = t/x), for real-valued x, y, and parameter image on the screen. But the more important reason is that t. <ref type="figure" target="#fig_4">Figure 6</ref> shows contours for this function at three values of each simplex in a contour-polytope can be passed as an t. When t reaches zero the contour develops a singularity (the argument to the contour routine again. A function f self-intersection at the origin), since xy = 0 has solutions 1 produces a contour-polytope which is split into simplexes.</p><p>x = 0 and y = 0 corresponding to the x-and y-axes. Each of the simplexes can be contoured against a function f 2 to find a lower-dimensional contour-polytope. Now consider complex-valued variables x, y, and parameter</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Contour Meshing Applied to CxC</head><p>This section presents the results of applying the Contour with two sheets intersecting transversely. It is especially Meshing algorithm to the particular problem of triangulating difficult to visualize the manner in which two surfaces a surface in 4-dimensional space. Such a surface arises in the intersect in a single point; such an intersection can never be context of studying complex curves. embedded in R . <ref type="figure" target="#fig_5">Figures 7 and 8</ref> show the results.</p><p>A major area of interest to algebraic geometers is the structure of families of complex algebraic varieties; that is, the contours C defined by isovalues for a collection of t polynomials parameterized by t. One contour can deform into another, but the deformation must preserve the algebraic structure of the variety. There are many difficult unsolved problems regarding families of varieties; an interesting case arises when a smooth variety deforms into a singular one (containing a cusp or a self-intersection).</p><p>Work of the last decade in the interaction between algebraic geometry and theoretical physics has increased interest in problems involving families of complex algebraic curves with additional structure such as vector bundles. The behavior of these bundles, as singularities develop in the underlying curves, has physical as well as mathematical significance. Even relatively simple questions are difficult to answer (for example, whether or not one of these curve-line bundle pairs can be deformed into any other such pair i.e., whether the space parameterizing all these pairs is connected). Visualization methods that increase understanding of these families would be very interesting to mathematicians.</p><p>A complex curve, defined by f : C C, can be represented 2 by a surface in real 4-space. Each complex variable is specified as a real/imaginary pair, hence the domain is 4dimensional and the function can be written as f : R R .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">2</head><p>The real-valued constraints real(f) = 0 and imaginary(f) = 0 serve as the two functions f and f for the Contour Meshing 1 2 algorithm. We first enumerate 4-cells that tile the space R , t. The function xy = t defines an implicit surface in the 4-dimensional space spanned by two complex planes. When t = 0 the surface contains an isolated singularity at the origin, 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Stereographic Projection</head><p>After the Contour Meshing algorithm has generated an isosurface, we would like to investigate its shape in R . Moreover, we would like to see the entire surface, despite its infinite extent.</p><p>To view the entire surface f(x,y) = 0, we must map an infinite space onto a finite one through a process called compactification. One way to accomplish this compactification is to use stereographic projection.  projecting the plane R onto a 2-sphere S in R (figure 9). That is, we could compute the one isovolume for f(x,y,t) = 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">3</head><p>The south pole rests on the plane. A line through the north Subcontours could then be extracted on-the-fly depending on pole and a point p on the plane must meet a point q on the the exact value of t that the user specifies. Then the sphere; q is the stereographic projection of p. Points on the interactive viewer could perform the final Contour Meshing plane just below the sphere are mapped to the southern to extract the isosurface. On a multiprocessor platform (or hemisphere, while points near infinity are mapped to a distributed over a cluster of machines) this might be a neighborhood of the north pole.</p><p>feasible approach, but a single-processor workstation is too Stereographic projection leaves a hole at the north pole. system already requires all available computing power from Filling the hole compactifies the space. We explicitly cover a single-processor SGI Onyx Reality Engine or an SGI the hole with polygons which connect the implicit surface's Indigo High Impact, even though the isosurfaces at different boundary (after projection) to the north-pole. Technically, values of t have been precomputed. these hole-filling triangles form a cone over the surface's boundary. <ref type="figure" target="#fig_5">Figures 7 and 8</ref> show the complex function</p><p>In his first session he expressed surprise that the family of f(x,y) = xy -t = 0, before and after stereographic projection isosurfaces deformed with a twist as it approached the (with the hole filled). singularity. He was also interested to see the actual geometry</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Manipulating the surface</head><p>After stereographic projection, our complex-valued surface lies on a 4-sphere in R . R allows 5 degrees of freedom for 5 5 translations and 10 for rotation; four-dimensional space R 4 allows 4 and 6 degrees of freedom, respectively. It is difficult to manipulate a graphical object in R using an input device 4 in our 3-dimensional world; it is even harder if the object lies in R . We therefore fix a particular projection of the surface 5 from R to R , where we can view it interactively using an 5 4</p><p>interface developed in the Fourfront system <ref type="bibr">[Banks]</ref>. The mechanics of interacting with surfaces in 4-space are described elsewhere <ref type="bibr">[Banks]</ref>  <ref type="bibr">[Hanson]</ref> [NDview].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Time Varying Surfaces</head><p>The impetus for this work was to examine a set of isosurfaces parameterized by t, where at t = 0 the isosurface contains a singularity. We create a separate meshed surface for several values of t. All meshes are loaded into machine memory. On a graphics workstation the 4D viewer then animates them as a flipbook of surfaces. This approach requires a long mesh-generation step, and it limits the set of slow to extract the isosurface in real time. The viewing 2 of the surface patches in the neighborhood of their 1-point intersection. Although he is well acquainted with the algebraic properties of the complex curves, this was his first experience visualizing them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Application Performance and Statistics</head><p>Our visualization system contains two parts, one to extract the contours and one to interact with them. Both were developed on an SGI Indigo with a 250MHz MIPS R4400  the origin in R for 51 values of t ranging from -1 to 1. <ref type="table">Table   4</ref> 1 shows what percentage of the triangles in the implicit surface arise from the various cases of contour-polyhedra in One area of future work is to improve the implicit surface by a 4-simplex (see the appendix), and what percentage of the recursive subdivision and to adjust the position of midpoints polygons arise from the cases of contour-polygons in a 3-to satisfy f = 0. Because of the large number of polygons simplex. Tetrahedra and prism-shaped isovolumes are shown Contour Meshing produces, a parallel implementation of the to dominate. <ref type="table" target="#tab_1">Table 2</ref> summarizes mesh-generation statistics algorithm could speed up this phase significantly. Another for the same complex reciprocal function. The possibility for mitigating the burden of the number of triangle-counts in table 2 do not include the polygons polygons produced is to decimate the triangular mesh. Since required to fill the hole in the stereographic projection. The the isosurfaces lie in R , we are examining ways to modify table shows that fewer than 30 triangles were found, on existing 3D methods for mesh simplification. average, in each 4-cell. This is significantly fewer than the worst-case analysis of 2 4! contour-polyhedra per 4-cell, 18 4-cells (see plate 3). This production is consistent with quadratic growth of about (16h) triangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Because it performs 4D-transformations, the interactive viewer is unable to match the rendering speed of ordinary 3D applications. Although SGI graphics engines can perform 4D rotations in hardware, they are not designed to perform 4D translations or 4D-to-3D projections. The interactive viewer renders approximately 60,000 4D triangles per second, which is about 40% of the performance for 3D triangles. For the complex reciprocal example, this limits us to an average of about 8 frames per second barely enough to be interactive. We find that this performance, at least on our SGI workstations, is essentially independent of window size. 6 Conclusions algorithm locates a contour-polytope in a simplex. Splitting a cell into simplexes and splitting a polytope into simplexes are steps that allow the algorithm to be applied recursively over multiple functions in large dimensions. We examined the sample case of triangulating an algebraic complex curve (producing a surface in real 4-dimensional space) and viewing the result interactively on a graphics workstation.  <ref type="figure">Figure 10</ref>. Case 2. In this 4-simplex (left) there are four vertices where f is positive and one where it is negative. Zero-crossings are shown as dots (middle). The resulting contour-polyhedron (right) has four triangular faces. <ref type="figure">Figure 11</ref>. Case 3. In this 4-simplex (top left) there are two vertices where f is positive, two where it is negative, and one where it is exactly zero. Zero-crossings are shown by dots (top middle). The contour-polyhedron (top right) has four triangular faces and one rectangular face. This pyramid (bottom left) can be midpoint-split once at its base. <ref type="figure">Figure 12</ref>. Case 4. This 4-simplex (top left) contains zerocrossings (top middle) that produce a contour-polyhedron with two triangular and three rectangular faces (top left). This prism (bottom left) can be midpoint-split into three pyramids and two tetrahedra (bottom middle). Only the pyramid-shaped components need to be split (bottom right).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 .</head><label>3</label><figDesc>Splitting the 2-cell (left). The midpoint connects to each edge to produce four 2-simplexes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Splitting the 3-cell (left)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>) 0 implies (by the intermediate value theorem) 1 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>, edge) if (function = 0) on edge then return contourPoint (function, edge) contourS2 (function, triangle) foreach edge in triangle do point contourS1 (function, edge) append point to contour /* contour will be a line segment */ Decomposing the 4-simplex (top) into 5 tetrahedra (bottom). Vertices are numbered consistently to show the 5-choose-4 combinations of sub-simplexes. contourS3 (function, tet) foreach triangle in tet do segment contourS2 (function, triangle) append segment to contour /* contour will be a polygon */ contourS4 (function, hypertet) foreach tet in hypertet do polygon contourS3 (function, tet) append polygon to contour /* contour will be a polyhedron */ contour (function, simplex, n) if (n &gt; 1) then foreach subsimplex in simplex do polytope contour (function, subsimplex, n-1) append polytope to contour else /* simplex is a line segment */ if (function = 0) on simplex then return contourPoint (function, simplex)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Contours for the real-valued reciprocal function xy = t (t = 2, 1, 0).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Contours for the complex-valued reciprocal function xy = t (see also plate 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Stereographically projected contours for complex-valued xy = t (see also plate 2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>-polyhedron. Its constituent tetrahedra are then contoured against f = 0 to extract the contour-polygons 2 that form the implicit surface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 .</head><label>9</label><figDesc>A stereographic projection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>of RAM, and a High Impact graphics engine. The mesh generator was written in C++ and the viewer in C and OpenGL. The following statistics describe the complex reciprocal function f(x,y) = xy -t = 0. The statistics in tables 1 and 2 describe the mesh elements and system performance. The complex reciprocal function was evaluated within a 4-cell of size 4x4x4x4 centered about xy -t = 0 for complex x, y, and tNumber of values assumed by t 51 Number of 4-cells per value of t (4x4x4x4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>3</head><label></label><figDesc>tetrahedra per polyhedron (case 4 with midpointtriangulation), 4 contour-polygons per tetrahedron, whichContour Meshing is an algorithm for triangulating a contour yields a total of 13,824 potential triangles per 4-cell.from a collection of functions in arbitrary dimension. The Increasing the resolution of the spatial tiling dramatically increases the number of cells to be traversed; with h cells in each of n dimensions, h cells result. However, the final n contour mesh only triangulates the cells that contain the kdimensional contour, so O(h ) is a more reasonable estimate k of the asymptotic complexity of the mesh. Triangulating the complex reciprocal function (in a neighborhood of the origin) at h = 2, 4, and 8 cells per dimension yields 896 triangles in 2 4-cells, 4768 in 4 4-cells, and 16,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>The viewing system maintains acceptable interactivity for a modest number of 4-cells tiling the domain. The mesh-generator and interactive viewer are in use by an algebraic geometer interested in the exploration of complex curves.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Distribution of contour-polyhedra and contourpolygons resulting from the complex reciprocal function.Stereographic projection maps R onto the n-dimensional values of t that the user can animate. Ideally, only the n sphere S , which can be imbedded in R . Consider isovolume through which t varies would be precomputed.</figDesc><table><row><cell>Triangles (out of 386,080) from</cell><cell>%</cell></row><row><cell>Case 2 (tetrahedral contour)</cell><cell>30.13</cell></row><row><cell>Case 3 (pyramid-shaped contour)</cell><cell>0.37</cell></row><row><cell>Case 4 (prism-shaped contour)</cell><cell>66.81</cell></row><row><cell>Case 5 (degenerate 4-simplex)</cell><cell>0.00</cell></row><row><cell>North-pole's cone over the boundary</cell><cell>2.69</cell></row><row><cell>Types of contour-polygons in 3-simplexes</cell><cell></cell></row><row><cell>3-sided polygons</cell><cell>81.69</cell></row><row><cell>4-sided polygons</cell><cell>18.31</cell></row></table><note>n n+1</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Mesh generation statistics for the complex reciprocal function.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>5 Future Work</head><label></label><figDesc></figDesc><table /><note>i 4</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We gratefully acknowledge the guidance of Tyler Jarvis (Brigham Young University, Department of Mathematics), who supplied the original problem of visualizing vector bundles over singular complex curves. We thank Jules Bloomenthal for insights into implicit-mesh algorithms. We thank the reviewers for pointers to a wealth of background material that significantly improved the quality of this paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix: Cases of 4-Simplex Contours</head><p>The number of 3-simplexes produced by triangulate can be reduced if the possible isovolumes of a 4-simplex are considered. It is also useful to consider the cases when constructing a table-driven contouring method, like enumerating the cases in Marching Cubes. There are five cases:  individual cases of contour-polyhedra from which they arise: green = case 2 (tetrahedron); blue = case 3 (pyramid); orange = case 4 (prism).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Allgower</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Georg</surname></persName>
		</author>
		<title level="m">Numerical Continuation Methods: An Introduction</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Simplical pivoting for mesh generation of implicitly defined surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Allgower</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gnutzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="305" to="325" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactive manipulation and display of two-dimensional surfaces in four-dimensional space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">C</forename><surname>Banks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Interactive 3D Graphics</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="197" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Polygonization of implicit A tetrahedron does not need to be midpoint-split into more surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jules</forename><surname>Bloomenthal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Figures</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="53" to="60" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
	<note>10-12 show how this small optimization avoids splitting tetrahedra</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">An implicit surface polygonizer. Graphics gems IV</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jules</forename><surname>Bloomenthal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Academic Press</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Triangulation of the manifold of class one</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Cairns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="549" to="552" />
			<date type="published" when="1935" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Interactive visualization methods for four dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Cross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;93</title>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="196" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Visualizing surfaces in four-dimensional space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoff</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianhua</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Design</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page">83</biblScope>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olaf</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Introducing</surname></persName>
		</author>
		<idno>1.0</idno>
		<ptr target="http://www.geom.umn.edu/software/geomview/docs/NDview/" />
		<imprint/>
		<respStmt>
			<orgName>The Geometry Center, University of Minnesota</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Polyhedral approximation approach to molecular orbital graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akio</forename><surname>Koide</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akio</forename><surname>Doi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koichi</forename><surname>Kajioka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Molecular Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">On the covering of analytic loci by complexes. Transactions of the</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">O</forename><surname>Koopman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Brown</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1932" />
			<publisher>American Mathematical Society</publisher>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="231" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Marching cubes: a high resolution 3-D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;87</title>
		<meeting>SIGGRAPH &apos;87</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The asymptotic decider resolving the ambiguity in marching cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">L</forename><surname>Van Der Waerden</surname></persName>
		</author>
		<title level="m">Topologische Begründung des kalküls der abzählenden geometrie</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathematische</forename><surname>Annalen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1929" />
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="337" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frederick</forename><surname>Wicklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Streed</surname></persName>
		</author>
		<ptr target="http://www.geom.umn.edu/software/pisces/" />
	</analytic>
	<monogr>
		<title level="j">Pisces Project at the Geometry Center</title>
		<imprint/>
		<respStmt>
			<orgName>The Geometry Center, University of Minnesota</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
