<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hierarchical and Parallelizable Direct Volume Rendering for Irregular and Multiple Grids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Tarantino</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Gibbs</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Hierarchical and Parallelizable Direct Volume Rendering for Irregular and Multiple Grids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Computer Graphics</term>
					<term>Scientific Visualization</term>
					<term>Scanline</term>
					<term>Direct Volume Rendering</term>
					<term>Curvilinear Grid</term>
					<term>Irregular Grid</term>
					<term>k-D Tree</term>
				</keywords>
			</textClass>
			<abstract>
				<p>A general volume rendering technique is described that efficiently produces images of excellent quality from data defined over irregular grids having a wide variety of formats. Rendering is done in software, eliminating the need for special graphics hardware, as well as any artifacts associated with graphics hardware. Images of volumes with about one million cells can be produced in one to several minutes on a workstation with a 150 MHz processor. A significant advantage of this method for applications such as computational fluid dynamics is that it can process multiple intersecting grids. Such grids present problems for most current volume rendering techniques. Also, the wide range of cell sizes (by a factor of 10,000 or more), which is typical of such applications, does not present difficulties, as it does for many techniques. A spatial hierarchical organization makes it possible to access data from a restricted region efficiently. The tree has greater depth in regions of greater detail, determined by the number of cells in the region. It also makes it possible to render useful &quot;preview&quot; images very quickly (about one second for one-million-cell grids) by displaying each region associated with a tree node as one cell. Previews show enough detail to navigate effectively in very large data sets. The algorithmic techniques include use of a k-d tree, with prefixorder partitioning of triangles, to reduce the number of primitives that must be processed for one rendering, coarse-grain parallelism for a shared-memory MIMD architecture, a new perspective transformation that achieves greater numerical accuracy, and a scanline algorithm with depth sorting and a new clipping technique.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Direct volume rendering is an attractive technique because it can convey a great deal of information in a single image by mapping the scalar data values in a sample volume to color and opacity. However, a great amount of computation is required to calculate the information presented, particularly when the samples are on irregular grids. The problem is further exacerbated when the data sets are very large.</p><p>This paper presents a direct volume rendering technique developed for a wide range of grids, including curvilinear grids with hexahedral cells, tetrahedral irregular grids, and rectilinear grids. Furthermore, this method can process multiple intersecting grids, which are often produced in complex computational fluid dynamics simulations <ref type="bibr" target="#b1">[2]</ref>. Most previous methods will not work correctly on such grids. The principal contributions are as follows:</p><p>Computer Science Dept, Univ. of California, Santa Cruz, CA 95064,</p><p>USA. E-mail: fwilhelms,avg,pault,jonog@cs.ucsc.edu <ref type="bibr" target="#b0">1</ref>. At the heart of the system is a software scan conversion method of direct volume rendering based on treating the faces of grid cells as independent polygons. This method generalizes polygon scanline methods in that it renders semitransparent regions of space between polygons, as well as opaque polygonal surfaces. Also, it introduces a new clipping technique that makes it unnecessary to clip individual polygons. This algorithm can be used independently of any hierarchy. It does not require any graphics hardware and produces excellent quality images (See Section 3.) 2. The basic algorithm has been implemented to run in parallel on shared-memory MIMD machines. Parallelization is relatively easy to implement and fits naturally into the algorithm. We observed a speed-up of better than 3.25 on four processors. (See Section 4.) 3. To efficiently visualize very large data sets, the program builds a k-d tree over the polygons, organizing them by spatial location. The hierarchy is useful in two ways. First, if one zooms in or otherwise restricts viewing to a part of the volume, the hierarchy permits the program to avoid processing data that is clearly not visible. Second, an approximate model of the data present within any subtree can be stored in the root node of the subtree. An error term in each node indicates how closely the local model approximates the actual data. Approximate images can be quickly produced. (See Section 5.) 4. A new perspective transformation achieves greater numerical accuracy on geometrical elements spanning a great range of sizes. Standard techniques lose accuracy in screen-z, leading to significant errors, both in color integration and in element order (See Section 6). We chose a projection-style algorithm because we were not designing our algorithm for massively parallel machines, we wanted to maximize coherence, and we wanted to avoid the difficulties of ray-casting intersecting cells.</p><p>We preferred the faced-based scanline approach because of its generality and speed (Section 3). We parallelized on a scanline basis because it limits duplication, is easy to implement, and provides reasonable speed-up for small-scale parallelization (see Section 4). We associated irregular grid data (and/or polygon mesh data) with a k-d tree. We believe this is the first use of a hierarchy with general irregular, possibly intersecting, grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Related Work</head><p>Early approaches for direct volume rendering used ray-casting, cell projection, and splatting (voxel projection) <ref type="bibr" target="#b6">[7]</ref>. Most research has addressed only rectilinear grids, and most previously reported acceleration and optimization techniques apply only to such grids. New methods including Fourier transforms, shear-warp transforms, or 3D texture maps suffer this limitation.</p><p>However, many applications create non-rectilinear volume data sets, such as computational fluid dynamics (CFD), finite element analysis (FEM), and atmospheric and oceanographic measurements. Such data is often found on curvilinear grids (where a computational regular grid is warped to fit around objects of interest), and unstructured grids (where data points are connected to form tetrahedral or other polyhedral cells). Sometimes non-tetrahedral cells are broken into tetrahedra to simplify processing; however, this can lead to artifacts and increases the number of primitives. Multiple overlapping and intersecting grids may be used to sample space around very complex shapes <ref type="bibr" target="#b1">[2]</ref>. Our research concentrates on rendering such irregular data.</p><p>Many complexities are introduced when imaging data on irregular grids and multiple grids, as opposed to rectilinear grids. A visibility ordering (front-to-back) is not implicit. Many operations are much more expensive, such as intersecting rays with cells, projecting irregular cells, and interpolating across faces or through cells.</p><p>A number of algorithms have been developed for irregular grids. Ray-casting general irregular grids is complicated and slow (though it does parallelize beautifully) <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b21">22]</ref>. Cell projection and splatting have been used for irregular grids in software <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b28">29]</ref> and hardware <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b23">24]</ref>. Though we process faces and they process volumetric regions, the methods of Max et al <ref type="bibr" target="#b18">[19]</ref> and Giertsen <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref> are related to ours in that they use scan-conversion for efficiency.</p><p>Lucas <ref type="bibr" target="#b14">[15]</ref> implemented a face projection method for irregular grids. Unlike ours (Section 3), he appears to fully sort all faces in depth and then scan convert them in visibility ordering. This is more closely related to the classic "Painter's Algorithm" for polygons, which is not widely used because of the costly z-sort. Lucas only sorts on the centroids of faces, which can produce an incorrect ordering. Challinger <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> explored direct volume rendering of irregular volumes on massively parallel machines. She initially used ray-casting, but then developed a face projection method for speed. She partitioned the screen into "tiles" for each processor, but within each tile her algorithm is very close in philosophy to ours, though data structures differ.</p><p>Two approaches for ray-casting of irregular grids on massively parallel machines have been described <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>Challinger distributed data to processors after conversion to screen space, which must be redone after each transformation <ref type="bibr" target="#b2">[3]</ref>. Ma distributed subvolumes to processors once, and composited contributions found by ray-casting the subvolumes <ref type="bibr" target="#b15">[16]</ref>. In their projection methods, Lucas <ref type="bibr" target="#b14">[15]</ref>, Challinger <ref type="bibr" target="#b4">[5]</ref>, and Giertsen et al <ref type="bibr" target="#b9">[10]</ref> all parallelize by breaking the screen space into rectangular tiles which are assigned to processors. This may require duplication, and as scanlines are broken into pieces, some coherence is lost.</p><p>Concerning hierarchies, Laur and Hanrahan used an octree on regular volumes, stored an average value at each node to approximate subtree data, and used splatting <ref type="bibr" target="#b13">[14]</ref>. Two of the present authors implemented an octree on regular volumes with trilinear nodal models and a choice of error terms, explored more complex approximate nodal models, and used cell projection for rendering <ref type="bibr" target="#b27">[28]</ref>. Cignoni et al <ref type="bibr" target="#b5">[6]</ref> created a hierarchy over tetrahedral grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Scanline Algorithm</head><p>The scanline technique has the merits of both generality and coherence. It is an extension of Watkin's scanline algorithm <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b24">25]</ref>. Sample data values are supplied at the vertices of polyhedral cells whose faces are (possibly non-planar) polygons. These faces are processed independently in the algorithm. While a great deal Procedure scan:</p><p>1. If a new geometrical transformation is specified, convert vertex locations from world space to screen space (Section 6).</p><p>2. For each (horizontal) scanline of the image, create its y-bucket list.</p><p>3. Initialize y-actives list as empty.  of work has been done (mostly in the 1980's) on the problem of scanline rendering of polygonal data sets, we wish to emphasize that using scan conversion for direct volume rendering is a different problem. Most importantly, in polygon scan conversion it is the surfaces that have color properties (and these are usually opaque, permitting further simplifications). In direct volume rendering, it is the material between the cell surfaces that has color properties, and this material is often semi-transparent. <ref type="figure" target="#fig_1">Figure 1</ref> gives the high-level procedure. The remainder of this section describes the main steps further. See the technical report <ref type="bibr" target="#b25">[26]</ref> for further details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Polygon Creation</head><p>The volume is decomposed into polygons, each given a unique integer identifier (polygon ID). Although many aspects of the design are compatible with a variety of polygons, the implementation permits only triangles. Because multiple grids are allowed, as well as surface polygon meshes, a grid ID is encoded in certain bits of the polygon ID, and specifies with which grid or surface this polygon is associated. The remaining bits of the polygon ID comprise either an index into an array of polygon structures (for irregular grids), or a direct encoding of the polygon's position within the grid (an option for curvilinear and rectilinear grids). Each polygon structure consists of an array of its vertex indices. For curvilinear and rectilinear grids, every cell has the same facial structure of 12 triangles, and the cell vertices can be inferred from the cell ID, so the vertex information can be encoded into the polygon ID, bypassing the use of polygon structures.</p><p>Any group of polygons to be rendered includes the faces of a clipping box, which delimits the subvolume to be rendered. The six faces (12 triangles) of the clipping box are treated much like other polygons during processing, but take on a special meaning for clipping during pixel processing (see Section 3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Y-Bucket Processing</head><p>Each scanline has associated with it a y-bucket list consisting of the IDs for those polygons that first appear on that scanline (processed bottom-to-top). Polygons are excluded from y-buckets if they are outside the clipping box or do not cross any pixel center. After computing y-bucket lists, each scanline must be processed and drawn into the software frame buffer. A y-actives list containing the polygon IDs of those polygons contributing to a scanline is maintained. Before processing the current scanline, the y-actives list must be updated by removing polygons from the previous scanline's y-actives that are no longer active on this scanline, and adding new polygons from the current y-bucket. The y-actives list is implemented as an array of structures, each containing various polygon information.</p><p>For polygons on the boundary of a grid, the vertices are stored in counter-clockwise order when viewed from outside the grid, so that it can be easily recognized whether a boundary polygon is the first or last in its grid, in visibility order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">X-Bucket Processing</head><p>When processing a scanline, information for each active polygon is transferred to an x-bucket data structure associated with the leftmost pixel in which the polygon appears. A linked list of these structures is associated with each x-bucket in front-to-back visibility order. As the scanline is processed, an x-actives list is maintained and updated for each pixel. It contains the data value and the screen depth (screen-z) for each polygon contributing to that pixel. As with the y-actives list (Section 3.2), polygons that become inactive at the current pixel are deleted, and polygons in the current xbucket are inserted, except that now the list is maintained in sorted order. The surviving polygons of the previous pixel's x-actives list must be updated with newly interpolated values of field data and screen-z. New screen-z values may require rearrangement of polygons among survivors, and new polygons must be merged in, maintaining screen-z order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Pixel Processing</head><p>The x-actives list for a particular pixel is traversed front-to-back to accumulate the color and opacity. In our implementation, data values (interpolated to that pixel) for each pair of adjacent polygons are averaged, and the average is used as the parameter of a transfer function that provides a color and opacity value. Taking into account the line-of-sight distance between the two polygons (Section 6), the color-opacity contribution for that inter-polygon region is calculated. This contribution is composited into a software floating point frame buffer. Standard equations for this are found elsewhere, e.g. <ref type="bibr" target="#b26">[27]</ref>.</p><p>A set of clipping polygons encloses the region to be rendered, removing the need to explicitly clip any polygon. Therefore, there are two clipping polygons in any pixel's x-actives list. The first indicates pixel contributions should begin to be accumulated, and the second indicates contributions should stop being accumulated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Parallelizing the Algorithm</head><p>Three primary components of this algorithm can, by and large, be easily parallelized. The first is the transformation of the vertices from world space to pixel space, and is trivially parallelizable, as each vertex can be transformed independently. The others require some discussion.</p><p>Step numbers in this section refer to <ref type="figure" target="#fig_1">Figure 1</ref>.</p><p>The second parallelizable component is the task of grouping polygons by scanline into y-buckets (step 2). Its parallelization is more involved, but highly scalable. It proceeds in two passes. In the first pass, each processor is given an equal number of polygons to process. One temporary array stores, for each polygon, the lowest scanline where it appears, or an invalidation flag if it doesn't cross any pixel centers within the clipping box (as described in Section 3.2). A second, two-dimensional, array stores, for each scanline and processor, how many polygons the processor found that belong in that y-bucket.</p><p>In the second pass, the number of polygons belonging in each y-bucket is found by accessing the latter array, and space for each y-bucket is allocated by partitioning a common output array. The space for one y-bucket is further partitioned into space for each processor to fill within that y-bucket. (While this transitional step can also be parallelized by standard techniques, its work per processor is only proportional to the number of scanlines, not the number of polygons.) During the second pass, each process creates appropriate y-bucket structures for all polygons that it processed in the first pass, except those that were invalidated.</p><p>The third parallelizable component involves processing each scanline in order from bottom to top, which involves the bulk of the computation (steps 4a through 4d). There are several ways of implementing this part in parallel. Our implementation contains a "critical section" of code (step 4a). Only one processor can run the critical section at a time. During this section, a processor updates the current y-actives list for the scanline, takes a copy of it, and then exits the critical section. Then it builds the x-buckets and processes the scanline (steps 4b through 4d).</p><p>This implementation is not 100% scalable because the critical section can act as a bottleneck as more processors are added. However, it was fairly easy to implement and caused low contention with the four processors we had available (Section 7). Our measurements suggest that it can extend to about 16 processors before contention becomes a serious drawback.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Use with a Multi-Resolution Hierarchy</head><p>A method of spatial partitioning in k dimensions, called k-d trees, was introduced by Jon Bentley <ref type="bibr" target="#b0">[1]</ref>. A binary tree is built that splits in one dimension at a time. Our current implementation splits in a round-robin fashion, but one could easily adopt a more sophisticated policy based on the locations of objects. At tree node v, the hyperplane that splits the region is orthogonal to the xi-axis when splitting on dimension i. Our implementation bisects the region, but in general, any partitioning value Xv can be chosen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Creation of the Hierarchy</head><p>Each node v in the tree has associated with it a list of polygon IDs. It is built as follows: for each polygon p passed into the tree node, which is splitting on dimension i, if all vertices have an xi location less than Xv, place p in the set to be passed to the left subtree. If all vertices have an xi location that is greater than the bisection value, place p in the set to be passed to the right subtree. Otherwise, retain p in the set to be stored at v (see <ref type="figure" target="#fig_2">Figure 2)</ref>. Then, process the left and right subtrees. If the number of polygons passed into node v is below a user-defined threshold, no splitting occurs, and the node is a leaf. Note this results in polygons being associated with the smallest node region that completely contains them, following Greene <ref type="bibr" target="#b10">[11]</ref>, and avoids subdividing polygons.</p><p>We developed a new, flexible storage method that allows us to avoid the extra space of linked lists and still pass all objects associated with a subtree in one operation. Polygon IDs are stored in one common array T i d , and arranged in the order that they would appear during a prefix-order traversal of the k-d tree. (A post-fix order can also be easily made to work.) Thus, all polygons stored in a subtree form a contiguous section in T i d , and all polygons associated with that subtree's root node are at the beginning of that segment.</p><p>Assuming the array begins with a known subscript of 0, it is necessary to store globally the total number of polygons in the tree, and to store in each node the offset to the beginning of its set of polygons. The remaining values can be recovered during traversal, provided the end-point for each subtree is passed in as a parameter of the traversal. For the whole tree, this is just the total number of polygons. Thus if a tree node v is visited with end-point E passed in:</p><p>The end-point for polygons associated with node v is the offset In this convention, an end-point is the first index above the segment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Fully Detailed Rendering</head><p>To prepare for rendering, the tree is traversed and a set of subranges of polygon IDs is developed, which represent all polygons within the user-defined restrict box. Recall that all polygon IDs within the spatial region represented by one node are stored contiguously in the polygon array, Tid (Section 5.1). If the entire node is outside the restrict box, the traversal returns from that branch immediately. If the node is entirely inside the restrict box, then the subrange for that node is added to the set of subranges to be rendered, and again the traversal returns without exploring the subtrees. The same applies for leaf nodes, and for nodes whose region contains fewer polygons than a user-specified cut-off. If a node is partially inside the restrict box and none of these exceptions applies, then the subrange of Tid associated with the node itself (but not its descendants) is added to the set of subranges to be rendered, and traversal continues into this node's children, which are treated recursively in the same manner.</p><p>When this traversal is completed, we have a possibly visible list (represented as a set of start and end positions within Tid) of all possibly relevant polygons (see <ref type="figure" target="#fig_2">Figure 2</ref>). This list is then sent to the renderer for processing (see Section 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Multi-Resolution Rendering</head><p>For multi-resolution rendering, we wish to display error-controlled approximations of the data for speed. For this, each k-d tree node must contain a model representing an approximation of the data in the subregion it represents, called a nodal region. The tree node also stores an error term representing the deviation of the model from the data. Our multi-resolution technique departs from that associated with wavelets <ref type="bibr" target="#b16">[17]</ref> in that each level represents a complete model of its region, whereas wavelets represent just the detail information not represented at higher levels. For rendering, the user specifies an acceptable error. During the traversal, if the error associated with the node is less than the acceptable error, or the node is a leaf, traversal stops there and the nodal region is drawn.</p><p>At present, our nodal model is a rather simple one, but it constructs very fast "preview" images to help orient the user in a very large data set (see <ref type="figure" target="#fig_8">Figure 9</ref>). Eight data values are stored with each k-d tree node representing the values of the eight corners of its nodal region. These corner values induce a trilinear function throughout the nodal region. The data values are found, for each corner point, by locating the grid cell that contains the corner of the nodal region, then interpolating within that grid cell to compute the data value at that nodal corner point.</p><p>A future implementation is planned to support a mixture of rendering modes, with some nodal regions being approximated by the model and others being rendered in detail with their polygons. Tree traversal occurs in front-to-back visibility order. When rendering a nodal region by scan conversion, the algorithm of Section 3 will be used, with the local clipping box being the intersection of the boundary of the nodal region and the global   restrict box. Nodal regions with smooth data will be rendered by an approximation technique. Separately rendered regions will be composited in the usual manner. There are numerous technical problems to be overcome to avoid discontinuities on the boundaries between nodal regions using different rendering methods. If we restrict ourselves to only drawing nodal regions, then standard cell projection methods can be used <ref type="bibr" target="#b26">[27]</ref>, which may take advantage of the graphics hardware. To avoid color-interpolation inaccuracies (as produced by hardware Gouraud shading), we subdivide large nodal regions on the fly and interpolate data to their corners, until nodes that cover a reasonably small number of pixels are obtained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Numerically Stable Perspective Transformation</head><p>Standard computer graphics software provides perspective transformations based on the eye being at the origin <ref type="bibr" target="#b6">[7]</ref>. Standard preparation for a perspective transformation is to translate the eye to the origin. However, with our data, that resulted in translating many vertices away from the origin in screen-z, introducing substantial relative floating point errors. Some ordering inconsistencies arose in later computations. Double precision for all values involved would have imposed unacceptable space requirements. For numerical accuracy we needed a different geometrical basis, in which the eye is away from the origin. The transformation introduced here preserves accuracy of the screen-z values near the center of the visibility bounding box (Vbb), which is the portion of the volume being imaged. In fact, our transformation maps the center of the Vbb to 0 in screen-z. Some texts give perspective transformations based on the projection plane passing through the origin <ref type="bibr" target="#b19">[20]</ref>. While this puts the eye away from the origin, it did not suffice for our purposes because a user-specified translation might separate the center of the Vbb from the projection plane. (For a general 3D perspective transformation, the projection plane is the set of points whose transformed homogeneous coordinate is 1.)</p><p>This section presents a perspective transformation with a new geometrical basis, in which both the eye and the projection plane may be away from the origin (see <ref type="figure" target="#fig_0">Figs. 3 and 4)</ref>. Specifically, the eye point is at 0; 0; e o z t , and the projection plane is z = zt. In addition, the Jacobian of this transformation is the identity at the origin. This transformation provided us with the numerical accuracy we needed in screen-z.</p><p>The Vbb is first centered at (0,0,0) in world space, then it is rotated by the user rotations. Now the eye is placed at 0; 0; e o . At this time the projection plane is z = 0. Then the user translates (exaggerated in the diagram) are applied, as follows. The user translate in z has the effect of moving the eye and the projection plane by zt. However, the user translates in x and y move the Vbb off the z-axis. The user translate in z is restricted to obey zt + 1 2 d + :05eo eo. Finally, transformed points are uniformly scaled by a factor:</p><formula xml:id="formula_0">es eo = s h s d ;<label>(1)</label></formula><p>to convert world units into pixels. For additional details of the derivations, see <ref type="bibr" target="#b25">[26]</ref>. </p><p>To invert the zv-to-zs mapping, just solve for zv. The following equation gives the difference in world-z between two points along one sight line (zv2 zv1), in terms of their screen-space values, again in a numerically stable form: </p><formula xml:id="formula_2">zv2 zv1 = eo</formula><p>Finally, the world distance between two points on a sight line is inversely proportional to the cosine of the angle between the sight line and the screen-z axis:</p><formula xml:id="formula_4">dist = zv2 zv1 cos = zv2 zv1 r zv1 eo 2 x 2 v1 + y 2 v1 + z v 1 e o 2<label>(4)</label></formula><p>Accurate values of this distance are critical because they affect the compositing of color through possibly thousands of triangles that are very close to each other, as seen in the space-shuttle grid (see <ref type="figure" target="#fig_7">Figure 8</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental Results</head><p>We first compare the performance of the method on a curvilinear multi-grid using single and multiple processors. Next, we compare Scale </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Performance on Single and Multiple Processors</head><p>Performance with one to four processors on an SGI Onyx, with four 150-MHz processors, is shown in <ref type="figure">Figure 5</ref>. For this evaluation, we used the nine-grid space shuttle data set with a spatial rotation of ( 90 X, 10 Y , 0 Z), and scale factors that ranged from 1.0 to 5.16. A scale factor of 1.0 causes the long diagonal of the volume's bounding box to equal the width of the screen window. The window size is 500x500 pixels. We see that four-processor efficiency is about 80%. We looked separately at the one-processor and four-processor times of different sections of the algorithm, including transformation of the points to screen space, creation of the Y-buckets, and generating scanlines. Times mentioned below are averaged over the four scale values reported in <ref type="figure">Figure 5</ref>.</p><p>Using a single processor, the average total CPU time to transform the shuttle vertex locations from world space to screen space was 1.25 seconds; four processors achieved a 3.8 speedup. The CPU time for creating Y-buckets averaged 17.8 seconds; four processors achieved a 3.5 speedup. The average CPU time for rendering the scanlines was 100 seconds. The speedup factor with four processors for this task was only 3.3, because of the critical section mentioned in Section 4.</p><p>From <ref type="figure">Figure 5</ref>, it is clear that, although 100% scalability is not achieved, there are significant speedups: 1.8, 2.5, and 3.3, respectively, for two, three, and four processors.</p><p>Memory use is another important factor in measuring the efficiency of an algorithm. Considering only the basic algorithm, without a hierarchy, the space shuttle grid itself takes 33.9 Mbytes, and the transformed vertex locations take 11.3 Mbytes. For a 500 500 window, the software frame buffer takes 5.  and the Y-bucket array takes 11.0 Mbytes. These sizes are viewindependent, and total to 51 Mbytes. The rest of the memory is used by the program to keep track of the polygons that it is rendering, so depends on the view. There is also some overhead for using multiple processors. For the scale 5.16, as reported in <ref type="figure">Figure 5</ref>, the total memory requirement ranged from 75 Mbytes for one processor to 87 Mbytes for four processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Comparison to Other Renderers</head><p>We have done speed comparisons of this new renderer against other direct volume renderers we have written. None of these other renderers have the generality to handle irregular multi-grids like the space-shuttle (which most renderers will not handle), and we have no other renderer that handles tetrahedral volumes. However, we can compare image quality and performance against the following: Ray Casting for rectilinear grids <ref type="bibr" target="#b22">[23]</ref>; Coherent Projection (hardware Gouraud shading) for rectilinear grids <ref type="bibr" target="#b26">[27]</ref>; and Incoherent Projection (hardware Gouraud shading) for single curvilinear grids <ref type="bibr" target="#b23">[24]</ref>.</p><p>Because of its extreme generality, our new software scan conversion algorithm cannot compete with methods designed to take advantage of the simplicity of regular grids. <ref type="figure">Figure 6</ref> compares the time taken to render each of the data sets described above by the renderers capable of handling them. Each volume is drawn in a 500x500 pixel window at a scale of 1 or 5 times.</p><p>We can provide some further general comments. First, software scan conversion generally produces pictures equivalent in image quality to ray casting, but much faster, because of the use of coherence. Also, our cell projection methods are not optimized for opaque data sets, while a ray caster processing front to back can easily halt when the pixel becomes opaque. Thus on a data set such as the head, the ray tracer can be competitive or even faster than other methods. In general, software scan conversion produces a noticeably clearer image with less artifacts than the hardware Gouraud shading methods. While it is noticeably slower, this cost may often be worth it for the improvement in image quality. <ref type="figure" target="#fig_7">Figure 8</ref> shows three images of the space shuttle at different scales.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Performance with the Hierarchy</head><p>There are two aspects of the hierarchy. First, there is the temporal savings of discarding whole invisible subregions at one time, rather than examining their primitives individually. We found this a significant savings only when zoomed in on the volume considerably (see <ref type="figure" target="#fig_6">Figure 7)</ref>, though with larger volumes, the gains may be more significant. For example, at a scale of 1, the hierarchy is slightly slower, whereas at a scale of 256, about twice as fast. As <ref type="figure" target="#fig_7">Figure 8</ref> indicates, scales of 256 and larger are needed to view these volumes.</p><p>The second aspect is the use of a multi-resolution model to approximate the information. <ref type="figure" target="#fig_8">Figure 9</ref> shows a comparison of the Lockheed fighter jet rendered using the scanline algorithm on every cell, and rendered using the hierarchy to draw an approximated version using hardware-assisted cell projection. The scanline image on the left is much better quality, but took over 3 minutes to render. The approximated version is suitable for exploring the volume and identifying regions of interest, and took less than three seconds to render.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>The renderer described in this paper allows rendering of large multiple intersecting irregular and regular grids including polygonal meshes without the use of expensive graphics hardware. Factors such as screen size and scale can affect the time needed to render the volume. The renderer is parallelizable and measurements show that this can greatly reduce elapsed time without greatly increasing memory requirements. Use of a k-d tree makes the algorithm better able to handle very large data sets. Accurate depth calculation can be achieved by using the projection method described in Section 6.</p><p>Future work should investigate more sophisticated methods to use the multi-resolution model effectively, including seamless mixtures of polygons and approximated regions.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>4 .</head><label>4</label><figDesc>For each (horizontal) scanline of the image, in bottom-to-top order: (a) Update y-actives list from previous line's y-actives and this line's y-bucket. (b) For each pixel in scanline, create its x-bucket list. (c) Initialize x-actives list as empty. (d) For each pixel in scanline, in left-to-right order: update xactives list from previous pixel's x-actives and this pixel's x-bucket; composite polygons in x-actives in front-to-back order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>The main processing steps are given here are described in Section 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Distributing polygons in a k-d tree, as described in Section 5. Grid is shown as solid lines, with numbered cells, upper left. Dashed lines show partitioning by k-d tree, whose skeleton appears lower left. The Tid array is partitioned into segments, as shown at right. For the view indicated, the "Possibly Visible" list identifies the segments belonging to tree nodes whose regions intersect the subvolume to be imaged.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>(</head><label></label><figDesc>begin-point) of v's left child; the end-point for the left child is the offset of v's right child; and the end-point for the right child is E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Perspective calculation notation. Visibility bounding box (Vbb) is centered at 0; 0; eo before user translation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure of perspective view in world space. Eye is at (0,0,0). Vbb is projected onto screen at left.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Speedups on space shuttle using a hierarchy to avoid invisible regions. Times are CPU seconds on an SGI Onyx using one 150-MHz processor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Three images of the space shuttle at different scales. Images took from 27 to 64 seconds on an SGI Onyx with four 150-MHz processors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Software scan conversion of the Lockheed fighter (a tetrahedral data set) on the left (time about 3 minutes), and an approximate version rendered using hardware cell projection (Section 5.3) on the right (time about 3 seconds). Times are on a 150-Mhz SGI workstation.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Funds for the support of this study have been allocated by NAS/NASA-Ames Research Center, Moffett Field, California, Grant Number NAG-2-991, and by the National Science Foundation, Grants Number CCR-9503829 and CDA-9115268.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="214" to="229" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Flowfield simulation of the space shuttle vehicle in ascent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Buning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">T</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename><forename type="middle">F W</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Meakin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Obayashi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">M</forename><surname>Rizk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Steger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yarrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth International Conference on Supercomputing</title>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="20" to="28" />
		</imprint>
	</monogr>
	<note>Space Shuttle data reference</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parallel volume rendering for curvilinear volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Judy</forename><surname>Challinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Scalable High Performance Computing Conference</title>
		<meeting>the Scalable High Performance Computing Conference</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1992-04" />
			<biblScope unit="page" from="14" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Scalable Parallel Direct Volume Rendering for Nonrectilinear Computational Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Judy</forename><surname>Challinger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-12" />
			<pubPlace>Santa Cruz</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Scalable parallel volume raycasting for nonrectilinear computational grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Judy</forename><surname>Challinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Parallel Visualization Workshop</title>
		<imprint>
			<date type="published" when="1993-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Multiresolution modeling and visualization of volume data based on simplicial complexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leila</forename><forename type="middle">De</forename><surname>Floriani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Puppo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1994 Symposium on Volume Visualization</title>
		<editor>Arie Kaufman and Wolfgang Krueger</editor>
		<meeting><address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Computer Graphics: Principles and Practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andies</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Feiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Hughes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley Publishing Company</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
	<note>2 edition</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Volume visualization of sparse irregular meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Giertsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="40" to="48" />
			<date type="published" when="1992-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Parallel volume rendering on a network of workstations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Giertsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johnny</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="16" to="23" />
			<date type="published" when="1993-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hierarchical z-buffer visibility</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ned</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Kass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gavin</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM SIGGRAPH Proceedings)</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="231" to="238" />
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Simulation of blunt-fin-induced shock-wave and turbulent boundary-layer interaction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ching-Mao</forename><surname>Hung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pieter</forename><forename type="middle">G</forename><surname>Buning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Fluid Mechanics</title>
		<imprint>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page" from="163" to="185" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast traversal of irregular volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koji</forename><surname>Koyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visual Computing -Integrating Computer Graphics and Computer Vision</title>
		<editor>T. L. Kunii</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="295" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hierarchical splatting: A progressive refinement algorithm for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM Siggraph Proceedings)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="285" to="288" />
			<date type="published" when="1991-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A scientific visualization renderer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;92</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="227" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Parallel volume ray-casting for unstructured grid data on distributed memory architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Rendering Symposium</title>
		<imprint>
			<biblScope unit="page" from="23" to="30" />
			<date type="published" when="1995" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A theory for multiresolution signal decomposition: The wavelet representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Mallat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="674" to="693" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Splatting of curvilinear volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoyang</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lichan</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;95</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995-11" />
			<biblScope unit="page" from="61" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Area and volume coherence for efficient visualization of 3d scalar functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM Workshop on</title>
		<imprint>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="27" to="33" />
			<date type="published" when="1990-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Mathematical Elements for Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><surname>Adams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>McGraw-Hill</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>2 edition</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1990-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Parallelizing volvis for multiprocessor sgi workstations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Uselton</surname></persName>
		</author>
		<idno>RNR-93-013</idno>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Moffett Field, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>NAS-NASA Ames Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Hierarchically accelerated ray casting for volume rendering with controlled error</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwansik</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>UCSC-CRL-95-31</idno>
		<imprint>
			<date type="published" when="1995-03" />
			<biblScope unit="volume">95064</biblScope>
			<pubPlace>Santa Cruz; Santa Cruz, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Rapid exploration of curvilinear grids using direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>UCSC-CRL-93-02</idno>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;93</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1993-10" />
		</imprint>
		<respStmt>
			<orgName>University of California technical report</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A Real Time Visible Surface Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Watkins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1970-06" />
			<pubPlace>Salt Lake City</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Utah</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">A scan-line algorithm for volume rendering of multiple curvilinear grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Tarantino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<idno>UCSC-CRL-95-57</idno>
		<imprint>
			<date type="published" when="1995-11" />
			<pubPlace>Santa Cruz</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Sciences Board, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A coherent projection approach for direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM Siggraph Proceedings)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="275" to="284" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Multi-dimensional trees for controlled volume rendering and compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<idno>UCSC-CRL-94-02</idno>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Volume Visualization</title>
		<meeting><address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
	<note>See also technical report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Interactive splatting of nonrectilinear volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;92</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
