<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Octree-Based Decimation of Marching Cubes Surfaces</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raj</forename><surname>Shekhar</surname></persName>
							<email>shekhar@bme.ri</email>
							<affiliation key="aff0">
								<orgName type="department">Biomedical Engineering Center</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Biomedical Engineering</orgName>
								<orgName type="institution">The Cleveland Clinic Foundation</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Biomedical Engineering Center</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<addrLine>260 Bevis Hall, 1080 Carmack Road</addrLine>
									<postCode>43210</postCode>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
							<affiliation key="aff5">
								<orgName type="department">Department of Biomedical Engineering</orgName>
								<address>
									<addrLine>Mail Stop Wb3, The Cleveland Clinic Foundation, 9500 Euclid Avenue</addrLine>
									<postCode>44195</postCode>
									<settlement>Cleveland</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Fayyad</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Biomedical Engineering Center</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Biomedical Engineering Center</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<addrLine>260 Bevis Hall, 1080 Carmack Road</addrLine>
									<postCode>43210</postCode>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
							<email>yagel@cis.ohio-state.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<addrLine>2015 Neil Avenue Mall</addrLine>
									<postCode>43210</postCode>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Fredrick</forename><surname>Cornhill</surname></persName>
							<email>cornhill@bme.ri</email>
							<affiliation key="aff0">
								<orgName type="department">Biomedical Engineering Center</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Biomedical Engineering</orgName>
								<orgName type="institution">The Cleveland Clinic Foundation</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Biomedical Engineering Center</orgName>
								<orgName type="institution">The Ohio State University</orgName>
								<address>
									<addrLine>260 Bevis Hall, 1080 Carmack Road</addrLine>
									<postCode>43210</postCode>
									<settlement>Columbus</settlement>
									<region>OH</region>
								</address>
							</affiliation>
							<affiliation key="aff5">
								<orgName type="department">Department of Biomedical Engineering</orgName>
								<address>
									<addrLine>Mail Stop Wb3, The Cleveland Clinic Foundation, 9500 Euclid Avenue</addrLine>
									<postCode>44195</postCode>
									<settlement>Cleveland</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Octree-Based Decimation of Marching Cubes Surfaces</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The Marching Cubes (MC) algorithm is a commonly used method for generating isosurfaces. The MC algorithm also generates an excessively large number of triangles to represent an isosurface. Generating many triangles increases the rendering time which is directly proportional to the number of triangles. This paper presents a decimation method to reduce the number of triangles generated by the MC algorithm. Decimation is carried out within the framework of the MC algorithm before creating a large number of triangles. Four major steps comprise the reported implementation of the algorithm: a) surface tracking, b) merging, c) crack patching, and d) triangulation. Surface tracking is an enhanced implementation of the MC algorithm. Starting from a seed point, the surface tracker visits only those cells likely to compose part of the desired isosurface. This results in up to approximately 80% computational saving The cells making up the extracted surface are stored in an octree that is further processed. A bottom-up approach is taken in merging the cells containing a relatively flat approximating surface. The finer surface details are maintained. Cells are merged as long as the error due to such an operation is within a user-specified error parameter, or a cell acquires more than one connected surface component in it. A simple, yet general, crack patching method is described that forces edges of smaller cells to lie along those of the larger neighboring cells. Patching does not introduce new triangles. The overall saving in the number of triangles depends both on the specified error value and the nature of the data. We demonstrate savings of more than 90% for two artificial datasets and an MRI head dataset for an error value of less than half the minimum voxel dimension. Use of the hierarchical octree data structure also presents the potential of incremental representation of surfaces. We can generate a highly smoothed surface representation which can be progressively refined as the user-specified error value is decreased.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Rendering isosurfaces, as opposed to volume rendering, is an area of continued interest to the visualization community. Availability of dedicated hardware to speed up surface rendering and thus achieve real-time or near real-time interaction has been a major contributing factor to this interest. Several algorithms can generate isosurfaces from 3D data. The Marching Cubes (MC) algorithm <ref type="bibr" target="#b2">[3]</ref> has, by far, been the most popular one in generating high-quality surface representation. Experience with visualizing medical datasets has proved that, despite the attractiveness of the surface rendering approach, the number of surface primitives (triangles) generated by the MC algorithm can be prohibitive to achieving a reasonable rendering speed. To circumvent this problem, original datasets are commonly downsampled before applying the MC algorithm to yield a surface representation of reasonable size. Thus there is a trade-off between surface detail and rendering speed.</p><p>The proposed decimation algorithm uses adaptive downsampling as a way to reduce the number of surface primitives. It downsamples the volume dataset where the isosurface is mostly flat and maintains high resolution in parts with finer details. Where the volume is being downsampled, the MC algorithm is applied to cells of 2×2×2, 4×4×4 or even larger dimensions, depending on the local surface characteristics and a user-specified error value. Therefore, the algorithm approximates the surface with large triangles at low frequency regions and small triangles at high frequency regions. This process increases the complexity of the surface generation algorithm, but helps to greatly reduce the number of surface primitives and subsequently enhances the performance of the renderer. Further, the quality of the surface generated is not significantly compromised. The overall surface quality is controlled by the user through the error value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>Several attempts have been made to reduce the number of triangles generated by the MC algorithm. The most notable, the decimation algorithm by Schroeder et al. <ref type="bibr" target="#b4">[5]</ref>, substitutes the triangular mesh obtained by the MC algorithm with a simpler mesh generated from a subset of original vertices. Vertices are classified as one of the six types based on their interconnections with neighboring vertices. Each vertex is a candidate for deletion and the error resulting from removing a vertex is evaluated. If the resulting error is within a user-specified limit, the vertex is deleted from the mesh. The algorithm has been shown to reduce the number of triangles by as much as 90% without much distortion. One major problem with this method is that a large number of triangles is generated, only to be eliminated later on.</p><p>Shu et al. <ref type="bibr" target="#b5">[6]</ref> report an adaptive MC algorithm. The MC algorithm is first applied to cells of a given size, which is a power of 2 (2×2×2, 4×4×4, 8×8×8 or so). If the approximating surface is not flat enough based on a curvature criterion, the initial cell is subdivided. The process continues until either the approximating surface is satisfactory or the initial cell is divided into 1×1×1 cells. There are several drawbacks to this approach. Primarily, savings of 55% do not compare favorably with those of nearly 90% offered by the decimation algorithm described above and the algorithm presented in this paper. Moreover, starting the process with cells of a fixed size may not fully exploit the possible reduction. Another drawback is that applying curvature criterion on the edges for splitting cells may cause loss of finer features present within the cells. In addition, crack patching replaces the cracks with equivalent polygons which may counter the saving. And finally, the algorithm is limited to datasets of resolutions of the power of 2.</p><p>Montani et al. <ref type="bibr" target="#b3">[4]</ref> have proposed a discretized MC algorithm where the edge intersections are approximated by edge midpoints. The authors argue that the error introduced with midpoint selection is within acceptable limits. The saving in their approach results primarily from the removal of smaller facets and the merging of the coplanar facets. Midpoint selection improves the chances that facets from neighboring cells will be coplanar. The investigators also report 80-90% savings in the number of triangles. The algorithm we propose can incorporate this idea and result in further saving.</p><p>Wilhelms and Van Gelder <ref type="bibr" target="#b6">[7]</ref> report use of an octree data structure to enhance the MC algorithm. Visiting only a subset of all the possible cells increases the efficiency. Octrees, with their hierarchical structure, provide a natural framework for avoiding the unnecessary cells. The enhancement in the present work is, however, achieved through tracking a surface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Surface Tracking ↓</head><p>Merging ↓ Crack Patching ↓ Triangulation <ref type="figure">Figure 1</ref>. The four steps in the reported implementation of the octree-based decimation algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ALGORITHM</head><p>The octree-based decimation algorithm involves four steps, as outlined in <ref type="figure">Figure 1</ref>. The first step is surface tracking, which is the application of an enhanced MC algorithm to the dataset. Surface tracking identifies each cell through which the isosurface passes. The result of surface tracking is saved in an octree data structure. Several passes are made through this octree to achieve a compact surface representation. The octree is first processed to replace simple cells by a larger cell, if allowed by the merge criteria. This adaptive technique will develop cracks at the interface of cells with different resolutions. Such cracks are removed in a subsequent pass. The final step is to create the triangles that make up the surface. Each step of the algorithm is explained in detail below. Surface tracking is optional as far as decimation is concerned. The Discussion section elaborates on a possible implementation without surface tracking.</p><p>Step</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1: Surface Tracking</head><p>The original MC algorithm by Lorensen and Cline <ref type="bibr" target="#b2">[3]</ref> exhaustively searches all the cells in a 3D dataset in its attempt to find an isosurface. Our improvement over the original MC algorithm is based on the observation that a connected surface can be more efficiently extracted by following it and hence "marching" only into the cells that contain the surface. Surface tracking guarantees a connected surface and avoids any stray surface primitives arising due to noise in the data. The final surface descriptions obtained from the two methods are identical for a single component surface. Described below is the original MC algorithm, the enhancement we propose, and the octree data structure we have used for storing results of surface traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Original MC Algorithm</head><p>The basic MC algorithm operates on cells with a grid point at each of its eight vertices. The vertices of a cell can be either inside or outside of the surface given a threshold function, thus generating 256 possible permutations, also called cases. Topologically, however, there are only 15 distinct cases, as shown in <ref type="figure" target="#fig_0">Figure 2</ref>. The figure also shows the triangulation scheme to approximate the part of the surface present in a cell for a given topological configuration. The points of intersection on the edges of a cube are computed from linear interpolation. The algorithm examines each cell and determines its case (0 through 255). If the case happens to be non-trivial (other than 0 and 255), the triangles for that case are generated and appended to the list of triangles representing the isosurface. Attention is paid to proper ordering (clockwise or counter-clockwise) of triangle vertices because that order determines which side of the triangle will be rendered as a front or a back face.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Enhanced MC Algorithm</head><p>The modified algorithm we propose is based on recognizing the following.</p><p>• Typically in many applications, even a very complex surface within a 3D dataset passes through only a small percentage of the total cells. Thus, an exhaustive search of all the cubes is deemed unnecessary.</p><p>• If a cell with a piece of surface in it is known, the neighboring cells (front, back, top, bottom, left and right) where the surface may extend can be determined based on the continuity of surface.</p><p>Based on the above observations, the 15 topologically distinct cases, as depicted in <ref type="figure" target="#fig_0">Figure 2</ref>, can be further tagged to show the number of 6-connected neighboring cells to visit from the current cell. The number of neighboring cubes to visit is either 0, 3, 4, 5 or 6. For example, if a cube of case 1 is encountered, only the three neighboring cells having one of the edges of the approximating triangle need to be visited. On the other hand, a cell of case 10 would require that all six neighbors be explored. It must be noted that only six out of 15 topologically distinct cases avoid visiting all the six neighboring cubes. However, our experience shows that these six cases account for 90% of the cases encountered in extracting an isosurface. <ref type="figure" target="#fig_1">Figure 3</ref> shows which cubes to visit for the six topologically distinct cases that result in savings. This figure also indicates the neighboring cells that one should visit. The algorithm maintains a linked list of candidate cells, called a candidate list, and a 3D flag array exactly the size of the 3D dataset. The user specifies a seed cell, i.e., a cell having a piece of the desired isosurface, by examining a slice out of the 3D dataset. The seed cell is the lone member of the candidate list in the beginning. Moreover, all the elements of the flag array are initially marked not-visited. The execution starts by popping off the first member from the candidate list for exploration. At each cell there are two decisions to be made. The first is to determine the case of the current cell, a number between 0 and 255 inclusive, by applying the threshold function to the eight vertices of the cell. The second decision involves finding out which neighboring cells to visit from the current cell. Although we generate the information on the fly, a look-up table, indexed by case, could be created that dictates which cells to visit from a given cell. The cells to be visited are appended to the candidate list if they have not already been visited. In the course of execution, cells that are explored have their corresponding flag marked visited. The execution stops when the candidate list becomes empty. By this time, the isosurface has been completely extracted. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Storage of the Isosurface in an Octree</head><p>Storing the isosurface is an integral part of the surface tracking method described above. The use of the octree data structure for this purpose is quite crucial. The depth of the octree is determined from the largest dimension of the dataset. If the dataset is X×Y×Z in size, the depth of the octree is the largest integer greater than or equal to the logarithm of the maximum of X, Y and Z.</p><p>Each node of the octree, which is grown on a demand basis, stores case information, intersection points (intersection of isosurface with the edges of a cell), and child nodes. During surface tracking, as cells containing the isosurface are identified, they are stored at the leaf nodes along with their case numbers and intersection points. The location (x, y, z) of the cells is implicitly present in the branching of the octree, and, therefore, is not stored. The intermediate nodes, at the completion of surface tracking, do not have a valid case (a number between 0 and 255) and intersection points. Since all eight children are inserted in the octree whenever branching is deemed necessary, there are many empty leaf nodes that do not have a valid case, either.</p><p>Step</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2: Merging of Cells</head><p>Merging is the most important component of this algorithm. The octree is traversed level by level from bottom to top. If the octree has n levels, the nodes at the (n -1)th level are taken up first. The nodes at this level are each the parents of eight 1×1×1 cells, which are also the leaf nodes of the octree. The child nodes under such parent nodes are evaluated to see if they can be merged together based on the merge criteria explained below. After processing all the nodes at the (n -1)th level, one moves up in the octree and considers nodes at the (n -2)th level, i.e., the parents of 2×2×2 cells. The process is repeated until the top of the octree is reached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Merge Criteria</head><p>At any level of the octree, merging attempts to replace eight child cells with a single parent cell. If successful, the result is a valid case for the parent cell as if the MC algorithm had been applied to the parent cell itself to begin with. The following conditions must be satisfied for a successful merge.</p><p>1) All the eight child cells must either be "simple" cases or null. A child cell is null if no surface passes through it (Case 0 of <ref type="figure" target="#fig_0">Figure  2)</ref>. A simple case is one in which the cell has only one connected surface. Therefore, in <ref type="figure" target="#fig_0">Figure 2</ref>, topologically distinct cases 1, 2, 5, 8, 9, 11 and 14 are the only simple cases.</p><p>2) At intermediate levels of the octree, the current node may have child nodes that in turn have child nodes without a valid case. This situation indicates that merging failed at a lower level. If the merging failed somewhere below the current node, then no merging occurs at the current node.</p><p>3) Inherent to the MC algorithm is the property that a cell edge can have no more than one intersection point. While merging, this condition is checked for the resulting parent cell or the current node. If the parent cell results in more than one intersection on any of its edges, whether inside or outside, merging is aborted at the current node and no changes are made to the octree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4)</head><p>If the above conditions are successfully met, but the resultant case for the current node is not a simple case, merging is not pursued. The rationale behind this is that such cases may result in two edges on at least one face of the parent cell. Having two edges causes ambiguity in the patching algorithm, described below. Case 10 of <ref type="figure" target="#fig_0">Figure 2</ref> represents this scenario where there are two edges on a face despite having not more than one intersection point per edge.</p><p>If the above four conditions are met, the intersection points for the parent cell are computed. The intersection point calculation is not repeated; rather, the intersection points of the child nodes are combined to obtain the intersection points of the parent. Space is allocated once again on demand to hold the intersection points at the current intermediate node.</p><p>5) The last criterion is to test if the error due to merging is within a user-specified limit. A least-squares plane is fit to the intersection points of the current cell. Next, the perpendicular distance of the intersection points saved at the leaf nodes (lowest level of the octree) below the current node is computed. If the maximum of such perpendicular distances is not greater than the permissible error, merging is allowed. If merging fails, then the intersection points computed after condition 4 above are deleted.</p><p>Merging is successful if all of the above five conditions are met. Following a successful merge, the case field of the current node (until now having not a valid value) is replaced with the case determined above. It is important to note that the intersection points of the leaf nodes, not the immediate children, are used for error calculation in step 5. This step would make a difference if the parent node represents a 4×4×4 or larger cell. Of course, the immediate children would be leaf nodes if the parent node is a 2×2×2 cell. It is for this error calculation step that the child nodes below a successful merge node are not deleted initially. They will not be needed if the merging fails at a higher level node. To remove unnecessary nodes when the merging fails, the algorithm works its way down the sub-octree and deletes all the nodes below those nodes with a valid case number and an array of edge intersection points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Step 3: Crack Patching Strategy</head><p>The merge algorithm modifies the octree. One can picture the octree after the merging as having nodes with a valid case number and an array of edge intersection points at all levels and not just the bottom level. Such nodes at higher levels are the result of the merging. If the triangulation is performed at this stage, cracks are generated at the interfaces of cells with differing dimensions. This is a common problem with adaptive subdivision algorithms. <ref type="figure" target="#fig_2">Figure 4</ref> shows one simple scenario where a 2×2×2 cell interfaces with 1×1×1 cells. To state the problem differently, there exist two edges at the interface that do not quite match, thus causing the crack. Let us call the edge originating from the bigger cell a lowresolution edge, and the other a high-resolution edge. Patching is accomplished by stretching the high-resolution edge to match with the low-resolution edge. The points that make the high-resolution edge are replaced by their perpendicular projections on the lowresolution edge <ref type="figure" target="#fig_2">(Figure 4</ref>). Since the points that make up the highresolution edge are stored as intersection points at the appropriate nodes, patching simply updates those intersection points. <ref type="figure" target="#fig_2">Figure 4</ref> shows a straightforward example of where patching was required, but it is not hard to imagine more complicated situations where, for example, a 4×4×4 cell meets with both 2×2×2 and 1×1×1 cells. The patching strategy takes into account all these situations. The major steps in patching are the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1)</head><p>Traverse the octree in a breadth-first manner.</p><p>2) If a node with a valid case is encountered, then following the logic of the surface tracker, patching is applied to its 6-connected neighboring cells at the same level of the octree to which the surface extends.</p><p>3) If a neighboring cell does not exist, the current cell is either on the edge of the dataset or is a neighbor of a larger cell. In the former case, patching cannot be carried out since there are no data, while in the latter situation, the larger neighboring cell would have taken care of patching. Since the octree is traversed in a breadth-first fashion, it is always the responsibility of the larger neighbor to move the intersection points of its smaller neighbors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4)</head><p>If the neighboring cell exists and has a valid case, the neighbor is a cell of the same dimension and, hence, there is no chance of having a crack at the interface. Patching is not required in this case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5)</head><p>If the neighboring cell has child cells below it, then the child cells that have a common face with the current cell are evaluated. If those cells have an edge on the common interface, the two end points of that edge are identified and moved to fall on the lowresolution edge.</p><p>6) Patching stops when the breadth-first traversal of nodes stops. Step</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4: Triangulation</head><p>The last step is to output the surface by triangulation. All the nodes in the octree with a valid case contain a part of the isosurface. Forming the surface, therefore, requires identifying such nodes and outputting their intersection points following the triangulation scheme of the MC algorithm. The nodes of the octree can be traversed and the triangles can be created in any order if it is the final shape that is of interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RESULTS</head><p>The following three datasets were used for this work.</p><p>1) 64×64×64 Sphere dataset with dx = dy = dy, 2) 128×128×84 MRI head dataset with 1.8dx = 1.8dy = dz.</p><p>3) 256×256×256 <ref type="table">Table dataset</ref> with dx = dy = dz, and <ref type="table" target="#tab_0">Table 1</ref> compares the execution times of the surface tracker and the original MC algorithm. All the execution times reported in this section are elapsed times on a Silicon Graphics Indigo-2 (R4400, 200MHz) workstation. The table shows that the surface tracker always outperforms MC algorithm and the computational saving increases with increasing resolution of the dataset. The octree-based adaptive MC algorithm was applied to the above datasets for a range of user-specified error values. The error value is a multiple of the smallest voxel dimension (the minimum of dx, dy and dz). The wiremesh models for an error value of 0.5 are shown in <ref type="figure" target="#fig_3">Figure 5</ref>. This figure shows the sites where smaller triangles were replaced by larger ones. <ref type="figure" target="#fig_4">Figure 6</ref> shows the rendered images at 0.0, 0.1 and 0.5 error values. <ref type="figure">Figure 7</ref> shows the savings for the different datasets against user-specified error value.  <ref type="table" target="#tab_1">Table 2</ref> shows the execution time of the complete algorithm for the three datasets at an error value of 0.5. The execution time is directly related to the size of the dataset.  Head <ref type="figure">Figure 7</ref>. Percent saving in the number of triangles versus userspecified error value for the three datasets. The saving curves start to plateau beyond an error value of approximately 1.0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DISCUSSION</head><p>Surface tracking is computationally more efficient than the original MC algorithm for the extraction of an isosurface. Moreover, the efficiency increases with higher resolution datasets as shown in <ref type="table" target="#tab_0">Table 1</ref>. Another advantage of surface tracking is that a connected surface is always obtained. This eliminates the need to apply a connectivity algorithm <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> following surface extraction in many applications. Any stray surface primitives arising due to noise in the data are also avoided. The final surface descriptions obtained from the two methods are identical if a single surface component is present in the data. Surface tracking allows selective generation of isosurfaces in multi-component data. For a 3D dataset with concentric spherical isosurfaces, while the original MC algorithm will generate all the surfaces, only the most exterior one will be visible upon rendering. On the other hand, surface tracking allows one to narrow down to the isosurface of interest and keep the surface representation compact.</p><p>The reasons for using the octree data structure are many. Octrees allow the use of any resolution dataset and not just those with a power of 2. Furthermore, the X, Y and Z dimensions need not be identical. This is convenient, particularly when dealing with medical (MRI, CT, etc.) datasets, which typically have lower resolution in the axial direction than in the other two. If the data dimensions are not similar, the resulting octree may be quite unbalanced. However, this has no adverse effect on the processing. Octrees also lend themselves well to the hierarchical representation of surfaces.</p><p>An attractive feature of the merging algorithm is that it is controlled by a user-specified parameter. For small error values in the vicinity of zero, the algorithm removes most of the redundancy in surface representation by the MC algorithm.</p><p>Triangles constituting coplanar parts of the surface are replaced by larger triangles without affecting the end result. However, as the error value is increased, more and more smoothing of the surface takes place. Like other adaptive approximation algorithms, it is hard to predict the overall saving given an error value. The saving is also dataset dependent. The same error value can produce different amounts of saving for different datasets, as is evident from <ref type="figure">Figure 7</ref>. However, there is a monotonic relationship between the error value and the saving, i.e., the higher the error value, the greater the saving. Also evident from the plots of <ref type="figure">Figure 7</ref> is that this relationship is non-linear. It must be noted that what limits merging of smaller cells into bigger ones is not just the user-specified error value, but the feasibility of merging smaller cells as well. If complex cases, i.e., cells with more than one connected surface, are encountered, the merging does not proceed. The plateau region of the curves is attributed to this feature of the merging process.</p><p>The crack patching strategy is simple and robust. Unlike many reported adaptive algorithms, patching does not create new triangles. Thus the benefits of merging are not overcome by the burden of crack patching. Furthermore, although patching moves intersection points, which in some cases may take an intersection point out of the cell from which it originated, the triangulation scheme of our modified MC algorithm is unaffected. Since patching involves moving the points forming a high-resolution edge, there is a chance that the error introduced due to such movement may exceed the user-specified error value. The net error cannot be too far away from the acceptable error. First of all, since the low-resolution edge was obtained within the limits of allowed error, stretching the high-resolution edge to overlap with the low-resolution edge should keep the error well within the limit. Moreover, most likely, the high-resolution edge was present because merging did not proceed due to a cell with a complex case, rather than the violation of the error criterion.</p><p>The accuracy of surface representations generated by our algorithm can be qualitatively judged by comparing rendered models in columns 2 and 3 of <ref type="figure" target="#fig_4">Figure 6</ref> against those in column 1.</p><p>As expected, more and more smoothing takes place as the error value is increased. At an error value of 0.1, the decimated and the non-decimated models are indistinguishable in their rendered image quality. The result of merging is seen in the wiremesh models of <ref type="figure" target="#fig_3">Figure 5</ref>. Merging was uniform for the sphere due to its symmetry. For the head dataset, however, the merging took place at relatively flat areas. Note that the finer details near the ear have been maintained.</p><p>The processing time of the algorithm is acceptable. Even though our implementation of the algorithm is not speed-optimized, the execution time was found to be less than half a minute on a Silicon Graphics Indigo-2 (R4400, 200MHz) workstation for the datasets used.</p><p>It is important to note that the surface tracking is not inseparable from the decimation algorithm. A different implementation of the ideas presented above can recursively apply decimation to the 3D dataset. The recursive algorithm will employ the original MC algorithm to generate the case and edge intersection points. This may be the desired approach for applications where isosurfaces have multiple components.</p><p>Several other variants of the algorithm presented here are possible. One could merge the cells in the octree as much as possible and record the maximum error due to the merging at each node. Since no nodes will ever be deleted, this will not be a memory-saving implementation as described above. However, a hierarchical representation of the surface will be possible. Surfaces can be formed for any given error value. The octree will be traversed in a similar top to bottom manner. The nodes satisfying the error criterion will be output. The crack patching strategy will have to be slightly modified so that it correctly identifies the nodes with a high-resolution edge. Having surfaces at varying degrees of detail is particularly attractive for animation applications. This allows an animator to maximize the level of surface detail while working within the constraint of an interactive frame rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSIONS</head><p>We have presented an enhanced implementation of the MC algorithm and a decimation technique that works within the framework of the MC algorithm. The saving in the number of triangles and the quality of the rendered surfaces compare favorably to the works described by other researchers. The unique features of our implementation are:</p><p>• Bottom-up approach to merging that guarantees preservation of finer details.</p><p>• Smoothing controlled by a user-specified error parameter.</p><p>• A simple crack patching scheme that maintains C 0 continuity of the MC algorithm and yet does not add extra triangles to the final surface representation.</p><p>• The ability to construct a surface incrementally with our use of a hierarchical octree data structure.</p><p>• Applicability of the methods to datasets of any resolution.</p><p>Future work will be directed toward developing a strategy to merge cells with complex cases that have more than one connected surface in them. This will help in further compacting the surface representation. Incremental generation of surfaces and recursive implementation of the decimation algorithm, as indicated above, will also be pursued.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Topologically distinct cases of the Marching Cubes algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Six topologically distinct cases that lead to savings in surface tracking. Bold arrows show the neighbors that will be visited by the surface tracker.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>A schematic diagram showing how crack patching moves the intersection points to align high-and low-resolution edges at an interface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Wiremesh models of the sphere and head datasets at an error value of 0.5. Due to symmetry, the merging of cells is quite uniform for the sphere, while, the head shows the adaptive nature of the merging.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Rendered surface models of sphere, table and head datasets at error values of 0, 0.1 and 0.5 from left to right. The visual quality of rendered non-decimated and decimated (at an error value of 0.1) models is nearly indistinguishable while resulting in a saving of 68-88%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Computational saving of the surface tracker</figDesc><table><row><cell></cell><cell cols="2">Execution Time (sec)</cell><cell></cell></row><row><cell>Dataset</cell><cell>MC</cell><cell>Surface</cell><cell>Saving (%)</cell></row><row><cell></cell><cell>Algorithm</cell><cell>Tracker</cell><cell></cell></row><row><cell>Sphere</cell><cell>2.8</cell><cell>1.7</cell><cell>39.3</cell></row><row><cell>Head</cell><cell>12.5</cell><cell>5.2</cell><cell>58.4</cell></row><row><cell>Table</cell><cell>103.7</cell><cell>21.2</cell><cell>79.6</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Execution time of the decimation algorithm</figDesc><table><row><cell>Dataset</cell><cell>Time (sec)</cell></row><row><cell>Sphere</cell><cell>2.3</cell></row><row><cell>Head</cell><cell>7.0</cell></row><row><cell>Table</cell><cell>28.0</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to extend thanks to our colleagues Mr. Ajeetkumar Gaddipati for his invaluable suggestions and readiness to discuss issues related to our algorithm, and. Dr. Elizabeth Fisher for providing us the MRI dataset.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">3D Reconstruction of the brain from magnetic resonance images using a connectivity algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Dumoulin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hart</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ludke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Magnetic Resonance Imaging</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="345" to="352" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Three dimensional segmentation of MR images of the head using probability and connectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kikinis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Jolesz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Assisted Tomography</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1037" to="1045" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Discretized marching cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scateni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization</title>
		<meeting>Visualization</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="281" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Kankanhalli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adaptive marching cubes. The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="202" to="217" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Octree for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
