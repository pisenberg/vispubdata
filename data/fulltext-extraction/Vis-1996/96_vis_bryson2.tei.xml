<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Time Management, Simultaneity and Time-Critical Computation in Interactive Unsteady Visualization Environments</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Bryson</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandy</forename><surname>Johan</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">MRJ, Inc./NASA Ames Research Center</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">NASA Ames Research Center</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Time Management, Simultaneity and Time-Critical Computation in Interactive Unsteady Visualization Environments</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper describes time management and time critical computing for a near-real-time interactive unsteady visualization environment. Subtle issues regarding the flow of time are described, formalized and addressed. The resulting system correctly reflects time behavior while allowing the user to control the flow of time. The problem of time-critical computation is discussed, and a solution is presented. These time-critical algorithms provide control over the frame rate of a visualization system, allowing interactive exploration.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Unsteady, or time-varying, simulations are becoming increasingly common in computational science. Examples abound in computational fluid dynamics (CFD) and computational magnetohydrodynamics (MHD) among other fields. These simulations typically involve extremely complex phenomena, reflecting spatial and temporal behaviors. The purpose of these simulations is typically to provide insight into these phenomena. Visualization provides a significant contribution to this insight. For this paper, we are assuming that the unsteady behavior is represented as a series of discrete timesteps of data.</p><p>Several new challenges arise in the visualization of unsteady data sets. One of these challenges is to provide to the researcher performing the simulation the means to explore that simulation. Near-real-time interactive direct-manipulation techniques (which we will refer to as "direct-manipulation") are one approach to the problem of simulation complexity. Direct manipulation techniques allow the researcher to move a visualization to a desired location and view that visualization after a short delay, resulting in the effect of exploring the simulation data. While the delay between a user control motion and the display of a resulting visualization is best kept less than 0.2 seconds, experience has shown that delays in the display of the visualization of up to 0.5 seconds for the visualization are tolerable in a direct manipulation context. Direct manipulation allows the researcher to quickly explore a data set, identifying phenomena of interest. The most fully developed use of direct manipulation is in virtual-reality based visualization systems such as the virtual windtunnel.</p><p>To be effective, direct manipulation requires that the user have some immediate (&lt;0.1 seconds) visual feedback reflecting the user's control motions. Longer feedback delays can result in significant degradation of the user's ability to control the visualization environment. As this feedback time scale (&lt;0.1 seconds) is less than the timescale required for the computation and display of the visualization (&lt;0.5 seconds), it is useful to have the graphics (which reflects the user's control motions) operating asychronously from the visualization computation. This way, a cursor representing, for example, the user's hand position will update quickly even when the resulting visualization computation takes up to 0.5 seconds.</p><p>This decoupling of the graphics and computation has become standard and is typically implemented via multiple processes, with the results of the computation communicated from the visualization computation process to the graphics process through shared memory, UNIX sockets, or a network protocol. This architecture has been implemented in several systems for steady flow visualization. In such a steady visualization environment, newly computed visualizations are simply drawn when they are completed.</p><p>When the computation and graphics are decoupled in an unsteady flow visualization environment, new complications arise. These complications involve making sure that simultaneous phenomena in the simulation are displayed as simultaneous phenomena in the graphics, and ensuring that the time flow of the computation process is correctly reflected in the time flow of the displayed visualizations. All of this should happen without introducing delays into the system by, for example, causing the graphics process to wait for the computation to complete. The situation is further complicated if the system allows the user to slow, stop, or reverse the apparent flow of time (without slowing or stopping the graphics process), while still allowing direct manipulation exploration within an individual data timestep. We refer to these issues as the problem of time management. Formalizing these requirements and providing an algorithm to meet these requirements is one of the main purposes of this paper.</p><p>Another issue that arises in a direct manipulation environment is the requirement that any computation resulting from a direct-manipulation user control action not take too much time. As mentioned above, experience has shown that visualization computations should return within less than 0.5 seconds. Other situations may imply other time scales, and the time scale may be userselectable. The problem of ensuring that the visualization computation does not take more than a given amount of time is known as time-critical computation. An approach to time-critical computation appropriate to unsteady CFD visualization environments is the other purpose of this paper.</p><p>Section 2 briefly surveys related work. Section 3 of this paper describes the virtual windtunnel system and architecture which was used to implement the time management and time-critical computation algorithms described in this paper. Section 4 describes the multiple-process architecture and introduces the issue of locking. Section 5 addresses the time management problem, while section 6 addresses the time-critical computation problem. The paper is summarized in section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Several unsteady visualization environments have been developed which synchronize their computation and display cycles. The time management issues addressed in this paper do not arise in such systems.</p><p>Some of these dedicated systems have been implemented with an interactive virtual reality interface, such as those developed at the University of North Carolina <ref type="bibr" target="#b0">[1]</ref> <ref type="bibr" target="#b1">[2]</ref>, and particularly with the CAVE environment <ref type="bibr" target="#b2">[3]</ref>.</p><p>Several virtual reality systems have been developed <ref type="bibr" target="#b1">[2]</ref>[5] which separate the graphics and computation process, usually by distributing these functions among several platforms.</p><p>Work related to time-critical graphics will be discussed in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">REQUIREMENTS OF THE VIRTUAL WINDTUNNEL</head><p>This paper presents solutions to the time management and time-critical computation problems as they have been implemented in the virtual windtunnel <ref type="bibr" target="#b5">[6]</ref> <ref type="bibr" target="#b6">[7]</ref>. The virtual windtunnel uses an object-oriented based implementation, where each visualization is an object. Objects in the virtual windtunnel environment are managed through an environment object list. The algorithms in this paper will be described in terms of a generic C++ object syntax, which closely reflects the structure in the virtual windtunnel.</p><p>The virtual windtunnel is at the intersection of two highly demanding applications of computer graphics: near-real-time interactive virtual environment systems and time-varying fluid flow visualization. In this section we outline the virtual windtunnel's underlying software framework relevant to this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Requirements of Computational Fluid Dynamics Visualization</head><p>The numerical data resulting from CFD simulations are typically vector and scalar fields in three-dimensional space that change over time. Time-varying datasets are provided on computational grids, with the time evolution of the data being encoded as a series of data files. Thus there is a discrete sense of time built into the data. A given visualization task can involve the simultaneous examination of several data fields, such as pressure, density and velocity.</p><p>Fluid flow visualization typically involves the two-stage process shown in <ref type="figure" target="#fig_0">Fig. 1</ref>. Data (usually a precomputed file on disk) is processed into visualization geometry called extracts which are displayed using three-dimensional computer graphics. Extracts are specified by user input. While some extracts such as arrows for a vector field involve little computation, others can involve significant computation. Isosurfaces, for example, involve interpolating values on the computational grid to compute surfaces reflecting a value specified by the user. Streamlines involve the integration of a vector field starting from a point in space specified by the user. Once the extracts are computed they may be displayed with a variety of user options. In a complex flow simulation several visualization extracts may be required to exhibit interesting phenomena, as shown in <ref type="figure" target="#fig_1">Fig. 2</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Requirements of Direct Manipulation</head><p>Direct manipulation in the virtual windtunnel is through abstract static gestures (sometimes called poses) at a position and orientation in space determined by a tracking device. These gestures may be the result of button pushes or gesture recognition based on a glove device. There are three static gestures defined in the virtual windtunnel: grab, point, and null. The action of each gesture is dependent on the context in which the gesture is made <ref type="bibr" target="#b6">[7]</ref>.</p><p>Direct manipulation is based on mapping data at a position in space, usually the position of the user's hand or mouse pointer, to an action in the virtual environment. This position and orientation data must be mapped to visualizations in order to specify their extracts. Visualizations that are specified using data at a point in space are called local visualizations. For visualization techniques such as vectors, streamlines, and cutting planes this is straightforward. Isosurfaces, however, are usually specified by value, without a spatial manipulation metaphor. For the virtual windtunnel, the concept of local isosurface was developed <ref type="bibr" target="#b9">[10]</ref>. This isosurface is specified by sampling the value of a scalar field at a point in space</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data</head><p>Extract Rendered</p><p>User Input</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computationally Intensive</head><p>Images and constructing the isosurface around that point. Using local isosurfaces the user can interactively explore the geometry of the scalar field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RUN-TIME SOFTWARE ARCHITECTURE</head><p>The run-time software architecture of the virtual windtunnel is designed to support both consistent high rendering rates and large amounts of computation. This architecture consists of two groups of processes, reflecting the difference in times scales between the rendering and computation tasks described in section 1. There is a graphics process group executing the draw functions of the environment objects, and a computation process group executing the compute functions, both executing asynchronously from each other. Both of these groups access a list of environment objects, leading to the requirement of process locking particularly during object creation or deletion. In addition, the results of the computational process must be communicated to the rendering processes respecting the requirements outlined in section 5. These processes are outlined in <ref type="figure">Fig. 3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 3</head><p>The computational processes of the virtual windtunnel, including the optional child graphics process created when there is a second graphics pipeline used for stereoscopic display. The computation process creates several parallel subprocesses that call the compute functions of the environment objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Graphics Process Group</head><p>When supported by the graphics hardware, the virtual windtunnel uses two graphics pipelines to produce visual stereoscopic images, one pipeline for each eye. The graphics processes are synchronized through the use of a pair of flags in shared memory. At the end of a draw cycle, each process does not proceed unless the other process has indicated it has also completed its draw cycle.</p><p>The parent graphics process (which is also the parent process of the virtual windtunnel) handles user interaction, polling the interface devices. Changes in the environment state, including the creation and deletion of objects are executed by this function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Computation Process Group</head><p>The computation process group is designed to take advantage of available multiple processors. It is comprised of one lightweight process which executes the environment objects' compute function in parallel using the SGI m_fork family of functions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data Buffers</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Synchronization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graphics Process Group</head><p>Group ronment object list is traversed in parallel with each processor taking charge of an object in turn. Because the object list is implemented as an array, the parallel execution of this list is straightforward.</p><p>Environment objects only recompute themselves when their defining parameters have changed or when the data to be displayed has changed due to, for example, time variation. The objects themselves determine whether or not they require computation at the start of their compute functions, so all objects' compute functions are called by the computation process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Process Locking</head><p>When objects are created and deleted in the parent graphics process these objects must be locked so that they are not deleted while being accessed by the computation process. Due to the implementation of the environment object lists as arrays, locking of the entire array is required. When this lock is requested by the graphics process, a flag is set which causes the computation process to stop. There are two reasons for stopping the computation process. The first is that some user interactions involve continuous parameter changes which create and destroy objects. An example is the selection of the number of emitters on a tool, which is continuously controlled by a slider and results in the creation and destruction of many objects in several successive frames. If the computation process is allowed to reacquire the array lock between graphics frames, the continuous control becomes very jerky as the graphics process waits to reacquire the array lock. The second reason for stopping computation is that the array lock request by the graphics process is an interrogation which returns for processing as described in section 5. The very small time window between when the computation process releases and reacquires the array lock would often cause the graphics process' lock request to be missed it the computation process were not stopped. When the interaction is completed the computational process is told to proceed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">TIME MANAGEMENT</head><p>This section describes time management algorithms which control the flow of data time. After outlining the requirements of the time management structure, we give the time flow algorithm which satisfies these requirements. These algorithms are deeply related to the process structure described in section 4.</p><p>As mentioned in section 2, the way in which time-varying data is represented implies that time in the visualization environment has a discrete nature. This sense of time, which we shall call data time, is distinct from the user's sense of time, which is continuous. The naive way to implement data time is to map each timestep to a single pass through the computation process, i.e. a single traversal of each of the environment object's computation functions. Then the rate at which data time passes is clocked by the speed at which the environment object's computation functions can be executed. A somewhat richer time structure is implemented in the virtual windtunnel, which allows time flow to be manipulated by the user and allows interactive exploration even when the data time flow is stopped.</p><p>The asynchronous nature of the virtual windtunnel process structure raises several issues about how the results of the computations should be provided to the graphics process. There are several requirements that must be met:</p><p>• Minimal Delay: The most recent computation data should be available to the graphics process.</p><p>• Avoid Blocking the Computation Process: The computation process should not have to wait for available buffers when consistent with other requirements.</p><p>• Completeness: All time steps that have been computed must be displayed.</p><p>• Directed Flow: The timesteps must be displayed in the order determined by the user specified time flow.</p><p>• Correct Simultaneity: All visualizations displayed in the same graphical frame must be from the same data time value.</p><p>• Time Flow Control: The user should be able to change the flow of time, making it speed up (= allow the computation process to skip time steps), slow down (allow the same timestep to be addressed several times by the computation process), stopped, or run backwards.</p><p>• Allow Exploration within a Timestep: When the user has slowed or stopped the flow of time, visualizations should be recomputed by the computation process when their defining data changes.</p><p>The first two requirements, avoiding delays and blocking of the computational process, is accomplished via a triple-buffer structure called a geometry buffer. When a geometry buffer is filled by the computation process it is marked computed, so that it may be drawn. The other possible buffer states are: available and busy. The usual operation of the triple-buffer structure, which would allow the faster process to simply alternate between the two buffers not used by the slower process, contradicts the other requirements as described below.</p><p>The requirement of allowing exploration within a timestep implies the ability to compute a subset of all the visualization objects without computing the ones that have not changed. This in turn implies that the geometry buffers must be defined on the object level. The buffers of some objects may be changing while the buffers of others are static.</p><p>The requirements of completeness, directed time flow, and correct simultaneity are implemented by defining data time counters for each of the computation and graphics processes:</p><p>• Computation Data Time: The time value of the current data timestep being used for the computation process.</p><p>• Graphics Data Time: The time value of the data timestep that was used for the computation of the visualizations currently being displayed.</p><p>The computation processes contain a global computation time value and the graphics processes contain a global graphics data time value. Each buffer of the triple buffer structure mentioned above contains a data time value set by the computation process. Simultaneity at display time is then enforced by the draw process selecting a buffer with a data time value equal to the global graphics data time value.</p><p>Time flow control is implemented as a proportional scaling: current computation data time is incremented by the time rate. The time rate is a floating point number and may be positive, negative, or zero. User selected time flow control implies that we cannot base the requirement of directed time flow on an increasing data time counter. For this reason a new counter is introduced, which is always increasing.</p><p>• Data Frame Time: A counter that is incremented whenever the computation data time changes.</p><p>Data frame time essentially encodes the timeliness of the data. The computation and graphics processes contain global values of the data frame time. The data frame time is also contained in the geometry buffers.</p><p>None of the above counters, however, are incremented with every pass through the computation process if the data time flow is slowed or stopped. When data time flow is slowed, for example, several executions of the computation process may take place before the computation data time and the data frame time change. Another counter is required to maintain synchronization within a computation frame, which may be thought of as a "fractional part" of the data frame time.</p><p>• In Frame Time: A counter that is incremented with every pass through the computational process. This counter is set to zero every time the data frame time is incremented.</p><p>So when time is slowed or stopped we may have several buffers with the same data frame time but different values of in frame time. Skipping in frame time buffers does not violate completeness so long as at least one of the buffers with that data frame time is drawn.</p><p>The problem of meeting the time management requirements is implemented by the following algorithms. Let b_drawing = the buffer currently being drawn, and b1 and b2 be the other two buffers.</p><p>First we present the algorithm for finding the next buffer for computation. This algorithm is essentially looking for a buffer that can be overwritten without violating the completeness requirement. First return any available buffer: if (any buffer is marked AVAILABLE) return that buffer Second, check to see if any buffers are from data frame times smaller than the data frame time that is currently being drawn. Such buffers correspond to data frame times that have already been drawn and so may be overwritten: if (b1's data frame time &lt; b_drawing's data frame time) return b1 if (b2's data frame time &lt; b_drawing's data frame time) return b2 If we have not yet returned from this algorithm, the data frame times of b1, and b2 are greater than or equal to that of b_drawing. The requirement of completeness demands that we do not skip any values of the data frame time. If b1 and b2's data frame times are equal, pick the one with the smallest in time frame as the other will draw that data time frame: if (b1's data frame time = b2's data frame time) { if (b1's in frame time &lt; b2's in frame time) return b1 else return b2 } If b1's or b2's in frame times are equal to b_drawing's in frame time, pick it, as that data time frame is being drawn: if (b1's data in frame time = b_drawing's data in frame time) return b1 if (b2's data in frame time = b_drawing's data in frame time) return b2 If we have reached this point in the algorithm then returning a buffer may cause the overwrite of a data frame time, violating the requirement of completeness. So: return NO_BUFFER_AVAILABLE</p><p>The computational process waits until a buffer becomes available. Buffers become available after they have been drawn and released by the graphics process. This introduces a potential deadlock condition with the array lock described in section 4.3: when we are in the computation process, the computation process has acquired the array lock and will not release it until a geometry buffer becomes available. The graphics process, in the meantime, may have completed its drawing and may have requested the array lock in response to a user command as described in section 4.3. At this point there is no drawing taking place in the graphics process, so no buffers will become available to the computation process. This deadlock condition is addressed by having the graphics process interrogate the lock using the IRIX uscsetlock call which returns a value indicating whether the lock is available. If the lock is not available, the graphics process repeatedly requests this lock for a short period of time. If the lock does not become available in that time, the command is archived for execution in the next graphics frame and drawing is resumed, releasing the array lock.</p><p>Selection of the draw buffer is much more straightforward. Return the buffer that has been computed, has data frame time = to the global graphics data frame time, and the largest value of in frame time. The largest value of in frame time indicates the most recently computed buffer, and is chosen to minimize frame latency. If no new buffer is available for drawing, then the current draw buffer is returned to be drawn again.</p><p>The implementation of the time management structure described in this section is simplified by defining the geom_buffer template class which contains the buffers and buffer selection functions. The geom_buffer class contains an array of the template class specified at declaration. Then for each visualization class, a geom_data class is defined which encapsulates the extract geometry of that visualization. A geom_buffer object is then declared in the visualization class which takes the geom_data class as its template instantiation. The C++ syntax for this operation is: class geom_data { /* geometry data structures */ }; class visualization { geom_buffer&lt;geom_data&gt; geometry; /* everything else */ } ;</p><p>In the computation function for this visualization subclass, the computational buffer must be acquired for use: /* declare a geom_data reference pointer */ geom_data &amp;comp_geom_buf; /* set to the current computational buffer */ comp_geom_buf = geometry.comp_buffer(); /* fill it in */ comp_geom_buf.data = value;</p><p>The draw buffer in the object's draw function is acquired in a similar way.</p><p>The use of this template structure hides the operation of the geom_buf object. This allows a programmer to implement visualizations using the time management structure without having to understand its details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">TIME-CRITICAL COMPUTATION</head><p>In this section we address the issue of controlling the time required to compute and display the visualization objects. This problem is at the heart of the conflict between the requirement of accurate visualization on the one hand and high performance for direct manipulation on the other. Many researchers have indicated that when interactively exploring a data set they would rather have a fast, less accurate answer than a slow accurate answer. Once interesting phenomena has been identified using a fast but inaccurate method, that phenomena can be verified with a slower but more accurate method. The degradation of accuracy must be implemented very delicately, respecting the needs of the researcher.</p><p>We first discuss ways to determine the computational budget, which is how much time a computation is allowed to take. Once a computational budget is established for an object we give examples of the parameterization of object computation that allow that budget to be automatically met. Finally, the results of a simple test of this time-critical structure is presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Time-Critical Computation</head><p>Once a total time for a computational frame has been specified by the user, there are two issues that must be addressed: determination of the how much of that total time each individual visualization computation is allowed, called the time budget, and modifying the computation to meet that time budget.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Determining the Time Budget of a Visualization</head><p>The determination of the computational time budget is the most difficult. Funkhouser and Sequin <ref type="bibr" target="#b10">[11]</ref> developed a method that maximized benefit/cost ratio for the graphical rendering of all objects in an environment. The cost of an object was the graphical rendering time for that object at a given level of detail. Each object in the environment has several pre-computed representations at varying levels of detail. The benefit of the object is more complicated, involving the apparent size of the object on the screen, the accuracy of the representation of the object at its current level of detail, and how close the object is to the center of the screen, among other measures. The benefit/cost ratio is maximized through an iterative algorithm.</p><p>For time-varying scientific visualization, the estimate of the benefit of a visualization is more difficult. Measures like screen size and location in the viewer's visual field require the computa-tion of the entire visualization: many visualization objects, such as streamlines and isosurfaces, may be objects that extend well away from their starting points. The location of a visualization in the user's field of view cannot be inferred from its defining data. Coherency from frame to frame cannot be used for time-varying data or when the visualization is moved, because the visualization may change drastically. A streamline, for example, may completely change direction when near a critical point in the vector field. This issue does not arise in non-time-varying flows for visualizations that are not moved, because these visualizations will not be recomputed.</p><p>For these reasons we compute the time budget for each visualization object through simple arithmetic. The entire computational frame is given a frame time budget, which is distributed across the visualizations. The actual time of the computational frame is measured. The ratio of the frame time budget to the actual time is computed. This ratio then multiplies the time budgets of the individual visualization objects. This scenario is somewhat complicated by the possibility of radical changes in the computational time: the computation time can effectively drop to zero when time flow is slowed down or stopped and no visualizations are moved, or when computation is stopped during a user command. The computational time may also be very long for user-selected events such as the load of a very large data file. These situations are handled by filtering the actual times, ignoring times that are too long or short (we currently ignore times that are a factor of 10 too long or short), and by clamping times between a factor of 2 and 10 too long or short to a factor of 2.</p><p>The user may specify that a set of visualizations be given a longer time budget at the expense of other visualizations in the environment. This is specified by a simple scale factor which multiplies the time budgets of all these visualizations. In this way the user can specify that one set of visualizations is of more interest than others.</p><p>The way in which the computational time budget is distributed among the visualization objects requires some care. If all visualization objects were of the same type, then each object's budget would simply be the computational time budget multiplied by the number of available processors divided by the number of objects. Some visualizations, however, inherently take longer to compute interesting geometries than others. Isosurfaces require more time than streamlines, for example, and there are typically many more streamlines than isosurfaces in a visualization environment. Thus an individual isosurfaces should be given a longer time budget than an individual streamline. Exactly how much longer depends on the visualization and is the subject of ongoing experimentation: we find that an increase of about a factor of three seems to give good results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Meeting the Computational Time Budget</head><p>Once the time budget of a visualization has been set, that time budget is met in ways that depend on how that visualization is computed. A simple example is that of local isosurfaces, where there is a fixed cost per polygon so the only way to control the time required to compute the isosurface is to control the number of polygons. Because local isosurfaces are computed by growing out from a point in space, one simply computes isosurface triangles until the time budget is used up.</p><p>Particle integration techniques like streamlines offer a richer set of possibilities. An example which has been implemented in the virtual windtunnel uses an adaptive particle integration technique <ref type="bibr" target="#b11">[12]</ref> which offers three parameters that affect the computation speed. The simplest is the length of the streamline: compute the streamline until the time budget is used up. The second param-eter is to switch the integration from fourth-order Runge-Kutta, which requires four interpolations of the vector field, to secondorder Runge-Kutta, which requires two interpolations of the vector field. This switch results in about an 80% speedup in the integration at a slight cost of accuracy. The third parameter is to switch off the adaptive computation, which results in an almost three-fold speedup but at the cost of a dramatic loss of accuracy. These two latter parameters are used when the resulting streamline has too few vertices. Thus the algorithm for parameterizing the streamline computations is:</p><p>if (last computation's vertex count &lt; minimum number) { if (using 4th-order Runge-Kutta) switch to 2nd-order Runge-Kutta else if (adaptive) turn off adaptive } while (time &lt; time_budget) compute vertices</p><p>When the time budget increases, the adaptivity or 4th-order Runge-Kutta are switched back on when the number of vertices in the streamline reaches more than three times the minimum number of vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Time-Critical Computation Results</head><p>When implemented in the virtual windtunnel, the time-critical algorithms described in this section delivered the computational time (as measured by UNIX timing calls) set by the user with very little variation regardless of the number of visualizations in the environment. The computation time does not completely determine the frame rate, however. The frame rate as presented to the user is determined by the graphics frame rate as well as the computational time.</p><p>The effective frame rate of the computation was tested by averaging the computational frame rate of several streamlines over 400 timesteps of a time-varying flow. The response to a shorter computation budget was to reduce the number of vertices in the streamline. The graphics frame rate for this measurement was 15 frames/second, so only lower computational frame rates were specified. The results are shown in table 1. We believe that the failure to meet the specified frame rate of 12.5 frames per second is due to the graphics frame rate overhead. . This paper describes the issues of time management and timecritical computation in a high-performance unsteady visualization environment. The problems encountered in such systems were formalized and we outlined algorithms for their implementation. These algorithms included the following features:</p><p>• The versatile time-management structure presented in this paper preserves the correct sense of time for time-varying visualization while providing the user with control over how time passes in the environment.</p><p>• Computation times are kept to a specified performance speed through time-critical structures. These structures provide a time budget to each visualization computational algorithm, which chooses the best way to meet that budget</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">ACKNOWLEDGMENTS</head><p>We have benefited from a long and fruitful relationship with the graphics group at Brown University under the direction of Andries van Dam. Andries van Dam himself brought the problem of time-critical computing into sharp focus as a problem that needs to be solved. Our discussions with Tom Meyer, Matthias Wloka, and Brook Connor in particular have been invaluable for providing insight into the subtleties and specifics of the time-critical problem.</p><p>At NASA Ames, David Kenwright has been extremely helpful in providing high-performance visualization algorithms and ideas.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>The visualization process: data is processed to produce visualization extracts, that are rendered on the computer screen.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2</head><label>2</label><figDesc>An example of a complex visualization environment, showing streamlines, isosurfaces and cutting planes displaying the velocity vector field and density scalar field around a harrier aircraft in hover<ref type="bibr" target="#b7">[8]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : Time Critical Results</head><label>1</label><figDesc></figDesc><table><row><cell>Specified Frame Rate</cell><cell>Actual Frame Rate</cell></row><row><cell>(frames/second)</cell><cell>(frames/second)</cell></row><row><cell>5</cell><cell>5.6</cell></row><row><cell>6.7</cell><cell>6.89</cell></row><row><cell>10</cell><cell>9.76</cell></row><row><cell>12.5</cell><cell>10.5</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">MS T27A-1 NASA Ames Research Center, Moffett Field, CA 94035</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Project GROPE -Haptic Displays for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Brooks</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ouh-Young</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Blatter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Kilpatrick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH 90</title>
		<imprint>
			<date type="published" when="1990-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Nanomanipulator: A Virtual Reality Interface for a Scanning Tunneling Microscope</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Robinett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">L</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Brooks</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH 93</title>
		<imprint>
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cruz-Neira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leigh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Englemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Papka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Siegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Vasilakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Sandin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Defanti</surname></persName>
		</author>
		<title level="m">Scientists in Wonderland: A Report on Visualization Applications in the CAVE Virtual Reality Environment</title>
		<imprint>
			<date type="published" when="1993-10" />
		</imprint>
	</monogr>
	<note>Proceedings of the IEEE Symposium on Research Frontiers in Virtual Reality</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">3D Widgets for Exploratory Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Herndon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of UIST &apos;94, ACM SIGGRAPH</title>
		<meeting>UIST &apos;94, ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="1994-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Brief Architectural Overview of Alice, a Rapid Prototyping System for Vitrual Reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pausch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Burnette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Capeheart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cosgrove</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Durbin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gossweiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Koga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<date type="published" when="1995-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Initial User Reaction to the Virtual Windtunnel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bryson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Johan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Globus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcewen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AIAA 95-0114, 33rd AIAA Aerospace Sciences Meeting and Exhibit</title>
		<meeting><address><addrLine>Reno., Nevada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Virtual Windtunnel Users Manual</title>
		<ptr target="http://www.nas.nasa.gov/NAS/VWT" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Numerical Simulation of a Complete STOVL Aircraft in Ground Effect</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Van Dalsem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">American Institute of Aeronautics 9th Aerodynamics Conference</title>
		<meeting><address><addrLine>Baltimore Md</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
	<note>paper AIAA-91-3293</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sheridan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ferrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Man-Machine</forename><surname>Systems</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Ma</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Direct Manipulation of Isosurfaces and Cutting Planes in Virtual Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Globus</surname></persName>
		</author>
		<idno>RNR-93-019</idno>
		<imprint/>
		<respStmt>
			<orgName>NASA Ames Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Adaptive Display Algorithm for Interactive Frame Rates During Visualization of Complex Virtual Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Sequin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics: Proceedings of SIGGRAPH 93</title>
		<imprint>
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimization of Time-Dependent Particle Tracing Using Tetrahedral Decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kenwright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;95</title>
		<meeting>Visualization &apos;95</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995-10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
