<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Isosurfacing in Span Space with Utmost Efficiency (ISSUE)</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Advanced Computing Laboratory University of Utah Los Alamos National Laboratory</orgName>
								<address>
									<settlement>Salt Lake City, Los Alamos</settlement>
									<country>UT, New Mexico</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yarden</forename><surname>Livnat</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Isosurfacing in Span Space with Utmost Efficiency (ISSUE)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present efficient sequential and parallel algorithms for isosurface extraction. Based on the Span Space data representation, new data subdivision and searching methods are described. We also present a parallel implementation with an emphasis on load balancing. The performance of our sequential algorithm to locate the cell elements intersected by isosurfaces is faster than the Kd-tree searching method originally used for the Span Space algorithm. The parallel algorithm can achieve high load balancing for massively parallel machines with distributed memory architectures.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Scientific visualization has played an important role in understanding three-dimensional scalar data. As costeffective high performance computers with large amount of memory and disk space become more accessible, the sizes of these scalar data also continue to increase. To visualize these large-scale data sets, generally two different paradigms are used. One paradigm is to transfer the data onto graphics workstations and perform the visualization as a postprocessing step. Alternatively, visualization can be performed on the same, typically parallel, machines that run the simulation thereby providing the user faster feedback necessary for computational steering. In this paper, we propose an efficient sequential isosurfacing algorithm and a load balanced parallel isosurfacing algorithm to fulfill the requirements of both visualization paradigms.</p><p>Isosurfacing is an effective technique to explore threedimensional scalar fields. A simple and effective method is the Marching Cubes algorithm, proposed by <ref type="bibr">Lorensen and</ref> Cline <ref type="bibr" target="#b0">[1]</ref>. The algorithm has a complexity of O(N) since it is necessary to visit each cell in the three-dimensional</p><p>In a uniform three-dimensional field, a cell is sometimes referred to as a voxel. We use the term cell to indicate elements of a three-dimensional grid that may be a uniform or regular structured grid or an unstructured field. When the data set is large, visiting each cell is too costly and recent research efforts have investigated the acceleration of the isosurfacing process, namely Wilhelms and Van Gelder's octree spatial subdivision <ref type="bibr" target="#b1">[2]</ref>, Gallengher's span filter <ref type="bibr" target="#b2">[3]</ref>, Itoh and Koyamada's extreme graph method <ref type="bibr" target="#b3">[4]</ref>, Shen and Johnson's sweeping simplices algorithm <ref type="bibr" target="#b4">[5]</ref>,and Livnat et al.'s near optimal isosurface extraction (NOISE) algorithm <ref type="bibr" target="#b5">[6]</ref>.</p><p>Among the above accelerating techniques, the NOISE algorithm is near optimal. This algorithm has a worst case complexity of O( p N + K) to locate the cells that are intersected by the isosurfaces, where N is the total number of cells in the scalar field, and K is the number of isosurface cells. The crux of this algorithm is a novel data representation, termed the Span Space. Using this representation, the isosurface extraction process can be reduced into a range searching problem. Livnat et al. proposed a classical Kdtree searching method <ref type="bibr" target="#b6">[7]</ref> to locate, in that space, the cells that contain an isosurface.</p><p>In this paper, we use the Span Space as the underlying representation to design high performance isosurface extraction algorithms for both single processor workstations and massively parallel machines with distributed memory architectures. Rather than using the Kd-tree searching method, we subdivide the Span Space into a twodimensional regular lattice and propose a new searching method. Our new sequential algorithm leads to a average case time complexity of O(log</p><formula xml:id="formula_0">( N L ) + p N L + K )</formula><p>to locate the isosurface intersected cell elements, where L is an user specified parameter, as explained in Section 3, with a value typically between 200 to 500. In practice, this new method is faster than the NOISE algorithm in locating the isosurface cells. Our parallel isosurfacing algorithm adopts a static load balancing scheme to distribute the cells among Processing Elements (PEs). Each PE executes the sequential algorithm locally leading to an average difference begrid. The cells may be tetrahedra, hexahedra, prisms or other polyhedra. The methods described in this paper are useful for any type of grid. We begin the paper by providing details of the Span Space data representation. Next, we describe the new lattice subdivision method with a fast searching algorithm. We then discuss some implementation details. Building upon this, we present the parallel algorithm with an emphasis on the load balancing. Finally, we conclude the paper with several experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Span Space</head><p>For each cell element in the three-dimensional scalar field, there exists an interval [a; b] representing the scalar range of the data at the cell's vertices, where a is the cell's minimum value and b is the cell's maximum value. For a given isovalue v, the cell C i that has interval [a i ; b i ]such that a i &lt; v , and b i &gt; v is intersected by the isosurface. To accelerate the isosurfacing process, researchers have proposed different methods to decompose the data domain such that for each isovalue, there is only a small number of subdomains that need to be examined <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>Livnat et al. provide an interesting perspective for the isosurfacing problem <ref type="bibr" target="#b5">[6]</ref>. In <ref type="figure" target="#fig_0">Figure 1</ref>, cells having points within the shaded area are the isosurface cells.</p><p>Unlike the interval representation for a cell that poses difficulties for subdividing the cells in the scalar field, the point representation in the Span Space provide a much simpler way to subdivide the data domain. This advantage lays down the basis for us to develop an efficient searching algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">New Searching Algorithm</head><p>In this section, we describe a data subdivision scheme and a new searching algorithm to locate the isosurface cells. Based on the Span Space representation, the new subdivision scheme organizes the cells in such a way that the isosurface cells can be easily located.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Lattice Subdivision</head><p>Our algorithm decomposes the data domain by subdividing the Span Space into a two dimensional LL lattice. Assuming that the scalar field has a global minimum value m, and a global maximum value M, we define a set of dividing  <ref type="figure" target="#fig_1">Figure 2</ref> shows a 8 8 lattice subdivision imposed upon the Span Space. Note that the X = Y line crosses the diagonals of lattice element(i; i); i= 1 ::L. Also, all the lattice elements with indices (i; j); i &gt; j are empty because the minimum values can not be greater than the maximum values. </p><formula xml:id="formula_1">points fd i g i=L i=0 such that d 0 = m, d L = 1, d i &lt; d i +1 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Searching Algorithm</head><p>Using the lattice subdivision, we can quickly locate the candidate lattice elements that contain the isosurface cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Given an isovalue</head><formula xml:id="formula_2">v, v 2 [d p 1 ; d p )</formula><p>, we classify the lattice elements in the Span Space into five cases based on their indices (i; j) as follows:</p><p>1. i &gt; p or j &lt; p : All the cells in this region have either a higher minimum value or lower maximum value than the isovalue. Hence these lattice elements trivially do not contain any isosurface cells. <ref type="bibr" target="#b1">2</ref>. i &lt; p and j &gt; p : All the cells in these lattice elements are isosurface cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">i &lt; p and j = p:</head><p>All the cells in this region have a lower minimum value than the isovalue. Hence only those cells that have a higher maximum value than the isovalue are isosurface cells. <ref type="bibr" target="#b3">4</ref>. i = p and j &gt; p : All the cells in this region have a higher maximum value than the isovalue. Hence only those cells that have a lower minimum value than the isovalue are isosurface cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">i = p and j = p:</head><p>This is the only lattice element that requires a min-max search to locate the isosurface cells. Any isosurfacing algorithm, such as a Kd-tree searching method or sweeping simplices, will do. From the above description, the lattice elements in case 1 can be immediately rejected. Locating isosurface cells from the case 2 region requires no searching operation since every cell in the region is an isosurface cell. The cells can be directly collected from the Lattice Element data structures that contain cell indices.</p><p>To locate isosurface cells in the lattice elements of case are isosurface cells and can be located with a binary search.</p><p>The lattice element in case 5 is the only region that we need to employ regular isosurface searching, i.e., finding cells with minimum values lower, and maximum values higher than the isovalue. To achieve this, we can use any efficient isosurface extraction algorithm. For instance, we can build a Kd-tree structure for lattice element (p;p) and apply Kd-tree search to locate the isosurface cells or we could employ the Sweeping Simplices algorithm <ref type="bibr" target="#b4">[5]</ref>.</p><p>The search phase of our isosurfacing algorithm includes two binary searches in the regions of case 3 and case 4, and one min-max search in the lattice element of case 5. </p><formula xml:id="formula_3">O(log( N L ) + p N L + K )</formula><p>, where K is the number of the isosurface cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Implementation Details</head><p>In this section, we provide important implementation details of our searching algorithm. First, we describe how to determine the dividing points fd i g. Second, we describe a sparse manipulation method to avoid visiting the empty lattice elements when collecting the isosurface cells.</p><p>From the earlier description, we know that a lattice ele- </p><formula xml:id="formula_4">ment (i; j) is</formula><formula xml:id="formula_5">= m + i M m L g i=L 1 i=0</formula><p>and d L = 1. However, this method does not produce a uniform data point distribution at each interval</p><formula xml:id="formula_6">[d i ; d i +1 ]</formula><p>which results in an uneven cell distribution among the</p><formula xml:id="formula_7">!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!! X Y X = Y</formula><p>: Non−empty lattice element <ref type="figure">Figure 4</ref>: Sparse Manipulation lattice elements. To avoid this, we find fd i g i=L 1 i=0 in such a way that the number of data points at each interval</p><formula xml:id="formula_8">[d i ; d i +1 ]</formula><p>is approximately the same. We achieve this by sorting all data points into a list and dividing the list into L</p><p>sublists having approximately the same lengths. The scalar values which bound those sublists are the dividing points.</p><p>As mentioned earlier, only lattice elements in cases 3, 4, and 5 require searching operations to locate the isosurface cells. The finer we subdivide the Span Space, the smaller the areas of the regions defined by those cases. This results in a greater number of cells which are located in the case 2 region and therefore can immediately be collected. However, as we more finely subdivide the Span Space, there can be a larger number of empty lattice elements. This has the potential to degrade the algorithm's performance since time would be spent checking those empty lattice elements when we collect the isosurface cells. To overcome this limitation, we use a sparse manipulation method on the lattice. As we pre-process the data field and distribute the cells into the lattice, the non-empty lattice elements are marked. The lattice elements at each row are then connected together with pointers. <ref type="figure">Figure 4</ref> illustrates the sparse manipulation method. We note that using sparse manipulation, the number of non-empty lattice elements is bounded by the number of cells in the 3D scalar field no matter how fine we subdivide the Span Space. In the results section, we show the relationship between the resolution of the lattice subdivision and the performance of the searching algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Parallel Algorithm</head><p>In this section, we present a parallel isosurfacing algorithm. The underlying architecture model is massively parallel machines with distributed memory such as the Cray . The algorithm can be divided into three phases: cell distribution, initialization, and isosurface extraction. In the cell distribution phase, cells are partitioned into several subsets and distributed to the processing elements (PEs). In the initialization phase, each PE builds lattice, row, and column data structures based on the local data. In the isosurface extraction phase, each PE locally employs our searching algorithm to extract the isosurfaces. Our emphasis is on paradigms of cell distribution achieving load balancing. For any given isovalue, we want the PEs to spend a balanced amount of time in isosurfacing and to produce balanced amount of triangles. In this way, not only does our isosurfacing algorithm exhibit good scalability, it can also be directly connected to a parallel rendering process, which requires an even distribution of primitives for the initial geometry processing <ref type="bibr" target="#b7">[8]</ref>.</p><p>We The resolution of the lattice subdivision is crucial to the load-balance of the algorithm since a finer subdivision exhibits better cell scattering. However, in the isosurfacing algorithm, creating a fine subdivision implies that we have to create more lattice data objects, which would incur higher memory overhead. To overcome this, we decouple the lattice subdivision used for the cell distributionfrom the one used for isosurfacing algorithm. Initially, a finer lattice subdivision is used for the round-robin distributionscheme. After each PE receives its local data, a coarser lattice subdivision is used to create the lattice, row, and column data structures. In this way, we can exploit a fine subdivision which achieves good cell scattering, but not invoke excessive memory overhead in performing isosurfacing. We refer to the elements of this subdivision for the cell distribution as buckets to distinguish from lattice elements used for the isosurfacing algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results and Discussion</head><p>In this section, we present empirical results to evaluate our algorithms. The sequential algorithm was tested on a 150 MHz MIPS R4400 processor. The parallel algorithm was tested on a Cray T3D parallel machine. All the results presented were obtained by averaging one thousand executions with randomly assigned isovalues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Sequential Algorithm</head><p>We used three unstructured grid data sets to test our sequential algorithm. These data were generated from bioelectric field problems solved using finite element methods. The data sizes range from 69 thousand to 1.3 million elements. <ref type="table" target="#tab_2">Table 1</ref> gives a summary of the data sets. <ref type="figure" target="#fig_0">Figures 11-13</ref> depict a single iso-surfaced image for each of the data sets. The performance of the searching phase of the algorithm is affected by the resolution of the lattice subdivision. The finer we subdivide the Span Space, the smaller the area of the regions covered by case 3,4,5 while the greater the area of the region covered by case 2. However, This is mitigated by the overhead of constructing the necessary data structures. <ref type="figure">Figure 6</ref> demonstrates the relationship between the time to search for isosurface cells and the resolution of the lattice subdivision. We can see that the search time dramatically decreases as we increase the number lattice elements up to 256 256. After that, the performance degraded slightly due the overhead incurred by using a very fine lattice structure. <ref type="figure">Figure 7</ref> shows the total isosurfacing time, including the time for triangulation, verses the resolution of the lattice subdivision. Because we used the sparse manipulation method mentioned in the sec- <ref type="table" target="#tab_2">Cells  Heart  11,504  69,892  Torso  201,142 1,290,072  Brain</ref> 74,217 471,770  <ref type="table">Table 2</ref>: Comparison of the lattice method with the Kd-tree method in locating the isosurface cells.(in msecs) tion 3.3, the overhead incured by a very fine subdivision is not overwhelming. 512x512 lattice elements were used in our experiments. <ref type="table">Table 2</ref> shows the times for locating which cells contain an isosurface for both the Lattice based algorithm and the Kdtree algorithm. Note that the time to locate the isosurface cells is an order of magnitude faster. <ref type="table" target="#tab_4">Table 3</ref> compares the total isosurfacing time: locating which cells contain an isosurface, traversing those cells to perform triangulation, and the triangulation time. It can be seen that the Lattice based search improves the overall performance by approximately 25%. The triangulation time begins to dominate which is why the time to locate the isosurface cells is an order of magnitude faster but overall the system exhibits only a 25% increase in performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data Set Vertices</head><p>The initialization complex-</p><formula xml:id="formula_9">ity for our algorithm is O(2L n L log( n L ) + n ) , where L</formula><p>is the number of bins used at each dimension of the span space, and n is the number of cells. The is because that we need to sort the cells at each row and column based on their minimum or maximum values, and put the cell indices into appropriate lattice elements. <ref type="table" target="#tab_5">Table 4</ref> gives the initialization time for the test data sets.</p><p>The memory requirement for our algorithm is O(n).   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>We assume that the memory requirement for the algorithm chosen to extract isosurfaces from cells in case 5 is bound by O(n), which is true if we use either KD-tree or Sweeping Simplices searching methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Parallel Algorithm</head><p>We have implemented our parallel algorithm using C++ on a Cray T3D supercomputer in the Advanced Computing Laboratory at Los Alamos National Laboratory. The Cray T3D is a massively parallel computer with a distributed memory architecture. Each processing element has a 64 bit DEC Alpha microprocessor and 8M words local memory.</p><p>Method Heart Torso Brain Time 1.88 53.19 13.01  Our implementation uses the message passing paradigm by employing the ACLMPL message passing library <ref type="bibr" target="#b9">[9]</ref> which is a high throughput, low latency communications library. y In this section, we show the load balancing characteristics of our parallel algorithm and give the speedup factors obtained from executions using 4 to 64 processing elements. We used the brain data set which has 471,770 cell elements.</p><p>To measure the load balance of our parallel algorithm, we use two different metrics. One is a formula of load imbalance used by Ma <ref type="bibr" target="#b10">[10]</ref>:</p><formula xml:id="formula_10">Load Imbalance = 1 loadAverage loadMax</formula><p>The other is a load difference formula:</p><formula xml:id="formula_11">Load Difference = (100 loadMax loadMin loadT otal )%</formula><p>Two different measurements are used to define the workload for each PE. One is the isosurfacing times for each PE, the other is the number of triangles produced by each PE. We present both of the workload measurements to evaluate our algorithm.</p><p>From our earlier discussion, we know that the load balance is affected by the resolution of bucket subdivision. <ref type="figure" target="#fig_9">Figure 8</ref> and <ref type="figure">Figure 9</ref> show the load imbalance and load difference, for both workload measurements, using 32 PEs. We increased the resolution of the bucket subdivision from 1616to 10241024. The results show that we can obtain a highly balanced load, namely under 0.2 of load imbalance and 2% of load difference for a 1024 1024 bucket subdivision. Remember that the bucket subdivision is a subdivision of the Span Space used to distribute the cell elements, which is different from the lattice subdivision used to perform the isosurfacing algorithm.</p><p>y We used ACLMPL since the MPI implementation on the T3D is not yet mature. The message passing library employed will effect the performance but is independent of the isosurfacing algorithm. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Summary</head><p>We have presented a high performance isosurfacing algorithm using a regular LL lattice subdivisionof the Span Space. The algorithm has a average case time complexity</p><formula xml:id="formula_12">of O(log( N L ) + p N L + K )</formula><p>, where the N is the total number of cells in the scalar field, K is the number of isosurface cells, and L is a user specified parameter. In practice, it is faster than the Kd-tree searching method. Empirically, the algorithm has its best performance when the value of L is about 200 to 500 for scalar data sets with sizes ranging from hundreds of thousands to millions of cell elements. We have also presented a load balanced parallel isosurfacing algorithm. In addition to the lattice subdivision, we use a bucket subdivision of the Span Space and a round-robin method to distribute the cell elements. Our experimental results show that the higher the resolution of the bucket subdivision, the better the load balance. Our sequential and parallel isosurfacing algorithm can satisfy the needs of both post-processing and computational steering visualization. <ref type="figure" target="#fig_0">Figure 12</ref>: A green isosurface within a multi-colored semitransparent head model <ref type="figure" target="#fig_0">Figure 13</ref>: A yellow isosurface within a multi-colored semi-transparent torso model</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Span Space tween the maximum and minimum workloads of lower than 2%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>For a cell with minimum value a and maximum value b, instead of treating the [a; b] as an interval, they map the cell into an unique point position, (a; b), in an R 2 value space, termed the Span Space. Figure 1 illustrates the Span Space. The horizontal axis X depicts a cell's minimum value, and the vertical axis Y depicts a cell's maximum value. Note that cell elements can be mapped only to the half space above the X = Y line because a cell's maximum value is always greater than or equal to its minimum value. Using the Span Space data representation, the isosurfacing problem is then reduced into a classical range search problem. The problem is stated as follow:For a given isovalue v, the cell C i that has associated Lattice Subdivision points (x i ; y i ) in the Span Space, such that x i &lt; v and y i &gt; v is an isosurface cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>and fd i g i=L 1 i=1 2</head><label>12</label><figDesc>(m; M]. A lattice element(i; j); i= 1 ::L and j = 1 ::L is defined as a square region in the Span Space containing point (x; y) such that x 2 [d i 1 ; d i )and y 2 [d j 1 ; d j ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Lattice Classification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3</head><label>3</label><figDesc>shows the five cases in the Span Space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Since the entire Span Space contains L rows, L columns, and LL+1 2 lattice elements above the X = Y half space, the average number of cells in each row and column is N L , and the average number of cells in each lattice element is 2N LL+1 . The binary search for each row and column requires O(log( N L )), and the Kd-tree mix-max search for the lattice element in case 5 requires O( p N L ). Hence, the overall average case performance for our new algorithm is then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Lattice DistributionT3D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2 )</head><label>2</label><figDesc>achieve the load balancing by carefully designing a cell distribution scheme. Ideally, if cells within any scalar range [a; b] are evenly scattered, each PE would have approximately the same number of isosurface cells for any isovalue. To achieve this, we use a cell distribution method built on top of the lattice subdivisionof the Span Space. Assuming that there are L L lattice elements in the Span Space, and that there are N PEs available, numbering from PE[0] to PE[N 1], we unfold the lattice elements in the half space above the X = Y line column by column into a 1D list and distribute these LL+1 2 elements into the PEs using a round-robin method. Figure 5 shows a lattice distribution of 88 lattice with 4 available PEs. To express our round-robin method in terms of indices of lattice elements and PEs, our method distributes the cells in the lattice(i; j) into PE[(j 1+ 2L ii 1 modN]. As a result, each PE receives a balanced work load because the lattice elements in cases 2,3,4,5 are evenly distributed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Searching Time v.s. K x K Lattice Subdivision Total Isosurfacing Time v.s. K x K Lattice Subdivision ues stored in the row and column date structures, cell indices stored in lattice elements, and memory consumed by the algorithm applied to cells in the lattice elements of case</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Load Imbalance for K x K Bucket Subdivision</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Load Difference for K x K Bucket Subdivision Speedup FactorsFigure 10gives the speedup factors for T3D partitions with 4 to 64 PEs. The test was performed with a 256256 lattice subdivision.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>3, we design a Row data structure. Row [R]containsindices and maximum values of cells in lattice elements (i;j), i &lt; R; j = R. The cell indices are sorted by their maximum values. To collect the isosurface cells, we apply a binary search to Row [p] and find the cells with maximum values greater than the isovalue v. collect isosurface cells in the lattice elements of case 4, we design a Column data structure. Column [C] contains indices and minimum values of cells in lattice elements (i; j), i = C ; j &gt; C . The cells in each column structure are sorted by their minimum values. Those cells in Column [p]with minimum values lower than the isovalue v</figDesc><table><row><cell>To</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>a region in the Span Space containing points (x; y) such that x 2 [d i 1 ; d i )and y 2 [d j 1 ; d j ) . Assuming that the value range of the field is [m; M]; m ; M2R , and that the Span Space is subdivided into an LL lattice,</figDesc><table /><note>a straightforward way to determine fd i g is to evenly cut the interval [m; M], that is, fd i</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell>Data Sets</cell><cell></cell></row><row><cell cols="4">Method Heart Torso Brain</cell></row><row><cell>Lattice</cell><cell cols="3">0.017 0.129 0.052</cell></row><row><cell>Kd-tree</cell><cell>0.4</cell><cell>2.2</cell><cell>1.5</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Comparison of the lattice method with the Kd-tree method in total isosurfacing time.(in msecs)</figDesc><table><row><cell></cell><cell>100</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Heart</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Torso</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Brain</cell></row><row><cell></cell><cell>10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Execution Time(msecs)</cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.01</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>200</cell><cell>400</cell><cell>600</cell><cell>800</cell><cell>1000</cell><cell>1200</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>K</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Initialization Time.(in secs)</figDesc><table><row><cell></cell><cell>0.9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Number of Triangles</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Isosurfacing Time</cell></row><row><cell></cell><cell>0.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.6</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Load Imbalance</cell><cell>0.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.4</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>200</cell><cell>400</cell><cell>600</cell><cell>800</cell><cell>1000</cell><cell>1200</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>K</cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The work was performed under the auspices of the United State Department of Energy, Los Alamos National Laboratory and was supported in part by the National Science Foundation and the National Institutes of Health. The research was performed in part using the resources located in the Department of Computer Science at the University of Utah and at the Advanced Computing Laboratory of Los Alamos National Laboratory. Furthermore, the authors appreciate access to facilities that are part of the NSF STC for Computer Graphics and Scientific Visualization.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="227" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Span filter: An optimization scheme for volume visualization of large finite element models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Isosurface generation by using extreme graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;94</title>
		<meeting>Visualization &apos;94<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="77" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Sweeping simplices: A fast isosurface extraction algorithm for unstructure grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;95</title>
		<meeting>Visualization &apos;95<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A near optimal isosurface extraction algorithm using the span space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transaction on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1996-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Computational Geometry, an introduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Shamos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Springer-Verlag Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A sorting classification of parallel rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ellsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="page" from="23" to="32" />
			<date type="published" when="1994-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Figure 11: A yellow isosurface within a multi-colored semi-transparent heart model</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The acl message passing library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Painter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Colin De Verdière</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EPFL Supercomputing Review</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="1995-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Parallel volume ray-casting for unstructured-grid data on distributed-memory architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1995 Parallel Rendering Symposium</title>
		<meeting>1995 Parallel Rendering Symposium</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
