<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dual Contouring with Topology-Preserving Simplification Using Enhanced Cell Representation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nan</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Visual Computing (CVC)</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="institution">Stony Brook University</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Hong</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Visual Computing (CVC)</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="institution">Stony Brook University</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Visual Computing (CVC)</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="institution">Stony Brook University</orgName>
								<address>
									<postCode>11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dual Contouring with Topology-Preserving Simplification Using Enhanced Cell Representation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.6 [Computer Graphics]: Methodology and Techniques-Graphics Data Structure and Data Types isosurface simplification</term>
					<term>isosurface extraction</term>
					<term>topology preservation</term>
					<term>vertex clustering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Simplifying the zero-isosurface of a directed distance volume of 256 3 using our topology-preserving isosurface simplification algorithm. Although the cylinders and the box are very close to each other, they don&apos;t touch, and thus there are several disconnected surface components in this volume. Note that disconnected surface components are assigned different materials and are clustered independently. (a) δ 2 = 0 and t = 97K. (b) δ 2 = 10 −6 and t = 23K. (c) δ 2 = 10 −4 and t = 2494. (δ 2 : quadric error threshold, t: triangle count.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Isosurface extraction is a very useful tool for visualizing volume datasets. Due to the improvements in resolution and accuracy of acquisition devices, the resolution of volume datasets has been increasing dramatically. For large volumes, the extracted triangles which make up an isosurface can easily overwhelm the interactive rendering capability of modern computers. Multiresolution isosurface extraction methods have been developed to address this issue. Usually, we want to preserve the topology of the finest resolution isosurface for the simplified one. Most of the topology-preserving isosurface simplification algorithms extract and maintain all critical points of the volume for topology preservation. They follow the concept used in a top-down based isosurfacing approach <ref type="bibr" target="#b19">[20]</ref>: if the adaptive volume contains all critical points (points where an isosurface would change genus or number of components), then the extracted isosurface has the same topology as the corresponding isosurface on the finest resolution. However, the expense is a lower simplification capability at the cells containing critical points since these cells cannot be merged.</p><p>Our solution to the topology-preserving isosurfacing problem on large, uniformly-sampled volumes is a bottom-up approach and therefore is based on a different idea: preserving the disconnected surface components in each cell during isosurface simplification. It is inspired by the observation that the volume grid cuts a surface into patches and these patches can be actually merged into a whole surface if the cell merging sequence can be altered. During isosurfacing, we extract the isosurface from the finest resolution volume. The isosurface components are then hierarchically simplified using a connectivity-guided method, where connected components are merged and disconnected components are preserved. The simplification capability of our approach is determined by the capability of representing the disconnected surface components inside a cell. There is no need to extract and maintain critical points, as in many other solutions.</p><p>To represent the surface components in a cell, we introduce a new data structure-the enhanced cell, where each isosurface component is represented inside a cell by a vertex with encoded connectivity information. These vertices can be simplified using a vertex clustering algorithm <ref type="bibr" target="#b15">[16]</ref>, where vertices that fall into the same cell are clustered into one representative vertex. Since vertices are clus-October 10-15, Austin, Texas, USA IEEE Visualization 2004 0-7803-8788-0/04/$20.00 ©2004 IEEE tered regardless of the topology, directly applying this algorithm for isosurface simplification will introduce more serious problems than for a mesh. The tiny triangles which make up an isosurface are more sensitive to position changes. Besides, human eyes are especially sensitive to topology errors and the resulting gradient abnormality (cf. <ref type="bibr" target="#b17">[18]</ref>). To solve the topology problem in vertex clustering, a connectivity-guided clustering algorithm is applied, where the vertices from different surface components are clustered independently. Surface components are detected by a graph algorithm that uses the connectivity information of the vertices.</p><p>Our simplification algorithm contains three steps: <ref type="bibr" target="#b0">(1)</ref> extracting and representing the finest resolution isosurface components, (2) building a vertex octree, and (3) extracting simplified isosurfaces from the vertex octree. The simplified isosurfaces preserve the topology of the isosurface in the finest resolution. Due to the space limitation, we omit the discussion here <ref type="bibr" target="#b0">1</ref> .</p><p>The primary contributions of this paper are:</p><p>• An encoding scheme, called enhanced cell, to represent the surface components in a cell. Our scheme handles multiple disconnected surface components, singular connections and up to two intersections per cell edge (including loops).</p><p>• A bottom-up cell merging algorithm, where topologypreserving vertex clustering is used to cluster the vertices in a cell. Thanks to the enhanced cell definition, we are able to encode complex surface components created in a cell during hierarchical merging.</p><p>• An enhanced dual contouring algorithm for the vertex octree built from bottom-up cell merging. We extend the Sur-faceNets algorithm <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14]</ref> to handle multiple representative vertices. Several vertex selection strategies have been supported to specify the active vertices used for contouring.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Isosurface Extraction and Simplification: The problem of isosurface extraction from volume datasets has been studied extensively. Limited by the space here, we only discuss the most relevant documents. The Marching Cubes (MC) algorithm <ref type="bibr" target="#b9">[10]</ref> has been widely used to extract triangular isosurfaces from the scalar values sampled in rectilinear lattices. It can be naturally integrated into the hierarchical octree data structure for multiresolution isosurface extraction. The MC algorithm has been further extended by Nielson <ref type="bibr" target="#b12">[13]</ref>. The major issue in multiresolution MC algorithms is that a crack patching stage is explicitly required when cells of different size meet, since the piecewise linear approximation surface is no longer continuous. Various patching schemes have been proposed, such as point deletion <ref type="bibr" target="#b18">[19]</ref> and point insertion <ref type="bibr" target="#b22">[23]</ref>. However, these strategies usually don't allow level differences of more than one. Furthermore, the original MC algorithm is unable to recover sharp features in a volume.</p><p>Recently, feature-preserving isosurface extraction techniques have been reported. Kobbelt et al. <ref type="bibr" target="#b7">[8]</ref> have presented a directed distance field representation and an extended MC algorithm for featuresensitive isosurface extraction. Ju et al. <ref type="bibr" target="#b6">[7]</ref> have described a dual contouring algorithm for Hermite data. This algorithm avoids the explicit feature testing stage in the extended MC algorithm by computing a minimized representative vertex for each cell and connecting the vertices using the SurfaceNets algorithm <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14]</ref>. Both surface extraction algorithms assume up to one feature per cell. Varadhan et al. <ref type="bibr" target="#b21">[22]</ref> have further extended Ju et al.'s work by handling more than one feature in a cell. We are interested in the Sur-faceNets family algorithms because of its feature-preserving ability and crack-free nature in multiresolution contouring. However, we have a different assumption than Varadhan et al. <ref type="bibr" target="#b21">[22]</ref>. We are more inclined to believe that most of the finest level cells are simple and multiple surface components are formed in the hierarchical simplification process.</p><p>Tetrahedral-based isosurface extraction has been presented <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6]</ref>. Gerstner and Pajarola <ref type="bibr" target="#b3">[4]</ref> have further studied the rules for extracting a simplified isosurface while maintaining its topology in adaptive tetrahedral refinement. A lookup-table method has been used to extract critical points. Isosurface topology is preserved by preserving all the critical points in the adaptive tetrahedral mesh. Ju et al. <ref type="bibr" target="#b6">[7]</ref> have applied a similar idea to simplify a volume grid tagged with material information. There are existing techniques for isosurface and volume topology simplification. In order to simplify the topology, these algorithm usually alter the voxel values. Wood et al. <ref type="bibr" target="#b23">[24]</ref> have analyzed the topology of the input isosurface based on its Reeb Graph. Small handles are located. Then, the corresponding area in the original volume is changed to remove these handles. Szymczak and Vanderhyde <ref type="bibr" target="#b20">[21]</ref> have described a volume topology simplification algorithm where a topology-sensitive carving technique is applied to progressively remove the boundary cells. A variant of the MC algorithm is used to extract an isosurface with simplified topology. However, it is not clear how to combine topology simplification with multiresolution isosurface extraction. Also, the topology-simple isosurface is not guaranteed to have fewer triangles than the complex one.</p><p>Vertex Clustering for Meshes: Although it lacks topologypreservation capability, vertex clustering remains a very powerful simplification technique for large mesh data. Rossignac and Borrel <ref type="bibr" target="#b15">[16]</ref> have reported one of the earliest vertex clustering algorithms on a uniform grid. Many enhancements have been presented for this prototype algorithm. Lindstrom <ref type="bibr" target="#b8">[9]</ref> has used quadric error metrics <ref type="bibr" target="#b2">[3]</ref> to improve the positioning of the representative vertices. His algorithm is further designed for out-of-core simplification using polygon soups. Luebke and Erikson <ref type="bibr" target="#b10">[11]</ref> have employed a hierarchical octree data structure to partition the space. Shaffer and Garland <ref type="bibr" target="#b17">[18]</ref> have presented BSP-tree partitioning. Although these algorithms reduce the clustering errors, the topology preservation problem has not been tackled. Our algorithm avoids the topology problem by allowing multiple representative vertices in a cell and clusters vertices using connectivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DEFINITION OF ENHANCED CELLS</head><p>Although it appears straightforward to add more representative vertices into a cell, the representation of their connectivity is not that trivial. Both the MC algorithm and the discretized MC algorithm <ref type="bibr" target="#b11">[12]</ref> use a cube-based approach, where the binary values of the eight corner points are used to determine the surface components and the connectivity of each component. However, each representative vertex is unable to find its own connectivity using a shared encoding vector of the 8 corner points. Storing the intersection points on edges, such as the directed distance method, may be another choice. However, the intersection points themselves are useless in our simplification process. Also, the intersection points are not associated with the representative vertices explicitly. Consequently, we decide to extend the cube-based encoding by assigning each vertex an encoding vector. Furthermore, we want to incorporate the ability of encoding 2 intersection points per edge, as presented by Varadhan et al. <ref type="bibr" target="#b21">[22]</ref>. Therefore, we define an enhanced cell as follows:</p><p>An enhanced cell is a cell with a list of representative vertices. Each representative vertex has its own inside/outside classification information for the eight cell corner points.</p><p>For each representative vertex v i , the classification information C i encodes the connectivity of v i with vertices in its neighborhood. C i is an encoded vector of (c 0 , ..., c 7 ). Each c i is a tri-value scalar in the range [0, X, 1], where 0 stands for outside the isosurface object, 1 stands for inside the object, and X means unknown. When the classification code of the two end points of an edge are (0, 1) or (1, 0), we refer to it as a sign change, since the isosurface must pass through this edge. The sign changes are directed, which means (0, 1) is different from (1, 0) 2 . The directed sign changes are used to distinguish two vertices that share the same edge for connectivity encoding. The X value is introduced for encoding singular connectivity. In detecting sign changes on edges, no sign changes are indicated if one end-point on an edge has a value X. Within a cell, the connectivity encoding vector of each vertex is unique. The connectivity set of all vertices must satisfy the following rule:</p><p>• There are no two same directed sign changes constructed from the coding vectors.</p><p>This rule enforces that every directed sign change on the edge corresponds to only one vertex. Therefore, the encoding power of the new representation is limited to at most two different directed sign changes per cell edge. Our scheme has higher connectivity encoding capability than the cube-based encoding schemes. It can represent more complex surface components in a cell. We show some examples in 2D. In <ref type="figure" target="#fig_0">Figure 2a</ref>, the coding vectors for the two representative vertices v 0 and v 1 are (1, 0, 0, 0) and (0, 0, 0, 1), respectively. In <ref type="figure" target="#fig_0">Figure 2b</ref>, the coding vectors for the two vertices v 0 and v 1 , which lie on the two parallel lines, are (0, 0, 1, 1) and (1, 1, 0, 0), respectively. The enhanced cell representation cannot represent the shape shown in <ref type="figure" target="#fig_1">Figure 3</ref>, where the coding rule is violated. Our new representation can further encode loops and singular connections inside a cell. Bloomenthal and Ferguson <ref type="bibr" target="#b0">[1]</ref> have addressed the non-manifold polygonization problem. Their method can't handle loops in cells. In our method, we introduce a vertex duping technique, where a vertex can be split into two or more, each with the same position but different coding. For example, for vertex v 2 on the loop of <ref type="figure" target="#fig_0">Figure 2b</ref>, we split it into v 2 and v 3 , which have the same position but different classification codes: (1, 0, X, X) and (0, 1, X, X). Each coding vector has only one sign change for all the four edges. Therefore, the surface components in <ref type="figure" target="#fig_0">Figure 2b</ref> can be represented by the four vertices and their classification codes: <ref type="bibr" target="#b1">2</ref> We consider the direction of the sign changes along the axis-aligned grid lines only. The directions can be +x, −x, +y, −y, +z or −z. <ref type="figure" target="#fig_0">Figure 2c</ref> shows a non-manifold topology example. Similarly, we split the vertex v 0 into two to guarantee manifold topology. The difference is that in the loop case, we mark the two vertices as the same vertex, while in <ref type="figure" target="#fig_0">Figure 2c</ref>, they are treated as different vertices. </p><formula xml:id="formula_0">v 1 v 0 v 2 / v 3 v 1 v 0 v 0 / v 1 c 0 c 1 c 2 c 3 (a) (b) (c)</formula><formula xml:id="formula_1">v 0 : (0, 0, 1, 1), v 1 : (1, 1, 0, 0), v 2 : (1, 0, X, X), v 3 : (0, 1, X, X).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DATA CONVERSION</head><p>Using the enhanced cells, the isosurfaces of various volume representations can be encoded. For a user-defined isovalue, the data conversion process extracts the isosurface and represents it by the enhanced cell representation. Although we only use regular volumes, adaptively-sampled volumes can be represented in the same way. Volume datasets usually include: scanned data, such as the data from CT, MRI and UltraSound, and synthesized data, such as the data generated by scan-conversion algorithms. Volume datasets can also be classified into density/distance volumes and directed distance volumes. The scanned datasets are all density volumes. The synthesized volumes can be density/distance volumes or directed distance volumes, depending on the scan-conversion algorithms used. After conversion, a vertex octree is initialized, where all the homogeneous regions are maximally collapsed and the boundary leaf cells are represented in the enhanced cell form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Density/Distance Volume</head><p>In density/distance volume datasets, for a given isovalue, we use the lookup table of the MC algorithm to determine the disconnected surface components. For each component S i , we generate a representative vertex v i by averaging the intersection points between this surface component and the cell edges. The coding vector C i for each vertex v i is determined by considering only the existence of the cluster S i in the cell. One coding vector is used for each representative vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Directed Distance Volume</head><p>Meshes and implicit surfaces are usually scan-converted (or voxelized) into regular distance fields. Alternatively, they can be sampled into directed distance volumes for feature-sensitive isosurface reconstruction. In the directed distance volumes, explicit intersection points with optional normal information are stored for each edge of the cell. The difference between voxelizing meshes and voxelizing implicit surfaces is mainly the intersection computation. The data conversion process inputs a directed distance volume of uniform resolution. Each cell edge may contain up to two intersection points with associated normals <ref type="bibr" target="#b21">[22]</ref>. The intersection points are grouped to find the surface components they belong to. A representative vertex is computed by minimizing a quadric error function (see Section 5.3 for detail).</p><p>Similar to the ambiguity problem in the MC algorithm, there is ambiguity in constructing surface components from the edges with up to two intersection points per edge. To find the surface components in a cell, we develop a robust algorithm, where repeated edge collapsing tests <ref type="bibr" target="#b3">[4]</ref> are performed. Starting from a corner point, the algorithm performs a depth-first traversal on the cell edges and stops at the first intersection point it meets. The edges with no intersection points are skipped. The intersection points which are first met are grouped into one surface component. At the same time, these intersection points are deleted from the cell. A new starting point is selected and the traversal is continued until all the intersection points are deleted from the cell. To robustly find the surface components, the choice of the starting point is crucial. We build a score board for all the corner points. The corner point with the highest score is chosen as the starting point. The scoring formula is determined by the number of intersection points associated with its three corner edges, the maximum normal deviation of the intersection points, and the in/out classification value of this corner point. In addition, we always prefer a starting point that groups all the vertices into one surface component.</p><p>Because of the existence of edges with two intersection points in a surface component, the computation of the coding vectors is more complicated than that of the density/distance volume data. The number of split vertices depends on the number of coding vectors generated for each surface component. The following greedy algorithm computes the coding vectors of a cluster of intersection points:</p><p>1. Initialize the coding vector buffer with X. Classify the cell edges into two sets: 1-edge (only one intersection point per edge) and 2-edge (two intersection points per edge).</p><p>2. Construct a coding vector C 0 using only the 1-edge edges. The inside/out classification values of the corner points are obtained using the normal directions of these intersection points.</p><p>3. Update C 0 using the intersection points from the 2-edge set, until unable to proceed. In such cases, there will be a wrong coding vector created (introducing conflicting corner classification or non-existing sign changes) if we add one more.</p><p>4. Construct a new coding vector C i (i &gt; 0) using the intersection points from the 2-edge set, until unable to proceed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Repeat step 4 until all intersection points have been exhausted.</head><p>Usually 1-2 coding vectors are sufficient to encode the connectivity, even for complicated cases. <ref type="figure" target="#fig_3">Figure 4a</ref> shows the topologically equivalent graph of a cube. In <ref type="figure" target="#fig_3">Figure 4b</ref>, even a complete edge graph where each edge has two intersection points can be encoded using two complement coding vectors. However, this is not always true. In <ref type="figure" target="#fig_3">Figure 4c</ref>, the graph with three 2-edge edges can't be encoded with only two vectors since there should be no sign changes for the top edge. Four coding vectors are required, instead. In our experiments, four is the maximum number for all examples. After computing the coding vectors, the representative vertex will be split if two or more coding vectors are used. These vertices are given one common id to indicate that they are the same split vertices.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Identifying Surface Components</head><p>During bottom-up cell merging, it is very common that the representative vertices in the child cells are from independent surface components. Clustering them into one single vertex will change the topology. Although in level-of-detail rendering, topology change is sometimes advocated, such as the edge contraction operator <ref type="bibr" target="#b2">[3]</ref>, the topology change will lead to much more error in isosurface simplification. To preserve topology, we separate the surface components and cluster them independently. In our approach, we first compute a connectivity graph of the vertices. Then, we compute the distinct surface components from this graph. To construct the connectivity graph, we use the coding vector associated with each vertex to recover the connection between vertices. Our algorithm is described as follows:</p><p>1. Initialize the vertex sets with the representative vertices from the eight child cells. Each vertex is an independent set.</p><p>2. Find connected surface components. For each cell edge with a directed sign change, the 4 vertices sharing that directed sign change are considered to be in the same component.</p><p>3. Merge the connected vertex sets to minimize the set count.</p><p>4. For the vertices with identical vertex id in a child cell, merge the sets they belong to into one set. In <ref type="figure" target="#fig_4">Figure 5</ref>, we show an example of identifying surface components in 2D. Simplifying surfaces such as this is straightforward for existing mesh simplification algorithms. However, for isosurface simplification algorithms which rely on one representative vertex per cell, the simplification is impossible. According to the components identifying steps, we generate the results and list them in <ref type="table" target="#tab_1">Table 1</ref>. Note that in the third step of  Steps for identifying the surface components in <ref type="figure" target="#fig_4">Figure 5</ref>.</p><formula xml:id="formula_2">v 0 ' v 1 ' v 0 v 1 / v 2 v 3 v 4 v 5 v 6 vertex clustering (a) (b)</formula><formula xml:id="formula_3">1 {v 0 }, {v 1 }, {v 2 }, {v 3 }, {v 4 }, {v 5 }, {v 6 } 2 {v 0 , v 1 }, {v 2 , v 3 }, {v 3 , v 4 }, {v 5 , v 6 } 3 {v 0 , v 1 }, {v 2 , v 3 , v 4 }, {v 5 , v 6 } 4 {v 0 , v 1 , v 2 , v 3 , v 4 }, {v 5 , v 6 }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Merging Coding Vectors</head><p>For each surface component, a set of coding vectors needs to be generated from the existing coding vectors of the child vertices {v i }. To ensure that the enhanced cell definition is not violated, we need to count the directed sign changes on edges of the coarse cell. This definition enforces that for each edge, at most two different directed sign changes exist, one in each direction. The child cells can't be merged if this rule is violated.</p><p>The edges of the child cells can be classified into three types: inneredges (edges that are not mapped to the boundary of the merged cell), edge-edges (edges that are mapped to the boundary edges of the merged cell), and face-edges (edges that are mapped to the boundary faces of the merged cell). During the coding vector merging process, the edge-edges of the child cells are mapped to the corresponding edges of the coarse cell. Their coding information is used to generate the new coding vectors. The merging process uses an algorithm similar to the one used for computing the coding vectors of intersection points in Section 4.2. The inner-edges and the face-edges are discarded since they can't be mapped to the edges of a coarse cell and have no contribution to the coding vectors. It is possible that the merged coding vectors show no connection with other cells. In such cases, we reject merging the child cells to prevent losing surface components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Positioning Representative Vertices</head><p>We use the quadric error function (QEF) <ref type="bibr" target="#b1">[2]</ref> as the vertex positioning metric. QEF has been widely use as an error metric for mesh simplification <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b17">18]</ref>. Different from the previous vertex clustering algorithms <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b17">18]</ref>, where one cell is associated with a QEF, we associate each surface component S i in the cell with a quadric error function Q, which is defined as:</p><formula xml:id="formula_4">Q(x) = ∑ Q i (x)<label>(1)</label></formula><p>where</p><formula xml:id="formula_5">Q i (x) is the QEF of a vertex v i , v i ∈ S i and v i is in a child cell.</formula><p>For boundary leaf cells, Q i (x) can be evaluated using the planes passing through the cells. The representative vertex of S i can be evaluated by minimizing Q.</p><p>The advantage of using a quadric error function is that each Q i can be represented by the following quadric form:</p><formula xml:id="formula_6">Q i (x) = x A i x − 2b i x + c i (2)</formula><p>where x is the representative vertex, A i is a 3×3 matrix, b i is a column vector, and c i is a constant. Similarly, their summarization Q is:</p><formula xml:id="formula_7">Q(x) = x Ax − 2b x + c<label>(3)</label></formula><p>Q(x) represents the sum of square distance of x to a set of planes passing the cell. Normally, the position of x can be solved by solving a linear equation Ax = b to minimize the square distance. To robustly produce the best vertex, we use the following equation to solve the least square optimization problem <ref type="bibr" target="#b8">[9]</ref>.</p><formula xml:id="formula_8">x =x + A −1 (b − Ax) (4)</formula><p>where the seed pointx is the center of the cell. If the matrix A is singular or near singular, the minimization can't be solved by the Gaussian elimination method. In these cases, we adopt the singular value decomposition method (SVD) <ref type="bibr" target="#b14">[15]</ref>. As pointed out by Schaefer et al. <ref type="bibr" target="#b16">[17]</ref>, using the center as the seed point sometimes causes the minimized point to be outside the cell. In the SVD method, although part of the solution space is inside the cell, the computed solution is not guaranteed to be in the cell. Actually, Equation 4 only gives a solution that has the minimized distance to the set of planes and is close to the seed point. In our system, we simply use the average of all the representative vertices,v = (∑ v i )/n, as the seed point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">ENHANCED DUAL CONTOURING</head><p>After the hierarchical clustering stage, a vertex octree has been created, but no isosurface generated. In the contouring stage, the surface that satisfies a specified condition is reconstructed. Instead of storing several levels of simplified isosurfaces, we favor onthe-fly polygon extraction from such a hierarchy. There are several reasons: (1) For any user-defined error threshold, a topologypreserving isosurface can be extracted from the vertex hierarchy.</p><p>(2) The vertex hierarchy allows a vertex to be dynamically refined or collapsed in a topology-preserving style, thus makes viewdependent rendering possible. <ref type="formula" target="#formula_7">3</ref>Other methods of isosurface visualization can be supported, such as the Region of Interest (ROI) isosurfacing. The ROI isosurfacing specifies a low error threshold on the regions of interest, while making the outside regions coarse.</p><p>We name our polygonization algorithm enhanced dual contouring since it extracts meshes from a vertex octree where multiple vertices may be stored in a cell and uses a vertex selection procedure to decide the active vertex set. To shorten our narration, we only discuss the polygonization strategy that employs single error-based strategy. The ROI isosurfacing can be easily derived by using regionbased vertex selection strategies. In the single error-based strategy, the vertices used in polygonization are chosen according to a given quadric error threshold δ 2 . A vertex v can be marked as active and selected for polygonization only if its quadric error Err v ≤ δ 2 . We discuss two types of polygonization:</p><p>• Static polygonization, where only the vertices in the boundary leaf cells of the octree are used to construct the isosurface. This polygonization algorithm is similar to the extended dual contouring algorithm <ref type="bibr" target="#b21">[22]</ref>.</p><p>• Dynamic polygonization, where the vertices in the intermediate level cells, which are created by hierarchical merging, are also used to connect the surface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Static Polygonization</head><p>The static polygonization corresponds to the case where δ 2 = 0. By default, all the representative vertices in the boundary leaf cells are initialized as active. In such a case, the polygonization algorithm is a straightforward extension of the SurfaceNets algorithm for multiple representative vertices. In a uniform resolution volume, for each edge with a directed sign change, the vertices from the four cells sharing that edge are connected to form a quad. Since there are multiple vertices in a cell, for each edge with a directed sign change, finding the corresponding vertex is performed by a sequential search of the vertex list stored in the cell. In the multiresolution cases, there might be only three cells involved and only one triangle is constructed. Note that the static polygonization algorithm also supports the crack-free multi-resolution isosurface extraction since it is still a dual method to the MC algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Dynamic Polygonization</head><p>The dynamic polygonization corresponds to the case where δ 2 &gt; 0. Every vertex v in the isosurface is required to satisfy Err v &lt;= δ 2 . Before polygonization, an explicit active vertex selection stage is applied, where the whole octree is recursively visited and all the representative vertices are checked for activeness. The potential problem in the selection is that there might be cases where some of the vertices in a cell have errors higher than the threshold and the remainder lower than the threshold. <ref type="figure" target="#fig_6">Figure 6</ref> gives such an example, where vertex a 0 is merged from a 1 , a  To handle the above problem in our dynamic polygonization algorithm, for each vertex v, a parent-vertex field is introduced. The parent-vertex field stores a pointer to the vertex that v is merged to. This field is initialized during the hierarchical merging stage. The vertex selection stage is modified. The parent-vertex field is checked for each vertex. If the parent vertex or ancestor has been activated, all the decedents must be deactivated. Otherwise, the representative vertices are classified according to δ 2 . The vertices within the error threshold are marked as active. In the modified polygonization algorithm, the parent-vertex is also checked to prevent missing surface components. Now, in <ref type="figure" target="#fig_6">Figure 6</ref>, since a 0 is used, a 1 , a 2 , and a 3 are disabled. On the contrary, since b 0 is not used, b 1 , b 2 , and b 3 are enabled. Note that vertices a 3 and b 1 are in the same cell whereas only b 1 is enabled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">IMPLEMENTATION AND RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Implementation</head><p>We have implemented our simplification algorithm in C/C++ and run all the experiments on a uni-processor 3.0GHz Intel Pentium IV PC running Windows XP, with 512M RAM and NVIDIA GeForce4 graphics board. In all the examples, the physical size of the octree is set to 1.0. The vertex octree has been implemented as a Hash tree to ease the neighborhood searching operations frequently used in our polygonization algorithms. In the hierarchical clustering algorithm, the quadric error metrics are used locally. Therefore, a buffer of 30 entries is sufficient for simplification. In the final vertex tree, for each vertex we store the quantized vertex position (6 bytes), a quadric error (4 bytes), a parent pointer (4 bytes), the vertex id (1 byte), a coding vector (2 bytes), and some tagging information (1 byte). Totally 18 bytes are used for each vertex. The simplification algorithm generates about 0.3n extra vertices in the vertex hierarchy, where n is the count of vertices in the finest resolution. Therefore, the space requirement for this algorithm is about O(1.3n), plus the octree cost. The simplification time complexity is also O(1.3n), since each vertex is visited only once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Performance</head><p>We have applied our algorithm on different volume datasets: density/distance volumes, scan-converted polygon meshes, and scanconverted implicit surfaces. The voxelization time for polygonal meshes and implicit surfaces varies from several seconds to about one minute. However, it is purely preprocessing cost. The time for data conversion is usually within seconds. There are two stages in the performance measurement: the simplification stage, where the vertex octree is built hierarchically, and the polygonization stage, where a user-specified error threshold is given and the isosurface satisfying that tolerance is extracted. The timing results for some test data are shown in <ref type="table" target="#tab_3">Table 2</ref>. The advantage of separating the two stages is reflected in the timing for polygonization. As indicated in <ref type="table" target="#tab_3">Table 2</ref>, since the representative vertices are computed in advance and stored in the cells, the surface extraction is much faster, compared to the result reported by Varadhan et al. <ref type="bibr" target="#b21">[22]</ref>, despite the fact that a deeper octree is used.    shows quadric error based simplification for the isosurface of a distance volume, where about 91% triangles are decimated. <ref type="figure" target="#fig_12">Figure 9</ref> shows ROI isosurfacing on two density volumes, where two different ROI methods are used: a rectangular and a spherical. The spherical ROI has gradual error increasing from its center. The versatility of our polygonization algorithm is attributed to a flexible vertex selection procedure on the vertex hierarchy. For a given error threshold, a vertex is selected based on its own error and is independent of the errors of other vertices. At the same time, the polygonization speed is only slightly slower than the dual contouring algorithm. The added cost is mainly the time for matching vertices and traversing the vertex hierarchy in finding the active vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Comparison with Previous Methods</head><p>Compared with our algorithm, the simplification algorithm described by Ju et al. <ref type="bibr" target="#b6">[7]</ref> is a more conservative algorithm. The core of their algorithm is a manifold test based on Gerstner and Pajarola's algorithm <ref type="bibr" target="#b3">[4]</ref>. Their algorithm requires that in each coarse cell, the shape should be a pseudo-manifold (each material is a manifold). For contouring, their method has the limitation of only one vertex per cell. However, we have shown that two disconnected surface components in a fine level cell can be merged into one surface component in the coarse level, such as the example in <ref type="figure" target="#fig_4">Figure 5</ref> where the two surface components represented by vertices v 0 and v 3 can   be clustered together in the cell merging process. Therefore, the simplification capability of their algorithm is restricted.</p><p>In <ref type="figure" target="#fig_13">Figure 10</ref>, we show the results of simplifying a 2D Chinese character based on a quadtree data structure. This character is sampled in 256 2 resolution. Several variations of the vertex clustering algorithm have been applied: the octree based algorithm where topology is ignored <ref type="bibr" target="#b10">[11]</ref>, the topology-preserving algorithm of Ju et al. <ref type="bibr" target="#b6">[7]</ref>, and ours. Some differences are highlighted with circles. In the non-topology-preserving result of <ref type="figure" target="#fig_13">Figure 10b</ref>, several regions have become disjointed. In the conservative result of <ref type="figure" target="#fig_13">Figure 10c</ref>, many tiny cells are kept since they violate the simplification rules defined by Ju et al. <ref type="bibr" target="#b6">[7]</ref>. In contrast, we are able to handle these cases. <ref type="table" target="#tab_4">Table 3</ref> gives the comparison of cell and vertex counts generated in <ref type="figure" target="#fig_13">Figure 10</ref>. Under the same error threshold, we generate fewer cells and vertices than the other topology-preserving algorithm. Tiny cells are merged so that a more balanced simplification result is achieved. Our method also generates fewer cells and vertices than the non-topology-preserving algorithm. It shows that fewer errors are accumulated on the vertices. Furthermore, the contouring cost is reduced by the facts: (1) fewer cells and vertices are visited, and (2) fewer lines are generated. The effectiveness of our algorithm is more significant in 3D cases. It is not easy to give a direct comparison between our algorithm and the octree-based MC decimation algorithm reported by Shekhar et al. <ref type="bibr" target="#b18">[19]</ref>, since ours is basically a dual method to the MC algorithm. However, because of the encoding power, we could expect that ours will generate better results. Furthermore, ours has the advantage of no crack-patching between different octree levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS AND FUTURE WORK</head><p>We have presented a topology-preserving isosurface simplification algorithm using a novel concept of preserving disconnected surface components during simplification. The problem is transformed into representing isosurface components and topology-preserving isosurface clustering. The enhanced cell representation is used to encode isosurface components in cells. A connectivity-guided vertex clustering algorithm is used to simplify the isosurface components. After building a hierarchically clustered vertex octree, topologypreserved isosurfaces can be extracted under various error bounds by the enhanced dual contouring algorithm. Our algorithm is efficient in simplifying isosurfaces of a fixed isovalue. Although it is not a general isosurface extraction algorithm with topology preservation, such as Gerstner and Pajarola's algorithm <ref type="bibr" target="#b3">[4]</ref>, the efficiency is attractive to those who are interested in fixed isovalues and concerned more about real-time visualization. In these cases, offline simplification algorithms, such as QSlim, are not suitable. Furthermore, the efficiency of our algorithm makes it possible to be combined with fast isosurface extraction algorithms to extract multiresolution isosurfaces with topology-preservation for different isovalues.</p><p>We have some on-going research work. We are studying powerful encoding schemes for isosurfaces. We are also interested in applying our approach in view-dependent isosurface rendering. Our pre-simplified vertex octree allows vertex refinement and collapsing in a topology-preserving manner. The screen-space errors can be considered in vertex selection. Finally, we plan to apply our new representation in point cloud reconstruction by better handling surface topology in cells.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>The enhanced cell representation for several cases, where the blue dashed line in (a) shows the corner indexing sequence. (a) Two disconnected surface components. (b) Two intersection points per edge, including a loop case. (c) Non-manifold topology.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Our encoding scheme can't represent two surface patches which generate the same directed sign change on an edge (shown as a dashed line).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Some cases for cell encoding. (a) The topologically equivalent 2D graph of a cube. (b) The complete graph where each edge has two intersection points can be encoded by two vectors. (c) An edge graph with three 2-edge edges can't be encoded with two vectors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Identifying surface components in cells. (a) The child cells. (b) The merged cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2 and a 3 and vertex b 0 is merged from b 1 , b 2 and b 3 .a 3 b 1 b 2 b 3</head><label>133</label><figDesc>Assume Err a 0 , Err b 1 , Err b 2 , Err b 3 ≤ δ 2 and Err b 0 &gt; δ 2 . Therefore, although a 0 and b 0 are in the same cell, only a 0 can be used for polygonization. To extract the surface component represented by b 0 , the child vertices of b 0 have to be used. However, the static polygonization algorithm is performed in a cell-by-cell order. An indication is required to extract the surface components in the child cells.Child cells</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>During dynamic polygonization, vertices which have error Err &gt; δ 2 are not selected, such as the vertex b 0 . Instead, the child vertices (b 1 , b 2 , and b 3 ) are selected for contouring.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>δ 2 = 10 −6 δ 2 = 10 −4 δ 2 = 10 Figure 1</head><label>2102102101</label><figDesc>demonstrates that disconnected, voxelized models are clustered independently. These objects are assigned different material properties. After simplification, the isosurfaces remain disconnected. InFigure 7, we further show the effectiveness of caching the surface components in the intermediate levels. The zero-isosurface of a voxelized mechanical part dataset is simplified to a symmetric object of 152 triangles(Figure 7c), where each octree cell contains only one representative vertex. However, the intermediate simplification result(Figure 7b) does contain some cells with multiple representative vertices (drawn as yellow spheres) in each cell. With the help of the enhanced cell representation as a temporary storage, these cells can be merged with other cells. Another interesting observation we gain from this dataset is that the adaptive sampling process with maximum octree level of 4 creates an inferior model(Figure 7d) than our simplification result, although more cells are used. This effect can be explained by the fact that during the adaptive sampling, the representative vertices are positioned according to the QEFs constructed from the intersection points on the cell edges. Since the sampling grid is coarse, these vertices are not as good as a simplification result where the vertices are actually the average of many vertices.(a) t = 128K (b) t = 1442 (c) t = 152 (d) t = 224 (e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Simplifying the zero-isosurface of a voxelized mechanical part dataset. (a) The original model. (b) Simplified, where δ 2 = 2.5 × 10 −3 . The octree subdivision is shown in green lines. (c) The final simplification result, where δ 2 = 1. (d) An adaptively sampled example. (e) Zoom-in view of the rectangular region in (b). The representative vertices are shown as red (one point per cell) or yellow (multiple points per cell) spheres.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8</head><label>8</label><figDesc>Figure 8 shows quadric error based simplification for the isosurface of a distance volume, where about 91% triangles are decimated. Figure 9 shows ROI isosurfacing on two density volumes, where two different ROI methods are used: a rectangular and a spherical. The spherical ROI has gradual error increasing from its center. The versatility of our polygonization algorithm is attributed to a flexible vertex selection procedure on the vertex hierarchy. For a given error threshold, a vertex is selected based on its own error and is independent of the errors of other vertices. At the same time, the polygonization speed is only slightly slower than the dual contouring algorithm. The added cost is mainly the time for matching vertices and traversing the vertex hierarchy in finding the active vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>(a) δ 2</head><label>2</label><figDesc>= 0, t = 900K. (b) δ 2 = 2 × 10 −5 , t = 80K.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Simplifying the isosurface from a distance volume, where the distance value 0.001 is used.(a) Rectangular ROI. (b) Spherical ROI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Isosurface visualization using ROI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Simplifying a Chinese character in 2D. (a) The original model. (b) Simplification result using the non-topology-preserving vertex clustering. (c) Simplification result using Ju et al.'s algorithm. (d) Simplification result using our algorithm. (e), (f), and (g) show zoom-in view of the circled regions of (b), (c), and (d), respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>5 BUILDING VERTEX HIERARCHYThe vertex hierarchy is built by hierarchically merging the octree cells in a bottom-up manner. During cell merging, the vertices in the child cells are clustered and a new representative vertex is created for each surface component. A new cell can't be created if the surface components in the cell cannot be represented by the enhanced cell structure. For each cell merging, there are three steps:1. Identify the connected surface components for the representative vertices in the child cells.2. Test whether the coding vectors of the child vertices in each surface component can be merged or not. If yes, go to step 3, otherwise quit.</figDesc><table /><note>3. Construct a new representative vertex and new coding vectors for each distinct surface component.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>, since v 1 and v 2 are the same vertex, the two sets associated with them:{v 0 , v 1 } and {v 2 , v 3 , v<ref type="bibr" target="#b3">4</ref> } are merged into one set. Finally, two distinct surface components are found by the identifying algorithm.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Simplification and polygonization timing (in sec.) for voxelized objects.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Comparison of the simplification results of a Chinese character, where δ 2 = 0.003 (EC: our enhanced cell method; VC: nontopology-preserving vertex clustering; JA: Ju et al.'s algorithm).</figDesc><table><row><cell>Algorithm</cell><cell># cells</cell><cell># vertices</cell><cell># lines</cell></row><row><cell>EC</cell><cell cols="3">279(100%) 300(100%) 300(100%)</cell></row><row><cell>VC</cell><cell cols="3">327(117%) 327(109%) 327(109%)</cell></row><row><cell>JA</cell><cell cols="3">470(168%) 470(157%) 470(157%)</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">A report of proof can be downloaded from our website: http://www.cs. sunysb.edu/∼vislab/papers/tpvc.pdf.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work is supported by NSF grant CCR0306438 and ONR grant N000140110034. We would like to thank the anonymous reviewers for their help in improving this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Polygonization of non-manifold implicit surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bloomenthal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ferguson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="1995-07" />
			<biblScope unit="page" from="55" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Quadric-Based Polygonal Surface Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-05" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Surface simplification using quadric error metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Topology preserving and controlled topology simplifying multiresolution isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gerstner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2000-10" />
			<biblScope unit="page" from="259" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Using distance maps for smooth surface representation in sampled volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gibson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Interactive view-dependent rendering of large isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gregorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2002-10" />
			<biblScope unit="page" from="475" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dual contouring of Hermite data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Losasso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="2002-07" />
			<biblScope unit="page" from="339" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Featuresensitive surface extraction from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">P</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Schwanecke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In SIGGRAPH Proceedings</title>
		<imprint>
			<biblScope unit="page" from="57" to="66" />
			<date type="published" when="2001-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Out-of-core simplification of large polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="259" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Marching Cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">View-dependent simplification of arbitrary polygonal environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Erikson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Discretized marching cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scateni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="281" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On marching cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="283" to="297" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Kizamu: A system for sculpting digital characters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">N</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">F</forename><surname>Frisken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="2001-08" />
			<biblScope unit="page" from="47" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">H</forename><surname>Press</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Teukolsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">T</forename><surname>Vetterling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Flannery</surname></persName>
		</author>
		<title level="m">Numerical Recipes in C++</title>
		<meeting><address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multi-resolution 3D approximation for rendering complex scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Dual contouring: The secret sauce</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
		<idno>02-408</idno>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Rice University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient adaptive simplification of massive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="127" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Octree-based decimation of marching cubes surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shekhar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Fayyad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cornhill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="335" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Guaranteeing the topology of an implicit surface polygonization for interactive modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Stander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Hart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH Proceedings</title>
		<imprint>
			<date type="published" when="1997-08" />
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Extraction of topologically simple isosurfaces from volume datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vanderhyde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="67" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Featuresensitive subdivision and isosurface reconstruction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varadhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="99" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Real-time exploration of regular volume data by adaptive reconstruction of isosurfaces. The Visual Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="100" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Isosurface topology simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<idno>MSR-TR-2002-28</idno>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>Microsoft Research</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
