<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Graphics Hardware-based Vortex Detection and Visualization System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Stegmaier</surname></persName>
							<email>stegmaier|ertl@vis.uni-stuttgart.de</email>
							<affiliation key="aff1">
								<orgName type="institution">Universität Stuttgart</orgName>
								<address>
									<addrLine>Universitätsstraße 38</addrLine>
									<postCode>70569</postCode>
									<settlement>Stuttgart</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Universität Stuttgart</orgName>
								<address>
									<addrLine>Universitätsstraße 38</addrLine>
									<postCode>70569</postCode>
									<settlement>Stuttgart</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute of Visualization and Interactive Systems</orgName>
								<orgName type="institution">University of Stuttgart</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Graphics Hardware-based Vortex Detection and Visualization System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Interactive Rendering-Flow Visualization; Features in Volume Data Sets</term>
					<term>Flow Visualization</term>
					<term>Hardware Acceleration</term>
					<term>3D Vector Field Visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Figure 1: Vortex structures extracted by the GPU. Simulated flow transition (left), simulation of hurricane Isabel (right).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Physical and numerical flow simulations have become an important part of the research activities in both industry and academia. To gain understanding of the simulated flow, it is necessary to perform some kind of data analysis. This is usually done by scientific flow However, vortex detection is computationally much more expensive than drawing an isosurface of the velocity magnitude or a slice with any other scalar property mapped to a color. Accordingly, vortex detection currently cannot be done on an off-the-shelf PC at interactive frame rates-which may be desirable for tracking flow structures over several time-steps in unsteady flows or for analyzing flow data obtained by simulation or measuring techniques vulnerable to noise, e.g. direct numerical simulation (DNS) or particle image velocimetry (PIV).</p><p>In the latter cases, the vortex detection may be considerably affected by noise ( <ref type="figure" target="#fig_1">Fig. 2)</ref>. Accordingly, some form of denoising should be applied to the raw data before one tries to detect vortices. If the frequency of the noise is known in advance, denoising is most effectively accomplished by designing a bandpass filter capable of removing the relevant frequencies.</p><p>However, if the noise cannot be exactly located in the frequency domain, an interactive cycle of filtering, vortex detection, visualization and evaluation (based on the existing knowledge of the flow) must be entered and repeated until the optimal filter characteristics have been found and a visualization of acceptable quality is obtained. Obviously, neither filtering nor visualization come for free so handling the complete cycle is even more difficult than handling the vortex detection alone. For engineers working in the field of fluid dynamics verifying results of experiments or simulations therefore presents a tedious and time-consuming task.</p><p>In this paper we present a system to alleviate this situation. We demonstrate that by shifting the entire cycle from the CPU to the GPU and by exploiting the modern GPUs' parallel processing capabilities interactive work is possible. Our solution expects the vector field data to be made available in a texture which assumes the in-  put data is defined on a uniform Cartesian grid. However, there are efficient techniques for the conversion between grids without sacrificing much accuracy (see e.g. <ref type="bibr" target="#b22">[23]</ref>), thus, this poses no limitation. Once the vortices have been detected an isosurface of the detected vortex regions is generated. If the user decides to adjust the filter support or the isovalue he will get an instantaneous update of the visualization. Since at no instant any intermediate results have to be passed back to the application, immediate feedback is obtained.</p><p>The remainder of the paper is organized as follows: In Section 2 we discuss work of other researchers related to this paper. Section 3 outlines the λ 2 vortex detection method and motivates why it was used in this work. The architecture of our system is presented in Section 4, followed by an evaluation in Section 5. The paper concludes in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>A large body of research has been conducted on methods that are able to reliably detect vortices. The papers by Jiang et al. <ref type="bibr" target="#b8">[9]</ref> and Post et al. <ref type="bibr" target="#b16">[17]</ref> provide good overviews of the most popular techniques and give taxonomies of vortex detection algorithms.</p><p>So-called local methods require only operations within the neighborhood of a cell; thus, all algorithms based on the Jacobian matrix (or the velocity gradient tensor) fall into this class. On the contrary, global methods examine many grid cells to detect a vortex. Typical representatives of this class are algorithms based on streamline tracing.</p><p>Furthermore, vortex detection algorithms can be classified according to Galilean invariance. A vortex detection algorithm that is Galilean invariant is valid in all inertial frames of reference and thus is able to detect vortices not only in steady but also in time-varying flow fields.</p><p>To our knowledge, none of the vortex detection algorithms found in the literature has ever been implemented on a GPU. However, many techniques have been developed to effectively visualize flow fields using a GPU. Especially texture-based techniques-though rather dated <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b13">14]</ref>-are enjoying great popularity and are still a topic of research <ref type="bibr" target="#b23">[24]</ref>. Since the basic procedure of GPU-based vortex detection can be expected to be the same as that of GPUbased flow visualization, these research results are nevertheless a valuable foundation for this work.</p><p>GPU-based feature detection is the most prominent part of this work. Two other aspects are GPU-based filtering and volume rendering. Both fields have been studied in detail by several researchers. Hardware-accelerated filters-both linear and nonlinear-implementing a wide variety of kernels have been described in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b20">21]</ref>. Volume rendering techniques for Cartesian grids are studied in <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b10">11]</ref>. Since this work concentrates on feature detection and extraction and on integrating various techniques into a productive system, we exclusively relied on these standard techniques for filtering our data and visualizing the vortex structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE λ 2 METHOD</head><p>Most of the graphics adapters nowadays shipped with off-the-shelf PCs include both programmable vertex and fragment processors. Thus, the programmer is able to operate on each vertex provided by the application and each fragment generated by the rasterization. Since arbitrary data can be stored in texture memory with 32 bit accuracy, these features have been used not only to create real-time advanced visual effects but also to implement numerous numerical algorithms. In fact, the modern GPUs' high parallelism on several levels (memory bandwidth, redundant rendering pipelines) has even led to the development of general numerical libraries that allow the user to transparently use the GPU as a high-performance floatingpoint coprocessor <ref type="bibr" target="#b11">[12]</ref>.</p><p>Nevertheless, a GPU implementation will not be advantageous for all algorithms. For a GPU implementation to be beneficial, it is of paramount importance that the algorithm exhibits local behavior or-put another way-that it can be efficiently implemented on a multi-processor computer. Thus, referring to the taxonomies given in Sec. 2 global vortex detection methods can immediately be discarded. Galilean invariance was said to be another desirable property of a vortex detection algorithm. This further isolates the number of vortex detection algorithms appropriate for an implementation on the GPU.</p><p>Of the algorithms proposed in the literature, we have found the λ 2 method proposed by Jeong and Hussain <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b14">15]</ref> to be the most suitable algorithm with these properties. This method is generally regarded to produce good results and only shows some shortcomings when applied to turbomachinery flows <ref type="bibr" target="#b19">[20]</ref>; thus, the λ 2 method presents an adequate choice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Given a vector field</head><formula xml:id="formula_0">u(x) =   u 1 u 2 u 3  </formula><p>the λ 2 method first decomposes the velocity gradient tensor ∇u (the Jacobian matrix of the vector field) into a symmetric part S and an antisymmetric part Ω:</p><formula xml:id="formula_1">S i j = 1 2 ∂ u i ∂ x j + ∂ u j ∂ x i , Ω i j = 1 2 ∂ u i ∂ x j − ∂ u j ∂ x i</formula><p>From a physical point of view S is the strain-rate tensor and Ω the spin tensor. Next, the eigenvalues of the matrix S 2 + Ω 2 need to be determined. Since this matrix is real and symmetric, there will be three eigenvalues-roots of the characteristic polynomial-denoted by λ 1 ≥ λ 2 ≥ λ 3 . A vortex is then defined as a connected region where two of the eigenvalues are negative. The eigenvalue relevant for visualization is λ 2 -hence the name of the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SYSTEM ARCHITECTURE</head><p>The system is divided into two parts: an initialization part that is executed once per data set and the actual cycle that is entered each time the filter characteristics are adjusted by the user.</p><p>Prior to entering the cycle, the vector field (which is assumed to be defined on a Cartesian grid) must be loaded and preprocessed. The preprocessing consists of adding a one-cell border around the volume. The values of the border cells are chosen such that the gradients at the original cells can all be determined using central differences. This work-around relieves us from the burden of having to handle border cells differently from inner cells during gradient estimation. Thus, assuming original grid dimensions of I × J × K, a volume of the dimensions (I + 2) × (J + 2) × (K + 2) is obtained. This volume is then cut into K + 2 slices each holding all the values of a constant Z-coordinate and each slice copied to a 2D RGBAtexture. We have chosen a 32 bit floating point texture for this purpose since this allows us to store vector components of type float without introducing truncation errors on common PC platforms.</p><p>The cycle in turn can be further divided into three major parts: denoising of the raw vector data, computation of λ 2 values, and rendering of the output of the vortex detection algorithm. Since the λ 2 values comprise scalar data, any volume rendering technique can be employed for visualization. Thus, part three can be titled the volume visualization phase. The following subsections describe these parts in detail.</p><p>For our implementation we have chosen the ATI 9800 graphics adapter and DirectX/D3D despite the low instruction limit of 64 + 32 = 96 instruction slots. The reason for choosing this platform is that-as will be shown-the system requires multiple passes if the number of redundant computations is to be reduced and multi-pass rendering with the ATI/DX9 combination does involve only a very minor performance penalty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Filtering</head><p>All measurements-and even some simulation data-are subject to noise. To oppress this noise, a lowpass filter can be employed. Usually, a lowpass filter's ability to oppress noise greatly depends on its support, i.e. the number of neighbors incorporated into the calculation of the filtered value.</p><p>In a hardware implementation the neighbors need to be determined by lookups into textures filled by the application with the appropriate information. Thus, a filter of support N requires N 3 texture lookups to obtain the neighbor information. Our target platform only supports 32 texture lookups per pass; thus, the maximum filter support that can be implemented in a single pass is three. If more advanced filters are required, multi-pass implementations must be resorted to.</p><p>For this work, a Gaussian lowpass filter has been employed. This type of filter has two benefits that make it suitable for our application:</p><p>• The Gauss filter is isotropic, i.e. it is rotation invariant. In contrary to non-isotropic filters, isotropic filters are good at preserving oriented features which is essential for vortex detection.</p><p>• The Gauss filter is separable, i.e. small filter kernels can be implemented in a single pass while large filter kernels can be implemented with several passes with little additional overhead.</p><p>For the presented system, both single-and multi-pass Gaussian lowpass filters have been implemented.</p><p>Single-Pass Filtering To filter the (border-extended) vector data, the application renders K + 2 filled quadrilaterals of (I + 2) × (J + 2) pixels each. For each quadrilateral, the current slice, the one to the back, and the one to the front are passed as textures. A pixel shader then is executed for each generated fragment. In the shader the neighbors are looked up and multiplied by a weighting factor. The intermediate results are then added and written to the RGB-components of the output pixel. The filtered data is directly rendered to a second stack of K + 2 floating point textures, each texture again of size (I + 2) × (J + 2) texels. Overall, 27 texture lookups plus 44 arithmetic instruction slots are required.</p><p>To obtain the weights of the neighbors we evaluate the Gauss function for the arguments 0, x, √ 2x, and √ 3x and normalize the function values so that the sum over all 27 weights equals one. The value of x is predefined to some constant value and denotes the minimum distance between voxel centers. The remaining arguments are calculated by considering the other distances (match in at most one coordinate) relative to the minimum distance. The arguments for evaluating the Gauss function remain constant. However, the user can adjust the variance σ 2 of the Gauss function and thus can adjust the neighbor weights which are then passed to the pixel shader as program parameters.</p><p>Multi-Pass Filtering A single-pass Gauss filter is restricted to support three. If multiple passes are acceptable, the 3D Gauss filter can be separated into three 1D filters, each of them applied in a single rendering pass and reusing the output of the preceding filter pass. The order of the passes is arbitrary and does not effect the result. However, the complexity of the implementation and the amount of temporary texture memory are very well affected.</p><p>If the data is filtered first in X-and Y-direction, only a single input and output texture are required for the first two passes since the input data is stored as Z-aligned slices. However, the final Z-direction rendering pass requires N slices to have already been filtered in Xand Y-direction; thus, N + 1 temporary floating point textures are required.</p><p>On the other hand, if the data is filtered first in Z-direction, N slices of the unfiltered vector data are used as input and the result is written to a single floating point texture. For the remaining passes, another floating point texture is required; thus, only two temporary textures are required (independent of the filter support) and no program logic is needed that caches the results of the XY-filtering for a final Z-filtering pass.</p><p>As before, the filtering is then done by rendering K +2 filled quadrilaterals of (I + 2) × (J + 2) pixels. In the pixel shader, the current pixel's N neighbor values (including itself) are looked up. Since all neighbors are equidistantly spaced, the Gauss function is now evaluated at equidistantly spaced points to obtain the weights.</p><p>The passes consume N texture lookups each and 32 and 12 instructions slots for the filtering in X-/Y-and Z-direction, respectively. Since, in either case, at most N texture lookups are required, filter supports of up to 31 could theoretically be implemented with the number of texture lookups restricted to 32. However, on our platform the number of texture samplers is currently limited to 16 so the maximum filter support is 15.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Vortex Detection</head><p>A careful implementation of λ 2 vortex detection requires almost twice as many instruction slots as are available on the ATI 9800. Hence it is impossible to implement the vortex detection in a single pass and the question arises as to where to cut the pixel shader into passes.</p><p>This split-up must not be arbitrary. When adjusting an algorithm to multi-pass rendering, intermediate results are written to a texture which in turn is made available to the subsequent pass. This means that the amount of intermediate data per pixel has to fit into a RBGA texel of at most 128 bit. If this does not suffice it is possible on some architectures to use multiple render targets (MRTs). Fortunately, the λ 2 method can very nicely be split into two passes.</p><p>The idea is to calculate the coefficients of the characteristic polynomial in the first pass and to solve the characteristic equation in the second pass. Since the characteristic polynomial is a cubic, only four floating point numbers need to be passed between the passes. This data tightly fits into an RGBA value and thus allows us to abandon MRTs.</p><p>The following paragraphs outline the shader implementations. ...</p><p>Unfortunately, this code compiles to too many instruction slots. However, by considering that the matrix to be used for calculating eigenvalues is symmetric, a more efficient (and somewhat more unreadable) formulation can be found that requires only six texture lookups and 59 instruction slots and, therefore, is accepted as a single-pass shader: The remaining matrix entries can be derived analogously by permutations of indices. Once the sum matrix has been derived, the coefficients of the characteristic polynomial are calculated in a straightforward way and assigned to the current pixel's color to make them available to the solver pass.</p><formula xml:id="formula_2">sum00 =</formula><p>Pass 2: Solving the Characteristic Equation To solve the polynomial equation involving the characteristic polynomial, we adopted the modification of Cardan's solution proposed by Nickalls <ref type="bibr" target="#b15">[16]</ref>. Assuming a cubic polynomial equation  where</p><formula xml:id="formula_3">α = x N + 2δ cos(θ )<label>(1)</label></formula><formula xml:id="formula_4">β = x N + 2δ cos(2π/3 + θ ) (2) γ = x N + 2δ cos(4π/3 + θ )<label>(3)</label></formula><formula xml:id="formula_5">x N = −b/(3a) cos(3θ ) = −y N /(2aδ 3 ) δ 2 = (b 2 − 3ac)/(9a 2 )</formula><p>and y N is the value of the polynomial evaluated at x N .</p><p>Expressions (1) -(3) can be easily mapped to graphics hardware since the HLSL instruction set includes a both a cos and an acos instruction. However, the PS2.0 sincos instruction (which the HLSL cos is mapped to) consumes eight instruction slots; thus, a total of 24 instruction slots are required for the three cosine calculations alone. As a result, when using the native instructions of the GPU, the maximum number of instructions is surpassed and the program is again rejected.</p><p>One often used technique to solve this problem is to replace trigonometric operations with lookups into 1D luminance textures of precalculated function values. Thus, by creating two textures with precomputed cosine and inverse cosine values, respectively, only four texture lookups are necessary for obtaining θ and the three cosines.</p><p>However, this approach is too general for our application. What is actually needed are cosine values for the arguments arccos(−y N /(2aδ 3 ))/3 + 2k/3π where k ∈ {0, 1, 2}. It is, therefore, much more efficient to create a single 1D RGBA texture 1 storing precomputed cosines for these arguments and to access the texture with the inverse cosine argument. The three cosines can then be obtained simultaneously with a single texture lookup and no inverse cosine calculations are necessary at all. The resulting program thus requires only two texture lookups and 31 arithmetic instruction slots.</p><p>Obviously, compared to the four texture lookups of the more general approach, this is another significant performance gain. This also becomes evident when comparing the λ 2 calculation times:</p><p>The overall computation time reduces by another 15%.</p><p>Actually, the described method for solving the characteristic polynomial does only produce correct eigenvalues if there are three distinct real roots. This is the case in about 99.5 percent for the data set shown in <ref type="figure">Fig. 5</ref>, thus, the results obtained by the given approach are a good approximation. Setting h = 2aδ 3 three real roots are obtained if y 2 N &lt; h 2 . For y N &gt; h 2 (one real root) or y 2 N = h 2 (three real roots, two or three equal roots) the calculation must be modified. For the latter case, δ is adjusted to δ = 3 y N /(2a) and the roots are</p><formula xml:id="formula_6">then α = β = x N + δ and γ = x N − 2δ .</formula><p>Handling all three cases is costly on a streaming architecture and even exceeds the maximum number of instruction slots of our platform. The matrix S 2 + Ω 2 , however, is real and symmetric and, therefore, will always have three real roots. The case y N &gt; h 2 will thus occur only very rarely (if at all) due to numerical inaccuracies. Accordingly, we have decided to neglect this case and to handle only the remaining two cases. The number of required instruction slots in our fragment program then raises from 31 to 55 which is well within the limits of available instruction slots. <ref type="figure" target="#fig_3">Fig. 3</ref> contrasts the approach handling two cases with the simplified root finding approach handling only a single case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Volume Visualization</head><p>The input vector data is processed slice per slice. Rendering the resulting λ 2 values directly into a 3D texture was not possible at the time of this writing, thus, the results are again written to a stack of 2D. Obviously, simply blending quadrilaterals with the λ 2 values mapped as textures will not produce appealing visualizations since virtually nothing at all is seen when looking along the X-or the <ref type="bibr" target="#b0">1</ref> The ATI 9800 does not support RGB floating point textures so RGBA textures had to be used, leaving the alpha component unused.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y-axis 2 .</head><p>Many techniques have been developed to cope with this problem. Rendering view-aligned slices is generally regarded as the method to produce the least artifacts. However, for doing this efficiently, 3D textures are usually required <ref type="bibr" target="#b2">[3]</ref> which would require transferring the scalar field from the graphics card memory back to the application. This introduces significant latencies into the vortex detection system and, thus, is not appropriate for our application.</p><p>One work-around to this problem was proposed by Rezk-Salama et. al <ref type="bibr" target="#b17">[18]</ref> based on the work of Eckel <ref type="bibr" target="#b3">[4]</ref>. The basic idea is to determine the intersection polygons of viewport-aligned slices with the given stack of quadrilaterals and to interpolate color values on these polygons using the two neighboring textures. The original stack of quadrilaterals and the resulting intermediate slices are depicted in <ref type="figure" target="#fig_5">Fig. 4 (a)</ref> and (c), respectively.</p><p>A drawback of this approach is the large number of intersection polygons that have to be calculated each time the volume is rotated. Our implementation, therefore, employs a slightly different approach.</p><p>Instead of determining viewport-aligned intersection polygons onthe-fly, we pre-compute sets of intersection polygons from the X-and Y-direction (both positive and negative), respectively, and switch between them (and the original stack) depending on the orientation of the volume's bounding box to the viewer. <ref type="figure" target="#fig_5">Fig. 4 (b)</ref> shows the resulting slices.</p><p>This approach not only enables us to pre-calculate the intersection polygons but also to send the geometry data of the slices only once to the graphics adapter as a vertex buffer. If the original stack's slices are assumed to be equidistant, the amount of geometry stored in the vertex buffers can further be significantly reduced (by factors of I + 1 and J + 1, respectively) by storing only a single stack of stripes and rendering the remaining ones with a suitable translation applied. Thus, the approach is able to accelerate the visualization without taking a noteworthy amount of memory.</p><p>An isosurface is most efficiently extracted from the stack of slices by rendering the slices with all pixels within a user-defined interval around the isovalue set to opaque and the remaining pixels set to transparent. However, the resulting "surface" will have a uniform color which conceals its 3D structure. We have, therefore, integrated a lighting model into our system incorporating both ambient <ref type="figure">Figure 5</ref>: Two visualizations of the same vortex tubes. The left image was produced with the hardware-based approach using direct volume rendering, the right image using a commercial flow visualization tool using a Marching Cubes approach. <ref type="figure">Figure 6</ref>: λ 2 isosurfaces of the hurricane Isabel data set. The images in the upper row show the effect of successively decreasing the isovalue. As can be seen, the vortex structures gets narrower. The lower row images illustrate the effect of modifying the filter characteristics starting with the same base image. While both adjustments tend to remove small-scale vortex structures, it can be seen that filtering better preserves large vortex structures.</p><p>and diffuse. A full-featured Blinn-Phong model including specular lighting was rejected due to the computational costs (we found that the specular component is about as costly as the ambient and diffuse terms taken together) and the little additional insight that is obtained from highlights. This way, the rendering in Z-direction can be accomplished with one texture lookup and 15 arithmetic instruction slots, the rendering in X-and Y-direction with two texture lookups and 18 instruction slots.</p><p>The quality of the extracted isosurface strongly depends on the number of slices used for the visualization. This is inherent in all slice-based volume rendering techniques and no drawback of the approach chosen for this system. We have added the possibility to add intermediate slices interpolated between grid points to be able to trade more pleasing visualizations for reduced frame rates. <ref type="figure" target="#fig_6">Fig. 7</ref> shows the effect of adding intermediate slices for the data set depicted in <ref type="figure" target="#fig_3">Fig. 3</ref>. Although not all artifacts are removed, there is nevertheless a notable improvement in image quality. <ref type="figure">Fig. 5</ref> shows screenshots taken with our system (without adding intermediate slices) and screenshots taken with PowerVIZ, a commercial flow visualization tool <ref type="bibr" target="#b4">[5]</ref>. The data set used for these screenshots has 135 × 225 × 129 voxels and was obtained by DNS of K-type transition experiments <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b18">19]</ref>. PowerVIZ does not use volume rendering techniques for extracting the isosurface but instead extracts a polygonal representation using a Marching Cubes approach. As can be seen, the results are nevertheless very similar in general and only differ (visually) where the vortex tubes narrow and the number of slices over the profile is reduced.</p><p>The effects of modifying the filter characteristics and isovalues are depicted in <ref type="figure">Fig. 6</ref> at the example of a 251 × 251 × 100 data set of hurricane Isabel. As can be seen, the Gauss filtering (lower row) clearly highlights large-scale vortex structures while suppressing small vortices-a behavior that cannot be obtained by isovalue adjustments (upper row). <ref type="figure" target="#fig_2">Fig. 1</ref>, left, demonstrates the filtering at the example of a larger Ktype transition data set of 229 × 116 × 250 voxels extracted from a more turbulent zone. As can be seen, the characteristic Λ-vortices that are of particular interest to fluid dynamics researchers are much easier to spot in the filtered vector field than in the unfiltered field <ref type="figure" target="#fig_1">(Fig. 2, left)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Storage Requirements</head><p>Most GPU-based algorithms using fragments programs or pixel shaders for performing the calculations store the input data as textures. However, the amount of texture memory is quite limited and 256 MB must be considered very large at the moment. Memory efficiency is, therefore, a crucial topic in the evaluation of graphicshardware-accelerated implementations since it eventually defines an upper limit for the size of the input data sets.</p><p>Our system stores the raw input data in a 128 bit RGBA texture. This texture must not be modified since it is needed each time the filter characteristics are adjusted. To store the filtered results, another 128 bit floating point texture is required. This texture is reused for storing the gradients of the λ 2 scalar field required for lighting the isosurface. The remaining textures are independent of the size of the input data and of negligible size. Thus, if the input data comprises N nodes, about 32N byte memory are consumed by the system. Assuming 256 MB texture memory, this means that the system is applicable to data sets of at most eight million grid points or equivalently a cube of the dimensions 200 × 200 × 200. We consider this to be sufficient for data sets obtained experimentally.</p><p>However, both the filtering and the λ 2 vortex detection are local. Thus, if the system limits are surpassed, a bricking approach can be easily used to accommodate the system to larger data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance Evaluation</head><p>For evaluating the performance of the system the data set of <ref type="figure">Fig. 5</ref> of the dimensions 135×225×129 was visualized at a viewport size of 512 × 512 pixels on an ATI 9800 XT graphics adapter. Since the system is almost completely GPU-based, the configuration of the underlying PC/workstation is irrelevant for the benchmark.</p><p>We have found the filtering time to be about 147 ms for both the single-pass Gauss filter of support three and the multi-pass Gauss filter of support 11. Obviously, the reduced number of texture lookups required for the separable Gauss filter more than outweighs the overhead of two additional rendering passes. The λ 2 computation took 108 ms for the simplified root finding approach and 130 ms for the correct approach, the gradient calculation time was 14 ms. These times are independent of the number of intermediate slices and the direction from which the volume is looked at.</p><p>One the other hand, the rendering time depends strongly on the direction and the number of intermediate slices, therefore, we have measured rendering times for both the cheapest direction (Zdirection, original stack of slices) and the most expensive direction (Y-direction, stacks of pre-calculated stripes, largest of the three dimensions).</p><p>For the Z-direction we measured a visualization time of 38 ms (26.3 fps), for the Y-direction a time of 212 ms (4.7 fps). When adding one intermediate slice, the visualization times increase by a factor of two. As expected, the frame rates scale linearly with the amount of pixels generated by the application. No color mapping of velocity magnitudes was done for these measurements.</p><p>To judge the performance of a GPU-based algorithm, a comparison with an equally optimized software implementation is required. For this reason, we have also implemented the vortex detection algorithm proposed above on an Intel Pentium 4 processor. All the proposed optimizations like e.g. the usage of lookup tables for determining cosine values were included. Since the P4's SSE2 extension is capable of processing four-component vectors with 32 bit per components, macros for performing vector operations were implemented and used where possible. Unfortunately, there is no SSE2 instruction a dot product can be mapped to; thus, an instruction sequence had to be used instead 3 . We have chosen the sequence proposed by Breternitz et al. <ref type="bibr" target="#b0">[1]</ref>. Using this implementation, we measured 1,150 ms for the λ 2 vortex detection on the 135 × 225 × 129 data set-almost an order of magnitude slower compared to the hardware-based approach. As expected, PowerVIZ, a tool well-known for its generally good performance is even significantly slower (about 8 s) than the optimized software implementation. This must probably be ascribed to more complex internal data structures since PowerVIZ works on a hierarchy of Cartesian grids while our system requires a single Cartesian grid. Anyway, using an own optimized implementation for comparison is well justified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Application to CFD</head><p>An interactive cycle of filtering, vortex detection, and visualization is particularly useful for noisy data. For experimentally obtained datasets this is obviously the case. <ref type="figure" target="#fig_7">Fig. 8</ref> shows a data set obtained in an experiment studying laminar-turbulent boundary layer transitions <ref type="bibr" target="#b12">[13]</ref>.</p><p>For data sets obtained by computational fluid dynamics (CFD) the situation depends on the simulation technique. Turbulence models vary in how much modelling they contribute to the fluid flow simulation. At one end of the spectrum there is RANS (Reynolds Averaged Navier-Stokes) which models turbulence by essentially increasing the fluid viscosity. Increased viscosity leads to the elimination of small-scale structures through diffusion and dissipation. Thus, RANS simulations usually are only modestly vulnerable to noise. Turbulence modelling in LES (Large Eddy Simulation) also results in an increased computational viscosity in comparison with the molecular viscosity and accordingly also results in data sets with moderate noise.</p><p>On the contrary, DNS should capture all scales that are relevant in the flow without any modelling. Large Reynolds number flows typically mean small viscosity, and, particularly for turbulent flows, very small length scales. Thus, high grid resolutions are required for DNS. If insufficient resolution is available, the smallest scales will be determined by the numerics and not by the physics, which eventually results in noisy data.</p><p>Our system is, therefore, particularly suitable for environments where experimental <ref type="figure" target="#fig_7">(Fig. 8</ref>) or DNS data ( <ref type="figure" target="#fig_2">Fig. 1 and 3)</ref> are subject of analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>We have described a system for filtering, vortex detection, and visualization of flow data. By employing modern graphics hardware for performing the calculations instead of the CPU, we were able to improve the system performance by almost an order of magnitude. For the first time, the cycle of filtering, vortex detection, and visualization can be handled interactively using low-cost off-the-shelf hardware readily available at the desks of many researchers. The presented system has already been approved by engineers working in the field of fluid dynamics. Despite the fact that basically only several well-known techniques are combined into a single tool our collaborators have decided that the performance and effectiveness of our system well justify an integration into their workflow.</p><p>In the future, we plan to evaluate further local vortex detection algorithms and more advanced filters in terms of portability to graphics hardware. Furthermore, we intend to improve the volume rendering to be able to produce more pleasing visualizations for data sets with a low number of slices. Another attractive feature would be the tracking of features over several time-steps as it was presented in <ref type="bibr" target="#b21">[22]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>October 10 -</head><label>10</label><figDesc>15, Austin, Texas, USA IEEE Visualization 2004 0-7803-8788-0/04/$20.00 ©2004 IEEE</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Vortex structures extracted from unfiltered vector fields. The data sets are the same as those used inFig. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Pass 1 :</head><label>1</label><figDesc>Finding the Characteristic Polynomial The HLSL instruction set includes instructions for manipulating matrices and vectors. Formulating the λ 2 method in HLSL is therefore a trivial task:// Construct the Jacobian and its transposed jacobianT = float3x3(gradientX, gradientY, gradientZ); jacobian = transpose(jacobianT); // Determine the symmetric and antisymmetric parts symmetric = (jacobian + jacobianT)/2.0; antisymmetric = (jacobian -jacobianT)/2.0; // ... and the sum of their squares sum = mul(symmetric, symmetric) + mul(antisymmetric, antisymmetric);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>ax 3 +</head><label>3</label><figDesc>bx 2 + cx + d = 0 the method gives the three roots (eigenvalues in our case) α, β , and γ by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Comparison of the two root finding approaches. As can be seen at the large arch near the image center, the handling of two cases (bottom) removes some artifacts present when handling only one case (top). The colors denote the velocity magnitude.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Comparison of slab filling methods. (a) Original slices, (b) pre-calculated axis-aligned slices, (c) viewport-aligned slices calculated on-the-fly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Upper right section of the data set shown in Fig. 3 rendered with no intermediate slices (left) and five intermediate slices (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Visualizations of vortex structures in an experimentally obtained water channel data set with little filtering (upper image) and strong filtering (lower image).</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">This statement assumes orthogonal projection; with perspective projection the situation is better but still unacceptable.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">MMX allows the dot product to be mapped to two instructions using the PMADDWD instruction. However, each vector component then is confined to 16 bit which is unacceptable for this application.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are grateful to the German Research Council (DFG) for financing this work as part of SPP 1147, to Milosz Walter and Martin Schulz of science+computing AG for making available a prototype of PowerVIZ capable of calculating and visualizing λ 2 values, to the organizers of the IEEE Visualization 2004 contest for providing the hurricane dataset, and to Ulrich Rist and Mark Linnick of the Institute of Aerodynamics and Gasdynamics (IAG) of the University of Stuttgart for providing experimental and simulated flow data sets and for sharing their insights regarding the analysis of flow field structures.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Compilation, Architectural Support, and Evaluation of SIMD Graphics Pipeline Programs on a General-Purpose CPU</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Breternitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename><surname>Hum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Parallel Architectures and Compilation Techniques (PACT &apos;03)</title>
		<meeting>the 12th International Conference on Parallel Architectures and Compilation Techniques (PACT &apos;03)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="135" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Imaging vector fields using line integral convolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Leedom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;93</title>
		<meeting>SIGGRAPH &apos;93</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Accelerating volume reconstruction with 3D texture mapping hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Cullip</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Neumann</surname></persName>
		</author>
		<idno>TR93-027</idno>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, University of North Carolina, Chapel Hill</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">OpenGL Volumizer Programmer&apos;s Guide. Silicon Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Eckel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<pubPlace>Inc., Mountain View, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Exa Corporation. PowerVIZ specifications</title>
		<ptr target="http://www.exa.com/pdf/PowerVIZscreen.pdf" />
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hardwareaccelerated high-quality filtering on PC hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hadwiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Theußl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Vision, Modelling, and Visualization VMV &apos;01</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="105" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Accelerating 3D Convolution using Graphics Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;99</title>
		<meeting>IEEE Visualization &apos;99</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="471" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the identification of a vortex</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Hussain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Fluid Mechanics</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="page" from="69" to="94" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Detection and visualization of vortices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Machiraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization Handbook</title>
		<editor>C. Johnson and C. Hansen</editor>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Physical mechanisms of laminar-boundary-layer transition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">S</forename><surname>Kachanov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Fluid Mech</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="411" to="482" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Acceleration Techniques for GPUbased Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;03</title>
		<meeting>IEEE Visualization &apos;03</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="287" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Linear algebra operators for GPU implementation of numerical algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics (TOG)</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="908" to="916" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Investigations on Disturbance Amplification in a Laminar Separation Bubble by Means of LDA and PIV</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Rist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Symposium on Laser Techniques to Fluid Mechanics</title>
		<meeting>the 11th International Symposium on Laser Techniques to Fluid Mechanics</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Flow visualization using moving textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ICASW/LaRC Symposium on Visualizing Time-Varying Data</title>
		<meeting>the ICASW/LaRC Symposium on Visualizing Time-Varying Data</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Enhanced visualization of latestage transitional structures using vortex identification and automatic feature extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Rist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Fluid Dynamics</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="786" to="791" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A new approach to solving the cubic: Cardan&apos;s solution revealed</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W D</forename><surname>Nickalls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Mathematical Association</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="354" to="359" />
		</imprint>
	</monogr>
	<note>Mathematical Gazette</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vrolijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Laramee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
		<title level="m">Eurographics 2002 STAR -State of The Art Report Feature Extraction and Visualisation of Flow Fields</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Interactive Volume Rendering on Standard PC Graphics Hardware Using Multi-Textures and Multi-Stage-Rasterization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rezk-Salama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Greiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware Workshop</title>
		<imprint>
			<publisher>Addison-Wesley Publishing Company, Inc</publisher>
			<date type="published" when="2000" />
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Numerical and experimental investigation of the K-regime of boundary-layer transition. Laminar-Turbulent Transition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Rist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">S</forename><surname>Kachanov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="405" to="412" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A higher-order method for finding vortex core lines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;98</title>
		<editor>D. Ebert, H. Hagen, and H. Rushmeier</editor>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="143" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Nonlinear diffusion in graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Strzodka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings EG/IEEE TCVG Symposium on Visualization VisSym &apos;01</title>
		<meeting>EG/IEEE TCVG Symposium on Visualization VisSym &apos;01</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="75" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Tracking Scalar Features in Unstructured Datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;98</title>
		<meeting>IEEE Visualization &apos;98</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Resampling of Large Datasets for Industrial Flow Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Stegmaier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Vision, Modelling, and Visualization VMV &apos;03</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="375" to="382" />
		</imprint>
	</monogr>
	<note>infix</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Texture-Based Framework for Spacetime-Coherent Visualization of Time-Dependent Vector Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Erlebacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;03</title>
		<meeting>IEEE Visualization &apos;03</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficiently using Graphics Hardware in Volume Rendering Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;98</title>
		<meeting>SIGGRAPH &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="169" to="177" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
