<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rendering Planar Cuts Through Quadratic and Cubic Finite Elements</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Brasher</surname></persName>
							<email>mbrasher@mit.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Aerospace Computational Design Laboratory</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Haimes</surname></persName>
							<email>haimes@mit.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Aerospace Computational Design Laboratory</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Rendering Planar Cuts Through Quadratic and Cubic Finite Elements</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.1.8 [Numerical Analysis]: Partial Differential Equations-Finite Element Methods</term>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation-Line and curve generation</term>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Color, Shading, Shadowing, and Texture</term>
					<term>Higher Order Elements, Programmable Shaders, Cutplanes</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Coloring higher order scientific data is problematic using standard linear methods as found in OpenGL. The visual results are inaccurate when there is a large scalar gradient over an element or when the scalar field is nonlinear. In addition to shading nonlinear data, fast and accurate rendering of planar cuts through parametric elements can be implemented using programmable shaders on current graphics hardware. The intersection of a planar cut with geometrically curved volume elements can be rendered using a combination of selective refinement and programmable shaders. This hybrid algorithm also handles curved 2D planar triangles.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Numerical methods are widely used throughout academia and industry to solve physical problems when experimental data is difficult to obtain. The details of these methods can vary greatly, but they all essentially solve a set of governing equations by discretizing the domain of interest and solving an analogous formulation at the discrete points or nodes. Once a solution has been generated for these nodes, then data over the entire domain can be obtained by interpolation. The simplest way to interpolate is to assume linearity within each cell based on the vertices that support that element. There are a number of ways available to then view this data, since most visualization techniques are based on the assumption of linear interpolation. However, there are many situations in which it is advantageous to solve the discrete equations using a non-linear basis or higher order elements <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b9">10]</ref>. This can mean using anything from the polynomial Lagrange basis to a hierarchical basis or spectral elements. One obvious difficulty with using higher order numerical methods is that there is no simple way to visualize the data in its native form (since most current visualization software uses a linear basis). This renders higher order methods much less useful. Understanding of numerical results and new insight is often only possible when one can accurately visualize the massive amounts of data produced.</p><p>Accurate rendering of nonlinear data cannot be performed efficiently using only the standard OpenGL API, since all OpenGL primitives are inherently linear. Higher order data can be interpolated and rendered quite simply and quickly by utilizing the flexibil-ity of modern graphical processing units (GPUs). In addition to rendering surfaces, one important technique used in scientific visualization is the generation planar cuts through 3D field data. This can be accomplished through a combination of selective refinement of the elements and accessing programmable shaders inside the GPU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PREVIOUS WORK</head><p>3D graphics APIs like OpenGL are designed to use planar primitives because of the simplicity of the resulting algorithms. This ability to render linear elements can be leveraged to visualize nonlinear surfaces through polygonization, which essentially translates the higher order surface into one that is piecewise linear. This method was used in <ref type="bibr" target="#b0">[1]</ref> to render parametric surfaces, while an adaptive refinement method was used in <ref type="bibr" target="#b10">[11]</ref> to subdivide implicit surfaces. This was then generalized to handle both implicit and parametric surfaces with a multi-resolution hierarchical structure in <ref type="bibr" target="#b11">[12]</ref>. These methods are able to sample the higher order data in way that can be handled by traditional visualization algorithms (i.e. at the end linear elements are produced).</p><p>A hierarchical approach was also used by <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b12">[13]</ref> in the direct visualization of higher order data. In <ref type="bibr" target="#b12">[13]</ref>, volume visualization was accomplished by ray casting through both straight-edged and curved quadratic elements. Isosurface extraction was performed by approximating the surface by quadratic patches in parameter space, transforming them to physical space, and rendering the resulting quartic functions through higher order patch rendering in hardware. Texture shaders and register combiners were used in <ref type="bibr" target="#b6">[7]</ref> to visualize higher order hexahedra. The hardware limitations of using texture shaders and register combiners can be avoided by instead using a fully programmable shading language like Cg <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DISCONTINUOUS FEM</head><p>One popular group of numerical techniques, the Finite Element Methods (FEM), are particularly convenient when dealing with complex geometries or unstructured computational meshes <ref type="bibr" target="#b9">[10]</ref>. FEM simplifies the solution scheme by mapping every element in the mesh to a master reference element, and then scalar interpolation can be performed using shape functions as a basis. Regardless of the basis used in the computational solver, the data can be easily converted to any other basis of the same order, so only the Lagrange basis will be discussed. Furthermore, only simplicial elements will be considered.</p><p>When rendering continuous data, neighboring elements share both the location and field data of common nodes. The use of collected primitives (polytriangles, quad meshes and etc.) can speed up the display time since the support data needs to be passed along the graphics pipeline fewer times. However, the direct goal of this research was to visualize flow solutions generated using the Discontinuous Galerkin (DG) method <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b1">[2]</ref>. As such, any scheme developed should be able to naturally handle discontinuities (at element faces) in the scalar fields being visualized. The simplest way to accomplish this is for each element to independently store data October 10-15, Austin, Texas, USA IEEE Visualization 2004 0-7803-8788-0/04/$20.00 ©2004 IEEE for all of its basis nodes, similar to <ref type="bibr" target="#b7">[8]</ref>. Even though the physical location of shared nodes is the same between neighboring elements, nodes must be respecified for each element in which they appear. The goal is to have a method that allows for easy handling of both continuous and discontinuous data with the acknowledgement that there will be some lose of the speed benefits in comparison to the use of collected primitives for continuous data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Reference Element Interpolation</head><p>In general, a triangular element T has a scalar interpolant of order p and q degrees of geometrical freedom. The degrees of freedom determine if and how the sides of T are curved, and the order of interpolation determines how many nodal values of the scalar function are needed to specify the interpolant. For example, a p 3 q 2 triangle would have a cubic polynomial scalar interpolant and quadratic geometry.</p><p>Using the Lagrange basis, every element in the mesh can be mapped to a reference element. The reference coordinates,x, are aligned so that the component x i is 1 at vertex i of the reference element and 0 at all other vertices. Note that there are 3 reference coordinates in 2D and 4 reference coordinates in 3D. The extra degree of freedom is removed by requiring that the coordinates identically sum to 1, i.e. ∑ i x i = 1. The nodal shape functions f i are defined so that at each node n j :</p><formula xml:id="formula_0">f i (n j ) = 1 if i = j 0 if i = j<label>(1)</label></formula><p>Given a scalar function with nodal values s i at node n i , the value of the scalar interpolant s(x) at a pointx is given by:</p><formula xml:id="formula_1">s(x) = ∑ i s i f i (x)<label>(2)</label></formula><p>It is convenient to scale the nodal values so that the scalar interpolant is contained in s ∈  In addition to nonlinear scalar data, the geometry of the element can be curved. Only the coordinates of each node in physical space, p i = {x i , y i , z i }, need to be specified, and then the geometry of the element is interpolated in the same manner as the scalar field using eq. 2. As a matter of practice in computational meshes, there will be q &gt; 1 elements conforming to the curved boundaries and linear q = 1 elements on straight boundaries and in the interior. At times q &gt; 1 interior elements may be seen when there is a stretched mesh near a curved boundary. This ensures positive volumes and wellbehaved interpolation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Dimensional Hierarchy</head><p>Given physical coordinates at the nodal points, the p x reference elements map to some curved region in physical space, called a p x tetrahedron in 3D, a p x triangle in 2D, and a p x line in 1D. The four faces of a p x tetrahedron can be mapped to the 2D reference element, so each face can be described as a p x triangle. Similarly, the three edges of a p x triangle can be described as a p x line. Thus the simplicial elements form a dimensional hierarchy where a p x simplex of dimension n contains p x simplices of dimension n − 1. This concept of a dimensional hierarchy is not restricted to the faces and edges. Any planar polygon in the 3D reference space can be triangulated into curved triangles, and any line segment in the 2D reference space can be described as a higher order line. However, not all curved regions can be described as a p x line, triangle, or tetrahedron. Any nonlinearity in the reference space will be compounded in the mapping, and the resulting interpolation will not be p x .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SHADING PARAMETRIC ELEMENTS</head><p>In order to visualize a parametric element with scalar values, s i , at each node, eq. 2 must be implemented in some manner. OpenGL alone can only do this by refining the triangle or generating a texture map. Both of these methods become extremely slow as the number of triangles increases. An alternative is to use the programmability in the GPU exposed by graphics languages like Cg. This is where great performance gains can be obtained. The GPU can inherently use the parallelism in these operations because the rasterization phase generates a pixel at a time (with no dependence on neighboring pixels). The processor can parcel out each pixel in the fragment to the number of raster engines available in the specific graphics hardware.</p><p>Eq. 2 can be implemented in a fragment shader by defining texture coordinates at each vertex as the vertex's position in reference space,x, and then evaluating the shape functions in the fragment shader. The results of this shader on one triangle is shown in <ref type="figure">fig. 2</ref>. Figs. 2, 3, and 4 show the results for the p 2 , p 3 , and p 4 shaders respectively. Note that Gouraud coloring would produce a constant color triangle for each case.</p><p>Because Gouraud shading interpolates in color space, coloring artifacts are seen when using the traditional OpenGL pipeline to render triangles with large gradients. This problem is avoided in the fragment shader because full scalar interpolation (even for p 1 ) is performed and the color applied as a last step via the colormap data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Performance</head><p>Evaluating the p 2 interpolation in the fragment shader involves more work than standard Gouraud shading. But as the number of vertices in the scene increases, the cost of transforming the vertices (which in most cases cannot run in parallel) overwhelms the extra cost of the fragment shader. As shown in <ref type="figure" target="#fig_3">fig. 5</ref>, when drawing 4050 triangles, Gouraud shading is 4 times faster than p 2 interpolation done in a programmable shader, but when the number of triangles is increased to 129600, Gouraud shading is only slightly faster than Cg. When drawing 4050 triangles, 1 level of refinement is faster than the Cg. When drawing more triangles however, the programmable shader is faster than 1 level of refinement and orders of magnitude faster than higher levels of refinement. Considering that programmable shaders are as accurate as refining to the pixel level, it is clear that programmable shaders represent a significant improvement in visual accuracy while running at nearly the same speed as standard linear shading. This is the compelling argument for the customized use of GPUs in handing non-linear interpolation. Note: the run times were generated on a P4 2.53 GHz processor with 1Gb of memory and an nVidia GeForceFX 5800 ultra graphics card running under LINUX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CUTPLANE INTERSECTION</head><p>Consider the analytical description of the intersection of a plane cutting through a geometrically curved q 2 or q 3 parametric domain. This intersection is the union of intersections with each individual element, so the problem can be simplified to finding the cutplane intersection with a single element. The discussion will focus on q 2 and q 3 elements, but the method extends naturally to higher orders of parametric elements.</p><p>A convenient way to describe the cutplane is by some point p 0 on the plane and the normal to the plane n. Then, the signed distance d of any point p to the plane is given by</p><formula xml:id="formula_2">d = (p − p 0 ) • n<label>(3)</label></formula><p>The distance d i from the nodal points to the cutplane is calculated, and this distance can then be interpolated at any point. Thus, the intersection of the surface and the plane is the locus of pointsx that satisfy the equation d(x) = 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Selective Refinement</head><p>In order to accurately visualize nonlinear data, the interpolation must be sampled at some set of discrete points. Since the intersection can be described implicitly, it could be polygonized using the method of <ref type="bibr" target="#b10">[11]</ref>. While this technique accurately samples a general implicit surface, it does not take advantage of the fact that the intersection is planar. The simplest approach is uniform refinement (UR), which homogeneously subdivides the q 2 element, and then treats subelements as linear by passing them to the standard marching cubes algorithm <ref type="bibr" target="#b8">[9]</ref>. However, as suggested by <ref type="bibr" target="#b4">[5]</ref>, this can be improved upon given an element T with nodal values s i , since the scalar field can be bounded. Start by defining:</p><formula xml:id="formula_3">s min = min i s i s − = 1 2 (s max − s min ) s max = max i s i s + = 1 2 (s max + s min )<label>(4)</label></formula><p>then</p><formula xml:id="formula_4">s(x) − s + = ∑ i s i − s + f i (x) ≤ ∑ i s max − s + f i (x) = s − ∑ i f i (x) ≤ s − max x∈T ∑ i f i (x)</formula><p>taking absolute values</p><formula xml:id="formula_5">s(x) − s + ≤ s − max x∈T ∑ i f i (x) ≤ s − max x∈T ∑ i f i (x)<label>(5)</label></formula><p>and noting that for the 3D q 2 shape functions, max</p><p>x∈T ∑</p><formula xml:id="formula_6">i f i (x) = 2<label>(6)</label></formula><p>which leads to the bounds</p><formula xml:id="formula_7">s min − s − ≤ s(x) ≤ s max + s − , ∀x ∈ T<label>(7)</label></formula><p>For the 3D q 3 shape functions, max</p><p>x∈T</p><formula xml:id="formula_8">∑ i f i (x) = 16 + 5 √ 5 9 ≤ 3.021<label>(8)</label></formula><p>which leads to the bounds</p><formula xml:id="formula_9">s min − 2.021s − ≤ s(x) ≤ s max + 2.021s − , ∀x ∈ T<label>(9)</label></formula><p>The cutplane M will intersect T if d(x) = 0 at some pointx inside the element. If 0 lies outside the bounds, then T is not intersected, but since the bounds of eqs. 7 and 9 are not tight, T is not necessarily intersected just because 0 is inside the bounds. Still, whether or not d = 0 lies outside the bounds can be used as an effective criterion to reject or further refine in a linear selective refinement (LSR) scheme, which treats the final subelements as linear just as in UR. LSR is a more efficient algorithm, since it refines coarsely away from the intersection, and thus handles many fewer subelements. By themselves, eqs. 7 and 9 only dictate whether the element should be refined, they do not specify how. The simplest method is to break the element into equal pieces, and then reapply the bounds to the subelements. However, a more sophisticated adaptive refinement algorithm that seeks to refine where the gradients in the scalar field are highest <ref type="bibr" target="#b5">[6]</ref> could be applied.</p><p>Even this algorithm is problematic, since the rendering time of LSR is O(V ) where V is the total number of vertices that are sent through the graphics pipeline. In order to achieve visual accuracy the refinement must be taken to essentially the pixel level as can be inferred from the simpler results seen in <ref type="figure" target="#fig_3">fig. 5</ref>. An alternative is to utilize the parallel nature of current graphics hardware by performing the necessary data sampling in the programmable shaders. This allows the nonlinear data to be resolved to the pixel level while sending much less data down the pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">SHADOW METHOD FOR CUTPLANE RENDERING</head><p>Though there is a great deal of flexibility when dealing with individual fragments through it Cg, OpenGL is still constrained in the construction of geometry. All pixels passed to the fragment program are a result of the rasterization of a planar primitive. Let such a linear primitive which lies in M and which will completely cover the intersection I be the shadow of the intersection. The two main questions to answer are how to generate a shadow and how to shade the fragments in the shadow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Determining The Shadow</head><p>The shadow primitive should completely cover the intersection so that there are no gaps seen in the final image. Finding a reasonably small shadow is more important than finding the absolute minimal area. The result of too large a shadow is that many pixels will be discarded, which entails additional work in the GPU. The additional effort of finding a smaller shadow must be balanced with the benefit of sending fewer fragments through the GPU's pipeline.</p><formula xml:id="formula_10">f i r i c i i Figure 6: q 2 Orthographic View f i r i c i d i p i j i Figure 7: q 2 Side View</formula><p>To generate the shadow, the curved element is first bounded with a congruent q 1 tetrahedron C. Call the linear tetrahedron defined by the four main vertices of the element the reduced tetrahedron R. Each face of C will be parallel to R, as shown in <ref type="figure">fig. 6 and fig. 7</ref>. For each main node i of the element, the opposite face is f i , the corresponding face of the reduced tetrahedron is r i , and the parallel face of the congruent tetrahedron is c i . C can then be described by the distance d i that each c i is offset from each r i , as shown in <ref type="figure">fig. 7</ref>. If d i ≥ 0, then C always completely contains R. Finding the minimal values of d i would require solving:</p><formula xml:id="formula_11">d i = max x∈ f i p i (x) such that d(x) = 0<label>(10)</label></formula><p>where p i (x) is the projected distance of f i (x) to r i , and d(x) = 0 constrainsx to M. Finding this maximum value of p i is possible, since it is just a constrained optimization problem, but it requires having the parameterization of d(x) = 0 and is not worth the effort. To simplify the process, remove the restriction that d(x) = 0, and try to ensure that c i lies outside the entire curved face f i . Let a i and b i be disjoint sets of nodes, where the main nodes of r i are in a i and the other nodes on f i are in b i . For a q 2 element, b i is just the set of mid-edge nodes on f i , and for a q 3 element, b i is the set of the 6 mid-edge nodes and the center node. Also, p i j = 0 for j ∈ a i since the projected distance to a plane of the three points that define that plane is zero. Let:</p><formula xml:id="formula_12">p max = max(max j∈b i p i j , 0)<label>(11)</label></formula><p>then p i can be bounded by:</p><formula xml:id="formula_13">p i ≤ max x∈ f i p i (x) = max x∈ f i ∑ j p i j f j (x) ≤ p max max x∈ f i ∑ j∈b i f j (x)<label>(12)</label></formula><p>for a 2D q 2 triangle:</p><formula xml:id="formula_14">max x∈ f i ∑ j∈b i f j (x) = 4 3<label>(13)</label></formula><p>yielding:</p><formula xml:id="formula_15">p i (x) ≤ 4 3 p max = d i (14)</formula><p>This provides a quick way to size the congruent tetrahedron while retaining the property that C contains the entire cutplane intersection, since the bound on d i in eq. 14 ensures that c i will at worst be tangent to f i . Now, after the congruent tetrahedron is found for a particular curved element, the standard linear cutplane algorithm is applied to C to determine the shadow primitive. One problem with this approach is that it can sometimes generate a shadow for an element that does not intersect M (e.g. C has one corner clipped by the cutplane). This could be avoided by refining the element and reapplying eq. 7, but these empty shadows are not a problem in practice.</p><p>Generating the congruent tetrahedron for a q 3 element is more complicated, but essentially the same process. A face of a q 2 tetrahedron can only be purely concave or convex, while it is possible for the curvature of a q 3 face to have an inflection point or curve. A q 3 face can be classified into one of three groups based on the signs of the p i j :</p><p>• Mixed: ∃ j, k ∈ b i such that p i j &gt; 0 and p i k &lt; 0</p><formula xml:id="formula_16">• Nonnegative: p i j ≥ 0, ∀ j ∈ b i</formula><p>• Nonpositive: p i j ≤ 0, ∀ j ∈ b i Define for a q 3 face:</p><formula xml:id="formula_17">p min = min j∈b i p i j p * max = max j∈b i p i j p ′ max = max( max j∈b i , j =9 p i j , 0)<label>(15)</label></formula><p>For a mixed q 3 triangle: </p><formula xml:id="formula_18">max x∈ f i ∑ j∈b i f j (x) =</formula><p>Call a q 3 face nonnegative if all of the p i j ≥ 0. This does not imply that p i (x) &gt; 0 everywhere, and such a face can be either convex or inflected. For a nonnegative q 3 triangle:</p><formula xml:id="formula_20">max x∈ f i ∑ j∈b i f j (x) = 9 8<label>(18)</label></formula><p>This maximum value occurs at the middle of each edge, that is the 3 points symmetric with:x</p><formula xml:id="formula_21">= 1 2 , 1 2 , 0<label>(19)</label></formula><p>The bound in eq. 18 can be improved in one special case, when the projected distance of the center node ( j = 9) is greater than eq. 18 applied to the other nodes in b i :</p><formula xml:id="formula_22">p i 9 ≥ 9 8 p ′ max<label>(20)</label></formula><p>which implies:</p><formula xml:id="formula_23">p i (x) ≤ p i 9 (21)</formula><p>Call a q 3 face nonpositive if all the p i j ≤ 0. Unlike a q 2 face, this face is not necessarily purely concave. Even if no p i j is positive, p i can still extend past r i . Bounding the maximum value of p i is a little different for a nonpositive face, since a term p i j f j in the interpolation will only be positive if f j &lt; 0. Therefore define H to be a step function:</p><formula xml:id="formula_24">H(x) = 0 if x ≥ 0 x if x &lt; 0<label>(22)</label></formula><p>Thus,</p><formula xml:id="formula_25">p i ≤ max x∈ f i p i (x) = max x∈ f i 9 ∑ j=0 p i j f j (x) ≤ max x∈ f i ∑ j∈b i p min H f j (x) = p min min x∈ f i ∑ j∈b i H f j (x)<label>(23)</label></formula><p>For a q 3 face:</p><formula xml:id="formula_26">min x∈ f i ∑ j∈b i H f j (x) = 20 − 14 √ 7 27 &gt; −0.632<label>(24)</label></formula><p>This minimum value occurs at the 3 points symmetric with:</p><formula xml:id="formula_27">x = 4 − √ 7 9 , 4 − √ 7 9 , 1 + 2 √ 7 9</formula><p>≈ (0.15, 0.15, 0.7)</p><p>Combining eq. 24 with eqs. 16, 18 and 21 suggests the following logic to compute d i for a general q 3 element:</p><formula xml:id="formula_29">d i =      2.128p * max if p min &lt; 0, p max &gt; 0 (Mixed) −0.632p min if p min &lt; 0, p max = 0 (Nonpositive) 1.125p max if p min ≥ 0, p i 9 &lt; p ′ max (Nonnegative) p i 9 if p min ≥ 0, p i 9 ≥ p ′ max (Nonnegative)<label>(26)</label></formula><p>The bound for a mixed q 3 element is relatively loose when compared to the bound for a nonnegative element. Also, a purely concave face would be contained by d i = 0, as is the case for a q 2 element, but the nonpositive bound in eq. 26 will set d i as some positive value. However, q 3 elements are used in a mesh to conform to the curved boundaries of the computational domain, and it is beneficial for the flow solver for these curved boundaries to be well resolved. As a matter of practice, very few of the elements (if any) in a computational grid will be mixed or inflected. In fact, most will be purely concave or convex, and the looser bounds for the mixed elements and nonpositive elements will not be necessary. Assuming that all the elements in a q 3 mesh are either purely concave or convex, this suggests the following logic to compute d i for a q 3 element:</p><formula xml:id="formula_30">d i =    0 if p min &lt; 0, p max = 0 (Concave) 1.125p max if p min ≥ 0, p i 9 &lt; p ′ max (Convex) p i 9 if p min ≥ 0, p i 9 ≥ p ′ max (Convex)<label>(27)</label></formula><p>6.2 Fragment Shading: Newton-Raphson Inversion</p><p>Once the shadow is sent down the graphics pipeline, how are the fragments shaded? Two questions must be answered:</p><p>1. Should the fragment be rejected (i.e. is it outside the element)?</p><p>2. How is the fragment colored if it is inside the element?</p><p>Both of these questions can be answered if the reference coordinatesx of the pixel to be rendered are known. The position is in the element ifx ≥ 0, and then eq. 2 can be implemented in the fragment shader. The reference coordinates will vary nonlinearly in physical space therefore they can be determined using a Newton-Raphson (NR) inversion algorithm. At each pixel, the physical coordinatesx p are known, since that's what determines the fragment's location via the modelview transformation. For any reference coordinate guess,x i , the position can be updated using:x</p><formula xml:id="formula_31">i+1 =x i + ¶x ¶x x i x p −x(x i )<label>(28)</label></formula><p>where</p><formula xml:id="formula_32">¶x ¶x = ¶x ¶x −1 and ¶x ¶x x i = ∑ jx j ¶f ¶x x i (29)</formula><p>While this is fairly straightforward, the standard OpenGL shading just linearly interpolates color values, so the NR algorithm does represent a significantly larger workload per pixel. However, the only straightforward way to pass nonlinear data through the OpenGL pipeline is through texture maps. Texture maps are are prohibitively expensive to generate for each element, and the additional work of the fragment shader is small by comparison.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Rendering Results</head><p>The shadow method is able to render curved planar cut intersections that are topologically similar to linear cutplane intersections. <ref type="figure">Fig. 8</ref> shows a triangular cut, where the p 2 tetrahedral element is outlined in black, the congruent tetrahedron is outlined in blue, and the shadow is shown in green and red. Those pixels that are in the cutplane intersection are shaded in green, and the pixels that lie outside the element are shown in red. The figure is shaded to highlight the fact that a linear primitive (the shadow) can be used to render a nonlinear intersection. In a visualization application, the pixels in the shadow outside the element would be discarded by setting their opacity to zero, and the actual intersection would be shaded as in <ref type="figure">fig. 9</ref>. In addition to the two linear cutplane intersections (triangle or quadrilateral), higher order elements can intersect a plane in complicated ways. The shadow algorithm is easily able to capture multiple distinct intersections as shown in <ref type="figure" target="#fig_1">fig. 10</ref>, and intersections that cut a face without touching an edge as shown in <ref type="figure" target="#fig_1">fig. 11</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Hybrid Selective Refinement</head><p>The majority of cutplane intersections will resemble <ref type="figure">fig. 8</ref>, with relatively few pixels in the fragment being discarded. But in examples like <ref type="figure" target="#fig_1">fig. 10 and fig. 11</ref>, a significant portion of the shadow is eventually thrown away. This extra computational burden can be lessened by using eq. 7 or 9 to selectively refine the element, and then applying the shadow algorithm to each subelement. As shown in figs. 12 through 14, this hybrid selective refinement (HSR) algorithm correctly renders the cutplane intersection while requiring much less refinement than LSR would to produce the same level of accuracy. Also notice that there is some amount of overlap between the shadows, but the reduction in excess fragments more than makes up for this redundancy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">HSR for 2D data</head><p>All elements found in the solution from a 2D flow solver can be thought of as occupying a single plane in 3D space. A shadow that lies in that plane can bound the 2D curved element. This shadow primitive will be a linear triangle C that is congruent to the reduced order triangle R of the element, as shown in <ref type="figure" target="#fig_1">fig. 15</ref>. This is an extension of the method described in sec. 6.4 where the main difference when visualizing 2D data is in computing the bounds of the element. The maximum value of p i (x) for a q 2 triangle face always lies at the midpoint. As with sizing the congruent tetrahedron for a 3D tetrahedral q 3 element, the bounds used for a general 2D triangular q 3 element are looser than those actually necessary for elements used in a computational mesh. The bounds for sizing of d i for a general element are:</p><formula xml:id="formula_33">d i =    1.3p * max if p min &lt; 0, p max &gt; 0 (Mixed) −0.316p min if p min &lt; 0, p max = 0 (Nonpositive) 1.125p max if p min ≥ 0 (Nonnegative)<label>(30)</label></formula><p>For a q 3 mesh, assuming that the edge is either concave or convex, using:</p><formula xml:id="formula_34">d i = 0 if p min &lt; 0, p max = 0 (Concave) 1.125p max if p min ≥ 0 (Convex)<label>(31)</label></formula><p>will ensure that C completely covers R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">APPLICATION TO FLOW SOLUTIONS</head><p>The method used to intersect finite elements with planar cuts described in previous sections was developed with the goal of visualizing flow solutions on unstructured grids in both 2D and 3D. This effort supports the work of Project X <ref type="bibr" target="#b3">[4]</ref>. The 2D code solves the Euler equations and the Navier-Stokes equations, while the 3D code is currently only inviscid. The equations are discretized using DG methods and solved using p multigrid with line smoothing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">2D Viscous Navier-Stokes</head><p>The approach to solving the Navier-Stokes equations is the same as the method to solve the Euler equations, except that the line smoothing is modified to account for viscous diffusion in addition to convection. The flow around a NACA0012 airfoil at 0 • angle of attack was solved using a grid containing 2264 p 1 q 1 triangles in the interior and the farfield, and 40 p 1 q 3 triangles on the airfoil. <ref type="figure" target="#fig_1">Fig. 16</ref> shows the Mach number distribution, which clearly show both the viscous boundary layer and the trailing wake. <ref type="figure" target="#fig_1">Fig. 17</ref> shows a close 1.163E-05</p><p>3.042E-01</p><p>6.084E-01  <ref type="figure" target="#fig_1">fig. 18</ref> shows the shadow pixels and outlines the elements. <ref type="figure" target="#fig_1">Fig. 19</ref> shows an extreme close-up of just two elements, which are fairly curved. Even at this size, the curvature of the element is preserved. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">3D Inviscid Euler</head><p>The application of the 3D code is to a straight NACA0012 wing with a span of 5 chord lengths. The grid used was generated from a 2D airfoil grid, which was then extrapolated into 3D. This produced a tetrahedral mesh consisting of 91936 p 2 q 1 interior and farfield elements and 3536 p 2 q 3 boundary elements around the wing. The Mach Number distribution is shown along the surface of the wing in <ref type="figure" target="#fig_8">fig. 20</ref>. Since the grid is fairly well refined around the airfoil, no enhancement was necessary to approximate the shape, though the depth and lighting were modified at each pixel in the fragment program to better approximate the curved shape. The farfield boundary forms a dome around the wing, as seen in <ref type="figure" target="#fig_1">fig. 21</ref>. <ref type="figure">Fig. 22</ref> also shows the position of the cutplane.</p><p>The vast majority of the elements in the grid are q 1 , so the standard marching cubes algorithm handles intersection. However, all the elements that either have a face or an edge on the wing surface are q 3 , so that they can accurately conform to the airfoil shape. The cuts through these elements were rendered using the shadow method of sec. 6, using eq. 27 to generate the shadows. The curvature at the wingtip is best handled with 1 level of selective refinement, so this was used throughout. The cutplane position in <ref type="figure">fig. 22</ref> was used to generate the following Mach cut in <ref type="figure" target="#fig_9">fig. 23</ref>  To provide a better sense of the element size involved, <ref type="figure">fig. 24</ref> shows the outline of all the q 3 elements that were cut at the position shown in <ref type="figure">fig. 22</ref>. <ref type="figure" target="#fig_3">Figs. 25 and 26</ref> show the cutplane through the leading edge, with all the shadow pixels shown in pink. Notice that there is some overlap of the shadow primitives, but since these pixels normally get rejected, this is never noticed by the viewer. <ref type="figure" target="#fig_10">Fig. 27</ref> shows the wingtip, with the cutplane at 3 locations approaching the tip. These cutplane positions were used to generate images through the Mach field and are displayed in <ref type="figure">fig. 28</ref>. This shows that the cutplane shadow method is able to correctly render the planar intersection for even the fairly curved elements at the wingtip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">EXTENSION TO ISOSURFACES</head><p>The discussion so far has focused on rendering planar cut intersections, and not on visualizing isosurfaces. The algorithms to render each type of intersection for linear elements are the same, and indeed, the LSR algorithm should work for isosurfaces. The crucial difference is that isosurface will not, in general, be planar. However, it may be possible to render the isosurface with scalar value, s * , by bounding it with linear primitives. Based on screen position, x s , of each pixel on the bounding shadow, the depth is adjusted until the point on the isosurface, x, is found such that x s lies on top of x (i.e. x and x s have the same screen coordinates but different depths). To find x, |s − s * | is first minimized by performing a search of points inside the element that lie beneath x s , then Performing this search would be relatively expensive, so acceptable values of s will lie close to s * within some bounds set by the accuracy of the search. Under some viewing transforms, the isosurface can curve behind itself, which means there can be multiple solutions, x, that all lie on top of x s . In this case, the several solutions should be compared using the depth test to determine which one is displayed.</p><p>The faces of the congruent tetrahedron used to generate the cutplane shadow would certainly cover the isosurface intersection, since it captures the entire element by design. But using those triangles could produce many extraneous fragments. This could be alleviated by combining the view-based refinement used in <ref type="bibr" target="#b6">[7]</ref> and the selective refinement of HSR to approximate the isosurface intersection. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>Subdivision algorithms generate exponentially more subelements as the refinement level is increased, and their performance is directly tied to the number of vertices being processed. Programmable shaders leverage the flexibility of modern GPUs to efficiently sample higher order data at each pixel in a powerful manner. Visualizing planar cuts through parametric FEM elements simplifies to knowing the reference coordinates at each pixel, and having the ability to use that information to correctly render the scalar field. The major obstacle is the limitation of having to use planar primitives to generate pixels for the fragment shader. To overcome this challenge, the HSR algorithm bounds the curved intersection with a shadow primitive, which can then be manipulated in the GPU. Some pixels will inevitably be discarded, and to minimize this wasted effort, very coarse selective refinement can be used to generate several shadow primitives that collectively cover the entire intersection. Thus the HSR algorithm provides an efficient and functional method to produce and shade planar cuts through higher order FEM data.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>[0,<ref type="bibr" target="#b0">1]</ref>. Once the value of the scalar interpolant is found at a point, the color at that point is defined by some arbitrary colormap. One standard choice of a colormap is the spectral colormap shown infig. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Spectral Colormap</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 : p 2 Figure 3 : p 3 Figure 4 : p 4</head><label>223344</label><figDesc>Shader Shader Shader</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Performance of p 2 Interpolation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :Figure 9 :Figure 10 :</head><label>8910</label><figDesc>Triangular p 2 Cut w/ Shadow Triangular p 2 Cut Shaded Multiple p 2 Cuts Figure 11: Face Only p 2 Cut</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 12 :Figure 13 :</head><label>1213</label><figDesc>One Hybrid Refinement Two Hybrid Refinements Figure 14: Three Hybrid Refinements Figure 15: Congruent Shadow Triangle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 16 :</head><label>16</label><figDesc>NACA0012 Airfoil Mach Distribution view of the leading edge, while</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 17: NACA0012 Airfoil Curve Figure 18: NACA0012 Airfoil Shadows Figure 19: Two Element Shadows</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 20 :</head><label>20</label><figDesc>NACA0012 Wing Mach Distribution Figure 21: Farfield Boundary Figure 22: Cutplane Position</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 23 :</head><label>23</label><figDesc>Cutplane Through Mach FieldFigure 24: NACA0012 Wing Boundary Elements Figure 25: NACA0012 Leading Edge Figure 26: A Few Element Shadows the fragment can rejected or drawn based on whether or not s = s * .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 27 :</head><label>27</label><figDesc>Cutplane Position at Wingtip Figure 28: Cutplane Through Mach Field at Wingtip</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The work presented here was partially funded by NASA grant NAG8-1872 (Suzanne Dorney, technical monitor). Thanks to Krzysztof Fidkowski and Todd Oliver for providing the grids and solutions used in this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A fast algorithm for rendering parametric surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">H</forename><surname>Clark</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Computer Science Press, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Runge-kutta discontinuous galerkin methods for convection-dominated problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernardo</forename><surname>Cockburn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chi-Wang</forename><surname>Shu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Scientific Computing</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="173" to="261" />
			<date type="published" when="2001-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The Cg Tutorial: The Definitive Guide to Programmable Real-Time Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randima</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">J</forename><surname>Kilgard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Boston, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Development of a higher order solver for aerodynamic applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krzysztof</forename><surname>Fidkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Darmofal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">42nd AIAA Aerospace Sciences Meeting and Exhibit</title>
		<imprint>
			<publisher>AIAA</publisher>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Personal Correspondence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Giles</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Multiresolution visualization of higher order adaptive finite element simulations. Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Haasdonk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ohlberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rumpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Seibert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-06" />
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="181" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rendering higher order finite element surfaces in hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Khardekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer graphics and interactive techniques in Austalasia and South East Asia</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Discontinuous finite element visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">O</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paola</forename><surname>Marzano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Gobbetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRS4 Bulletin 1998. CRS4, Center for Advanced Studies</title>
		<meeting><address><addrLine>Sardinia, Cagliari, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proceedings of SIGGRAPH)</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Higher-Order Finite Element Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Solin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Segeth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Dolezel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>CRCPress</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Simple and efficient polygonization of implicit surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luiz</forename><surname>Velho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph. Tools</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="5" to="24" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A unified approach for hierarchical adaptive tesselation of surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luiz</forename><surname>Velho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luiz</forename><surname>Henrique De Figueiredo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Gomes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="329" to="360" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Approximation and Visualization of Scientific Data Using Higher-order Elements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">F</forename><surname>Wiley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
		<respStmt>
			<orgName>University of California, Davis</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
