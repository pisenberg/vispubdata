<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Projecting Tetrahedra without Rendering Artifacts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
							<email>kraus@purdue.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Qiao</surname></persName>
							<email>qiaow@purdue.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">S</forename><surname>Ebert</surname></persName>
							<email>ebertd@purdue.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Projecting Tetrahedra without Rendering Artifacts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation-Display algorithms</term>
					<term>Bitmap and framebuffer operations; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Raytracing volume visualization</term>
					<term>volume rendering</term>
					<term>cell projection</term>
					<term>projected tetrahedra</term>
					<term>perspective interpolation</term>
					<term>dithering</term>
					<term>programmable graphics hardware</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Hardware-accelerated direct volume rendering of unstructured volumetric meshes is often based on tetrahedral cell projection, in particular, the Projected Tetrahedra (PT) algorithm and its variants. Unfortunately, even implementations of the most advanced variants of the PT algorithm are very prone to rendering artifacts. In this work, we identify linear interpolation in screen coordinates as a cause for significant rendering artifacts and implement the correct perspective interpolation for the PT algorithm with programmable graphics hardware. We also demonstrate how to use features of modern graphics hardware to improve the accuracy of the coloring of individual tetrahedra and the compositing of the resulting colors, in particular, by employing a logarithmic scale for the pre-integrated color lookup table, using textures with high color resolution, rendering to floating-point color buffers, and alpha dithering. Combined with a correct visibility ordering, these techniques result in the first implementation of the PT algorithm without objectionable rendering artifacts. Apart from the important improvement in rendering quality, our approach also provides a test bed for different implementations of the PT algorithm that allows us to study the particular rendering artifacts introduced by these variants.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION AND PREVIOUS WORK</head><p>There are several approaches to direct volume rendering of unstructured meshes, e.g., ray casting and cell projection. However, most implementations for OpenGL graphics hardware are based on cell projection; more specifically, the Projected Tetrahedra (PT) algorithm published by Shirley and Tuchman <ref type="bibr" target="#b17">[18]</ref>.</p><p>The PT algorithm exploits the triangle rasterization performance of graphics hardware by decomposing the projected silhouette of a tetrahedron into three or four triangles, as in <ref type="figure" target="#fig_0">Figure 1</ref>. Previous research has focused on two aspects of this algorithm: the color computation for these triangles <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19]</ref> and the computation of a visibility ordering of the tetrahedra <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b9">10]</ref>. In this work, we are not concerned with the latter and assume that a correct visibility ordering is available. In fact, we employ the extension of the meshed polyhedra visibility ordering (MPVO) algorithm for nonconvex meshes suggested by Williams <ref type="bibr" target="#b21">[22]</ref>, which computes a correct ordering for most tetrahedral meshes. To compute the colors of triangles generated by the PT algorithm, Shirley and Tuchman <ref type="bibr" target="#b17">[18]</ref> suggested computing correct colors only for the triangles' vertices. Thus, the efficient linear interpolation of vertex colors provided by graphics hardware can be exploited. Unfortunately, this results in rendering artifacts even for uniform attenuation coefficients as noted by Stein, Becker, and Max <ref type="bibr" target="#b18">[19]</ref>. Their solution was to interpolate the thickness and the average attenuation coefficient of the projected tetrahedron for each fragment by means of texture coordinate interpolation. Based on these two interpolated values, the opacity of each fragment is determined by a two-dimensional texture lookup. This opacity is either modulated with a constant color, or with an interpolated vertex color. Unfortunately, the linear interpolation of the average attenuation coefficient and the thickness is only correct for orthogonal projections and leads to rendering artifacts for perspective projections.</p><p>An efficient computation of the correct perspective interpolation has been published by Heckbert and Moreton <ref type="bibr" target="#b6">[7]</ref> and independently by Blinn <ref type="bibr" target="#b0">[1]</ref>. Moreover, correct perspective interpolation is usually offered by modern graphics hardware supporting OpenGL. However, the perspective interpolation employed in OpenGL <ref type="bibr" target="#b16">[17]</ref> cannot directly cure this problem for the PT algorithm because it was designed for an interpolation of values on triangles-not within tetrahedra.</p><p>Another well-known disadvantage of the method by Stein et al. <ref type="bibr" target="#b18">[19]</ref> is the restriction of the attenuation coefficients to linear functions within each tetrahedron. This problem was addressed by a software-based computation for arbitrary attenuation transfer functions published by Max, Hanrahan and Crawfis <ref type="bibr" target="#b12">[13]</ref>. The availability of hardware-supported three-dimensional texture maps allowed Röttger, Kraus, and Ertl <ref type="bibr" target="#b15">[16]</ref> to implement a generalization of this method in graphics hardware. This technique is now known as pre-integrated cell projection. The basic idea is to employ linear interpolation of texture coordinates to interpolate the thickness of the tetrahedron and the scalar data value on the front and back faces of the tetrahedron for each fragment. Hardware-accelerated three-dimensional texture mapping is then exploited to perform a lookup of the color for a particular fragment. Note that this particu- is also restricted to orthogonal projections and generates rendering artifacts for perspective projections. Pre-integrated cell projection was further improved <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14]</ref>; however, the artifacts caused by perspective projections were never addressed.</p><p>An alternative to cell projection is ray casting in unstructured meshes. The basic algorithm for traversing cells of a tetrahedral mesh along viewing rays and an implementation in software were published by Garrity <ref type="bibr" target="#b4">[5]</ref>. More recently, Weiler et al. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> published a cell projection algorithm based on the idea of ray casting single tetrahedra in graphics hardware and a hardware-based implementation of a pre-integrated variant of Garrity's algorithm using floating-point color buffers. With respect to rendering artifacts, there are two advantages of the ray casting approach in contrast to the PT algorithm: the use of floating-point precision to composite colors and the absence of any interpolation errors due to perspective projection. In order to achieve a similar rendering quality with the PT algorithm, we derive the correct perspective interpolation for projected tetrahedra and discuss its implementation with the help of programmable graphics hardware in Section 2.</p><p>For the coloring of individual tetrahedra, Weiler et al. <ref type="bibr" target="#b19">[20]</ref> employed a pre-integrated lookup table implemented by a threedimensional floating-point RGBA texture. Unfortunately, the lack of trilinear interpolation in these textures and the limited resolution result in rendering artifacts. Our solution to these problems is the use of textures with 16 bits per color component and the implementation of a logarithmic scale for the pre-integrated lookup table. These enhancements are described in Section 3.</p><p>While the compositing of color contributions is performed with floating-point precision by most ray casters, hardware-accelerated cell projection with programmable graphics hardware has been restricted to 8-bit fixed-point color components until recently. Even the currently available hardware support for floating-point color buffers does not allow us to blend small, overlapping triangle primitives without rendering artifacts. Since the PT algorithm tends to generate many small triangles, it is prone to these artifacts. In Section 4, we show how to avoid them at the cost of rendering performance. Moreover, we present an alternative approach for 8-bit color components similar to the alpha dithering technique suggested by Williams, Frank, and LaMar <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>A comparison of the common rendering artifacts of implementations of the PT algorithm is given in Section 5. The rendering performance of our enhanced variants of the PT algorithm are also discussed in this section. Section 6 presents our conclusions and plans for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PERSPECTIVE INTERPOLATION</head><p>Before discussing the interpolation of vertex attributes with perspective correction for the PT algorithm in Section 2.2, we will introduce our notation and derive the required equations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Interpolation in Normalized Device Coordinates</head><p>Our notation is based on the OpenGL specification <ref type="bibr" target="#b16">[17]</ref>; in particular, the homogeneous coordinates of a vertex v o in object space are denoted by (</p><formula xml:id="formula_0">x o , y o , z o , w o ) T . Assuming w o is not equal to 0, this four-dimensional vector represents a three-dimensional vec- tor (x o /w o , y o /w o , z o /w o ) T .</formula><p>The model-view matrix M maps a vector v o from object space to a vector v e = (x e , y e , z e , w e ) T in eye space, i.e., v e = Mv o . The mapping from eye space to clip space is performed by the projection matrix P: v c = Pv e with v c = (x c , y c , z c , w c ) T . Finally, we define the normalized device coordinates as the components of the four-dimensional vector </p><formula xml:id="formula_1">v d = eye point view plane v d 1 v d 2 f v o v c 1 v c 2 0 1 w c 1 w c 2 w c</formula><formula xml:id="formula_2">(x d , y d , z d , 1) T obtained by a "perspective division" from v c , i.e, v d = v c /w c .</formula><p>For the derivation of the perspective interpolation 1 , we have to consider linear functions in object space. In homogeneous coordinates, any scalar function f (v o ) that is linear in the threedimensional coordinates</p><formula xml:id="formula_3">x o /w o , y o /w o , and z o /w o is of the form f (v o ) = c x x o w o + c y y o w o + c z z o w o + c w = c • v o w o with a constant four-dimensional vector c = c x , c y , c z , c w T . Note</formula><p>that the projection to normalized device coordinates will turn this linear function into a nonlinear function as illustrated in <ref type="figure" target="#fig_2">Figure 2</ref>. Assuming w c is not equal to 0 and the matrix product PM has an inverse, we can also write:</p><formula xml:id="formula_4">f (v o ) = c • (PM) −1 PM v o w c w c w o .</formula><p>With the constant vector c = (PM) −1 T c and the equality These results were exploited by Heckbert and Moreton <ref type="bibr" target="#b6">[7]</ref> and independently by Blinn <ref type="bibr" target="#b0">[1]</ref> for the perspective interpolation of attributes between vertices, e.g., color or texture coordinates. If two vertices are connected by a line, the corresponding attributes of the two vertices define a linear function on the line segment. Analogously, if three vertices are connected by a triangle, the corresponding attributes define a linear function on the triangle. The domain view plane </p><formula xml:id="formula_5">PMv o /w c = v d we obtain f (v o ) w o w c = c • v d . This equation implies that f (v o )w o /w</formula><formula xml:id="formula_6">b o t o a o d o c o eye point</formula><formula xml:id="formula_7">(a o , b o , c o , t o ), (c o , b o , d o , t o ), and (d o , b o , a o , t o ).</formula><p>of these linear functions f (v o ) may be extended to the whole threedimensional object space without any complications. The projection of these functions is, however, not linear in normalized device coordinates (see <ref type="figure" target="#fig_2">Figure 2</ref>). Therefore, instead of linearly interpolating vertex attributes, the values of f (v o )w o /w c and w o /w c are interpolated separately for each vertex, and these values are interpolated linearly in normalized device coordinates for each fragment. The value of f (v o ) is then reconstructed by one division per fragment:</p><formula xml:id="formula_8">f (v o ) = f (v o ) w o w c interpolated w o w c interpolated .</formula><p>Assuming w o is equal to 1 (or at least all w o 's are the same for all vertices), this leads directly to Equations 3.4 and 3.6 in the OpenGL 1.5 specification <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Interpolation for Projected Tetrahedra</head><p>The original PT algorithm <ref type="bibr" target="#b17">[18]</ref> decomposes the (non-degenerate) projection of a tetrahedron into three or four triangles (see <ref type="figure" target="#fig_0">Figure 1)</ref>, computes colors for all triangle vertices, and employs hardware-accelerated triangle rasterization to interpolate the fragment color. Note that a correct perspective interpolation of colors is impossible for this algorithm because each rasterized fragment corresponds to a viewing ray segment through the tetrahedron with a range of w c coordinates instead of a single w c coordinate.</p><p>Instead of decomposing the projection of a tetrahedron into three or four triangles, we can also decompose the tetrahedron itself into three or four smaller tetrahedra. In this case, the decomposition is performed in object coordinates instead of normalized device coordinates. As illustrated in <ref type="figure" target="#fig_4">Figure 3</ref>, each of these smaller tetrahedra is projected to one of the triangles of the original PT decomposition. Moreover, each of the smaller tetrahedra features one pair of vertices, which are projected to the same two-dimensional vertex in the view plane. In <ref type="figure" target="#fig_8">Figure 4</ref>, for example, v (the "back" vertex) are projected to the same vertex in the view plane. In order to process all three vertices of the triangles in the view plane in exactly the same way (as required by our implementation), we duplicate the other two three-dimensional vertices of the tetrahedron. For example, v  </p><formula xml:id="formula_9">v o 1f v o 1b v o 2f v o 2b v o 3f v o 3b</formula><p>eye point Once the six vertices v</p><formula xml:id="formula_10">(1f) o , v (1b) o , v (2f) o , v (2b) o , v<label>(3f)</label></formula><p>o , and v </p><formula xml:id="formula_11">v (1b) o , v (2b) o , and v (3b) o</formula><p>can be rasterized because both triangles will cover the same pixels. During the rasterization of either triangle, we can interpolate any vertex attribute either on the front facing triangle by interpolating between vertices v</p><formula xml:id="formula_12">(1f) o , v (2f) o , and v (3f)</formula><p>o , or on the back facing triangle by interpolating (with the same weights) between vertices v</p><formula xml:id="formula_13">(1b) o , v (2b) o , and v (3b)</formula><p>o . The correct perspective interpolation can be performed as described in Section 2.1.</p><p>This approach avoids rendering artifacts caused by an incorrect (nonperspective) interpolation in several important variants of the PT algorithm. For example, in the variant of the PT algorithm published by Stein et al. <ref type="bibr" target="#b18">[19]</ref>, we can interpolate the attenuation coefficients τ (f) and τ (b) with perspective correction on the front facing and the back facing triangle, respectively, while rasterizing either one. Similarly, we can interpolate the scalar data values s (f) and s (b) on the two triangles in the pre-integrated variant of the PT algorithm suggested by Röttger et al. <ref type="bibr" target="#b15">[16]</ref>.</p><p>These two variants of the PT algorithm also require the thickness of the tetrahedron for the rasterized fragment. This thickness l may be computed as the distance (in three-dimensional eye space) between the points on the two triangles corresponding to the rasterized fragment: e are linear functions of the three-dimensional object coordinates for any model-view matrix M with a fourth row vector of (0, 0, 0, 1) T ; therefore, v e can be interpolated with perspective correction on the front facing and back facing triangle, respectively, as described above.</p><formula xml:id="formula_14">l = v (b) e w (b) e − v<label>(</label></formula><p>Usually all w e coordinates are 1. Furthermore, we can exploit the fact that the three-dimensional points represented by v   Note that |v e . The latter equation is also employed in our implementation, which is presented in the next section.</p><formula xml:id="formula_15">l = v (b) e − v (f) e = v</formula><formula xml:id="formula_16">v o 1f , s 1f , v o 1b , s 1b v o 2f , ... v o 3f , ... call vertex program output vertex attributes v d 1f , 1 w c 1f , s 1f w c 1f , v e 1f w c 1f , 1 w c 1b , ... v d 2f , ... v d 3f , ... ...</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>interpolate for triangle rasterization fragment attributes</head><formula xml:id="formula_17">v d f , 1 w c f , s f w c f , v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Implementation with Programmable Graphics Hardware</head><p>Our implementation is based on the OpenGL 1.5 ARB extensions for vertex programs and fragment programs <ref type="bibr" target="#b16">[17]</ref>. <ref type="figure">Figure 5</ref> illustrates the data flow for perspective interpolation in our implementation of the PT algorithm for pre-integrated cell projection.</p><p>As discussed in Section 2.2, each tetrahedron is decomposed into three or four smaller tetrahedra corresponding to the triangles of the original PT algorithm. For each of the smaller tetrahedra, the six vertices</p><formula xml:id="formula_18">v (1f) o , v (1b) o , v (2f) o , v (2b) o , v (3f) o , and v (3b) o are computed. Moreover, six corresponding scalar data values s (1f) , s (1b) , s (2f) , s (2b) , s (3f)</formula><p>, and s (3b) are determined. We rasterize the front facing triangle spanned by the vertices v</p><formula xml:id="formula_19">(1f) o , v (2f) o and v (3f)</formula><p>o . Apart from these coordinates, each triangle vertex is also provided with the object coordinates of the corresponding "back" vertex and the scalar data values for the front and back vertex. For example, for the i-th vertex with object coordinates v   </p><formula xml:id="formula_20">v (if) d = v (if) c /w (if)</formula><p>c . By performing the perspective division and returning normalized device coordinates instead of clip coordinates, we ensure that OpenGL does not use perspective interpolation but linear interpolation since we specify that w c is equal to 1.</p><p>Apart from the projected position, the output parameters of our vertex program for the i-th vertex are 1/w</p><formula xml:id="formula_21">(if) c , s (if) /w (if) c , v (if) e /w (if) c , 1/w (ib) c , s (ib) /w (ib) c , and z (ib) e /w (ib)</formula><p>c . Note that we set all w o 's to 1; thus, they do not appear in these quantities.</p><p>These output vertex attributes are linearly interpolated between the three vertices of each triangle. We denote the results of these interpolations by 1/w</p><formula xml:id="formula_22">(f) c , s (f) /w (f) c , v (f) e /w (f) c , 1/w (b) c , s (b) /w (b) c , and z (b) e /w (b)</formula><p>c , respectively. These are input parameters for our fragment program, which completes the perspective interpolation by dividing interpolated values:</p><formula xml:id="formula_23">s (f) = s (f) /w (f) c 1/w (f) c , v<label>(f)</label></formula><formula xml:id="formula_24">e = v (f) e /w (f) c 1/w (f) c , s (b) = s (b) /w (b) c 1/w (b) c , z (b) e = z (b) e /w (b) c 1/w (b) c .</formula><p>The thickness l of the tetrahedron is computed from these quantities as described in Section 2.2. Note that it is often possible to simplify the computation of l without introducing visible rendering artifacts with the help of the approximation l ≈ |z</p><formula xml:id="formula_25">(b) e − z (f)</formula><p>e |. This completes the perspective interpolation of s (f) , s <ref type="bibr">(b)</ref> , and the computation of l. Based on these parameters, the color of the fragment is determined by the fragment program as discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ACCURATE COLORING</head><p>In the PT algorithm, many tetrahedra can contribute to the color of a single pixel; therefore, even small color contributions of individual tetrahedra can sum up to a significant contribution to the final image. Thus, in order to avoid rendering artifacts, the accuracy of the color computation for a single tetrahedron has to exceed the color accuracy of the final image.</p><p>Fortunately, arithmetic computations in fragment programs may be performed with floating-point precision. Therefore, it is beneficial to replace, for example, the texture lookup for the correct exponential attentuation suggested by Stein et al. <ref type="bibr" target="#b18">[19]</ref> by a more accurate computation in a fragment program. For some optical models, the three-dimensional texture lookup for pre-integrated cell projection can also be replaced by a fragment program as suggested by Guthe et al. <ref type="bibr" target="#b5">[6]</ref>. In general, however, the pre-integrated lookup can only be replaced by an expensive numerical integration.</p><p>Therefore, instead of replacing the pre-integrated texture lookup, we improve its accuracy by employing textures with 16-bit color components (so called "HILO textures" <ref type="bibr" target="#b8">[9]</ref>), which support trilinear interpolation. Since HILO textures are only available with two color components, we have to split the RGBA lookup texture into two HILO textures and perform two texture lookups to get all four color components. Note that we avoid floating-point textures because they only permit nearest-neighbor "interpolation."</p><p>Apart from the accuracy of the colors tabulated in the threedimensional lookup texture, we also have to consider its minimum dimensions. The three coordinates for this texture lookup correspond to the scalar data value at the front s (f) , the scalar data value at the back s <ref type="bibr">(b)</ref> , and the thickness l <ref type="bibr" target="#b15">[16]</ref>. The texture coordinates are usually computed by a linear mapping of the whole range of s (f) , s <ref type="bibr">(b)</ref> , and l, respectively, to the range of texture coordinates. In our implementation, the range of a particular texture coordinate is</p><formula xml:id="formula_26">[(2n) −1 , 1 − (2n) −1 ],</formula><p>where n is the dimension of the texture in the corresponding direction. Note that (2n) −1 and 1 − (2n) −1 specify the coordinates of the centers of the 0-th and the (n − 1)-th texel, respectively, in OpenGL textures.</p><p>For the dimensions corresponding to s (f) and s (b) a resolution corresponding to the Nyquist sampling rate of the transfer functions will avoid most visible artifacts. In contrast to the scalar data values, the range of the thickness l depends on the tetrahedral mesh. More specifically, the minimum thickness is zero and the maximum thickness is equal to the length l max of the longest edge of all cells in eye space. If the model-view matrix does not include any scaling, l max is also the length of the longest edge in object space. Note that fragments on the silhouette of a tetrahedral cell usually require a thickness very close to zero; thus, the pre-integrated lookup table has to cover the whole range [0, l max ]. The dependency of the color on the thickness l is in general a very smooth function since the most relevant dependencies are the exponential attentuation and the linear accumulation of emitted light. Therefore, previous implementations of pre-integrated cell projection have often chosen a rather low resolution for the thickness. However, this is not appropriate for data sets featuring a very high ratio between the lengths of the longest and the shortest edges of the mesh. In these cases, the thickness of many small tetrahedra will be close to zero. Therefore, on the one hand, these data sets require a very high resolution of the lookup table for small values of l; on the other hand, the thickness is still a smooth function for large values of l; thus, a coarse resolution for large l is sufficient.</p><p>Therefore, a logarithmic mapping of the thickness l to the texture coordinate r is more appropriate than a linear mapping. Note that a thickness of l = 0 should be mapped to the texture coordinate of the 0-th texel r = (2n r ) −1 where n r is the r-dimension of the texture. In order to satisfy these constraints, we chose a mapping of l to r, which is linear for 0 ≤ l ≤ ∆l with ∆l = 2 −(n r −2) l max and logarithmic for l ≥ ∆l; see <ref type="figure" target="#fig_19">Figure 6</ref> and Equation 1.</p><formula xml:id="formula_27">r = max log 2 l ∆l , 0 + min l ∆l , 1 n r + 1 2n r<label>(1)</label></formula><p>A straightforward implementation of Equation 1 using the OpenGL ARB extension for fragment programs requires seven instructions. (Implementing this mapping by means of a 1D texture lookup would usually require a prohibitively large texture size.) To compute the pre-integrated lookup table efficiently, we employ an adapted variant of the incremental pre-integration method <ref type="bibr" target="#b19">[20]</ref> that incrementally computes two-dimensional slices of the table for l = 0, ∆l, 2∆l, 4∆l, 8∆l, . . ., 2 n r −2 ∆l.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ACCURATE COMPOSITING</head><p>In order to avoid rendering artifacts in volume rendering algorithms, colors have to be composited with a higher accuracy than most graphics adapters offer for frame buffers. Unfortunately, the current hardware support for floating-point color buffers has some crucial limitations, which prevent their efficient use in the context of the PT algorithm as discussed in detail in Section 4.1. Section 4.2 describes an approach based on randomized dithering using frame buffers with 8-bit color components to improve the quality of the final image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Floating-Point Color Buffer</head><p>Current graphics adapters (based on NVIDIA's NV3x and ATI's R3xx chipsets) allow fragment programs to write to and read from floating-point textures at the same time. Although the results of these texture read operations are undefined, this technique has been successfully employed to implement color blending for slice-based volume visualization <ref type="bibr" target="#b7">[8]</ref>.</p><p>For the small triangle primitives of the PT algorithm, however, the results of these texture read operations are in fact erroneouspresumably due to caching of texture data. If the compositing computation in the fragment program is based on outdated data, severe caching artifacts can appear. For the NVIDIA Quadro FX 3000 graphics board used in this work, we found several ways to avoid all these caching artifacts. The two most important are:</p><p>1. rasterizing a large point primitive after each triangle fan, or 2. binding the color buffer texture and sending a fence (see the GL NV fence extension <ref type="bibr" target="#b8">[9]</ref>) after each triangle fan. <ref type="bibr" target="#b1">2</ref> Although rather slow, the latter approach performed better and was, therefore, used for our measurements in Section 5. The recently released NVIDIA GeForce FX 6800 (NV40 chipset) supports rendering to 16-bit floating-point color buffers with alpha blending; thus, there is no need to simultaneously read from and write to the same texture. Our preliminary measurements indicate that this allows us to use floating-point color buffers at interactive frame rates for the PT algorithm.</p><p>We found it extremely useful to employ floating-point color buffers to generate reference images because these visualizations avoid all artifacts due to color quantization during color compositing. Thus, we are able to reveal rendering artifacts that would otherwise be hidden by color quantization artifacts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Alpha Dithering</head><p>For frame buffers with very limited color resolution, e.g., 8 bits per color component, Williams, Frank, and LaMar <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b10">11]</ref> suggested alpha dithering as an efficient way to overcome quantization artifacts in volume rendering algorithms.</p><p>Our variant of alpha dithering customizes the 8-bit color quantization of the color result of the fragment program. The default quantization on our graphics hardware maps an output αcomponent between 0 and 1 to 255α + 1/2 /255 with the floor function x denoting the largest integer smaller than or equal to x. In contrast to this default quantization, we implement the following quantization at the very end of our fragment program:</p><formula xml:id="formula_28">α → ( 255α + 1) /255 if 255α − 255α &gt; q 255α /255</formula><p>otherwise with a pseudo-random number q ∈ [0, 1], which is determined by texture lookups in tables of random numbers. In other words, we round up with a probability equal to the fractional part of 255α, otherwise we round down. Our randomized rounding performs very well in many cases; however, it does not avoid all rendering artifacts since the graphics   hardware performs a second quantization after the blending operation of the fixed-function OpenGL pipeline. Unfortunately, this blending operation is not customizable; thus, we cannot avoid artifacts introduced at this point. The only exception to this rule is purely additive blending. In this case, the result of the blending is guaranteed to be quantized, and the second quantization is, therefore, ineffective. This is also the only case in which a randomized rounding of the red, green, and blue components is preferable to the randomized rounding of α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Timings</head><p>We tested our implementation on a Windows XP PC with an AMD Athlon 64 3400+ processor (2.4 GHz), an AGP 8× bus, and an NVIDIA Quadro FX 3000 graphics adapter with 256 MB of video memory. As discussed in Section 2.3, our implementation takes advantage of the programmable vertex and fragment processing provided by the graphics hardware. Many factors influence the rendering performance, for example, the number of tetrahedra, the image dimensions, and the depth complexity. The transfer function does  not affect the rendering performance since different transfer functions are achieved by modifying the pre-integrated lookup table. <ref type="table" target="#tab_0">Table 1</ref> shows the timing results for the NASA blunt fin data set, which is decomposed into 187,318 tetrahedra before rendering. All times were measured for images of 800 × 600 pixels. Since our system is fragment-bound, additional instructions in the fragment program increase the rendering time. Note that we could greatly improve the rendering performance by culling transparent tetrahedra in software; however, for benchmarking purposes we are projecting all tetrahedra.</p><p>Perspective interpolation is implemented using vertex and fragment programs with twelve and eleven arithmetic instructions, respectively (see Section 2.3). The use of HILO lookup textures requires an additional 3D-texture lookup per fragment (see Section 3). The logarithmic lookup is implemented with seven arithmetic instructions per fragment, as mentioned in Section 3. For the images in this paper we always employed lookup tables of dimensions 256 × 256 × 16 where 16 is the dimension of the texture corresponding to the thickness l.</p><p>Ten arithmetic instructions and two 2D-texture lookups in pseudo-random number tables are needed per fragment for alpha dithering (see Section 4.2). Due to the additional operations required to eliminate the texture caching artifacts as discussed in Section 4.1, the color compositing in a floating-point color buffer is considerably slower than in a frame buffer. <ref type="table" target="#tab_1">Table 2</ref> presents the rendering times per frame for different data sets rendered with perspective interpolation and logarithmic HILO lookup textures. The times are roughly linear in the number of projected tetrahedra but also depend strongly on the number of rasterized fragments.  Our preliminary measurements on an NVIDIA GeForce FX 6800 GT clocked at 350 MHz show only a slight increase in performance. For example, the rendering with all enhancements to an 8-bit frame buffer is about 22 % faster than with the NVIDIA Quadro FX 3000. This is presumably due to bottlenecks caused by the CPU or the AGP bus. There is, however, an important exception: the rendering with hardware-supported blending to a 16-bit floating-point color buffer is only less than 1 % slower than the rendering to an 8-bit frame buffer since no additional operations are necessary to avoid caching artifacts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Comparison of Artifacts</head><p>One advantage of our implementation is that it allows us to study artifacts in terms of their causes and remedies. In the following discussion, we compare different renderings and relate artifacts to techniques that remove them. Perspective interpolation of vertex attributes is required in the PT algorithm since an incorrect linear interpolation of texture coordinates causes erroneous coloring (see Section 3). In <ref type="figure" target="#fig_22">Figure 8</ref>, we show a volume visualization of the heat sink data set, which mimics an isosurface rendering by employing a transfer function with a sharp peak at the isovalue. Without perspective interpolation, artifacts in the form of cracks and overlaps occur along the intersections of the isosurface with cell faces, as shown in the inset in  <ref type="figure" target="#fig_20">Figure 7b</ref> shows a rendering using a frame buffer with only 8 bits per component for color compositing. This limited color depth results in structured artifacts, which are similar to those in <ref type="figure" target="#fig_20">Figure 7a</ref>.</p><p>As explained in Section 4.2, alpha dithering alleviates rendering artifacts resulting from quantization errors to a certain extent. <ref type="figure" target="#fig_23">Figure 9a</ref> shows the NASA tapered cylinder data set rendered with an 8-bit per component frame buffer. Alpha dithering lessens artifacts in inset "1" and almost removes them in inset "2" as shown in <ref type="figure" target="#fig_23">Figure 9b</ref>. With floating-point precision for the color compositing, alpha dithering is unnecessary, as shown in <ref type="figure" target="#fig_23">Figure 9c</ref>.</p><p>As explained in Section 3, a uniform lookup texture is inappropriate if the ratio between the lengths of the longest and the shortest mesh edges is very high, which is the case in the NASA X38 data set. Very small tetrahedra have thicknesses close to zero; thus, they require lookup textures with an extremely high resolution for small thicknesses. Uniform lookup textures cannot offer such a high resolution at a feasible size and, therefore, lead to under-sampling errors for extremely small tetrahedra. This results in darker renderings with substantial edge artifacts <ref type="figure" target="#fig_0">(Figure 10a</ref>) as opposed to the artifact-free rendering with a logarithmic lookup texture <ref type="figure" target="#fig_0">(Figure 10b</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FUTURE WORK</head><p>We have identified and cured all major rendering artifacts that are common in implementations of the PT algorithm. These include incorrect interpolation, insufficient accuracy and dimensions of preintegrated lookup tables, and insufficient accuracy of the frame buffer used for compositing. With our improvements, the PT algorithm is capable of achieving a rendering quality that was previously only possible with ray casting approaches.</p><p>Our solution to the limited accuracy of frame buffers is the use of floating-point color buffers, which is well supported only by the latest graphics hardware. This hardware allows us to provide the highest rendering quality at interactive frame rates.</p><p>Several of our improvements are not restricted to the PT algorithm. For example, the correct perspective interpolation could also be applied to pre-integrated texture-based volume rendering <ref type="bibr" target="#b3">[4]</ref>, and logarithmic lookup textures could be used for hardwareaccelerated ray casting algorithms with an adaptive sampling rate <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20]</ref>.</p><p>In order to further improve the PT algorithm, we plan to integrate the volume lighting method described by Lum et al. <ref type="bibr" target="#b11">[12]</ref> with correct perspective interpolation. Moreover, we intend to validate the volume visualizations generated by our system by means of a comparison with a software ray caster. This will allow us to study the effect of incorrect visibility orderings and to compare the numerical pre-integration with analytic solutions of the volume rendering integral for piecewise-linear transfer functions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Classification of non-degenerate projected tetrahedra (top row) and the corresponding decompositions (bottom row).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>October 10 -</head><label>10</label><figDesc>15, Austin, Texas, USA IEEE Visualization 2004 0-7803-8788-0/04/$20.00 ©2004 IEEE lar implementation of pre-integrated cell projection by Röttger et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :d</head><label>2</label><figDesc>The projection of a linear function f (v o ) onto the view plane results in a nonlinear function. In the depicted case of a linear color interpolation between vertices v as illustrated by the centered dashed line.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>c is a linear function of the normalized device coordinates x d , y d , and z d . Therefore, given any function f (v o ) that is linear in the three-dimensional coordinates x o /w o , y o /w o , and z o /w o , we may linearly interpolate values of f (v o )w o /w c in normalized device coordinates. An important example is f (v o ) ≡ 1. Since 1 is constant, it is also a linear "function" of x o /w o , y o /w o , and z o /w o . In this particular case, the result from above implies that w o /w c is a linear function of x d , y d , and z d ; therefore, we may linearly interpolate values of w o /w c in normalized device coordinates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Decomposition of the tetrahedron (a o , b o , c o , d o ) into three smaller tetrahedra corresponding to the triangles generated by the PT algorithm for class 1a (see Figure 1). The new vertex t o is determined by the intersection of triangle (a o , c o , d o ) with the extension of the line from the eye point to b o . The three tetrahedra are</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>front" vertex) and v (1b) o</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(2f) o and v (2b) oinFigure 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>view plane</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 4 :</head><label>4</label><figDesc>The tetrahedron (d o , b o , a o , t o ) from Figure 3 in our notation for triangle vertices. Note that v (1f) o and v (1b) o are projected to the same point on the view plane. are identical copies of one vertex. Analogously, v (3f) o and v (3b) o are identical.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(3b) o are computed, either the front facing triangle spanned by the vertices v (1f) o , v (2f) o , and v (3f) o or the back facing triangle spanned by the vertices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>(f) e and v (b) e are on one line with the origin:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>e f w c f , 1 Figure 5 :</head><label>15</label><figDesc>w c b , ... call fragment program fragment color RGBA s f , s b , l blend with color in frame buffer Data flow in our implementation of perspective interpolation for the PT algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>e</head><label></label><figDesc>| denotes the Euclidean vector norm of the threedimensional eye space vector represented by v (f)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>o</head><label></label><figDesc>we specify the scalar data values s(if)  and s(ib)  , and the vector v</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>o</head><label></label><figDesc>as additional vertex attributes. These vertex attributes are the input parameters for our vertex program. For the i-th vertex, the vertex program computes clip coordinates v (if) c = PMv</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>o</head><label></label><figDesc>and normalized device coordinates</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 6 :</head><label>6</label><figDesc>Mapping of l ∈ [0, l max ] to texture coordinate r ∈ [(2n r ) −1 , 1− (2n r ) −1 ] for dimension n r = 8.Note that the mapping is linear instead of logarithmic for 0 ≤ l ≤ 2 −(nr −2) l max = l max /64.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 7 :</head><label>7</label><figDesc>Rendering of the NASA blunt fin data set: (a) without HILO lookup textures, (b) without floating-point color buffer, and (c) with both HILO lookup textures and floating-point color buffer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 8 :</head><label>8</label><figDesc>Isosurface visualization of the heat sink data set: (a) without and (b) with perspective interpolation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 9 :</head><label>9</label><figDesc>Rendering of the NASA tapered cylinder data set: (a) with color compositing in the frame buffer, (b) with alpha dithering and color compositing in the frame buffer, and (c) with color compositing in a floating-point color buffer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 10 :</head><label>10</label><figDesc>Isosurface visualization of the pressure component of the NASA X38 data set: (a) with a uniform lookup texture and (b) with a logarithmic lookup texture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>Figure 8a. In contrast, rendering with perspective interpolation shows no artifacts, as shown in the inset inFigure 8b. Note that all insets in Figures 7 to 10 are magnified and contrast-enhanced. An 8-bit per component pre-integrated lookup texture does not offer sufficient color depth, as mentioned in Section 3. For example, the structured artifacts shown in Figure 7a result from the coarsely quantized colors of such a lookup texture. On the other hand, HILO lookup textures produce artifact-free renderings as shown in Figure 7c. Color compositing also requires a high color accuracy, as noted in Section 4.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Total rendering times per frame (including cell sorting) and overhead introduced by our enhancements for the blunt fin data set.</figDesc><table><row><cell cols="2">rendering technique/enhancement time in secs</cell></row><row><cell>basic pre-integrated PT algorithm (i)</cell><cell>0.195</cell></row><row><cell>overhead for perspective interpolation (ii)</cell><cell>0.048</cell></row><row><cell>overhead for HILO lookup textures (iii)</cell><cell>0.031</cell></row><row><cell>overhead for logarithmic lookup (iv)</cell><cell>0.040</cell></row><row><cell>total for frame buffer (i+ii+iii+iv)</cell><cell>0.314</cell></row><row><cell>total with alpha dithering</cell><cell>0.621</cell></row><row><cell>total for floating-point color buffer</cell><cell>1.781</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Number of tetrahedra and total frame buffer rendering times per frame for different data sets.</figDesc><table><row><cell>data set</cell><cell cols="3">no. tets time in secs tets per sec</cell></row><row><cell>heat sink</cell><cell>121,668</cell><cell>0.252</cell><cell>483K</cell></row><row><cell>blunt fin</cell><cell>187,318</cell><cell>0.314</cell><cell>597K</cell></row><row><cell>cylinder</cell><cell>624,960</cell><cell>0.929</cell><cell>673K</cell></row><row><cell cols="2">X38 1,943,483</cell><cell>3.07</cell><cell>633K</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Compare Equations 3.4 and 3.6 in the OpenGL 1.5 specification<ref type="bibr" target="#b16">[17]</ref>.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">This method was suggested by Nick Triantos (NVIDIA).</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGMENTS</head><p>The authors would like to thank Cass Everitt, Randall Frank, Markus Hadwiger, Mark Kilgard, Eric LaMar, Kirk Riley, Nik Svakhine, Nick Triantos, Peter Williams, and the anonymous reviewers for many helpful discussions, comments, and suggestions. We would also like to thank Kelly Gaither for providing the NASA X38 dataset and NVIDIA for providing a pre-release GeForce FX 6800 board. This material is based upon work supported by the National Science Foundation under Grant Nos. 0222675, 0081581, 0121288, 0196351, and 0328984.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Jim Blinn&apos;s corner: Hyperbolic interpolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">F</forename><surname>Blinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="89" to="94" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the optimization of projective volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Montani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donatella</forename><surname>Sarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Scopigno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization in Scientific Computing &apos;95</title>
		<editor>R. Scanteni, J. van Wijk, and P. Zanarini</editor>
		<meeting><address><addrLine>Wien</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="58" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast polyhedral cell sorting for interactive rendering of unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">João</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">L</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Eurographics &apos;99)</title>
		<meeting>Eurographics &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="369" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">High-quality preintegrated volume rendering using hardware-accelerated pixel shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Graphics Hardware</title>
		<editor>William Mark and Andreas Schilling</editor>
		<meeting>Graphics Hardware</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Raytracing irregular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">High-quality unstructured volume rendering on the pc platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Roettger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Schieber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Strasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Graphics Hardware</title>
		<editor>Thomas Ertl, Wolfgang Heidrich, and Michael Doggett</editor>
		<meeting>Graphics Hardware</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="119" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Interpolation for polygon texture mapping and shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><forename type="middle">P</forename><surname>Moreton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">State of the Art in Computer Graphics: Visualization and Modeling</title>
		<editor>David F. Rogers and Rae A. Earnshaw</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="101" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Acceleration techniques for gpu-based volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization 2003</title>
		<editor>Greg Turk, Jarke J. van Wijk, and Robert Moorhead</editor>
		<meeting>IEEE Visualization 2003</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="287" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">NVIDIA OpenGL Extension Specifications. NVIDIA Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kilgard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cell-projection of cyclic meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<editor>Thomas Ertl, Kenneth Joy, and Amitabh Varshney</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="215" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On issues of precision for hardware texture-based volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">C</forename><surname>Lamar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIE -The International Society for Optical Engineering</title>
		<editor>R. F. Erbacher, P. C. Chen, J. C. Roberts, and Craig M. Wittenbrink</editor>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="19" to="23" />
		</imprint>
	</monogr>
	<note>Visual Data Exploration and Analysis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">High-quality lighting and efficient pre-integration for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">B</forename><surname>Lum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brett</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwa-Liu</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Joint Eurographics-IEEE TVCG Symposium on Visualization 2004 (VisSym &apos;04)</title>
		<meeting>Joint Eurographics-IEEE TVCG Symposium on Visualization 2004 (VisSym &apos;04)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Area and volume coherence for efficient visualization of 3d scalar functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings San Diego Workshop on</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="27" to="33" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
	<note>ACM Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A two-step approach for interactive pre-integrated volume rendering of unstructured grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Roettger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Volume Visualization and Graphics Symposium</title>
		<editor>Roger Crawfis, Chris Johnson, and Klaus Mueller</editor>
		<meeting>Volume Visualization and Graphics Symposium</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="23" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Smart hardware-accelerated volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Roettger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Guthe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Joint Eurographics-IEEE TCVG Symposium on Visualization (VisSym &apos;03)</title>
		<meeting>Joint Eurographics-IEEE TCVG Symposium on Visualization (VisSym &apos;03)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="231" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hardware-accelerated volume and isosurface rendering based on cell-projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Röttger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<editor>Thomas Ertl, Bernd Hamann, and Amitabh Varshney</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="109" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The OpenGL Graphics System: A Specification (Version 1.5)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Segal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kurt</forename><surname>Akeley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Silicon Graphics, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A polygonal approximation to direct scalar volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics (Proceedings San Diego Workshop on</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sorting and hardware assisted rendering for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clifford</forename><forename type="middle">M</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barry</forename><forename type="middle">G</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><forename type="middle">L</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1994 Symposium on Volume Visualization</title>
		<editor>Arie Kaufman and Wolfgang Krueger</editor>
		<meeting>1994 Symposium on Volume Visualization</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="83" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Hardware-based ray casting for tetrahedral meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manfred</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Visualization</title>
		<editor>Greg Turk, Jarke J. van Wijk, and Robert Moorhead</editor>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="333" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Hardware-based view-independent cell projection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manfred</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="163" to="175" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Visibility ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="126" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Alpha dithering to correct low-opacity 8 bit compositing errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randall</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">C</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lamar</surname></persName>
		</author>
		<idno>UCRL-ID-153185</idno>
		<imprint>
			<date type="published" when="2003-03" />
		</imprint>
		<respStmt>
			<orgName>Lawrence Livermore National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
