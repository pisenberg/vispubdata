<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scout: A Hardware-Accelerated System for Quantitatively Driven Visualization and Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><forename type="middle">S</forename><surname>M C Cormick</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Inman</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">P</forename><surname>Ahrens</surname></persName>
							<email>ahrens@lanl.gov</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hansen</surname></persName>
							<email>hansen@cs.utah.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Roth</surname></persName>
							<email>roth@cs.utah.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Advanced Computing Lab Los Alamos National Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Scientific Computing and Imaging Institute The University of Utah</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Scout: A Hardware-Accelerated System for Quantitatively Driven Visualization and Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.6 [Computing Methodologies]: Computer Graphics-Methodology and Techniques Visualization systems</term>
					<term>hardware acceleration</term>
					<term>multivariate visualization</term>
					<term>volume rendering</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Quantitative techniques for visualization are critical to the successful analysis of both acquired and simulated scientific data. Many visualization techniques rely on indirect mappings, such as transfer functions, to produce the final imagery. In many situations, it is preferable and more powerful to express these mappings as mathematical expressions, or queries, that can then be directly applied to the data. In this paper, we present a hardware-accelerated system that provides such capabilities and exploits current graphics hardware for portions of the computational tasks that would otherwise be executed on the CPU. In our approach, the direct programming of the graphics processor using a concise data parallel language, gives scientists the capability to efficiently explore and visualize data sets.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The visualization and analysis process involves the investigation of relationships between the numerical and spatial properties of one or more data sets. Many different visualization processes use indirect mappings, such as transfer functions, to assign optical properties like color and transparency to data values. While these techniques can be powerful, they have had limited acceptance in the scientific community because they require scientists to work in a secondary data space (e.g. the transfer function domain). This often makes it difficult to efficiently express queries and mathematical operations that would be natural in the original data space. As the success of software packages like MATLAB and Mathematica have shown, it is beneficial to have the ability to directly perform mathematical operations when exploring and analyzing data. Although this approach is effective and expressive, due to the computational costs involved in evaluating mathematical expressions, it often fails to provide users with an interactive experience. The power and programmability of today's commodity graphics hardware provides a unique opportunity to help reduce the impact of these calculations.</p><p>We have developed Scout -a software system that provides expression based queries which are evaluated in the data space. In this case, we consider a query to be a set of relational and conditional expressions based on numerical values. This system reduces the computational bottleneck by utilizing the graphics processor <ref type="bibr">(GPU)</ref> In addition to reducing the workload on the CPU, Scout also benefits from the computational performance rates of the GPU. In our experiments, the graphics hardware routinely out-performs the main processor. This performance gain is due to the parallel, streaming architecture, and the high-speed local memory systems of the card. The GPU architecture also allows for derived values to be computed as part of the streaming process and thus avoids the need to allocate system memory for intermediate storage. Finally, by storing data sets on the graphics card we can amortize the cost of transferring data across the system bus, which would generally be a requirement if the CPU were responsible for computing derived values. It is important to note that this benefit often increases the amount of data that must be stored on the GPU.</p><p>In the following section, we discuss related efforts and present a brief review of the latest GPU related research activities. Section 3 provides an overview of the features and design of the Scout software and programming language. Section 4 presents the results of applying Scout to different visualization tasks. Finally, Section 5 discusses conclusions, improvements, and future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Expression Evaluation for Visualization</head><p>The calculator paradigm of deriving data from equations is utilized by the MATLAB and Mathematica systems, allowing scientists to compute and plot the results of various mathematical expressions <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b25">26]</ref>. These packages provide excellent insight into formal mathematical models, but are inefficient for processing large data sets, and thus not typically used. Data-flow systems such as OpenDX and SCIRun provide calculator interfaces through their data-flow modules <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b21">22]</ref>. These systems compute derived field data, but employ the CPU and memory of the host system. For large fields, the computation process of the derived field is noninteractive.</p><p>Moran and Henze describe a system based on the calculator paradigm, the Demand Driven Visualizer (DDV), for computation and visualization of fields derived from large datasets <ref type="bibr" target="#b17">[18]</ref>. This approach employs both sparse traversal and lazy evaluation to avoid computation at each grid location, thereby running faster than eager October 10-15, Austin, Texas, USA IEEE Visualization 2004 0-7803-8788-0/04/$20.00 ©2004 IEEE evaluation systems. This work is similar to Scout since both systems are based on the application of visualization to derived fields which are expressed by mathematical equations. The focus of DDV is to expedite the computation of derived fields by using lazy evaluation. Since this system runs entirely on general purpose processors, the result is a fast but non-interactive visualization system. Jankun-Kelly and Ma describe a spreadsheet-like system for data exploration <ref type="bibr" target="#b8">[9]</ref>. This system provides an interface through a scripting language for performing operations on data. As such, one can view this system as providing a calculator functionality that executes on the main CPU. Interactivity timings were not provided, but using the CPU without sparse traversal and lazy evaluation was shown to be non-interactive by Moran and Henze <ref type="bibr" target="#b17">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graphics Hardware</head><p>Since the 1990s the power of commodity graphics hardware has seen incredible growth. This has been realized in terms of performance, programmability, and increased arithmetic precision -all at an amazingly low price. Even though these capabilities have been primarily driven by the entertainment industry, many active research efforts are leveraging GPUs for advanced rendering, visualization, and general purpose computation.</p><p>As several efforts have shown, the streaming architectures of the latest graphics cards from ATI <ref type="bibr" target="#b1">[2]</ref> and NVIDIA <ref type="bibr" target="#b18">[19]</ref>, are capable of outperforming CPUs on specific computational tasks <ref type="bibr" target="#b7">[8]</ref>. In particular, the GPU has been used for several general scientific computing tasks. For example, Krüeger and Westermann, Goodnight et al., and Bolz, et al. have implemented numerical solvers on the GPU <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b12">13]</ref>. In addition, Lefohn et al. presented an interactive sparse-grid level set solver <ref type="bibr" target="#b13">[14]</ref>. The majority of these projects have focused on the acceleration of particular algorithms and have usually been implemented in low-level (assembly) language or with one of the higher-level graphics shading languages such as NVIDIA's Cg <ref type="bibr" target="#b15">[16]</ref>.</p><p>The Brook programming language allows users to program the GPU using a data streaming paradigm <ref type="bibr" target="#b3">[4]</ref>. Under this model, a new data type, referred to as a stream, is used to represent a collection of data which can be operated on in parallel. These streams of data are then operated on by kernels which are functions that execute a specific set of instructions on stream data. In comparison to the work described above, Scout and Brook allow the programmability of the GPU to be exposed directly to the user through a data parallel paradigm. Given the underlying streaming architecture of the GPU, Scout shares similarities with Brook. For example, data sets in Scout are equivalent to Brook's streams, and a Scout program is a kernel with a result that maps data values to colors. Unlike Brook, Scout is based upon a more traditional data parallel paradigm and provides an interactive development environment for the visualization and exploration of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">IMPLEMENTATION</head><p>Current graphics processors must be programmed directly using a graphics-specific API, such as OpenGL or DirectX. The clear disadvantage of this approach is that all operations must be expressed in terms of graphics primitives. In this section we present the details of Scout's underlying OpenGL-based architecture, the Scout programming language, and the details of the runtime environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data Model and Rendering</head><p>Scout represents all imported data sets as either one-, two-, or threedimensional OpenGL texture maps having from one to four channels. The main disadvantage of this texture-based representation is that only regular grid structures are directly supported. Onedimensional textures are most commonly used as lookup tables, while two and three-dimensional textures normally represent scientific data. Multi-channeled textures are most useful for representing vector fields or for packing multiple variables into a single texture. Data sets may be stored as bytes, shorts, integers, or floats. The particular data type and the number of channels in a texture may have an impact on how the data must be represented within a texture, and may also affect performance. For example, basic OpenGL floating point textures (GL FLOAT) must have values in the range [0, 1] and a four-channel texture may align better in memory than a three-channel texture, giving increased performance. The impact of normalized texture values is discussed further in Section 3.2.</p><p>After one or more data sets have been stored in texture memory, Scout allows users to write a program that maps data values to a final rendered image. The source code from this program is compiled to either a single fragment shader or a single vertex and fragment program pair. The Scout compiler currently generates low-level code that corresponds to the OpenGL ARB extensions GL VERTEX PROGRAM ARB and GL FRAGMENT PROGRAM ARB <ref type="bibr" target="#b14">[15]</ref>. Once these programs are downloaded to the GPU, geometry is rendered according to the types of data sets that are stored in texture memory. For two-dimensional data, a single quadrilateral (matching the given data set dimensions) is rendered. In the case of threedimensional data, view-aligned slices are rendered that implement texture based, direct volume rendering <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b24">25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Scout Programming Language</head><p>In designing Scout we had several goals for the programming language:</p><p>1. It should be simple and concise. The primary motivation for this was to make the language easy to learn and use. In addition, we wanted to assure that compilation times would be fast enough to guarantee interactive performance for the user.</p><p>2. It should reveal the parallel nature of the underlying hardware without complicating the language. This should be true for both the SIMD and the 4-vector arithmetic parallelism available on the GPU.</p><p>3. Where possible, the language should hide any nuances introduced by the OpenGL API or the graphics hardware.</p><p>4. It should provide the user with flexible methods for producing both general purpose computations and visualization results.</p><p>Of these goals, the most challenging are hiding the details of the graphics API and the specific hardware limitations of the GPU. Contemporary GPUs have many constraints; these include restrictions on the number of instructions a program may contain, the number of textures that may be active, the number of local temporary registers that can be used, and the number of parameters that may be passed in via the OpenGL interface. In addition, OpenGL (1.5) stores textures internally within the hardware as floating point values in the range [0 − 1]. This forces texture data to be normalized, and when used with scientific data can lead to the loss of important information. Recent OpenGL extensions have eliminated this restriction, allowing textures to be stored in an unnormalized 32-bit floating point format. Because current hardware does not support the blending of these 32-bit values in the frame buffer, they cannot be used when implementing direct volume rendering. When possible, Scout uses 16-bit float point values and blending for threedimensional texture based volume rendering. <ref type="bibr" target="#b0">1</ref> Fortunately, the first two goals for the Scout language are easier to achieve. The instruction set of the GPU is small, and recently added capabilities for flow control (e.g., loops, true branches, and subroutine calls) have not yet been implemented in Scout; therefore, only simple language structures are currently supported. Without considering instruction-level optimizations (e.g., scheduling) and multi-pass rendering, this limited functionality makes compilation relatively straightforward -provided that the language closely models the architecture of the hardware. Furthermore, because the assembly-level instructions of the GPU already use a SIMD and vector parallel paradigm, the task of supporting a data parallel language is greatly simplified. Finally, the constraints that vertex and fragment programs receive inputs via registers to which they cannot write, and produce outputs from which they cannot read, can easily be matched to a limited functional language. Given these advantages we have loosely based the Scout language on the C* Programming Language <ref type="bibr" target="#b22">[23]</ref>. This results in a language structure that is simple and can easily be applied to many areas within the scientific and visualization communities.</p><p>All Scout programs achieve their effect by assigning values to pixels in the output image. This assignment is made to the predefined 4-component vector variable, image, representing the output (RGBA) register of the fragment engine. The simplest Scout program is:</p><formula xml:id="formula_0">image = c;</formula><p>where c is a scalar constant. When assigning a scalar value to a vector value, the scalar value is simply replicated across all four components of the vector. In the case of the variable image, the channels are all clamped to the range [0, 1]. Assigning a floating point value in this range results in a gray-scale image.</p><p>The Scout language supports scalar and 4-component vector types, arithmetic operators (+, -, *, /), relational operators (&lt;, &lt;=, ==, =&gt;, &gt;, !=), and logical operators (&amp;&amp;, ||, !), matching the functionality of the equivalent operators in the C programming language. In addition, Scout provides built-in functions for all operators available on the fragment or vertex engines, such as sin, cos, pow, dotproduct, cross-product, and a few additional functions that are expanded in-line by the compiler, such as hsva, norm, global min, and global max.</p><p>In situations where 16-bit or 32-bit floating point textures are not available, or when data has been quantized into a non-floating point type, the Scout compiler automatically includes instructions that de-normalize texture values into the range of the original data. In the remainder of this section we will introduce the Scout language by presenting a series of small programs that operate on a twodimensional data set produced by the POP ocean model <ref type="bibr" target="#b5">[6]</ref>.</p><p>When working with data produced by POP it is common to use a land mask to represent locations where model results have not been computed. This mask contains 1 at locations where land is present and 0 for regions of water. The example presented in <ref type="figure" target="#fig_0">Figure 1</ref> introduces this mask (land), potential temperature at the ocean surface (pt), and a one-dimensional array of RGB colors (colormap). We also make use of the Scout functions, norm, to normalize values from any dataset into the range [0, 1], and positionsof, to return the number of elements (colors) in the color map. The simple program shown in <ref type="figure" target="#fig_0">Figure 1</ref>   Input data sets (textures) can be treated as either arrays or as scalars. When treated as scalars, they are implicitly accessed with the texture-coordinates of the current output pixel. This scalar syntax is natural for data-parallel computations, whereas array syntax is useful for referencing neighbors or values in a pre-computed lookup table.</p><p>Scout preserves the ability of the GPU to treat floating point values as indices (texture coordinates) of a data array. When such an index value falls between existing array elements, the hardware performs an interpolation between the neighboring values based on the relative position of the index. However, in contrast with assembly-level GPU programming, Scout array indices are based on the dimension of the given variable (data set). This policy matches the syntax used by many other languages for multi-dimensional array operations, and thus makes the language more familiar to scientists. The array-indices of nearest neighbors are simply ±1 in a given dimension, relative to the current data-parallel position of the pixel. The indices of this location are represented by the predefined variables i, j, and k. We also arrange, where possible, for array index expressions to be computed on the vertex engine. This is often more efficient, because the values need only be computed at the vertices and can then be generated via hardware-supported interpolation at all other points.</p><p>In the next example we add a conditional expression that isolates a specific range of temperature values. The sample code uses the hsva() function to produce an RGBA color described in terms of the HSV color space with the addition of an alpha channel. In comparison to the RGB color space, the continuous nature of the HSV space makes it more suitable for mapping colors to a range of data values. This approach allows users to define a color mapping dynamically, and thus potentially use many different mappings for different regions in the data. An rgba() function is also available, allowing users to define the output color as an additive combination of color channels. <ref type="figure" target="#fig_2">Figure 2</ref> shows both the code and the resulting image.</p><p>The display can easily be tailored with successive conditions to either emphasize or de-emphasize features, or to present multiple variables from one or more data sets. Furthermore, we can use spa-  tial criteria to define regions of interest. <ref type="figure" target="#fig_3">Figure 3</ref>, illustrates the use of mathematical expressions to define a circular clipping region, with a radius of 600 grid units, centered at the point (2400, 1000). The interior of this circle is rendered with temperature values using the same color mapping applied in <ref type="figure" target="#fig_0">Figure 1</ref>. The region outside of the circle is colored by a function that displays blue decreasing from full intensity to zero intensity, west to east, and green decreasing in an identical fashion from south to north. The built-in symbols i and j refer to the x and y coordinates of the current computational grid cell. The example code also introduces a function that returns the dimension of a variable along a given axis index, dimof.</p><p>The final component of the Scout implementation is the runtime layer that provides users with an interactive environment for the development of code and the exploration of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Runtime Environment</head><p>The Scout runtime environment consists of a user interface containing a code editor and a rendering window. The user interface provides support for invoking the Scout compiler in addition to a mouse-based interface for navigation (rotation, translation, and zooming) within the rendered data. A diagnostic window provides feedback when warnings or errors are detected in the source code or when hardware limits have been exceeded. The compilation of a Scout program results in the generation of an assembly level fragment program, and possibly an accompanying vertex program. These two programs are interdependent and are treated as a unit.</p><p>The assembly program(s) generated by the compiler depend on the creation of a OpenGL environment by the runtime system. For example, texture lookups depend upon variables being assigned to compiler specified texture-units on the GPU. These references are currently implemented by associating the compiled Scout program with a set of dependencies. The dependencies identify data sets used by the program and values for support of operations, such as normalization, queries of data-range, dimension-size, etc. When a compiled program is being executed, the runtime system first resolves all of the associated dependencies and then binds data to the proper texture units and loads local variables into the proper registers. Once these steps are complete, the associated geometry is generated and sent to the GPU for execution.</p><p>// Compute the distance from our location (i,j) to the center // of the circle clip region at (2400, 1000). float radius = sqrt(pow(abs(2400-i),2) + pow(abs(1000-j),2)); where (land == 1) image = 0; // Render land as black. else where (radius &lt; 600) // Color by pt within the circle. image = colormap[positionsof(colormap) * norm(pt)]; else // Color by spatial location. dimof() returns the dimension // of pt along the given axis index (0: x axis, 1: y axis). image = rgba(0, i/dimof(pt, 0), j/dimof(pt, 1), 1); </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>The development of Scout has been motivated by the need to solve advanced visualization and analysis problems in various application areas. In this section we present examples of this, with a particular focus on multi-dimensional transfer functions, multivariate visualization, and the derivation of data using the Scout language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Multi-dimensional Transfer Functions</head><p>Volume rendering applications commonly encounter data sets in which it is difficult to distinguish between regions due to overlapping boundaries. Multi-dimensional transfer functions are commonly used to address this issue, as demonstrated by Kniss et al. using the Simian volume renderer <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>. The flexibility of Scout's programming language allows the implementation of multidimensional transfer functions based on many different variables (limited only by the number of textures supported on the GPU).</p><p>To demonstrate the use of multi-dimensional transfer functions in Scout we have duplicated one of the results produced by the triangular widget used in Simian. Using Simian, it is possible to set the transfer function by probing the data and placing widgets interactively with keystrokes. While this is a powerful exploratory technique, these widgets do not support the use of direct quantitative bounds. We have implemented the triangular transfer function in Scout by using the density and the gradient magnitude of the computed tomography generated, tooth data set that was also explored by Kniss et al. <ref type="bibr" target="#b10">[11]</ref>. The domain of the transfer function is defined by the range of density values along the horizontal axis, U, and gradient magnitude values along the vertical axis, V . The implemented triangle function is an isosceles triangle positioned within the domain such that it's base is parallel to the U axis and the apex is pointed downward. The edges of this triangle are defined by the half angle at the apex θ , the minimum and maximum allowed gradient magnitudes G min and G max , and the density center point C of the triangle. To quantitatively calculate the triangle function for a given input value, we first calculate half the width of the triangle at the gradient magnitude gm using θ . The distance from the center, to the current density value d is calculated and clamped to width. If gm falls outside of the limits G min and G max alpha is assigned zero, otherwise, the alpha value is scaled according to the distance from the center tapering off to zero as it approaches the edges of the triangle. The Scout code presented in <ref type="figure" target="#fig_4">Figure 4</ref> shows the basic details of this implementation. For comparison, the figure shows the results produced by both Simian and Scout using triangular functions.</p><p>In Scout the elliptical widget can be succinctly described for a 2D transfer function similar to the 2D spatial clipping circle presented in section 3.2. While this approach is not as flexible for exploring unknown data, the ability to directly control the transfer function using quantitative expressions provides a versatile, and often more accurate interface for scientists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Multivariate Visualization</head><p>When analyzing computational modeling results, it is often valuable for scientists to study the relationships between several different variables. This can be especially true when exploring anomalies and temporal data. In this section we investigate the multivariate data produced by a simulation of an of an El Niño-Southern Oscillation (ENSO) event generated by the POP ocean model <ref type="bibr" target="#b5">[6]</ref>.</p><p>During normal Pacific Ocean conditions, the trade winds blow from east to west across the tropics. These winds cause warm surface water to pile up in the western portion of the Tropical Pacific. In the east, the water that has been pushed to the west is replaced by the upwelling of cooler water. The ocean state can therefore be summarized as increased sea surface height, increased potential temperature, and an increased thermocline depth in the western Pacific relative to the east. The thermocline is a sharp temperature gradient separating the upper layers of ocean water from those at depth. Under El Niño conditions, the east-west trade winds relax over the central and western Pacific. This results in a decreased sea surface height and an elevated thermocline in the west, and an increased sea surface height and a depressed thermocline in the east.</p><p>In order to explore the details of a simulated ENSO event, we have extracted a 414 × 128 × 17 region from a global ocean simulation. The visualization of ocean simulations is often difficult because the horizontal extent of the data is much greater than the depth. To make it easier to see details in the data, the data is resampled along the z axis to produce a 414 × 128 × 64 data set. Using Scout we visualize several key features that show the changes that occurred during the simulation of the 1998 El Niño. <ref type="figure" target="#fig_5">Figure 5</ref> shows the results.</p><p>The <ref type="figure">Figure presents</ref> land masses as tan colored regions rendered with diffuse lighting; with the western Pacific on the left-hand side of the image. The first condition that we are interested in studying is the difference between the potential ocean temperature during the January of the ENSO event and the mean of all January conditions from the model run. The rendered results show the regions where this difference exceeds 2.5 • C as solid magenta (in the east), and locations where the difference is less than −2.5 • C as solid blue (in the west). Both regions are clipped as they pass south of the equator. This result shows how the increased depth of the thermocline in the east causes an overall warming in the surface waters, while the shoaling of the thermocline in the west leads to cooler water temperatures. which is traditionally used as a proxy for the thermocline in the tropics. The thermocline for the January mean is also shown for the same temperature range; this surface is colored by the difference in sea surface height between the ENSO and the mean data. The differences are color mapped from blue (low) to red (high). Note the relationship between the two different thermoclines: the white, ENSO, surface is higher in the west and lower in the east. This shows, along with the differences in sea surface heights, the see-saw pattern that is consistent with the occurrence of an El Niño.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Computing Derived Fields</head><p>In the process of analyzing data it is often necessary for scientists to compute one or more derived values. This section demonstrates the computation of derived variables using Scout. The Terascale Supernova Initiative (TSI) project is currently studying the mechanisms responsible for driving core collapse supernovae <ref type="bibr" target="#b23">[24]</ref>. A core collapse supernovae occurs when a iron core forms in an aging super-giant star. This core is a result of several sequences of fusion reactions which come to a halt once the iron is produced. In this state, the core no longer supports these reactions, and internal gravity pulls inward on the core until it collapses into an incredibly dense region that will eventually become a neutron star. The core becomes so dense that the collapse stops, and a shock wave is sent outward through the gas layers that are rushing in to the fill the void left from the collapse. The expanding shock wave from the core, and the inward collapse of the outer gases result in the explosion of the star.</p><p>The goal of the computation presented below is to model the behavior of the core during the time in which the shock wave is expanding. The simulation is a hydrodynamics-only calculation in which the shock wave is modeled after it has moved approximately 200 km from the center of the star. The simulation is computed on a 320 × 320 × 320 grid and produces the following variables: pressure (p), density (ρ), and velocity ( − → v ). From these variables we can define two additional variables of interest: entropy (e) and tangential velocity (v t ). Entropy is given by the equation, e = p/ρ 4/3 .</p><p>Tangential velocity is computed as follows. Let − → r represent the radius vector from the center point C of the grid to a given location on the grid. Then for each point P on the computational grid:</p><formula xml:id="formula_1">− → r = (P x −C x )i + (P y −C y )j + (P z −C z )k.<label>(1)</label></formula><p>Next we compute the square of the radial velocity (v r ):</p><formula xml:id="formula_2">v 2 r = − → v • − → r − → r • − → r .<label>(2)</label></formula><p>This then allows us to compute the tangential velocity:</p><formula xml:id="formula_3">v t = − → v • − → v − v 2 r .<label>(3)</label></formula><p>Using these derived fields we can begin to explore the results produced by the simulation.</p><p>Due to the size of the full floating point data sets, it is not possible to fit two variables in the texture memory of most graphics cards, which are commonly limited to 256 MB. This is perhaps the most limiting factor to our approach of leveraging the GPU. In order to compute entropy and tangential velocity we have resampled the data to 256 × 256 × 256. <ref type="figure" target="#fig_8">Figure 6</ref> shows the computed entropy. The image was produced by a Scout program that computes entropy, selects two different ranges of entropy using a where statement, and finally colors them by the magnitude of the velocity field.</p><p>The first entropy range is between 0.070 and 0.076 and represents high entropy values. This region is partially clipped away to reveal the structure of the turbulent flow in the interior of the core. The second range (0.01 to 0.04) represents lower entropy values and isolates the details of the shock front.</p><p>The computation of v t gives insight into the structure and behavior of the flow created by the shock wave within the core. <ref type="figure" target="#fig_9">Figure 7</ref> shows the results produced by computing v t and volume rendering the results. The transparent white region represents low entropy values, and is displayed to show the shock front as a frame of reference. The shell is clipped away by two arbitrary clipping planes that were computed using the plane equation. The code for this example follows directly from the equations given above and is not presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">GPU Versus CPU</head><p>The ability to derive data values as part of the rendering process can reduce the amount of required system memory, and eliminate the travel of recomputed data between the CPU and GPU. It is important to note that these benefits often come at the price of requiring that more texture memory be used on the GPU. As noted earlier, this is a clearly a major disadvantage of using the GPU. In order to complete the comparison between the CPU and GPU this section reviews the performance of the computations carried out in Section 4.3. <ref type="table" target="#tab_2">Table 1</ref> presents the execution times for the computation of entropy, magnitude of the velocity field, and the tangential velocity. The table compares two different versions of the CPU code. The first version is compiled using GNU GCC 3.  which is capable of producing code that uses the Streaming SIMD Extensions (SSE). The use of the SSE instructions can result in dramatic performance improvements. The CPU timing results are measured using the hardware counters available on the main processor. The benchmarks were run on a 3.0 GHz Intel Xeon EM64T processor with 4 GB RAM and an NVIDIA Quadro 3400 (connected via PCI Express).</p><p>The GPU benchmarks are measured by instrumenting Scout with the CPU's hardware counters and then rendering the same image multiple times and taking the average of the resulting execution times. In order to study the performance of the GPU directly, the cost of the first rendered frame is discarded to avoid including the costs of transferring textures and other data to the GPU. It is important to note that this does not present an accurate overall view of Scout's performance but is done intentionally to measure performance characteristics of the graphics hardware.  All Scout programs incur an overhead cost associated with the process of compiling code, downloading textures, downloading the compiled fragment and vertex programs, sending the necessary ge- ometry to the GPU, and other tasks carried out by the runtime system. Of these operations texture download rates clearly dominate the overhead execution time; the other operations require only a few microseconds each to complete. Large 32-bit floating point textures can be downloaded at approximately 200-300 MB/second. Our benchmarks show that a large data set, such as the TSI velocity field, takes approximately 1 second to download to the graphics card. It is possible to download textures at a faster rate (700-800 MB/second) over PCI Express -these rates require the use of bytebased texture data and therefore were not benchmarked. Overall, the GPU can achieve very fast computational rates, but in order to outperform the CPU it is necessary to amortize the cost of the transfer of data between main memory and the graphics card.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSIONS AND FUTURE WORK</head><p>This paper has introduced Scout, a hardware-accelerated software system for the visualization and analysis of data using quantitative, query based expressions. This approach allows scientists to work directly in the original data space using a direct programming methodology. By leveraging the GPU as a co-processor we have allowed for interactive response rates, reduced main memory costs, and, in several situations, decreased the amount of data transfered over the system bus.</p><p>Although Scout allows the use of quantitative expressions to control the visualization process, it does not yet provide the user with a complete set of general purpose operations or direct quantitative feedback. Supporting these features is critical to providing a complete analysis environment. The task of providing more advanced language features on the GPU can be challenging. In particular, the limits of the GPU (number of supported instructions, number of textures, and number of temporary variables) require the determination and management of multiple rendering passes. We are collaborating with UC Davis to incorporate their multi-pass partitioning technology to limit the impact of these restrictions <ref type="bibr" target="#b20">[21]</ref>.</p><p>Although Scout provides interactive performance, there are many data sets that easily exceed the capabilities of a single GPU. To address this challenge we are exploring the use of Scout in a parallel, cluster-based, environment. In addition, there are likely to be many situations where a GPU-based co-processor may not be the most advantageous approach. In this situation we are investigating the use of other processor technologies to help improve the data visualization and analysis process.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Sample Scout code and the resulting image showing the color mapped potential temperatures and black landmasses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>where (land == 1) image = 0; // render land as black. // select data range(s) of interest and render as color. else where (pt &lt; 2.375 || (pt &gt;= 21.0 &amp;&amp; pt &lt; 29.5)) image = hsva(240 -(norm(pt) * 240), 1,1,1);// blue to red else image = 0.6; // outside data range colored by gray pixels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Sample source and the resulting image showing the selected ranges of temperature values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Scout code and rendered image showing temperature within a circular clipping region and spatially-controlled coloring outside of the region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>//Figure 4 :</head><label>4</label><figDesc>Compute the half width of the triangle. width = tan(theta) * gm; // Compute and clamp the distance from the // center to density. where (d &gt;= (C -width) &amp;&amp; d &lt; (C + width)) dist = abs(d -C); else dist = width; // Scale alpha value by distance from the center. where (gm &gt; G_min &amp;&amp; gm &lt; G_max) alpha = 1 -dist / width; else alpha = 0.0; Volume rendered results using triangular transfer functions from Scout (top) and Simian (bottom). Both images are rendered with diffuse lighting. This was implemented directly in Scout, but removed from the sample code for clarity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5</head><label>5</label><figDesc>also includes the position of the thermocline near the equator. The white strip of data shown in the rendered image represents the position of the El Niño thermocline over the temperature range 19.0 • C -21.0 • C;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>The result of studying several features that are consistent with an El Niño event. Anomalies in water temperature are shown as solid magenta and blue and are clipped south of the equator. The white region represents the ENSO thermocline and the color mapped region shows the mean January thermocline; the colors show the difference in sea surface heights. Land masses are rendered in tan. All variables have been rendered with diffuse lighting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>3.3 with full optimization (-O3) and the second uses version 8.0 of the Intel C++ compiler // Compute entropy. float ent = pressure / pow(density, 4.0/3.0); // Compute |v|. float vmag = sqrt(dot3(v, v)); where(i &gt; 115 &amp;&amp; ent &gt; 0.070 &amp;&amp; ent &lt; 0.076) image = hsva(...); else where(ent &gt; 0.01 &amp;&amp; ent &lt; 0.04) // shock wave image = hsva(...); else image = 0; // transparent black</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Volume rendered results of two selected entropy ranges colored by corresponding velocity magnitude. Both the entropy and velocity magnitude were computed directly using Scout.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>A volume rendered representation of tangential velocity. The shell of low entropy regions is shown as transparent white to emphasize the shock front as a frame of reference.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>displays black for land values and mapped color values for ocean temperatures.</figDesc><table><row><cell>// Display color mapped potential ocean surface temperature.</cell></row><row><cell>where (land == 1)</cell></row><row><cell>image = 0; // Render land as black.</cell></row><row><cell>else</cell></row><row><cell>// Map temperature values into color look-up table.</cell></row><row><cell>image = colormap[positionsof(colormap) * norm(pt)];</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Table 1: CPU vs. GPU computation times in seconds. All times reflect computation times only, overhead costs are not included. Values in parentheses show the speed up achieved in relation to the times presented in the CPU column.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">NVIDIA's NV4X series of hardware currently supports this feature<ref type="bibr" target="#b18">[19]</ref>.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">ACKNOWLEDGMENTS</head><p>This work was sponsored by the Mathematical, Information, and Computational Sciences Program which is part of the DOE Office of Science. A very special thanks to John Blondin and Tony Mezzacappa of the TSI project, and JoAnn Lysne, Matthew Hecht and Mat Maltrud from the COSIM project. Without their help, lively discussions, and enthusiasm, this paper would have been impossible. Thanks to Nick Triantos from NVIDIA and Mark Segal at ATI for their technical help as well as donating hardware to our effort. Gordon Kindlmann's help and advice as well as his nnrd software were used for data manipulation. Finally, thanks to the reviewers for their comments and suggestions. This paper has been released under LA-UR-04-2373.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An extended data-flow architecture for data analysis and visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Treinish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;95</title>
		<meeting>Visualization &apos;95</meeting>
		<imprint>
			<publisher>IEEE CS</publisher>
			<date type="published" when="1995-10" />
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ati</forename><surname>Ati Technologies</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Inc</surname></persName>
		</author>
		<ptr target="http://www.ati.com" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Sparse matrix solvers on the gpu: Conjugate gradients and multigrid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Bolz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Farmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eitan</forename><surname>Grinspun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Schröder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="917" to="924" />
			<date type="published" when="2003-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Brook for GPUs: Stream computing on graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Sugerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kayvon</forename><surname>Fatahalian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics -SIGGRAPH</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Accelerated Volume Rendering and Tomographic Reconstruction Using Texture Mapping Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nancy</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium On Volume Visualization</title>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A reformulation and implementation of the Bryan-Cox-Semtner ocean model on the Connection Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Dukowicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Malone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Atmos. Ocean. Tech</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="195" to="208" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A multigrid solver for boundary value problems using programmable graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nolan</forename><surname>Goodnight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cliff</forename><surname>Woolley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Lewin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Humphreys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware</title>
		<imprint>
			<date type="published" when="2003-07" />
			<biblScope unit="page" from="102" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">General-Purpose Computation Using Graphics Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Harris</surname></persName>
		</author>
		<ptr target="http://www.gpgpu.org" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Visualization exploration and encapsulation via a spreadsheet-like interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Jankun-Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="275" to="287" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Large-scale computational science applications using the SCIRun problem solving environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Supercomputing</title>
		<meeting>Supercomputing</meeting>
		<imprint>
			<publisher>IEEE CS</publisher>
			<date type="published" when="2000-11" />
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Interactive volume rendering using multi-dimensional transfer functions and direct manipulation widgets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gordon</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preceedings of IEEE Visualization</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="255" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multidimensional transfer functions for interactive volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gordon</forename><surname>Kindlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="270" to="285" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Linear algebra operators for GPU implementation of numerical algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="908" to="916" />
			<date type="published" when="2003-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interactive deformation and visualization of level set surfaces using graphics hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Kniss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The OpenGL Extensions Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Lengyel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Charles River Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Cg: A system for programming graphics hardware in a C-like language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">R</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Steven Glanville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kurt</forename><surname>Akeley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">J</forename><surname>Kilgard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="896" to="907" />
			<date type="published" when="2003-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mathworks</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note type="report_type">The Mathworks -Products -MATLAB</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Large data visualization with demand-driven calculation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Henze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;99</title>
		<meeting>Visualization &apos;99</meeting>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="27" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nvidia</forename><surname>Home</surname></persName>
		</author>
		<ptr target="http://www.nvidia.com" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Open Visualization Data Explorer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Opendx</surname></persName>
		</author>
		<ptr target="http://www.opendx.org" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mio: Fast multipass partitioning via priority-based instruction scheduling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Riffel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><forename type="middle">E</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kiril</forename><surname>Vidimce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Hardware</title>
		<imprint>
			<date type="published" when="2004-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Scientific Computing Problem Solving Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Scirun</surname></persName>
		</author>
		<ptr target="http://software.sci.utah.edu/scirun.html" />
	</analytic>
	<monogr>
		<title level="m">Scientific Computing and Imaging Institute (SCI)</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Thinking Machines Corporation. C* User&apos;s Guide</title>
		<imprint>
			<date type="published" when="1991-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tsi. Terascale Supernova Initiative</surname></persName>
		</author>
		<ptr target="http://www.phy.ornl.gov/tsi/" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Direct Volume Rendering via 3D Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orion</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>UCSC-CRL-94-19</idno>
		<imprint>
			<date type="published" when="1994-06" />
		</imprint>
		<respStmt>
			<orgName>University of California at Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfram</forename><surname>Research</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mathematica</surname></persName>
		</author>
		<ptr target="http://www.wolfram.com" />
		<title level="m">The Way the World Calculates</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
