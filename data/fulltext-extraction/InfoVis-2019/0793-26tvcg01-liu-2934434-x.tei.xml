<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SmartCube: An Adaptive Data Management Architecture for the Real-Time Visualization of Spatiotemporal Datasets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Can</forename><surname>Liu</surname></persName>
							<email>can.liu@pku.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cong</forename><surname>Wu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanning</forename><surname>Shao</surname></persName>
							<email>hanning.shao@pku.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Senior Member, IEEE</roleName><forename type="first">Xiaoru</forename><surname>Yuan</surname></persName>
							<email>xiaoru.yuan@pku.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of EECS</orgName>
								<orgName type="laboratory">are with Key Laboratory of Machine Perception (Ministry of Education)</orgName>
								<orgName type="institution">Peking University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">National Engineering Laboratory for Big Data Analysis and Application, Peking University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">SmartCube: An Adaptive Data Management Architecture for the Real-Time Visualization of Spatiotemporal Datasets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/TVCG.2019.2934434</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>data management, spatial-temporal data</keywords>
			</textClass>
			<abstract>
				<p>Interactive visualization and exploration of large spatiotemporal data sets is difficult without carefully-designed data preprocessing and management tools. We propose a novel architecture for spatiotemporal data management. The architecture can dynamically update itself based on user queries. Datasets is stored in a tree-like structure to support memory sharing among cuboids in a logical structure of data cubes. An update mechanism is designed to create or remove cuboids on it, according to the analysis of the user queries, with the consideration of memory size limitation. Data structure is dynamically optimized according to different user queries. During a query process, user queries are recorded to predict the performance increment of the new cuboid. The creation or deletion of a cuboid is determined by performance increment. Experiment results show that our prototype system deliveries good performance towards user queries on different spatiotemporal datasets, which costing small memory size with comparable performance compared with other state-of-the-art algorithms.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Real-time interactive visualization of large spatiotemporal data is difficult without an efficient way to aggregate the original data sets. Often data is pre-aggregated over certain constraints in interactive scenarios. Data Cube <ref type="bibr" target="#b9">[10]</ref> pre-computes and stores all aggregates of datasets on every possible combination of dimensions. An aggregation query can immediately get the results from the pre-computed data cubes. Many visualization systems organize data structures based on data cubes for real-time response.</p><p>In a data cube, the aggregation of certain dimensions combination is called a cuboid, which stores all the possible aggregates on a combination of several dimensions. For example, the data cube of the dataset with dimensions D = {country, language, device} has 2 3 cuboids. One of the cuboids is {country, language, all}, which stores the aggregates of dimension {country, language}, i.e., all the possible values in the country × language. The memory usage of the data cube grows exponentially as the number of dimension increases. A series of works have been done to reduce memory usage in data management with data cubes. One of those solutions is to store only a subset of the cuboids, while omitting other rarely-visited cuboids.</p><p>For example, TimeLattice <ref type="bibr" target="#b20">[21]</ref> introduces a method to reduce the number of pre-computed cuboids by only storing cuboids with partial order relations along temporal dimensions, such as cuboids with dimension combination {year, month, day, hour}, {year, month, day}, {year, month}, and {year}. Another method to reduce space is to share memory among cuboids as much as possible. Nanocubes <ref type="bibr" target="#b16">[17]</ref>, one of such algorithms, builds a tree-like structure to store a data cube, in which cuboids share nodes when possible.</p><p>However, both approaches only improve on a limited range of data and tasks. On the one hand, in data management, nanocube is difficult to organize the dense time series data with many constraints in the temporal dimension, for memory usage grows rapidly when the number of dimensions increases. The experiment in TimeLattice <ref type="bibr" target="#b20">[21]</ref> indicated that the memory usage of nanocube was over 100 times of TimeLattice in the dense time series. On the other hand, TimeLattice cannot handle queries other than time series.</p><p>These algorithms cannot adapt to various datasets mainly because of the diversity in datasets and tasks. Different spatiotemporal datasets have different dimension properties. For example, some time dimensions have partial order relations while some other dimensions are independent. These properties may lead to different performance in memory and time usage. Given a new dataset, the visualization system designers need to carefully choose the suitable algorithm for the query of the visualization tasks.</p><p>Apart from the low latency requirement, there are some resource limitations on the hardware (e.g., memory). For large data management, the most significant resource limitation is the memory size, which will affect the performance when the data I/O in the disk is needed. Considering the diversity in datasets and tasks, the limits in memory, and the interactive requirement, ideally, we need better data structures or management algorithms to handle different datasets and tasks scenarios with lower memory usage and high interactive performance.</p><p>To meet these requirements, this paper proposes an adaptive spatiotemporal data management framework, SmartCube, which can update itself according to user queries. A user query can be translated to data aggregates on a data structure, which can be fit into the specific cuboids. For example, when a user wants to explore the aggregated value of each hour in 24 hours of the different days of a week, the cuboid with the day week × hour dimension can be used for this query. The diversity in the query pattern leads to different importance in the cuboids, which guides the SmartCube to manage the cuboids by keeping the valuable cuboid and omitting the trivial ones to save the memory. SmartCube changes its structure by operating the creation and removing in the cuboid to reach a low latency on queries. To make an adaptive data structure framework, the machine learning model can be combined to enhance the performance. We show the possibility of deep learning models to determine cuboids that need to be initialized at the initialization process. We build an LSTM-model that takes the statistic property of the data set as input and outputs the information of the initialized cuboids at the beginning.</p><p>We conduct several experiments on different data sets under different query tasks. Compared with some state-of-the-art algorithms, SmartCube requires much smaller memory and faster performance in most scenarios.</p><p>The contributions of this work are as follows.</p><p>1. We introduced SmartCube, a data structure adaptive to different type of spatial-temporal datasets and query tasks by operating the cuboids during query process; 2. We built an update algorithm that can create and delete cuboids in SmartCube dynamically 3. We proposed the algorithm for real-time query in the dynamic data structure, which can change its query route according to the structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>High efficient data management is an important topic for visualization <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b31">30,</ref><ref type="bibr" target="#b37">36]</ref>. The large size of datasets and the low-latency visualization require the data structure to be efficient. The real-time interaction with the system can affect the exploration. For example, as Liu and Heer observed <ref type="bibr" target="#b17">[18]</ref>, a delay of 500 ms harms users' explorations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Efficient Data Management for Visualization</head><p>Several methods were proposed to improve the response time to support real-time visualizations. Some increase the resource for data management. For example, VisReduce <ref type="bibr" target="#b12">[13]</ref> by Im et al. computes visualization results in a distributed fashion using a MapReduce <ref type="bibr" target="#b5">[6]</ref> algorithm and data compression. GPU acceleration is also used <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref> for higher performance. However, increasing the calculation resource can not totally solve the problem.</p><p>If some precision loss is allowed, approximate techniques <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9]</ref> could be taken. BlinkDB <ref type="bibr" target="#b0">[1]</ref> allows interactive queries over extremely large datasets with approximate results by sampling. Stolper et al. presented a framework for visual analysis progressively <ref type="bibr" target="#b29">[28]</ref>. Online aggregation <ref type="bibr" target="#b11">[12]</ref> is a method to provide estimated results for the user with low latency and then increase the accuracy at the process of waiting for the query results. Wang et al. proposed NNCubes <ref type="bibr" target="#b33">[32]</ref>to train a deep neural network to synthesize the query answer to support the visualizations.</p><p>Tree structure has a wide range of applications in data management. The partitioning in spatial data often uses the KD-tree method to discretize the data space using binary encoding <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b36">35]</ref>. STIG <ref type="bibr" target="#b7">[8]</ref> combines CPU and GPU for parallel processing based on traditional KDtree. The Quad-tree uses a fixed spatial partitioning which divides the block into four sub-blocks in the next level <ref type="bibr" target="#b25">[25]</ref>. There are other structures, such as R-tree <ref type="bibr" target="#b32">[31]</ref>, STR-tree <ref type="bibr" target="#b6">[7]</ref> and KDB-Tree <ref type="bibr" target="#b23">[24]</ref>. The methods above mainly focus on spatial dimension management.</p><p>Besides, to predict the users' actions is also a choice. Battle et al. proposed Forecache <ref type="bibr" target="#b1">[2]</ref> to predict user actions and loads related datasets before the query to improve system performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data Cubes-Based Method</head><p>In spatiotemporal data, the time has multiple periodic dimensions, and its analysis tasks need to be queried under different combinations of dimensions; while spatial distribution faces huge resolution challenges, and spatial dimensions may need to be divided into more detailed dimensions for indexing. In the analysis of multi-dimensional spatiotemporal data, the content is often needed to be aggregated over several dimensions. The data cube <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b35">34]</ref> solves this need by calculating data values for any combination of dimensions to support rapid exploration analysis, and it can lead to extremely low latency. Data cubes have good query performances, but computing all data cubes requires huge memory cost. As the number of dimensions increases, the memory required explodes exponentially.</p><p>There are two kinds of methods to reduce the usage of memory. One is to share memory between cuboids. Lins et al. proposed a treeshaped data cube, Nanocubes <ref type="bibr" target="#b16">[17]</ref>, in which all cuboids are shared in a single tree-like structure. They save the memory by sharing nodes and create nodes only when necessary. When the original data is sparsely distributed, there will be more shared nodes. However, this method does not essentially solve the problem of the memory of the data cube explosion as the number of dimensions increases. The main difference between Nanocubes and previously published sparse coalesced data cubes such as Dwarf cubes <ref type="bibr" target="#b26">[26]</ref> is in the design of aggregations across spatiotemporal dimensions.</p><p>The other way is to store only a part of the cuboids. Data cubes have different optimizations in spatiotemporal data sets with different characteristics. For a dataset biased toward the time dimension, Miranda et al. proposed TimeLattice <ref type="bibr" target="#b20">[21]</ref> by setting several dimensions, such as year, month, and day, in the time grid without pre-calculating the combination of all dimensions.</p><p>The memory footprint of its data structure is very small. For queries that are not in its stored cuboids, the query can be implemented by DRILL DOWN and ROLL UP operations. Compared with Nanocubes, Hashedcubes <ref type="bibr" target="#b22">[23]</ref> reduced memory usage to a greater extent. It uses a linear array to store the data and calculates the bounds of each dimension based on the value of the node. However, when the query does not satisfy the order of the indices, it needs to calculate the result on the fly. In the management of biased spatial data, unlike the storage of geographic grid quadtrees, Li et al. proposed a cluster-based data cube based on semantics. The structure can represent the concept of "country-province-county" <ref type="bibr" target="#b15">[16]</ref>. Liu et al. decomposed the data cube into a set of 3D and 4D subcubes and data slices to reduce the number of combination of dimensions, and the data slice allows it to take advantage of parallel processing on the GPU <ref type="bibr" target="#b18">[19]</ref>. However, it does not change the time complexity.</p><p>In addition to pure data cubes, there are extensions for specific tasks in visualization analysis. Gaussian Cubes proposed by Wang et al. <ref type="bibr" target="#b34">[33]</ref> are extensions to data cubes. In addition to the functions supported by traditional data cubes, it adds some modeling variables and precalculates enough statistical data, such as Gaussian distribution, ordinary least squares, and PCA, to accommodate some linear models and provide more data exploration. TopKube <ref type="bibr" target="#b21">[22]</ref> is also an extension to Nanocubes by ranking objects and answering top-k queries to find potential trends. Li et al. proposed SemanticsSpace-Time Cube <ref type="bibr" target="#b14">[15]</ref> by considering the text's semantic to help analyze the text-related spatiotemporal scenarios.</p><p>Compared with these works, especially Nanocubes, our method does not pre-compute all cuboids in the beginning. Instead, we choose some valuable cuboids based on some rules such as statistics of the data structures generated by data sets and querying frequency. Then, we reduce memory usage, and improve performance with more cuboids that change adaptively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METHOD</head><p>We propose SmartCube, an adaptive data structure for spatiotemporal data sets, to reach low-latency with less memory cost for different spatiotemporal datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Method Overview</head><p>Rather than querying on the dataset to get detailed items, real-time visualization often requests aggregated values, such as count, sum, minimum, maximum, and average. Data Cube <ref type="bibr" target="#b9">[10]</ref> is a structure that stores all the possible aggregates of the dataset.</p><p>As the number of dimensions increases, the memory usage of the data cube grows exponentially. The number of cuboids is 2 d if the number of dimensions is d. The cuboids in a data cube are not equally important, since some of them are used more frequently than others. Those being hit by query frequently are the valuable cuboids. Those less used consume a considerable amount of memory while devoting nearly nothing to improve the query efficiency. SmartCube is designed to be able to manage the cuboids it stores during the query process, i.e., it may create or delete cuboids dynamically when queries hit or miss for certain cuboids. As a result, the flexible data structure maintains efficiency by only storing the most valuable cuboids and removing those less valuable cuboids.</p><p>To reduce the memory usage, SmartCube stores all cuboids in a uniform hierarchical structure to support sharing of the nodes of cuboids. We develop an updating algorithm on the tree by creating and deleting cuboids dynamically. To query the structure based on the existed pre-computed cuboids, we develop a query engine that can choose the most efficient route in the tree to reach high performance. <ref type="figure">Figure 1</ref> shows the workflow of SmartCube. The workflow can be divided into an adaptive data structure part and supported algo-  <ref type="figure">Fig. 1</ref>. The workflow of SmartCube. According to the original spatiotemporal data set, the algorithm builds the initial structure with the finest cuboid, which contains the finest aggregates. A machine learning based model can be added as an additional part to decide the cuboids that need to be created based on the statistic of the dimensions. The cuboids adding algorithm adds the cuboids to the data structure accordingly. SmartCube records user queries, and an updating decision making part decides whether a cuboid should be created or deleted according to the query records.</p><p>rithms part. For the data structure aspect, the original dataset is loaded to build the data structure with the finest cuboids. With a carefullydesigned structure and the cuboid structure updating algorithm, the data structure can be updated dynamically. During the query process, the updating algorithm decides what cuboids to keep in the memory and when to create new cuboids. As an additional part, a prediction model can be added to decide which cuboids to be created at the beginning to address the cold-start problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Structure Definition</head><p>We first discuss the generic concept of data cubes. We then discuss SmartCube, which is an adaptive tree-like structure version of data cubes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Data Cubes</head><p>Data cube <ref type="bibr" target="#b9">[10]</ref> is a structure to handle data aggregate (e.g., count, sum, max, min) queries efficiently. The data cube of a dataset with dimension set</p><formula xml:id="formula_0">D = {d 1 , d 2 , ..., d n } has 2 n cuboids C = {c 1 , c 2 , ..., c n }, in which c i ∈ {d i , all}, i = 1, 2, ..., n.</formula><p>We call C a k-dimensional cuboid when k = |{c|c ∈ C ∧c = all}|. Each cuboid corresponds to an element of the power set of D. We use value all to represent the aggregate attributes. A cuboid with c i = all means that this cuboid aggregates on d i dimension. We use |c| to represent the cardinality of dimension c. Particularly, the cardinality of all is 1, i.e., |all| = 1.  For example, as <ref type="figure" target="#fig_0">Figure 2</ref> shows, given a dataset of the phone sales in some countries in several years, i.e., D = {country, phone, year}. There are 2 3 cuboids in the data structure. In the right box of <ref type="figure" target="#fig_0">Figure  2</ref>, the cuboid {all, phone, year} is a 2-dimensional cuboid that aggregates over dimension country and stores value of {phone, year} dimensions, e.g, iPhone sale in 2018.</p><p>In a data structure, a cuboid C can be calculated based on another cuboid C when the dimensions in C is a subset of that in C .</p><formula xml:id="formula_1">For C = {c 1 , c 2 , ..., c n } and C = {c 1 , c 2 , ..., c n }, We say C is the base cuboid of C, C C , if |c i | ≤ |c i |, i = 1, 2, ..., n.</formula><p>Among the base cuboids, the one that shares the smallest different dimensions (levels) is the closest base cuboid (CBC). For example, the cuboid {all, phone, year} is a base cuboid of {all, phone, all}. The cuboid with all the dimensions (levels) cannot be converted from any other cuboids, which is called the finest cuboid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">SmartCube Structure</head><p>The index dimensions in spatiotemporal data sets include spatial, temporal, and categorical dimensions. A query of the data set sets constraints on those dimensions to define the data items and returns the aggregate value of those items. To support the aggregates query on spatial, temporal, and categorical dimensions, a SmartCube data structure is built by organizing those dimensions on the original dataset.</p><p>SmartCube needs to index on the spatial, temporal, and categorical dimensions to support the queries. We build the index of spatial and categorical dimensions based on nanocubes <ref type="bibr" target="#b16">[17]</ref>. We adopt the similar tree-like structure but each cuboid is independent. The categorical dimension is directly indexed by its value, while the range of temporal and spatial dimension cannot directly use the value because the value is tremendous and continuous. Thus, we need further division and discretization on those dimensions. Considering the different properties between spatial and temporal dimensions, we discuss them separately. To better describe the sub-dimensions of dimension (e.g., spatial or temporal dimension), we use the level to present the sub-dimension (e.g., year and month in the temporal dimension), and use the word path to refer to the ordered level series inside a dimension. Take the structure of <ref type="figure">Figure 3</ref> as an example, the year and month are the levels of the temporal dimension and the path is {year, month}.</p><p>Categorical Dimension. The index of the categorical dimension is built directly by the value. There is no extra division in the categorical dimension. To use the uniform concept level and path, we define the categorical level l as the categorical dimension itself, and the path p = {l}.</p><p>Spatial Dimension. Quad-tree is often used in spatial data management <ref type="bibr" target="#b25">[25]</ref>. It can be regarded as a cross binary division on latitude and longitude attributes. In SmartCube, quad-tree is used to build the hierarchical layers in the spatial dimension, which is highly efficient. Specifically, a 25-layer hierarchical quad-tree can make a precision loss of less than 1 meter, which is accurate enough to re-  <ref type="figure">Fig. 3</ref>. The illustration of the updating algorithm. The structure on the leftmost only has Cuboid 1. This cuboid has all the possible levels, which are spatial levels S 1 , S 2 , and categorical level C, and temporal levels Year, month. The very right one is the tree with only cuboid 2 that aggregated on level S 2 . In the middle are the virtual tree created during the process of creating Cuboid 2, and the tree with both Cuboid 1 and Cuboid 2 as well. Two cuboids share the nodes pointed by the dashed arrow line.</p><formula xml:id="formula_2">Spatial dimension (2 levels) Categorical dimension (1 level) 0,1 1,0 1,1<label>(1)</label></formula><p>fer to any position in the world. The spatial levels can be presented as {s i |i ≤ depth m }, in which s i is the i-th layer on the quad-tree division and depth m is the max spatial division layers (we often set max depth as 25). The path of the spatial dimension can be presented as {s 1 , s 2 , ..., s depth m }. The granularity goes finer along the path of the spatial dimension. In the division of the spatial dimension, the deeper level depends on the upper level because the deeper level is the sub-division of the upper level. Thus there would not be the cuboid with combination skip in the levels of a dimension. e.g., Cuboid C = {s 1 , all, s 3 } is not meaningful in real-world scenarios. The cuboids we can construct on the spatial dimension is the combination along the path order</p><formula xml:id="formula_3">{s 1 , s 2 , s 3 , ..., s i , all, all,..., all depth m −i }, i ≤ depth m .</formula><p>For a more compact representation, the alls at the tail of spatial dimension can be omitted and the spatial dimension can be presented as:</p><formula xml:id="formula_4">C = {s 1 , s 2 , ..., s p },</formula><p>where p ≤ depth m , and the all levels are omitted.</p><p>Temporal Dimension. Users would be interested in the aggregates time series on several levels or certain resolution. However, the levels of the temporal is complex. On one hand, there are some natural orders in the temporal dimension. We should consider the natural properties. For month and year, a month is defined under a year and a year always contains 12 months, we say the month is covered by year. On the other hand, some levels in the dimension are independent. For example, the week follows it's own order and is independent of month, and vice versa.</p><p>We define the partial order on the levels of temporal dimension, in which one level is totally covered by the next level. The realworld partial order chains built by connected partial order levels, e.g., second ≺ minute ≺ hour ≺ day month ≺ month ≺ year and second ≺ minute ≺ hour ≺ day year ≺ year. in which A B is the level of n-th A inside a B, e.g., day month represents the n-th day level under a month. Path <ref type="bibr" target="#b0">(1)</ref> presents that there are several month inside a year, and several day month inside a month, etc. Besides, if the path can fully recover the time stamps in certain resolution, we call this path a partial order level list (POLL), e.g., the hour ≺ day month ≺ month ≺ year is a POLL, while second ≺ minute ≺ month ≺ year is not. The division under the POLL can handle queries under certain resolutions and can get a time series as a result by drilling down and rolling up the aggregates over certain dimensions, which can support the times series query under the resolution. However, a POLL path is not enough to support the the query with levels across POLLs, e.g, query on the month and day week are not supported by any POLLs. To support the query across POLLs, SmartCube extends the POLLs with extra levels as the base path. More than one path is allowed in SmartCube. The requirements are as follows.</p><p>• At least one path covers a POLL, supporting a complete query on time series.</p><p>• Unlike the spatial dimension which only has one path inside the dimension, there can be several ways to discretize the temporal dimension.</p><p>• The new path can be built according to another path. The new path is a sub-path of the existing path.</p><p>• The level order inside a path is not allowed to conflict the order in any POLL, e.g., the path day month is always finer than month, while there is no constraint on day week and day month .</p><p>Formally, the path set in the time P = {p i |i &lt; M}, M is the path number,</p><formula xml:id="formula_5">p i = {t i 1 ,t i 2 , ...,t i depth i }.</formula><p>SmartCube seeks a tradeoff between the partial order relation and the demands of the full user query. By default, we set the paths with two paths P = {{year, month, day month , day week , hour}, {day week , hour}}.</p><p>Cuboid. With the definition, the cuboid can be formulated as:</p><formula xml:id="formula_6">C = {{s 1 , s 2 , ..., s p }, {d 1 }, {d 2 }, ...{d Q }, {t i 1 ,t i 2 , ...,t i r }} Where p ≤ depth m , Q is the category dimension number, r &lt; depth i , i &lt; M.</formula><p>We also use schema to present a cuboid, which is an array with the depth (i.e., the number of non-all levels) of each dimension. For example, the schema of</p><formula xml:id="formula_7">C = {{s 1 , s 2 , s 3 , all, all}, {all}, {d 2 }, {t i 1 ,t i 2 }} is S(C) = {3, 0, 1, 2}</formula><p>i , i is the path id in the temporal dimension.</p><p>The partial order relation in the cuboids of SmartCube is like this: For cuboid C and C , we say C C if the depth of each dimension of C equal to or smaller than corresponding depth in C .</p><p>Specially, for a path p i and cuboid C i f , if all the cuboids on the path satisfy C C i f , we call C i f the finest cuboid, which can be easily presented as:</p><formula xml:id="formula_8">S(C i f ) = {depth m , 1, 1, ...1, depth i } i</formula><p>, which stores all the information on each levels in all dimensions. For example, in <ref type="figure" target="#fig_0">Figure 2</ref>, the cuboid {d 1 , d 2 , d 3 } is the finest cuboid. Since there may be more than one path in the temporal dimension and there is a finest cuboid for a path, it is possible that there is more than one finest cuboid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Tree structure</head><p>The hierarchical layers follow the dimension order of spatial, categorical, and temporal. The order is similar to the nanocubes <ref type="bibr" target="#b16">[17]</ref>. Inside each dimension, the levels follow in path order. We take an example to explain the tree structure of a cuboid. On the left side of <ref type="figure">Figure 3</ref> is Cuboid 1. There are several levels in each dimension, e.g., {year, month} in temporal dimension.</p><p>The nodes of cuboids share memory in the tree-like data structure, which is similar to nanocubes. However, each cuboid in the structure is allowed to add or remove. Thus, the sharing status of the node is needed to store in the nodes. The accumulate shared number (ASN), which means how many cuboids the node is shared with, is introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Structure Update Algorithm</head><p>The structure update algorithm operates on the nodes of the tree structure to create or delete a cuboid. We propose the algorithm of creating and deleting cuboids on the structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Creating Cuboids</head><p>After the original data set is loaded to the data structure, the new cuboids are, if needed, calculated base on the existing cuboids on the tree. We need to find the CBC of the new cuboid to calculate the cuboid. A new cuboid can always be added since at least the finest cuboid is the base cuboid. <ref type="figure" target="#fig_1">Figure 4</ref> describes the Pseudo-code of creating a new cuboid. We traversing the new tree from the root. For each child node, we count the corresponding nodes in the CBC. If there is only a corresponding node, we directly link it to the corresponding node according to the sharing mechanism. For there are more than one, we have to allocate a new node. Finally, in the aggregate level, we calculate the aggregate value of the new nodes based on the corresponding aggregates in the CBC. We show an example describe in <ref type="figure">Figure 3</ref>, we want to add Cuboid 2 on the Structure. Here, Cuboid 1 {S 1 , S 2 , C, year, month} is the CBC for Cuboid 2. Starting from the root node, Cuboid 2 can share nodes with cuboid 1 until the S 2 level. The all node that directly links to categorical nodes in S 1 dimension is needed to calculate. For the (0, 1) node and the (1, 1) node in S 1 , there is only one node in the categorical dimension. They can be directly linked to the categorical dimension. However, for the (1, 0) node, there are two nodes B and C in the categorical dimension. Thus a new node A is allocated. For the child node of A, there are two categorical values, which are C 1 and C 2 . On the one hand, both B and C have the category value C 1 , so the count is 2. We need to add a C 1 child node for A. On the other hand, the count for category value C 2 is 0, so there is no C 2 node for A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Deleting Cuboids</head><p>The process of deleting a cuboid from the structure is showed below. First, find all the nodes of the cuboid when traversing the whole structure. Then, the ASN of the nodes in the cuboid minus 1. In the meanwhile, those nodes whose ASN value comes down to zero are freed. <ref type="figure">Figure 3</ref> shows an example of the deleting process. Cuboid 1 is removed from the structure, and the nodes only kept by Cuboid 1 are freed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Query Engine</head><p>SmartCube supports queries on spatial, categorical, and temporal dimensions. Different from other algorithms, the query route of the same query may change when the cuboids of the structure changes.</p><p>Take query Q = {country = America, language = all, device = iPhone} for example, if the cuboid {country, all, device} exists in the tree, the result can be obtained immediately. If {country, all, device} is not in the tree, we need to drill down to {country, language, device} to get the value of America and iPhone with different languages and aggregate them. The cuboid existing in the structure which can support the query is called the supporting cuboids. Among them, the cuboid with needs least calculation for the query is called the best supporting cuboid (BSC). The query process is divided into following parts, which are (1) finding the BSCs of the query, (2) drilling down to the BSCs to get the results, and (3) rolling up to get the aggregates.</p><p>Query on Spatial Dimension. The query on a certain spatial region is essential in the visualization of spatial-temporal data. Several common scenarios need the spatial region, e.g., density map on the geo-map of the current screen, the aggregate value of a selection of the region. The first dimension of the SmartCube is the spatial Quad-tree structure, in which a given region can be computed under the quadtree intersecting algorithm <ref type="bibr" target="#b25">[25]</ref>. The query seldom matches the region of the nodes in the quad-tree exactly, in the most situation we need to drill down to deeper layer to get the finer division.</p><p>We demonstrate a case to help to understand the data query on the spatial dimension. In <ref type="figure" target="#fig_2">Figure 5</ref>, we are interested in the rectangular areas on the map (a). We divide the region to fit the nodes of the tree: the (1, 0) node is totally inside the region, while the (0, 1) and (1, 1) node intersects with the region, which needs to go deeper. The child of (0, 1) do not fit the query, while the child of (1, 0), i.e., ((0, 1), (0, 0)), is covered by the region. Now there are two levels of nodes need to calculate; they may refer to different CBCs respectively. In two situation (b) and (c), the cuboids in the tree are different. For (b), there is only a cuboid {s 1 , s 2 } in the tree, the node (1, 0) still need to drill down to the second layer to get the aggregate value from cuboid {s 1 , s 2 }. For (c), there are two cuboid {s 1 , all} and {s 1 , s 2 }, the node (1, 0) follows the cuboid {s 1 , all} while the node ((0, 1), (0, 0)) follows the cuboid {s 1 , s 2 }.</p><p>To be general, each layer of the spatial dimension need to find a CBC to support the query, which may lead to a situation where a query requires several different CBCs.</p><p>Query on Category Dimension. The categorical dimensions follow the flat trees, which have a root layer and the nodes of the root refer to different values in the category. The query engine simply follows the path with the value. It does not engage extra CBC as the Spatial query do.</p><p>Query on Temporal Dimension. We divide the temporal dimension into levels with different resolutions, which supports query on time series under different resolutions. SmartCube supports query on time series under a certain range with constraints on certain time levels and the given resolution. The query on the time series will drill down from the root of the time dimension until the given resolution, and the constraints of each layer and time range are considered for pruning the tree. If the current structure does not contain the cuboid of such layer, the drill-down and roll-up to the BSCs are also needed.</p><p>Considering the query together with the spatial region, there may be several paths on the spatial query which may have different BSC query. The final time series results are aggregated from the results of each BSC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Updated Cuboids Decision Algorithm</head><p>During the process of the user query, SmartCube records the query to help decide which cuboid to create or delete.</p><p>Query Recording. We first define the cuboids that the query directly hit as query cuboids. A query can be presented as an array of cuboids and weight, which means the directly hit cuboid and their percentage. For a new query updated to the recent query record, there is a rate r to attenuate the frequency of the past query cuboid, i.e., the sum frequency in the past is set to r while the new query's frequency is set to (1 − r), then add the new query into the recent query records.</p><p>Update by Recent Query.</p><p>We estimate the total latency of recorded query when creating a new cuboid and choose the cuboid that will reduce the latency to the greatest extent. For the cuboid C and its BSC C bsc , the latency can be estimated by the size of these two cuboids, i.e., the larger the difference of the two cuboids' size, the more need to calculate for a results. The query latency mainly comes from the drill-down and roll-up operation, which is linear to S C bsc S C on average. A cuboid's size S C can be present by: S C = Π|c i | a , c i ∈ C, |c| a presents the average node of each level C. Thus, the query latency can be predict as</p><formula xml:id="formula_9">S C bsc S C = Π |c i | a |c i | a .</formula><p>The estimated latency from a cuboid C to its BSC C bsc comes from the cardinality of those levels that exists  in C bsc while not in C. Considering add a new cuboid, since the cuboid C is unknown, we use the average node number |c | of C bsc to estimate the average node number |c| of C. Thus, the latency from C to C bsc is estimated as:</p><formula xml:id="formula_10">Π{|c i | a | c i ∈ C bsc , |c i | a &gt; 1, |c i | a = 1.</formula><p>With the latency estimated method defined, the update process is (1) to find a new cuboid C add that has the maximum total latency reducing recent query list and (2) to find an existing cuboid C remove that has the smallest total latency increase. SmartCube sets a threshold on the latency reduction when considering a cuboid to add.</p><p>When queries meet SmartCube, there are new valuable cuboids to be created or less important existing cuboids to be removed. With the valuable cuboids to be created, the latency of the SmartCube converges into a small value, which is called convergence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Initial Cuboids Prediction Model</head><p>With the update algorithm and the update decision algorithm, the structure can work well for the query tasks. However, the query at the beginning may be time-consuming when the dataset is extremely large. We propose an additional part to show the possibility of a machine learning technique used to reduce the cold-start in the initialization. We introduce a machine learning model for predicting valuable cuboids and add them to the data structure. The input is the information of the datasets and the output is the cuboids that are predicted to add. The average node number of each level shows the basic properties of the data structure, e.g., the spatial and categorical distributions. In this simplest trial, the average node number array is taken to present the datasets. The output is a series of cuboids, we set as three cuboids, each of which is presented as the schema. The input is like this, <ref type="figure" target="#fig_0">(1, 2, 2, 1.3, 2.</ref>3), each number is the average node of each level; the output is like this, {3, 0, 2}, {2, 0, 1}, {1, 0, 2}, which is several cuboids' schema.</p><p>The input and output of the model are series. LSTM is a common method to deal with the series problem. We take the input and output as string and use a natural language translate model (OpenNMT) <ref type="bibr" target="#b13">[14]</ref> to fit it. The training data set is generated randomly, we first generate a random average node series. A synthesized spatiotemporal dataset is generated to fit the series. We randomly generate the query with patterns (e.g., Q3) for the datasets. We apply the queries on it to find several valuable cuboids. The final cuboids are used as the output, and the dataset information is used as input. The model is then trained, which make the initialization be faster and suit for real datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION</head><p>We use C++ based implementation in the data structure. In order to support the structure, we need to store some information such as the path information, sub-tree information, and ASN information. Tagged pointers are used to store them for less memory usage. Libtcmalloc is used for optimizing memory usage as well.</p><p>We develop the approach as the back-end service, which supports HTTP API for website queries. The browser-based interface is developed in HTML, CSS, JavaScript, and D3.js library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PERFORMANCE EVALUATION</head><p>We conducted several experiments to evaluate the efficiency of the SmartCube. These tasks in the experiments cover the common scenarios in visualization. To evaluate the adaptive ability of SmartCube, we also conducted a comparison with several state-of-the-art works on diverse tasks and data sets. From the results, we can conclude that SmartCube can be adaptive to different query tasks for different spatiotemporal data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluation Setup</head><p>The experiments were performed on two workstations. One of the experiment was performed on a Intel Core i7-8700 CPU clocked at 3.20GHz with 8 GB RAM. We used this workstation to evaluate our performance in small memory setting. The other one was performed    We applied three datasets that range in size from 4 million records up to over 100 million records in our experiments to evaluate the adaptability of SmartCube. These data sets include both time series data and spatial-temporal data.</p><formula xml:id="formula_11">S d M c S d t c M c M c M c M c M c M c M c M c t c t c t c t c t c t c t c t c N N 0,1 1,0 1,1 O1 O1 O2 O3 O4 O5 0,0 0,1 0,0 1,0 O2 O3 O4 O5 0,1 1,0 1,1 all all all O1 O2 O3 O4 O5 O2 O3 0,0 0,1 1,0 0,0</formula><formula xml:id="formula_12">Data M i (GB) T i (s) query T c (s) M c (GB) t i (</formula><p>BrightKite. The BrightKite dataset contains 4.5M items with spatial and temporal attributes. It was collected by Cho et. al. <ref type="bibr" target="#b4">[5]</ref>, which contains the check-ins of a website between Apr. 2018 and Oct. 2010.</p><p>Weibo. Weibo is a microblogging social-media website mainly used in China. We collected the weibo post data from Jan. 2014 to Dec. 2014. The data set contains 55.6 Million posts with location of latitude, longitude and timestamps as well.</p><p>Time series. For time series evaluation, we focused on the range <ref type="table">Table 3</ref>. Queries in the Spatiotemporal Data Sets. Queries from Q1 to Q5 are related to spatial region query, some also related to time series query. Queries from Q6 to Q9 are the time series query.</p><p>Q1 query the sum of values given range and granularity Q2 query day week and hour day distribution given spatial region and granularity Q3 query time series given spatial region, temporal range aggregated by certain resolution Q4 query time series given spatial region, temporal range and temporal constraints aggregated by certain resolution Q5 query time series given spatial region, temporal range, temporal constraints and categorical constraints aggregated by certain resolution and time constraint query under dense time series. We follow the setting of Time Lattice <ref type="bibr" target="#b20">[21]</ref> to generate the synthetic time series with 100M items. The data set is at second resolution with each second as a time step. Random number in uniform distribution is used as the value for each time step. The queries used in the experiments are list in <ref type="table">Table 3</ref>. Those queries cover the usual setting in the visualization scenarios.</p><p>Q1 to Q5 are the queries on a certain spatial region. Q1 is a query to get an aggregate value on a given region under a certain spatial granularity, which is useful to have a quick overview of a certain region. Q2 returns a 7 × 24 array on week day and hour. The visualization that needs to explore time patterns requires to query on such scenarios. Q3 queries a time series on a given time range, specific temporal resolution, and a given spatial region, which is a common query for the spatial region and time consideration. Q4 further increases the query complexity by adding the temporal constraints on the Q3, e.g, obtaining the time series of the work hour, work day in a certain region and time range. The query is useful when studying the labor-related problem. Q5 adds constraints on categorical dimensions based on Q3. One of the scenarios of Q5 is that we want to compare the spatial and temporal dimensions under different categories on the same spatial region and temporal range.</p><p>For the pure time series query, we focus on the aggregate query and the time series query. We adopted the temporal queries setting in Time-Lattice <ref type="bibr" target="#b20">[21]</ref> and used it in our evaluation. Q6 queries for the time series under a range in certain resolution. Q7 is the query for the aggregation of certain time resolution. Q8 queries for the aggregation on the day of the week with the constraints in hour and minutes. Besides, the query for the time series with certain constraints under certain resolution is also common in visualization setting, as Q9 does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Convergence of SmartCube</head><p>In summary, SmartCube can handle all the common queries with low latency. SmartCube was able to quickly converge on the overhead of adding cuboids during the query process to reach state-of-the-art latency. The memory after convergence is several times smaller than other state-of-the-art algorithms. Even before convergence, the query time is acceptable in the visualization exploration scenarios. In our evaluation, we conducted different types of queries on the BrightKite data sets and Q4 of Weibo data sets. As <ref type="table" target="#tab_6">Table 2</ref> shows, SmartCube fits into each query in a small convergence time within seconds. Even for large Weibo data with more than 50 million items, the convergence time is less than several dozens of seconds. Therefore we can ignore the convergence time in the real-world visualization exploration for users. (a) to (d) of <ref type="figure">Figure 7</ref> shows the time performance as the query over time for each seconds. (e) and (f) in the figure shows the time performance and memory change as the temporal resolution of query changes. The two peaks are at the beginning of the resolution change.</p><p>In the beginning, the convergence time may face the cold-start problem. In order to reduce the latency at the beginning when the dataset is extremely large. We adopt a Machine learning model to show the possibility of predicting valuable cuboids when initializing the dataset. We train the model using synthesizing datasets and validate in the Weibo dataset (which is large) in order to show the generalization. The datasets number of the model is set to 300 because it has the best performance in the scenario. As <ref type="figure">Figure 8</ref> shows, with the assistant of machine learning, the query latency during convergence time is several times lower than the cold start.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Comparison in Spatial-Temporal Dataset</head><p>The exploration on a visualization of spatial temporal dataset requires the understanding on the spatial relationship and time series together. <ref type="figure">Figure 6</ref> shows a visualization system we built to explore spatialtemporal patterns with aggregate patterns. A visualization system with the density heatmap on a zoomable and panable map can help users to understand the spatial distribution. The related patterns on certain dimensions can help users to understand the distribution in a certain spatial region. For example, <ref type="figure">Figure 9</ref> shows the week-hour pattern in certain regions under different spatial levels of the weibo data. This visualization can help the user to understand the day-hour pattern in a different region. The different task in the visualization system of spatial-temporal data can be covered by the queries in <ref type="table">Table 3</ref> from Q1 to Q5.</p><p>To evaluate the efficiency in those spatiotemporal case, we conduct the comparison from Q1 to Q5 with the state-of-the-art algorithms under the datasets of BrightKite and Weibo. <ref type="table" target="#tab_8">Table 4</ref> shows the properties of state-of-arts algorithms. When the structure store more cuboids, it can support more direct query. TimeLattice and HashedCube only stores some of the cuboids, the query on it require calculation on the fly. Among them, SmartCube has a flexible structure, which may need calculation on the fly at the beginning but soon directly get the results. Nanocubes <ref type="bibr" target="#b16">[17]</ref> has the lowest query latency because it can get all the results directly.</p><p>Hashedcube <ref type="bibr" target="#b22">[23]</ref> focus on reducing the memory cost but result in lower performance. Most results on the hashedcube need calculation on the fly, which leads to a worse performance than nanocubes. SmartCube can create the cuboids to fit in all the similar queries next time, which may not need to calculate on the fly when getting convergence. We show that SmartCube can reach the corresponding performance with nanocube, which is higher than hashedcube. <ref type="table" target="#tab_5">Table 1</ref> shows the time performance and memory size comparison with nanocubes under two datasets. The BrightKite data set is run in the machine with smaller RAM. In this setting, SmartCube have the schema: lat <ref type="bibr" target="#b25">(25)</ref>, lon <ref type="bibr" target="#b25">(25)</ref>, year(2), month(3), day(5), weekday(3), hour(5), while nanocube have the schema: lat(25), lon <ref type="bibr" target="#b25">(25)</ref>, year(2), month(3), day <ref type="bibr" target="#b4">(5)</ref>, weekday(3), hour <ref type="bibr" target="#b4">(5)</ref>. For the larger data set on weibo, consider the nacube can not run on the smaller machine, we run on the machine with larger memory. SmartCube have the schema: lat <ref type="bibr" target="#b25">(25)</ref>, lon <ref type="bibr" target="#b25">(25)</ref>, year(2), month(3), day <ref type="bibr" target="#b4">(5)</ref>, weekday(3), hour(5), num image (4), while nanocube have the schema: lat <ref type="bibr" target="#b25">(25)</ref>, lon <ref type="bibr" target="#b25">(25)</ref>, time <ref type="bibr" target="#b15">(16)</ref>, weekday(3), hour(5), num image <ref type="bibr" target="#b3">(4)</ref>. These settings are to make sure nanocube can handle all the queries. The SmartCube can generate the results on the fly or directly get the results from the newly added cuboids. As SmartCube can add those cuboids quickly, most of the performance after convergence is similar to that of nanocube. For Q1 and Q2, the structure of Smartcube after convergence is similar to nanocube. In Q1 and Q2 of dataset BrightKite, the machine is with a CPU memory of 8G, the larger memory cost in nanocube may need more I/O exchange, that is why the SmartCube is quicker than nanocubes. In Q1 and Q2 of weibo dataset, the machine is with a large CPU and the I/O exchange is not needed, so nanocube is quicker than Smartcube. Consider the difference in the temporal dimensions, the performance in Q3 -Q5 may be quite different from nanocubes. As the constraints on the temporal level, the performance of SmartCube becomes better (From Q4 and Q5). That's because the hierarchical structure of the temporal dimension help to jump those nodes who's don't fit the constraints in a high level while nanocubes need to go through an empty array to put into each value. <ref type="figure">Fig. 6</ref>. An example of visualization that requires the aggregations on several combination of the data sets. The constraints on time can be added by the right part. The query for spatial region is for time series, temporal pattern in hour of week days.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Comparison in Time series dataset</head><p>SmartCube supports the query on certain constraints on the levels and return the time series with a certain resolution. The common queries on temporal dimension is supported by the the SmartCube structure. To evaluate the efficiency in temporal dimension. We conduct the comparison the comparison with the Time Lattice, the state-of-art data management method <ref type="bibr" target="#b20">[21]</ref>. Time Lattice conduct several comparison on time series data with existing techniques, which outperforms other techniques in memory cost and time costing. However, the code of the Time Lattice is not accessible. To compare with Time Lattice, we follow the hardware and software setting in Time Lattice. In hardware setting, our CPU is Intel Xeon E5-2650 CPU clocked at 2.20GHz and CPU of Time Lattice is Intel Xeon E5-2650 CPU clocked at 2.00 GHz. There is only small difference in clock frequency. The memory costs in different environment should be the same. Results show that SmartCube costs smaller memory then TimeLattice and can support the same query. Both SmartCube and TimeLattice can be regarded as hierarchical trees in the time series. In Q6, SmartCube have similar performance with TimeLattice. While in Q7 -Q8, SmartCube can be faster than TimeLattice mainly because the multi-path in temporal dimension. Our performance in the 100M random datasets shows the high performance than other counterparts. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DISCUSSION</head><p>SmartCube is an adaptive structure for the spatiotemporal datasets. It realized the adaptive ability by operating the cuboid. A cuboid is defined by the dimension combination, which contains aggregations in all the k-dimensional array. Our process only updates the cuboid information when a cuboid is finished adding to the cuboid, i.e., during the adding cuboid process, the query for such cuboid cannot reach a partially finished cuboid and can only query existing cuboids on the structure to get the results. In the current setting, for the extremely large dataset, the query hit a non-existed cuboid would have a high latency until the building of the cuboid is finished. However, during the adding process, some query on this cuboid can be handled by the partially finished cuboid. The query on partially finished cuboids has two possible solutions. One is to record the more detailed information than cuboid; another is to the estimation of the probability to successfully query on these cuboids, together with the fault-tolerance algorithm to support the query.</p><p>Under the multi-user environment, the common situation is that many users use the same visualization systems querying on the same structure. The convergence memory cost will still be smaller than the state-of-art algorithms like nanocubes. The reason is that there are limits of the possible queries in a visualization system. Even if all the cuboids that directly fit the queries of a system is load, the cuboids are still a subset of all the cuboids, which guarantee that the memory of SmartCube will be relatively smaller than nanocubes.</p><p>To suit for the extremely large datasets, the distributed system may be induced to the data management. The dynamic management of the SmartCube can be combined with a distributed system for a highperformance cuboid update and distributed query.</p><p>To better suit for the memory limits, setting a hard constraint on the memory is useful and can easily be extended from current framework, e.g., on a server of visualization of large datasets, set a memory limit to make sure the data structure stay in the memory.</p><p>In the future, machine learning techniques will be introduced in more parts of the pipeline for a smarter data structure.  <ref type="figure">Fig. 9</ref>. The heat map shows the weekday × hour values according to the certain region on the map. The darker the square color is, the higher the value it represented is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSIONS</head><p>In this work, we proposed SmartCube, a flexible framework for spatiotemporal data sets. Not only organizing the data structure at the beginning, but the framework also changes adaptively according to query patterns . The framework takes the cuboids as the basic unit and updates the data structure by creating and deleting cuboids. When new query are received, the updating engine will judge the query changes, estimate the performance and memory changes, and finally, make the decision of cuboids changes.</p><p>We conducted several comparisons with state-of-the-art algorithms. The results indicate that our algorithm is adaptive to different forms of spatiotemporal datasets. The performance increases as the users interact with the system. Our algorithm reaches a comparable performance of the state-of-the-art algorithm with smaller memory cost.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>The data cube of a dataset with level D= {d 1 , d 2 , d 3 }.Each box here is a cuboid, and the all here means the aggregation level. Totally, there are 2 |D| (2 3 ) cuboids.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>The pseudo-code of creating a new cuboid on the structure. In the left, the function AddCuboid builds the new cuboid based on the basic cuboid with the schema of these cuboids. In the right, the function AddCuboidChildren shares nodes or creates new nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>The quad-tree division and the query on it in spatial region (a). Querying a region on the map will be translated to certain query on the tree. (b) and (c) are the same query on different tree status. The query routes are different. (c) can directly jump to the aggregate of {O2, O3} while (b) needs extra drilling down on the tree to get aggregate of {O2} and {O3}, and then combines the two values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Q6 select time series between December 14, 1970 5:20 and February 3, 1972 9:20 aggregated by hour Q7 select time series group by hour Q8 select time series where time between 09:30 and 17:30 group by day week Q9 select time series where time between 09:30 and 17:30, month in [January, February, March] group by hour, minute</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>(a) to (d) is the performance of Query Q1 to Q4 change over time in the BrightKite dataset; (a) for Q1, (b) for Q2, (c) for Q3, and (d) for Q4, respectively. (e) and (f) shows the query performance and memory change as the query pattern of different resolution. The query time convergence soon as the new cuboid are added to the data structure.query over time (s) The performance of ML-initialize towards the cold start. It shows that ML reduces the query time before finishing convergence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Initialization I Original Data Set ... Lat: 12.2 Lng: 170 Time: 2019.3.31 Category: Big Lat: 30.2 Lng: -90 Time: 2019.3.31 Category: Big</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">Finest Cuboid Structure</cell><cell></cell><cell>Adaptive Data Structure</cell><cell>Query Engine</cell></row><row><cell></cell><cell>n</cell><cell></cell><cell></cell><cell>Cuboids Adding</cell><cell>Query</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Hit</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>New Added</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Recording Recording Recording Recording</cell></row><row><cell></cell><cell></cell><cell cols="2">Initial Cuboids</cell><cell></cell><cell>Underlying Structure</cell><cell>Cuboid Status</cell></row><row><cell>Adaptive Structure Loop</cell><cell></cell><cell cols="2">Prediction Model</cell><cell></cell><cell>Update Algorithm</cell><cell>Manager</cell></row><row><cell>Information Transform Dataset Structure</cell><cell></cell><cell>Cuboids:</cell><cell>[24, 0, 5]</cell><cell></cell><cell>Add</cell><cell>Add?</cell></row><row><cell></cell><cell>Statistics of</cell><cell></cell><cell></cell><cell>Cuboids</cell><cell>Remove</cell></row><row><cell>Update Cuboid Suggestion</cell><cell>dimensions</cell><cell cols="2">[1, 2.1, 0.2, 2.0]</cell><cell>to add</cell><cell>Remove?</cell></row><row><cell>Algorithm Support</cell><cell></cell><cell cols="2">Dimension average node</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1 .</head><label>1</label><figDesc>The performance compared with the state-of-the-art algorithms under different datasets. The experiments with the '*' is the testing results quoted from the Time Lattice<ref type="bibr" target="#b20">[21]</ref>.</figDesc><table><row><cell></cell><cell>Data</cell><cell></cell><cell>(GB)</cell><cell>(M)</cell><cell>Q1 (GB)</cell><cell>(ms)</cell><cell cols="2">Q2 (GB) (ms)</cell><cell>Q3 (GB)</cell><cell>(ms)</cell><cell>Q4 (GB)</cell><cell>(ms)</cell><cell cols="2">Q5 (GB) (ms)</cell></row><row><cell>SmartCube NanoCube</cell><cell cols="2">BrightKite</cell><cell>0.37</cell><cell>4.7</cell><cell>0.61 2.64</cell><cell>0.12 0.25</cell><cell>0.89 2.64</cell><cell>1.66 3.32</cell><cell>1.53 2.64</cell><cell>3.89 1.46</cell><cell>1.53 2.64</cell><cell>13.82 21.99</cell><cell>--</cell><cell>--</cell></row><row><cell>SmartCube NanoCube</cell><cell cols="2">Weibo</cell><cell cols="2">2.77 55.6</cell><cell>12.56 97.29</cell><cell>1.66 1.43</cell><cell cols="2">14.18 25.92 97.29 17.82</cell><cell>17.06 97.29</cell><cell cols="2">13.45 12.23 1.83 97.29</cell><cell>3.58 11.01</cell><cell>20.99 97.29</cell><cell>22.05 17.33</cell></row><row><cell></cell><cell></cell><cell cols="2">Data</cell><cell>(GB)</cell><cell>(M)</cell><cell cols="2">Q6 (MB) (ms)</cell><cell cols="2">Q7 (MB) (ms)</cell><cell cols="2">Q8 (MB) (ms)</cell><cell cols="2">Q9 (MB) (ms)</cell></row><row><cell cols="2">SmartCube</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>67</cell><cell>27.54</cell><cell>67</cell><cell>1.80</cell><cell>68</cell><cell>3.93</cell><cell>68</cell><cell>9.01</cell></row><row><cell cols="2">*Time Lattice</cell><cell cols="2">Time Series</cell><cell>2.59</cell><cell>100</cell><cell>397</cell><cell>40.50</cell><cell>397</cell><cell>15.00</cell><cell>397</cell><cell>12.80</cell><cell>397</cell><cell>92.40</cell></row><row><cell cols="2">*NanoCube</cell><cell></cell><cell></cell><cell></cell><cell cols="2">41799</cell><cell cols="3">116.00 41799 4.60</cell><cell cols="4">41799 2491.80 41799 40083.90</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 .</head><label>2</label><figDesc>The converge process in data Brightkite and Weibo. M i the initial memory. T i the initial time. T c the convergence time. M c the memory after convergence. t i the query time before convergence. BK the BrightKite dataset. WB the Weibo dataset.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 .</head><label>4</label><figDesc>Comparison with some state-of-the-art algorithms.</figDesc><table><row><cell></cell><cell>structure</cell><cell>query</cell><cell>cuboids</cell><cell>datasets</cell></row><row><cell>SmartCube</cell><cell>flexible</cell><cell>flexible</cell><cell>flexible</cell><cell>spatiotemporal</cell></row><row><cell>TimeLattice</cell><cell>fixed</cell><cell>direct, on the fly</cell><cell>some</cell><cell>temporal</cell></row><row><cell>nanocubes</cell><cell>fixed</cell><cell>direct</cell><cell>all</cell><cell>spatiotemporal</cell></row><row><cell>HashedCube</cell><cell>fixed</cell><cell>direct, on the fly</cell><cell>some</cell><cell>spatiotemporal</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors thank the anonymous reviewers for their valuable comments. This work is supported by NSFC No. 61672055 and 61872013, and the National Program on Key Basic Research Project (973 Program) No. 2015CB352503. This work is also supported by PKU-Qihoo Joint Data Visual Analytics Research Center.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Blinkdb: Queries with bounded errors and bounded response times on very large data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<idno type="DOI">10.1145/2465351.2465355</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM European Conference on Computer Systems, EuroSys &apos;13</title>
		<meeting>the 8th ACM European Conference on Computer Systems, EuroSys &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="29" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dynamic prefetching of data tiles for interactive visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Battle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2882919</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Management of Data, SIGMOD &apos;16</title>
		<meeting>the International Conference on Management of Data, SIGMOD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1363" to="1375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dynamic reduction of query result sets for interactive visualizaton</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Battle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chang</surname></persName>
		</author>
		<idno type="DOI">10.1109/BigData.2013.6691708</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Big Data</title>
		<meeting>the IEEE International Conference on Big Data</meeting>
		<imprint>
			<date type="published" when="2013-10" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
		<idno>doi: 10.1145/ 361002.361007</idno>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="509" to="517" />
			<date type="published" when="1975-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Friendship and mobility: User movement in location-based social networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<idno type="DOI">10.1145/2020408.2020579</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>the ACM SIGKDD International Conference on Knowledge Discovery and Data Mining<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1082" to="1090" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">MapReduce: simplified data processing on large clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="113" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Trajectory Indexing and Retrieval</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4614-1629-62</idno>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">09</biblScope>
			<biblScope unit="page">2011</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A GPU-based index to support interactive spatio-temporal queries over historical data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doraiswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2016.7498315</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 32nd International Conference on Data Engineering (ICDE)</title>
		<meeting>the IEEE 32nd International Conference on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2016-05" />
			<biblScope unit="page" from="1086" to="1097" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Trust me, i&apos;m partially right: Incremental visualization lets analysts explore large datasets faster</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Popov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Drucker</surname></persName>
		</author>
		<idno type="DOI">10.1145/2207676.2208294</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI Conference on Human Factors in Computing Systems, CHI &apos;12</title>
		<meeting>the SIGCHI Conference on Human Factors in Computing Systems, CHI &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1673" to="1682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data cube: A relational aggregation operator generalizing group-by, cross-tab, and sub-totals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bosworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Layman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reichart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Venkatrao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pellow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<idno type="DOI">10.1023/A:1009726021843</idno>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="53" />
			<date type="published" when="1997-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Advection-based sparse data management for visualizing unsteady flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2555" to="2564" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Online aggregation. SIG-MOD Rec</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1145/253262.253291</idno>
		<imprint>
			<date type="published" when="1997-06" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="171" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Visreduce: Fast and responsive incremental information visualization of large datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Im</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">G</forename><surname>Villegas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Mcguffin</surname></persName>
		</author>
		<idno type="DOI">10.1109/BigData.2013.6691710</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Big Data</title>
		<meeting>the IEEE International Conference on Big Data</meeting>
		<imprint>
			<date type="published" when="2013-10" />
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">OpenNMT: Open-source toolkit for neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Rush</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Semanticsspace-time cube. a conceptual framework for systematic analysis of texts in space and time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Andrienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Andrienko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Concavecubes: Supporting cluster-based geographical visualization in large data scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.13414</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="217" to="228" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Nanocubes for real-time exploration of spatiotemporal datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2456" to="2465" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The effects of interactive latency on exploratory visual analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2014.2346452</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2122" to="2131" />
			<date type="published" when="2014-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">immens: Real-time visual querying of big data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
		<idno>doi: 10.1111/ cgf.12129</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3pt4</biblScope>
			<biblScope unit="page" from="421" to="430" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards utilizing gpus in information visualization: A model and implementation of image-space operations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mcdonnel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2009.191</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1105" to="1112" />
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Time lattice: A data structure for the interactive visual analysis of large time series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Miranda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doraiswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mydlarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Salamon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lockerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.13398</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="23" to="35" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Topkube: A rankaware data cube for real-time exploration of spatiotemporal data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Miranda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Klosowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2671341</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1394" to="1407" />
			<date type="published" when="2018-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hashedcubes: Simple, low memory, real-time visual exploration of big data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A L</forename><surname>Pahins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L D</forename><surname>Comba</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2016.2598624</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The k-d-b-tree: A search structure for large multidimensional dynamic indexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;81</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;81</meeting>
		<imprint>
			<biblScope unit="page" from="10" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<idno type="DOI">10.1145/582318.582321</idno>
		<imprint>
			<date type="published" when="1981" />
			<publisher>ACM</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Foundations of multidimensional and metric data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Hierarchical dwarfs for the rollup cube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sismanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Deligiannakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<idno type="DOI">10.1145/956060.956064</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th ACM International Workshop on Data Warehousing and OLAP, DOLAP &apos;03</title>
		<meeting>the 6th ACM International Workshop on Data Warehousing and OLAP, DOLAP &apos;03<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Dwarf: Shrinking the petacube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sismanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Deligiannakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;02</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;02</meeting>
		<imprint>
			<biblScope unit="page" from="464" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<idno type="DOI">10.1145/564691.564745</idno>
		<imprint>
			<date type="published" when="2002" />
			<publisher>ACM</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Progressive visual analytics: Userdriven visual exploration of in-progress analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Stolper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Perer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gotz</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2014.2346574</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1653" to="1662" />
			<date type="published" when="2014-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Polaris: A system for query, analysis, and visualization of multidimensional relational databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<idno type="DOI">10.1109/2945.981851</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="52" to="65" />
			<date type="published" when="2002-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Multiscale visualization using data cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stolte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2003.1196005</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="176" to="187" />
			<date type="published" when="2003-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Spatio-temporal indexing for large multimedia applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vazirgiannis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<idno type="DOI">10.1109/MMCS.1996.535011</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Multimedia Computing and Systems</title>
		<meeting>the IEEE International Conference on Multimedia Computing and Systems</meeting>
		<imprint>
			<date type="published" when="1996-06" />
			<biblScope unit="page" from="441" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cashman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1808.08983</idno>
		<title level="m">Nncubes: Learned structures for visual data exploration</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Gaussian cubes: Real-time modeling for visual exploration of large multidimensional datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Bhaskar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scheidegger</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2016.2598694</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="681" to="690" />
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Condensed cube: an effective approach to reducing data cube size</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianlin</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongjun</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2002.994705</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings 18th International Conference on Data Engineering</title>
		<meeting>18th International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2002-02" />
			<biblScope unit="page" from="155" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dynamic load balancing based on constrained k-d tree decomposition for parallel particle tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Peterka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="954" to="963" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Efficient unsteady flow visualization with high-order access dependencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Pacific Visualization Symposium (PacificVis)</title>
		<meeting>the IEEE Pacific Visualization Symposium (PacificVis)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="80" to="87" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
