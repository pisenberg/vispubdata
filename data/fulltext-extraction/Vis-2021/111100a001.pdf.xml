<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Simultaneous Matrix Orderings for Graph Collections</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nathan</forename><surname>Van Beusekom</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wouter</forename><surname>Meulemans</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bettina</forename><surname>Speckmann</surname></persName>
						</author>
						<title level="a" type="main">Simultaneous Matrix Orderings for Graph Collections</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A88FBE11A3A9806B36150F07031657F9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.1" ident="GROBID" when="2022-06-13T13:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Matrix ordering</term>
					<term>graph visualization</term>
					<term>algorithms</term>
					<term>quality measures</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Fig. <ref type="figure">1</ref>. A collection of two matrices (top left). The state-of-the-art first computes a (weighted) union (top middle and right, blue squares have weight 2), then orders the union, and finally applies this ordering to all matrices in the collection. The union leads to a loss of information, specifically, on those parts of the matrices which are different (bottom right). We propose a collection-aware approach to compute orderings which avoids this loss of information (bottom left). Our approach can be applied to existing ordering methods; examples in this figure use the popular leaf order heuristic.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graphs are a common tool to model interacting entities, be it humans in social networks, synapses in human brains, or servers in computer networks. Visualizations are a natural tool to explore the structure of graphs and to analyze the underlying interactions. The majority of current graph analysis tools make use of node-link diagrams to visualize graphs. However, matrix visualizations of graphs -which directly draw the graphs' adjacency matrix -have been shown to be effective for lowlevel analysis tasks <ref type="bibr" target="#b21">[21]</ref> ('are the vertices x and y connected') and for comparisons of (large) graphs <ref type="bibr" target="#b0">[1]</ref>. A matrix visualization can highlight local structures in graphs -such as clusters, bi-cliques, or stars -but this relies on a suitable ordering of the rows and columns to make these structures manifest as visual patterns. Formally defining the quality of an ordering and then automatically computing a high-quality ordering are challenging problems. A multitude of different techniques have been proposed over the years; see the survey by Behrisch et al. <ref type="bibr" target="#b8">[8]</ref> for an extensive discussion.</p><p>Often, graphs do not appear in isolation, but they are rather part of a collection of graphs which share a common set of vertices. Examples include dynamic graphs (such as brain activity of one person over time) and graphs with distinct edge sets (such as brain activity patterns of different persons). In either case, visualizing these graph collections with matrices requires us to compute a single ordering that works well for all graphs simultaneously. Using one single ordering for all graphs in a collection facilitates comparisons between the matrices; at the same time, the ordering should allow local structures in each matrix to visually manifest themselves.</p><p>There are only a few visual analysis tools for graph collections that use matrix visualizations. The Cubix system by Bach et al. <ref type="bibr" target="#b2">[3]</ref> allows the user to explore the evolution of a dynamic network using a matrix visualization for each time step. These matrix visualizations are then combined into a so-called matrix cube, using a single, possibly userdefined, ordering for all matrices. The user can reorder any of the matrices in the cube using a variety of provided ordering algorithms; the new ordering is computed based on the values in this single selected matrix only and then applied to all others. The MultiPiles technique by Bach et al. <ref type="bibr" target="#b1">[2]</ref> is another approach that facilitates the analysis of time-series of graphs. Here collections of adjacency matrices are "piled" together, using temporal clustering or based on user interactions; the piles are then arranged in a small multiples style layout to facilitate comparisons. Among the large set of user interactions is the option to impose a so-called local order on a pile (collection) of matrices: this ordering is computed for all matrices in the pile using the weighted union of all matrices as input for the leaf order heuristic. Using a union matrix inevitably loses information about the individual matrices, and hence, the ordering algorithms have less information at their disposal. Nevertheless, this approach works well if all matrices in the pile are fairly similar. However, as illustrated in the example in Figure <ref type="figure">1</ref>, if the graphs contain complementary edges, then the union does not contain enough information to arrive at a good simultaneous ordering.</p><p>In this paper we propose a collection-aware approach to computing simultaneous matrix orderings for collections of graphs. As most previous work, we focus our attention on undirected graphs, that is, symmetric 0-1 valued adjacency matrices (indicated with 0:white and 1:black squares in all figures). Our basic premise is that a method will produce an ordering which works well for all matrices simultaneously, if the decisions that the method takes are based on the individual matrices -as far as that is possible. Since any method needs to produce a single ordering in the end, eventually information from all matrices in the collection needs to be aggregated. However, the further down the algorithmic pipeline this aggregation is happening, the more of the local structures in the input matrices are preserved. We demonstrate the soundness of our premise and the feasibility of our approach by describing collection-aware variants of two popular matrix ordering methods: the leaf order <ref type="bibr" target="#b3">[4]</ref> and barycenter <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b27">27]</ref> heuristics.</p><p>The de-facto standard computational quality metrics for matrix visualizations are based on distances induced by the input graph. Specifically, the bandwidth, profile, and linear arrangement measures count how far each edge is removed from the diagonal (using different schemes to aggregate this information into a single value). By design these measures are optimized by orderings that move matrix cells of edges as close to the diagonal as possible. However, many meaningful patterns that occur in matrix visualizations, representing graph features such as bi-cliques or stars (see the survey by Behrisch et al. <ref type="bibr" target="#b8">[8]</ref>), are in fact not close to the diagonal and hence are not captured by these measures. The same survey is calling for future research into quantitative measures which evaluate the quality of all patterns. To overcome the current lack of such quantitative measures, Behrisch et al. <ref type="bibr" target="#b6">[7]</ref> propose to describe and compare matrices via feature vectors (Magnostics) that describe specific patterns. These vectors are well-suited to support database queries and user interactions, but they are less suited for computational benchmarks and algorithmic optimization.</p><p>We observe that salient patterns in matrix visualizations are formed by clusters of black and white cells -a simple form of spatial autocorrelation. We hence propose to use Moran's I <ref type="bibr" target="#b30">[30]</ref>, a prominent measure for spatial auto-correlation, as a quality metric for matrix visualizations. Moran's I counts vertical and horizontal adjacencies in three classes: black-black, white-white, and black-white (see Figure <ref type="figure" target="#fig_0">2</ref>). Black-black and white-white adjacencies contribute positively to the count, weighted by relative frequency of white or black, while blackwhite adjacencies contribute negatively. The final score is normalized to lie between −1 (checkerboard pattern) and +1 (a white or black matrix). Moran's I is closely related to several quality metrics which are used internally in matrix re-ordering algorithms (see Section 7.2 in the survey by Behrisch et al. <ref type="bibr" target="#b9">[9]</ref> on quality metrics). However, until now, none of these metrics have been used as a quality metric for the final matrix visualization.</p><p>Contributions. Summarizing the above, the contributions of our paper are twofold. Our primary contribution is the new collection-aware approach hinted at above, with a description of how to apply this approach to the leaf order and barycenter heuristics.</p><p>Our second contribution is the introduction of Moran's I as a quality metric for matrix visualizations. Specifically, we explain how Moran's I relates to existing measures and algorithms, we show that Moran's I captures the full range of established patterns and anti-patterns in matrix visualizations, and we explain how to efficiently approximate an optimal matrix ordering for Moran's I.</p><p>Throughout the main body of the paper we focus on collections of undirected, unweighted graphs with symmetric adjacency matrices. In Section A in the supplementary material we consider the more general case of directed graphs. There we also argue that for undirected graphs it is optimal (under Moran's I) to use a single ordering for rows and columns. Hence, we restrict our discussion in the main paper to a single ordering. However, our techniques and measures readily generalize to weighted or directed graphs.</p><p>We validate the efficacy of our methodology using a short computational experiment using implementations of the collection-aware and union approaches, to showcase that the loss of information indeed occurs in real-world data, and that the collection-aware approach overcomes this problem.</p><p>The paper is organized as follows. In Section 2 we briefly summarize notations and definitions. We provide details on measuring quality and distances for matrix orderings and provide our exposition on Moran's I in Section 3. We then describe and review the union approach, and our newly proposed collection-aware approach and its implementation in Section 4. We describe in Section 5 the setup and results of our computational experiments, and close in Section 6 with a review of our findings and possible future work.</p><p>Related work. We are not aware of previous work that computes simultaneous orderings for matrices, beyond the union approach of MultiPiles <ref type="bibr" target="#b1">[2]</ref>; see above, as well as Section 4 for a discussion of this method. A discussion of related work in terms of ordering quality is deferred to Section 3.</p><p>In the graph-drawing literature, we find related work on simultaneously drawing graphs in the node-link diagram style <ref type="bibr" target="#b10">[10]</ref>. The goal here typically is to avoid crossings, i.e., draw graphs planarly, on a common vertex set. In other words, can locations for each vertex be found, such that for each graph, all edges of that graph can be drawn using these locations (e.g., with straight lines or few bends per edge) while not introducing intersections. Note that crossings between edges of different graphs are thus allowed. Results here focus on theoretical aspects, establishing computational complexity, i.e., showing that the problem is hard in general <ref type="bibr" target="#b16">[16]</ref> but that other variants admit polynomialtime solutions <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b22">22]</ref>. Recently, simultaneous embeddings were generalized to graphs drawn in 3D, with the goal that different twodimensional projections preserve user specified distances <ref type="bibr" target="#b24">[24]</ref>. Beck et al. <ref type="bibr" target="#b4">[5]</ref> present an extensive overview on visualization techniques for dynamic graphs, which also touches upon matrix visualizations.</p><p>We focus on simple black-and-white representations of undirected, unweighted graphs. However, there are many possibilities to augment matrix visualizations. For example, cells can be used to display auxiliary data of the edges, including temporal data <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b34">34]</ref>. Moreover, augmentations with lines can help overcome some of the drawbacks of matrix visualizations, such as the identification of paths <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b32">32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>Graphs. A graph G = (V, E) consists of a set V of n vertices and a set E ⊆ V 2 of m edges. We assume graphs to be undirected, that is, (u, v) ∈ E ⇔ (v, u) ∈ E. Typically, undirected graphs do not contain self-loops (u, u) ∈ E, but we assume that these may occur.</p><p>With N(G, v) we denote the neighborhood of vertex v in graph G. Specifically, we interpret it as an n-dimensional 0-1 vector: an entry is 1 if and only if (v, u i ) ∈ E where u i is the ith vertex in some arbitrary fixed order of the vertices in V .</p><p>Orderings. An ordering of a graph G is a permutation of its vertices V , which we represent as a bijective function on the indices, ρ : {1,...,n} → V . So, ρ(1) is the first vertex in the ordering, and ρ −1 (v) is the rank (position) of v ∈ V in the ordering. 1 We use ρ(i, j) as a shorthand for the pair (ρ(i), ρ( j)), that is, a pair of vertices which may or may not constitute an edge in E.</p><p>Given an ordering ρ of G, we can create a table with n rows and n columns, where each row and column is associated with a vertex through the ordering. We color each cell [i, j] in row i and column j of this table black if the edge ρ(i, j) is in E, and white otherwise. Simultaneous orderings. Assume that we are given a set G = {G 1 ,...,G k } of k undirected graphs . Each graph G i = (V, E i ) is defined on the same set V of vertices but has its own set of edges E i ⊆ V 2 . Our goal is to find a simultaneous ordering ρ for the set G , that is, an ordering of the vertices V that results in good matrix visualizations for all graphs in the set G .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MEASURING ORDERING QUALITY</head><p>Computational quality measures play an important role when designing and evaluating matrix ordering algorithms. Here measures are used essentially in three different ways: to evaluate the final quality of a matrix visualization, as part of the objective function to be optimized by an algorithm, or simply as distance function between two rows of the matrix. In principle each measure can be used in all three settings, however, we observe that so far, certain measures have been used only in one or two of them. We can roughly separate existing measures into two categories: measures that are based on distances in the ordering between vertices and measures that are based on adjacencies of row (or column) vectors in the matrix.</p><p>Ordering distance. Measures in this category focus on combinatorial, connectivity aspects of the input graph. That is, they measure how well the ordering represents the (edge) connectivity in the graph. The measures attempt to capture the idea that nodes which are adjacent or at least close in the graph should be adjacent or close in the order and vice versa. The de-facto standard computational quality metrics are all based on the concept of rank difference (distance in the ordering):</p><formula xml:id="formula_0">λ ρ (u, v) = |ρ −1 (u) − ρ −1 (v)</formula><p>| should be small for all (u, v) ∈ E. The function λ effectively expresses the deviation of an edge from the diagonal of the matrix. This principle is used to define three common measures <ref type="bibr" target="#b8">[8]</ref>:</p><p>bandwidth which is the maximum deviation, max</p><formula xml:id="formula_1">(u,v)∈E λ (u, v)</formula><p>profile which measures per vertex the maximum deviation to an adjacent vertex earlier in the order,</p><formula xml:id="formula_2">n ∑ i=1 (i − min j&lt;i∧ρ( j,i)∈E j) = n ∑ i=1 max j&lt;i∧ρ( j,i)∈E λ (ρ( j), ρ(i))</formula><p>linear arrangement which accounts for all edges,</p><formula xml:id="formula_3">∑ u∈V ∑ (u,v)∈E λ (u, v) = ∑ (u,v)∈E λ (u, v)</formula><p>All three measures are focused on keeping edges close to the diagonal and are hence optimized by orderings which form block patterns along the diagonal (see Figure <ref type="figure">3</ref> top left). They are used both in optimization functions and, specifically linear arrangement, as a measure for the final quality of a matrix visualization. However, several meaningful patterns which correspond to salient structures in the input graph are not related to distance from the diagonal. Furthermore, the bandwidth anti-pattern (which does not match a logical structure in the input graph) is in fact a typical result of optimizing for ordering distance. See Figure <ref type="figure">3</ref> for an illustration of the most common patterns according to the survey by Behrisch et al. <ref type="bibr" target="#b8">[8]</ref>. Table 1 lists each of the three ordering distance measures for each pattern and anti-pattern (lower = better). Bandwidth and linear arrangement, for example, assess the off-diagonal block pattern as worse than the bandwidth anti-pattern, and profile cannot distinguish between these. In contrast, Moran's I consistently ranks the patterns higher than the anti-patterns (higher = better). Adjacency. Measures in this category are usually used to compute distances between two (adjacent) rows of a matrix, based on the directly adjacent cells in the respective rows. Two vertically or horizontally adjacent black squares correspond to two edges which share a vertex. Hence, in some sense these measures promote the clustering of the neighborhood of vertices in the graph into adjacent cells of the matrix. Adjacency measures naturally generalize to the complete matrix and hence are used also as part of optimization functions. So far, measures in this category do not appear to have been used as a quality measure for the final matrix visualization.</p><p>Moran's I, which we will describe in greater detail in the next subsection, is an adjacency measure, and so are the measure of effectiveness by McCormick et al. <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b29">29]</ref> and the stress measure by Niermann <ref type="bibr" target="#b31">[31]</ref>. All standard distance measures for vectors fall into this category as well, such as the Euclidean distance L 2 . Note that the squared Euclidean distance is identical to the Manhattan distance for 0 − 1 vectors.</p><p>Lenstra and Kan <ref type="bibr" target="#b26">[26]</ref> observed that an optimal ordering for the measure of effectiveness is equivalent to a traveling salesperson path, Table <ref type="table">1</ref>. Metrics for the patterns and anti-patterns in Figure <ref type="figure">3</ref>. For the first three metrics lower is better, while for the Moran's I higher is better. where each matrix row corresponds to a city and the distance between two rows is measured by the number of pairwise vertical black-black adjacencies. In fact, every adjacency measure is optimized globally via a traveling salesperson path. The Bond Energy Algorithm by Mc-Cormick et al. <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b29">29]</ref> is in fact a heuristic for TSP using the measure of effectiveness. The popular leaf order heuristic is a heuristic for TSP as well, using the Euclidean distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Spatial auto-correlation: Moran's I</head><p>We observe that salient patterns are formed by clusters of black cells: moving rows (vertices) close together which have similar neighborhoods. As such, we postulate that promoting patterns is a form of spatial auto-correlation. Spatial auto-correlation measures are global measures of structure in the data. The matrix visualization in this context becomes the data for which we try to measure spatial auto-correlation. We propose to use Moran's I <ref type="bibr" target="#b30">[30]</ref>, one of the prominent measures for spatial auto-correlation. This very general measure requires values associated with each cell and a weight matrix which captures how the cells are structurally (visually) related. In our case, we associate the values 1 and 0 with each cell, depending on whether the associated edge is in E or not. We design the weight matrix such that each cell is considered adjacent (with weight 1) to the cells with which it shares a border and unadjacent (weight 0) otherwise. Higher scores in Moran's I indicate a stronger correlation and are thus desirable for an ordering.</p><p>As described above, we use Rook's adjacency rather than Queen's adjacency 2 . Our motivation is twofold. First, two cells (i, j) and (i , j ) correspond to two edges and thus up to four vertices. If each of these has a different value, we get indeed four vertices and the two edges connect two arbitrary pairs. As such, it does not match to a local structure. However, if the two cells are in the same column or row, there are only three vertices, and thus it describes a small pattern of two vertices sharing a common neighbor. Second, Moran's I with Queen's adjacency fails to capture negative spatial auto-correlation on the prototypical chess board of alternating black and white cells.</p><p>In our setting, Moran's I effectively simplifies to the following expression (see below for a derivation).</p><formula xml:id="formula_4">I(G, ρ) = c B (G) • B(G, ρ) + c W (G) •W (G, ρ) − 1</formula><p>Here, B(G, ρ) and W (G, ρ) refer to the number of black-black and white-white adjacencies, respectively. See Figure <ref type="figure" target="#fig_2">4</ref> for illustrations. The c-terms are constants, relying only on the number of vertices and edges in G, that weigh the relative impact of these types of adjacencies. Generally speaking, if the matrix has more white cells than black cells, black-black adjacencies have more impact and vice versa. Derivation. Here we present a brief derivation of our simplified form of Moran's I, starting from its general form. For a detailed derivation, refer to Section A of the supplementary material.</p><p>A graph G = (V, E) on n vertices for some fixed ordering ρ implies an n×n 0-1 matrix M where M i j = 1 if ρ(i, j) ∈ E and 0 otherwise. The cells of M are interpreted as the spatial units for the sake of Moran's I, and contains all necessary information to derive Moran's I. We hence omit dependencies on G and ρ in our derivation here, for sake of notational simplicity.</p><p>We use slightly different notation than perhaps conventional for the general form of Moran's I, so as to distinguish between the general form and our simplified form. Specifically, we use r instead of N to denote the number of spatial units (regions) and use a weights matrix T (topology) with sum t instead of w with sum W . Moreover, we refer to the regions using indices a and b rather than i and j.</p><p>Moran's I is defined over r spatial units, which have associated values x a for a ∈ {1,...,r}. Furthermore, an r × r matrix T encodes the weights for (typically neighboring) regions: entry T ab is the weight between region a and b. We use t to denote the sum over all weights in T . Moreover, let x denote the average value ∑ r a=1 x a r</p><p>. The general form of Moran's I is as follows <ref type="bibr" target="#b30">[30]</ref>:</p><formula xml:id="formula_5">I = r t • ∑ r a=1 ∑ r b=1 T ab (x a − x)(x b − x) ∑ r a=1 (x a − x) 2</formula><p>As the cells of M correspond to spatial units, we have r = n 2 . Let m denote the total number of entries with value 1 in M (the number of edges, with double counting). Hence, x = m n 2 and we can rewrite</p><formula xml:id="formula_6">x a − x = x a n 2 −m n 2 .</formula><p>This allows us to simplify the generic form to</p><formula xml:id="formula_7">I = n 2 t • ∑ r a=1 ∑ r b=1 T ab (x a n 2 − m)(x b n 2 − m) ∑ r i=1 (x a n 2 − m) 2</formula><p>. With Rook's adjacency, T ab is 1 if a and b are adjacent cells in M and 0 otherwise. We thus need to consider only the terms for which T ab is 1, i.e., for adjacent cells in M. Furthermore, since M is a 0-1 matrix, x a is either 0 or 1: the term x a n 2 − m is either n 2 − m or −m. In the denominator, there are hence two cases to consider (white cells and black cells) and for the numerator there are three cases (a and b describe a white-white, black-black, or black-white adjacency). The contribution to Moran's I is the same per case.</p><p>We thus case simplify this summation by simply counting the number of occurrences of each case, and we identify B (black-black), W (white-white) and D (black-white) with this count. There are 2n(n − 1) adjacencies, but we count every adjacency twice since T is symmetric: </p><formula xml:id="formula_8">t = ∑ T ab = 4n(n − 1).</formula><formula xml:id="formula_9">I = n 2 4n(n − 1) • 2B • (n 2 − m) 2 + 2W • (−m) 2 + 2D • (n 2 − m)(−m) m(n 2 − m) 2 + (n 2 − m)(−m) 2 = 1 2n(n − 1)m(n 2 − m) • (B • (n 2 − m) 2 +W • m 2 − D • (n 2 − m)m) Since B +W + D = 2n(n − 1)</formula><p>, we see that it suffices to count only B and W . This allows us to simplify the expression to a sum of B and W , introducing c B and c B as the coefficients of B and W :  <ref type="table">1</ref> that the patterns score considerably higher than the anti-patterns. As such, this makes the measure more amenable for algorithmic use. Indeed, we see that we are effectively counting cells in determining similarity of neighborhoods. We denote with B(G, u, v) the number of (vertical) black-black adjacencies we would obtain when u and v are made adjacent in the ordering -the number of common neighboring vertices in G; similarly, W (G, u, v) denotes the white-white adjacencies for u and v -the number of vertices in G that are neighboring to neither u nor v. Measuring the neighborhood similarity between u and v as s</p><formula xml:id="formula_10">I = B • n 2(n − 1)m +W • n 2(n − 1)(n 2 − m) − 1 = c B • B + c W •W −</formula><formula xml:id="formula_11">(G, u, v) = c B (G) • B(G, u, v) + c W (G) •W (G, u, v)</formula><p>, we get the following form of the metric:</p><formula xml:id="formula_12">I(G, ρ) = −1 + 2 n−1 ∑ i=1 s(G, ρ(i), ρ(i + 1))</formula><p>Maximizing Moran's I is equivalent to maximizing the sum of s over adjacent rows. However, many algorithms such as leaf order are based upon minimizing a sum of distances. Hence, we define a Moran's</p><formula xml:id="formula_13">I metric δ I (G, u, v) = 1 − s(G, u, v), which gives that I(G, ρ) = n − 2 − 2 ∑ n−1 i=1 δ I (G, ρ(i), ρ(i + 1)</formula><p>). Now, maximizing Moran's I corresponds exactly to minimizing the sum of distances. We do observe that δ I is not a proper metric, since identical rows do not have a distance of zero. This identity of indiscernables is inherently incompatible with Moran's I as two fully black rows and two fully white rows should score differently depending on the number of black cells over the entire matrix. Nonetheless, the triangle inequality holds: <ref type="figure">, u, w</ref>). However, we know that I(G, ρ) cannot exceed one and thus s(G, u, v) + s(G, u, w) ≤ 1, which proves the claim.</p><formula xml:id="formula_14">δ I (G, u, w) ≤ δ I (G, u, v)+δ I (G, v, w) rewrites to 1 + s(G, u, w) ≥ s(G, u, v) + s(G</formula><p>Measure δ I can generally be used with methods that are based on distance measures between rows such as leaf order. It also works well with algorithms that are designed for metric TSP and rely on the triangle inequality in their approximation guarantees. Furthermore, we believe that this relation between spatial auto-correlation and neighborhood similarities helps to explain why neighborhood measures for computing orderings have been successful and popular in practice. Relation to other adjacency measures. The measure of effectiveness by McCormick et al. <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b29">29]</ref>, when translated to 0 − 1 valued (whiteblack) matrices, simply counts '1' for each vertical or horizontal blackblack adjacency, and '0' otherwise. As such it is a less refined form of Moran's I. The stress measure proposed by Niermann <ref type="bibr" target="#b31">[31]</ref>, which uses Queen's adjacency, is related to Moran's I as well; the final score is the sum of all squared differences between a cell and its neighbors. As already mentioned above, diagonal adjacencies do not capture a graph property, they simply arise from two independent edges. Hence, this stress measure is less suitable to optimize adjacency matrices of graphs. Finally, the popular leaf order heuristic 3 uses the Euclidean distance 3 "[leaf order] consistently generates excellent results visually" Fekete <ref type="bibr" target="#b17">[17]</ref> I(G, ρ) = 0.66</p><formula xml:id="formula_15">I(G, ρ) = 0.33 I(G, ρ) = 0.29 I(G, ρ) = 0.63 I(G, ρ) = 0.65 I(G, ρ) = 0.30 I(G, ρ) = 0.20 I(G, ρ) = 0.63</formula><p>Fig. <ref type="figure">5</ref>. Optimizing Moran's I using NN-2OPT (top row) and leaf order (bottom row), matrices from <ref type="bibr" target="#b8">[8]</ref>.</p><p>between row vectors. For a 0-1 valued matrix, the Euclidean distance simply counts '1' for each black-white adjacency and then takes the square root of this sum. Orders produced with the leaf order algorithm hence tend to score very well on Moran's I. Optimizing Moran's I. As mentioned in Section 3, every adjacency measure is optimized via a traveling salesperson path. Since TSP is NP-hard to compute, we implemented the Nearest Neighbor (NN) heuristic using δ I and further optimized the results using the 2-OPT algorithm <ref type="bibr" target="#b13">[13]</ref> as long as Moran's I improves by more than 0.0001. Figure <ref type="figure">5</ref> shows the results for the four running-example matrices from the survey paper by Behrisch et al. <ref type="bibr" target="#b8">[8]</ref>; each was computed in less than half a second. For comparison, we also include the results using leaf order with the L 2 metric. We see that NN-2OPT manages to achieve higher quality in terms of Moran's I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">COMPUTING SIMULTANEOUS ORDERINGS</head><p>There are various ways in which a simultaneous ordering can be computed. In the literature, we find two approaches that rely on computing an ordering for a single graph. A simple method, used by both Cubix <ref type="bibr" target="#b2">[3]</ref> and MultiPiles <ref type="bibr" target="#b1">[2]</ref>, to compute an ordering is to base it on a single graph, using any algorithm; this ordering is then simply applied to the other graphs as well. However, we do not consider such an approach to really address the simultaneous ordering problem, as it uses the structure of only a single graph.</p><p>Below we review what we refer to as the union approach that is suggested by MultiPiles <ref type="bibr" target="#b1">[2]</ref> for the leaf order method and apply it to the barycenter method as well. We then propose our new collection-aware approach which overcomes the loss of information that arises in the union approach (see also Figure <ref type="figure">1</ref>), and show how to apply it to the leaf order method and the barycenter method. As we extend these methods, below is a brief summary of their basic steps (see also the survey <ref type="bibr" target="#b8">[8]</ref> for details on these methods). Leaf order. The leaf order method <ref type="bibr" target="#b3">[4]</ref> computes an ordering in three stages: first, the distance between each pair of vertices is determined, based on some distance measure δ (G, u, v); second, this information is used to construct a hierarchical clustering on the vertices -our implementation is built on reorder.js 4 which uses greedy completelinkage clustering here; third, the ordering ρ is computed that minimizes ∑ n−1 i=1 δ (G, ρ(i), ρ(i + 1)) and "adheres" to the clustering tree. "Adhering" here means that the ordering matches the order in which an in-order traversal visits the leaves of the tree; effectively, we can choose for each internal node of the tree which of its two children will be the left and the right child. Note that this choice is for every node and thus allows completely reversing the leaves in any subtree. As not all permutations adhere to a given hierarchy, this method avoids the complexity that is inherent in the TSP formulation; indeed, this problem can be solved optimally in an efficient manner <ref type="bibr" target="#b11">[11]</ref>. Often, this approach is implemented using for δ some measure of (dis)similarity between N(G, u) and N(G, v).</p><p>Barycenter method. The barycenter method <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b27">27]</ref> (see also the survey <ref type="bibr" target="#b8">[8]</ref>) focuses on optimizing "crossings", a standard measure of quality in traditional node-link drawings of graphs. The number of crossings incurred by an ordering ρ of G = (V, E) is defined as follows: we duplicate each vertex v into v 0 and v 1 , and draw v i at (ρ(v), i); we then draw every edge (u, v) ∈ E as two line segments, u 0 v 1 and v 1 v 0 ; the number of crossings caused by these line segments (excluding common endpoints) is the number of crossings that ρ incurs.</p><p>The basic barycenter method works in two phases. First, starting from an arbitrary ordering, the ordering is repeatedly updated by sorting the vertices according to the median rank of its neighbors. This is done at least for a fixed number of iterations, possibly followed by additional iterations until the number of crossings no longer decreases ("convergence"). Second, a postprocessing step is applied which tries to swap adjacent vertices in the ordering, while such a swap reduces the number of crossings further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The union approach</head><p>With MultiPiles, Bach et al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">Section 4.7]</ref> suggest an approach to computing a simultaneous ordering: "MultiPiles can calculate a global ordering which tries to find a topological clustering across all matrices". The paper itself provides no further detail on this method, but as their code is open source 5 , we were able to extract the exact algorithm. What follows is first our general interpretation of their approach, followed by their exact implementation on the leaf order heuristic.</p><p>The union approach takes the (weighted) union over all graphs in G to arrive at a graph H on the same vertex set V , where each edge has a weight corresponding to the number of graphs of G it occurs in. Effectively, it is the sum over all 0-1 adjacency matrices. We may apply any ordering algorithm to H and apply the resulting ordering to all graphs in G . For a vertex v, N(H, v) = ∑ G∈G N(G, v) is now a vector of length n where each entry is an integer in {0,...,k}, reflecting the weight of the associated edge.</p><p>The drawback of the union approach is a potential information loss, as H does not store information on which of the underlying graphs the edges actually occur in. In the extreme case, H could be a complete graph with unit weights for all edges, even though the underlying graphs have structures; imagine for example, two cliques in one graph and a biclique connecting the vertices of the two cliques in a second graph. In this case, all neighborhoods are identical and as such, there is no information left in H to inform a suitable simultaneous order. This is in fact our example in Figure <ref type="figure">1</ref>, though we introduced some "noise" in this figure. The advantage is its simplicity: techniques that inherently work on (or straightforwardly generalize to) weighted graphs can readily be applied. It could in principle also be applied to techniques for unweighted graphs, but this only exacerbates the information loss.</p><p>Union leaf order. MultiPiles <ref type="bibr" target="#b1">[2]</ref> applies the union approach to the leaf order method. This algorithm readily works on weighted graphs, and all it needs is some choice of measure δ . The MultiPiles implementation uses</p><formula xml:id="formula_16">δ (u, v) = L 2 (N(H, u), N(H, v)) = L 2 (∑ G∈G N(G, u), ∑ G∈G N(G, v))</formula><p>, that is, the Euclidean distance between neighborhoods. In general, we may of course use other measures instead of L 2 in the same fashion. We observe that squaring has no effect on comparisons of distances and thus does not affect the result of the complete-linkage clustering; it may however alter the eventual ordering, since comparisons between sums of distances may change.</p><p>But we may also use, for example, a Moran's I-based metric. We shall refer to it in this context also as δ I , but observe that it is not simply counting the number of black-black and white-white adjacencies. Instead, we compute δ I (u, v) = − ∑ x∈V (w(u, x) − w)(w(v, x) − w) where w(a, b) is the weight of edge (a, b) in H, i.e., the number of graphs in G it occurs in, and w is the average weight over all pairs. Effectively, this is the original Moran's I formula where we forego the normalization terms as they are all the same for a given matrix; we multiply this by −1 as to obtain a distance function. As the implementation relies only on comparisons and sums, the negative values do not cause issues in this method -though we could factor in the normalization and add 1 as we did for δ I in Section 3 to obtain a nonnegative measure that satisfies triangle inequality.</p><p>We observe the loss of information here as follows. Whereas indeed similar neighborhoods across the graphs lead to similar sums, the converse is not true: similar sums do not imply similar neighborhoods across the graphs. As such, the method may promote putting two vertices adjacent in the ordering that look similar in H but are actually not similar in any of the individual graphs. Union barycenter. The barycenter method is typically applied in an unweighted setting. However, the crossing measure readily generalizes to a weighted setting. That is, rather than counting the number of crossings, we multiply the weights of two intersecting edges and sum the result of all intersecting pairs. We refer to this as the union barycenter.</p><p>We observe the information loss here as follows. Whereas crossings in one of the graphs contribute to the cost of an ordering, a counted crossing need not actually be present in any of the graphs in the collection. That is, two edges may cross in the union, but not occur together in any graph, and as such incorrectly contribute to the cost.</p><p>Though the second stage is readily affected by this change in measure, we note that it does not truly affect the first stage, beyond testing convergence: the ordering by median ranks of neighbors remains the same. We could apply a weighted median instead, or revert to using the actual (weighted) barycenters. As such, if this is pursued, it may be worthwhile to revisit this idea and in fact compute with the actual weighted barycenter. However, such extension is beyond the scope of our work here, as we focus on avoiding the loss of information that the union approach incurs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The collection-aware approach</head><p>We propose a new approach to computing simultaneous orderings, one that is collection-aware. That is, we push the graph collection actually into the algorithms that compute orderings as much as possible. Specifically, when an algorithm makes decisions about the quality of an ordering, or how to modify an ordering based on neighborhoods, we now base this information on all graphs, rather than some aggregated form. In this manner, we may prevent the information loss that the union approach incurs. How this is done specifically, naturally depends on the algorithm under consideration. Collection-aware leaf order. As all information is captured in the pairwise distances between vertices, it suffices here to ensure that δ is collection-aware. That is, δ (u, v) should be low if u and v have similar neighborhoods in many graphs, and vice versa. Whereas the union approach gives the former, it does not succeed in the latter.</p><p>Rather than δ (u, v) = L 2 (∑ G∈G N(G, u), ∑ G∈G N(G, v)), a collection-aware interpretation would apply these operators the other way around:</p><formula xml:id="formula_17">δ (u, v) = ∑ G∈G L 2 (N(G, u), N(G, v)).</formula><p>Again, we observe that we may replace L 2 with other distance measures as well. Specifically, observe that L 2 2 , using the squared Euclidean distance, is different from using L 2 now also in the clustering step. Also, we can again use the Moran's I-based metric δ I where we can now rely on the metric formulation as presented in Section 3.</p><p>Note that this provides no computational overhead in asymptotic terms. As adding vectors is typically slightly faster than computing distances, we may expect a slight overhead. Yet, this is likely overshadowed by the clustering and leaf order stages of the algorithm and as such barely noticeable. Collection-aware barycenter. In our collection-aware barycenter implementation, we go back to counting crossings (as we assume unweighted graphs in G ), but we now do so for each graph separately and then take the sum over all graphs. This makes the second stage collection-aware.</p><p>However, as before, changing the way we measure crossings does not readily influence the procedure in the first stage, beyond testing convergence, as this is based purely on the ranks of the neighbors. In a collection-aware approach, however, we should strive to base these decisions on ordering on all graphs. Rather than using all neighbors in all graphs to determine the target rank of a vertex, we determine the target rank per graph, and aggregate this information. We implement this as follows. For every vertex, we compute the median rank of its neighbors in each graph in G separately to arrive at a set of median ranks. Subsequently, we compute the median of these median ranks. In the event that a vertex has no neighbors at all in a graph, it is omitted from the set of median ranks. Sorting then proceeds as before, but is now based on the median of medians instead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTS</head><p>Here we present the results of a brief experimental evaluation that aims to quantify how much improvement our collection-aware approach provides compared to the union approach, via various implementations. Moreover, we also investigate the use of Moran's I as a distance measure for optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Setup</head><p>Algorithms. We have two approaches to solving the simultaneous ordering problem: (U) union and (C) collection-aware. We have shown how to implement these approaches on two base algorithms: (LO) leaf order and (BC) barycenter. Finally, LO can work with various distance metrics. In particular, we use Euclidean distance L 2 and the Moran's I-based metric δ I , as well as their squared variants L 2 2 and δ 2 I . We name each algorithm using a concatenation of these abbreviations. For example, U-LO-L 2 refers to the union leaf order method using L 2 , effectively the implementation suggested by MultiPiles; C-LO-δ 2 I refers to the collection-aware leaf order method using δ 2 I as a metric; C-BC refers to the collection-aware barycenter method. Our implementation of the ten resulting algorithms is openly available on GitHub 6 . Data. We test our algorithms with three datasets, chosen to obtain a variety of characteristics, ranging from many graphs with few vertices, to few graphs with many vertices; Table <ref type="table" target="#tab_3">2</ref> provides some basic statistics.</p><p>FLT The "flashtap" data that was used for MultiPiles <ref type="bibr" target="#b1">[2]</ref>  7 . It represents functional brain connectivity in a Parkinson's disease study.</p><p>SCH Social interaction between children and teachers at a primary school <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b33">33]</ref> </p><p>VIS Publications data in the InfoVis conference <ref type="bibr" target="#b25">[25]</ref> 9 . We construct a graph on the authors for each year from 2015 to 2020, where an edge between two authors is included if they had a joint paper in this period. We include only authors with publications in at least three years and their co-authors.</p><p>The density m/n 2 of these graphs varies (Table <ref type="table" target="#tab_3">2</ref>). Arguably, graphs with low density such as the VIS co-authorship network are better visualized using other visual idioms, for instance, node-link diagrams or hybrid visualizations, but we include them here to investigate our algorithms under diverse circumstances. For each dataset we also measured the change Δ between graphs, which is the number of cells in the matrix that change their value. Though expressed as a fraction of the entire matrix (where FLT changes most, and VIS the least), these values can also be interpreted with respect to the edge density (in which case VIS changes most, relatively speaking, and FLT the least). Quality measures. We measure the quality of the resulting matrix orderings via the current standard of linear arrangement as well as with Moran's I. Whereas Moran's I is normalized to [−1, 1] by definition, linear arrangement is not. We normalize a linear arrangement value a to 1 − a/M, where M is the maximum value over all algorithms and graphs of the same dataset. Hence, the normalized linear arrangement  <ref type="bibr">]</ref>, where 1 is the best performing matrix, such that in both measures, higher values correspond to higher quality. Note that we measure our metrics for each graph in the collection separately. As such, we obtain a distribution of ordering quality, for each algorithm-dataset combination. We focus on the minimum, average and median quality. The latter two simply because we aim for high overall quality. The minimum, however, is also specifically useful since it gives us an idea of the worst matrix in the collection. Ideally, we would want to avoid slightly improving many graphs at the expense of greatly reducing the quality of one graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results</head><p>Figure <ref type="figure" target="#fig_0">2</ref> in Section B of the supplementary material shows the results for each algorithm on each dataset in terms on the two measures. Our primary observation here is that using squared versions of metrics changes the results, but does not seem to considerably change the overall performance (in terms of means, medians and minima). Refer to the tables in Section B of the the supplementary material for precise differences; averaged over all datasets the differences do not exceed  0.02 for Moran's I. A notable outlier is the differences in the VIS dataset between using L 2 2 and L 2 for collection-aware leaf order, though we do not investigate this further.</p><formula xml:id="formula_19">U-LO-L 2 G 1 C-LO-δ I G 48 G 96</formula><p>Here, we focus on the six algorithms that do not use the squared distance functions. In Section B of the supplementary material, Figures 3 to 16, we show all matrix visualizations obtained through the six ordering algorithms for the FLT dataset. Figure <ref type="figure" target="#fig_3">6</ref> shows an excerpt of the FLT dataset for U-LO-L 2 (as proposed in <ref type="bibr" target="#b1">[2]</ref>) and C-LO-δ I (our proposed algorithm). Clearly, each of the matrices in isolation can be improved, but each column uses but one ordering by design, which must work well for all 96 graphs in the collection. We may observe that block patterns feature more strongly in the C-LO-δ I result; the U-LO-L 2 result partitions these into smaller block patterns complemented by matching off-diagonal blocks.</p><p>A summary of the results of the six algorithms are shown in Figure <ref type="figure" target="#fig_4">7</ref>. Below, we discuss various comparisons based on Moran's I, before briefly discussing linear arrangement.</p><p>(U/C)-LO-L 2 . Let us first compare the performance of the union and collection-aware implementations of leaf order, using the standard Euclidean distance. Generally, we see very similar performance between these methods. For FLT and SCH, the median and average improve slightly in the collection-aware variant (difference of 0.02 and 0.03 for median, and 0.01 and 0.02 for average); the minimum improves more, 0.06 (FLT) and 0.07 (SCH).</p><p>For VIS we actually see a decrease, roughly −0.03 for each statistic. We attribute this to the overall sparsity of the graphs. The Euclidean distance may weigh white-white adjacencies too heavily, whereas they contribute little to improving Moran's I. Using a union gives for a slightly denser graph and thus may help in finding some structure in this specific case.</p><p>In this comparison, we conclude that there indeed is some information loss in the union approach. The medium-density graph improves most, hinting that very dense graphs and very sparse graphs suffer less from the information loss that complementary patterns may give -though this may benefit more structural investigation using more (controlled) datasets.</p><p>(U/C)-LO-δ I . Let us now repeat the above comparison, but with algorithms based on the Moran's I metric δ I . We now see an improvement for each dataset. On average, the minimum Moran's I improves by 0.07 and the median and average by 0.02 and 0.03 respectively. Most different from the previous comparison is the improvement for VIS. From this we conclude that the collection-aware approach actually does help to make find structures in very sparse graphs. That is, the decrease in performance can be attributed to the use of the Euclidean distance rather than the collection-aware approach itself. C-LO-(L 2 /δ I ). From the above, we may conclude that our collectionaware adaptations yield benefits in terms of Moran's I. So, we now briefly consider the choice of metrics between the collection-aware implementations. We see that on average (in terms of minimum, average and median) using δ I improves Moran's I by 0.04 compared to using L 2 . Some improvement was to be expected, since the method now (heuristically) optimizes the quality measure directly. Yet, the effect is somewhat small in that light.</p><p>Primarily, we can conclude that the Euclidean distance serves well as a proxy. We see that this proxy suffers in case of very sparse graphs (VIS), where using δ I improves considerably more (differences of 0.12 to 0.14) than in the other datasets. The equal treatment of types of adjacencies in the Euclidean distance does seem to hinder it, in obtaining high Moran's I. (U/C)-BC. Let us now briefly turn to the barycenter method. We see here again a strong difference between datasets. Whereas C-BC clearly outperforms U-BC (differences of 0.08 to 0.15) for FLT and SCH, the opposite it true for VIS. Again, we can attribute this to the sparsity of the graph. As many vertices have edges in only one graph, their ranks in the collection-aware method are based primarily on that one graph -which may interfere with other graphs. With the union approach, at least everything is treated centrally and thus the information in the slightly denser union graph is indeed a bit more rich. Linear arrangement. Though it focuses on block patterns only and does not generally measure the degree of structure of the visualization, linear arrangement is the de-facto standard for automatically measuring ordering quality <ref type="bibr" target="#b8">[8]</ref>. We briefly consider it for this reason.</p><p>For FLT, we may observe that the U-LO variants outperform C-LO approaches, though the performance between C-LO variants is mostly similar. For the barycenter method, this is rather the other way around: C-BC outperforms U-BC.</p><p>For SCH, we see more spread of the linear arrangement within one graph collection, but this may be an effect of the normalization. Though U-LO-δ I still slightly outperforms C-LO-δ I , we now see that C-LO-L 2 offers a slight improvement on U-LO-L 2 . C-BC still outperforms U-BC in terms of median and average, though its minimum is now considerably lower.</p><p>For VIS, we again see that the U-LO variants outperform C-LO approaches, now with a considerable difference. Interestingly, C-BC is now slightly under U-BC as well. We may attribute this again to the sparsity of the dataset.</p><p>We conclude that, for linear arrangement, the union approach is typically better than the collection-aware approach to leaf order. For the barycenter method, however, this appears to be opposite, unless the dataset is excessively sparse. This is, perhaps, not surprising since the crossing measure underlying the barycenter methods discourages "long edges" and thus off-diagonal cells. With the collection-aware approach, we see that this indeed avoids information loss, unless there is very little information to begin with -in which case the union method strengthens the signal of the little information that is available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overall comparison.</head><p>Considering the above, we may conclude that our collection-aware adaptations have been successful in improving Moran's I and thereby the structure of the resulting matrix visualizations. We observe that C-LO-δ I performs best over all methods, with higher minimum, median and average scores compared to all other methods. It specifically performs better on the minimum compared to other LO variants, and considerably improves upon BC variants. Whereas the barycenter method focuses (indirectly) more on block structures and thus linear arrangement, we do not see it consistently outperforming the leaf order methods even in this criterion. We would thus recommend the use of C-LO-δ I as the most versatile algorithm for solving the simultaneous ordering problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>In this paper we considered the problem of computing simultaneous orderings for graph collections. That is, given a set of graphs, compute a single ordering that works well for visualizing each graph as a matrix. To automatically assess quality, we observed that patterns in the matrix can be seen as a form of spatial auto-correlation and thus proposed the use of Moran's I as a global measure of quality. Moran's I readily implies a distance metric between two vertices that can be used in algorithms such as leaf order, as an alternative to other common functions that measure adjacencies or neighborhood similarity.</p><p>Algorithmically, computing simultaneous orderings has received little attention. We generalized the union approach that is found in MultiPiles, but observed that this may lead to hiding structural information from the ordering algorithms. Instead, we proposed a generic collection-aware approach that avoids such loss of information and showed how to apply this approach to the common leaf order and barycenter methods.</p><p>Our experiments demonstrate that our collection-aware approach is effective, especially leaf order based on the Moran's I-inspired metric. Our collection-aware leaf ordering method using δ I is the most versatile and consistently performs equally or better than the other algorithms, though the magnitude of improvement varies between datasets. For other algorithm comparisons, there is less consistency in relative performance, also interacting with dataset. Our results confirm that the potential information loss as sketched for the union approach indeed occurs, also in real datasets. Though it does not occur to such a degree to really cause arbitrary orderings as in hypothetical constructed cases, it nonetheless leads to inferior orderings when not accounting for the collection of graphs in the ordering algorithms.</p><p>Future work. There is not a clear metric, the optimization of which gives visually the best or most useful ordering, even for a single graph. Though we postulate that Moran's I can be effective here, further re-search is needed on how this concept actually relates to perceiving structure in matrix visualizations. Our focus was with algorithm-compatible measures, but such future work can likely leverage the work on magnostics <ref type="bibr" target="#b6">[7]</ref>. Furthermore, it may be worthwhile to investigate the perceptual effects that improving Moran's I brings; for example, Beecham et al. <ref type="bibr" target="#b5">[6]</ref> study the "just noticeable difference" of Moran's I and their experiment includes weight grids as well. It suggests a degree to which Moran's I must improve for an observer to reliably identify the improved ordering, though in our case, we have black-and-white and symmetric matrices, which may influence the perception.</p><p>With our work, we provide (to the best of our knowledge) the first explicit definition of the simultaneous ordering problem for visualizing graphs using matrices. Our general concept of making algorithms collection-aware is applicable to other alternatives. Especially distancebased approaches like leaf order are easily amended. But we could also consider other ways in making algorithms collection-aware, and indeed, some algorithms may be more suitable than others for such adaptation. Can we, for example, in fact directly modify the clustering algorithm in leaf ordering, or change the objective function in its final stage, to explicitly optimize e.g., the smallest sum?</p><p>Finally, our experiments show differences depending on the number of graphs and vertices in the dataset. Whereas for a few matrices (or a few MultiPiles) a single ordering can be effective, when using many matrices, one is bound to have to make concessions for many of them. As such, the question is perhaps, whether we could permit small changes to the ordering for each matrix, to better highlight the structure in each graph. In our next steps, we plan to address this challenge of "stable" orderings.</p><p>To conclude, perhaps the main take-away of our work here is that simultaneous matrix ordering is a complex algorithmic-visualization problem. We have now taken the first steps in bringing this to the fore and addressing the algorithmic challenges.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Moran's I counts vertical and horizontal adjacencies in three classes: black-black, white-white, and black-white.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>I 19 Fig. 3 .</head><label>193</label><figDesc>Fig.3. Patterns (black) and anti-patterns (red)<ref type="bibr" target="#b8">[8]</ref> with Moran's I score (higher = more correlated). Top row: block pattern, off-diagonal block pattern, noise anti-pattern; bottom row: line/star pattern, bands pattern, bandwidth anti-pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.<ref type="bibr" target="#b3">4</ref>. Visualizations of the same graph based on two different orderings, ρ and ρ . The bottom row shows the same visualizations, with annotated horizontal and vertical adjacencies. More such lines mean more samecolored adjacencies and thus a higher quality in terms of Moran's I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. A comparison of the state-of-the-art (U-LO-L 2 ) against our main contribution (C-LO-δ I ) on timesteps G 1 , G 48 and G 96 of the FLT dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig.7. Performance of the six main algorithms considered for each of the datasets (columns) in terms of Moran's I (top row) and Linear Arrangement (bottom row). For both, higher values indicate higher quality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>1</head><label></label><figDesc>Using Moran's I. With Moran's I, we have a measure that is aimed at capturing how well-structured the matrix visualization is. That is, it aims to globally capture patterns, without specifically aiming to specify what a pattern actually constitutes. We indeed see in Table</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>6 https://github.com/nvbeusekom/reorder.js 7 https://aviz.fr/ ˜bbach/multipiles/, accessed March 2021. 8 http://www.sociopatterns.org/datasets/ primary-school-temporal-network-data/, accessed March 2021. 9 https://sites.google.com/site/vispubdata/home, accessed March 2021 at version 9.02. Overview of datasets. k: number of graphs in collection; n: number of vertices in each graph; m: number of black cells in the matrix; Δ: number of changing edges between graphs. m and Δ are given as a percentage of the number of cells in the matrix (n 2 ), and we provide the mean μ and standard deviation σ .</figDesc><table><row><cell>Dataset</cell><cell>k</cell><cell>n</cell><cell cols="2">m/n 2 (%)</cell><cell cols="2">Δ/n 2 (%)</cell></row><row><cell></cell><cell></cell><cell></cell><cell>μ</cell><cell>σ</cell><cell>μ</cell><cell>σ</cell></row><row><cell>FLT</cell><cell>96</cell><cell>29</cell><cell>44.06</cell><cell>11.31</cell><cell>19.67</cell><cell>20.61</cell></row><row><cell>SCH</cell><cell>17</cell><cell>242</cell><cell>5.15</cell><cell>1.48</cell><cell>3.31</cell><cell>3.68</cell></row><row><cell>VIS</cell><cell>6</cell><cell>536</cell><cell>0.28</cell><cell>0.10</cell><cell>0.21</cell><cell>0.26</cell></row><row><cell cols="2">is a value in [0, 1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Note that the survey by Behrisch et al.<ref type="bibr" target="#b8">[8]</ref> defines the ordering function the other way around, from vertex to index; being a bijection, this is but a notational difference. We found that in our exposition, we rely mostly on the resulting row order so our definition avoids excessive use of the inverse.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">This refers to the movement capabilities of chess pieces.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">https://github.com/jdfekete/reorder.js/</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">https://github.com/benjbach/multipiles, accessed Feb. 2021.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Weighted graph comparison techniques for brain connectivity analysis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Alper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Henry Riche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Isenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<idno type="DOI">10.1145/2470654.2470724</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCHI Conference on Human Factors in Computing Systems</title>
				<meeting>SIGCHI Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="483" to="492" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Small MultiPiles: Piling time to explore temporal patterns in dynamic networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Henry-Riche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Grabowski</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.12615</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="31" to="40" />
			<date type="published" when="2015-05">05 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visualizing dynamic networks with matrix cubes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pietriga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<idno type="DOI">10.1145/2556288.2557010</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCHI Conference on Human Factors in Computing Systems</title>
				<meeting>SIGCHI Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="877" to="886" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fast optimal leaf ordering for hierarchical clustering</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="S22" to="S29" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>suppl 1</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A taxonomy and survey of dynamic graph visualization</title>
		<author>
			<persName><forename type="first">F</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Diehl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.12791</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="133" to="159" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Map LineUps: effects of spatial structure on graphical inference</title>
		<author>
			<persName><forename type="first">R</forename><surname>Beecham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dykes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meulemans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Slingsby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Turkay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="391" to="400" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Behrisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blumenschein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Delz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Von Rueden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Magnostics: Image-based search of interesting matrix views for guided network exploration</title>
		<author>
			<persName><forename type="first">T</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName><surname>Schreck</surname></persName>
		</author>
		<idno>doi: 10.1109/ TVCG.2016.2598467</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page">2016</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Matrix reordering methods for table and network visualization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Behrisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Henry Riche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schreck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Forum</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="693" to="716" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Quality metrics for information visualization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Behrisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blumenschein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">W</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>El-Assady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Seebacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Diehl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Brandes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schreck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.13446</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="625" to="662" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Simultaneous embedding of planar graphs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bläsius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Kobourov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Rutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Graph Drawing and Visualization</title>
				<editor>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</editor>
		<imprint>
			<publisher>CRC Press</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="349" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal leaf ordering of complete binary trees</title>
		<author>
			<persName><forename type="first">U</forename><surname>Brandes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="546" to="552" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Geometric simultaneous embeddings of a graph and a matching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cabello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Liotta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Speckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Verbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="79" to="96" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A method for solving traveling-salesman problems</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Croes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="791" to="812" />
			<date type="published" when="1958">1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Edge crossings in drawings of bipartite graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C</forename><surname>Wormald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="379" to="403" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">ZAME: Interactive large-scale graph visualization</title>
		<author>
			<persName><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-N</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Goodell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<idno type="DOI">10.1109/pacificvis.2008.4475479</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. 2008 IEEE Pacific Visualization Symposium</title>
				<meeting>2008 IEEE Pacific Visualization Symposium</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="215" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Simultaneous geometric graph embeddings</title>
		<author>
			<persName><forename type="first">A</forename><surname>Estrella-Balderrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gassner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Percan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th International Symposium on Graph Drawing</title>
		<title level="s">LNCS</title>
		<meeting>15th International Symposium on Graph Drawing</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4875</biblScope>
			<biblScope unit="page" from="280" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">js: A JavaScript Library to Reorder Tables and Networks</title>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName><surname>Reorder</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01214274/file/reorder.pdf" />
	</analytic>
	<monogr>
		<title level="m">Abstr. 2015 IEEE VIS posters</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Characterizations of restricted pairs of planar graphs allowing simultaneous embedding with fixed edges</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jünger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Kobourov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="385" to="398" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A technique for drawing directed graphs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Koutsofios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-P</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="214" to="230" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mitigation of infectious disease at school: targeted class closure vs school closure</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gemmetto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cattuto</surname></persName>
		</author>
		<idno type="DOI">10.1186/s12879-014-0695-9</idno>
	</analytic>
	<monogr>
		<title level="j">BMC infectious diseases</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">695</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A comparison of the readability of graphs using node-link and matrix-based representations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ghoniem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Castagliola</surname></persName>
		</author>
		<idno type="DOI">10.1109/INFVIS.2004.1</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Information Visualization</title>
				<meeting>IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Testing simultaneous planarity when the common graph is 2-connected</title>
		<author>
			<persName><forename type="first">B</forename><surname>Haeupler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jampani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lubiw</surname></persName>
		</author>
		<idno type="DOI">10.7155/jgaa.00289</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="147" to="171" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">MatLink: Enhanced matrix visualization for analyzing social networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Henry Riche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th IFIP TC13 International Conference on Human-Computer Interaction</title>
		<title level="s">LNCS</title>
		<meeting>13th IFIP TC13 International Conference on Human-Computer Interaction</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4663</biblScope>
			<biblScope unit="page" from="288" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Multiperspective, simultaneous embedding</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Hossain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Huroyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kobourov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Navarrete</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2020.3030373</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1569" to="1579" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Isenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Heimerl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Isenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stolper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sedlmair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2016.2615308</idno>
		<title level="m">vispubdata.org: A metadata collection about IEEE Visualization (VIS) publications. IEEE Transactions on Visualization and Computer Graphics</title>
				<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="2199" to="2206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Some simple applications of the travelling salesman problem</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H G R</forename><surname>Kan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operational Research Quarterly</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="717" to="733" />
			<date type="published" when="1970">1970-1977. 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The barycenter heuristic and the reorderable matrix</title>
		<author>
			<persName><forename type="first">E</forename><surname>Mäkinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Siirtola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Informatica (Slovenia)</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="357" to="364" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Identification of data structures and relationships by matrix reordering techniques</title>
		<author>
			<persName><forename type="first">W</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schweitzer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Problem decomposition and data reorganization by a clustering technique</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Mccormick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Schweitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="993" to="1009" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Notes on continuous stochastic phenomena</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A P</forename><surname>Moran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrika</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="17" to="23" />
			<date type="published" when="1950">1950</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Optimizing the ordering of tables with evolutionary computation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Niermann</surname></persName>
		</author>
		<idno>doi: 10.1198/ 000313005X22770</idno>
	</analytic>
	<monogr>
		<title level="j">The American Statistician</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="46" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Path visualization for adjacency matrices</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<idno type="DOI">10.2312/VisSym/EuroVis07/083-090</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Joint Eurographics / IEEE VGTC Conference on Visualization</title>
				<meeting>9th Joint Eurographics / IEEE VGTC Conference on Visualization</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">High-resolution measurements of face-to-face contact patterns in a primary school</title>
		<author>
			<persName><forename type="first">J</forename><surname>Stehlé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Voirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cattuto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Isella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Pinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Quaggiotto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Van Den Broeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Régis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lina</surname></persName>
		</author>
		<idno type="DOI">10.1371/journal.pone.0023176</idno>
	</analytic>
	<monogr>
		<title level="j">PloS one</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">TimeMatrix: Analyzing temporal social networks using interactive matrix-based visualizations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<idno type="DOI">10.1080/10447318.2010.516722</idno>
	</analytic>
	<monogr>
		<title level="j">International Journal of Human-Computer Interaction</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">11-12</biblScope>
			<biblScope unit="page" from="1031" to="1051" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
