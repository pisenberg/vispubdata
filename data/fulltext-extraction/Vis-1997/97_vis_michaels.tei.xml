<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">VizWiz: A Java Applet for Interactive 3D Scientific Visualization on the Web</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cherilyn</forename><surname>Michaels</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science B Engineering</orgName>
								<orgName type="institution">University of California San Diego</orgName>
								<address>
									<addrLine>9500 Gilman Drive, La Jolla</addrLine>
									<postCode>92093-011~</postCode>
									<region>California</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bailey</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Depadment of Computer Science d Engineering</orgName>
								<orgName type="laboratory">-011~ and San Diego SupercomputeT Centeq</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego, 9500 Gilman Drive, La Jolla, S an Diego</addrLine>
									<postBox>PO Box 85608</postBox>
									<postCode>92093, 92186-5608</postCode>
									<region>California, California</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">VizWiz: A Java Applet for Interactive 3D Scientific Visualization on the Web</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>VizWiz is a Java applet that provides basic interactive scientific visualization functionality, such as isosupfaces, cutting planes, and elevation plots, for 2D and 3D datasets that can be loaded into the applet by the user via the applet&apos;s web server. VizWiz is unique in that it is a completely platform independent scientific visualization tool, and is usable over the web, without being manually downloaded or installed. Its 30 graphics are implemented using only the Java AWT API, making them portable across all Java supporting pl8tfOrmS. This paper describes the implementation of VizWiz, including design tradeoffs. Graphics performance figures are provided for a number of different platforms. A solution to the problem of uploading user data files into 8 Java applet, working around security limitations, is demonstrated. The lessons learned from this project are discussed.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VizWiz</head><p>is a scientific visualization tool implemented as a Java applet.</p><p>Users can load their own 2D and 3D datasets into VizWiz, and visualize them interactively, using a number of standard scientific visualization techniques, such as isosurfaces, cutting planes, and elevation plots.</p><p>It is located at http://uuu.sdsc.edu/vizwiz/viz/vizui?..html, and can also be found in the Gamelan Java applet repository, http://vvv.gamelau.com.</p><p>VizWiz is unique in that it makes interactive 3D visualization functionality for any dataset available across the internet to anyone with a Java enabled browser. Its 3D graphics use only the Java AWT API [2], making them instantly portable across all Java supporting platforms. Through careful design and appropriate tradeoffs, we were able to obtain high performance for this Java only implementation.</p><p>The resulting applet is not only a useful platform independent visualization sketchpad, but also a demonstration of both the benefits and pitfalls of implementing a complex application as a Java applet</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIG. 1. The VizWiz User Interface</head><p>O-8186-8262-0/97 $10.00 Copyright 1997 IEEE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. MOTIVATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. A New Kind of Visualization Tool</head><p>There are plenty of scientific visualization tools available today. Viz5D <ref type="bibr">[l]</ref>, <ref type="bibr">AVS [6)</ref>, and IBM Data Explorer <ref type="bibr">[4]</ref> are just a few examples of excellent full-featured scientific visualization tools that have been available for some time. All these tools, and a.ll other scientific visualization applications around today, do, however, share a fundamental constraint. They are platform dependent. Many are, of course, available for multiple platforms, but only after being more or less painfully ported from one to another. Scientific visualization applications, with their emphasis on user interface and the graphical display of data, are never trivial to port. In addition, developers of a multi-platform application must of course test each code separately, and when changes are needed, they must be made to and tested in the code for every platform.</p><p>An obvious advantage of writing a scientific visua.lization application as a Java applet is that it works on all Java-supporting platforms, and only one version of the code needs to be created, tested, and maintained. Since Java code is compiled not into machine language, but into platform independent bytecode, a Java application or applet can be run just as easily on a 486 PC as on an SGI or a SPARCstation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Platform</head><p>independence alone makes VizWiz useful, There is simply no other way to perform 3D visualizations on such a wide variety of platforms, with so little overhead for both the user and the programmer.</p><p>Another constraint shared by all general scientific visualization tools available today is that they must be downloaded or purchased and installed by the user before they can be used. Although this is usually not particularly difficult, it is a discouragement to casual use of the tools.</p><p>It is not possible to try out a tool without going to considerable effort to download it, configure it, and so on. Ironically, although there are dozens of 3D visualization tools of one sort or another in existence, many of them available free over the Internet, many scientists still find it too much trouble to download and use them. Making a visualization tool available as a Java applet helps to solve this problem. An applet runs automatically when the web page in which it is embedded is downloaded into the user's web browser. In the case of VizWiz, not only does the applet run automatically when its web page is visited, but also loads in a sample dataset, which can immediately be experimented with by the user. Moreover, because VizWiz is resident on the Internet, and not on the user's local machine, it can be used anywhere the user has access to a Java enabled browser.</p><p>Our first motivation in creating VizWiz was thus to provide the scientific community with a new kind of scientific visualization tool. It would be platform independent, simple to use, trivial to try out, and would make 3D visualization functionality available to a wider audience, including some who might have been discouraged by the roadblocks encountered in using traditional visualization applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Testing the Suitability of a Java Applet for a Scientific Visualization Application</head><p>Since its introduction, Java has been hyped as the language that will enable a shift in applications from the desktop to the Internet.</p><p>The combination of the Web and CGI scripts in and of themselves have encouraged the development of a number of interesting applications related to scientific visualization.</p><p>These applications tend to be based on the construction or selection of images by CGI scripts based on user input in an HTML form, and are not interactive in the sense that a Java applet makes possible. The second motivation for developing VizWiz was to test the suitability of Java applets for developing useful scientific applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. GOALS AND IMPLEMENTATION</head><p>In light of the above motivations, we developed VizWiz with five goals in mind.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.</head><p>B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.</head><p>The tool had to be completely platform independent.</p><p>It had to be uncomplicated and easy to use, especially the first time.</p><p>It had to provide the expected basic set of 3D visualization functionality. D. Its performance had to be acceptably interactive, and its graphics acceptable attractive, even on low end machines. E. Users had to be able to easily use this tool to visualize their own datasets.</p><p>In order to come up with an application that met these goals, we had to make a number of design decisions and tradeoffs. The remainder of this paper will describe how VizWiz was implemented, demonstrate how it met the goals, and discuss what lessons we learned from the project.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Platform Independence</head><p>The first and foremost goal for this application was that it should be completely platform independent. This is, of course, not possible in a strict sense, but different language and environment choices give varying approximations of it. The inclusion of the Java runtime in Netscape Navigator and Microsoft Internet Explorer, by now almost ubiquitous applications across all common platforms, makes Java a compelling choice of language for a platform independent application. Moreover, since the only way to implement 3D graphics in Java without requiring that the user have installed any supporting software besides a Java-enabled web browser is to use the standard Java API, we chose to develop our rendering engine using only the built-in Java AWT.</p><p>Choosing Java with the AWT API for rendering brought with it significant penalties in terms of performance. VizWiz is both computationally and graphically intensive.</p><p>Since Java programs are interpreted, not run directly, they are in general slower than their native counterparts would be. Although just-in-time compilers can improve the situation, by translating bytecode into machine language on the fly, it will be a long time before these are ubiquitous enough to build into development strategies.</p><p>Moreover, the fact that Java is interpreted is not the most significant hindrance to performance.</p><p>All the windowing and graphics code in VizWiz uses the AWT library which comes with the Java environment, and obviously uses native windowing and graphics calls, and so one would assume that it is principally written in native code anyway. The simple fact that VizWiz has to do its 3D graphics in software, rather than being able to take advantage of machine specific accelerators and other hardware, is the greatest stumbling block in terms of performance. This is a problem that will be alleviated by the Java 3D API since it will enable platform specific AWT implementations to take advantage of 3D hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Ease of Initial</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use</head><p>Besides platform independence, the goal making VizWiz very easy to use the first time was the factor that cemented our choice of Java as development language. Java applications can be written as applets, which allows them to be downloaded and run automatically by a web browser.</p><p>Thus, running VizWiz for the first time is no more difficult than simply visiting a web page.</p><p>This choice too had ramifications in other areas of the project.</p><p>For security reasons, a Java applet running in Netscape or Internet Explorer is not allowed to access the file system of the machine on which it is executing. Although this restriction is sensible from a security standpoint, it definitely makes it challenging to design a useful application.</p><p>Any sort of application that operates on data files, from a word processor to a CAD program, needs to allow users to load data files, and usually to save them as well. Since there is no natural way to do this in the context of a Java applet, we had to design a system that made it as straightforward as possible for the user to upload data files for use by VizWiz, without actually allowing the applet to access the user's local file system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Visualization Functionality</head><p>VizWiz needed to provide a basic set of visualization functions.</p><p>We chose a core of functionality including support for isosurfaces, cutting planes, point clouds, and elevation plots. The surface functions are implemented as polygon surfaces, and can be viewed both as filled surfaces and as wireframe surfaces. A Marching Cubes algorithm</p><p>[5] was used to generate the isosurfaces. Some of these capabilities are shown in Figures 5-8. All these visualization objects are implemented in the same manner, as a set of vertices and connection indices, and a base color for each line or polygon thus specified. All visualization objects share the services of the same rendering engine. This arrangement makes it straightforward to add new visualization objects. In addition to the static specification of each polygon, two additional items are computed dynamically for each polygon: a color, based on the base color and the angle the polygon makes with the light source, and a distance from the camera, used for polygon sorting during rendering.</p><p>The VizWiz applet runs inside a window that pops up out of the browser page when a start button is pressed (see <ref type="figure">Figure 1)</ref>. A control panel on the lefthand side of the window allows parameters affecting all display objects in VizWiz to be set. For example, scaling, setting the desired resolution, and loading files are all done from inside the control panel. On the right hand side of the window is an inspector panel, a different one for each display object.</p><p>Each of these allows parameters relevant to its particular display object to be set. Any combination of display objects may be selected to appear simultaneously in the display. A display area in the center of the window shows the actual visualization, which can be rotated by dragging the mouse over top of it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Interactivity</head><p>In order to be useful, VizWiz needed to be able to perform 3D visualizations for at least moderately sized datasets in an adequately interactive manner. The fact that VizWiz was implemented in Java, and could not take advantage of any potential 3D graphics hardware, made this goal challenging to achieve. In order to compensate for the performance limitations of Java, we used a number of techniques, including smart caching, simplified rendering, and interactive resolution control, in addition to general attention to performanceissues throughout development . These rendering simplifications, allow significant complicated figures to be visualized interactively. Caching avoids duplication of expensive computations. Interactive resolution control allows the user to control the computational difficulty of the task at hand. The final result is an application with acceptable to excellent interactive performance in the face of what might seem at first to be overwhelming obstacles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Continuous OT Flat Shading Model</head><p>One of the first decisions to be taken was whether to support a continuous or a polygon based shading model. A continuous shading model, such as Phong or Gouraud shading, produces 3D models with impressively smooth looking surfaces, even if the actual surface is constructed of fairly large polygons. Since there is no support for continuous polygon shading in the Java AWT API, however, we would have needed to implement the shading ourselves by laboriously constructing images of shaded polygons on a pixel by pixel basis. The resulting image would need to be completely reconstructed whenever the displayed object was moved. Instead, to save time, we chose to flat shade each polygon. For surfaces that were composed of a large number of small polygons, this technique yielded surfaces similar in appearance to a truly smooth shaded one, but low resolution surfaces were able to be rendered relatively quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Hard and Soft Updates</head><p>The rendering engine was designed in two parts, with rendering efficiency in mind. Most of the interactive manipulation performed on a 3D model does not result in any change in the polygons comprising the model. They simply need to be transformed, colored, and depth sorted. Sometimes, however, the display objects themselves are actually changed, and all the display objects need to be recopied from scratch into the main display list. VizWiz takes advantage of this natural split by supporting two types of image updates.</p><p>The main type, a "soft" update, takes place most of the time and consists of performing the transformation, coloring, and sorting steps on the combined polygon list, as described above. From time to time, a "hard" update is necessary, whenever the actual polygons being displayed have changed. This "hard" update takes longer than a "soft" update, since the polygons and associated information need to be copied from their permanent locations inside particular display objects to the combined display list. Avoiding this copy except when strictly necessary helped improve VizWiz's rendering speed. The rendering engine uses at its lowest level, the Mat&amp;SD matrix transformation functions made available early on by Sun [3].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Marching Cubes Simplij%ation</head><p>We made a significant simplification to the traditional Marching Cubes algorithm in order to increase performance. Instead of rendering non-triangular cube slices as a set of triangles, we simply drew the resulting polygon directly, regardless of whether or not it was actually planar.</p><p>The code was implemented breaking polygons correctly into triangles, but rendering surfaces with this feature was about twice as slow as leaving it out. The datasets tested seemed to be smooth enough so that this shortcut made no noticeable difference in the appearance of the resulting surface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Resolution Control</head><p>VizWiz makes it very easy for the user to control the surface resolution, so as to avoid calculating high resolution isosurfaces unless they are the specific ones desired. This functionality has a tremendous impact on interactivity, since dropping the resolution by a factor of two results in a reduction of the number of polygons by three quarters.</p><p>Qualitatively, this means that surfaces that would take several seconds to render at full resolution require less than a second at half resolution.</p><p>Yet on ail but the most irregular datasets, half resolution is perfectly adequate for examining data in passing, and full resolution surfaces can be calculated as they are needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Caching</head><p>Both the cutting planes and the isosurfaces take considerably longer to compute than they do to render. For example, an isosurface from a 30 x 30 x 30 dataset requires about a minute and a half to compute on a 66 MHz 486 PC. The time required to actually draw the isosurface to the screen, assuming a typical isosurface size for that size of dataset of 2000 polygons, is only about 0.9 seconds on the same machine. In terms of performance and interactivity, there is clearly a great benefit to calculating isosurfaces only once, and storing them for future use.</p><p>VizWiz maintains two caches, one for cutting planes, and one for isosurfaces.</p><p>Whenever one of these objects is calculated for the first time, it is placed in the cache. If the same object is needed later, the precalculated version can be used immediately.</p><p>There is no limit on the size of the cache except the available memory of the Java runtime environment.</p><p>When the available memory is exhausted, it is not possible to compute any more large display objects without restarting VizWiz. This behavior could clearly be improved by intelligent cache management of some sort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Visualization of Users' Data</head><p>One of the more challenging tasks in creating a useful web application was working around the security limitations imposed on Java applets. No Java applet is allowed by Netscape or Internet Explorer to access the local file system of the machine on which it is run.</p><p>Most applications read input input flies, in one form or another, operate on that input, and possibly save output files. The fact that Java applets running in standard browsers like Netscape and Internet Explorer cannot directly perform these two operations is a severe impediment to implementing real applications as Java applets. In the case of VizWiz, we need to read a datafile in order to visualize it. Since it is not possible to do this in a straightforward fashion, we developed an HTML/CGI workaround to make file upload and download as transparent as possible to the user.</p><p>Although a Java applet is not allowed to read from the local file system, luckily HTML inside of Netscape and Internet Explorer is not entirely restricted from doing so. It is possible to make an HTML form that allows the selection and upload of a file from the users filesystem to the server. We put such a form on the VizWiz homepage. The data generated by the form, i.e. the contents of the selected datafile, are sent to the server, where they are processed by a CGI script. This script reads in the contents of the dataflle, and creates a new file on the server where it writes the data. This server 6le is accessible to the VizWiz applet, and the user can have it downloaded to VizWiz from within the applet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PERFORMANCE</head><p>The most important factor in determining the usefulness of VizWiz for scientific visualization is its rendering speed. In order to be minimally interactive, we required that VizWiz be able to draw isosurfaces and so forth for moderately large datasets to the screen at least several times a second. In addition, it had to have tolerable performance on a low end machine such as a 486 PC, so as not to be limited to fast workstations.</p><p>In practice, the "moderately large" datasets that could be visualized effectively at full resolution using VizWiz ranged from about 8000 points on a slowish 486 PC, to about 27000 points on a more powerful workstation.</p><p>At half resolution, these ranges greatly improve, from about 64000 points on the PC, to 125000 points on the workstation. At these dataset sizes, the amount of memory available for storing computed.isosurfaces, not the time required to compute and display them, typically begins to become the limiting performance factor.  <ref type="figure">Figure 2</ref> shows the time required to redraw the display on a visualization containing the specified number of polygons for the five different architectures. <ref type="figure">Figure  3</ref> shows the same data, but plotted in terms of frames per second, to give a more intuitive idea of the level of interactivity achieved. The rendering rates, in polygons, for the different platforms are summarized in the table below. <ref type="figure">Figure 4</ref> shows the number of polygons in the largest isosurface of our quarter-sphere test dataset, for various side lengths, giving a ballpark figure for the number of polygons to expect in a dataset of a particular size. The dramatic effect of downsampling on the number of polygons is evident.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>System</head><p>Polygons The lowest end machine on which we tested VizWiz was a 486 66/33 MHz PC, with 40M of RAM. This represents the low end of the desktop spectrum in terms of processor speed, although it is not at the bottom in terms of RAM (16M or even 8M are very common).</p><p>As seen from the data in <ref type="figure">Figure 2</ref>, VizWiz had a consistent performance of about 800 polygons per second. What size of dataset this enables us to visualize in an interactive manner clearly depends on the specific dataset, but the isosurface size data shown in <ref type="figure">Figure 4</ref> give some indication of what to expect.</p><p>For that dataset, the 8000 point volume (20 points on a side) was the largest that could be manipulated at full resolution on the 486 with any reasonable degree of interactivity. In the worst case for that dataset, the screen was able to be updated about once a second. The interactive resolution control greatly improves the picture, though.</p><p>to upload datasets from the VizWiz home page to the VizWiz server. These datasets can then be read in directly by the VizWiz applet, and displayed locally, Although we were able to work around the browser's applet security restrictions against accessing the local file system in a tolerable manner, our solution was a hack, and hacks are the only possible solution until a more reasonable security model is implemented.</p><p>Until this issue is dealt with properly, it will be impossible to write serious web-based Java applet applications that do not have to go through great contortions over the user's input and output files.</p><p>VizWiz was used enthusiastically during development by a number of scientists.</p><p>It was clear that its simplicity and platform independence made it attractive and easy to try. However, the limitations imposed by finite memory and processor speed always made themselves quickly felt.</p><p>Although VizWiz can handle datasets of up to 125,000 points, it is clearly much more effective to stay with datasets consisting of fewer than 50,000 points.</p><p>Java runs on a large number of different platforms, but with different degrees of success. In actuality, the difference in the reliability of VizWiz (i.e. how likely it was to crash the browser) varied greatly from one platform to the next. In general, it was most unreliable (or rather, the Java implementation was most unreliable) on the Windows 95 and Windows NT platforms.</p><p>Moreover, development of the user interface was in some ways problematic, because of the wild variations in look and feel of AWT implementations on different platforms.</p><p>In particular, the AWT implementation under Windows 95 and Windows NT resulted in a GUI whose appearance was almost unrecognizably different from its appearance on Unix systems such as Irix, Solaris, or Linux.</p><p>Finally, the pervasive "smoke and mirrors" hyperidden atmosphere at the intersection of the web, Java, and 3D graphics domains created a novel work environment in which to attempt to create a scientifically useful tool. We took the path of pushing existing (albeit just barely) technology, in order to be sure of a working product.</p><p>We chose not to gamble on promised technology such as the 3D extensions to the Java API, much of which is only beginning to materialize now. As a result, we have been able to produce a working interactive scientific visualization tool, which performs 3D graphical visualizations of real user-provided datasets in any Java enabled browser.</p><p>It, is clear to us that the ultimate implementation of a tool like VizWiz should be with Java3D. Java3D will eventually allow Java applets to deal with 3D graphics at the higher world-coordinate level that PHIGS and OpenGL users have learned to use so well. Platformindependent Java3D programs will be able to access graphics accelerator hardware through the platformdependent Java runtime environments. This will give us the ability to perform Java-based visualization without the performance penalties encountered here by implementing it all in software.</p></div>			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proceedings of the 8th IEEE Visualization '97 Conference 1070-2385/97 $10.00 Â© 1997 IEEE</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. ACKNOWLEDGEMENTS</head><p>We are grateful for SDSC's support of this project through an SDSC CSE Graduate Research Internship.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PI PI</head></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Although the time required to redraw an image on the 486 may make interactive manipulation of larger isosurfaces unworkable, dropping the resolution by even a factor of two greatly improves interactivity, while showing a useful and recognizable approximation to the desired full resolution visualization.</p><p>In this case, for example, a dataset eight times the size (64000 points, or 40 points on a side) can be manageably manipulated on the 486 PC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6000</head><p>'id .dC</p><p>FIG. 4. Typical number of polygons in cube volumetric dataset with Side N. The horizontal lines indicate the number of polygons that can be drawn in one second on each architecture. The points on the X axis where they intersect the side-polygons plot is the largest side size that can be interactively viewed at full resolution. Although faster, however, the polygon drawing speed is in the same league as that of the PC, whose processor is two thirds the speed of that of the workstation.</p><p>The SGI workstation is able to draw about 2000 polygons per second.</p><p>In the context of our test dataset, this means it can handle 27000 point datasets (30 points on a side) with once per second update interactivity, and at the second highest resolution gives good performance on the largest datasets VizWiz can handle (125000 points).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. SPARC 20 125 MHz 128 MBytes RAM Running Solaris</head><p>The performance of VizWiz on a Sun SPARC 20 workstation (2 125 MHz RT625 processors and 128MBytes Ram, with a SPECint92 performance of 159), was about the same as that of the SGI, despite the fact that its CPU speed was considerably faster and it had the same amount of main memory to work with. They were not, of course, running the same operating or windowing systems, and in a graphics software application such as this, this factor is very important.</p><p>Irix on the SGI significantly outperformed Solaris on the SPARC on this application. Under Windows 95, using the Netscape 3.0 just-in-time compiler that comes automatically with that version of Netscape for Windows 95, performance was no better than it had been on the 486 PC, and was significantly slower than it was on exactly the same hardware under Linux. The fact that the faster processor made no improvement in performance was probably accounted for in part by the smaller amount of RAM available on the laptop. Netscape, Java, and VizWiz are all memory intensive, so differences in the size of the main memory have a significant effect. It is very clear from the comparison between the results under Linux and those for the Windows 95 test that the operating and windowing system under which a graphics intensive applet is run can have a larger effect on performance than hardware.</p><p>VizWiz ran a solid 25% faster under Linux than under Windows on the same hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSIONS AND LESSONS LEARNED</head><p>The two factors specific to Java applets that caused the most difficulties in the effective implementation of VizWiz were performance and local file access. The performance of an interpreted Java applet is certainly slower than that of its native equivalent. Although the performance difference is not so great for software graphics, which are based on largely native code libraries, it is significant for simple calculations, which made up a large part of the work done by VizWiz, specifically in isosurface generation.</p><p>To minimize the impact of slow isosurface calculation, we cached computed isosurfaces so they would not need to be recomputed, made it easy for the user to control the surface resolution, so as to avoid calculating high resolution isosurfaces unless they were the specific ones desired, rendered flat shaded polygons, used the imperfect Painter's algorithm to sort them, and ignored the non-planar possibilities of the cube slices in the Marching Cubes isosurface algorithm.</p><p>It was interesting to note that choice of operating system, notably Linux vs. Windows 95, had as much effect on performance as switching hardware from a 486 to a Pentium.</p><p>In order to make local file access possible, we put together an HTML form and CGI script that allows users</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The VIS-5D System for Easy Interactive Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bill</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Santek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Java API Documentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Yellin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sun Microsystems</title>
		<imprint/>
	</monogr>
	<note>The Java Team</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<ptr target="http://uwu.javasoft.com:80/products/jdk/i.0.2/api/packages.htmlGosling" />
	</analytic>
	<monogr>
		<title level="j">James. MatrixJD Applet. Model3D Applet. Sun Microsystems</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">S</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Gresh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Mcauliffe</surname></persName>
		</author>
		<ptr target="http://www.javasoft.com/applets/applets/WireFrame/" />
		<title level="m">IBM Data Explorer. Proceedings Visualization 92</title>
		<imprint>
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Faulhaber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">Avs</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">30</biblScope>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
