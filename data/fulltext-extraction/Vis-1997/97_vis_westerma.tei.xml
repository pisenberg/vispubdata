<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The VSBUFFER: Visibility Ordering of Unstructured Volume Primitives by Polygon Drawing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Westermann</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ertl</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Graphics Group</orgName>
								<orgName type="institution">Universität Erlangen-Nürnberg</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Lehrstuhl für Graphische Datenverarbeitung (IMMD9)</orgName>
								<address>
									<addrLine>Universität Erlangen-Nürnberg, Am Weichselgarten 9</addrLine>
									<postCode>91054</postCode>
									<settlement>Erlangen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The VSBUFFER: Visibility Ordering of Unstructured Volume Primitives by Polygon Drawing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Different techniques have been proposed for rendering volumetric scalar data sets. Usually these approaches are focusing on orthogonal cartesian grids, but in the last years research did also concentrate on arbitrary structured or even unstructured topologies. In particular, direct volume rendering of these data types is numerically complex and mostly requires sorting the whole data base. In this paper we present a new approach to direct rendering of convex, voluminous polyhedra on arbitrary grid topologies, which efficiently use hardware assisted polygon drawing to support the sorting procedure. The key idea of this technique lies in a two-pass rendering approach. First, the volume primitives are drawn in polygon mode to obtain their cross-sections in the VSBUFFER orthogonal to the viewing plane. Second, this buffer is traversed in front-to-back order and the volume integration is performed. Thus, the complexity of the sorting procedure is reduced. Furthermore, any connectivity information can be completely neglected, which allows for the rendering of arbitrary scattered, convex polyhedra.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Scalar volume data can be visualized by many different methods which strongly depend on the intended application and on the topology of the grid on which the data samples are given. In direct volume rendering techniques the object is supposed to be filled with a semi-transparent gel which is rendered according to the physics of light transport <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>. A variety of techniques have been developed for the direct rendering of 3D scalar data fields on regular cartesian grids <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. Apparently, the underlying theory is well understood and several approaches offering combinations of rendering speed and image quality have been established <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>Recently, hardware assisted direct rendering methods benefiting from real-time 3D texture interpolation <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19]</ref> produce remarkable frame rates. However, these approaches are restricted to rectilinear grids, and it seems questionable whether they can be adapted to other grid topologies. On the other hand, in order to directly render volume data generated by numerical simulations or adaptive refinement strategies the visualization of irregular or even unstructured grids becomes a major challenge. Since the emerging grid types and cell primitives can be of arbitrary topology the development of rendering algorithms which are not restricted to a certain class of application is an important goal. Simultaneously, the overhead spent in such a universal framework should not dominate the overall rendering times.</p><p>In this paper we present a new approach to the visualization of scalar data fields which are available on unstructured grid topologies. Our method has the following basic advantages: This is achieved by a two-pass rendering approach which takes advantage of hardware assisted polygon drawing available on a variety of different platforms. First, the data base is successively rendered into a buffer orthogonal to the viewing plane and parallel to the active scanline. Second, this buffer, which now holds the crosssections between the primitives and the plane, is traversed. Since the cross-sections are already in correct order, the sorting of primitives within each scanline can be completely avoided. The final rendering pass is performed by casting rays along each line of sight through the detected data cells. Consequently, arbitrary integration rules can be applied, and these rules can also be adapted to the underlying cell structure.</p><p>We should note here that only the sorting of primitives according to the actual viewing definition and the determination of intersection points between rays and cells is accelerated by this approach. No optimization of the integration process itself will be achieved.</p><p>Our method is very similar to the ones proposed by Giertsen <ref type="bibr" target="#b3">[4]</ref>, Silva <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr">Wilhelms</ref>  <ref type="bibr" target="#b21">[22]</ref>, and Yagel <ref type="bibr" target="#b23">[24]</ref>. All three approaches utilize the coherence within cutting planes in object space and thus reduce the 3D problem to a 2D problem within each plane. Furthermore, the sorting procedure within each plane can be reduced to the sorting of primitives along each line of sight. However, the fundamental difference to our method lies in the way in which we obtain the relevant information within each plane.</p><p>Definitely the most critical part when rendering unstructured grids is to determine the visible ordering of the available primitives. In general, for each modification of the viewers line of sight the whole data base has to be sorted to obtain the sequence of elements which have to be inspected in correct order. Since the underlying sorting procedure immensely effects the complexity of the complete rendering process, it is not astonishing that much work has been spent on efficiently integrating or extending available sorting algorithms <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b2">3]</ref>. Additionally, specialized graphics hardware has been used to improved the rendering process <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b23">24]</ref>. Drawing each primitive as transparent polygon structure results in a very fast but less accurate approximation of realistic volume effects.</p><p>In the following sections we first discuss the new sorting procedure and the way in which we take advantage of hardware assisted polygon drawing. The basic concept of the VSBUFFER and the resulting rendering strategy are described. Then, results are given and the run times are analyzed. We conclude with some ideas for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The VSBUFFER</head><p>Basically, there are two possible strategies which can be used to optimize the complexity of rendering algorithms for unstructured grids. First, one can try to optimize known sorting algorithms or the emerging data structures in order to accelerate the sorting procedure <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b22">23]</ref>. Second, explicitly sorting the whole data base can be avoided at the expense of less costly and possibly hardware supported operations <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b17">18]</ref>. We decided to choose the second strategy which will be outlined in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sweep-Planes</head><p>A well known approach for the visualization of unstructured grids is the use of sweep-planes. A sweep-plane belongs to a certain scanline of the screen. It is a plane in object space that is perpendicular to the viewing plane and parallel to that scanline (see <ref type="figure" target="#fig_0">Figure  1</ref>). According to this definition a sweep-plane is uniquely described for each scanline. Probably the first approach to the application of sweep-planes in direct volume rendering came from Upson et al. <ref type="bibr" target="#b16">[17]</ref>. They introduced the V-Buffer to efficiently render volume cells. Although this approach was not specifically designed for the rendering of arbitrary grid types, cutting planes in object space were introduced to improve scanline based cell projections. In this respect the V-Buffer might be seen as a forerunner to a whole number of sweep-plane based approaches for the visualization of arbitrary grid topologies.</p><p>The key idea in rendering unstructured grids with sweep-planes is to reduce the complexity of the sorting procedure by restricting the number of primitives which have to be sorted for each scanline <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14]</ref>. This is achieved by first determining those primitives which are potential candidates for an intersection with the actual plane. Thereupon these primitives are sorted with respect to the chosen viewing transformation. Thus, the 3D problem is reduced to a 2D problem within one sweep-plane.</p><p>Now the critical part is to find the right order of objects with respect to their intersections with these planes. Computing the sequence of primitives which are hit consecutively by arbitrary rays emanating from a scanline is a non-trivial task.</p><p>Note, that the intrinsic problem is to find the cross-sections between the primitives and the sweep-planes in correct order. Assuming that the coverage of a sweep-plane with all cross-sections has been determined, then the problem collapses to the traversal of the 2D plane for each ray of sight emanating from the corresponding scanline <ref type="bibr" target="#b3">[4]</ref>. This is outlined in <ref type="figure" target="#fig_1">Figure 2</ref> where the coverage of a sweep-plane according to a number of primitives is shown. In the following we will call the buffer that holds all the cross-sections for a certain scanline the VSBUFFER. But it is not yet clear how to obtain this information without sorting and projecting the whole data base. This will be demonstrated in the next section, where we introduce an elegant method to compute the coverage of a sweep-plane with the cross-sections of primitives. Once the coverage is computed and stored in a buffer the shooting and traversal of rays in object space collapses to a simple walk through the regular domain of that buffer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Buffered Polygon Drawing</head><p>In the following we will make two assumptions. First, the polyhedra are build up of several triangles and stored in a linear list. Second, an orthographic projection is chosen to generate the final images. Thus all scanlines can be processed using the same viewing direction, and consequently all sweep-planes have the same orientation. In case of perspective projections the orientation of sweep-planes changes with each scanline. Although perspective projections can be handled by our approach, we will focus on orthographic views to simplify the discussion.</p><p>In order to process one scanline after another we temporarily change the viewing parameters, thereby performing an orthographic projection perpendicular to the sweep-plane. The position of the observer moves above the scene, thus looking down onto the sweep-plane with a viewing direction parallel to the former screen y-axis. Of course, this can also be managed by rotating the objects in the opposite direction. Since we are in global orthographic mode, the intermediate projection with respect to the sweep-plane orientation does not change while processing arbitrary scanlines.</p><p>Our goal is to determine the coverage of the VSBUFFER with all cross-sections of primitives which intersect the buffer. This is similar to rendering the whole scene into the buffer with a viewing direction orthogonal to it, and with a front and back clipping plane set to the actual sweep-plane. This process can be repeated simultaneously for each scanline. What should remain visible in each buffer are the cross-sections with the rendered objects. However, because of two reasons this can not be achieved in general. First, standard graphics libraries as OpenGL would produce incorrect or probably empty results due to rounding errors. Second, even if it would be possible to choose the same front and back clipping plane only the surrounding polygons of each cross-section remain visible in the buffer. Thus a different method needs to be developed which solves this problem.</p><p>The key idea is to render the primitives twice into different buffers. Both times only one clipping plane is enabled which is set to the orientation of the actual sweep-plane. We are always looking from above down to the sweep-plane, and we classify each face of a polyhedra whether it is a front or a back face with respect to this intermediate viewing direction. In the first pass only back facing polygons of the convex polyhedra are drawn and we clip everything away that is in front of the clipping plane. Depth test is set to less. This means that those objects behind the clipping plane which are nearest to the plane are visible. In the second pass the normal of the clipping plane is reversed. Now everything behind the plane is clipped. Additionally, only front facing polygons are drawn and depth test is set to greater. Again, only those objects in front of the plane are drawn which are closest to it. Both passes are performed with disabled lighting, flat shading, and no anti-aliasing to avoid averaging pixel values. Both steps are outlined in <ref type="figure" target="#fig_2">Figures 3 and 4</ref>.</p><p>Since the polyhedra are stored in a linear list each of them can be assigned an ID which uniquely defines that cell within the entire data base. This ID is used as the color of the faces of each primitive which is drawn. For example, if we have a RGB-visual with 8 Bits per color channel we can code 2 <ref type="bibr" target="#b23">24</ref> primitives in the RGB color values. Coding the IDs of objects in this way allows their direct identification from the pixel values already drawn.</p><p>After both rendering passes the footprints of the drawn faces are uniquely coded by the color values available in the used buffers. Unfortunately it is impossible to obtain the correct cross-sections by considering only one buffer. Depending on the orientation of primitives the cross-sections in either of both buffers will cover more area than is really occupied. In order to find corresponding pixel values which have the same color, i.e. where the same object was drawn to that location, both buffers have to be compared to each other. The result of the comparison is stored in the VSBUFFER. In <ref type="figure" target="#fig_4">Figure 5</ref> the intermediate buffers after both rendering passes and also the resulting VSBUFFER are shown.</p><p>At this time the reader might wonder whether all primitives have to be drawn in both rendering passes although they possibly do not have an intersection with a certain sweep-plane. It will be described  The basic idea is once more demonstrated in <ref type="figure" target="#fig_5">Figure 6</ref> along one line of sight. A 2D slice through the 3D scene is simulated that shows the generated intervals on a ray passing through the primitives. As a result the ray is broken down into distinct segments each of which indicate that a certain cell was hit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Building the buffer</head><p>The set of pixels which have the same color value in both buffers exactly determines all cross-sections between a sweep-plane and the polyhedra. The correct result is obtained by comparing pixel values at the same location in both buffers. This is completely done in software by walking through the regular domain of the buffers. All that remains to be specified is how to access the buffer values. After each rendering pass the framebuffer extent that was affected by the actual intermediate orthographic projection is read into main memory. Prior to processing a new sweep-plane the comparison of pixel values starts and the result is stored in the VSBUFFER. An unsigned integer value is allocated for each pixel. Either the pixel is set, then the color value uniquely identifies a tetrahedron that was hit, or the pixel value is zero.</p><p>Since the viewing transformation that was applied to render the objects twice into distinct buffers was carefully adjusted to the original coordinate system, the IDs of cells which are hit along one ray of sight emanating from a scanline is now exactly given by one pixel column in the VSBUFFER. In order to traverse a ray and to determine all intersections between that ray and the cell primitives we just have to walk through the discrete buffer thereby testing its values.</p><p>Note the basic idea we propose. Sorting the data base is traded in against successive rendering of parts of the data base into the VSBUFFER. Sorting is given up at the expense of multiple polygon drawings and framebuffer read operations. However, the result is the same: A unique ordering of primitives within each sweep-plane according to the viewing specification.</p><p>Due to the fact that the sorting of primitives is completely neglected the complexity of our approach is reduced. All that needs to be done is to successively render the primitives into the used buffers. Furthermore, the algorithm neither depends on the grid topology nor on the connectivity between the available objects. Each cell is treated as an separate atom processed independently of all others. All we require is that the objects are convex. Additionally, the grid structure can be disconnected or even concave. This will not influence the algorithm.</p><p>Of course, in order to minimize the amount of polygons passed through the graphics pipeline we have to determine the set of primitives contributing to a certain scanline in advance. Otherwise we will draw the whole data base for every sweep-plane. We address this problem by building a tree structure over all primitives which allows us to efficiently determine those cells which have an intersection with the actual scanline. This will be described in more detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Volume Integration</head><p>Once the VSBUFFER for a certain scanline is build the rendering of volume primitives starts. In order to integrate volume effects like emission and absorption within the voluminous primitives the volume rendering integral</p><formula xml:id="formula_0">I = Z t 1 t 0 qte , R t t 0</formula><p>sds dt is evaluated for each ray that intersects that primitive. Thereby, the volume source term qt and the absorption s are obtained by interpolating and mapping the material values given at the objects vertices via a transfer function. Traditionally the continuous integral is approximated by discretization. The intervals a certain ray passes through a cell are split into equally spaced segments for which the material properties are assumed to be constant. Now, for each ray of sight emanating from a scanline the VS-BUFFER is traversed along the corresponding pixel column. Each time a color value is determined it indicates that the ray hits a certain primitive. The values in the buffer directly correspond to the ID of the objects. Then, the buffer is traversed until a different ID is identified.</p><p>Once we find a cell that is hit by a certain ray of sight we start computing the entry and the exit points along that ray. This is managed by first determining the front and back faces of the cell and by testing the scalar productÑ D between the normal of each face and the viewing direction. The entry point is the furthermost intersection point to the viewpoint of all front faces, while the exit point is the closest one of all back faces.</p><p>The intersection points are computed in barycentric coordinates of each triangle that is hit. We assume that each polyhedra is build from a number of triangles. Given three verticesŨ ; V ; W that define a triangle, a point within the triangle can be expressed by P u; v; w = uŨ + vṼ + wW , with u + v + w = 1 and 0 u; v; w 1.</p><p>The positions of intersection points along the ray are computed by clipping the ray against each face of a cell that is hit. The scalar productÑ S + tD ,T has to be zero, whereS is the start point of the ray andT an arbitrary vertex of the triangle to be clipped. Since we know that the ray has an intersection with the primitive, otherwise we would not have determined the ID of the object, no testing is performed whether the point is inside or outside the primitive. Thus, we obtain the intersection pointP and solve the resultant system of equations to get its representation in barycentric coordinates: In order to be on the safe side (detŨṼW 6 = 0 ) we first trans-lateP and the triangle vertices along a fourth vertex that does not lie in the triangle plane. For example, if the primitives are tetrahedra this point is the unused vertex. Since the system of equations is over-determined we replace the last row of the system matrix with the row that contributes the least information, delete the last row and solve the 3 3 system. This row can be found by determining the maximum component of the normal vector to the actual face, i.e. if all triangle vertices lie in the y-z plane then we replace the first (x) row in our system. Rounding errors are avoided by accounting for the condition 0 u; v; w 1. We only try to find an intersection point if the ID of a primitive was found in the VSBUFFER. Consequently, we can be sure that there really is an intersection. In the case of barycentric coordinates outside 0; 1 we slightly shift the point inside the triangle by adjusting the wrong coordinate.</p><p>If the data set consists of tetrahedra we can efficiently use this representation to perform the volume traversal. Since it is also possible to express a certain point within a tetrahedron in barycentric coordinates of its four vertices, and it also holds that u+v+w+q = 1 and f = uŨ + vṼ + wW + qQ, whereQ is the fourth vertex, we can easily interpolate between the entry and the exit point. Since for each point on one of the tetrahedron faces one coordinate equals zero and the others have been computed, a linear interpolation between both representations with arbitrary step size can be applied. For other types of polyhedra the same intersection routine can be used but the integration has to be adapted accordingly.</p><p>Particularly, for tetrahedron we follow the ideas in <ref type="bibr" target="#b10">[11]</ref> assuming a linear range of material values within each cell. A trapezoidal rule where we also account for attenuation effects in the objects delivers good results. Of course, higher order integration methods can be applied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation Details</head><p>We implemented the proposed technique using the OpenGL graphics library. The basic algorithm is supplied in pseudo code notation in <ref type="figure" target="#fig_7">Figure 7</ref>. The basic code is very short and can be implemented quite easily. Only the traversal routine has to be adapted to the available grid cells. It can be clearly realized that the kernel of the algorithm neither depends on the grid topology nor on the structure of the underlying cells. As long as the volume primitives can be split into distinct triangles the same algorithm can be applied and only the traversal routine needs to be changed.</p><p>In the following we will have a closer look on different optimization strategies and some of the emerging difficulties and limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Performance tuning</head><p>So far, a major limitation of the proposed method is the enormous number of triangles passed through the graphics pipeline during generation of the VSBUFFER. For each scanline the whole data base is drawn twice into the framebuffer. This requires a huge amount on hardware resources, and it is indeed the bottleneck for large scale data sets.</p><p>The problem can be attacked in two principle ways. First, a data structure is generated in which all faces are stored which contribute to the active scanline that is processed. Each time the viewing coordinate system is changed the entire list of vertices is converted from object space to screen space and sorted with respect to the actual view y-direction. From the sorted list those cells can be obtained which contribute to the actual scanline by successively updating a y-active list which holds all active vertices for the scanline. A very complete description of this procedure can be found in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b21">22]</ref>. The second approach, as proposed in <ref type="bibr" target="#b21">[22]</ref>, uses a k-d tree that is build over all primitives. At every node of the tree the bounding box structure for all primitives inside the node is stored. Polygons are inserted at the node deepest in the tree that completely contains the polygon. Each time another scanline is processed the tree is traversed and the cells at each node that have an intersection with the scanline are drawn.</p><p>While in the first approach the complete list of vertices has to be transformed and ordered each time the viewing system changes, the k-d tree which is build in a pre-processing step remains unchanged for arbitrary views. The disadvantage is the additional amount of memory and computation. The whole tree has to be stored, and for each scanline the tree traversal takes place checking for possible intersections between the bounding box of the nodes and that scanlines. Only if the scanline intersects a bounding box all polygons stored at that node are drawn.</p><p>On the other hand, the tree structure allows us to choose the optimal depth of the tree. Thus we can try to find the most effective setting with respect to the computational load, the used memory, and load resulting from drawing operations. In particular, it turned out that even if we work with a rather flat tree the additional number of drawing operations does not effect the final rendering times dramatically. Consequently, we implemented a regular octree equally partitioning the underlying domain.</p><p>The tree structure allows us to completely avoid the sorting of primitives. Instead, each cell within a node that seems to have an intersection with the actual scanline is directly rendered into the intermediate buffers. The correct order is found implicitly by walking through the generated VSBUFFER.</p><p>The drawing routine was further improved by computing the facing of all primitives with respect to the actual sweep-plane orientation in advance. Thus, a certain triangle is never rendered twice for the same sweep-plane. Since each volume cell commonly overlaps many scanlines this phenomenon will probably occur quite often.</p><p>We should also mention that the use of clipping planes in the OpenGL code can be completely avoided. All we have to do is to call glOrtho twice for each scanline with the near and far values adapted to the actual clipping plane equation. Since we are always looking orthogonal to the sweep-plane we just have to restrict the visible region in world coordinates. One time the near value is set equal to the distance to the sweep-plane and the other time this is done for the far value. This implies that we generate a new projection matrix twice for each scanline, but on the other hand, our timings showed that almost twice the time for the drawing pass was consumed with enabled clipping planes. Additionally, restricting the distance between the near and the far values to the largest size of available primitives also optimizes the drawing pass, since faces which are completely outside the visible region are not drawn. Actually, this method is used in our implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OpenGL issues</head><p>In the present approach possible sources of error are vertices which belong to multiple cells. If the same vertex is drawn twice for different triangles we can not be sure that the color value at this location really belongs to the object we expect. The IDs of objects we find in the intermediate buffers depend on the drawing order. This is sketched in <ref type="figure">Figure 8</ref> where the circle indicates a possible incorrect color value along a ray. However, in case of wrong drawing order the VSBUFFER at this point will be zero since the wrong object is only drawn once. Thus the problem can be easily solved be skipping over that point and traversing the ray until the next correct ID is found. During ray traversal a list is updated which stores the IDs incorrect pixel value view direction <ref type="figure">Figure 8</ref>: Clipping along one ray of sight. already found along the actual ray. If a segment along the ray is split into two distinct segments due to incorrect drawing order we will check whether that primitive has already been traversed by inspecting the list. Therefore, multiple integrations along the same object will never occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Buffer resolution and anti-aliasing</head><p>As already pointed out in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b21">22]</ref> the resolution of the VS-BUFFER plays a critical role. Two relevant problems should be further discussed. First, the resolution of the buffer with respect to the size of the involved primitives. Second, the handling of aliasing artifacts due to point-sampling of triangles during the drawing procedure.</p><p>The first problem is indeed difficult to handle, but two things should be mentioned here. In order to obtain accurate results the sampling frequency and thus the resolution of the used buffers has to be adapted to the coverage of the smallest available primitives. In general, this is impossible even if the cell sizes vary in the order of 1:10000. As a consequence small objects will be missed. On the other hand, we do have the same problem in all visualization methods for unstructured grids, either they are object-space or image-space driven. The accuracy of ray-tracing variants depends on the screen sampling frequency and also projection methods will definitely lead to incorrect results without multipoint-sampling.</p><p>The main problem in our approach is that the resolution of the VSBUFFER possibly not suffices to detect all cells which are hit by a certain sweep-plane. We try to solve the problem by choosing different buffer resolutions in the x-and y-direction. Of course, in the x-direction it is fixed by the actual viewport definition. However, we adjust the resolution in y with respect to the bounding box of the underlying grid and the size of details we want to be able to detect. If the resolution exceeds the available framebuffer extent we split the VSBUFFER in several distinct parts and perform the entire procedure for each of these parts separately.</p><p>Since we render multiple sweep-planes orthogonal to the active viewport, we need a separate render area in which the cell primitives can be drawn. Choosing the back buffer has several disadvantages. First, objects already drawn into the back buffer would be destroyed. Second, the actual render area could be too small or could be overlay-ed by other windows, which results in wrong color values read from the buffer. Therefore, we decided to use the SGIX pbuffer extension which provides a part of the physical framebuffer which can be directly accessed by the graphics hardware, but which is not displayed on the screen. Furthermore, pbuffers can be locked exclusively by a certain application against other access. discretization artifact Discretization errors as shown in <ref type="figure" target="#fig_8">Figure 9</ref>, where the dark triangle overlaps a certain pixel column but is not drawn in that column, can be solved efficiently. These kinds of errors can only occur at the border between two objects. Each time we leave a primitive we check its direct neighbors in the VSBUFFER for an intersection. Errors as outlined can be completely avoided in this way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implicit use of connectivity</head><p>One important issue of our approach is the capability to handle unstructured grids even if no connectivity information is given. At first glance we loose performance since we do compute the entry and the exit intersection point for each primitive. In order to improve the procedure we always store the last exit point and it's barycentric coordinates with respect to the face that is hit along the ray. For the next cell along the ray we first check the faces belonging to that cell. If it has a face in common with the last cell and the ray left the last object on that face, then we can use the previous exit point as the new entry point. The numerical complexity is thus reduced by a factor of two. Of course, if explicit connectivity information comes with the geometric representation of the used grid, further acceleration of the final rendering can be achieved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Perspective projection</head><p>Our approach easily extends to perspective projections. All which has to be done is to modify the final projection matrix before primitives are drawn to the intermediate buffers. An additional rotation of 90 degrees around the screen x-axis is applied after the perspective distortion. If all vertices are in normalized device coordinates and we multiply the projection matrix with the rotation matrix we have all primitives in the right orientation. Also, the sweep-planes must be inclined according to the chosen perspective for each scanline. The angle of rotation changes incrementally from one scanline to another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>All result were computed on a Silicon Graphics Indigo 2 IMPACT with 250 Mhz R4400 processor. The experiments were run on three tetrahedra data sets: An artificial data set (ell64) that should aid comprehension, a finite-element data set (fedata), and the tetrahedralised NASA bluntfin data set (bluntfin). The image size was 450x450 pixels. The resolution of the VSBUFFER was chosen equal to the image resolution; the long main diagonal of the data sets is mapped to 450 pixel.</p><p>Two parts of the algorithm were investigated separately. First, we measured the elapsed time that was consumed in the graphics pipeline (GrOps) including polygon drawing and reading the framebuffer into local memory. Second, we analyzed the CPU time spent for the calculation of intersection points and the final volume integration (Int). The corresponding images are shown on the color page below. For each data set we also give the total number of primitives and the total number of drawn primitives. Of course, the number of drawn primitives increases the original amount to some extent. This is due to the fact that, in general, one cell overlaps multiple scanlines. Additionally, at each node of the used tree structure some primitives which are stored might be drawn although they do not contribute to a certain scanline.</p><p>To demonstrate the complexity of the basic algorithm we processed the entire 450 scanlines for each data set, not depending on whether the object really had a cross-section with the corresponding sweep-plane or not. All times were measured without explicit use of connectivity information. <ref type="table" target="#tab_0">Table 1</ref> shows explicit timings and the number of involved primitives for all data sets. Note that GrOps exactly specifies the time that was needed to completely determine the visibility ordering of all primitives. This is a major improvement over other techniques. For example, in <ref type="bibr" target="#b13">[14]</ref> it was reported that it took approximately 48 seconds to completely order the bluntfin data set containing 190000 primitives with respect to 200 scanlines.</p><p>A detailed comparison concerning the time used for the integration process seems to be difficult because it strongly depends on the applied intersection routine, the sampling frequency, and finally the kind of volume compositing that was performed. In <ref type="bibr" target="#b23">[24]</ref> it took roughly 40 seconds to render the smaller bluntfin data set with hardware supported compositing of volume cells. Slicing the data set with 350 slices parallel to the view plane would yield almost the same result as with the actual resolution of the VSBUFFER in our configuration.</p><p>However, we should mention that the times used for the integration within volume cells can be improved considerably. Actually, for each primitive within a certain scanline all calculations are performed from the scratch, including normal calculations and solving the system of equations to obtain the intersection points in barycentric coordinates. By computing implicit descriptions for the available tetrahedra in advance the overall times can be accelerated to some extent.</p><p>In the total times the time needed to traverse the tree data structure scanline by scanline is included. Prior to each new rendering pass we first transform the coordinates of the bounding boxes at the nodes to screen space. In this way we can easily check whether a node has an intersection with the actual scanline or not.</p><p>Since the finite element data set and the artificial data set have much more intersections with scanlines than the bluntfin data set this reflects in the measured integration times. On the other hand, the time spent in the graphics pipeline grows almost linearly with the number of primitives, if we take into account a constant offset of 5.6 seconds that is consumed for reading and clearing the framebuffer and the depth buffer.</p><p>For the bluntfin data set we build a tree structure of depth 5. The additional memory usage was 2.6 MB. Building the tree in advance took 1.4 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have presented a novel technique for hardware assisted sorting and rendering of convex non-overlapping polyhedra which are cells of arbitrary unstructured grid topologies. No connectivity information between primitives is needed, but if primitives are connected this can be used efficiently to accelerate the intersection procedure. The underlying grid types can be convex, non-convex or even disconnected.</p><p>The timing results have shown that this method significantly accelerates the rendering process by completely avoiding the sorting of the data base. In contrast to other methods the complexity of the actual approach is thus bound by the numerical intersection calculations and the volume integration.</p><p>Since the kernel of the program is a volume ray-casting variant it offers highest flexibility in the chosen visualization options and the image quality. The code is quite easy to implement and runs on standard architectures supporting OpenGL.</p><p>Different visualization modes and new types of volume primitives will be integrated in the future. As long as the cell primitives are disjunct and can be split into triangle lists we can use the same sorting procedure. Only the integration rule has to be adapted to the underlying topology.</p><p>Furthermore, we think about a parallelization of the algorithm in the style of the SGI Performer toolkit. The whole drawing of primitives is done by a specific processor, but when the intermediate buffers are generated multiple processors are used to build the VSBUFFERS for different scanlines. Of course, this implies that the processing order of the scanlines is chosen in a predefined way, avoiding multiple access of different processors to the same primitives. However, since we do not take advantage of spatial coherence between sweep-planes the processing order can be chosen arbitrarily.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Overview of sweep-plane approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Coverage of sweep-plane with cross-sections.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>clippingFigure 3 :</head><label>3</label><figDesc>First rendering pass: We are looking from above. Objects above the sweep-plane are clipped. Back faces are drawn.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>clippingFigure 4 :</head><label>4</label><figDesc>Second rendering pass: We are looking from above. Objects below the sweep-plane are clipped. Front faces are drawn.below how this can be avoided.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Result of buffer comparison.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Clipping along one ray of sight.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>/Figure 7 :</head><label>7</label><figDesc>/ rotating the objects glRotatef(-90.0, xview[0],xview[1],xview[2]); // set the orthographic projection with adjusted parameters glOrtho(left,right,top,bottom,front,back); for (each scanLine ) f glCullFace(GL FRONT); glDepthFunc(GL LESS); updateClipPlane(clipPlaneEquation); glClipPlane(GL CLIP PLANE0, clipPlaneEquation); drawObjects(facesList); glReadPixels(0,0,x,y,RGBA,BYTE,frontMem); glCullFace(GL BACK); glDepthFunc(GL GREATER); clipPlaneEquation[0,1,2] = -clipPlaneEquation[0,1,2]; glClipPlane(GL CLIP PLANE0, clipPlaneEquation); drawObjects(facesList); glReadPixels(0,0,x,y,RGBA,BYTE,backMem); VSBUFFER = compare(frontMem,backMem); traverse(VSBUFFER,facesList);g OpenGL pseudo code for VSBUFFER generation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Possible discretization artifact.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>The concave finite-element data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>The concave and disconnected artificial data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>The NASA bluntfin data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 :</head><label>13</label><figDesc>A detailed view of the bluntfin data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Processed primitives and timings (seconds) for the used data sets.</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell cols="4">Tetra DrawnTetra GrOps Int Total</cell></row><row><cell>ell64</cell><cell>44689</cell><cell>954317</cell><cell>9.2</cell><cell>36.6 46.9</cell></row><row><cell>fedata</cell><cell>99306</cell><cell>1498032</cell><cell>12.4</cell><cell>42.1 56.0</cell></row><row><cell>bluntfin</cell><cell>224874</cell><cell>2102153</cell><cell>16.3</cell><cell>42.3 61.6</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head><p>Thanks to Alex Dietz for providing the p-buffer code, and Paolo Cignoni who made the tetrahedralized bluntfin data set available to us.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Accelerated Volume Rendering and Tomographic Reconstruction Using Texture Mapping Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1994 Symposium on Volume Visualization</title>
		<editor>A. Kaufman and W. Krüger</editor>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast Algorithms for Volume Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Danskin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Ray tracing irregular volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garrity</surname></persName>
		</author>
		<editor>Kaufmann A., editor</editor>
		<imprint>
			<date type="published" when="1990" />
			<publisher>ACM SIGGRAPH</publisher>
			<biblScope unit="page" from="35" to="40" />
		</imprint>
	</monogr>
	<note>Workshop on Volume Visualization</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Volume visualization of sparse irregular meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Giertsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="40" to="48" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ray Tracing Volume Densities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Kajiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Von Herzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="165" to="174" />
			<date type="published" when="1984-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Application of Transport Theory to the Visualization of 3-D Scalar Data Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Krüger</surname></persName>
		</author>
		<editor>A. Kaufman</editor>
		<imprint>
			<date type="published" when="1990" />
			<publisher>IEEE Computer Society Press</publisher>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="page" from="273" to="280" />
			<pubPlace>Los Alamitos, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast Volume Rendering Using a Shear-Warp Factorization of the Viewing Transform. Computer Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lacroute</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGGRAPH &apos;94</title>
		<meeting>SIGGRAPH &apos;94</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="451" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hierarchical Splatting: A Progressive Refinement Algorithm for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="285" to="288" />
			<date type="published" when="1991-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient Ray Tracing of Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="261" />
			<date type="published" when="1990-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Area and Volume Coherence for Efficient Visualization of 3D Scalar functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="27" to="33" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Rendering Algorithm for Visualizing 3D Scalar Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="51" to="58" />
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Polygonal Approximation to Direct Scalar Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">San Diego Workshop on</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1988-12" />
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast rendering of irregular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Volume Visualization</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="15" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Sorting and hardware assisted rendering for volume visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1994 Symposium on Volume Visualization</title>
		<editor>A. Kaufman and W. Krüger</editor>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="83" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Frequency Domain Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Totsuka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="271" to="78" />
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">V-BUFFER: Visible Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="59" to="64" />
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Rapid exploration of curvilinear grids using direct volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="70" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Direct Volume Rendering with Shading via Three-Dimensional Textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Geldern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kwansik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1996 Symposium on Volume Visualization</title>
		<editor>R. Crawfis and Ch. Hansen</editor>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Footprint Evaluation for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="367" to="376" />
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multi-dimensional trees for controlled volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1994 Symposium on Volume Visualization</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="27" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Hierarchical and parallelizable direct volume rendering for irregular and multiple grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tarantino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="57" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Visibility ordering meshed polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="102" to="126" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Hardware assisted volume rendering of unstructured grids by incremental slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shareef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Volume Visualization</title>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="55" to="63" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
