<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Collision Detection for Volumetric Objects</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taosong</forename><surname>He</surname></persName>
							<email>taosong@research.bell-labs.com</email>
							<affiliation key="aff0">
								<orgName type="department">Software Production Research Department * Center for Visual Computing Bell Laboratories and Computer Science Department</orgName>
								<orgName type="institution">University of New York at Stony Brook Naperville</orgName>
								<address>
									<addrLine>1000 E. Warrenville Road State</addrLine>
									<postCode>1U-328, 60566, 11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>IL, NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Software Production Research Department * Center for Visual Computing Bell Laboratories and Computer Science Department</orgName>
								<orgName type="institution">University of New York at Stony Brook Naperville</orgName>
								<address>
									<addrLine>1000 E. Warrenville Road State</addrLine>
									<postCode>1U-328, 60566, 11794-4400</postCode>
									<settlement>Stony Brook</settlement>
									<region>IL, NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Collision Detection for Volumetric Objects</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism -Virtual reality</term>
					<term>I.4.10 [Image Processing], Image Representation -Hierarchical, Volumetric</term>
					<term>G.1.6 [Mathematics of Computing] Optimization -Constrained optimization</term>
					<term>F.1.2 [Theory of Computation] Modes of Computation -Probabilistic computation volume visualization, volume rendering, virtual reality, volume graphics, volumetric collision, collision probability, surface crossing probability, distance map, octree, sphere tree</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We propose a probability model for the handling of complicated interactions between volumetric objects. In our model each volume is associated with a &quot;probability map&quot; that assigns a &quot;surface crossing&quot; probability to each space point according to local volume properties. The interaction between two volumes is then described by finding the intersecting regions between the volumes, and calculating the &quot;collision probabilities&quot; at each intersecting point from the surface crossing probabilities. To enable fast and efficient calculations, we introduce the concept of a distance map and develop two hierarchical collision detection algorithms, taking advantage of the uniform structure of volumetric datasets.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Collision detection is a fundamental problem in 3D interactive applications such as computer animation and virtual reality. It has been extensively studied from different perspectives such as computational geometry, geometric modeling, and collision free path planning. Most of the previous work on this problem focuses on the interaction between surface-based objects, which are represented by primitives such as polygon meshes, polyhedra, splines, or algebraic surfaces <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b2">3]</ref>. On the other hand, with the advent of volume visualization and volume graphics, volumetric objects are becoming essential to and important for many applications. Compared to surface primitives, volume representation presents advantages in several aspects. First, it is a natural representation for the modeling of sampled datasets, such as those in 3D medical imaging; simulated datasets, such as those in computational fluid dynamics; and amorphous datasets, such as fog, clouds, and smoke. Second, it can also be used to model synthetic geometric objects commonly used in graphics applications <ref type="bibr" target="#b13">[13]</ref>. Third, it can be applied to visualize and manipulate the heterogeneous inner structures of the datasets − an important feature required by such applications as virtual surgery. Finally, a volumetric object is associated with a uniform regular volume raster.</p><p>Despite potentially wide applications, there has been little research on the collision detection for volumetric objects. As far as we know, Gibson proposed the first algorithm for detecting collisions between volumetric objects <ref type="bibr" target="#b4">[5]</ref>. In her algorithm, an occupancy map is first constructed with the dimensions of the whole virtual environment. Each element of the map contains either a null pointer or an address of an object voxel. A collision is considered detected when a voxel address from one object is written into a map cell that has already been occupied by the voxel address of another object. This approach could consume a vast amount of memory for storing the environment empty space in the occupancy map. It is also slow due to the requirement of shifting each voxel of an object into the appropriate location in the map.</p><p>Collision detection between volumetric objects is different from that between surface-based objects and it is an interesting problem, since explicit surfaces are rare in volumetric objects. This is because of the discrete representation of the volume raster. Since the usual definition of collision is only valid for solid objects with well-defined surfaces, the concept of collision between volumetric objects needs to be redefined. From another point of the view, howev er, a volume representation contains more information about the object, such as its inner structures. Therefore, a more detailed description of the interaction between the objects can be provided. In this paper, we propose a probability model for this description, and a hierarchical structure for the detection of the collisions between volumetric objects. We first present in Section 2 the probability model. Then, in Section 3, we discuss an efficient hierarchical collision detection algorithm. We propose the application of a distance map to accelerate the algorithm, and compare the effectiveness of different tree structures. Finally, the testing results of our algorithm are summarized in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Collision between Volumetric Objects</head><p>Although the underlying physical object is usually continuous, a volumetric object is a discrete representation of a predominately heterogeneous object. Theoretically there are no well-defined surfaces in the datasets because of the bandlimits of the discrete representation, and the accuracy of any interaction description is ultimately decided by the volume resolution. Thus, inherently the interaction between volumetric objects is not a binary process that only reports colliding or not colliding. Instead, it can be described as a non-deterministic process, where a probability of collision is given at each space point to indicate the interaction property between different materials of the objects. Although for convenience, we will henceforth borrow the terms "collision" and "collision detection" from surface-based applications to describe the volume interaction, we are more interested in studying the different interaction properties in the intersection regions than finding the time and position of the initial contact, as usually implied by these words. Such a difference between the surface and volume collision concept is illustrated in <ref type="figure" target="#fig_4">Figure 1</ref>. For the left side of <ref type="figure" target="#fig_4">Figure 1</ref>, a surface-based approach can be applied to report whether, when, and where the ball hits the table. For the right side of <ref type="figure" target="#fig_4">Figure 1</ref>, however, it is impossible to calculate the exact contact between the CT-head and the radiation beam due to the finite resolution of the head dataset. However, a volumetric collision model can be used to report the properties of the materials the beam is currently intersecting, such as bone, soft tissue, or a mixture of the two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Probability model</head><p>To describe the volumetric collision, a probability model is proposed. In this model, each continuous point inside a volume is assigned a value in the range [0, 1]. Conceptually, this value can be seen as the probability that there exists a surface crossing that point. Note that the surface here does not need to have any specific geometry and physical meaning. Instead, it is an abstract concept describing all the object properties the user is interested in, and the surface crossing probability is the value associated with the voxel, such as the density, the stiffness, or the attraction/repulsion coefficient. After the construction of such a probability model for each object, the probability that two objects collide at a certain point can then be defined as the probability that the surfaces in the two objects intersect at that point. From probability theory, this collision probability should be calculated as the multiplication of the surface crossing probabilities of the two objects at the point. On the other hand, since the surface crossing probability can be the abstraction of any object property, other collision probability calculation methods such as addition are also possible. The essence of this probability model is to allow the user to specify one map from the object properties to the surface crossing probability, and another map from the surface crossing probabilities of different objects to the collision probability.</p><p>Avila and Sobierajski <ref type="bibr" target="#b1">[2]</ref> recently proposed a haptic interaction model for volume visualization. They also use a map to generate the haptic force feedback from the local volume properties such as density and gradient. While they focus on the interaction between a point-based virtual device and a volumetric object and the fast rendering, we propose a general model to handle the interaction between two volumetric objects and develop an efficient algorithm for the calculation of the interaction properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Probability map</head><p>A probability map is a function assigning the probability to each space point according to some object properties. Different maps generate different probability models, and the selection of an appropriate map is closely related to the specific application. The inclusion of such a user-defined probability map provides great flexibility and potential to deal with very different scenarios.</p><p>On the other hand, there are some general maps whose underlying interpretations nicely fit the concept of probability based collision model. For example, borrowing from the volume rendering literature <ref type="bibr" target="#b9">[9]</ref>, properties of a volumetric object at a certain point x can be described by simulating with particles the participating medium at x. Assume that the probability that there exists a particle at x is ρ 1 for the first object and ρ 2 for the second object, then the probability that the two particles collide at x is ρ 1 ρ 2 . For volume rendering, such ρ 1 and ρ 2 are usually represented by the opacities. Therefore, one possible map is to directly assign the opacity to the surface crossing probability.</p><p>Another interesting map for geometric objects is generated by the volume sampled modeling technique <ref type="bibr" target="#b13">[13]</ref>. In an interactive application dealing with volumetric objects, geometric objects are first scan-converted (voxelized) into volume representations. A volume sampling approach appropriately samples and low-pass filters a geometric object into an alias-free volume object. Unfortunately, the well-defined continuous surface is lost in the process because of the discrete representation. Instead, the object can be described as a density function d(x) over R <ref type="bibr" target="#b2">3</ref> , where d = 1 inside the geometry object, d = 0 outside the object, and 0 &lt; d &lt; 1 within the fuzzy region of the object surface. Depending on the filters applied during the voxelization, these densities can be transformed to approximate the distance between a point and the real surface. The probability map that is accordingly established on d(x) can therefore be used to provide a fast estimation of the distance between objects during animation. For example, if we calculate the collision probability at any intersecting point by appropriately adding the surface crossing probabilities of the two volumes (taking into consideration the possible different scales of the volumes) the maximum collision probability approximates the closest distance between the objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Hierarchical Collision Detection</head><p>Having constructed the non-deterministic probability models, the next step is to efficiently evaluate the collision probability between the objects. Basically, all the collision probabilities inside the continuous intersection space between two volume rasters need to be estimated. Then, depending on the application, results such as maximum collision probability or the collision probabilities within a certain region need to be reported. To achieve this, one approach is to represent the entire 3D environment by a single volume raster, as proposed by Gibson <ref type="bibr" target="#b4">[5]</ref>. However, this method suffers from both the inefficiencies in storage requirements and from the inflexibility of interaction. Instead, we employ the multiple volume approach. Each object is individually modeled by its own volume, which contains a local coordinate system that defines the position, orientation, and unit in reference to a standard world coordinate system. One of the major advantages is that a simple transformation (such as translation, rotation, and scaling) can be independently performed on each object simply by changing its transformation matrix.</p><p>A naive approach for collision detection using multiple volumes checks the intersection between each voxel of a volume and all the other objects. It can be achieved by transforming the coordinates of the voxel into the coordinates of other volumes. It takes O(N 3 ) time, assuming the volume resolutions are of O(N 3 ). However, the resolution of the volume could be very large, which significantly increases the collision detection time. For example, a volume at 256 3 resolution contains 16 million voxels, which is far more than the usual number of surface primitives dealt with by the surface-based applications.</p><p>In surface-based applications, hierarchical data structures have been widely used to accelerate collision detection <ref type="bibr" target="#b10">[10]</ref>. The essence of hierarchical collision detection is to construct a tree of bounding volumes to tightly enclose the original object. Then, starting from the highest level of the tree, a recursive algorithm is applied to detect collision. It only descends to a lower level when an intersection is detected between the bounding volumes at the current level. Thus, significant computation time could be saved by avoiding intersection detection in regions that cannot possibly collide. Below we discuss the hierarchical collision detection algorithms for volumetric objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Hierarchical structures</head><p>A good tree structure for fast collision detection should satisfy the following often conflicting criteria:</p><p>• The bounding volumes at each level should fit the original object as tightly as possible to avoid overlap checking between empty spaces • The overlap checking between nodes of the tree should be as fast as possible • The tree should be easily and efficiently constructed Typical bounding volumes include axis-aligned bounding boxes (AABB), oriented bounding boxes (OBB), and spheres. Each has its limitations: for AABBs and spheres, very efficient algorithms exist for the overlap checking, but these bounding volumes can not tightly fit some surface primitives like long-thin and arbitrary-oriented polygons. OBBs can snugly fit all kinds of primitives, but the overlap checking between them is slow. A tree composed of spheres or OBBs can be constructed once in a preprocessing stage, while a tree based on AABBs needs to be adjusted or reconstructed dynamically. The typical tree structures used for the surface-based collision detections include k-d trees, octree, sphere-tree, BSP trees, space-time trees and many more. A comprehensive survey on the interference detection data structures has been presented in <ref type="bibr" target="#b6">[6]</ref>.</p><p>For a volumetric object, the spatial presortedness of the volume raster lends itself naturally to a hierarchical structure. Because of the lack of explicit surfaces, the basic primitive is the rectilinear voxel. Therefore, the tightest bounding volumes are the OBBs, and the most direct tree structure is the octree. The disadvantage of an octree is that overlap checking between the octants could be expensive. On the other hand, a sphere tree <ref type="bibr" target="#b7">[7]</ref> for volumetric objects is similar to the octree, but, instead of using cuboids, the circumspheres that tightly enclose boxes are used as octants. The advantages of a sphere tree is that overlap checking is accelerated. The disadvantage is that the spheres are not the tightest bounds of the voxels, therefore the efficiency of rejecting the test between non-intersecting regions is lowered. Below we present our methods of constructing both the octree and the sphere tree, and compare their effectiveness for volumetric collision detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Tr ee construction</head><p>Our tree construction algorithm is a two stage process. The first stage is a bottom-up pass starting from the leaf level. For the octree, the leaves are the rectilinear voxels, and a simple recursive algorithm is then applied to build the tree.</p><p>For the sphere tree, the leaves can be simply defined as the circumsphere of the voxels, where the circumcenters are located at the voxel centers. To avoid the possible large empty space at the leaves, an alternative approach is adopted in our implementation. We first assume that the length, width, and height of each voxel are l, w, and h, respectively. The whole volume space is then resubdivided into another raster with the new voxel size as min(l, w, h). The radii of the leaf spheres are then defined as √ 2/2 min(l, w, h), while the sphere centers are located at the centers of the new voxels. In other words, circumspheres of the new cubic voxels are used as the basic units. To build up the nodes one level higher in the sphere tree, we simply cluster the cubes contained by every eight neighboring leaf nodes, and construct the circumsphere of a node with twice the radius. This process is recursively performed up to the root of the tree. The disadvantage of this approach is that it could increase the size of the tree, in contrast to the result of directly using the circumspheres of the rectilinear voxels as tree nodes.</p><p>Each node S in the tree is associated with an index range [S ρ min , S ρ max ], which are the minimum and the maximum surface collision probabilities of all the continuous points inside its inscribed rectilinear or cube. This is similar to the idea of the min-max tree used for fast isocontouring <ref type="bibr" target="#b14">[14]</ref>. Note that for the sphere tree, although the nodes at the same level may overlap, the spaces covered by them are disjointed. This is to make sure that a node covers all its descendents.</p><p>The second stage of our approach is to prune the empty and solid nodes of the tree in a top-down fashion. First, the user specifies a solid threshold τ max , and an empty threshold τ min . All the points with surface crossing probability above τ max are considered to be totally solid, and those with probability below τ min are considered to be empty. Generally, increasing the empty threshold or decreasing the solid threshold reduces the complexity of the tree, and thus speeds up the collision detection. An interesting extreme is to assign both the solid and empty threshold to an isosurface value. To prune a tree T , we start from the root and follow the breadth-first search order. Assume that the current node is S, • If S ρ max &lt;τ min , delete both S and all the descendants of S.</p><p>• If S ρ min &gt;τ max , delete all the descendants of S. After the pruning, we further simplify T top-down by • For a direct child S 1 of S, if S 1 only has one child S 2 , delete S 1 , making S 2 to be the direct child of S. <ref type="figure" target="#fig_1">Figure 2</ref> illustrates a 2D example of the sphere tree construction. The pruning effect can be seen in all levels. Note that for the root, instead of using the circumsphere of the whole volume, a tight bounding box is adopted to avoid the possible large empty space.</p><p>The index range for a leaf node can be derived from the underlying probability model. Assuming that for a node S the probability function is Ρ and the inscribed cuboid space is R <ref type="bibr" target="#b2">3</ref> c , then S ρ min = min(Ρ(x)), and</p><formula xml:id="formula_0">S ρ max = max(Ρ(x)), x ∈R 3</formula><p>c . For simple Ρ, these can be analytically derived. Otherwise, a conservative estimate is applied. Such estimation is valid since the purpose of the hierarchical structure is to avoid the collision evaluation in the non-penetratable areas. The final accurate collision detection based on the probability model in the interpenetrating space is discussed in Section 3.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Distance map</head><p>Having created the hierarchical model for each object, the time for collision detection is partially decided by the number of overlap checkings between the tree nodes. A distance map is constructed for each object to reduce this number. The dimension and the resolution of the distance  map is the same as the original volume, and each voxel stores the Euclidean distance to the nearest non-solid voxel. A 2D example of such a distance map is presented in <ref type="figure" target="#fig_3">Figure 3</ref>. Note that in <ref type="figure" target="#fig_3">Figure 3</ref> the Euclidean distance saved for each voxel is conservatively evaluated. It is defined to be the shortest distance between any point inside the voxel to the nearest point inside a voxel with τ min ≤ ρ ≤ τ max . The computation of the Euclidean distance is based on the fast algorithm proposed by Saito and Toriwaki <ref type="bibr" target="#b12">[12]</ref>.</p><p>The reason that a distance map can usually accelerate the collision detection process is that both the sphere tree and the octree impose an artificial subdivision of the volume space. Such a subdivision does not account for the data coherence, especially on the border between neighboring nodes. The distance map alleviates this problem by avoiding the time consuming tree traversal and overlap checking when the node of an object falls into a totally solid or empty space of another object. In other words, during the recursive collision detection process, before we split a node on the tree of the first object and descend to a lower level, we check the distance value of the node center from the distance map of the second object. If this value is greater than the radius of the node, the node falls into a homogeneous area and the tree traversal can usually be stopped. A distance map is independently created for each object in preprocessing, and is not changed during transformation. On the other hand, storing a map increases the memory requirement of the algorithm, which could become a bottleneck of the algorithm when the volumes are of high resolutions. One compromise is to use a distance map with lower resolution than that of the original volume.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Octree vs. sphere tree</head><p>The selection between an octree and a sphere tree is essentially decided by the tradeoff between the efficiency of overlap checking and the tightness of the bounding volumes. An octree for a volumetric object is a special case of an OBB tree, and the best overlap checking algorithm between two OBBs has been recently proposed by Gottschalk et al. <ref type="bibr" target="#b6">[6]</ref>. The idea is to apply a separating axis theorem which states that two convex polytopes are disjoint iff there exists a separating axis orthogonal to a face of either polytop, or orthogonal to an edge from each polytop. A line is a separating axis iff the projected interval of the two polytops on the line do not intersect. There are 15 possible separating axes to test for the overlap between two OBBs. The whole computation has been simplified to at most 200 operations, which is significantly faster than the previous algorithms.</p><p>Nonetheless, an octree for a volumetric object has two attractive properties that normal OBB trees do not have. First, all the boxes in a tree are of the same orientation since the volume is represented by a regular gird. Second, there are only a small number of possible node sizes for a volume tree. That is, for a volume with resolution from 2 N −1 to 2 N − 1 along a main axis, the number of possible node size along the axis is N . These properties can be used to further accelerate the overlap checking between two octants. To illustrate this, we follow the algorithm of <ref type="bibr" target="#b6">[6]</ref>. Assume that we are given two OBBs, A and B, with B placed relative to A by rotation R and translation T. The half-dimension of A and B are a i and b i , where i = 1, 2, 3. If we denote the axes of A and B as the unit vectors A i and B i , for i = 1, 2, 3, the possible 15 separating axes L are A i , B i , and A i × B j , for i = 1, 2, 3 and j = 1, 2, 3. The disjoint tests are: Given the octrees for two volumetric objects, R is a constant matrix for all the octants. Since half dimensions of the octants are of small number, we can precalculate the right term of the inequality, and reduce the number of operations to two multiplications, 1 absolute value, 1 subtraction, and 1 compare. By simplifying all the 15 equalities in the same fashion, the total required operations are reduced to 15 absolute values, 15 additions and subtractions, 27 multiplications, and 15 compares. That is, the worst number of operations is 72, only 36% of the original version.</p><formula xml:id="formula_1">| T • L | &gt; Σ i | a i A i • L | + Σ i | b i B i •L |.</formula><p>We can simplify the overlap checking between the sphere tree in the same fashion. Assume that we are given two spheres, A and B, with their centers at A x,y,z and B x,y,z , and their radius as A r and B r , the overlap checking inequality is:</p><formula xml:id="formula_2">( A x − B x ) 2 + ( A y − B y ) 2 + ( A y − B y ) 2 &gt; (A r + B r ) 2.</formula><p>The right term of the inequality can also be precalculated. So, the required operations are 9 additions and subtractions, 3 multiplications, and 1 compare, with a total number of 13. Assume that the average number of operations for the overlap checking between OBBs is half of that for the worst case. This suggests that the overlap checking between spheres is by average 3 times as fast as that between OBBs.</p><p>Another interesting property of a volumetric object is that since a voxel is the smallest primitive in our collision model, the tightness of a bounding volume can be easily defined. Assume that the length, width, and height of a voxel is l, w, and h, respectively, we can define the tightness of the corresponding OBB to be 1.0, and that of the corresponding sphere node to be,</p><formula xml:id="formula_3">lwh 4 3 π ( √   (l 2 + w 2 + h 2) 2 ) 3 .</formula><p>The maximum of the sphere node tightness is 0.37, achieved when l = w = h. Since we know that by average the speed of overlap checking between spheres is three times as fast as that between OBBs, it means that an octree approach is as fast as a sphere tree approach when the voxel is cubic. When the differences among voxel dimensions become larger and larger, the performance of an octree does not change, while that of a sphere tree decreases quickly, even with our alternative approach of resubdividing the volume with cubic voxels. This suggests that the octree structure is the right choice for the hierarchical volumetric collision detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Probability evaluation</head><p>After a possible collision has been detected at the leaf level of the trees, efficient procedures must be called to calculate the collision probability. Howev er, depending on the probability maps applied to the objects and the formula to calculate the collision probability, the accurate result evaluation can be both difficult and slow. We address this issue by using the example of calculating the maximum collision probability between two leaf voxels v 1 and v 2 .</p><p>Formally, assume that the probability function for v 1 is P 1 , and that for v 2 is P 2 . The maximum collision probability is therefore decided by both P 1 and P 2 , and the accuracy that can be achieved is decided by the volume resolutions. When a simple probability map is used, P 1 and P 2 can sometimes be approximated analytically. For example, a possible probability map is to directly assign the density function d to the surface crossing probability ρ. Since d is only defined on the grid points, the widely applied trilinear interpolation function can then be used to reconstruct the continuous density function. The trilinear interpolation is,</p><formula xml:id="formula_4">d(x, y, z) = Σ 1 i=0 Σ 1 j=0 Σ 1 k=0 C i, j,k x i y j z k , 0 ≤ x, y, z ≤ 1.</formula><p>where C i, j,k are the coefficients decided by the densities at the eight neighboring grids, and x, y, z are the offsets along three main axes of the voxel. If the collision probability formula is also a polynomial, the maximum probability evaluation is reduced to find the maximum value of a polynomial function in the intersection region Γ = v 1 ∩v 2 . Robust and accurate numerical methods such as the Lagrange method of multipliers combined with numerical root finding can be used to solve this problem. Unfortunately, these methods are usually very time consuming. Furthermore, since the probability maps generally can not be easily approximated by a continuous and closed formed polynomial, it might be difficult to apply these numerical methods. As an alternative, methods requiring only function evaluation and no derivatives or continuous representations can be used. Press et. al. have provided a comprehensive survey of such methods <ref type="bibr" target="#b11">[11]</ref>. For example, the downhill simplex method in <ref type="bibr" target="#b11">[11]</ref> solves the maximization of the multiplication of two tri-linear interpolation functions in 0. 01 − 0. 07 sec on a Sun SPARC IPC.</p><p>Yet, such speed is still not enough for interactive or real time application, since tens or hundreds of collision probability evaluations are needed between complicated objects. To alleviate this problem, we have designed an approximation method. Generally, ρ max is calculated as max(P 1 (x i )P 2 (x i )), i = 1, . . . , k, x i ∈Γ. In other words, we sample the intersection space Γ with k sampling points, and compute the maximum (minimum) collision probability at these k points. The accuracy of this method is largely decided by the size of Γ and the number of the sampling points. The advantage of this discrete probability evaluation approach is that it provides a progressive refined solution to the problem. That is, when longer time is allowed for the collision detection in the application, more sampling points can be used to progressively increase the accuracy of the evaluation. On the other hand, when very quick detection is required, conservative estimate S ρ max associated with v 1 and v 2 can be directly used even without sampling Γ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation and Results</head><p>We hav e implemented the proposed collision probability model and the collision detection algorithm with both the octree based and the sphere tree. The data structures are similar. The whole tree is saved as a list of nodes. Each node S consists of a pair of floating points [S ρ min , S ρ max ] indicating the surface cross probability ranges, an integer indicating the offset of the first child in the list, an unsigned char indicating the configurations of all the children, and an unsigned char map flag controlling the distance map checking. The total length of a node is therefore 14 bytes. The map flag of each node is set in such a way during the process that distance map checking is performed only once between a node and another object. It also guarantees that if S has been found fallen into a totally solid or empty region of another object, the recursive algorithm will not visit S again.</p><p>We hav e conducted several tests to demonstrate the applications of the probability collision model and the effectiveness of the hierarchical collision detection algorithms. The first two experiments have been performed on an SGI O2, equipped with a 174MHz IP32 processor and 128MB of main memory. The VolVis system has been used for the volume rendering <ref type="bibr" target="#b0">[1]</ref>.</p><p>The first experiment is to estimate the closest distance between two volume sampled springs. The resolutions of the springs are both 47 × 117 × 47, and the scalar densities of the voxels are between 0 and 255. Since a hyper-cone filter was applied during the voxelization of the spring volumes, the scalar density v at each point can be used to approximate the distance d from this point to the closest surface using a simple formula d = (v − 128)r/128, where r is the filter support. The probability model is therefore to assign the normalized d to the surface crossing possibility, and the addition of surface crossing possibilities at the intersecting point to the collision probability. The preprocessing time for the sphere tree is 1. 18 sec for tree construction, and 0. 52 sec for the distance map generation. For the octree, the tree construction time is reduced to 0. 63 sec since we don't need to resubdivide the volumes, and the distance map generation time is 0. 50 sec. The worst and average time for the evaluation of such collision probability are 22. 2 ms and 8. 4 ms, respectively, for the sphere tree; and 15. 4 ms and 5. 4 ms, respectively, for the octree. The statistics includes a speedup between 5% to 30% through the application of the distance map. <ref type="figure" target="#fig_6">Figure 4</ref> presents four snapshot frames from an interaction, where the approximately closest distances (collision probability) from left to right are 1. 5, 1. 0, 0. 5, and 0 voxels,. This experiment demonstrates the possible usage of our model to some traditionally surface-based applications, such as predicating the collision time between complex objects. The convetional threshold and isosurface methods would not be able to provide the continuous proximity estimations.</p><p>The second experiment is performed between a negative and a positive potential of a high potential iron protein. The simulated scenario here is to apply the probability model to the electron density clouds for the calculation of the maximum attraction between two molecules. The attraction coefficient (surface crossing probability) is calculated by multiplying a density transfer function with a gradient transfer function. Similar approaches have been used to calculate the opacity <ref type="bibr" target="#b8">[8]</ref> or haptic force <ref type="bibr" target="#b1">[2 ]</ref>. The collision probability is calculated by multiplying two attraction coefficients. Physically-based and more complex computational models can also be applied. The resolutions of the datasets are both 66 × 66 × 66. The preprocessing time for the sphere tree is 1. 3 sec for tree construction, and 0. 69 sec for the distance map generation. For the octree, the tree construction time is 0. 68 sec, and the distance map generation time is 0. 62 sec. The worst and average time for the probability evaluation are 13. 2 ms and 6. 1 ms, respectively, for the sphere tree; and 12. 4 ms and 6. 0 ms, respectively, for the octree. The statistics includes an average speedup of 19% through the application of the distance map. <ref type="figure" target="#fig_7">Figure 5</ref> presents four snapshot frames from an interaction, where the attraction force is 0.26 (top left), 0.44 (top right), 0.68 (bottom left), and 0.82 (bottom right). Note that in <ref type="figure" target="#fig_7">Figure  5</ref>, direct volume rendering is applied to generate the images, where the transfer function for the attraction forces are also applied to the opacity transfer functions. Different color transfer functions are used for the two datasets.</p><p>To further demonstrate the unique capability of our probability collision model for volumetric objects, we present in <ref type="figure" target="#fig_5">Figure 6</ref> the simulated interaction between a CT head and a radiation beam. This experiment has been conducted using a single SGI Challenge 196MHz IP27 processor with 1536 MB main memory. The resolution of the CT head is 258 × 258 × 111, and the scale along three main axes are 2. 064 × 1. 376 × 1. 376. The radiation beam is simulated with a volume sampled cylinder with resolution of 15 × 57 × 15. The probability map is specified so that bones of the head have high surface crossing possibilities, and the soft brain tissues in the head have low surface crossing possibilities. For the radiation beam, the highest possibilities are assigned to the center beam, which linearly decrease to the lowest possibilities on the edge. The output of the algorithm is all the regions whose collision probabilities, calculated by multiplying the surface crossing possibilities, are within a certain region. The preprocessing time of the CT head for the sphere tree is 33. 7 sec for tree construction, and 24. 6 sec for the distance map generation. For the octree, the tree construction time is 10. 8 sec, and the distance map generation time is 15. 2 sec. The collision detection time, up to 412 ms for the sphere tree and 252 ms for the octree, depends on the range of the output probabilities. Generally, the octree algorithm is two times faster than the sphere tree algorithm because of the different scales of the datasets. This model can be applied to provide the visual and haptic feedback during a virtual surgery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusions</head><p>In this paper we have dev eloped a probability model for the description of the collision between volumetric objects with no explicit surfaces. It takes advantage of one of the key features of volumetric representation, the capability of supporting complicated objects with heterogeneous inner structures. Hierarchical structures based on an octree and a sphere tree are applied to accelerate the collision detection.</p><p>We hav e demonstrated that the octree generally achieves better or equal performance compared to the sphere tree due to the uniform grids associated with volumetric objects. We hav e also proposed use of the distance map to further increase the algorithm speed. As demonstrated by the experiments, our approach provides a general and effective framework for dealing with the complicated but interesting interaction between volumetric objects. To further broaden the application area, we are currently investigating the possibilities of expanding our probability model and hierarchical structure into non-uniform volume rasters such as curvilinear and irregular grids.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>2D example of a sphere tree construction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Construction of the distance map.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Surface-based vs. volumetric collision</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Interaction between a CT head and a detection. simulated r adiation beam.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Collision between two volume-sampled springs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Collision betwee n a p ositive and a negative potential of a high potential iron protein.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Gottschalk et al. further simplified these tests. For example, when L = A 1 × B 2 , the test is | T 3 R 22 − T 2 R 32 | &gt; a 2 |R 32 | + a 3 |R 22 | + b 1 |R 13 | + b 3 |R 11 |.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work has been supported by the National Science Foundation under grants CCR-9205047 and MIP-9527694. The authors would like to thank Sarah Gibson at Mitsubishi Electric Research Laboratories for her helpful comments on a previous draft of the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">VolVis: A Diversified Volume Visualization System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Avila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Sobierajski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;94 Proceedings</title>
		<imprint>
			<date type="published" when="1994-10" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Haptic Interaction Method for Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Avila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Soberajski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization&apos;96 Proceedings</title>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="197" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Icollide: An Interactive and Exact Collision Detection System for Large-scale Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ponamgi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-04" />
			<biblScope unit="page" from="189" to="196" />
		</imprint>
	</monogr>
	<note>Symposium on Interactive 3D Graphics</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Solving the Collision Detection Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Garica-Alonso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Serrano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flaquer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="36" to="43" />
			<date type="published" when="1994-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Beyond Volume Rendering : Visualization, Haptic Exploration, and Physical Modeling of Voxel-Based Objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gibson</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Eurographics Workshop on Visualization in Scientific Computing</title>
		<imprint>
			<date type="published" when="1995-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">OBB-Tree: A Hierarchical Structure for Rapid Interference Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gottschalk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGGRAPH 96</title>
		<meeting>ACM SIGGRAPH 96</meeting>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Approximating Polyhedra with Spheres for Time-Critical Collision Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Hubbard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transacations on Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1996-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optical Models for Direct Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="99" to="108" />
			<date type="published" when="1995-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Collision Detection and Response for Computer Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;88 Proceedings)</title>
		<imprint>
			<date type="published" when="1988-08" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="289" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Press</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teukolsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Vetterling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Flannery</surname></persName>
		</author>
		<title level="m">Numerical Recipes in C, The Art of Scientific Computing, Second Edition</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">New Algorithms for Euclidean Distance Transformation of an n-Dimensional Digitized Picture with Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Toriwaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1551" to="1565" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Volume-Sampled 3D Modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="26" to="32" />
			<date type="published" when="1994-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Octree for Faster Isosurface Generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="57" to="62" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
